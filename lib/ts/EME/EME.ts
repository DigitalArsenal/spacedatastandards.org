// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';



/**
 * Encrypted Message Envelope
 */
export class EME implements flatbuffers.IUnpackableObject<EMET> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):EME {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsEME(bb:flatbuffers.ByteBuffer, obj?:EME):EME {
  return (obj || new EME()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsEME(bb:flatbuffers.ByteBuffer, obj?:EME):EME {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new EME()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$EME');
}

/**
 * Encrypted data blob, containing the ciphertext of the original plaintext message.
 */
ENCRYPTED_BLOB(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

encryptedBlobLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

encryptedBlobArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Temporary public key used for the encryption session, contributing to the derivation of the shared secret.
 */
EPHEMERAL_PUBLIC_KEY():string|null
EPHEMERAL_PUBLIC_KEY(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
EPHEMERAL_PUBLIC_KEY(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Message Authentication Code to verify the integrity and authenticity of the encrypted message.
 */
MAC():string|null
MAC(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
MAC(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique value used to ensure that the same plaintext produces a different ciphertext for each encryption.
 */
NONCE():string|null
NONCE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
NONCE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Additional authentication tag used in some encryption schemes for integrity and authenticity verification.
 */
TAG():string|null
TAG(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TAG(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Initialization vector used to introduce randomness in the encryption process, enhancing security.
 */
IV():string|null
IV(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
IV(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Identifier for the public key used, aiding in recipient key management and message decryption.
 */
PUBLIC_KEY_IDENTIFIER():string|null
PUBLIC_KEY_IDENTIFIER(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PUBLIC_KEY_IDENTIFIER(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Specifies the set of cryptographic algorithms used in the encryption process.
 */
CIPHER_SUITE():string|null
CIPHER_SUITE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CIPHER_SUITE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Parameters for the Key Derivation Function, guiding the process of deriving keys from the shared secret.
 */
KDF_PARAMETERS():string|null
KDF_PARAMETERS(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
KDF_PARAMETERS(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Parameters defining specific settings for the encryption algorithm, such as block size or operation mode.
 */
ENCRYPTION_ALGORITHM_PARAMETERS():string|null
ENCRYPTION_ALGORITHM_PARAMETERS(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ENCRYPTION_ALGORITHM_PARAMETERS(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startEME(builder:flatbuffers.Builder) {
  builder.startObject(10);
}

static addEncryptedBlob(builder:flatbuffers.Builder, ENCRYPTED_BLOBOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, ENCRYPTED_BLOBOffset, 0);
}

static createEncryptedBlobVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startEncryptedBlobVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addEphemeralPublicKey(builder:flatbuffers.Builder, EPHEMERAL_PUBLIC_KEYOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, EPHEMERAL_PUBLIC_KEYOffset, 0);
}

static addMac(builder:flatbuffers.Builder, MACOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, MACOffset, 0);
}

static addNonce(builder:flatbuffers.Builder, NONCEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, NONCEOffset, 0);
}

static addTag(builder:flatbuffers.Builder, TAGOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, TAGOffset, 0);
}

static addIv(builder:flatbuffers.Builder, IVOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, IVOffset, 0);
}

static addPublicKeyIdentifier(builder:flatbuffers.Builder, PUBLIC_KEY_IDENTIFIEROffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, PUBLIC_KEY_IDENTIFIEROffset, 0);
}

static addCipherSuite(builder:flatbuffers.Builder, CIPHER_SUITEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, CIPHER_SUITEOffset, 0);
}

static addKdfParameters(builder:flatbuffers.Builder, KDF_PARAMETERSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, KDF_PARAMETERSOffset, 0);
}

static addEncryptionAlgorithmParameters(builder:flatbuffers.Builder, ENCRYPTION_ALGORITHM_PARAMETERSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, ENCRYPTION_ALGORITHM_PARAMETERSOffset, 0);
}

static endEME(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishEMEBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EME');
}

static finishSizePrefixedEMEBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EME', true);
}

static createEME(builder:flatbuffers.Builder, ENCRYPTED_BLOBOffset:flatbuffers.Offset, EPHEMERAL_PUBLIC_KEYOffset:flatbuffers.Offset, MACOffset:flatbuffers.Offset, NONCEOffset:flatbuffers.Offset, TAGOffset:flatbuffers.Offset, IVOffset:flatbuffers.Offset, PUBLIC_KEY_IDENTIFIEROffset:flatbuffers.Offset, CIPHER_SUITEOffset:flatbuffers.Offset, KDF_PARAMETERSOffset:flatbuffers.Offset, ENCRYPTION_ALGORITHM_PARAMETERSOffset:flatbuffers.Offset):flatbuffers.Offset {
  EME.startEME(builder);
  EME.addEncryptedBlob(builder, ENCRYPTED_BLOBOffset);
  EME.addEphemeralPublicKey(builder, EPHEMERAL_PUBLIC_KEYOffset);
  EME.addMac(builder, MACOffset);
  EME.addNonce(builder, NONCEOffset);
  EME.addTag(builder, TAGOffset);
  EME.addIv(builder, IVOffset);
  EME.addPublicKeyIdentifier(builder, PUBLIC_KEY_IDENTIFIEROffset);
  EME.addCipherSuite(builder, CIPHER_SUITEOffset);
  EME.addKdfParameters(builder, KDF_PARAMETERSOffset);
  EME.addEncryptionAlgorithmParameters(builder, ENCRYPTION_ALGORITHM_PARAMETERSOffset);
  return EME.endEME(builder);
}

unpack(): EMET {
  return new EMET(
    this.bb!.createScalarList<number>(this.ENCRYPTED_BLOB.bind(this), this.encryptedBlobLength()),
    this.EPHEMERAL_PUBLIC_KEY(),
    this.MAC(),
    this.NONCE(),
    this.TAG(),
    this.IV(),
    this.PUBLIC_KEY_IDENTIFIER(),
    this.CIPHER_SUITE(),
    this.KDF_PARAMETERS(),
    this.ENCRYPTION_ALGORITHM_PARAMETERS()
  );
}


unpackTo(_o: EMET): void {
  _o.ENCRYPTED_BLOB = this.bb!.createScalarList<number>(this.ENCRYPTED_BLOB.bind(this), this.encryptedBlobLength());
  _o.EPHEMERAL_PUBLIC_KEY = this.EPHEMERAL_PUBLIC_KEY();
  _o.MAC = this.MAC();
  _o.NONCE = this.NONCE();
  _o.TAG = this.TAG();
  _o.IV = this.IV();
  _o.PUBLIC_KEY_IDENTIFIER = this.PUBLIC_KEY_IDENTIFIER();
  _o.CIPHER_SUITE = this.CIPHER_SUITE();
  _o.KDF_PARAMETERS = this.KDF_PARAMETERS();
  _o.ENCRYPTION_ALGORITHM_PARAMETERS = this.ENCRYPTION_ALGORITHM_PARAMETERS();
}
}

export class EMET implements flatbuffers.IGeneratedObject {
constructor(
  public ENCRYPTED_BLOB: (number)[] = [],
  public EPHEMERAL_PUBLIC_KEY: string|Uint8Array|null = null,
  public MAC: string|Uint8Array|null = null,
  public NONCE: string|Uint8Array|null = null,
  public TAG: string|Uint8Array|null = null,
  public IV: string|Uint8Array|null = null,
  public PUBLIC_KEY_IDENTIFIER: string|Uint8Array|null = null,
  public CIPHER_SUITE: string|Uint8Array|null = null,
  public KDF_PARAMETERS: string|Uint8Array|null = null,
  public ENCRYPTION_ALGORITHM_PARAMETERS: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const ENCRYPTED_BLOB = EME.createEncryptedBlobVector(builder, this.ENCRYPTED_BLOB);
  const EPHEMERAL_PUBLIC_KEY = (this.EPHEMERAL_PUBLIC_KEY !== null ? builder.createString(this.EPHEMERAL_PUBLIC_KEY!) : 0);
  const MAC = (this.MAC !== null ? builder.createString(this.MAC!) : 0);
  const NONCE = (this.NONCE !== null ? builder.createString(this.NONCE!) : 0);
  const TAG = (this.TAG !== null ? builder.createString(this.TAG!) : 0);
  const IV = (this.IV !== null ? builder.createString(this.IV!) : 0);
  const PUBLIC_KEY_IDENTIFIER = (this.PUBLIC_KEY_IDENTIFIER !== null ? builder.createString(this.PUBLIC_KEY_IDENTIFIER!) : 0);
  const CIPHER_SUITE = (this.CIPHER_SUITE !== null ? builder.createString(this.CIPHER_SUITE!) : 0);
  const KDF_PARAMETERS = (this.KDF_PARAMETERS !== null ? builder.createString(this.KDF_PARAMETERS!) : 0);
  const ENCRYPTION_ALGORITHM_PARAMETERS = (this.ENCRYPTION_ALGORITHM_PARAMETERS !== null ? builder.createString(this.ENCRYPTION_ALGORITHM_PARAMETERS!) : 0);

  return EME.createEME(builder,
    ENCRYPTED_BLOB,
    EPHEMERAL_PUBLIC_KEY,
    MAC,
    NONCE,
    TAG,
    IV,
    PUBLIC_KEY_IDENTIFIER,
    CIPHER_SUITE,
    KDF_PARAMETERS,
    ENCRYPTION_ALGORITHM_PARAMETERS
  );
}
}
