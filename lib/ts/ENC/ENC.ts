// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { KDF } from './KDF.js';
import { KeyExchange } from './KeyExchange.js';
import { SymmetricAlgo } from './SymmetricAlgo.js';


/**
 * Encryption Header containing all parameters needed for decryption
 */
export class ENC implements flatbuffers.IUnpackableObject<ENCT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ENC {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsENC(bb:flatbuffers.ByteBuffer, obj?:ENC):ENC {
  return (obj || new ENC()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsENC(bb:flatbuffers.ByteBuffer, obj?:ENC):ENC {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ENC()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$ENC');
}

/**
 * Schema version for forward compatibility
 */
VERSION():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 1;
}

/**
 * Key exchange algorithm used
 */
KEY_EXCHANGE():KeyExchange {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : KeyExchange.X25519;
}

/**
 * Symmetric encryption algorithm used
 */
SYMMETRIC():SymmetricAlgo {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : SymmetricAlgo.AES_256_CTR;
}

/**
 * Key derivation function used
 */
KEY_DERIVATION():KDF {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : KDF.HKDF_SHA256;
}

/**
 * Ephemeral public key for ECDH key agreement (32-65 bytes depending on algorithm)
 */
EPHEMERAL_PUBLIC_KEY(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

ephemeralPublicKeyLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

ephemeralPublicKeyArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
 */
NONCE_START(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

nonceStartLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

nonceStartArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Optional identifier for the recipient's public key (up to 32 bytes)
 */
RECIPIENT_KEY_ID(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

recipientKeyIdLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

recipientKeyIdArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Optional domain separation context string
 */
CONTEXT():string|null
CONTEXT(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CONTEXT(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional SHA-256 hash of the FlatBuffers schema (32 bytes)
 */
SCHEMA_HASH(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

schemaHashLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

schemaHashArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Optional root type name from the schema
 */
ROOT_TYPE():string|null
ROOT_TYPE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ROOT_TYPE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional Unix timestamp (milliseconds) when encryption was performed
 */
TIMESTAMP():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

static startENC(builder:flatbuffers.Builder) {
  builder.startObject(11);
}

static addVersion(builder:flatbuffers.Builder, VERSION:number) {
  builder.addFieldInt8(0, VERSION, 1);
}

static addKeyExchange(builder:flatbuffers.Builder, KEY_EXCHANGE:KeyExchange) {
  builder.addFieldInt8(1, KEY_EXCHANGE, KeyExchange.X25519);
}

static addSymmetric(builder:flatbuffers.Builder, SYMMETRIC:SymmetricAlgo) {
  builder.addFieldInt8(2, SYMMETRIC, SymmetricAlgo.AES_256_CTR);
}

static addKeyDerivation(builder:flatbuffers.Builder, KEY_DERIVATION:KDF) {
  builder.addFieldInt8(3, KEY_DERIVATION, KDF.HKDF_SHA256);
}

static addEphemeralPublicKey(builder:flatbuffers.Builder, EPHEMERAL_PUBLIC_KEYOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, EPHEMERAL_PUBLIC_KEYOffset, 0);
}

static createEphemeralPublicKeyVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startEphemeralPublicKeyVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addNonceStart(builder:flatbuffers.Builder, NONCE_STARTOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, NONCE_STARTOffset, 0);
}

static createNonceStartVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startNonceStartVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addRecipientKeyId(builder:flatbuffers.Builder, RECIPIENT_KEY_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, RECIPIENT_KEY_IDOffset, 0);
}

static createRecipientKeyIdVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startRecipientKeyIdVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addContext(builder:flatbuffers.Builder, CONTEXTOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, CONTEXTOffset, 0);
}

static addSchemaHash(builder:flatbuffers.Builder, SCHEMA_HASHOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, SCHEMA_HASHOffset, 0);
}

static createSchemaHashVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startSchemaHashVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addRootType(builder:flatbuffers.Builder, ROOT_TYPEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, ROOT_TYPEOffset, 0);
}

static addTimestamp(builder:flatbuffers.Builder, TIMESTAMP:bigint) {
  builder.addFieldInt64(10, TIMESTAMP, BigInt('0'));
}

static endENC(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 12) // EPHEMERAL_PUBLIC_KEY
  builder.requiredField(offset, 14) // NONCE_START
  return offset;
}

static finishENCBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$ENC');
}

static finishSizePrefixedENCBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$ENC', true);
}

static createENC(builder:flatbuffers.Builder, VERSION:number, KEY_EXCHANGE:KeyExchange, SYMMETRIC:SymmetricAlgo, KEY_DERIVATION:KDF, EPHEMERAL_PUBLIC_KEYOffset:flatbuffers.Offset, NONCE_STARTOffset:flatbuffers.Offset, RECIPIENT_KEY_IDOffset:flatbuffers.Offset, CONTEXTOffset:flatbuffers.Offset, SCHEMA_HASHOffset:flatbuffers.Offset, ROOT_TYPEOffset:flatbuffers.Offset, TIMESTAMP:bigint):flatbuffers.Offset {
  ENC.startENC(builder);
  ENC.addVersion(builder, VERSION);
  ENC.addKeyExchange(builder, KEY_EXCHANGE);
  ENC.addSymmetric(builder, SYMMETRIC);
  ENC.addKeyDerivation(builder, KEY_DERIVATION);
  ENC.addEphemeralPublicKey(builder, EPHEMERAL_PUBLIC_KEYOffset);
  ENC.addNonceStart(builder, NONCE_STARTOffset);
  ENC.addRecipientKeyId(builder, RECIPIENT_KEY_IDOffset);
  ENC.addContext(builder, CONTEXTOffset);
  ENC.addSchemaHash(builder, SCHEMA_HASHOffset);
  ENC.addRootType(builder, ROOT_TYPEOffset);
  ENC.addTimestamp(builder, TIMESTAMP);
  return ENC.endENC(builder);
}

unpack(): ENCT {
  return new ENCT(
    this.VERSION(),
    this.KEY_EXCHANGE(),
    this.SYMMETRIC(),
    this.KEY_DERIVATION(),
    this.bb!.createScalarList<number>(this.EPHEMERAL_PUBLIC_KEY.bind(this), this.ephemeralPublicKeyLength()),
    this.bb!.createScalarList<number>(this.NONCE_START.bind(this), this.nonceStartLength()),
    this.bb!.createScalarList<number>(this.RECIPIENT_KEY_ID.bind(this), this.recipientKeyIdLength()),
    this.CONTEXT(),
    this.bb!.createScalarList<number>(this.SCHEMA_HASH.bind(this), this.schemaHashLength()),
    this.ROOT_TYPE(),
    this.TIMESTAMP()
  );
}


unpackTo(_o: ENCT): void {
  _o.VERSION = this.VERSION();
  _o.KEY_EXCHANGE = this.KEY_EXCHANGE();
  _o.SYMMETRIC = this.SYMMETRIC();
  _o.KEY_DERIVATION = this.KEY_DERIVATION();
  _o.EPHEMERAL_PUBLIC_KEY = this.bb!.createScalarList<number>(this.EPHEMERAL_PUBLIC_KEY.bind(this), this.ephemeralPublicKeyLength());
  _o.NONCE_START = this.bb!.createScalarList<number>(this.NONCE_START.bind(this), this.nonceStartLength());
  _o.RECIPIENT_KEY_ID = this.bb!.createScalarList<number>(this.RECIPIENT_KEY_ID.bind(this), this.recipientKeyIdLength());
  _o.CONTEXT = this.CONTEXT();
  _o.SCHEMA_HASH = this.bb!.createScalarList<number>(this.SCHEMA_HASH.bind(this), this.schemaHashLength());
  _o.ROOT_TYPE = this.ROOT_TYPE();
  _o.TIMESTAMP = this.TIMESTAMP();
}
}

export class ENCT implements flatbuffers.IGeneratedObject {
constructor(
  public VERSION: number = 1,
  public KEY_EXCHANGE: KeyExchange = KeyExchange.X25519,
  public SYMMETRIC: SymmetricAlgo = SymmetricAlgo.AES_256_CTR,
  public KEY_DERIVATION: KDF = KDF.HKDF_SHA256,
  public EPHEMERAL_PUBLIC_KEY: (number)[] = [],
  public NONCE_START: (number)[] = [],
  public RECIPIENT_KEY_ID: (number)[] = [],
  public CONTEXT: string|Uint8Array|null = null,
  public SCHEMA_HASH: (number)[] = [],
  public ROOT_TYPE: string|Uint8Array|null = null,
  public TIMESTAMP: bigint = BigInt('0')
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const EPHEMERAL_PUBLIC_KEY = ENC.createEphemeralPublicKeyVector(builder, this.EPHEMERAL_PUBLIC_KEY);
  const NONCE_START = ENC.createNonceStartVector(builder, this.NONCE_START);
  const RECIPIENT_KEY_ID = ENC.createRecipientKeyIdVector(builder, this.RECIPIENT_KEY_ID);
  const CONTEXT = (this.CONTEXT !== null ? builder.createString(this.CONTEXT!) : 0);
  const SCHEMA_HASH = ENC.createSchemaHashVector(builder, this.SCHEMA_HASH);
  const ROOT_TYPE = (this.ROOT_TYPE !== null ? builder.createString(this.ROOT_TYPE!) : 0);

  return ENC.createENC(builder,
    this.VERSION,
    this.KEY_EXCHANGE,
    this.SYMMETRIC,
    this.KEY_DERIVATION,
    EPHEMERAL_PUBLIC_KEY,
    NONCE_START,
    RECIPIENT_KEY_ID,
    CONTEXT,
    SCHEMA_HASH,
    ROOT_TYPE,
    this.TIMESTAMP
  );
}
}
