// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { attitudeStateType } from './attitudeStateType.js';


/**
 * Attitude State Data
 */
export class attitudeState implements flatbuffers.IUnpackableObject<attitudeStateT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):attitudeState {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsattitudeState(bb:flatbuffers.ByteBuffer, obj?:attitudeState):attitudeState {
  return (obj || new attitudeState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsattitudeState(bb:flatbuffers.ByteBuffer, obj?:attitudeState):attitudeState {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new attitudeState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Attitude state type
 */
ATT_TYPE():attitudeStateType {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : attitudeStateType.QUATERNION;
}

/**
 * Reference frame A
 */
REF_FRAME_A():string|null
REF_FRAME_A(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
REF_FRAME_A(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Reference frame B
 */
REF_FRAME_B():string|null
REF_FRAME_B(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
REF_FRAME_B(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Attitude direction (A2B or B2A)
 */
ATT_DIR():string|null
ATT_DIR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ATT_DIR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Epoch (ISO 8601)
 */
EPOCH():string|null
EPOCH(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
EPOCH(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Quaternion scalar component (q0 or qc)
 */
Q1():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Quaternion vector component i
 */
Q2():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Quaternion vector component j
 */
Q3():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Quaternion vector component k
 */
QC():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Euler angle X in degrees
 */
ANGLE_1():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Euler angle Y in degrees
 */
ANGLE_2():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Euler angle Z in degrees
 */
ANGLE_3():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Euler rotation sequence (e.g., 321, 313)
 */
EULER_ROT_SEQ():string|null
EULER_ROT_SEQ(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
EULER_ROT_SEQ(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Angular velocity X in deg/s
 */
ANGVEL_X():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Angular velocity Y in deg/s
 */
ANGVEL_Y():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Angular velocity Z in deg/s
 */
ANGVEL_Z():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Spin alpha in degrees
 */
SPIN_ALPHA():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Spin delta in degrees
 */
SPIN_DELTA():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Spin angle in degrees
 */
SPIN_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Spin angle velocity in deg/s
 */
SPIN_ANGLE_VEL():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Nutation angle in degrees
 */
NUTATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Nutation period in seconds
 */
NUTATION_PERIOD():number {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Nutation phase in degrees
 */
NUTATION_PHASE():number {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

static startattitudeState(builder:flatbuffers.Builder) {
  builder.startObject(23);
}

static addAttType(builder:flatbuffers.Builder, ATT_TYPE:attitudeStateType) {
  builder.addFieldInt8(0, ATT_TYPE, attitudeStateType.QUATERNION);
}

static addRefFrameA(builder:flatbuffers.Builder, REF_FRAME_AOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, REF_FRAME_AOffset, 0);
}

static addRefFrameB(builder:flatbuffers.Builder, REF_FRAME_BOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, REF_FRAME_BOffset, 0);
}

static addAttDir(builder:flatbuffers.Builder, ATT_DIROffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, ATT_DIROffset, 0);
}

static addEpoch(builder:flatbuffers.Builder, EPOCHOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, EPOCHOffset, 0);
}

static addQ1(builder:flatbuffers.Builder, Q1:number) {
  builder.addFieldFloat64(5, Q1, 0.0);
}

static addQ2(builder:flatbuffers.Builder, Q2:number) {
  builder.addFieldFloat64(6, Q2, 0.0);
}

static addQ3(builder:flatbuffers.Builder, Q3:number) {
  builder.addFieldFloat64(7, Q3, 0.0);
}

static addQc(builder:flatbuffers.Builder, QC:number) {
  builder.addFieldFloat64(8, QC, 0.0);
}

static addAngle1(builder:flatbuffers.Builder, ANGLE_1:number) {
  builder.addFieldFloat64(9, ANGLE_1, 0.0);
}

static addAngle2(builder:flatbuffers.Builder, ANGLE_2:number) {
  builder.addFieldFloat64(10, ANGLE_2, 0.0);
}

static addAngle3(builder:flatbuffers.Builder, ANGLE_3:number) {
  builder.addFieldFloat64(11, ANGLE_3, 0.0);
}

static addEulerRotSeq(builder:flatbuffers.Builder, EULER_ROT_SEQOffset:flatbuffers.Offset) {
  builder.addFieldOffset(12, EULER_ROT_SEQOffset, 0);
}

static addAngvelX(builder:flatbuffers.Builder, ANGVEL_X:number) {
  builder.addFieldFloat64(13, ANGVEL_X, 0.0);
}

static addAngvelY(builder:flatbuffers.Builder, ANGVEL_Y:number) {
  builder.addFieldFloat64(14, ANGVEL_Y, 0.0);
}

static addAngvelZ(builder:flatbuffers.Builder, ANGVEL_Z:number) {
  builder.addFieldFloat64(15, ANGVEL_Z, 0.0);
}

static addSpinAlpha(builder:flatbuffers.Builder, SPIN_ALPHA:number) {
  builder.addFieldFloat64(16, SPIN_ALPHA, 0.0);
}

static addSpinDelta(builder:flatbuffers.Builder, SPIN_DELTA:number) {
  builder.addFieldFloat64(17, SPIN_DELTA, 0.0);
}

static addSpinAngle(builder:flatbuffers.Builder, SPIN_ANGLE:number) {
  builder.addFieldFloat64(18, SPIN_ANGLE, 0.0);
}

static addSpinAngleVel(builder:flatbuffers.Builder, SPIN_ANGLE_VEL:number) {
  builder.addFieldFloat64(19, SPIN_ANGLE_VEL, 0.0);
}

static addNutation(builder:flatbuffers.Builder, NUTATION:number) {
  builder.addFieldFloat64(20, NUTATION, 0.0);
}

static addNutationPeriod(builder:flatbuffers.Builder, NUTATION_PERIOD:number) {
  builder.addFieldFloat64(21, NUTATION_PERIOD, 0.0);
}

static addNutationPhase(builder:flatbuffers.Builder, NUTATION_PHASE:number) {
  builder.addFieldFloat64(22, NUTATION_PHASE, 0.0);
}

static endattitudeState(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createattitudeState(builder:flatbuffers.Builder, ATT_TYPE:attitudeStateType, REF_FRAME_AOffset:flatbuffers.Offset, REF_FRAME_BOffset:flatbuffers.Offset, ATT_DIROffset:flatbuffers.Offset, EPOCHOffset:flatbuffers.Offset, Q1:number, Q2:number, Q3:number, QC:number, ANGLE_1:number, ANGLE_2:number, ANGLE_3:number, EULER_ROT_SEQOffset:flatbuffers.Offset, ANGVEL_X:number, ANGVEL_Y:number, ANGVEL_Z:number, SPIN_ALPHA:number, SPIN_DELTA:number, SPIN_ANGLE:number, SPIN_ANGLE_VEL:number, NUTATION:number, NUTATION_PERIOD:number, NUTATION_PHASE:number):flatbuffers.Offset {
  attitudeState.startattitudeState(builder);
  attitudeState.addAttType(builder, ATT_TYPE);
  attitudeState.addRefFrameA(builder, REF_FRAME_AOffset);
  attitudeState.addRefFrameB(builder, REF_FRAME_BOffset);
  attitudeState.addAttDir(builder, ATT_DIROffset);
  attitudeState.addEpoch(builder, EPOCHOffset);
  attitudeState.addQ1(builder, Q1);
  attitudeState.addQ2(builder, Q2);
  attitudeState.addQ3(builder, Q3);
  attitudeState.addQc(builder, QC);
  attitudeState.addAngle1(builder, ANGLE_1);
  attitudeState.addAngle2(builder, ANGLE_2);
  attitudeState.addAngle3(builder, ANGLE_3);
  attitudeState.addEulerRotSeq(builder, EULER_ROT_SEQOffset);
  attitudeState.addAngvelX(builder, ANGVEL_X);
  attitudeState.addAngvelY(builder, ANGVEL_Y);
  attitudeState.addAngvelZ(builder, ANGVEL_Z);
  attitudeState.addSpinAlpha(builder, SPIN_ALPHA);
  attitudeState.addSpinDelta(builder, SPIN_DELTA);
  attitudeState.addSpinAngle(builder, SPIN_ANGLE);
  attitudeState.addSpinAngleVel(builder, SPIN_ANGLE_VEL);
  attitudeState.addNutation(builder, NUTATION);
  attitudeState.addNutationPeriod(builder, NUTATION_PERIOD);
  attitudeState.addNutationPhase(builder, NUTATION_PHASE);
  return attitudeState.endattitudeState(builder);
}

unpack(): attitudeStateT {
  return new attitudeStateT(
    this.ATT_TYPE(),
    this.REF_FRAME_A(),
    this.REF_FRAME_B(),
    this.ATT_DIR(),
    this.EPOCH(),
    this.Q1(),
    this.Q2(),
    this.Q3(),
    this.QC(),
    this.ANGLE_1(),
    this.ANGLE_2(),
    this.ANGLE_3(),
    this.EULER_ROT_SEQ(),
    this.ANGVEL_X(),
    this.ANGVEL_Y(),
    this.ANGVEL_Z(),
    this.SPIN_ALPHA(),
    this.SPIN_DELTA(),
    this.SPIN_ANGLE(),
    this.SPIN_ANGLE_VEL(),
    this.NUTATION(),
    this.NUTATION_PERIOD(),
    this.NUTATION_PHASE()
  );
}


unpackTo(_o: attitudeStateT): void {
  _o.ATT_TYPE = this.ATT_TYPE();
  _o.REF_FRAME_A = this.REF_FRAME_A();
  _o.REF_FRAME_B = this.REF_FRAME_B();
  _o.ATT_DIR = this.ATT_DIR();
  _o.EPOCH = this.EPOCH();
  _o.Q1 = this.Q1();
  _o.Q2 = this.Q2();
  _o.Q3 = this.Q3();
  _o.QC = this.QC();
  _o.ANGLE_1 = this.ANGLE_1();
  _o.ANGLE_2 = this.ANGLE_2();
  _o.ANGLE_3 = this.ANGLE_3();
  _o.EULER_ROT_SEQ = this.EULER_ROT_SEQ();
  _o.ANGVEL_X = this.ANGVEL_X();
  _o.ANGVEL_Y = this.ANGVEL_Y();
  _o.ANGVEL_Z = this.ANGVEL_Z();
  _o.SPIN_ALPHA = this.SPIN_ALPHA();
  _o.SPIN_DELTA = this.SPIN_DELTA();
  _o.SPIN_ANGLE = this.SPIN_ANGLE();
  _o.SPIN_ANGLE_VEL = this.SPIN_ANGLE_VEL();
  _o.NUTATION = this.NUTATION();
  _o.NUTATION_PERIOD = this.NUTATION_PERIOD();
  _o.NUTATION_PHASE = this.NUTATION_PHASE();
}
}

export class attitudeStateT implements flatbuffers.IGeneratedObject {
constructor(
  public ATT_TYPE: attitudeStateType = attitudeStateType.QUATERNION,
  public REF_FRAME_A: string|Uint8Array|null = null,
  public REF_FRAME_B: string|Uint8Array|null = null,
  public ATT_DIR: string|Uint8Array|null = null,
  public EPOCH: string|Uint8Array|null = null,
  public Q1: number = 0.0,
  public Q2: number = 0.0,
  public Q3: number = 0.0,
  public QC: number = 0.0,
  public ANGLE_1: number = 0.0,
  public ANGLE_2: number = 0.0,
  public ANGLE_3: number = 0.0,
  public EULER_ROT_SEQ: string|Uint8Array|null = null,
  public ANGVEL_X: number = 0.0,
  public ANGVEL_Y: number = 0.0,
  public ANGVEL_Z: number = 0.0,
  public SPIN_ALPHA: number = 0.0,
  public SPIN_DELTA: number = 0.0,
  public SPIN_ANGLE: number = 0.0,
  public SPIN_ANGLE_VEL: number = 0.0,
  public NUTATION: number = 0.0,
  public NUTATION_PERIOD: number = 0.0,
  public NUTATION_PHASE: number = 0.0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const REF_FRAME_A = (this.REF_FRAME_A !== null ? builder.createString(this.REF_FRAME_A!) : 0);
  const REF_FRAME_B = (this.REF_FRAME_B !== null ? builder.createString(this.REF_FRAME_B!) : 0);
  const ATT_DIR = (this.ATT_DIR !== null ? builder.createString(this.ATT_DIR!) : 0);
  const EPOCH = (this.EPOCH !== null ? builder.createString(this.EPOCH!) : 0);
  const EULER_ROT_SEQ = (this.EULER_ROT_SEQ !== null ? builder.createString(this.EULER_ROT_SEQ!) : 0);

  return attitudeState.createattitudeState(builder,
    this.ATT_TYPE,
    REF_FRAME_A,
    REF_FRAME_B,
    ATT_DIR,
    EPOCH,
    this.Q1,
    this.Q2,
    this.Q3,
    this.QC,
    this.ANGLE_1,
    this.ANGLE_2,
    this.ANGLE_3,
    EULER_ROT_SEQ,
    this.ANGVEL_X,
    this.ANGVEL_Y,
    this.ANGVEL_Z,
    this.SPIN_ALPHA,
    this.SPIN_DELTA,
    this.SPIN_ANGLE,
    this.SPIN_ANGLE_VEL,
    this.NUTATION,
    this.NUTATION_PERIOD,
    this.NUTATION_PHASE
  );
}
}
