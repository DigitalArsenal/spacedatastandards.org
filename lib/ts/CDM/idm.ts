// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Band, BandT } from './band.js';
import { DataMode } from './data-mode.js';
import { DeviceType } from './device-type.js';
import { FrequencyRange, FrequencyRangeT } from './frequency-range.js';
import { PolarizationType } from './polarization-type.js';
import { SimplePolarization } from './simple-polarization.js';
import { StokesParameters, StokesParametersT } from './stokes-parameters.js';


/**
 * Integrated Device Message
 */
export class IDM implements flatbuffers.IUnpackableObject<IDMT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):IDM {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsIDM(bb:flatbuffers.ByteBuffer, obj?:IDM):IDM {
  return (obj || new IDM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsIDM(bb:flatbuffers.ByteBuffer, obj?:IDM):IDM {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new IDM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$IDM');
}

/**
 * Unique identifier for the EMT
 */
id():string|null
id(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
id(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Name of the EMT
 */
name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Mode of the data (real, simulated, synthetic)
 */
dataMode():DataMode {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : DataMode.REAL;
}

/**
 * Uplink frequency range
 */
uplink(obj?:FrequencyRange):FrequencyRange|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new FrequencyRange()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Downlink frequency range
 */
downlink(obj?:FrequencyRange):FrequencyRange|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new FrequencyRange()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Beacon frequency range
 */
beacon(obj?:FrequencyRange):FrequencyRange|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? (obj || new FrequencyRange()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Bands associated with the EMT
 */
band(index: number, obj?:Band):Band|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? (obj || new Band()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

bandLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Type of polarization used
 */
polarizationType():PolarizationType {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : PolarizationType.linear;
}

/**
 * Simple polarization configuration
 */
simplePolarization():SimplePolarization {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : SimplePolarization.vertical;
}

/**
 * Stokes parameters for polarization characterization
 */
stokesParameters(obj?:StokesParameters):StokesParameters|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? (obj || new StokesParameters()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Power required in Watts
 */
powerRequired():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Type of power (eg. AC or DC)
 */
powerType():string|null
powerType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
powerType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicates if the EMT can transmit
 */
transmit():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Indicates if the EMT can receive
 */
receive():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Type of the sensor
 */
sensorType():DeviceType {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : DeviceType.UNKNOWN;
}

/**
 * Source of the data
 */
source():string|null
source(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
source(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Timestamp of the last observation
 */
lastObTime():string|null
lastObTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
lastObTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Lower left elevation limit
 */
lowerLeftElevationLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Upper left azimuth limit
 */
upperLeftAzimuthLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Lower right elevation limit
 */
lowerRightElevationLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Lower left azimuth limit
 */
lowerLeftAzimuthLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Upper right elevation limit
 */
upperRightElevationLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Upper right azimuth limit
 */
upperRightAzimuthLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Lower right azimuth limit
 */
lowerRightAzimuthLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Upper left elevation limit
 */
upperLeftElevationLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Right geostationary belt limit
 */
rightGeoBeltLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Left geostationary belt limit
 */
leftGeoBeltLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Magnitude limit of the sensor
 */
magnitudeLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Indicates if the site is taskable
 */
taskable():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

static startIDM(builder:flatbuffers.Builder) {
  builder.startObject(29);
}

static addId(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idOffset, 0);
}

static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, nameOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, dataMode:DataMode) {
  builder.addFieldInt8(2, dataMode, DataMode.REAL);
}

static addUplink(builder:flatbuffers.Builder, uplinkOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, uplinkOffset, 0);
}

static addDownlink(builder:flatbuffers.Builder, downlinkOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, downlinkOffset, 0);
}

static addBeacon(builder:flatbuffers.Builder, beaconOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, beaconOffset, 0);
}

static addBand(builder:flatbuffers.Builder, bandOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, bandOffset, 0);
}

static createBandVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startBandVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addPolarizationType(builder:flatbuffers.Builder, polarizationType:PolarizationType) {
  builder.addFieldInt8(7, polarizationType, PolarizationType.linear);
}

static addSimplePolarization(builder:flatbuffers.Builder, simplePolarization:SimplePolarization) {
  builder.addFieldInt8(8, simplePolarization, SimplePolarization.vertical);
}

static addStokesParameters(builder:flatbuffers.Builder, stokesParametersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, stokesParametersOffset, 0);
}

static addPowerRequired(builder:flatbuffers.Builder, powerRequired:number) {
  builder.addFieldFloat64(10, powerRequired, 0.0);
}

static addPowerType(builder:flatbuffers.Builder, powerTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, powerTypeOffset, 0);
}

static addTransmit(builder:flatbuffers.Builder, transmit:boolean) {
  builder.addFieldInt8(12, +transmit, +false);
}

static addReceive(builder:flatbuffers.Builder, receive:boolean) {
  builder.addFieldInt8(13, +receive, +false);
}

static addSensorType(builder:flatbuffers.Builder, sensorType:DeviceType) {
  builder.addFieldInt8(14, sensorType, DeviceType.UNKNOWN);
}

static addSource(builder:flatbuffers.Builder, sourceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, sourceOffset, 0);
}

static addLastObTime(builder:flatbuffers.Builder, lastObTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, lastObTimeOffset, 0);
}

static addLowerLeftElevationLimit(builder:flatbuffers.Builder, lowerLeftElevationLimit:number) {
  builder.addFieldFloat64(17, lowerLeftElevationLimit, 0.0);
}

static addUpperLeftAzimuthLimit(builder:flatbuffers.Builder, upperLeftAzimuthLimit:number) {
  builder.addFieldFloat64(18, upperLeftAzimuthLimit, 0.0);
}

static addLowerRightElevationLimit(builder:flatbuffers.Builder, lowerRightElevationLimit:number) {
  builder.addFieldFloat64(19, lowerRightElevationLimit, 0.0);
}

static addLowerLeftAzimuthLimit(builder:flatbuffers.Builder, lowerLeftAzimuthLimit:number) {
  builder.addFieldFloat64(20, lowerLeftAzimuthLimit, 0.0);
}

static addUpperRightElevationLimit(builder:flatbuffers.Builder, upperRightElevationLimit:number) {
  builder.addFieldFloat64(21, upperRightElevationLimit, 0.0);
}

static addUpperRightAzimuthLimit(builder:flatbuffers.Builder, upperRightAzimuthLimit:number) {
  builder.addFieldFloat64(22, upperRightAzimuthLimit, 0.0);
}

static addLowerRightAzimuthLimit(builder:flatbuffers.Builder, lowerRightAzimuthLimit:number) {
  builder.addFieldFloat64(23, lowerRightAzimuthLimit, 0.0);
}

static addUpperLeftElevationLimit(builder:flatbuffers.Builder, upperLeftElevationLimit:number) {
  builder.addFieldFloat64(24, upperLeftElevationLimit, 0.0);
}

static addRightGeoBeltLimit(builder:flatbuffers.Builder, rightGeoBeltLimit:number) {
  builder.addFieldFloat64(25, rightGeoBeltLimit, 0.0);
}

static addLeftGeoBeltLimit(builder:flatbuffers.Builder, leftGeoBeltLimit:number) {
  builder.addFieldFloat64(26, leftGeoBeltLimit, 0.0);
}

static addMagnitudeLimit(builder:flatbuffers.Builder, magnitudeLimit:number) {
  builder.addFieldFloat64(27, magnitudeLimit, 0.0);
}

static addTaskable(builder:flatbuffers.Builder, taskable:boolean) {
  builder.addFieldInt8(28, +taskable, +false);
}

static endIDM(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishIDMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$IDM');
}

static finishSizePrefixedIDMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$IDM', true);
}


unpack(): IDMT {
  return new IDMT(
    this.id(),
    this.name(),
    this.dataMode(),
    (this.uplink() !== null ? this.uplink()!.unpack() : null),
    (this.downlink() !== null ? this.downlink()!.unpack() : null),
    (this.beacon() !== null ? this.beacon()!.unpack() : null),
    this.bb!.createObjList<Band, BandT>(this.band.bind(this), this.bandLength()),
    this.polarizationType(),
    this.simplePolarization(),
    (this.stokesParameters() !== null ? this.stokesParameters()!.unpack() : null),
    this.powerRequired(),
    this.powerType(),
    this.transmit(),
    this.receive(),
    this.sensorType(),
    this.source(),
    this.lastObTime(),
    this.lowerLeftElevationLimit(),
    this.upperLeftAzimuthLimit(),
    this.lowerRightElevationLimit(),
    this.lowerLeftAzimuthLimit(),
    this.upperRightElevationLimit(),
    this.upperRightAzimuthLimit(),
    this.lowerRightAzimuthLimit(),
    this.upperLeftElevationLimit(),
    this.rightGeoBeltLimit(),
    this.leftGeoBeltLimit(),
    this.magnitudeLimit(),
    this.taskable()
  );
}


unpackTo(_o: IDMT): void {
  _o.id = this.id();
  _o.name = this.name();
  _o.dataMode = this.dataMode();
  _o.uplink = (this.uplink() !== null ? this.uplink()!.unpack() : null);
  _o.downlink = (this.downlink() !== null ? this.downlink()!.unpack() : null);
  _o.beacon = (this.beacon() !== null ? this.beacon()!.unpack() : null);
  _o.band = this.bb!.createObjList<Band, BandT>(this.band.bind(this), this.bandLength());
  _o.polarizationType = this.polarizationType();
  _o.simplePolarization = this.simplePolarization();
  _o.stokesParameters = (this.stokesParameters() !== null ? this.stokesParameters()!.unpack() : null);
  _o.powerRequired = this.powerRequired();
  _o.powerType = this.powerType();
  _o.transmit = this.transmit();
  _o.receive = this.receive();
  _o.sensorType = this.sensorType();
  _o.source = this.source();
  _o.lastObTime = this.lastObTime();
  _o.lowerLeftElevationLimit = this.lowerLeftElevationLimit();
  _o.upperLeftAzimuthLimit = this.upperLeftAzimuthLimit();
  _o.lowerRightElevationLimit = this.lowerRightElevationLimit();
  _o.lowerLeftAzimuthLimit = this.lowerLeftAzimuthLimit();
  _o.upperRightElevationLimit = this.upperRightElevationLimit();
  _o.upperRightAzimuthLimit = this.upperRightAzimuthLimit();
  _o.lowerRightAzimuthLimit = this.lowerRightAzimuthLimit();
  _o.upperLeftElevationLimit = this.upperLeftElevationLimit();
  _o.rightGeoBeltLimit = this.rightGeoBeltLimit();
  _o.leftGeoBeltLimit = this.leftGeoBeltLimit();
  _o.magnitudeLimit = this.magnitudeLimit();
  _o.taskable = this.taskable();
}
}

export class IDMT implements flatbuffers.IGeneratedObject {
constructor(
  public id: string|Uint8Array|null = null,
  public name: string|Uint8Array|null = null,
  public dataMode: DataMode = DataMode.REAL,
  public uplink: FrequencyRangeT|null = null,
  public downlink: FrequencyRangeT|null = null,
  public beacon: FrequencyRangeT|null = null,
  public band: (BandT)[] = [],
  public polarizationType: PolarizationType = PolarizationType.linear,
  public simplePolarization: SimplePolarization = SimplePolarization.vertical,
  public stokesParameters: StokesParametersT|null = null,
  public powerRequired: number = 0.0,
  public powerType: string|Uint8Array|null = null,
  public transmit: boolean = false,
  public receive: boolean = false,
  public sensorType: DeviceType = DeviceType.UNKNOWN,
  public source: string|Uint8Array|null = null,
  public lastObTime: string|Uint8Array|null = null,
  public lowerLeftElevationLimit: number = 0.0,
  public upperLeftAzimuthLimit: number = 0.0,
  public lowerRightElevationLimit: number = 0.0,
  public lowerLeftAzimuthLimit: number = 0.0,
  public upperRightElevationLimit: number = 0.0,
  public upperRightAzimuthLimit: number = 0.0,
  public lowerRightAzimuthLimit: number = 0.0,
  public upperLeftElevationLimit: number = 0.0,
  public rightGeoBeltLimit: number = 0.0,
  public leftGeoBeltLimit: number = 0.0,
  public magnitudeLimit: number = 0.0,
  public taskable: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const id = (this.id !== null ? builder.createString(this.id!) : 0);
  const name = (this.name !== null ? builder.createString(this.name!) : 0);
  const uplink = (this.uplink !== null ? this.uplink!.pack(builder) : 0);
  const downlink = (this.downlink !== null ? this.downlink!.pack(builder) : 0);
  const beacon = (this.beacon !== null ? this.beacon!.pack(builder) : 0);
  const band = IDM.createBandVector(builder, builder.createObjectOffsetList(this.band));
  const stokesParameters = (this.stokesParameters !== null ? this.stokesParameters!.pack(builder) : 0);
  const powerType = (this.powerType !== null ? builder.createString(this.powerType!) : 0);
  const source = (this.source !== null ? builder.createString(this.source!) : 0);
  const lastObTime = (this.lastObTime !== null ? builder.createString(this.lastObTime!) : 0);

  IDM.startIDM(builder);
  IDM.addId(builder, id);
  IDM.addName(builder, name);
  IDM.addDataMode(builder, this.dataMode);
  IDM.addUplink(builder, uplink);
  IDM.addDownlink(builder, downlink);
  IDM.addBeacon(builder, beacon);
  IDM.addBand(builder, band);
  IDM.addPolarizationType(builder, this.polarizationType);
  IDM.addSimplePolarization(builder, this.simplePolarization);
  IDM.addStokesParameters(builder, stokesParameters);
  IDM.addPowerRequired(builder, this.powerRequired);
  IDM.addPowerType(builder, powerType);
  IDM.addTransmit(builder, this.transmit);
  IDM.addReceive(builder, this.receive);
  IDM.addSensorType(builder, this.sensorType);
  IDM.addSource(builder, source);
  IDM.addLastObTime(builder, lastObTime);
  IDM.addLowerLeftElevationLimit(builder, this.lowerLeftElevationLimit);
  IDM.addUpperLeftAzimuthLimit(builder, this.upperLeftAzimuthLimit);
  IDM.addLowerRightElevationLimit(builder, this.lowerRightElevationLimit);
  IDM.addLowerLeftAzimuthLimit(builder, this.lowerLeftAzimuthLimit);
  IDM.addUpperRightElevationLimit(builder, this.upperRightElevationLimit);
  IDM.addUpperRightAzimuthLimit(builder, this.upperRightAzimuthLimit);
  IDM.addLowerRightAzimuthLimit(builder, this.lowerRightAzimuthLimit);
  IDM.addUpperLeftElevationLimit(builder, this.upperLeftElevationLimit);
  IDM.addRightGeoBeltLimit(builder, this.rightGeoBeltLimit);
  IDM.addLeftGeoBeltLimit(builder, this.leftGeoBeltLimit);
  IDM.addMagnitudeLimit(builder, this.magnitudeLimit);
  IDM.addTaskable(builder, this.taskable);

  return IDM.endIDM(builder);
}
}
