// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { accessType } from './accessType.js';
import { paymentMethod } from './paymentMethod.js';


/**
 * Access Control Grant - Permission to access purchased data
 */
export class ACL implements flatbuffers.IUnpackableObject<ACLT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ACL {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsACL(bb:flatbuffers.ByteBuffer, obj?:ACL):ACL {
  return (obj || new ACL()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsACL(bb:flatbuffers.ByteBuffer, obj?:ACL):ACL {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ACL()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$ACL');
}

/**
 * Unique identifier for this grant
 */
GRANT_ID():string|null
GRANT_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
GRANT_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the listing this grant applies to
 */
LISTING_ID():string|null
LISTING_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
LISTING_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Peer ID of the buyer/grantee
 */
BUYER_PEER_ID():string|null
BUYER_PEER_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
BUYER_PEER_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Buyer's encryption public key for encrypted delivery
 */
BUYER_ENCRYPTION_PUBKEY(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

buyerEncryptionPubkeyLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

buyerEncryptionPubkeyArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Type of access granted
 */
ACCESS_TYPE():accessType {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : accessType.OneTime;
}

/**
 * Name of the pricing tier purchased
 */
TIER_NAME():string|null
TIER_NAME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TIER_NAME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unix timestamp when access was granted
 */
GRANTED_AT():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

/**
 * Unix timestamp when access expires (0 = never expires)
 */
EXPIRES_AT():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

/**
 * Transaction hash or reference proving payment
 */
PAYMENT_TX_HASH():string|null
PAYMENT_TX_HASH(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PAYMENT_TX_HASH(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Payment method used
 */
PAYMENT_METHOD():paymentMethod {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : paymentMethod.Crypto_ETH;
}

/**
 * Ed25519 signature from provider
 */
PROVIDER_SIGNATURE(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

providerSignatureLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

providerSignatureArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startACL(builder:flatbuffers.Builder) {
  builder.startObject(11);
}

static addGrantId(builder:flatbuffers.Builder, GRANT_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, GRANT_IDOffset, 0);
}

static addListingId(builder:flatbuffers.Builder, LISTING_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, LISTING_IDOffset, 0);
}

static addBuyerPeerId(builder:flatbuffers.Builder, BUYER_PEER_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, BUYER_PEER_IDOffset, 0);
}

static addBuyerEncryptionPubkey(builder:flatbuffers.Builder, BUYER_ENCRYPTION_PUBKEYOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, BUYER_ENCRYPTION_PUBKEYOffset, 0);
}

static createBuyerEncryptionPubkeyVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startBuyerEncryptionPubkeyVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addAccessType(builder:flatbuffers.Builder, ACCESS_TYPE:accessType) {
  builder.addFieldInt8(4, ACCESS_TYPE, accessType.OneTime);
}

static addTierName(builder:flatbuffers.Builder, TIER_NAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, TIER_NAMEOffset, 0);
}

static addGrantedAt(builder:flatbuffers.Builder, GRANTED_AT:bigint) {
  builder.addFieldInt64(6, GRANTED_AT, BigInt('0'));
}

static addExpiresAt(builder:flatbuffers.Builder, EXPIRES_AT:bigint) {
  builder.addFieldInt64(7, EXPIRES_AT, BigInt('0'));
}

static addPaymentTxHash(builder:flatbuffers.Builder, PAYMENT_TX_HASHOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, PAYMENT_TX_HASHOffset, 0);
}

static addPaymentMethod(builder:flatbuffers.Builder, PAYMENT_METHOD:paymentMethod) {
  builder.addFieldInt8(9, PAYMENT_METHOD, paymentMethod.Crypto_ETH);
}

static addProviderSignature(builder:flatbuffers.Builder, PROVIDER_SIGNATUREOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, PROVIDER_SIGNATUREOffset, 0);
}

static createProviderSignatureVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startProviderSignatureVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static endACL(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 4) // GRANT_ID
  builder.requiredField(offset, 6) // LISTING_ID
  builder.requiredField(offset, 8) // BUYER_PEER_ID
  return offset;
}

static finishACLBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$ACL');
}

static finishSizePrefixedACLBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$ACL', true);
}

static createACL(builder:flatbuffers.Builder, GRANT_IDOffset:flatbuffers.Offset, LISTING_IDOffset:flatbuffers.Offset, BUYER_PEER_IDOffset:flatbuffers.Offset, BUYER_ENCRYPTION_PUBKEYOffset:flatbuffers.Offset, ACCESS_TYPE:accessType, TIER_NAMEOffset:flatbuffers.Offset, GRANTED_AT:bigint, EXPIRES_AT:bigint, PAYMENT_TX_HASHOffset:flatbuffers.Offset, PAYMENT_METHOD:paymentMethod, PROVIDER_SIGNATUREOffset:flatbuffers.Offset):flatbuffers.Offset {
  ACL.startACL(builder);
  ACL.addGrantId(builder, GRANT_IDOffset);
  ACL.addListingId(builder, LISTING_IDOffset);
  ACL.addBuyerPeerId(builder, BUYER_PEER_IDOffset);
  ACL.addBuyerEncryptionPubkey(builder, BUYER_ENCRYPTION_PUBKEYOffset);
  ACL.addAccessType(builder, ACCESS_TYPE);
  ACL.addTierName(builder, TIER_NAMEOffset);
  ACL.addGrantedAt(builder, GRANTED_AT);
  ACL.addExpiresAt(builder, EXPIRES_AT);
  ACL.addPaymentTxHash(builder, PAYMENT_TX_HASHOffset);
  ACL.addPaymentMethod(builder, PAYMENT_METHOD);
  ACL.addProviderSignature(builder, PROVIDER_SIGNATUREOffset);
  return ACL.endACL(builder);
}

unpack(): ACLT {
  return new ACLT(
    this.GRANT_ID(),
    this.LISTING_ID(),
    this.BUYER_PEER_ID(),
    this.bb!.createScalarList<number>(this.BUYER_ENCRYPTION_PUBKEY.bind(this), this.buyerEncryptionPubkeyLength()),
    this.ACCESS_TYPE(),
    this.TIER_NAME(),
    this.GRANTED_AT(),
    this.EXPIRES_AT(),
    this.PAYMENT_TX_HASH(),
    this.PAYMENT_METHOD(),
    this.bb!.createScalarList<number>(this.PROVIDER_SIGNATURE.bind(this), this.providerSignatureLength())
  );
}


unpackTo(_o: ACLT): void {
  _o.GRANT_ID = this.GRANT_ID();
  _o.LISTING_ID = this.LISTING_ID();
  _o.BUYER_PEER_ID = this.BUYER_PEER_ID();
  _o.BUYER_ENCRYPTION_PUBKEY = this.bb!.createScalarList<number>(this.BUYER_ENCRYPTION_PUBKEY.bind(this), this.buyerEncryptionPubkeyLength());
  _o.ACCESS_TYPE = this.ACCESS_TYPE();
  _o.TIER_NAME = this.TIER_NAME();
  _o.GRANTED_AT = this.GRANTED_AT();
  _o.EXPIRES_AT = this.EXPIRES_AT();
  _o.PAYMENT_TX_HASH = this.PAYMENT_TX_HASH();
  _o.PAYMENT_METHOD = this.PAYMENT_METHOD();
  _o.PROVIDER_SIGNATURE = this.bb!.createScalarList<number>(this.PROVIDER_SIGNATURE.bind(this), this.providerSignatureLength());
}
}

export class ACLT implements flatbuffers.IGeneratedObject {
constructor(
  public GRANT_ID: string|Uint8Array|null = null,
  public LISTING_ID: string|Uint8Array|null = null,
  public BUYER_PEER_ID: string|Uint8Array|null = null,
  public BUYER_ENCRYPTION_PUBKEY: (number)[] = [],
  public ACCESS_TYPE: accessType = accessType.OneTime,
  public TIER_NAME: string|Uint8Array|null = null,
  public GRANTED_AT: bigint = BigInt('0'),
  public EXPIRES_AT: bigint = BigInt('0'),
  public PAYMENT_TX_HASH: string|Uint8Array|null = null,
  public PAYMENT_METHOD: paymentMethod = paymentMethod.Crypto_ETH,
  public PROVIDER_SIGNATURE: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const GRANT_ID = (this.GRANT_ID !== null ? builder.createString(this.GRANT_ID!) : 0);
  const LISTING_ID = (this.LISTING_ID !== null ? builder.createString(this.LISTING_ID!) : 0);
  const BUYER_PEER_ID = (this.BUYER_PEER_ID !== null ? builder.createString(this.BUYER_PEER_ID!) : 0);
  const BUYER_ENCRYPTION_PUBKEY = ACL.createBuyerEncryptionPubkeyVector(builder, this.BUYER_ENCRYPTION_PUBKEY);
  const TIER_NAME = (this.TIER_NAME !== null ? builder.createString(this.TIER_NAME!) : 0);
  const PAYMENT_TX_HASH = (this.PAYMENT_TX_HASH !== null ? builder.createString(this.PAYMENT_TX_HASH!) : 0);
  const PROVIDER_SIGNATURE = ACL.createProviderSignatureVector(builder, this.PROVIDER_SIGNATURE);

  return ACL.createACL(builder,
    GRANT_ID,
    LISTING_ID,
    BUYER_PEER_ID,
    BUYER_ENCRYPTION_PUBKEY,
    this.ACCESS_TYPE,
    TIER_NAME,
    this.GRANTED_AT,
    this.EXPIRES_AT,
    PAYMENT_TX_HASH,
    this.PAYMENT_METHOD,
    PROVIDER_SIGNATURE
  );
}
}
