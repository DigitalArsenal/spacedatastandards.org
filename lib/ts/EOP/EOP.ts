// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { DataType } from './DataType.js';


/**
 * Earth Orientation Parameters
 */
export class EOP implements flatbuffers.IUnpackableObject<EOPT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):EOP {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsEOP(bb:flatbuffers.ByteBuffer, obj?:EOP):EOP {
  return (obj || new EOP()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsEOP(bb:flatbuffers.ByteBuffer, obj?:EOP):EOP {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new EOP()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$EOP');
}

/**
 * Date in ISO 8601 format
 */
DATE():string|null
DATE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
DATE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Modified Julian Date
 */
MJD():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * x pole coordinate in arcseconds
 */
X():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * y pole coordinate in arcseconds
 */
Y():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * UT1-UTC in seconds
 */
UT1_MINUS_UTC():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Length of Day correction in seconds
 */
LOD():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Nutation correction in longitude (δΔψ) in arcseconds
 */
DPSI():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Nutation correction in obliquity (δΔε) in arcseconds
 */
DEPS():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Celestial pole offset in x (δX) in arcseconds
 */
DX():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Celestial pole offset in y (δY) in arcseconds
 */
DY():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Delta Atomic Time (TAI-UTC) in seconds
 */
DAT():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

/**
 * Data type (O = Observed, P = Predicted)
 */
DATA_TYPE():DataType {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : DataType.OBSERVED;
}

static startEOP(builder:flatbuffers.Builder) {
  builder.startObject(12);
}

static addDate(builder:flatbuffers.Builder, DATEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, DATEOffset, 0);
}

static addMjd(builder:flatbuffers.Builder, MJD:number) {
  builder.addFieldInt32(1, MJD, 0);
}

static addX(builder:flatbuffers.Builder, X:number) {
  builder.addFieldFloat32(2, X, 0.0);
}

static addY(builder:flatbuffers.Builder, Y:number) {
  builder.addFieldFloat32(3, Y, 0.0);
}

static addUt1MinusUtc(builder:flatbuffers.Builder, UT1_MINUS_UTC:number) {
  builder.addFieldFloat32(4, UT1_MINUS_UTC, 0.0);
}

static addLod(builder:flatbuffers.Builder, LOD:number) {
  builder.addFieldFloat32(5, LOD, 0.0);
}

static addDpsi(builder:flatbuffers.Builder, DPSI:number) {
  builder.addFieldFloat32(6, DPSI, 0.0);
}

static addDeps(builder:flatbuffers.Builder, DEPS:number) {
  builder.addFieldFloat32(7, DEPS, 0.0);
}

static addDx(builder:flatbuffers.Builder, DX:number) {
  builder.addFieldFloat32(8, DX, 0.0);
}

static addDy(builder:flatbuffers.Builder, DY:number) {
  builder.addFieldFloat32(9, DY, 0.0);
}

static addDat(builder:flatbuffers.Builder, DAT:number) {
  builder.addFieldInt16(10, DAT, 0);
}

static addDataType(builder:flatbuffers.Builder, DATA_TYPE:DataType) {
  builder.addFieldInt8(11, DATA_TYPE, DataType.OBSERVED);
}

static endEOP(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishEOPBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EOP');
}

static finishSizePrefixedEOPBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EOP', true);
}

static createEOP(builder:flatbuffers.Builder, DATEOffset:flatbuffers.Offset, MJD:number, X:number, Y:number, UT1_MINUS_UTC:number, LOD:number, DPSI:number, DEPS:number, DX:number, DY:number, DAT:number, DATA_TYPE:DataType):flatbuffers.Offset {
  EOP.startEOP(builder);
  EOP.addDate(builder, DATEOffset);
  EOP.addMjd(builder, MJD);
  EOP.addX(builder, X);
  EOP.addY(builder, Y);
  EOP.addUt1MinusUtc(builder, UT1_MINUS_UTC);
  EOP.addLod(builder, LOD);
  EOP.addDpsi(builder, DPSI);
  EOP.addDeps(builder, DEPS);
  EOP.addDx(builder, DX);
  EOP.addDy(builder, DY);
  EOP.addDat(builder, DAT);
  EOP.addDataType(builder, DATA_TYPE);
  return EOP.endEOP(builder);
}

unpack(): EOPT {
  return new EOPT(
    this.DATE(),
    this.MJD(),
    this.X(),
    this.Y(),
    this.UT1_MINUS_UTC(),
    this.LOD(),
    this.DPSI(),
    this.DEPS(),
    this.DX(),
    this.DY(),
    this.DAT(),
    this.DATA_TYPE()
  );
}


unpackTo(_o: EOPT): void {
  _o.DATE = this.DATE();
  _o.MJD = this.MJD();
  _o.X = this.X();
  _o.Y = this.Y();
  _o.UT1_MINUS_UTC = this.UT1_MINUS_UTC();
  _o.LOD = this.LOD();
  _o.DPSI = this.DPSI();
  _o.DEPS = this.DEPS();
  _o.DX = this.DX();
  _o.DY = this.DY();
  _o.DAT = this.DAT();
  _o.DATA_TYPE = this.DATA_TYPE();
}
}

export class EOPT implements flatbuffers.IGeneratedObject {
constructor(
  public DATE: string|Uint8Array|null = null,
  public MJD: number = 0,
  public X: number = 0.0,
  public Y: number = 0.0,
  public UT1_MINUS_UTC: number = 0.0,
  public LOD: number = 0.0,
  public DPSI: number = 0.0,
  public DEPS: number = 0.0,
  public DX: number = 0.0,
  public DY: number = 0.0,
  public DAT: number = 0,
  public DATA_TYPE: DataType = DataType.OBSERVED
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const DATE = (this.DATE !== null ? builder.createString(this.DATE!) : 0);

  return EOP.createEOP(builder,
    DATE,
    this.MJD,
    this.X,
    this.Y,
    this.UT1_MINUS_UTC,
    this.LOD,
    this.DPSI,
    this.DEPS,
    this.DX,
    this.DY,
    this.DAT,
    this.DATA_TYPE
  );
}
}
