// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Score, ScoreT } from './score.js';


/**
 * Hypothesis Message
 */
export class HYP implements flatbuffers.IUnpackableObject<HYPT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):HYP {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsHYP(bb:flatbuffers.ByteBuffer, obj?:HYP):HYP {
  return (obj || new HYP()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsHYP(bb:flatbuffers.ByteBuffer, obj?:HYP):HYP {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new HYP()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$HYP');
}

/**
 * Space Objects Involved
 */
catIds(index: number):string
catIds(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
catIds(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

catIdsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Space Objects Involved
 */
sitIds(index: number):string
sitIds(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
sitIds(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

sitIdsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Name of the hypothesis
 */
name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Category of the hypothesis
 */
category():string|null
category(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
category(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Row indicators for the hypothesis matrix
 */
rowIndicators(index: number):string
rowIndicators(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
rowIndicators(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

rowIndicatorsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Column indicators for the hypothesis matrix
 */
colIndicators(index: number):string
colIndicators(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
colIndicators(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

colIndicatorsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Matrix data as a boolean array in row major format; if overflow, adds additional rows
 */
matrix(index: number):boolean|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? !!this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : false;
}

matrixLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

matrixArray():Int8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Scores for objects
 */
score(index: number, obj?:Score):Score|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? (obj || new Score()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

scoreLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Analysis methodology used to form the hypothesis
 */
analysisMethod():string|null
analysisMethod(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
analysisMethod(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

eventStartTime():string|null
eventStartTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
eventStartTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

eventEndTime():string|null
eventEndTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
eventEndTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startHYP(builder:flatbuffers.Builder) {
  builder.startObject(11);
}

static addCatIds(builder:flatbuffers.Builder, catIdsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, catIdsOffset, 0);
}

static createCatIdsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startCatIdsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addSitIds(builder:flatbuffers.Builder, sitIdsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, sitIdsOffset, 0);
}

static createSitIdsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startSitIdsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, nameOffset, 0);
}

static addCategory(builder:flatbuffers.Builder, categoryOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, categoryOffset, 0);
}

static addRowIndicators(builder:flatbuffers.Builder, rowIndicatorsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, rowIndicatorsOffset, 0);
}

static createRowIndicatorsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startRowIndicatorsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addColIndicators(builder:flatbuffers.Builder, colIndicatorsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, colIndicatorsOffset, 0);
}

static createColIndicatorsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startColIndicatorsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addMatrix(builder:flatbuffers.Builder, matrixOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, matrixOffset, 0);
}

static createMatrixVector(builder:flatbuffers.Builder, data:boolean[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(+data[i]!);
  }
  return builder.endVector();
}

static startMatrixVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addScore(builder:flatbuffers.Builder, scoreOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, scoreOffset, 0);
}

static createScoreVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startScoreVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addAnalysisMethod(builder:flatbuffers.Builder, analysisMethodOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, analysisMethodOffset, 0);
}

static addEventStartTime(builder:flatbuffers.Builder, eventStartTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, eventStartTimeOffset, 0);
}

static addEventEndTime(builder:flatbuffers.Builder, eventEndTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, eventEndTimeOffset, 0);
}

static endHYP(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishHYPBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$HYP');
}

static finishSizePrefixedHYPBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$HYP', true);
}

static createHYP(builder:flatbuffers.Builder, catIdsOffset:flatbuffers.Offset, sitIdsOffset:flatbuffers.Offset, nameOffset:flatbuffers.Offset, categoryOffset:flatbuffers.Offset, rowIndicatorsOffset:flatbuffers.Offset, colIndicatorsOffset:flatbuffers.Offset, matrixOffset:flatbuffers.Offset, scoreOffset:flatbuffers.Offset, analysisMethodOffset:flatbuffers.Offset, eventStartTimeOffset:flatbuffers.Offset, eventEndTimeOffset:flatbuffers.Offset):flatbuffers.Offset {
  HYP.startHYP(builder);
  HYP.addCatIds(builder, catIdsOffset);
  HYP.addSitIds(builder, sitIdsOffset);
  HYP.addName(builder, nameOffset);
  HYP.addCategory(builder, categoryOffset);
  HYP.addRowIndicators(builder, rowIndicatorsOffset);
  HYP.addColIndicators(builder, colIndicatorsOffset);
  HYP.addMatrix(builder, matrixOffset);
  HYP.addScore(builder, scoreOffset);
  HYP.addAnalysisMethod(builder, analysisMethodOffset);
  HYP.addEventStartTime(builder, eventStartTimeOffset);
  HYP.addEventEndTime(builder, eventEndTimeOffset);
  return HYP.endHYP(builder);
}

unpack(): HYPT {
  return new HYPT(
    this.bb!.createScalarList<string>(this.catIds.bind(this), this.catIdsLength()),
    this.bb!.createScalarList<string>(this.sitIds.bind(this), this.sitIdsLength()),
    this.name(),
    this.category(),
    this.bb!.createScalarList<string>(this.rowIndicators.bind(this), this.rowIndicatorsLength()),
    this.bb!.createScalarList<string>(this.colIndicators.bind(this), this.colIndicatorsLength()),
    this.bb!.createScalarList<boolean>(this.matrix.bind(this), this.matrixLength()),
    this.bb!.createObjList<Score, ScoreT>(this.score.bind(this), this.scoreLength()),
    this.analysisMethod(),
    this.eventStartTime(),
    this.eventEndTime()
  );
}


unpackTo(_o: HYPT): void {
  _o.catIds = this.bb!.createScalarList<string>(this.catIds.bind(this), this.catIdsLength());
  _o.sitIds = this.bb!.createScalarList<string>(this.sitIds.bind(this), this.sitIdsLength());
  _o.name = this.name();
  _o.category = this.category();
  _o.rowIndicators = this.bb!.createScalarList<string>(this.rowIndicators.bind(this), this.rowIndicatorsLength());
  _o.colIndicators = this.bb!.createScalarList<string>(this.colIndicators.bind(this), this.colIndicatorsLength());
  _o.matrix = this.bb!.createScalarList<boolean>(this.matrix.bind(this), this.matrixLength());
  _o.score = this.bb!.createObjList<Score, ScoreT>(this.score.bind(this), this.scoreLength());
  _o.analysisMethod = this.analysisMethod();
  _o.eventStartTime = this.eventStartTime();
  _o.eventEndTime = this.eventEndTime();
}
}

export class HYPT implements flatbuffers.IGeneratedObject {
constructor(
  public catIds: (string)[] = [],
  public sitIds: (string)[] = [],
  public name: string|Uint8Array|null = null,
  public category: string|Uint8Array|null = null,
  public rowIndicators: (string)[] = [],
  public colIndicators: (string)[] = [],
  public matrix: (boolean)[] = [],
  public score: (ScoreT)[] = [],
  public analysisMethod: string|Uint8Array|null = null,
  public eventStartTime: string|Uint8Array|null = null,
  public eventEndTime: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const catIds = HYP.createCatIdsVector(builder, builder.createObjectOffsetList(this.catIds));
  const sitIds = HYP.createSitIdsVector(builder, builder.createObjectOffsetList(this.sitIds));
  const name = (this.name !== null ? builder.createString(this.name!) : 0);
  const category = (this.category !== null ? builder.createString(this.category!) : 0);
  const rowIndicators = HYP.createRowIndicatorsVector(builder, builder.createObjectOffsetList(this.rowIndicators));
  const colIndicators = HYP.createColIndicatorsVector(builder, builder.createObjectOffsetList(this.colIndicators));
  const matrix = HYP.createMatrixVector(builder, this.matrix);
  const score = HYP.createScoreVector(builder, builder.createObjectOffsetList(this.score));
  const analysisMethod = (this.analysisMethod !== null ? builder.createString(this.analysisMethod!) : 0);
  const eventStartTime = (this.eventStartTime !== null ? builder.createString(this.eventStartTime!) : 0);
  const eventEndTime = (this.eventEndTime !== null ? builder.createString(this.eventEndTime!) : 0);

  return HYP.createHYP(builder,
    catIds,
    sitIds,
    name,
    category,
    rowIndicators,
    colIndicators,
    matrix,
    score,
    analysisMethod,
    eventStartTime,
    eventEndTime
  );
}
}
