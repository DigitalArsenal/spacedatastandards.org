// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';



/**
 * Collection Request Message
 */
export class CRM implements flatbuffers.IUnpackableObject<CRMT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):CRM {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsCRM(bb:flatbuffers.ByteBuffer, obj?:CRM):CRM {
  return (obj || new CRM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsCRM(bb:flatbuffers.ByteBuffer, obj?:CRM):CRM {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new CRM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$CRM');
}

/**
 * Unique identifier of the record, auto-generated by the system.
 */
ID():string|null
ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 */
CLASSIFICATION():string|null
CLASSIFICATION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CLASSIFICATION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The type of this collect or contact request.
 */
TYPE():string|null
TYPE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TYPE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique identifier of the parent plan or schedule associated with this request.
 */
ID_PLAN():string|null
ID_PLAN(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID_PLAN(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Index number for records within a collection plan or schedule.
 */
PLAN_INDEX():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Task ID associated with this request.
 */
TASK_ID():string|null
TASK_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TASK_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The dwell ID associated with this request.
 */
DWELL_ID():string|null
DWELL_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
DWELL_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional ID from external systems.
 */
EXTERNAL_ID():string|null
EXTERNAL_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
EXTERNAL_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique identifier of the requested/scheduled/planned sensor associated with this request.
 */
ID_SENSOR():string|null
ID_SENSOR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID_SENSOR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request.
 */
ORIG_SENSOR_ID():string|null
ORIG_SENSOR_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIG_SENSOR_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional type of observation requested.
 */
OB_TYPE():string|null
OB_TYPE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
OB_TYPE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The priority of the collect request.
 */
PRIORITY():string|null
PRIORITY(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PRIORITY(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The tasking category associated with this request.
 */
TASK_CATEGORY():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The tasking suffix associated with this request.
 */
SUFFIX():string|null
SUFFIX(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SUFFIX(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Boolean indicating that this collect request is UCT follow-up.
 */
UCT_FOLLOW_UP():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The start time of the collect or contact request window, in ISO 8601 UTC format.
 */
START_TIME():string|null
START_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
START_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The end time of the collect or contact request window, in ISO 8601 UTC format.
 */
END_TIME():string|null
END_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
END_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Satellite/catalog number of the target on-orbit object for this request.
 */
NORAD_CAT_ID():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * Optional identifier provided by the data source to indicate the target object of this request.
 */
ORIG_OBJECT_ID():string|null
ORIG_OBJECT_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIG_OBJECT_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The tasking group to which the target object is assigned.
 */
TASK_GROUP():string|null
TASK_GROUP(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TASK_GROUP(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Inter-Range Operations Number.
 */
IRON():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The orbit regime of the target.
 */
ORBIT_REGIME():string|null
ORBIT_REGIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORBIT_REGIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The minimum object (diameter) size, in meters, to be reported.
 */
TARGET_SIZE():number {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The minimum Radar Cross-Section of the target, in m^2.
 */
RCS_MIN():number {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The Radar Cross-Section of the target, in m^2.
 */
RCS():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum Radar Cross-Section of the target, in m^2.
 */
RCS_MAX():number {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The minimum frequency of interest, in MHz.
 */
FREQ_MIN():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The estimated or expected emission frequency of the target, in MHz.
 */
FREQ():number {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum frequency of interest, in MHz.
 */
FREQ_MAX():number {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The RF polarization.
 */
POLARIZATION():string|null
POLARIZATION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
POLARIZATION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).
 */
VIS_MAG_MIN():number {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The estimated or expected visual magnitude of the target, in Magnitudes (M).
 */
VIS_MAG():number {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
 */
VIS_MAG_MAX():number {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The spectral model used for the irradiance calculation.
 */
SPECTRAL_MODEL():string|null
SPECTRAL_MODEL(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SPECTRAL_MODEL(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The fraction of solar energy reflected from target.
 */
REFLECTANCE():number {
  const offset = this.bb!.__offset(this.bb_pos, 72);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The target object irradiance value.
 */
IRRADIANCE():number {
  const offset = this.bb!.__offset(this.bb_pos, 74);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For optical sensors, the requested number of frames to capture at each sensor step.
 */
NUM_FRAMES():number {
  const offset = this.bb!.__offset(this.bb_pos, 76);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * For optical sensors, the frame rate of the camera, in Hz.
 */
FRAME_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 78);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For optical sensors, the integration time per camera frame, in milliseconds.
 */
INTEGRATION_TIME():number {
  const offset = this.bb!.__offset(this.bb_pos, 80);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The number of requested tracks on the target.
 */
NUM_TRACKS():number {
  const offset = this.bb!.__offset(this.bb_pos, 82);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The number of requested observations on the target.
 */
NUM_OBS():number {
  const offset = this.bb!.__offset(this.bb_pos, 84);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The duration of the collect request, in seconds.
 */
DURATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 86);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The search pattern to be executed for this request.
 */
SRCH_PATTERN():string|null
SRCH_PATTERN(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SRCH_PATTERN(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 88);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
 */
SCENARIO():string|null
SCENARIO(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SCENARIO(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 90);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the Elset of the object associated with this request.
 */
ID_ELSET():string|null
ID_ELSET(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID_ELSET(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 92);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the Manifold Elset of the object associated with this request.
 */
ID_MANIFOLD():string|null
ID_MANIFOLD(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID_MANIFOLD(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 94);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the State Vector of the object or central vector associated with this request.
 */
ID_STATE_VECTOR():string|null
ID_STATE_VECTOR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID_STATE_VECTOR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 96);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the Ephemeris Set of the object associated with this request.
 */
ES_ID():string|null
ES_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ES_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 98);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Epoch time, in ISO 8601 UTC format, of the orbital elements.
 */
EPOCH():string|null
EPOCH(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
EPOCH(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 100);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The average of the periapsis and apoapsis distances, in kilometers.
 */
SEMI_MAJOR_AXIS():number {
  const offset = this.bb!.__offset(this.bb_pos, 102);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The orbital eccentricity of an astronomical object.
 */
ECCENTRICITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 104);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The angle, in degrees, between the equator and the orbit plane.
 */
INCLINATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 106);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Right ascension of the ascending node, in degrees.
 */
RAAN():number {
  const offset = this.bb!.__offset(this.bb_pos, 108);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The argument of perigee, in degrees.
 */
ARG_OF_PERIGEE():number {
  const offset = this.bb!.__offset(this.bb_pos, 110);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The mean anomaly defines the angular position, in degrees, of the object on its orbital path.
 */
MEAN_ANOMALY():number {
  const offset = this.bb!.__offset(this.bb_pos, 112);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed right ascension angle, in degrees.
 */
RA():number {
  const offset = this.bb!.__offset(this.bb_pos, 114);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed declination angle, in degrees.
 */
DEC():number {
  const offset = this.bb!.__offset(this.bb_pos, 116);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed azimuth angle, in degrees.
 */
AZ():number {
  const offset = this.bb!.__offset(this.bb_pos, 118);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed elevation angle, in degrees.
 */
EL():number {
  const offset = this.bb!.__offset(this.bb_pos, 120);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected acquisition range or defined center range, in km.
 */
RANGE():number {
  const offset = this.bb!.__offset(this.bb_pos, 122);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The extent of the azimuth angle, in degrees, from center azimuth.
 */
EXTENT_AZ():number {
  const offset = this.bb!.__offset(this.bb_pos, 124);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The extent of the elevation angle, in degrees, from center elevation.
 */
EXTENT_EL():number {
  const offset = this.bb!.__offset(this.bb_pos, 126);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The extent of the range, in km, from center range.
 */
EXTENT_RANGE():number {
  const offset = this.bb!.__offset(this.bb_pos, 128);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * WGS-84 latitude, in degrees.
 */
LAT():number {
  const offset = this.bb!.__offset(this.bb_pos, 130);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * WGS-84 longitude, in degrees.
 */
LON():number {
  const offset = this.bb!.__offset(this.bb_pos, 132);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Height above WGS-84 ellipsoid (HAE), in kilometers.
 */
ALT():number {
  const offset = this.bb!.__offset(this.bb_pos, 134);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The stopping WGS-84 latitude of a volume definition, in degrees.
 */
STOP_LAT():number {
  const offset = this.bb!.__offset(this.bb_pos, 136);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The stopping WGS-84 longitude of a volume definition, in degrees.
 */
STOP_LON():number {
  const offset = this.bb!.__offset(this.bb_pos, 138);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The stopping HAE WGS-84 height above ellipsoid (HAE), in kilometers.
 */
STOP_ALT():number {
  const offset = this.bb!.__offset(this.bb_pos, 140);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum inclination, in degrees, to be used in search operations.
 */
SRCH_INC():number {
  const offset = this.bb!.__offset(this.bb_pos, 142);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The angular distance, in degrees, in the sensor-x direction from scan center.
 */
X_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 144);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The angular distance, in degrees, in the sensor-y direction from scan center.
 */
Y_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 146);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.
 */
ORIENT_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 148);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The customer for this request.
 */
CUSTOMER():string|null
CUSTOMER(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CUSTOMER(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 150);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Notes or comments associated with this request.
 */
NOTES():string|null
NOTES(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
NOTES(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 152);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 *  Source of the data.
 */
SOURCE():string|null
SOURCE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SOURCE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 154);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 *  Originating system or organization which produced the data, if different from the source.
 */
ORIGIN():string|null
ORIGIN(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIGIN(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 156);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 *  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data.
 */
DATA_MODE():string|null
DATA_MODE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
DATA_MODE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 158);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startCRM(builder:flatbuffers.Builder) {
  builder.startObject(78);
}

static addId(builder:flatbuffers.Builder, IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, IDOffset, 0);
}

static addClassification(builder:flatbuffers.Builder, CLASSIFICATIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, CLASSIFICATIONOffset, 0);
}

static addType(builder:flatbuffers.Builder, TYPEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, TYPEOffset, 0);
}

static addIdPlan(builder:flatbuffers.Builder, ID_PLANOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, ID_PLANOffset, 0);
}

static addPlanIndex(builder:flatbuffers.Builder, PLAN_INDEX:number) {
  builder.addFieldInt32(4, PLAN_INDEX, 0);
}

static addTaskId(builder:flatbuffers.Builder, TASK_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, TASK_IDOffset, 0);
}

static addDwellId(builder:flatbuffers.Builder, DWELL_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, DWELL_IDOffset, 0);
}

static addExternalId(builder:flatbuffers.Builder, EXTERNAL_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, EXTERNAL_IDOffset, 0);
}

static addIdSensor(builder:flatbuffers.Builder, ID_SENSOROffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, ID_SENSOROffset, 0);
}

static addOrigSensorId(builder:flatbuffers.Builder, ORIG_SENSOR_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, ORIG_SENSOR_IDOffset, 0);
}

static addObType(builder:flatbuffers.Builder, OB_TYPEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, OB_TYPEOffset, 0);
}

static addPriority(builder:flatbuffers.Builder, PRIORITYOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, PRIORITYOffset, 0);
}

static addTaskCategory(builder:flatbuffers.Builder, TASK_CATEGORY:number) {
  builder.addFieldInt32(12, TASK_CATEGORY, 0);
}

static addSuffix(builder:flatbuffers.Builder, SUFFIXOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, SUFFIXOffset, 0);
}

static addUctFollowUp(builder:flatbuffers.Builder, UCT_FOLLOW_UP:boolean) {
  builder.addFieldInt8(14, +UCT_FOLLOW_UP, +false);
}

static addStartTime(builder:flatbuffers.Builder, START_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, START_TIMEOffset, 0);
}

static addEndTime(builder:flatbuffers.Builder, END_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, END_TIMEOffset, 0);
}

static addNoradCatId(builder:flatbuffers.Builder, NORAD_CAT_ID:number) {
  builder.addFieldInt32(17, NORAD_CAT_ID, 0);
}

static addOrigObjectId(builder:flatbuffers.Builder, ORIG_OBJECT_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(18, ORIG_OBJECT_IDOffset, 0);
}

static addTaskGroup(builder:flatbuffers.Builder, TASK_GROUPOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, TASK_GROUPOffset, 0);
}

static addIron(builder:flatbuffers.Builder, IRON:number) {
  builder.addFieldInt32(20, IRON, 0);
}

static addOrbitRegime(builder:flatbuffers.Builder, ORBIT_REGIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(21, ORBIT_REGIMEOffset, 0);
}

static addTargetSize(builder:flatbuffers.Builder, TARGET_SIZE:number) {
  builder.addFieldFloat64(22, TARGET_SIZE, 0.0);
}

static addRcsMin(builder:flatbuffers.Builder, RCS_MIN:number) {
  builder.addFieldFloat64(23, RCS_MIN, 0.0);
}

static addRcs(builder:flatbuffers.Builder, RCS:number) {
  builder.addFieldFloat64(24, RCS, 0.0);
}

static addRcsMax(builder:flatbuffers.Builder, RCS_MAX:number) {
  builder.addFieldFloat64(25, RCS_MAX, 0.0);
}

static addFreqMin(builder:flatbuffers.Builder, FREQ_MIN:number) {
  builder.addFieldFloat64(26, FREQ_MIN, 0.0);
}

static addFreq(builder:flatbuffers.Builder, FREQ:number) {
  builder.addFieldFloat64(27, FREQ, 0.0);
}

static addFreqMax(builder:flatbuffers.Builder, FREQ_MAX:number) {
  builder.addFieldFloat64(28, FREQ_MAX, 0.0);
}

static addPolarization(builder:flatbuffers.Builder, POLARIZATIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(29, POLARIZATIONOffset, 0);
}

static addVisMagMin(builder:flatbuffers.Builder, VIS_MAG_MIN:number) {
  builder.addFieldFloat64(30, VIS_MAG_MIN, 0.0);
}

static addVisMag(builder:flatbuffers.Builder, VIS_MAG:number) {
  builder.addFieldFloat64(31, VIS_MAG, 0.0);
}

static addVisMagMax(builder:flatbuffers.Builder, VIS_MAG_MAX:number) {
  builder.addFieldFloat64(32, VIS_MAG_MAX, 0.0);
}

static addSpectralModel(builder:flatbuffers.Builder, SPECTRAL_MODELOffset:flatbuffers.Offset) {
  builder.addFieldOffset(33, SPECTRAL_MODELOffset, 0);
}

static addReflectance(builder:flatbuffers.Builder, REFLECTANCE:number) {
  builder.addFieldFloat64(34, REFLECTANCE, 0.0);
}

static addIrradiance(builder:flatbuffers.Builder, IRRADIANCE:number) {
  builder.addFieldFloat64(35, IRRADIANCE, 0.0);
}

static addNumFrames(builder:flatbuffers.Builder, NUM_FRAMES:number) {
  builder.addFieldInt32(36, NUM_FRAMES, 0);
}

static addFrameRate(builder:flatbuffers.Builder, FRAME_RATE:number) {
  builder.addFieldFloat64(37, FRAME_RATE, 0.0);
}

static addIntegrationTime(builder:flatbuffers.Builder, INTEGRATION_TIME:number) {
  builder.addFieldFloat64(38, INTEGRATION_TIME, 0.0);
}

static addNumTracks(builder:flatbuffers.Builder, NUM_TRACKS:number) {
  builder.addFieldInt32(39, NUM_TRACKS, 0);
}

static addNumObs(builder:flatbuffers.Builder, NUM_OBS:number) {
  builder.addFieldInt32(40, NUM_OBS, 0);
}

static addDuration(builder:flatbuffers.Builder, DURATION:number) {
  builder.addFieldInt32(41, DURATION, 0);
}

static addSrchPattern(builder:flatbuffers.Builder, SRCH_PATTERNOffset:flatbuffers.Offset) {
  builder.addFieldOffset(42, SRCH_PATTERNOffset, 0);
}

static addScenario(builder:flatbuffers.Builder, SCENARIOOffset:flatbuffers.Offset) {
  builder.addFieldOffset(43, SCENARIOOffset, 0);
}

static addIdElset(builder:flatbuffers.Builder, ID_ELSETOffset:flatbuffers.Offset) {
  builder.addFieldOffset(44, ID_ELSETOffset, 0);
}

static addIdManifold(builder:flatbuffers.Builder, ID_MANIFOLDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(45, ID_MANIFOLDOffset, 0);
}

static addIdStateVector(builder:flatbuffers.Builder, ID_STATE_VECTOROffset:flatbuffers.Offset) {
  builder.addFieldOffset(46, ID_STATE_VECTOROffset, 0);
}

static addEsId(builder:flatbuffers.Builder, ES_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(47, ES_IDOffset, 0);
}

static addEpoch(builder:flatbuffers.Builder, EPOCHOffset:flatbuffers.Offset) {
  builder.addFieldOffset(48, EPOCHOffset, 0);
}

static addSemiMajorAxis(builder:flatbuffers.Builder, SEMI_MAJOR_AXIS:number) {
  builder.addFieldFloat64(49, SEMI_MAJOR_AXIS, 0.0);
}

static addEccentricity(builder:flatbuffers.Builder, ECCENTRICITY:number) {
  builder.addFieldFloat64(50, ECCENTRICITY, 0.0);
}

static addInclination(builder:flatbuffers.Builder, INCLINATION:number) {
  builder.addFieldFloat64(51, INCLINATION, 0.0);
}

static addRaan(builder:flatbuffers.Builder, RAAN:number) {
  builder.addFieldFloat64(52, RAAN, 0.0);
}

static addArgOfPerigee(builder:flatbuffers.Builder, ARG_OF_PERIGEE:number) {
  builder.addFieldFloat64(53, ARG_OF_PERIGEE, 0.0);
}

static addMeanAnomaly(builder:flatbuffers.Builder, MEAN_ANOMALY:number) {
  builder.addFieldFloat64(54, MEAN_ANOMALY, 0.0);
}

static addRa(builder:flatbuffers.Builder, RA:number) {
  builder.addFieldFloat64(55, RA, 0.0);
}

static addDec(builder:flatbuffers.Builder, DEC:number) {
  builder.addFieldFloat64(56, DEC, 0.0);
}

static addAz(builder:flatbuffers.Builder, AZ:number) {
  builder.addFieldFloat64(57, AZ, 0.0);
}

static addEl(builder:flatbuffers.Builder, EL:number) {
  builder.addFieldFloat64(58, EL, 0.0);
}

static addRange(builder:flatbuffers.Builder, RANGE:number) {
  builder.addFieldFloat64(59, RANGE, 0.0);
}

static addExtentAz(builder:flatbuffers.Builder, EXTENT_AZ:number) {
  builder.addFieldFloat64(60, EXTENT_AZ, 0.0);
}

static addExtentEl(builder:flatbuffers.Builder, EXTENT_EL:number) {
  builder.addFieldFloat64(61, EXTENT_EL, 0.0);
}

static addExtentRange(builder:flatbuffers.Builder, EXTENT_RANGE:number) {
  builder.addFieldFloat64(62, EXTENT_RANGE, 0.0);
}

static addLat(builder:flatbuffers.Builder, LAT:number) {
  builder.addFieldFloat64(63, LAT, 0.0);
}

static addLon(builder:flatbuffers.Builder, LON:number) {
  builder.addFieldFloat64(64, LON, 0.0);
}

static addAlt(builder:flatbuffers.Builder, ALT:number) {
  builder.addFieldFloat64(65, ALT, 0.0);
}

static addStopLat(builder:flatbuffers.Builder, STOP_LAT:number) {
  builder.addFieldFloat64(66, STOP_LAT, 0.0);
}

static addStopLon(builder:flatbuffers.Builder, STOP_LON:number) {
  builder.addFieldFloat64(67, STOP_LON, 0.0);
}

static addStopAlt(builder:flatbuffers.Builder, STOP_ALT:number) {
  builder.addFieldFloat64(68, STOP_ALT, 0.0);
}

static addSrchInc(builder:flatbuffers.Builder, SRCH_INC:number) {
  builder.addFieldFloat64(69, SRCH_INC, 0.0);
}

static addXAngle(builder:flatbuffers.Builder, X_ANGLE:number) {
  builder.addFieldFloat64(70, X_ANGLE, 0.0);
}

static addYAngle(builder:flatbuffers.Builder, Y_ANGLE:number) {
  builder.addFieldFloat64(71, Y_ANGLE, 0.0);
}

static addOrientAngle(builder:flatbuffers.Builder, ORIENT_ANGLE:number) {
  builder.addFieldFloat64(72, ORIENT_ANGLE, 0.0);
}

static addCustomer(builder:flatbuffers.Builder, CUSTOMEROffset:flatbuffers.Offset) {
  builder.addFieldOffset(73, CUSTOMEROffset, 0);
}

static addNotes(builder:flatbuffers.Builder, NOTESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(74, NOTESOffset, 0);
}

static addSource(builder:flatbuffers.Builder, SOURCEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(75, SOURCEOffset, 0);
}

static addOrigin(builder:flatbuffers.Builder, ORIGINOffset:flatbuffers.Offset) {
  builder.addFieldOffset(76, ORIGINOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, DATA_MODEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(77, DATA_MODEOffset, 0);
}

static endCRM(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishCRMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$CRM');
}

static finishSizePrefixedCRMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$CRM', true);
}

static createCRM(builder:flatbuffers.Builder, IDOffset:flatbuffers.Offset, CLASSIFICATIONOffset:flatbuffers.Offset, TYPEOffset:flatbuffers.Offset, ID_PLANOffset:flatbuffers.Offset, PLAN_INDEX:number, TASK_IDOffset:flatbuffers.Offset, DWELL_IDOffset:flatbuffers.Offset, EXTERNAL_IDOffset:flatbuffers.Offset, ID_SENSOROffset:flatbuffers.Offset, ORIG_SENSOR_IDOffset:flatbuffers.Offset, OB_TYPEOffset:flatbuffers.Offset, PRIORITYOffset:flatbuffers.Offset, TASK_CATEGORY:number, SUFFIXOffset:flatbuffers.Offset, UCT_FOLLOW_UP:boolean, START_TIMEOffset:flatbuffers.Offset, END_TIMEOffset:flatbuffers.Offset, NORAD_CAT_ID:number, ORIG_OBJECT_IDOffset:flatbuffers.Offset, TASK_GROUPOffset:flatbuffers.Offset, IRON:number, ORBIT_REGIMEOffset:flatbuffers.Offset, TARGET_SIZE:number, RCS_MIN:number, RCS:number, RCS_MAX:number, FREQ_MIN:number, FREQ:number, FREQ_MAX:number, POLARIZATIONOffset:flatbuffers.Offset, VIS_MAG_MIN:number, VIS_MAG:number, VIS_MAG_MAX:number, SPECTRAL_MODELOffset:flatbuffers.Offset, REFLECTANCE:number, IRRADIANCE:number, NUM_FRAMES:number, FRAME_RATE:number, INTEGRATION_TIME:number, NUM_TRACKS:number, NUM_OBS:number, DURATION:number, SRCH_PATTERNOffset:flatbuffers.Offset, SCENARIOOffset:flatbuffers.Offset, ID_ELSETOffset:flatbuffers.Offset, ID_MANIFOLDOffset:flatbuffers.Offset, ID_STATE_VECTOROffset:flatbuffers.Offset, ES_IDOffset:flatbuffers.Offset, EPOCHOffset:flatbuffers.Offset, SEMI_MAJOR_AXIS:number, ECCENTRICITY:number, INCLINATION:number, RAAN:number, ARG_OF_PERIGEE:number, MEAN_ANOMALY:number, RA:number, DEC:number, AZ:number, EL:number, RANGE:number, EXTENT_AZ:number, EXTENT_EL:number, EXTENT_RANGE:number, LAT:number, LON:number, ALT:number, STOP_LAT:number, STOP_LON:number, STOP_ALT:number, SRCH_INC:number, X_ANGLE:number, Y_ANGLE:number, ORIENT_ANGLE:number, CUSTOMEROffset:flatbuffers.Offset, NOTESOffset:flatbuffers.Offset, SOURCEOffset:flatbuffers.Offset, ORIGINOffset:flatbuffers.Offset, DATA_MODEOffset:flatbuffers.Offset):flatbuffers.Offset {
  CRM.startCRM(builder);
  CRM.addId(builder, IDOffset);
  CRM.addClassification(builder, CLASSIFICATIONOffset);
  CRM.addType(builder, TYPEOffset);
  CRM.addIdPlan(builder, ID_PLANOffset);
  CRM.addPlanIndex(builder, PLAN_INDEX);
  CRM.addTaskId(builder, TASK_IDOffset);
  CRM.addDwellId(builder, DWELL_IDOffset);
  CRM.addExternalId(builder, EXTERNAL_IDOffset);
  CRM.addIdSensor(builder, ID_SENSOROffset);
  CRM.addOrigSensorId(builder, ORIG_SENSOR_IDOffset);
  CRM.addObType(builder, OB_TYPEOffset);
  CRM.addPriority(builder, PRIORITYOffset);
  CRM.addTaskCategory(builder, TASK_CATEGORY);
  CRM.addSuffix(builder, SUFFIXOffset);
  CRM.addUctFollowUp(builder, UCT_FOLLOW_UP);
  CRM.addStartTime(builder, START_TIMEOffset);
  CRM.addEndTime(builder, END_TIMEOffset);
  CRM.addNoradCatId(builder, NORAD_CAT_ID);
  CRM.addOrigObjectId(builder, ORIG_OBJECT_IDOffset);
  CRM.addTaskGroup(builder, TASK_GROUPOffset);
  CRM.addIron(builder, IRON);
  CRM.addOrbitRegime(builder, ORBIT_REGIMEOffset);
  CRM.addTargetSize(builder, TARGET_SIZE);
  CRM.addRcsMin(builder, RCS_MIN);
  CRM.addRcs(builder, RCS);
  CRM.addRcsMax(builder, RCS_MAX);
  CRM.addFreqMin(builder, FREQ_MIN);
  CRM.addFreq(builder, FREQ);
  CRM.addFreqMax(builder, FREQ_MAX);
  CRM.addPolarization(builder, POLARIZATIONOffset);
  CRM.addVisMagMin(builder, VIS_MAG_MIN);
  CRM.addVisMag(builder, VIS_MAG);
  CRM.addVisMagMax(builder, VIS_MAG_MAX);
  CRM.addSpectralModel(builder, SPECTRAL_MODELOffset);
  CRM.addReflectance(builder, REFLECTANCE);
  CRM.addIrradiance(builder, IRRADIANCE);
  CRM.addNumFrames(builder, NUM_FRAMES);
  CRM.addFrameRate(builder, FRAME_RATE);
  CRM.addIntegrationTime(builder, INTEGRATION_TIME);
  CRM.addNumTracks(builder, NUM_TRACKS);
  CRM.addNumObs(builder, NUM_OBS);
  CRM.addDuration(builder, DURATION);
  CRM.addSrchPattern(builder, SRCH_PATTERNOffset);
  CRM.addScenario(builder, SCENARIOOffset);
  CRM.addIdElset(builder, ID_ELSETOffset);
  CRM.addIdManifold(builder, ID_MANIFOLDOffset);
  CRM.addIdStateVector(builder, ID_STATE_VECTOROffset);
  CRM.addEsId(builder, ES_IDOffset);
  CRM.addEpoch(builder, EPOCHOffset);
  CRM.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
  CRM.addEccentricity(builder, ECCENTRICITY);
  CRM.addInclination(builder, INCLINATION);
  CRM.addRaan(builder, RAAN);
  CRM.addArgOfPerigee(builder, ARG_OF_PERIGEE);
  CRM.addMeanAnomaly(builder, MEAN_ANOMALY);
  CRM.addRa(builder, RA);
  CRM.addDec(builder, DEC);
  CRM.addAz(builder, AZ);
  CRM.addEl(builder, EL);
  CRM.addRange(builder, RANGE);
  CRM.addExtentAz(builder, EXTENT_AZ);
  CRM.addExtentEl(builder, EXTENT_EL);
  CRM.addExtentRange(builder, EXTENT_RANGE);
  CRM.addLat(builder, LAT);
  CRM.addLon(builder, LON);
  CRM.addAlt(builder, ALT);
  CRM.addStopLat(builder, STOP_LAT);
  CRM.addStopLon(builder, STOP_LON);
  CRM.addStopAlt(builder, STOP_ALT);
  CRM.addSrchInc(builder, SRCH_INC);
  CRM.addXAngle(builder, X_ANGLE);
  CRM.addYAngle(builder, Y_ANGLE);
  CRM.addOrientAngle(builder, ORIENT_ANGLE);
  CRM.addCustomer(builder, CUSTOMEROffset);
  CRM.addNotes(builder, NOTESOffset);
  CRM.addSource(builder, SOURCEOffset);
  CRM.addOrigin(builder, ORIGINOffset);
  CRM.addDataMode(builder, DATA_MODEOffset);
  return CRM.endCRM(builder);
}

unpack(): CRMT {
  return new CRMT(
    this.ID(),
    this.CLASSIFICATION(),
    this.TYPE(),
    this.ID_PLAN(),
    this.PLAN_INDEX(),
    this.TASK_ID(),
    this.DWELL_ID(),
    this.EXTERNAL_ID(),
    this.ID_SENSOR(),
    this.ORIG_SENSOR_ID(),
    this.OB_TYPE(),
    this.PRIORITY(),
    this.TASK_CATEGORY(),
    this.SUFFIX(),
    this.UCT_FOLLOW_UP(),
    this.START_TIME(),
    this.END_TIME(),
    this.NORAD_CAT_ID(),
    this.ORIG_OBJECT_ID(),
    this.TASK_GROUP(),
    this.IRON(),
    this.ORBIT_REGIME(),
    this.TARGET_SIZE(),
    this.RCS_MIN(),
    this.RCS(),
    this.RCS_MAX(),
    this.FREQ_MIN(),
    this.FREQ(),
    this.FREQ_MAX(),
    this.POLARIZATION(),
    this.VIS_MAG_MIN(),
    this.VIS_MAG(),
    this.VIS_MAG_MAX(),
    this.SPECTRAL_MODEL(),
    this.REFLECTANCE(),
    this.IRRADIANCE(),
    this.NUM_FRAMES(),
    this.FRAME_RATE(),
    this.INTEGRATION_TIME(),
    this.NUM_TRACKS(),
    this.NUM_OBS(),
    this.DURATION(),
    this.SRCH_PATTERN(),
    this.SCENARIO(),
    this.ID_ELSET(),
    this.ID_MANIFOLD(),
    this.ID_STATE_VECTOR(),
    this.ES_ID(),
    this.EPOCH(),
    this.SEMI_MAJOR_AXIS(),
    this.ECCENTRICITY(),
    this.INCLINATION(),
    this.RAAN(),
    this.ARG_OF_PERIGEE(),
    this.MEAN_ANOMALY(),
    this.RA(),
    this.DEC(),
    this.AZ(),
    this.EL(),
    this.RANGE(),
    this.EXTENT_AZ(),
    this.EXTENT_EL(),
    this.EXTENT_RANGE(),
    this.LAT(),
    this.LON(),
    this.ALT(),
    this.STOP_LAT(),
    this.STOP_LON(),
    this.STOP_ALT(),
    this.SRCH_INC(),
    this.X_ANGLE(),
    this.Y_ANGLE(),
    this.ORIENT_ANGLE(),
    this.CUSTOMER(),
    this.NOTES(),
    this.SOURCE(),
    this.ORIGIN(),
    this.DATA_MODE()
  );
}


unpackTo(_o: CRMT): void {
  _o.ID = this.ID();
  _o.CLASSIFICATION = this.CLASSIFICATION();
  _o.TYPE = this.TYPE();
  _o.ID_PLAN = this.ID_PLAN();
  _o.PLAN_INDEX = this.PLAN_INDEX();
  _o.TASK_ID = this.TASK_ID();
  _o.DWELL_ID = this.DWELL_ID();
  _o.EXTERNAL_ID = this.EXTERNAL_ID();
  _o.ID_SENSOR = this.ID_SENSOR();
  _o.ORIG_SENSOR_ID = this.ORIG_SENSOR_ID();
  _o.OB_TYPE = this.OB_TYPE();
  _o.PRIORITY = this.PRIORITY();
  _o.TASK_CATEGORY = this.TASK_CATEGORY();
  _o.SUFFIX = this.SUFFIX();
  _o.UCT_FOLLOW_UP = this.UCT_FOLLOW_UP();
  _o.START_TIME = this.START_TIME();
  _o.END_TIME = this.END_TIME();
  _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
  _o.ORIG_OBJECT_ID = this.ORIG_OBJECT_ID();
  _o.TASK_GROUP = this.TASK_GROUP();
  _o.IRON = this.IRON();
  _o.ORBIT_REGIME = this.ORBIT_REGIME();
  _o.TARGET_SIZE = this.TARGET_SIZE();
  _o.RCS_MIN = this.RCS_MIN();
  _o.RCS = this.RCS();
  _o.RCS_MAX = this.RCS_MAX();
  _o.FREQ_MIN = this.FREQ_MIN();
  _o.FREQ = this.FREQ();
  _o.FREQ_MAX = this.FREQ_MAX();
  _o.POLARIZATION = this.POLARIZATION();
  _o.VIS_MAG_MIN = this.VIS_MAG_MIN();
  _o.VIS_MAG = this.VIS_MAG();
  _o.VIS_MAG_MAX = this.VIS_MAG_MAX();
  _o.SPECTRAL_MODEL = this.SPECTRAL_MODEL();
  _o.REFLECTANCE = this.REFLECTANCE();
  _o.IRRADIANCE = this.IRRADIANCE();
  _o.NUM_FRAMES = this.NUM_FRAMES();
  _o.FRAME_RATE = this.FRAME_RATE();
  _o.INTEGRATION_TIME = this.INTEGRATION_TIME();
  _o.NUM_TRACKS = this.NUM_TRACKS();
  _o.NUM_OBS = this.NUM_OBS();
  _o.DURATION = this.DURATION();
  _o.SRCH_PATTERN = this.SRCH_PATTERN();
  _o.SCENARIO = this.SCENARIO();
  _o.ID_ELSET = this.ID_ELSET();
  _o.ID_MANIFOLD = this.ID_MANIFOLD();
  _o.ID_STATE_VECTOR = this.ID_STATE_VECTOR();
  _o.ES_ID = this.ES_ID();
  _o.EPOCH = this.EPOCH();
  _o.SEMI_MAJOR_AXIS = this.SEMI_MAJOR_AXIS();
  _o.ECCENTRICITY = this.ECCENTRICITY();
  _o.INCLINATION = this.INCLINATION();
  _o.RAAN = this.RAAN();
  _o.ARG_OF_PERIGEE = this.ARG_OF_PERIGEE();
  _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
  _o.RA = this.RA();
  _o.DEC = this.DEC();
  _o.AZ = this.AZ();
  _o.EL = this.EL();
  _o.RANGE = this.RANGE();
  _o.EXTENT_AZ = this.EXTENT_AZ();
  _o.EXTENT_EL = this.EXTENT_EL();
  _o.EXTENT_RANGE = this.EXTENT_RANGE();
  _o.LAT = this.LAT();
  _o.LON = this.LON();
  _o.ALT = this.ALT();
  _o.STOP_LAT = this.STOP_LAT();
  _o.STOP_LON = this.STOP_LON();
  _o.STOP_ALT = this.STOP_ALT();
  _o.SRCH_INC = this.SRCH_INC();
  _o.X_ANGLE = this.X_ANGLE();
  _o.Y_ANGLE = this.Y_ANGLE();
  _o.ORIENT_ANGLE = this.ORIENT_ANGLE();
  _o.CUSTOMER = this.CUSTOMER();
  _o.NOTES = this.NOTES();
  _o.SOURCE = this.SOURCE();
  _o.ORIGIN = this.ORIGIN();
  _o.DATA_MODE = this.DATA_MODE();
}
}

export class CRMT implements flatbuffers.IGeneratedObject {
constructor(
  public ID: string|Uint8Array|null = null,
  public CLASSIFICATION: string|Uint8Array|null = null,
  public TYPE: string|Uint8Array|null = null,
  public ID_PLAN: string|Uint8Array|null = null,
  public PLAN_INDEX: number = 0,
  public TASK_ID: string|Uint8Array|null = null,
  public DWELL_ID: string|Uint8Array|null = null,
  public EXTERNAL_ID: string|Uint8Array|null = null,
  public ID_SENSOR: string|Uint8Array|null = null,
  public ORIG_SENSOR_ID: string|Uint8Array|null = null,
  public OB_TYPE: string|Uint8Array|null = null,
  public PRIORITY: string|Uint8Array|null = null,
  public TASK_CATEGORY: number = 0,
  public SUFFIX: string|Uint8Array|null = null,
  public UCT_FOLLOW_UP: boolean = false,
  public START_TIME: string|Uint8Array|null = null,
  public END_TIME: string|Uint8Array|null = null,
  public NORAD_CAT_ID: number = 0,
  public ORIG_OBJECT_ID: string|Uint8Array|null = null,
  public TASK_GROUP: string|Uint8Array|null = null,
  public IRON: number = 0,
  public ORBIT_REGIME: string|Uint8Array|null = null,
  public TARGET_SIZE: number = 0.0,
  public RCS_MIN: number = 0.0,
  public RCS: number = 0.0,
  public RCS_MAX: number = 0.0,
  public FREQ_MIN: number = 0.0,
  public FREQ: number = 0.0,
  public FREQ_MAX: number = 0.0,
  public POLARIZATION: string|Uint8Array|null = null,
  public VIS_MAG_MIN: number = 0.0,
  public VIS_MAG: number = 0.0,
  public VIS_MAG_MAX: number = 0.0,
  public SPECTRAL_MODEL: string|Uint8Array|null = null,
  public REFLECTANCE: number = 0.0,
  public IRRADIANCE: number = 0.0,
  public NUM_FRAMES: number = 0,
  public FRAME_RATE: number = 0.0,
  public INTEGRATION_TIME: number = 0.0,
  public NUM_TRACKS: number = 0,
  public NUM_OBS: number = 0,
  public DURATION: number = 0,
  public SRCH_PATTERN: string|Uint8Array|null = null,
  public SCENARIO: string|Uint8Array|null = null,
  public ID_ELSET: string|Uint8Array|null = null,
  public ID_MANIFOLD: string|Uint8Array|null = null,
  public ID_STATE_VECTOR: string|Uint8Array|null = null,
  public ES_ID: string|Uint8Array|null = null,
  public EPOCH: string|Uint8Array|null = null,
  public SEMI_MAJOR_AXIS: number = 0.0,
  public ECCENTRICITY: number = 0.0,
  public INCLINATION: number = 0.0,
  public RAAN: number = 0.0,
  public ARG_OF_PERIGEE: number = 0.0,
  public MEAN_ANOMALY: number = 0.0,
  public RA: number = 0.0,
  public DEC: number = 0.0,
  public AZ: number = 0.0,
  public EL: number = 0.0,
  public RANGE: number = 0.0,
  public EXTENT_AZ: number = 0.0,
  public EXTENT_EL: number = 0.0,
  public EXTENT_RANGE: number = 0.0,
  public LAT: number = 0.0,
  public LON: number = 0.0,
  public ALT: number = 0.0,
  public STOP_LAT: number = 0.0,
  public STOP_LON: number = 0.0,
  public STOP_ALT: number = 0.0,
  public SRCH_INC: number = 0.0,
  public X_ANGLE: number = 0.0,
  public Y_ANGLE: number = 0.0,
  public ORIENT_ANGLE: number = 0.0,
  public CUSTOMER: string|Uint8Array|null = null,
  public NOTES: string|Uint8Array|null = null,
  public SOURCE: string|Uint8Array|null = null,
  public ORIGIN: string|Uint8Array|null = null,
  public DATA_MODE: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const ID = (this.ID !== null ? builder.createString(this.ID!) : 0);
  const CLASSIFICATION = (this.CLASSIFICATION !== null ? builder.createString(this.CLASSIFICATION!) : 0);
  const TYPE = (this.TYPE !== null ? builder.createString(this.TYPE!) : 0);
  const ID_PLAN = (this.ID_PLAN !== null ? builder.createString(this.ID_PLAN!) : 0);
  const TASK_ID = (this.TASK_ID !== null ? builder.createString(this.TASK_ID!) : 0);
  const DWELL_ID = (this.DWELL_ID !== null ? builder.createString(this.DWELL_ID!) : 0);
  const EXTERNAL_ID = (this.EXTERNAL_ID !== null ? builder.createString(this.EXTERNAL_ID!) : 0);
  const ID_SENSOR = (this.ID_SENSOR !== null ? builder.createString(this.ID_SENSOR!) : 0);
  const ORIG_SENSOR_ID = (this.ORIG_SENSOR_ID !== null ? builder.createString(this.ORIG_SENSOR_ID!) : 0);
  const OB_TYPE = (this.OB_TYPE !== null ? builder.createString(this.OB_TYPE!) : 0);
  const PRIORITY = (this.PRIORITY !== null ? builder.createString(this.PRIORITY!) : 0);
  const SUFFIX = (this.SUFFIX !== null ? builder.createString(this.SUFFIX!) : 0);
  const START_TIME = (this.START_TIME !== null ? builder.createString(this.START_TIME!) : 0);
  const END_TIME = (this.END_TIME !== null ? builder.createString(this.END_TIME!) : 0);
  const ORIG_OBJECT_ID = (this.ORIG_OBJECT_ID !== null ? builder.createString(this.ORIG_OBJECT_ID!) : 0);
  const TASK_GROUP = (this.TASK_GROUP !== null ? builder.createString(this.TASK_GROUP!) : 0);
  const ORBIT_REGIME = (this.ORBIT_REGIME !== null ? builder.createString(this.ORBIT_REGIME!) : 0);
  const POLARIZATION = (this.POLARIZATION !== null ? builder.createString(this.POLARIZATION!) : 0);
  const SPECTRAL_MODEL = (this.SPECTRAL_MODEL !== null ? builder.createString(this.SPECTRAL_MODEL!) : 0);
  const SRCH_PATTERN = (this.SRCH_PATTERN !== null ? builder.createString(this.SRCH_PATTERN!) : 0);
  const SCENARIO = (this.SCENARIO !== null ? builder.createString(this.SCENARIO!) : 0);
  const ID_ELSET = (this.ID_ELSET !== null ? builder.createString(this.ID_ELSET!) : 0);
  const ID_MANIFOLD = (this.ID_MANIFOLD !== null ? builder.createString(this.ID_MANIFOLD!) : 0);
  const ID_STATE_VECTOR = (this.ID_STATE_VECTOR !== null ? builder.createString(this.ID_STATE_VECTOR!) : 0);
  const ES_ID = (this.ES_ID !== null ? builder.createString(this.ES_ID!) : 0);
  const EPOCH = (this.EPOCH !== null ? builder.createString(this.EPOCH!) : 0);
  const CUSTOMER = (this.CUSTOMER !== null ? builder.createString(this.CUSTOMER!) : 0);
  const NOTES = (this.NOTES !== null ? builder.createString(this.NOTES!) : 0);
  const SOURCE = (this.SOURCE !== null ? builder.createString(this.SOURCE!) : 0);
  const ORIGIN = (this.ORIGIN !== null ? builder.createString(this.ORIGIN!) : 0);
  const DATA_MODE = (this.DATA_MODE !== null ? builder.createString(this.DATA_MODE!) : 0);

  return CRM.createCRM(builder,
    ID,
    CLASSIFICATION,
    TYPE,
    ID_PLAN,
    this.PLAN_INDEX,
    TASK_ID,
    DWELL_ID,
    EXTERNAL_ID,
    ID_SENSOR,
    ORIG_SENSOR_ID,
    OB_TYPE,
    PRIORITY,
    this.TASK_CATEGORY,
    SUFFIX,
    this.UCT_FOLLOW_UP,
    START_TIME,
    END_TIME,
    this.NORAD_CAT_ID,
    ORIG_OBJECT_ID,
    TASK_GROUP,
    this.IRON,
    ORBIT_REGIME,
    this.TARGET_SIZE,
    this.RCS_MIN,
    this.RCS,
    this.RCS_MAX,
    this.FREQ_MIN,
    this.FREQ,
    this.FREQ_MAX,
    POLARIZATION,
    this.VIS_MAG_MIN,
    this.VIS_MAG,
    this.VIS_MAG_MAX,
    SPECTRAL_MODEL,
    this.REFLECTANCE,
    this.IRRADIANCE,
    this.NUM_FRAMES,
    this.FRAME_RATE,
    this.INTEGRATION_TIME,
    this.NUM_TRACKS,
    this.NUM_OBS,
    this.DURATION,
    SRCH_PATTERN,
    SCENARIO,
    ID_ELSET,
    ID_MANIFOLD,
    ID_STATE_VECTOR,
    ES_ID,
    EPOCH,
    this.SEMI_MAJOR_AXIS,
    this.ECCENTRICITY,
    this.INCLINATION,
    this.RAAN,
    this.ARG_OF_PERIGEE,
    this.MEAN_ANOMALY,
    this.RA,
    this.DEC,
    this.AZ,
    this.EL,
    this.RANGE,
    this.EXTENT_AZ,
    this.EXTENT_EL,
    this.EXTENT_RANGE,
    this.LAT,
    this.LON,
    this.ALT,
    this.STOP_LAT,
    this.STOP_LON,
    this.STOP_ALT,
    this.SRCH_INC,
    this.X_ANGLE,
    this.Y_ANGLE,
    this.ORIENT_ANGLE,
    CUSTOMER,
    NOTES,
    SOURCE,
    ORIGIN,
    DATA_MODE
  );
}
}
