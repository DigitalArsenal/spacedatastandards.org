// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { paymentMethod } from './paymentMethod.js';


/**
 * Purchase Request - Request to purchase data from a storefront listing
 */
export class PUR implements flatbuffers.IUnpackableObject<PURT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):PUR {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsPUR(bb:flatbuffers.ByteBuffer, obj?:PUR):PUR {
  return (obj || new PUR()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsPUR(bb:flatbuffers.ByteBuffer, obj?:PUR):PUR {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new PUR()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$PUR');
}

/**
 * Unique identifier for this purchase request
 */
REQUEST_ID():string|null
REQUEST_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
REQUEST_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the listing being purchased
 */
LISTING_ID():string|null
LISTING_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
LISTING_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Name of the pricing tier selected
 */
TIER_NAME():string|null
TIER_NAME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TIER_NAME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Peer ID of the buyer
 */
BUYER_PEER_ID():string|null
BUYER_PEER_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
BUYER_PEER_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Buyer's encryption public key for encrypted delivery
 */
BUYER_ENCRYPTION_PUBKEY(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

buyerEncryptionPubkeyLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

buyerEncryptionPubkeyArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Payment method used
 */
PAYMENT_METHOD():paymentMethod {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : paymentMethod.Crypto_ETH;
}

/**
 * Payment amount in smallest unit
 */
PAYMENT_AMOUNT():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

/**
 * Currency of payment
 */
PAYMENT_CURRENCY():string|null
PAYMENT_CURRENCY(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PAYMENT_CURRENCY(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Transaction hash for cryptocurrency payments
 */
PAYMENT_TX_HASH():string|null
PAYMENT_TX_HASH(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PAYMENT_TX_HASH(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Blockchain network: "ethereum", "solana", "bitcoin"
 */
PAYMENT_CHAIN():string|null
PAYMENT_CHAIN(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PAYMENT_CHAIN(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Reference ID for credit/fiat payments
 */
PAYMENT_REFERENCE():string|null
PAYMENT_REFERENCE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PAYMENT_REFERENCE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Ed25519 signature from buyer
 */
BUYER_SIGNATURE(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

buyerSignatureLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

buyerSignatureArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Unix timestamp of the request
 */
TIMESTAMP():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

static startPUR(builder:flatbuffers.Builder) {
  builder.startObject(13);
}

static addRequestId(builder:flatbuffers.Builder, REQUEST_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, REQUEST_IDOffset, 0);
}

static addListingId(builder:flatbuffers.Builder, LISTING_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, LISTING_IDOffset, 0);
}

static addTierName(builder:flatbuffers.Builder, TIER_NAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, TIER_NAMEOffset, 0);
}

static addBuyerPeerId(builder:flatbuffers.Builder, BUYER_PEER_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, BUYER_PEER_IDOffset, 0);
}

static addBuyerEncryptionPubkey(builder:flatbuffers.Builder, BUYER_ENCRYPTION_PUBKEYOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, BUYER_ENCRYPTION_PUBKEYOffset, 0);
}

static createBuyerEncryptionPubkeyVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startBuyerEncryptionPubkeyVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addPaymentMethod(builder:flatbuffers.Builder, PAYMENT_METHOD:paymentMethod) {
  builder.addFieldInt8(5, PAYMENT_METHOD, paymentMethod.Crypto_ETH);
}

static addPaymentAmount(builder:flatbuffers.Builder, PAYMENT_AMOUNT:bigint) {
  builder.addFieldInt64(6, PAYMENT_AMOUNT, BigInt('0'));
}

static addPaymentCurrency(builder:flatbuffers.Builder, PAYMENT_CURRENCYOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, PAYMENT_CURRENCYOffset, 0);
}

static addPaymentTxHash(builder:flatbuffers.Builder, PAYMENT_TX_HASHOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, PAYMENT_TX_HASHOffset, 0);
}

static addPaymentChain(builder:flatbuffers.Builder, PAYMENT_CHAINOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, PAYMENT_CHAINOffset, 0);
}

static addPaymentReference(builder:flatbuffers.Builder, PAYMENT_REFERENCEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, PAYMENT_REFERENCEOffset, 0);
}

static addBuyerSignature(builder:flatbuffers.Builder, BUYER_SIGNATUREOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, BUYER_SIGNATUREOffset, 0);
}

static createBuyerSignatureVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startBuyerSignatureVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addTimestamp(builder:flatbuffers.Builder, TIMESTAMP:bigint) {
  builder.addFieldInt64(12, TIMESTAMP, BigInt('0'));
}

static endPUR(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 4) // REQUEST_ID
  builder.requiredField(offset, 6) // LISTING_ID
  builder.requiredField(offset, 8) // TIER_NAME
  builder.requiredField(offset, 10) // BUYER_PEER_ID
  return offset;
}

static finishPURBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$PUR');
}

static finishSizePrefixedPURBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$PUR', true);
}

static createPUR(builder:flatbuffers.Builder, REQUEST_IDOffset:flatbuffers.Offset, LISTING_IDOffset:flatbuffers.Offset, TIER_NAMEOffset:flatbuffers.Offset, BUYER_PEER_IDOffset:flatbuffers.Offset, BUYER_ENCRYPTION_PUBKEYOffset:flatbuffers.Offset, PAYMENT_METHOD:paymentMethod, PAYMENT_AMOUNT:bigint, PAYMENT_CURRENCYOffset:flatbuffers.Offset, PAYMENT_TX_HASHOffset:flatbuffers.Offset, PAYMENT_CHAINOffset:flatbuffers.Offset, PAYMENT_REFERENCEOffset:flatbuffers.Offset, BUYER_SIGNATUREOffset:flatbuffers.Offset, TIMESTAMP:bigint):flatbuffers.Offset {
  PUR.startPUR(builder);
  PUR.addRequestId(builder, REQUEST_IDOffset);
  PUR.addListingId(builder, LISTING_IDOffset);
  PUR.addTierName(builder, TIER_NAMEOffset);
  PUR.addBuyerPeerId(builder, BUYER_PEER_IDOffset);
  PUR.addBuyerEncryptionPubkey(builder, BUYER_ENCRYPTION_PUBKEYOffset);
  PUR.addPaymentMethod(builder, PAYMENT_METHOD);
  PUR.addPaymentAmount(builder, PAYMENT_AMOUNT);
  PUR.addPaymentCurrency(builder, PAYMENT_CURRENCYOffset);
  PUR.addPaymentTxHash(builder, PAYMENT_TX_HASHOffset);
  PUR.addPaymentChain(builder, PAYMENT_CHAINOffset);
  PUR.addPaymentReference(builder, PAYMENT_REFERENCEOffset);
  PUR.addBuyerSignature(builder, BUYER_SIGNATUREOffset);
  PUR.addTimestamp(builder, TIMESTAMP);
  return PUR.endPUR(builder);
}

unpack(): PURT {
  return new PURT(
    this.REQUEST_ID(),
    this.LISTING_ID(),
    this.TIER_NAME(),
    this.BUYER_PEER_ID(),
    this.bb!.createScalarList<number>(this.BUYER_ENCRYPTION_PUBKEY.bind(this), this.buyerEncryptionPubkeyLength()),
    this.PAYMENT_METHOD(),
    this.PAYMENT_AMOUNT(),
    this.PAYMENT_CURRENCY(),
    this.PAYMENT_TX_HASH(),
    this.PAYMENT_CHAIN(),
    this.PAYMENT_REFERENCE(),
    this.bb!.createScalarList<number>(this.BUYER_SIGNATURE.bind(this), this.buyerSignatureLength()),
    this.TIMESTAMP()
  );
}


unpackTo(_o: PURT): void {
  _o.REQUEST_ID = this.REQUEST_ID();
  _o.LISTING_ID = this.LISTING_ID();
  _o.TIER_NAME = this.TIER_NAME();
  _o.BUYER_PEER_ID = this.BUYER_PEER_ID();
  _o.BUYER_ENCRYPTION_PUBKEY = this.bb!.createScalarList<number>(this.BUYER_ENCRYPTION_PUBKEY.bind(this), this.buyerEncryptionPubkeyLength());
  _o.PAYMENT_METHOD = this.PAYMENT_METHOD();
  _o.PAYMENT_AMOUNT = this.PAYMENT_AMOUNT();
  _o.PAYMENT_CURRENCY = this.PAYMENT_CURRENCY();
  _o.PAYMENT_TX_HASH = this.PAYMENT_TX_HASH();
  _o.PAYMENT_CHAIN = this.PAYMENT_CHAIN();
  _o.PAYMENT_REFERENCE = this.PAYMENT_REFERENCE();
  _o.BUYER_SIGNATURE = this.bb!.createScalarList<number>(this.BUYER_SIGNATURE.bind(this), this.buyerSignatureLength());
  _o.TIMESTAMP = this.TIMESTAMP();
}
}

export class PURT implements flatbuffers.IGeneratedObject {
constructor(
  public REQUEST_ID: string|Uint8Array|null = null,
  public LISTING_ID: string|Uint8Array|null = null,
  public TIER_NAME: string|Uint8Array|null = null,
  public BUYER_PEER_ID: string|Uint8Array|null = null,
  public BUYER_ENCRYPTION_PUBKEY: (number)[] = [],
  public PAYMENT_METHOD: paymentMethod = paymentMethod.Crypto_ETH,
  public PAYMENT_AMOUNT: bigint = BigInt('0'),
  public PAYMENT_CURRENCY: string|Uint8Array|null = null,
  public PAYMENT_TX_HASH: string|Uint8Array|null = null,
  public PAYMENT_CHAIN: string|Uint8Array|null = null,
  public PAYMENT_REFERENCE: string|Uint8Array|null = null,
  public BUYER_SIGNATURE: (number)[] = [],
  public TIMESTAMP: bigint = BigInt('0')
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const REQUEST_ID = (this.REQUEST_ID !== null ? builder.createString(this.REQUEST_ID!) : 0);
  const LISTING_ID = (this.LISTING_ID !== null ? builder.createString(this.LISTING_ID!) : 0);
  const TIER_NAME = (this.TIER_NAME !== null ? builder.createString(this.TIER_NAME!) : 0);
  const BUYER_PEER_ID = (this.BUYER_PEER_ID !== null ? builder.createString(this.BUYER_PEER_ID!) : 0);
  const BUYER_ENCRYPTION_PUBKEY = PUR.createBuyerEncryptionPubkeyVector(builder, this.BUYER_ENCRYPTION_PUBKEY);
  const PAYMENT_CURRENCY = (this.PAYMENT_CURRENCY !== null ? builder.createString(this.PAYMENT_CURRENCY!) : 0);
  const PAYMENT_TX_HASH = (this.PAYMENT_TX_HASH !== null ? builder.createString(this.PAYMENT_TX_HASH!) : 0);
  const PAYMENT_CHAIN = (this.PAYMENT_CHAIN !== null ? builder.createString(this.PAYMENT_CHAIN!) : 0);
  const PAYMENT_REFERENCE = (this.PAYMENT_REFERENCE !== null ? builder.createString(this.PAYMENT_REFERENCE!) : 0);
  const BUYER_SIGNATURE = PUR.createBuyerSignatureVector(builder, this.BUYER_SIGNATURE);

  return PUR.createPUR(builder,
    REQUEST_ID,
    LISTING_ID,
    TIER_NAME,
    BUYER_PEER_ID,
    BUYER_ENCRYPTION_PUBKEY,
    this.PAYMENT_METHOD,
    this.PAYMENT_AMOUNT,
    PAYMENT_CURRENCY,
    PAYMENT_TX_HASH,
    PAYMENT_CHAIN,
    PAYMENT_REFERENCE,
    BUYER_SIGNATURE,
    this.TIMESTAMP
  );
}
}
