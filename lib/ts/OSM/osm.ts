// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Observation Stability Message
 */
export class OSM implements flatbuffers.IUnpackableObject<OSMT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):OSM {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsOSM(bb:flatbuffers.ByteBuffer, obj?:OSM):OSM {
  return (obj || new OSM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsOSM(bb:flatbuffers.ByteBuffer, obj?:OSM):OSM {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new OSM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$OSM');
}

/**
 * Indicates whether the observation is stable or not
 */
isStable():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The number of observations
 */
numObs():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Unique identifier for the object being observed
 */
objectId():string|null
objectId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
objectId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Identifier of the sensor
 */
idSensor():string|null
idSensor(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idSensor(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Timestamp of data creation
 */
passStart():string|null
passStart(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
passStart(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Duration of the observation pass in seconds
 */
passDuration():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

static startOSM(builder:flatbuffers.Builder) {
  builder.startObject(6);
}

static addIsStable(builder:flatbuffers.Builder, isStable:boolean) {
  builder.addFieldInt8(0, +isStable, +false);
}

static addNumObs(builder:flatbuffers.Builder, numObs:number) {
  builder.addFieldInt32(1, numObs, 0);
}

static addObjectId(builder:flatbuffers.Builder, objectIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, objectIdOffset, 0);
}

static addIdSensor(builder:flatbuffers.Builder, idSensorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, idSensorOffset, 0);
}

static addPassStart(builder:flatbuffers.Builder, passStartOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, passStartOffset, 0);
}

static addPassDuration(builder:flatbuffers.Builder, passDuration:number) {
  builder.addFieldInt32(5, passDuration, 0);
}

static endOSM(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishOSMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$OSM');
}

static finishSizePrefixedOSMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$OSM', true);
}

static createOSM(builder:flatbuffers.Builder, isStable:boolean, numObs:number, objectIdOffset:flatbuffers.Offset, idSensorOffset:flatbuffers.Offset, passStartOffset:flatbuffers.Offset, passDuration:number):flatbuffers.Offset {
  OSM.startOSM(builder);
  OSM.addIsStable(builder, isStable);
  OSM.addNumObs(builder, numObs);
  OSM.addObjectId(builder, objectIdOffset);
  OSM.addIdSensor(builder, idSensorOffset);
  OSM.addPassStart(builder, passStartOffset);
  OSM.addPassDuration(builder, passDuration);
  return OSM.endOSM(builder);
}

unpack(): OSMT {
  return new OSMT(
    this.isStable(),
    this.numObs(),
    this.objectId(),
    this.idSensor(),
    this.passStart(),
    this.passDuration()
  );
}


unpackTo(_o: OSMT): void {
  _o.isStable = this.isStable();
  _o.numObs = this.numObs();
  _o.objectId = this.objectId();
  _o.idSensor = this.idSensor();
  _o.passStart = this.passStart();
  _o.passDuration = this.passDuration();
}
}

export class OSMT implements flatbuffers.IGeneratedObject {
constructor(
  public isStable: boolean = false,
  public numObs: number = 0,
  public objectId: string|Uint8Array|null = null,
  public idSensor: string|Uint8Array|null = null,
  public passStart: string|Uint8Array|null = null,
  public passDuration: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const objectId = (this.objectId !== null ? builder.createString(this.objectId!) : 0);
  const idSensor = (this.idSensor !== null ? builder.createString(this.idSensor!) : 0);
  const passStart = (this.passStart !== null ? builder.createString(this.passStart!) : 0);

  return OSM.createOSM(builder,
    this.isStable,
    this.numObs,
    objectId,
    idSensor,
    passStart,
    this.passDuration
  );
}
}
