// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { CollectMethod } from './CollectMethod.js';
import { DataMode } from './DataMode.js';
import { DeviceType } from './DeviceType.js';
import { ObservationPosition } from './ObservationPosition.js';
import { RFM, RFMT } from './RFM.js';


/**
 * Electro-Optical Observation
 */
export class EOO implements flatbuffers.IUnpackableObject<EOOT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):EOO {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsEOO(bb:flatbuffers.ByteBuffer, obj?:EOO):EOO {
  return (obj || new EOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsEOO(bb:flatbuffers.ByteBuffer, obj?:EOO):EOO {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new EOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$EOO');
}

/**
 * Unique identifier of the record.
 */
ID():string|null
ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 */
CLASSIFICATION():string|null
CLASSIFICATION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CLASSIFICATION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Ob detection time in ISO 8601 UTC (YYYY-MM-DDTHH:MM:SS.ssssssZ), up to microsecond precision.
 */
OB_TIME():string|null
OB_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
OB_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Correlation score of the observation when compared to a known orbit state.
 */
CORR_QUALITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Server will auto-populate with SAT_NO if available.
 */
ID_ON_ORBIT():string|null
ID_ON_ORBIT(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID_ON_ORBIT(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique ID of the sensor. Must have a corresponding sensor record on the server.
 */
SENSOR_ID():string|null
SENSOR_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SENSOR_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Accepted Collection Method
 */
COLLECT_METHOD():CollectMethod {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : CollectMethod.SIDEREAL;
}

/**
 * 18SDS satellite number. Only list if correlated against the 18SDS catalog.
 */
NORAD_CAT_ID():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Identifier for the collectRequest message if the collection was in response to tasking.
 */
TASK_ID():string|null
TASK_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TASK_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional identifier to track a transaction.
 */
TRANSACTION_ID():string|null
TRANSACTION_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TRANSACTION_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The user-defined set ID of a sequence of images.
 */
IMAGE_SET_ID():string|null
IMAGE_SET_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
IMAGE_SET_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The number of images in an image set.
 */
IMAGE_SET_LENGTH():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The sequence ID of an image within an image set.
 */
SEQUENCE_ID():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).
 */
OB_POSITION():ObservationPosition {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : ObservationPosition.FENCE;
}

/**
 * Provider maintained ID. May not be consistent with 18SDS SAT_NO.
 */
ORIG_OBJECT_ID():string|null
ORIG_OBJECT_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIG_OBJECT_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Sensor ID.
 */
ORIG_SENSOR_ID():string|null
ORIG_SENSOR_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIG_SENSOR_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Required if correlation is attempted. Indicates whether correlation succeeded.
 */
UCT():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Line of sight azimuth angle in degrees and topocentric frame.
 */
AZIMUTH():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight azimuth angle, in degrees.
 */
AZIMUTH_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor line of sight azimuth angle bias in degrees.
 */
AZIMUTH_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Rate of change of the line of sight azimuth in degrees per second.
 */
AZIMUTH_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Line of sight elevation in degrees and topocentric frame.
 */
ELEVATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight elevation angle, in degrees.
 */
ELEVATION_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor line of sight elevation bias in degrees.
 */
ELEVATION_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Rate of change of the line of sight elevation in degrees per second.
 */
ELEVATION_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Line of sight range in km. Reported value should include all applicable corrections.
 */
RANGE():number {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight range, in km.
 */
RANGE_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor line of sight range bias in km.
 */
RANGE_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Range rate in km/s. Reported value should include all applicable corrections.
 */
RANGE_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight range rate, in km/sec.
 */
RANGE_RATE_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Right ascension in degrees. Required metric reporting field for EO observations.
 */
RA():number {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Line of sight right ascension rate of change, in degrees/sec.
 */
RA_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight right ascension angle, in degrees.
 */
RA_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor line of sight right ascension bias in degrees.
 */
RA_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Declination in degrees. Required metric reporting field for EO observations.
 */
DECLINATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 72);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Line of sight declination rate of change, in degrees/sec.
 */
DECLINATION_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 74);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight declination angle, in degrees.
 */
DECLINATION_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 76);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor line of sight declination angle bias in degrees.
 */
DECLINATION_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 78);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * X-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
 */
LOSX():number {
  const offset = this.bb!.__offset(this.bb_pos, 80);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Y-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
 */
LOSY():number {
  const offset = this.bb!.__offset(this.bb_pos, 82);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Z-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
 */
LOSZ():number {
  const offset = this.bb!.__offset(this.bb_pos, 84);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line-of-sight direction vector components.
 */
LOS_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 86);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * X-component of the velocity vector along the line of sight, in km/s.
 */
LOSXVEL():number {
  const offset = this.bb!.__offset(this.bb_pos, 88);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Y-component of the velocity vector along the line of sight, in km/s.
 */
LOSYVEL():number {
  const offset = this.bb!.__offset(this.bb_pos, 90);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Z-component of the velocity vector along the line of sight, in km/s.
 */
LOSZVEL():number {
  const offset = this.bb!.__offset(this.bb_pos, 92);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * WGS-84 latitude in decimal degrees at the time of the observation.
 */
SENLAT():number {
  const offset = this.bb!.__offset(this.bb_pos, 94);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * WGS-84 longitude in decimal degrees at the time of the observation.
 */
SENLON():number {
  const offset = this.bb!.__offset(this.bb_pos, 96);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor height in km relative to the WGS-84 ellipsoid at the time of the observation.
 */
SENALT():number {
  const offset = this.bb!.__offset(this.bb_pos, 98);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Cartesian X position in km at the time of the observation.
 */
SENX():number {
  const offset = this.bb!.__offset(this.bb_pos, 100);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Cartesian Y position in km at the time of the observation.
 */
SENY():number {
  const offset = this.bb!.__offset(this.bb_pos, 102);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Cartesian Z position in km at the time of the observation.
 */
SENZ():number {
  const offset = this.bb!.__offset(this.bb_pos, 104);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Total number of satellites in the field of view.
 */
FOV_COUNT():number {
  const offset = this.bb!.__offset(this.bb_pos, 106);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Number of uncorrelated satellites in the field of view (JCO).
 */
FOV_COUNT_UCTS():number {
  const offset = this.bb!.__offset(this.bb_pos, 108);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Image exposure duration in seconds. For observations performed using frame stacking or synthetic tracking methods, 
 * the exposure duration should be the total integration time. This field is highly recommended / required if the 
 * observations are going to be used for photometric processing.
 */
EXP_DURATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 110);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Formula: 2.5 * log_10 (zero_mag_counts / EXP_DURATION).
 */
ZEROPTD():number {
  const offset = this.bb!.__offset(this.bb_pos, 112);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Net object signature = counts / EXP_DURATION.
 */
NET_OBJ_SIG():number {
  const offset = this.bb!.__offset(this.bb_pos, 114);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Net object signature uncertainty = counts uncertainty / EXP_DURATION.
 */
NET_OBJ_SIG_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 116);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Measure of observed brightness calibrated against the Gaia G-band.
 */
MAG():number {
  const offset = this.bb!.__offset(this.bb_pos, 118);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Uncertainty of the observed brightness.
 */
MAG_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 120);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * [Definition needed].
 */
MAG_NORM_RANGE():number {
  const offset = this.bb!.__offset(this.bb_pos, 122);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Computed estimate of the latitude, positive degrees north. It should be computed based on the assumed slant range 
 * and corresponding viewing geometry. It must NOT be computed from the orbit state.
 */
GEOLAT():number {
  const offset = this.bb!.__offset(this.bb_pos, 124);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Computed estimate of the longitude as +/- 180 degrees east. It should be computed based on the assumed slant range 
 * and viewing geometry. It must NOT be computed from the orbit state.
 */
GEOLON():number {
  const offset = this.bb!.__offset(this.bb_pos, 126);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Computed estimate of satellite altitude in km at the reported location. It must NOT be computed from the orbit state.
 */
GEOALT():number {
  const offset = this.bb!.__offset(this.bb_pos, 128);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Computed estimate of the slant range in km. It must NOT be computed from the orbit state.
 */
GEORANGE():number {
  const offset = this.bb!.__offset(this.bb_pos, 130);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently 
 * empty part of the night sky.
 */
SKY_BKGRND():number {
  const offset = this.bb!.__offset(this.bb_pos, 132);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass 
 * to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general, 
 * describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical 
 * object and the observer.
 */
PRIMARY_EXTINCTION():number {
  const offset = this.bb!.__offset(this.bb_pos, 134);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Primary Extinction Coefficient Uncertainty, in Magnitudes.
 */
PRIMARY_EXTINCTION_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 136);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * The angle, in degrees, between the target-to-observer vector and the target-to-sun vector. Recommend using the 
 * calculation listed in the EOSSA documentation, pg 106 of the EOSSA spec.
 */
SOLAR_PHASE_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 138);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector 
 * onto the equatorial plane. The convention used is negative when closing (i.e., before the opposition) 
 * and positive when opening (after the opposition).
 */
SOLAR_EQ_PHASE_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 140);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Angle from the sun to the equatorial plane.
 */
SOLAR_DEC_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 142);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Shutter delay in seconds.
 */
SHUTTER_DELAY():number {
  const offset = this.bb!.__offset(this.bb_pos, 144);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor timing bias in seconds.
 */
TIMING_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 146);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Optional URI location in the document repository of the raw file parsed by the system to produce this record. 
 */
RAW_FILE_URI():string|null
RAW_FILE_URI(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
RAW_FILE_URI(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 148);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Intensity of the target for IR observations, in kw/sr/em.
 */
INTENSITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 150);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Background intensity for IR observations, in kw/sr/um.
 */
BG_INTENSITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 152);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Optional source-provided and searchable metadata or descriptor of the data.
 */
DESCRIPTOR():string|null
DESCRIPTOR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
DESCRIPTOR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 154);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Source of the data.
 */
SOURCE():string|null
SOURCE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SOURCE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 156);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Originating system or organization which produced the data, if different from the source.
 * The origin may be different than the source if the source was a mediating system which forwarded 
 * the data on behalf of the origin system. If null, the source may be assumed to be the origin.
 */
ORIGIN():string|null
ORIGIN(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIGIN(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 158);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST.
 */
DATA_MODE():DataMode {
  const offset = this.bb!.__offset(this.bb_pos, 160);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : DataMode.EXERCISE;
}

/**
 * Time the row was created in the database, auto-populated by the system.
 */
CREATED_AT():string|null
CREATED_AT(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CREATED_AT(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 162);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Application user who created the row in the database, auto-populated by the system.
 */
CREATED_BY():string|null
CREATED_BY(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CREATED_BY(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 164);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * EO observations are assumed to be topocentric J2000 coordinates ('J2000') as defined by the IAU, unless otherwise specified.
 */
REFERENCE_FRAME(obj?:RFM):RFM|null {
  const offset = this.bb!.__offset(this.bb_pos, 166);
  return offset ? (obj || new RFM()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * The sensor reference frame is assumed to be the International Terrestrial Reference Frame (ITRF), 
 * unless otherwise specified. (ITRF is equivalent to Earth-Centered Earth-Fixed (ECEF) for this purpose). 
 * Lat / long / height values should be reported using the WGS-84 ellipsoid, where applicable.
 */
SEN_REFERENCE_FRAME(obj?:RFM):RFM|null {
  const offset = this.bb!.__offset(this.bb_pos, 168);
  return offset ? (obj || new RFM()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Boolean indicating that the target object was in umbral eclipse at the time of this observation.
 */
UMBRA():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 170);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
 * This field is highly recommended if the observations will be used for photometric processing.
 */
PENUMBRA():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 172);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The originating source network on which this record was created, auto-populated by the system.
 */
ORIG_NETWORK():string|null
ORIG_NETWORK(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIG_NETWORK(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 174);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The source from which this record was received.
 */
SOURCE_DL():string|null
SOURCE_DL(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SOURCE_DL(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 176);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Device Type
 */
TYPE():DeviceType {
  const offset = this.bb!.__offset(this.bb_pos, 178);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : DeviceType.UNKNOWN;
}

/**
 * True if measured, false if computed. Required if azimuth is reported.
 */
AZIMUTH_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 180);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if measured, false if computed. Required if elevation is reported.
 */
ELEVATION_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 182);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if measured, false if computed. Required if range is reported.
 */
RANGE_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 184);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if measured, false if computed. Required if range-rate is reported.
 */
RANGERATE_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 186);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if measured, false if computed. Required if right ascension is reported.
 */
RA_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 188);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if measured, false if computed. Required if declination is reported.
 */
DECLINATION_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 190);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * National Imagery Interpretability Rating Scale (NIIRS). Ranging from 0 (lowest) to 9 (highest).
 */
NIIRS():number {
  const offset = this.bb!.__offset(this.bb_pos, 192);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Ground sample distance in meters per pixel.
 */
METERS_PER_PIXEL():number {
  const offset = this.bb!.__offset(this.bb_pos, 194);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Signal-to-noise ratio of the image. Higher values indicate cleaner imagery.
 */
IMAGE_SNR():number {
  const offset = this.bb!.__offset(this.bb_pos, 196);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Bit depth of the image (e.g., 8, 12, 16).
 */
IMAGE_BIT_DEPTH():number {
  const offset = this.bb!.__offset(this.bb_pos, 198);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Width of the image in pixels.
 */
IMAGE_WIDTH():number {
  const offset = this.bb!.__offset(this.bb_pos, 200);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Height of the image in pixels.
 */
IMAGE_HEIGHT():number {
  const offset = this.bb!.__offset(this.bb_pos, 202);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Compression type used for the image, e.g., "JPEG", "PNG", "RAW", etc.
 */
IMAGE_COMPRESSION():string|null
IMAGE_COMPRESSION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
IMAGE_COMPRESSION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 204);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Compression ratio used (original size / compressed size), if applicable.
 */
IMAGE_COMPRESSION_RATIO():number {
  const offset = this.bb!.__offset(this.bb_pos, 206);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * URI to the processed image used for this observation.
 */
PROCESSED_IMAGE_URI():string|null
PROCESSED_IMAGE_URI(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PROCESSED_IMAGE_URI(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 208);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Flag indicating whether the image was auto-enhanced (e.g., contrast stretch, denoise).
 */
IMAGE_AUTO_ENHANCED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 210);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if the observation was taken with multiple frames stacked into one image.
 */
MULTI_FRAME_STACKED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 212);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if synthetic tracking was used to create the image.
 */
SYNTHETIC_TRACKING_USED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 214);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Sharpness metric of the image based on the Tenengrad method or variance of Laplacian. Higher values indicate sharper images.
 */
IMAGE_SHARPNESS():number {
  const offset = this.bb!.__offset(this.bb_pos, 216);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Noise level of the image, estimated via pixel intensity variance in background regions.
 */
IMAGE_NOISE_STDDEV():number {
  const offset = this.bb!.__offset(this.bb_pos, 218);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Contrast metric of the image, such as Michelson contrast or RMS contrast.
 */
IMAGE_CONTRAST():number {
  const offset = this.bb!.__offset(this.bb_pos, 220);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Dynamic range of the image (max pixel value / min pixel value), indicating tonal spread.
 */
IMAGE_DYNAMIC_RANGE():number {
  const offset = this.bb!.__offset(this.bb_pos, 222);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Entropy of the image, representing the richness of information content. Higher entropy suggests higher texture detail.
 */
IMAGE_ENTROPY():number {
  const offset = this.bb!.__offset(this.bb_pos, 224);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Background uniformity metric (e.g., mean gradient in background areas). Lower values indicate more uniform background.
 */
BACKGROUND_UNIFORMITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 226);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Mean background level, computed from non-object regions in pixel units.
 */
BACKGROUND_MEAN_LEVEL():number {
  const offset = this.bb!.__offset(this.bb_pos, 228);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Percentage of saturated pixels in the image. Indicates overexposure when high.
 */
SATURATED_PIXEL_PERCENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 230);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Percentage of dead or zero-value pixels in the image. Indicates sensor defects or underexposure.
 */
DEAD_PIXEL_PERCENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 232);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Estimated Point Spread Function (PSF) Full Width at Half Maximum (FWHM) in pixels. Indicates image blur or focus.
 */
PSF_FWHM():number {
  const offset = this.bb!.__offset(this.bb_pos, 234);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Estimated percentage of cloud cover in the image. Derived using cloud detection algorithms such as Fmask or machine learning classifiers.
 */
CLOUD_COVER_PERCENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 236);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Confidence score of the cloud detection result, from 0 (low confidence) to 1 (high confidence).
 */
CLOUD_DETECTION_CONFIDENCE():number {
  const offset = this.bb!.__offset(this.bb_pos, 238);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Estimated percentage of the image obscured by haze or atmospheric scattering effects.
 */
HAZE_PERCENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 240);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Estimated aerosol optical thickness (AOT) at 550 nm, indicating particulate matter in the atmosphere affecting image clarity.
 */
AEROSOL_OPTICAL_THICKNESS():number {
  const offset = this.bb!.__offset(this.bb_pos, 242);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Estimated water vapor content (e.g., total column precipitable water) at the time of imaging, in mm.
 */
WATER_VAPOR_CONTENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 244);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sun elevation angle at the time of image capture, in degrees above the horizon.
 */
SUN_ELEVATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 246);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sun azimuth angle at the time of image capture, in degrees from true north.
 */
SUN_AZIMUTH():number {
  const offset = this.bb!.__offset(this.bb_pos, 248);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * View zenith angle (sensor line-of-sight angle from nadir), in degrees.
 */
VIEW_ZENITH_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 250);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * View azimuth angle (direction of sensor relative to north), in degrees.
 */
VIEW_AZIMUTH_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 252);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Off-nadir angle of the sensor at the time of image capture, in degrees.
 */
OFF_NADIR_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 254);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Ground coverage width of the image swath in kilometers.
 */
SWATH_WIDTH_KM():number {
  const offset = this.bb!.__offset(this.bb_pos, 256);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Mean terrain elevation in the image footprint, in meters above sea level.
 */
MEAN_TERRAIN_ELEVATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 258);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Standard deviation of terrain elevation in the image footprint, in meters.
 */
TERRAIN_ELEVATION_STDDEV():number {
  const offset = this.bb!.__offset(this.bb_pos, 260);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Percentage of the image affected by shadows, derived via topographic or object shadow detection.
 */
SHADOW_COVER_PERCENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 262);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Flag indicating whether sunglint is present in the image (true if high reflectance from water surface due to sun geometry).
 */
SUNGLINT_PRESENT():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 264);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Percentage of image affected by sunglint.
 */
SUNGLINT_PERCENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 266);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Estimated percentage of snow or ice coverage in the image footprint.
 */
SNOW_ICE_COVER_PERCENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 268);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Total area covered by valid data (non-masked, usable imagery) in square kilometers.
 */
VALID_DATA_AREA_KM2():number {
  const offset = this.bb!.__offset(this.bb_pos, 270);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

static startEOO(builder:flatbuffers.Builder) {
  builder.startObject(134);
}

static addId(builder:flatbuffers.Builder, IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, IDOffset, 0);
}

static addClassification(builder:flatbuffers.Builder, CLASSIFICATIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, CLASSIFICATIONOffset, 0);
}

static addObTime(builder:flatbuffers.Builder, OB_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, OB_TIMEOffset, 0);
}

static addCorrQuality(builder:flatbuffers.Builder, CORR_QUALITY:number) {
  builder.addFieldFloat32(3, CORR_QUALITY, 0.0);
}

static addIdOnOrbit(builder:flatbuffers.Builder, ID_ON_ORBITOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, ID_ON_ORBITOffset, 0);
}

static addSensorId(builder:flatbuffers.Builder, SENSOR_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, SENSOR_IDOffset, 0);
}

static addCollectMethod(builder:flatbuffers.Builder, COLLECT_METHOD:CollectMethod) {
  builder.addFieldInt8(6, COLLECT_METHOD, CollectMethod.SIDEREAL);
}

static addNoradCatId(builder:flatbuffers.Builder, NORAD_CAT_ID:number) {
  builder.addFieldInt32(7, NORAD_CAT_ID, 0);
}

static addTaskId(builder:flatbuffers.Builder, TASK_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, TASK_IDOffset, 0);
}

static addTransactionId(builder:flatbuffers.Builder, TRANSACTION_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, TRANSACTION_IDOffset, 0);
}

static addImageSetId(builder:flatbuffers.Builder, IMAGE_SET_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, IMAGE_SET_IDOffset, 0);
}

static addImageSetLength(builder:flatbuffers.Builder, IMAGE_SET_LENGTH:number) {
  builder.addFieldInt32(11, IMAGE_SET_LENGTH, 0);
}

static addSequenceId(builder:flatbuffers.Builder, SEQUENCE_ID:number) {
  builder.addFieldInt32(12, SEQUENCE_ID, 0);
}

static addObPosition(builder:flatbuffers.Builder, OB_POSITION:ObservationPosition) {
  builder.addFieldInt8(13, OB_POSITION, ObservationPosition.FENCE);
}

static addOrigObjectId(builder:flatbuffers.Builder, ORIG_OBJECT_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(14, ORIG_OBJECT_IDOffset, 0);
}

static addOrigSensorId(builder:flatbuffers.Builder, ORIG_SENSOR_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, ORIG_SENSOR_IDOffset, 0);
}

static addUct(builder:flatbuffers.Builder, UCT:boolean) {
  builder.addFieldInt8(16, +UCT, +false);
}

static addAzimuth(builder:flatbuffers.Builder, AZIMUTH:number) {
  builder.addFieldFloat32(17, AZIMUTH, 0.0);
}

static addAzimuthUnc(builder:flatbuffers.Builder, AZIMUTH_UNC:number) {
  builder.addFieldFloat32(18, AZIMUTH_UNC, 0.0);
}

static addAzimuthBias(builder:flatbuffers.Builder, AZIMUTH_BIAS:number) {
  builder.addFieldFloat32(19, AZIMUTH_BIAS, 0.0);
}

static addAzimuthRate(builder:flatbuffers.Builder, AZIMUTH_RATE:number) {
  builder.addFieldFloat32(20, AZIMUTH_RATE, 0.0);
}

static addElevation(builder:flatbuffers.Builder, ELEVATION:number) {
  builder.addFieldFloat32(21, ELEVATION, 0.0);
}

static addElevationUnc(builder:flatbuffers.Builder, ELEVATION_UNC:number) {
  builder.addFieldFloat32(22, ELEVATION_UNC, 0.0);
}

static addElevationBias(builder:flatbuffers.Builder, ELEVATION_BIAS:number) {
  builder.addFieldFloat32(23, ELEVATION_BIAS, 0.0);
}

static addElevationRate(builder:flatbuffers.Builder, ELEVATION_RATE:number) {
  builder.addFieldFloat32(24, ELEVATION_RATE, 0.0);
}

static addRange(builder:flatbuffers.Builder, RANGE:number) {
  builder.addFieldFloat32(25, RANGE, 0.0);
}

static addRangeUnc(builder:flatbuffers.Builder, RANGE_UNC:number) {
  builder.addFieldFloat32(26, RANGE_UNC, 0.0);
}

static addRangeBias(builder:flatbuffers.Builder, RANGE_BIAS:number) {
  builder.addFieldFloat32(27, RANGE_BIAS, 0.0);
}

static addRangeRate(builder:flatbuffers.Builder, RANGE_RATE:number) {
  builder.addFieldFloat32(28, RANGE_RATE, 0.0);
}

static addRangeRateUnc(builder:flatbuffers.Builder, RANGE_RATE_UNC:number) {
  builder.addFieldFloat32(29, RANGE_RATE_UNC, 0.0);
}

static addRa(builder:flatbuffers.Builder, RA:number) {
  builder.addFieldFloat32(30, RA, 0.0);
}

static addRaRate(builder:flatbuffers.Builder, RA_RATE:number) {
  builder.addFieldFloat32(31, RA_RATE, 0.0);
}

static addRaUnc(builder:flatbuffers.Builder, RA_UNC:number) {
  builder.addFieldFloat32(32, RA_UNC, 0.0);
}

static addRaBias(builder:flatbuffers.Builder, RA_BIAS:number) {
  builder.addFieldFloat32(33, RA_BIAS, 0.0);
}

static addDeclination(builder:flatbuffers.Builder, DECLINATION:number) {
  builder.addFieldFloat32(34, DECLINATION, 0.0);
}

static addDeclinationRate(builder:flatbuffers.Builder, DECLINATION_RATE:number) {
  builder.addFieldFloat32(35, DECLINATION_RATE, 0.0);
}

static addDeclinationUnc(builder:flatbuffers.Builder, DECLINATION_UNC:number) {
  builder.addFieldFloat32(36, DECLINATION_UNC, 0.0);
}

static addDeclinationBias(builder:flatbuffers.Builder, DECLINATION_BIAS:number) {
  builder.addFieldFloat32(37, DECLINATION_BIAS, 0.0);
}

static addLosx(builder:flatbuffers.Builder, LOSX:number) {
  builder.addFieldFloat32(38, LOSX, 0.0);
}

static addLosy(builder:flatbuffers.Builder, LOSY:number) {
  builder.addFieldFloat32(39, LOSY, 0.0);
}

static addLosz(builder:flatbuffers.Builder, LOSZ:number) {
  builder.addFieldFloat32(40, LOSZ, 0.0);
}

static addLosUnc(builder:flatbuffers.Builder, LOS_UNC:number) {
  builder.addFieldFloat32(41, LOS_UNC, 0.0);
}

static addLosxvel(builder:flatbuffers.Builder, LOSXVEL:number) {
  builder.addFieldFloat32(42, LOSXVEL, 0.0);
}

static addLosyvel(builder:flatbuffers.Builder, LOSYVEL:number) {
  builder.addFieldFloat32(43, LOSYVEL, 0.0);
}

static addLoszvel(builder:flatbuffers.Builder, LOSZVEL:number) {
  builder.addFieldFloat32(44, LOSZVEL, 0.0);
}

static addSenlat(builder:flatbuffers.Builder, SENLAT:number) {
  builder.addFieldFloat32(45, SENLAT, 0.0);
}

static addSenlon(builder:flatbuffers.Builder, SENLON:number) {
  builder.addFieldFloat32(46, SENLON, 0.0);
}

static addSenalt(builder:flatbuffers.Builder, SENALT:number) {
  builder.addFieldFloat32(47, SENALT, 0.0);
}

static addSenx(builder:flatbuffers.Builder, SENX:number) {
  builder.addFieldFloat32(48, SENX, 0.0);
}

static addSeny(builder:flatbuffers.Builder, SENY:number) {
  builder.addFieldFloat32(49, SENY, 0.0);
}

static addSenz(builder:flatbuffers.Builder, SENZ:number) {
  builder.addFieldFloat32(50, SENZ, 0.0);
}

static addFovCount(builder:flatbuffers.Builder, FOV_COUNT:number) {
  builder.addFieldInt32(51, FOV_COUNT, 0);
}

static addFovCountUcts(builder:flatbuffers.Builder, FOV_COUNT_UCTS:number) {
  builder.addFieldInt32(52, FOV_COUNT_UCTS, 0);
}

static addExpDuration(builder:flatbuffers.Builder, EXP_DURATION:number) {
  builder.addFieldFloat32(53, EXP_DURATION, 0.0);
}

static addZeroptd(builder:flatbuffers.Builder, ZEROPTD:number) {
  builder.addFieldFloat32(54, ZEROPTD, 0.0);
}

static addNetObjSig(builder:flatbuffers.Builder, NET_OBJ_SIG:number) {
  builder.addFieldFloat32(55, NET_OBJ_SIG, 0.0);
}

static addNetObjSigUnc(builder:flatbuffers.Builder, NET_OBJ_SIG_UNC:number) {
  builder.addFieldFloat32(56, NET_OBJ_SIG_UNC, 0.0);
}

static addMag(builder:flatbuffers.Builder, MAG:number) {
  builder.addFieldFloat32(57, MAG, 0.0);
}

static addMagUnc(builder:flatbuffers.Builder, MAG_UNC:number) {
  builder.addFieldFloat32(58, MAG_UNC, 0.0);
}

static addMagNormRange(builder:flatbuffers.Builder, MAG_NORM_RANGE:number) {
  builder.addFieldFloat32(59, MAG_NORM_RANGE, 0.0);
}

static addGeolat(builder:flatbuffers.Builder, GEOLAT:number) {
  builder.addFieldFloat32(60, GEOLAT, 0.0);
}

static addGeolon(builder:flatbuffers.Builder, GEOLON:number) {
  builder.addFieldFloat32(61, GEOLON, 0.0);
}

static addGeoalt(builder:flatbuffers.Builder, GEOALT:number) {
  builder.addFieldFloat32(62, GEOALT, 0.0);
}

static addGeorange(builder:flatbuffers.Builder, GEORANGE:number) {
  builder.addFieldFloat32(63, GEORANGE, 0.0);
}

static addSkyBkgrnd(builder:flatbuffers.Builder, SKY_BKGRND:number) {
  builder.addFieldFloat32(64, SKY_BKGRND, 0.0);
}

static addPrimaryExtinction(builder:flatbuffers.Builder, PRIMARY_EXTINCTION:number) {
  builder.addFieldFloat32(65, PRIMARY_EXTINCTION, 0.0);
}

static addPrimaryExtinctionUnc(builder:flatbuffers.Builder, PRIMARY_EXTINCTION_UNC:number) {
  builder.addFieldFloat32(66, PRIMARY_EXTINCTION_UNC, 0.0);
}

static addSolarPhaseAngle(builder:flatbuffers.Builder, SOLAR_PHASE_ANGLE:number) {
  builder.addFieldFloat32(67, SOLAR_PHASE_ANGLE, 0.0);
}

static addSolarEqPhaseAngle(builder:flatbuffers.Builder, SOLAR_EQ_PHASE_ANGLE:number) {
  builder.addFieldFloat32(68, SOLAR_EQ_PHASE_ANGLE, 0.0);
}

static addSolarDecAngle(builder:flatbuffers.Builder, SOLAR_DEC_ANGLE:number) {
  builder.addFieldFloat32(69, SOLAR_DEC_ANGLE, 0.0);
}

static addShutterDelay(builder:flatbuffers.Builder, SHUTTER_DELAY:number) {
  builder.addFieldFloat32(70, SHUTTER_DELAY, 0.0);
}

static addTimingBias(builder:flatbuffers.Builder, TIMING_BIAS:number) {
  builder.addFieldFloat32(71, TIMING_BIAS, 0.0);
}

static addRawFileUri(builder:flatbuffers.Builder, RAW_FILE_URIOffset:flatbuffers.Offset) {
  builder.addFieldOffset(72, RAW_FILE_URIOffset, 0);
}

static addIntensity(builder:flatbuffers.Builder, INTENSITY:number) {
  builder.addFieldFloat32(73, INTENSITY, 0.0);
}

static addBgIntensity(builder:flatbuffers.Builder, BG_INTENSITY:number) {
  builder.addFieldFloat32(74, BG_INTENSITY, 0.0);
}

static addDescriptor(builder:flatbuffers.Builder, DESCRIPTOROffset:flatbuffers.Offset) {
  builder.addFieldOffset(75, DESCRIPTOROffset, 0);
}

static addSource(builder:flatbuffers.Builder, SOURCEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(76, SOURCEOffset, 0);
}

static addOrigin(builder:flatbuffers.Builder, ORIGINOffset:flatbuffers.Offset) {
  builder.addFieldOffset(77, ORIGINOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, DATA_MODE:DataMode) {
  builder.addFieldInt8(78, DATA_MODE, DataMode.EXERCISE);
}

static addCreatedAt(builder:flatbuffers.Builder, CREATED_ATOffset:flatbuffers.Offset) {
  builder.addFieldOffset(79, CREATED_ATOffset, 0);
}

static addCreatedBy(builder:flatbuffers.Builder, CREATED_BYOffset:flatbuffers.Offset) {
  builder.addFieldOffset(80, CREATED_BYOffset, 0);
}

static addReferenceFrame(builder:flatbuffers.Builder, REFERENCE_FRAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(81, REFERENCE_FRAMEOffset, 0);
}

static addSenReferenceFrame(builder:flatbuffers.Builder, SEN_REFERENCE_FRAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(82, SEN_REFERENCE_FRAMEOffset, 0);
}

static addUmbra(builder:flatbuffers.Builder, UMBRA:boolean) {
  builder.addFieldInt8(83, +UMBRA, +false);
}

static addPenumbra(builder:flatbuffers.Builder, PENUMBRA:boolean) {
  builder.addFieldInt8(84, +PENUMBRA, +false);
}

static addOrigNetwork(builder:flatbuffers.Builder, ORIG_NETWORKOffset:flatbuffers.Offset) {
  builder.addFieldOffset(85, ORIG_NETWORKOffset, 0);
}

static addSourceDl(builder:flatbuffers.Builder, SOURCE_DLOffset:flatbuffers.Offset) {
  builder.addFieldOffset(86, SOURCE_DLOffset, 0);
}

static addType(builder:flatbuffers.Builder, TYPE:DeviceType) {
  builder.addFieldInt8(87, TYPE, DeviceType.UNKNOWN);
}

static addAzimuthMeasured(builder:flatbuffers.Builder, AZIMUTH_MEASURED:boolean) {
  builder.addFieldInt8(88, +AZIMUTH_MEASURED, +false);
}

static addElevationMeasured(builder:flatbuffers.Builder, ELEVATION_MEASURED:boolean) {
  builder.addFieldInt8(89, +ELEVATION_MEASURED, +false);
}

static addRangeMeasured(builder:flatbuffers.Builder, RANGE_MEASURED:boolean) {
  builder.addFieldInt8(90, +RANGE_MEASURED, +false);
}

static addRangerateMeasured(builder:flatbuffers.Builder, RANGERATE_MEASURED:boolean) {
  builder.addFieldInt8(91, +RANGERATE_MEASURED, +false);
}

static addRaMeasured(builder:flatbuffers.Builder, RA_MEASURED:boolean) {
  builder.addFieldInt8(92, +RA_MEASURED, +false);
}

static addDeclinationMeasured(builder:flatbuffers.Builder, DECLINATION_MEASURED:boolean) {
  builder.addFieldInt8(93, +DECLINATION_MEASURED, +false);
}

static addNiirs(builder:flatbuffers.Builder, NIIRS:number) {
  builder.addFieldFloat32(94, NIIRS, 0.0);
}

static addMetersPerPixel(builder:flatbuffers.Builder, METERS_PER_PIXEL:number) {
  builder.addFieldFloat32(95, METERS_PER_PIXEL, 0.0);
}

static addImageSnr(builder:flatbuffers.Builder, IMAGE_SNR:number) {
  builder.addFieldFloat32(96, IMAGE_SNR, 0.0);
}

static addImageBitDepth(builder:flatbuffers.Builder, IMAGE_BIT_DEPTH:number) {
  builder.addFieldInt32(97, IMAGE_BIT_DEPTH, 0);
}

static addImageWidth(builder:flatbuffers.Builder, IMAGE_WIDTH:number) {
  builder.addFieldInt32(98, IMAGE_WIDTH, 0);
}

static addImageHeight(builder:flatbuffers.Builder, IMAGE_HEIGHT:number) {
  builder.addFieldInt32(99, IMAGE_HEIGHT, 0);
}

static addImageCompression(builder:flatbuffers.Builder, IMAGE_COMPRESSIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(100, IMAGE_COMPRESSIONOffset, 0);
}

static addImageCompressionRatio(builder:flatbuffers.Builder, IMAGE_COMPRESSION_RATIO:number) {
  builder.addFieldFloat32(101, IMAGE_COMPRESSION_RATIO, 0.0);
}

static addProcessedImageUri(builder:flatbuffers.Builder, PROCESSED_IMAGE_URIOffset:flatbuffers.Offset) {
  builder.addFieldOffset(102, PROCESSED_IMAGE_URIOffset, 0);
}

static addImageAutoEnhanced(builder:flatbuffers.Builder, IMAGE_AUTO_ENHANCED:boolean) {
  builder.addFieldInt8(103, +IMAGE_AUTO_ENHANCED, +false);
}

static addMultiFrameStacked(builder:flatbuffers.Builder, MULTI_FRAME_STACKED:boolean) {
  builder.addFieldInt8(104, +MULTI_FRAME_STACKED, +false);
}

static addSyntheticTrackingUsed(builder:flatbuffers.Builder, SYNTHETIC_TRACKING_USED:boolean) {
  builder.addFieldInt8(105, +SYNTHETIC_TRACKING_USED, +false);
}

static addImageSharpness(builder:flatbuffers.Builder, IMAGE_SHARPNESS:number) {
  builder.addFieldFloat32(106, IMAGE_SHARPNESS, 0.0);
}

static addImageNoiseStddev(builder:flatbuffers.Builder, IMAGE_NOISE_STDDEV:number) {
  builder.addFieldFloat32(107, IMAGE_NOISE_STDDEV, 0.0);
}

static addImageContrast(builder:flatbuffers.Builder, IMAGE_CONTRAST:number) {
  builder.addFieldFloat32(108, IMAGE_CONTRAST, 0.0);
}

static addImageDynamicRange(builder:flatbuffers.Builder, IMAGE_DYNAMIC_RANGE:number) {
  builder.addFieldFloat32(109, IMAGE_DYNAMIC_RANGE, 0.0);
}

static addImageEntropy(builder:flatbuffers.Builder, IMAGE_ENTROPY:number) {
  builder.addFieldFloat32(110, IMAGE_ENTROPY, 0.0);
}

static addBackgroundUniformity(builder:flatbuffers.Builder, BACKGROUND_UNIFORMITY:number) {
  builder.addFieldFloat32(111, BACKGROUND_UNIFORMITY, 0.0);
}

static addBackgroundMeanLevel(builder:flatbuffers.Builder, BACKGROUND_MEAN_LEVEL:number) {
  builder.addFieldFloat32(112, BACKGROUND_MEAN_LEVEL, 0.0);
}

static addSaturatedPixelPercent(builder:flatbuffers.Builder, SATURATED_PIXEL_PERCENT:number) {
  builder.addFieldFloat32(113, SATURATED_PIXEL_PERCENT, 0.0);
}

static addDeadPixelPercent(builder:flatbuffers.Builder, DEAD_PIXEL_PERCENT:number) {
  builder.addFieldFloat32(114, DEAD_PIXEL_PERCENT, 0.0);
}

static addPsfFwhm(builder:flatbuffers.Builder, PSF_FWHM:number) {
  builder.addFieldFloat32(115, PSF_FWHM, 0.0);
}

static addCloudCoverPercent(builder:flatbuffers.Builder, CLOUD_COVER_PERCENT:number) {
  builder.addFieldFloat32(116, CLOUD_COVER_PERCENT, 0.0);
}

static addCloudDetectionConfidence(builder:flatbuffers.Builder, CLOUD_DETECTION_CONFIDENCE:number) {
  builder.addFieldFloat32(117, CLOUD_DETECTION_CONFIDENCE, 0.0);
}

static addHazePercent(builder:flatbuffers.Builder, HAZE_PERCENT:number) {
  builder.addFieldFloat32(118, HAZE_PERCENT, 0.0);
}

static addAerosolOpticalThickness(builder:flatbuffers.Builder, AEROSOL_OPTICAL_THICKNESS:number) {
  builder.addFieldFloat32(119, AEROSOL_OPTICAL_THICKNESS, 0.0);
}

static addWaterVaporContent(builder:flatbuffers.Builder, WATER_VAPOR_CONTENT:number) {
  builder.addFieldFloat32(120, WATER_VAPOR_CONTENT, 0.0);
}

static addSunElevation(builder:flatbuffers.Builder, SUN_ELEVATION:number) {
  builder.addFieldFloat32(121, SUN_ELEVATION, 0.0);
}

static addSunAzimuth(builder:flatbuffers.Builder, SUN_AZIMUTH:number) {
  builder.addFieldFloat32(122, SUN_AZIMUTH, 0.0);
}

static addViewZenithAngle(builder:flatbuffers.Builder, VIEW_ZENITH_ANGLE:number) {
  builder.addFieldFloat32(123, VIEW_ZENITH_ANGLE, 0.0);
}

static addViewAzimuthAngle(builder:flatbuffers.Builder, VIEW_AZIMUTH_ANGLE:number) {
  builder.addFieldFloat32(124, VIEW_AZIMUTH_ANGLE, 0.0);
}

static addOffNadirAngle(builder:flatbuffers.Builder, OFF_NADIR_ANGLE:number) {
  builder.addFieldFloat32(125, OFF_NADIR_ANGLE, 0.0);
}

static addSwathWidthKm(builder:flatbuffers.Builder, SWATH_WIDTH_KM:number) {
  builder.addFieldFloat32(126, SWATH_WIDTH_KM, 0.0);
}

static addMeanTerrainElevation(builder:flatbuffers.Builder, MEAN_TERRAIN_ELEVATION:number) {
  builder.addFieldFloat32(127, MEAN_TERRAIN_ELEVATION, 0.0);
}

static addTerrainElevationStddev(builder:flatbuffers.Builder, TERRAIN_ELEVATION_STDDEV:number) {
  builder.addFieldFloat32(128, TERRAIN_ELEVATION_STDDEV, 0.0);
}

static addShadowCoverPercent(builder:flatbuffers.Builder, SHADOW_COVER_PERCENT:number) {
  builder.addFieldFloat32(129, SHADOW_COVER_PERCENT, 0.0);
}

static addSunglintPresent(builder:flatbuffers.Builder, SUNGLINT_PRESENT:boolean) {
  builder.addFieldInt8(130, +SUNGLINT_PRESENT, +false);
}

static addSunglintPercent(builder:flatbuffers.Builder, SUNGLINT_PERCENT:number) {
  builder.addFieldFloat32(131, SUNGLINT_PERCENT, 0.0);
}

static addSnowIceCoverPercent(builder:flatbuffers.Builder, SNOW_ICE_COVER_PERCENT:number) {
  builder.addFieldFloat32(132, SNOW_ICE_COVER_PERCENT, 0.0);
}

static addValidDataAreaKm2(builder:flatbuffers.Builder, VALID_DATA_AREA_KM2:number) {
  builder.addFieldFloat32(133, VALID_DATA_AREA_KM2, 0.0);
}

static endEOO(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishEOOBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EOO');
}

static finishSizePrefixedEOOBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EOO', true);
}


unpack(): EOOT {
  return new EOOT(
    this.ID(),
    this.CLASSIFICATION(),
    this.OB_TIME(),
    this.CORR_QUALITY(),
    this.ID_ON_ORBIT(),
    this.SENSOR_ID(),
    this.COLLECT_METHOD(),
    this.NORAD_CAT_ID(),
    this.TASK_ID(),
    this.TRANSACTION_ID(),
    this.IMAGE_SET_ID(),
    this.IMAGE_SET_LENGTH(),
    this.SEQUENCE_ID(),
    this.OB_POSITION(),
    this.ORIG_OBJECT_ID(),
    this.ORIG_SENSOR_ID(),
    this.UCT(),
    this.AZIMUTH(),
    this.AZIMUTH_UNC(),
    this.AZIMUTH_BIAS(),
    this.AZIMUTH_RATE(),
    this.ELEVATION(),
    this.ELEVATION_UNC(),
    this.ELEVATION_BIAS(),
    this.ELEVATION_RATE(),
    this.RANGE(),
    this.RANGE_UNC(),
    this.RANGE_BIAS(),
    this.RANGE_RATE(),
    this.RANGE_RATE_UNC(),
    this.RA(),
    this.RA_RATE(),
    this.RA_UNC(),
    this.RA_BIAS(),
    this.DECLINATION(),
    this.DECLINATION_RATE(),
    this.DECLINATION_UNC(),
    this.DECLINATION_BIAS(),
    this.LOSX(),
    this.LOSY(),
    this.LOSZ(),
    this.LOS_UNC(),
    this.LOSXVEL(),
    this.LOSYVEL(),
    this.LOSZVEL(),
    this.SENLAT(),
    this.SENLON(),
    this.SENALT(),
    this.SENX(),
    this.SENY(),
    this.SENZ(),
    this.FOV_COUNT(),
    this.FOV_COUNT_UCTS(),
    this.EXP_DURATION(),
    this.ZEROPTD(),
    this.NET_OBJ_SIG(),
    this.NET_OBJ_SIG_UNC(),
    this.MAG(),
    this.MAG_UNC(),
    this.MAG_NORM_RANGE(),
    this.GEOLAT(),
    this.GEOLON(),
    this.GEOALT(),
    this.GEORANGE(),
    this.SKY_BKGRND(),
    this.PRIMARY_EXTINCTION(),
    this.PRIMARY_EXTINCTION_UNC(),
    this.SOLAR_PHASE_ANGLE(),
    this.SOLAR_EQ_PHASE_ANGLE(),
    this.SOLAR_DEC_ANGLE(),
    this.SHUTTER_DELAY(),
    this.TIMING_BIAS(),
    this.RAW_FILE_URI(),
    this.INTENSITY(),
    this.BG_INTENSITY(),
    this.DESCRIPTOR(),
    this.SOURCE(),
    this.ORIGIN(),
    this.DATA_MODE(),
    this.CREATED_AT(),
    this.CREATED_BY(),
    (this.REFERENCE_FRAME() !== null ? this.REFERENCE_FRAME()!.unpack() : null),
    (this.SEN_REFERENCE_FRAME() !== null ? this.SEN_REFERENCE_FRAME()!.unpack() : null),
    this.UMBRA(),
    this.PENUMBRA(),
    this.ORIG_NETWORK(),
    this.SOURCE_DL(),
    this.TYPE(),
    this.AZIMUTH_MEASURED(),
    this.ELEVATION_MEASURED(),
    this.RANGE_MEASURED(),
    this.RANGERATE_MEASURED(),
    this.RA_MEASURED(),
    this.DECLINATION_MEASURED(),
    this.NIIRS(),
    this.METERS_PER_PIXEL(),
    this.IMAGE_SNR(),
    this.IMAGE_BIT_DEPTH(),
    this.IMAGE_WIDTH(),
    this.IMAGE_HEIGHT(),
    this.IMAGE_COMPRESSION(),
    this.IMAGE_COMPRESSION_RATIO(),
    this.PROCESSED_IMAGE_URI(),
    this.IMAGE_AUTO_ENHANCED(),
    this.MULTI_FRAME_STACKED(),
    this.SYNTHETIC_TRACKING_USED(),
    this.IMAGE_SHARPNESS(),
    this.IMAGE_NOISE_STDDEV(),
    this.IMAGE_CONTRAST(),
    this.IMAGE_DYNAMIC_RANGE(),
    this.IMAGE_ENTROPY(),
    this.BACKGROUND_UNIFORMITY(),
    this.BACKGROUND_MEAN_LEVEL(),
    this.SATURATED_PIXEL_PERCENT(),
    this.DEAD_PIXEL_PERCENT(),
    this.PSF_FWHM(),
    this.CLOUD_COVER_PERCENT(),
    this.CLOUD_DETECTION_CONFIDENCE(),
    this.HAZE_PERCENT(),
    this.AEROSOL_OPTICAL_THICKNESS(),
    this.WATER_VAPOR_CONTENT(),
    this.SUN_ELEVATION(),
    this.SUN_AZIMUTH(),
    this.VIEW_ZENITH_ANGLE(),
    this.VIEW_AZIMUTH_ANGLE(),
    this.OFF_NADIR_ANGLE(),
    this.SWATH_WIDTH_KM(),
    this.MEAN_TERRAIN_ELEVATION(),
    this.TERRAIN_ELEVATION_STDDEV(),
    this.SHADOW_COVER_PERCENT(),
    this.SUNGLINT_PRESENT(),
    this.SUNGLINT_PERCENT(),
    this.SNOW_ICE_COVER_PERCENT(),
    this.VALID_DATA_AREA_KM2()
  );
}


unpackTo(_o: EOOT): void {
  _o.ID = this.ID();
  _o.CLASSIFICATION = this.CLASSIFICATION();
  _o.OB_TIME = this.OB_TIME();
  _o.CORR_QUALITY = this.CORR_QUALITY();
  _o.ID_ON_ORBIT = this.ID_ON_ORBIT();
  _o.SENSOR_ID = this.SENSOR_ID();
  _o.COLLECT_METHOD = this.COLLECT_METHOD();
  _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
  _o.TASK_ID = this.TASK_ID();
  _o.TRANSACTION_ID = this.TRANSACTION_ID();
  _o.IMAGE_SET_ID = this.IMAGE_SET_ID();
  _o.IMAGE_SET_LENGTH = this.IMAGE_SET_LENGTH();
  _o.SEQUENCE_ID = this.SEQUENCE_ID();
  _o.OB_POSITION = this.OB_POSITION();
  _o.ORIG_OBJECT_ID = this.ORIG_OBJECT_ID();
  _o.ORIG_SENSOR_ID = this.ORIG_SENSOR_ID();
  _o.UCT = this.UCT();
  _o.AZIMUTH = this.AZIMUTH();
  _o.AZIMUTH_UNC = this.AZIMUTH_UNC();
  _o.AZIMUTH_BIAS = this.AZIMUTH_BIAS();
  _o.AZIMUTH_RATE = this.AZIMUTH_RATE();
  _o.ELEVATION = this.ELEVATION();
  _o.ELEVATION_UNC = this.ELEVATION_UNC();
  _o.ELEVATION_BIAS = this.ELEVATION_BIAS();
  _o.ELEVATION_RATE = this.ELEVATION_RATE();
  _o.RANGE = this.RANGE();
  _o.RANGE_UNC = this.RANGE_UNC();
  _o.RANGE_BIAS = this.RANGE_BIAS();
  _o.RANGE_RATE = this.RANGE_RATE();
  _o.RANGE_RATE_UNC = this.RANGE_RATE_UNC();
  _o.RA = this.RA();
  _o.RA_RATE = this.RA_RATE();
  _o.RA_UNC = this.RA_UNC();
  _o.RA_BIAS = this.RA_BIAS();
  _o.DECLINATION = this.DECLINATION();
  _o.DECLINATION_RATE = this.DECLINATION_RATE();
  _o.DECLINATION_UNC = this.DECLINATION_UNC();
  _o.DECLINATION_BIAS = this.DECLINATION_BIAS();
  _o.LOSX = this.LOSX();
  _o.LOSY = this.LOSY();
  _o.LOSZ = this.LOSZ();
  _o.LOS_UNC = this.LOS_UNC();
  _o.LOSXVEL = this.LOSXVEL();
  _o.LOSYVEL = this.LOSYVEL();
  _o.LOSZVEL = this.LOSZVEL();
  _o.SENLAT = this.SENLAT();
  _o.SENLON = this.SENLON();
  _o.SENALT = this.SENALT();
  _o.SENX = this.SENX();
  _o.SENY = this.SENY();
  _o.SENZ = this.SENZ();
  _o.FOV_COUNT = this.FOV_COUNT();
  _o.FOV_COUNT_UCTS = this.FOV_COUNT_UCTS();
  _o.EXP_DURATION = this.EXP_DURATION();
  _o.ZEROPTD = this.ZEROPTD();
  _o.NET_OBJ_SIG = this.NET_OBJ_SIG();
  _o.NET_OBJ_SIG_UNC = this.NET_OBJ_SIG_UNC();
  _o.MAG = this.MAG();
  _o.MAG_UNC = this.MAG_UNC();
  _o.MAG_NORM_RANGE = this.MAG_NORM_RANGE();
  _o.GEOLAT = this.GEOLAT();
  _o.GEOLON = this.GEOLON();
  _o.GEOALT = this.GEOALT();
  _o.GEORANGE = this.GEORANGE();
  _o.SKY_BKGRND = this.SKY_BKGRND();
  _o.PRIMARY_EXTINCTION = this.PRIMARY_EXTINCTION();
  _o.PRIMARY_EXTINCTION_UNC = this.PRIMARY_EXTINCTION_UNC();
  _o.SOLAR_PHASE_ANGLE = this.SOLAR_PHASE_ANGLE();
  _o.SOLAR_EQ_PHASE_ANGLE = this.SOLAR_EQ_PHASE_ANGLE();
  _o.SOLAR_DEC_ANGLE = this.SOLAR_DEC_ANGLE();
  _o.SHUTTER_DELAY = this.SHUTTER_DELAY();
  _o.TIMING_BIAS = this.TIMING_BIAS();
  _o.RAW_FILE_URI = this.RAW_FILE_URI();
  _o.INTENSITY = this.INTENSITY();
  _o.BG_INTENSITY = this.BG_INTENSITY();
  _o.DESCRIPTOR = this.DESCRIPTOR();
  _o.SOURCE = this.SOURCE();
  _o.ORIGIN = this.ORIGIN();
  _o.DATA_MODE = this.DATA_MODE();
  _o.CREATED_AT = this.CREATED_AT();
  _o.CREATED_BY = this.CREATED_BY();
  _o.REFERENCE_FRAME = (this.REFERENCE_FRAME() !== null ? this.REFERENCE_FRAME()!.unpack() : null);
  _o.SEN_REFERENCE_FRAME = (this.SEN_REFERENCE_FRAME() !== null ? this.SEN_REFERENCE_FRAME()!.unpack() : null);
  _o.UMBRA = this.UMBRA();
  _o.PENUMBRA = this.PENUMBRA();
  _o.ORIG_NETWORK = this.ORIG_NETWORK();
  _o.SOURCE_DL = this.SOURCE_DL();
  _o.TYPE = this.TYPE();
  _o.AZIMUTH_MEASURED = this.AZIMUTH_MEASURED();
  _o.ELEVATION_MEASURED = this.ELEVATION_MEASURED();
  _o.RANGE_MEASURED = this.RANGE_MEASURED();
  _o.RANGERATE_MEASURED = this.RANGERATE_MEASURED();
  _o.RA_MEASURED = this.RA_MEASURED();
  _o.DECLINATION_MEASURED = this.DECLINATION_MEASURED();
  _o.NIIRS = this.NIIRS();
  _o.METERS_PER_PIXEL = this.METERS_PER_PIXEL();
  _o.IMAGE_SNR = this.IMAGE_SNR();
  _o.IMAGE_BIT_DEPTH = this.IMAGE_BIT_DEPTH();
  _o.IMAGE_WIDTH = this.IMAGE_WIDTH();
  _o.IMAGE_HEIGHT = this.IMAGE_HEIGHT();
  _o.IMAGE_COMPRESSION = this.IMAGE_COMPRESSION();
  _o.IMAGE_COMPRESSION_RATIO = this.IMAGE_COMPRESSION_RATIO();
  _o.PROCESSED_IMAGE_URI = this.PROCESSED_IMAGE_URI();
  _o.IMAGE_AUTO_ENHANCED = this.IMAGE_AUTO_ENHANCED();
  _o.MULTI_FRAME_STACKED = this.MULTI_FRAME_STACKED();
  _o.SYNTHETIC_TRACKING_USED = this.SYNTHETIC_TRACKING_USED();
  _o.IMAGE_SHARPNESS = this.IMAGE_SHARPNESS();
  _o.IMAGE_NOISE_STDDEV = this.IMAGE_NOISE_STDDEV();
  _o.IMAGE_CONTRAST = this.IMAGE_CONTRAST();
  _o.IMAGE_DYNAMIC_RANGE = this.IMAGE_DYNAMIC_RANGE();
  _o.IMAGE_ENTROPY = this.IMAGE_ENTROPY();
  _o.BACKGROUND_UNIFORMITY = this.BACKGROUND_UNIFORMITY();
  _o.BACKGROUND_MEAN_LEVEL = this.BACKGROUND_MEAN_LEVEL();
  _o.SATURATED_PIXEL_PERCENT = this.SATURATED_PIXEL_PERCENT();
  _o.DEAD_PIXEL_PERCENT = this.DEAD_PIXEL_PERCENT();
  _o.PSF_FWHM = this.PSF_FWHM();
  _o.CLOUD_COVER_PERCENT = this.CLOUD_COVER_PERCENT();
  _o.CLOUD_DETECTION_CONFIDENCE = this.CLOUD_DETECTION_CONFIDENCE();
  _o.HAZE_PERCENT = this.HAZE_PERCENT();
  _o.AEROSOL_OPTICAL_THICKNESS = this.AEROSOL_OPTICAL_THICKNESS();
  _o.WATER_VAPOR_CONTENT = this.WATER_VAPOR_CONTENT();
  _o.SUN_ELEVATION = this.SUN_ELEVATION();
  _o.SUN_AZIMUTH = this.SUN_AZIMUTH();
  _o.VIEW_ZENITH_ANGLE = this.VIEW_ZENITH_ANGLE();
  _o.VIEW_AZIMUTH_ANGLE = this.VIEW_AZIMUTH_ANGLE();
  _o.OFF_NADIR_ANGLE = this.OFF_NADIR_ANGLE();
  _o.SWATH_WIDTH_KM = this.SWATH_WIDTH_KM();
  _o.MEAN_TERRAIN_ELEVATION = this.MEAN_TERRAIN_ELEVATION();
  _o.TERRAIN_ELEVATION_STDDEV = this.TERRAIN_ELEVATION_STDDEV();
  _o.SHADOW_COVER_PERCENT = this.SHADOW_COVER_PERCENT();
  _o.SUNGLINT_PRESENT = this.SUNGLINT_PRESENT();
  _o.SUNGLINT_PERCENT = this.SUNGLINT_PERCENT();
  _o.SNOW_ICE_COVER_PERCENT = this.SNOW_ICE_COVER_PERCENT();
  _o.VALID_DATA_AREA_KM2 = this.VALID_DATA_AREA_KM2();
}
}

export class EOOT implements flatbuffers.IGeneratedObject {
constructor(
  public ID: string|Uint8Array|null = null,
  public CLASSIFICATION: string|Uint8Array|null = null,
  public OB_TIME: string|Uint8Array|null = null,
  public CORR_QUALITY: number = 0.0,
  public ID_ON_ORBIT: string|Uint8Array|null = null,
  public SENSOR_ID: string|Uint8Array|null = null,
  public COLLECT_METHOD: CollectMethod = CollectMethod.SIDEREAL,
  public NORAD_CAT_ID: number = 0,
  public TASK_ID: string|Uint8Array|null = null,
  public TRANSACTION_ID: string|Uint8Array|null = null,
  public IMAGE_SET_ID: string|Uint8Array|null = null,
  public IMAGE_SET_LENGTH: number = 0,
  public SEQUENCE_ID: number = 0,
  public OB_POSITION: ObservationPosition = ObservationPosition.FENCE,
  public ORIG_OBJECT_ID: string|Uint8Array|null = null,
  public ORIG_SENSOR_ID: string|Uint8Array|null = null,
  public UCT: boolean = false,
  public AZIMUTH: number = 0.0,
  public AZIMUTH_UNC: number = 0.0,
  public AZIMUTH_BIAS: number = 0.0,
  public AZIMUTH_RATE: number = 0.0,
  public ELEVATION: number = 0.0,
  public ELEVATION_UNC: number = 0.0,
  public ELEVATION_BIAS: number = 0.0,
  public ELEVATION_RATE: number = 0.0,
  public RANGE: number = 0.0,
  public RANGE_UNC: number = 0.0,
  public RANGE_BIAS: number = 0.0,
  public RANGE_RATE: number = 0.0,
  public RANGE_RATE_UNC: number = 0.0,
  public RA: number = 0.0,
  public RA_RATE: number = 0.0,
  public RA_UNC: number = 0.0,
  public RA_BIAS: number = 0.0,
  public DECLINATION: number = 0.0,
  public DECLINATION_RATE: number = 0.0,
  public DECLINATION_UNC: number = 0.0,
  public DECLINATION_BIAS: number = 0.0,
  public LOSX: number = 0.0,
  public LOSY: number = 0.0,
  public LOSZ: number = 0.0,
  public LOS_UNC: number = 0.0,
  public LOSXVEL: number = 0.0,
  public LOSYVEL: number = 0.0,
  public LOSZVEL: number = 0.0,
  public SENLAT: number = 0.0,
  public SENLON: number = 0.0,
  public SENALT: number = 0.0,
  public SENX: number = 0.0,
  public SENY: number = 0.0,
  public SENZ: number = 0.0,
  public FOV_COUNT: number = 0,
  public FOV_COUNT_UCTS: number = 0,
  public EXP_DURATION: number = 0.0,
  public ZEROPTD: number = 0.0,
  public NET_OBJ_SIG: number = 0.0,
  public NET_OBJ_SIG_UNC: number = 0.0,
  public MAG: number = 0.0,
  public MAG_UNC: number = 0.0,
  public MAG_NORM_RANGE: number = 0.0,
  public GEOLAT: number = 0.0,
  public GEOLON: number = 0.0,
  public GEOALT: number = 0.0,
  public GEORANGE: number = 0.0,
  public SKY_BKGRND: number = 0.0,
  public PRIMARY_EXTINCTION: number = 0.0,
  public PRIMARY_EXTINCTION_UNC: number = 0.0,
  public SOLAR_PHASE_ANGLE: number = 0.0,
  public SOLAR_EQ_PHASE_ANGLE: number = 0.0,
  public SOLAR_DEC_ANGLE: number = 0.0,
  public SHUTTER_DELAY: number = 0.0,
  public TIMING_BIAS: number = 0.0,
  public RAW_FILE_URI: string|Uint8Array|null = null,
  public INTENSITY: number = 0.0,
  public BG_INTENSITY: number = 0.0,
  public DESCRIPTOR: string|Uint8Array|null = null,
  public SOURCE: string|Uint8Array|null = null,
  public ORIGIN: string|Uint8Array|null = null,
  public DATA_MODE: DataMode = DataMode.EXERCISE,
  public CREATED_AT: string|Uint8Array|null = null,
  public CREATED_BY: string|Uint8Array|null = null,
  public REFERENCE_FRAME: RFMT|null = null,
  public SEN_REFERENCE_FRAME: RFMT|null = null,
  public UMBRA: boolean = false,
  public PENUMBRA: boolean = false,
  public ORIG_NETWORK: string|Uint8Array|null = null,
  public SOURCE_DL: string|Uint8Array|null = null,
  public TYPE: DeviceType = DeviceType.UNKNOWN,
  public AZIMUTH_MEASURED: boolean = false,
  public ELEVATION_MEASURED: boolean = false,
  public RANGE_MEASURED: boolean = false,
  public RANGERATE_MEASURED: boolean = false,
  public RA_MEASURED: boolean = false,
  public DECLINATION_MEASURED: boolean = false,
  public NIIRS: number = 0.0,
  public METERS_PER_PIXEL: number = 0.0,
  public IMAGE_SNR: number = 0.0,
  public IMAGE_BIT_DEPTH: number = 0,
  public IMAGE_WIDTH: number = 0,
  public IMAGE_HEIGHT: number = 0,
  public IMAGE_COMPRESSION: string|Uint8Array|null = null,
  public IMAGE_COMPRESSION_RATIO: number = 0.0,
  public PROCESSED_IMAGE_URI: string|Uint8Array|null = null,
  public IMAGE_AUTO_ENHANCED: boolean = false,
  public MULTI_FRAME_STACKED: boolean = false,
  public SYNTHETIC_TRACKING_USED: boolean = false,
  public IMAGE_SHARPNESS: number = 0.0,
  public IMAGE_NOISE_STDDEV: number = 0.0,
  public IMAGE_CONTRAST: number = 0.0,
  public IMAGE_DYNAMIC_RANGE: number = 0.0,
  public IMAGE_ENTROPY: number = 0.0,
  public BACKGROUND_UNIFORMITY: number = 0.0,
  public BACKGROUND_MEAN_LEVEL: number = 0.0,
  public SATURATED_PIXEL_PERCENT: number = 0.0,
  public DEAD_PIXEL_PERCENT: number = 0.0,
  public PSF_FWHM: number = 0.0,
  public CLOUD_COVER_PERCENT: number = 0.0,
  public CLOUD_DETECTION_CONFIDENCE: number = 0.0,
  public HAZE_PERCENT: number = 0.0,
  public AEROSOL_OPTICAL_THICKNESS: number = 0.0,
  public WATER_VAPOR_CONTENT: number = 0.0,
  public SUN_ELEVATION: number = 0.0,
  public SUN_AZIMUTH: number = 0.0,
  public VIEW_ZENITH_ANGLE: number = 0.0,
  public VIEW_AZIMUTH_ANGLE: number = 0.0,
  public OFF_NADIR_ANGLE: number = 0.0,
  public SWATH_WIDTH_KM: number = 0.0,
  public MEAN_TERRAIN_ELEVATION: number = 0.0,
  public TERRAIN_ELEVATION_STDDEV: number = 0.0,
  public SHADOW_COVER_PERCENT: number = 0.0,
  public SUNGLINT_PRESENT: boolean = false,
  public SUNGLINT_PERCENT: number = 0.0,
  public SNOW_ICE_COVER_PERCENT: number = 0.0,
  public VALID_DATA_AREA_KM2: number = 0.0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const ID = (this.ID !== null ? builder.createString(this.ID!) : 0);
  const CLASSIFICATION = (this.CLASSIFICATION !== null ? builder.createString(this.CLASSIFICATION!) : 0);
  const OB_TIME = (this.OB_TIME !== null ? builder.createString(this.OB_TIME!) : 0);
  const ID_ON_ORBIT = (this.ID_ON_ORBIT !== null ? builder.createString(this.ID_ON_ORBIT!) : 0);
  const SENSOR_ID = (this.SENSOR_ID !== null ? builder.createString(this.SENSOR_ID!) : 0);
  const TASK_ID = (this.TASK_ID !== null ? builder.createString(this.TASK_ID!) : 0);
  const TRANSACTION_ID = (this.TRANSACTION_ID !== null ? builder.createString(this.TRANSACTION_ID!) : 0);
  const IMAGE_SET_ID = (this.IMAGE_SET_ID !== null ? builder.createString(this.IMAGE_SET_ID!) : 0);
  const ORIG_OBJECT_ID = (this.ORIG_OBJECT_ID !== null ? builder.createString(this.ORIG_OBJECT_ID!) : 0);
  const ORIG_SENSOR_ID = (this.ORIG_SENSOR_ID !== null ? builder.createString(this.ORIG_SENSOR_ID!) : 0);
  const RAW_FILE_URI = (this.RAW_FILE_URI !== null ? builder.createString(this.RAW_FILE_URI!) : 0);
  const DESCRIPTOR = (this.DESCRIPTOR !== null ? builder.createString(this.DESCRIPTOR!) : 0);
  const SOURCE = (this.SOURCE !== null ? builder.createString(this.SOURCE!) : 0);
  const ORIGIN = (this.ORIGIN !== null ? builder.createString(this.ORIGIN!) : 0);
  const CREATED_AT = (this.CREATED_AT !== null ? builder.createString(this.CREATED_AT!) : 0);
  const CREATED_BY = (this.CREATED_BY !== null ? builder.createString(this.CREATED_BY!) : 0);
  const REFERENCE_FRAME = (this.REFERENCE_FRAME !== null ? this.REFERENCE_FRAME!.pack(builder) : 0);
  const SEN_REFERENCE_FRAME = (this.SEN_REFERENCE_FRAME !== null ? this.SEN_REFERENCE_FRAME!.pack(builder) : 0);
  const ORIG_NETWORK = (this.ORIG_NETWORK !== null ? builder.createString(this.ORIG_NETWORK!) : 0);
  const SOURCE_DL = (this.SOURCE_DL !== null ? builder.createString(this.SOURCE_DL!) : 0);
  const IMAGE_COMPRESSION = (this.IMAGE_COMPRESSION !== null ? builder.createString(this.IMAGE_COMPRESSION!) : 0);
  const PROCESSED_IMAGE_URI = (this.PROCESSED_IMAGE_URI !== null ? builder.createString(this.PROCESSED_IMAGE_URI!) : 0);

  EOO.startEOO(builder);
  EOO.addId(builder, ID);
  EOO.addClassification(builder, CLASSIFICATION);
  EOO.addObTime(builder, OB_TIME);
  EOO.addCorrQuality(builder, this.CORR_QUALITY);
  EOO.addIdOnOrbit(builder, ID_ON_ORBIT);
  EOO.addSensorId(builder, SENSOR_ID);
  EOO.addCollectMethod(builder, this.COLLECT_METHOD);
  EOO.addNoradCatId(builder, this.NORAD_CAT_ID);
  EOO.addTaskId(builder, TASK_ID);
  EOO.addTransactionId(builder, TRANSACTION_ID);
  EOO.addImageSetId(builder, IMAGE_SET_ID);
  EOO.addImageSetLength(builder, this.IMAGE_SET_LENGTH);
  EOO.addSequenceId(builder, this.SEQUENCE_ID);
  EOO.addObPosition(builder, this.OB_POSITION);
  EOO.addOrigObjectId(builder, ORIG_OBJECT_ID);
  EOO.addOrigSensorId(builder, ORIG_SENSOR_ID);
  EOO.addUct(builder, this.UCT);
  EOO.addAzimuth(builder, this.AZIMUTH);
  EOO.addAzimuthUnc(builder, this.AZIMUTH_UNC);
  EOO.addAzimuthBias(builder, this.AZIMUTH_BIAS);
  EOO.addAzimuthRate(builder, this.AZIMUTH_RATE);
  EOO.addElevation(builder, this.ELEVATION);
  EOO.addElevationUnc(builder, this.ELEVATION_UNC);
  EOO.addElevationBias(builder, this.ELEVATION_BIAS);
  EOO.addElevationRate(builder, this.ELEVATION_RATE);
  EOO.addRange(builder, this.RANGE);
  EOO.addRangeUnc(builder, this.RANGE_UNC);
  EOO.addRangeBias(builder, this.RANGE_BIAS);
  EOO.addRangeRate(builder, this.RANGE_RATE);
  EOO.addRangeRateUnc(builder, this.RANGE_RATE_UNC);
  EOO.addRa(builder, this.RA);
  EOO.addRaRate(builder, this.RA_RATE);
  EOO.addRaUnc(builder, this.RA_UNC);
  EOO.addRaBias(builder, this.RA_BIAS);
  EOO.addDeclination(builder, this.DECLINATION);
  EOO.addDeclinationRate(builder, this.DECLINATION_RATE);
  EOO.addDeclinationUnc(builder, this.DECLINATION_UNC);
  EOO.addDeclinationBias(builder, this.DECLINATION_BIAS);
  EOO.addLosx(builder, this.LOSX);
  EOO.addLosy(builder, this.LOSY);
  EOO.addLosz(builder, this.LOSZ);
  EOO.addLosUnc(builder, this.LOS_UNC);
  EOO.addLosxvel(builder, this.LOSXVEL);
  EOO.addLosyvel(builder, this.LOSYVEL);
  EOO.addLoszvel(builder, this.LOSZVEL);
  EOO.addSenlat(builder, this.SENLAT);
  EOO.addSenlon(builder, this.SENLON);
  EOO.addSenalt(builder, this.SENALT);
  EOO.addSenx(builder, this.SENX);
  EOO.addSeny(builder, this.SENY);
  EOO.addSenz(builder, this.SENZ);
  EOO.addFovCount(builder, this.FOV_COUNT);
  EOO.addFovCountUcts(builder, this.FOV_COUNT_UCTS);
  EOO.addExpDuration(builder, this.EXP_DURATION);
  EOO.addZeroptd(builder, this.ZEROPTD);
  EOO.addNetObjSig(builder, this.NET_OBJ_SIG);
  EOO.addNetObjSigUnc(builder, this.NET_OBJ_SIG_UNC);
  EOO.addMag(builder, this.MAG);
  EOO.addMagUnc(builder, this.MAG_UNC);
  EOO.addMagNormRange(builder, this.MAG_NORM_RANGE);
  EOO.addGeolat(builder, this.GEOLAT);
  EOO.addGeolon(builder, this.GEOLON);
  EOO.addGeoalt(builder, this.GEOALT);
  EOO.addGeorange(builder, this.GEORANGE);
  EOO.addSkyBkgrnd(builder, this.SKY_BKGRND);
  EOO.addPrimaryExtinction(builder, this.PRIMARY_EXTINCTION);
  EOO.addPrimaryExtinctionUnc(builder, this.PRIMARY_EXTINCTION_UNC);
  EOO.addSolarPhaseAngle(builder, this.SOLAR_PHASE_ANGLE);
  EOO.addSolarEqPhaseAngle(builder, this.SOLAR_EQ_PHASE_ANGLE);
  EOO.addSolarDecAngle(builder, this.SOLAR_DEC_ANGLE);
  EOO.addShutterDelay(builder, this.SHUTTER_DELAY);
  EOO.addTimingBias(builder, this.TIMING_BIAS);
  EOO.addRawFileUri(builder, RAW_FILE_URI);
  EOO.addIntensity(builder, this.INTENSITY);
  EOO.addBgIntensity(builder, this.BG_INTENSITY);
  EOO.addDescriptor(builder, DESCRIPTOR);
  EOO.addSource(builder, SOURCE);
  EOO.addOrigin(builder, ORIGIN);
  EOO.addDataMode(builder, this.DATA_MODE);
  EOO.addCreatedAt(builder, CREATED_AT);
  EOO.addCreatedBy(builder, CREATED_BY);
  EOO.addReferenceFrame(builder, REFERENCE_FRAME);
  EOO.addSenReferenceFrame(builder, SEN_REFERENCE_FRAME);
  EOO.addUmbra(builder, this.UMBRA);
  EOO.addPenumbra(builder, this.PENUMBRA);
  EOO.addOrigNetwork(builder, ORIG_NETWORK);
  EOO.addSourceDl(builder, SOURCE_DL);
  EOO.addType(builder, this.TYPE);
  EOO.addAzimuthMeasured(builder, this.AZIMUTH_MEASURED);
  EOO.addElevationMeasured(builder, this.ELEVATION_MEASURED);
  EOO.addRangeMeasured(builder, this.RANGE_MEASURED);
  EOO.addRangerateMeasured(builder, this.RANGERATE_MEASURED);
  EOO.addRaMeasured(builder, this.RA_MEASURED);
  EOO.addDeclinationMeasured(builder, this.DECLINATION_MEASURED);
  EOO.addNiirs(builder, this.NIIRS);
  EOO.addMetersPerPixel(builder, this.METERS_PER_PIXEL);
  EOO.addImageSnr(builder, this.IMAGE_SNR);
  EOO.addImageBitDepth(builder, this.IMAGE_BIT_DEPTH);
  EOO.addImageWidth(builder, this.IMAGE_WIDTH);
  EOO.addImageHeight(builder, this.IMAGE_HEIGHT);
  EOO.addImageCompression(builder, IMAGE_COMPRESSION);
  EOO.addImageCompressionRatio(builder, this.IMAGE_COMPRESSION_RATIO);
  EOO.addProcessedImageUri(builder, PROCESSED_IMAGE_URI);
  EOO.addImageAutoEnhanced(builder, this.IMAGE_AUTO_ENHANCED);
  EOO.addMultiFrameStacked(builder, this.MULTI_FRAME_STACKED);
  EOO.addSyntheticTrackingUsed(builder, this.SYNTHETIC_TRACKING_USED);
  EOO.addImageSharpness(builder, this.IMAGE_SHARPNESS);
  EOO.addImageNoiseStddev(builder, this.IMAGE_NOISE_STDDEV);
  EOO.addImageContrast(builder, this.IMAGE_CONTRAST);
  EOO.addImageDynamicRange(builder, this.IMAGE_DYNAMIC_RANGE);
  EOO.addImageEntropy(builder, this.IMAGE_ENTROPY);
  EOO.addBackgroundUniformity(builder, this.BACKGROUND_UNIFORMITY);
  EOO.addBackgroundMeanLevel(builder, this.BACKGROUND_MEAN_LEVEL);
  EOO.addSaturatedPixelPercent(builder, this.SATURATED_PIXEL_PERCENT);
  EOO.addDeadPixelPercent(builder, this.DEAD_PIXEL_PERCENT);
  EOO.addPsfFwhm(builder, this.PSF_FWHM);
  EOO.addCloudCoverPercent(builder, this.CLOUD_COVER_PERCENT);
  EOO.addCloudDetectionConfidence(builder, this.CLOUD_DETECTION_CONFIDENCE);
  EOO.addHazePercent(builder, this.HAZE_PERCENT);
  EOO.addAerosolOpticalThickness(builder, this.AEROSOL_OPTICAL_THICKNESS);
  EOO.addWaterVaporContent(builder, this.WATER_VAPOR_CONTENT);
  EOO.addSunElevation(builder, this.SUN_ELEVATION);
  EOO.addSunAzimuth(builder, this.SUN_AZIMUTH);
  EOO.addViewZenithAngle(builder, this.VIEW_ZENITH_ANGLE);
  EOO.addViewAzimuthAngle(builder, this.VIEW_AZIMUTH_ANGLE);
  EOO.addOffNadirAngle(builder, this.OFF_NADIR_ANGLE);
  EOO.addSwathWidthKm(builder, this.SWATH_WIDTH_KM);
  EOO.addMeanTerrainElevation(builder, this.MEAN_TERRAIN_ELEVATION);
  EOO.addTerrainElevationStddev(builder, this.TERRAIN_ELEVATION_STDDEV);
  EOO.addShadowCoverPercent(builder, this.SHADOW_COVER_PERCENT);
  EOO.addSunglintPresent(builder, this.SUNGLINT_PRESENT);
  EOO.addSunglintPercent(builder, this.SUNGLINT_PERCENT);
  EOO.addSnowIceCoverPercent(builder, this.SNOW_ICE_COVER_PERCENT);
  EOO.addValidDataAreaKm2(builder, this.VALID_DATA_AREA_KM2);

  return EOO.endEOO(builder);
}
}
