// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Band, BandT } from './Band.js';
import { DataMode } from './DataMode.js';
import { DeviceType } from './DeviceType.js';
import { FrequencyRange, FrequencyRangeT } from './FrequencyRange.js';
import { PolarizationType } from './PolarizationType.js';
import { SimplePolarization } from './SimplePolarization.js';
import { StokesParameters, StokesParametersT } from './StokesParameters.js';


/**
 * Integrated Device Message
 */
export class IDM implements flatbuffers.IUnpackableObject<IDMT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):IDM {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsIDM(bb:flatbuffers.ByteBuffer, obj?:IDM):IDM {
  return (obj || new IDM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsIDM(bb:flatbuffers.ByteBuffer, obj?:IDM):IDM {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new IDM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$IDM');
}

/**
 * Unique identifier for the EMT
 */
ID():string|null
ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Name of the EMT
 */
NAME():string|null
NAME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
NAME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Mode of the data (real, simulated, synthetic)
 */
DATA_MODE():DataMode {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : DataMode.EXERCISE;
}

/**
 * Uplink frequency range
 */
UPLINK(obj?:FrequencyRange):FrequencyRange|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new FrequencyRange()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Downlink frequency range
 */
DOWNLINK(obj?:FrequencyRange):FrequencyRange|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new FrequencyRange()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Beacon frequency range
 */
BEACON(obj?:FrequencyRange):FrequencyRange|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? (obj || new FrequencyRange()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Bands associated with the EMT
 */
BAND(index: number, obj?:Band):Band|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? (obj || new Band()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

bandLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Type of polarization used
 */
POLARIZATION_TYPE():PolarizationType {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : PolarizationType.linear;
}

/**
 * Simple polarization configuration
 */
SIMPLE_POLARIZATION():SimplePolarization {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : SimplePolarization.vertical;
}

/**
 * Stokes parameters for polarization characterization
 */
STOKES_PARAMETERS(obj?:StokesParameters):StokesParameters|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? (obj || new StokesParameters()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Power required in Watts
 */
POWER_REQUIRED():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Type of power (eg. AC or DC)
 */
POWER_TYPE():string|null
POWER_TYPE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
POWER_TYPE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicates if the EMT can transmit
 */
TRANSMIT():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Indicates if the EMT can receive
 */
RECEIVE():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Type of the sensor
 */
SENSOR_TYPE():DeviceType {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : DeviceType.UNKNOWN;
}

/**
 * Source of the data
 */
SOURCE():string|null
SOURCE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SOURCE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Timestamp of the last observation
 */
LAST_OB_TIME():string|null
LAST_OB_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
LAST_OB_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Lower left elevation limit
 */
LOWER_LEFT_ELEVATION_LIMIT():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Upper left azimuth limit
 */
UPPER_LEFT_AZIMUTH_LIMIT():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Lower right elevation limit
 */
LOWER_RIGHT_ELEVATION_LIMIT():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Lower left azimuth limit
 */
LOWER_LEFT_AZIMUTH_LIMIT():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Upper right elevation limit
 */
UPPER_RIGHT_ELEVATION_LIMIT():number {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Upper right azimuth limit
 */
UPPER_RIGHT_AZIMUTH_LIMIT():number {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Lower right azimuth limit
 */
LOWER_RIGHT_AZIMUTH_LIMIT():number {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Upper left elevation limit
 */
UPPER_LEFT_ELEVATION_LIMIT():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Right geostationary belt limit
 */
RIGHT_GEO_BELT_LIMIT():number {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Left geostationary belt limit
 */
LEFT_GEO_BELT_LIMIT():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Magnitude limit of the sensor
 */
MAGNITUDE_LIMIT():number {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Indicates if the site is taskable
 */
TASKABLE():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

static startIDM(builder:flatbuffers.Builder) {
  builder.startObject(29);
}

static addId(builder:flatbuffers.Builder, IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, IDOffset, 0);
}

static addName(builder:flatbuffers.Builder, NAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, NAMEOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, DATA_MODE:DataMode) {
  builder.addFieldInt8(2, DATA_MODE, DataMode.EXERCISE);
}

static addUplink(builder:flatbuffers.Builder, UPLINKOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, UPLINKOffset, 0);
}

static addDownlink(builder:flatbuffers.Builder, DOWNLINKOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, DOWNLINKOffset, 0);
}

static addBeacon(builder:flatbuffers.Builder, BEACONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, BEACONOffset, 0);
}

static addBand(builder:flatbuffers.Builder, BANDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, BANDOffset, 0);
}

static createBandVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startBandVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addPolarizationType(builder:flatbuffers.Builder, POLARIZATION_TYPE:PolarizationType) {
  builder.addFieldInt8(7, POLARIZATION_TYPE, PolarizationType.linear);
}

static addSimplePolarization(builder:flatbuffers.Builder, SIMPLE_POLARIZATION:SimplePolarization) {
  builder.addFieldInt8(8, SIMPLE_POLARIZATION, SimplePolarization.vertical);
}

static addStokesParameters(builder:flatbuffers.Builder, STOKES_PARAMETERSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, STOKES_PARAMETERSOffset, 0);
}

static addPowerRequired(builder:flatbuffers.Builder, POWER_REQUIRED:number) {
  builder.addFieldFloat64(10, POWER_REQUIRED, 0.0);
}

static addPowerType(builder:flatbuffers.Builder, POWER_TYPEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, POWER_TYPEOffset, 0);
}

static addTransmit(builder:flatbuffers.Builder, TRANSMIT:boolean) {
  builder.addFieldInt8(12, +TRANSMIT, +false);
}

static addReceive(builder:flatbuffers.Builder, RECEIVE:boolean) {
  builder.addFieldInt8(13, +RECEIVE, +false);
}

static addSensorType(builder:flatbuffers.Builder, SENSOR_TYPE:DeviceType) {
  builder.addFieldInt8(14, SENSOR_TYPE, DeviceType.UNKNOWN);
}

static addSource(builder:flatbuffers.Builder, SOURCEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, SOURCEOffset, 0);
}

static addLastObTime(builder:flatbuffers.Builder, LAST_OB_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, LAST_OB_TIMEOffset, 0);
}

static addLowerLeftElevationLimit(builder:flatbuffers.Builder, LOWER_LEFT_ELEVATION_LIMIT:number) {
  builder.addFieldFloat64(17, LOWER_LEFT_ELEVATION_LIMIT, 0.0);
}

static addUpperLeftAzimuthLimit(builder:flatbuffers.Builder, UPPER_LEFT_AZIMUTH_LIMIT:number) {
  builder.addFieldFloat64(18, UPPER_LEFT_AZIMUTH_LIMIT, 0.0);
}

static addLowerRightElevationLimit(builder:flatbuffers.Builder, LOWER_RIGHT_ELEVATION_LIMIT:number) {
  builder.addFieldFloat64(19, LOWER_RIGHT_ELEVATION_LIMIT, 0.0);
}

static addLowerLeftAzimuthLimit(builder:flatbuffers.Builder, LOWER_LEFT_AZIMUTH_LIMIT:number) {
  builder.addFieldFloat64(20, LOWER_LEFT_AZIMUTH_LIMIT, 0.0);
}

static addUpperRightElevationLimit(builder:flatbuffers.Builder, UPPER_RIGHT_ELEVATION_LIMIT:number) {
  builder.addFieldFloat64(21, UPPER_RIGHT_ELEVATION_LIMIT, 0.0);
}

static addUpperRightAzimuthLimit(builder:flatbuffers.Builder, UPPER_RIGHT_AZIMUTH_LIMIT:number) {
  builder.addFieldFloat64(22, UPPER_RIGHT_AZIMUTH_LIMIT, 0.0);
}

static addLowerRightAzimuthLimit(builder:flatbuffers.Builder, LOWER_RIGHT_AZIMUTH_LIMIT:number) {
  builder.addFieldFloat64(23, LOWER_RIGHT_AZIMUTH_LIMIT, 0.0);
}

static addUpperLeftElevationLimit(builder:flatbuffers.Builder, UPPER_LEFT_ELEVATION_LIMIT:number) {
  builder.addFieldFloat64(24, UPPER_LEFT_ELEVATION_LIMIT, 0.0);
}

static addRightGeoBeltLimit(builder:flatbuffers.Builder, RIGHT_GEO_BELT_LIMIT:number) {
  builder.addFieldFloat64(25, RIGHT_GEO_BELT_LIMIT, 0.0);
}

static addLeftGeoBeltLimit(builder:flatbuffers.Builder, LEFT_GEO_BELT_LIMIT:number) {
  builder.addFieldFloat64(26, LEFT_GEO_BELT_LIMIT, 0.0);
}

static addMagnitudeLimit(builder:flatbuffers.Builder, MAGNITUDE_LIMIT:number) {
  builder.addFieldFloat64(27, MAGNITUDE_LIMIT, 0.0);
}

static addTaskable(builder:flatbuffers.Builder, TASKABLE:boolean) {
  builder.addFieldInt8(28, +TASKABLE, +false);
}

static endIDM(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishIDMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$IDM');
}

static finishSizePrefixedIDMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$IDM', true);
}


unpack(): IDMT {
  return new IDMT(
    this.ID(),
    this.NAME(),
    this.DATA_MODE(),
    (this.UPLINK() !== null ? this.UPLINK()!.unpack() : null),
    (this.DOWNLINK() !== null ? this.DOWNLINK()!.unpack() : null),
    (this.BEACON() !== null ? this.BEACON()!.unpack() : null),
    this.bb!.createObjList<Band, BandT>(this.BAND.bind(this), this.bandLength()),
    this.POLARIZATION_TYPE(),
    this.SIMPLE_POLARIZATION(),
    (this.STOKES_PARAMETERS() !== null ? this.STOKES_PARAMETERS()!.unpack() : null),
    this.POWER_REQUIRED(),
    this.POWER_TYPE(),
    this.TRANSMIT(),
    this.RECEIVE(),
    this.SENSOR_TYPE(),
    this.SOURCE(),
    this.LAST_OB_TIME(),
    this.LOWER_LEFT_ELEVATION_LIMIT(),
    this.UPPER_LEFT_AZIMUTH_LIMIT(),
    this.LOWER_RIGHT_ELEVATION_LIMIT(),
    this.LOWER_LEFT_AZIMUTH_LIMIT(),
    this.UPPER_RIGHT_ELEVATION_LIMIT(),
    this.UPPER_RIGHT_AZIMUTH_LIMIT(),
    this.LOWER_RIGHT_AZIMUTH_LIMIT(),
    this.UPPER_LEFT_ELEVATION_LIMIT(),
    this.RIGHT_GEO_BELT_LIMIT(),
    this.LEFT_GEO_BELT_LIMIT(),
    this.MAGNITUDE_LIMIT(),
    this.TASKABLE()
  );
}


unpackTo(_o: IDMT): void {
  _o.ID = this.ID();
  _o.NAME = this.NAME();
  _o.DATA_MODE = this.DATA_MODE();
  _o.UPLINK = (this.UPLINK() !== null ? this.UPLINK()!.unpack() : null);
  _o.DOWNLINK = (this.DOWNLINK() !== null ? this.DOWNLINK()!.unpack() : null);
  _o.BEACON = (this.BEACON() !== null ? this.BEACON()!.unpack() : null);
  _o.BAND = this.bb!.createObjList<Band, BandT>(this.BAND.bind(this), this.bandLength());
  _o.POLARIZATION_TYPE = this.POLARIZATION_TYPE();
  _o.SIMPLE_POLARIZATION = this.SIMPLE_POLARIZATION();
  _o.STOKES_PARAMETERS = (this.STOKES_PARAMETERS() !== null ? this.STOKES_PARAMETERS()!.unpack() : null);
  _o.POWER_REQUIRED = this.POWER_REQUIRED();
  _o.POWER_TYPE = this.POWER_TYPE();
  _o.TRANSMIT = this.TRANSMIT();
  _o.RECEIVE = this.RECEIVE();
  _o.SENSOR_TYPE = this.SENSOR_TYPE();
  _o.SOURCE = this.SOURCE();
  _o.LAST_OB_TIME = this.LAST_OB_TIME();
  _o.LOWER_LEFT_ELEVATION_LIMIT = this.LOWER_LEFT_ELEVATION_LIMIT();
  _o.UPPER_LEFT_AZIMUTH_LIMIT = this.UPPER_LEFT_AZIMUTH_LIMIT();
  _o.LOWER_RIGHT_ELEVATION_LIMIT = this.LOWER_RIGHT_ELEVATION_LIMIT();
  _o.LOWER_LEFT_AZIMUTH_LIMIT = this.LOWER_LEFT_AZIMUTH_LIMIT();
  _o.UPPER_RIGHT_ELEVATION_LIMIT = this.UPPER_RIGHT_ELEVATION_LIMIT();
  _o.UPPER_RIGHT_AZIMUTH_LIMIT = this.UPPER_RIGHT_AZIMUTH_LIMIT();
  _o.LOWER_RIGHT_AZIMUTH_LIMIT = this.LOWER_RIGHT_AZIMUTH_LIMIT();
  _o.UPPER_LEFT_ELEVATION_LIMIT = this.UPPER_LEFT_ELEVATION_LIMIT();
  _o.RIGHT_GEO_BELT_LIMIT = this.RIGHT_GEO_BELT_LIMIT();
  _o.LEFT_GEO_BELT_LIMIT = this.LEFT_GEO_BELT_LIMIT();
  _o.MAGNITUDE_LIMIT = this.MAGNITUDE_LIMIT();
  _o.TASKABLE = this.TASKABLE();
}
}

export class IDMT implements flatbuffers.IGeneratedObject {
constructor(
  public ID: string|Uint8Array|null = null,
  public NAME: string|Uint8Array|null = null,
  public DATA_MODE: DataMode = DataMode.EXERCISE,
  public UPLINK: FrequencyRangeT|null = null,
  public DOWNLINK: FrequencyRangeT|null = null,
  public BEACON: FrequencyRangeT|null = null,
  public BAND: (BandT)[] = [],
  public POLARIZATION_TYPE: PolarizationType = PolarizationType.linear,
  public SIMPLE_POLARIZATION: SimplePolarization = SimplePolarization.vertical,
  public STOKES_PARAMETERS: StokesParametersT|null = null,
  public POWER_REQUIRED: number = 0.0,
  public POWER_TYPE: string|Uint8Array|null = null,
  public TRANSMIT: boolean = false,
  public RECEIVE: boolean = false,
  public SENSOR_TYPE: DeviceType = DeviceType.UNKNOWN,
  public SOURCE: string|Uint8Array|null = null,
  public LAST_OB_TIME: string|Uint8Array|null = null,
  public LOWER_LEFT_ELEVATION_LIMIT: number = 0.0,
  public UPPER_LEFT_AZIMUTH_LIMIT: number = 0.0,
  public LOWER_RIGHT_ELEVATION_LIMIT: number = 0.0,
  public LOWER_LEFT_AZIMUTH_LIMIT: number = 0.0,
  public UPPER_RIGHT_ELEVATION_LIMIT: number = 0.0,
  public UPPER_RIGHT_AZIMUTH_LIMIT: number = 0.0,
  public LOWER_RIGHT_AZIMUTH_LIMIT: number = 0.0,
  public UPPER_LEFT_ELEVATION_LIMIT: number = 0.0,
  public RIGHT_GEO_BELT_LIMIT: number = 0.0,
  public LEFT_GEO_BELT_LIMIT: number = 0.0,
  public MAGNITUDE_LIMIT: number = 0.0,
  public TASKABLE: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const ID = (this.ID !== null ? builder.createString(this.ID!) : 0);
  const NAME = (this.NAME !== null ? builder.createString(this.NAME!) : 0);
  const UPLINK = (this.UPLINK !== null ? this.UPLINK!.pack(builder) : 0);
  const DOWNLINK = (this.DOWNLINK !== null ? this.DOWNLINK!.pack(builder) : 0);
  const BEACON = (this.BEACON !== null ? this.BEACON!.pack(builder) : 0);
  const BAND = IDM.createBandVector(builder, builder.createObjectOffsetList(this.BAND));
  const STOKES_PARAMETERS = (this.STOKES_PARAMETERS !== null ? this.STOKES_PARAMETERS!.pack(builder) : 0);
  const POWER_TYPE = (this.POWER_TYPE !== null ? builder.createString(this.POWER_TYPE!) : 0);
  const SOURCE = (this.SOURCE !== null ? builder.createString(this.SOURCE!) : 0);
  const LAST_OB_TIME = (this.LAST_OB_TIME !== null ? builder.createString(this.LAST_OB_TIME!) : 0);

  IDM.startIDM(builder);
  IDM.addId(builder, ID);
  IDM.addName(builder, NAME);
  IDM.addDataMode(builder, this.DATA_MODE);
  IDM.addUplink(builder, UPLINK);
  IDM.addDownlink(builder, DOWNLINK);
  IDM.addBeacon(builder, BEACON);
  IDM.addBand(builder, BAND);
  IDM.addPolarizationType(builder, this.POLARIZATION_TYPE);
  IDM.addSimplePolarization(builder, this.SIMPLE_POLARIZATION);
  IDM.addStokesParameters(builder, STOKES_PARAMETERS);
  IDM.addPowerRequired(builder, this.POWER_REQUIRED);
  IDM.addPowerType(builder, POWER_TYPE);
  IDM.addTransmit(builder, this.TRANSMIT);
  IDM.addReceive(builder, this.RECEIVE);
  IDM.addSensorType(builder, this.SENSOR_TYPE);
  IDM.addSource(builder, SOURCE);
  IDM.addLastObTime(builder, LAST_OB_TIME);
  IDM.addLowerLeftElevationLimit(builder, this.LOWER_LEFT_ELEVATION_LIMIT);
  IDM.addUpperLeftAzimuthLimit(builder, this.UPPER_LEFT_AZIMUTH_LIMIT);
  IDM.addLowerRightElevationLimit(builder, this.LOWER_RIGHT_ELEVATION_LIMIT);
  IDM.addLowerLeftAzimuthLimit(builder, this.LOWER_LEFT_AZIMUTH_LIMIT);
  IDM.addUpperRightElevationLimit(builder, this.UPPER_RIGHT_ELEVATION_LIMIT);
  IDM.addUpperRightAzimuthLimit(builder, this.UPPER_RIGHT_AZIMUTH_LIMIT);
  IDM.addLowerRightAzimuthLimit(builder, this.LOWER_RIGHT_AZIMUTH_LIMIT);
  IDM.addUpperLeftElevationLimit(builder, this.UPPER_LEFT_ELEVATION_LIMIT);
  IDM.addRightGeoBeltLimit(builder, this.RIGHT_GEO_BELT_LIMIT);
  IDM.addLeftGeoBeltLimit(builder, this.LEFT_GEO_BELT_LIMIT);
  IDM.addMagnitudeLimit(builder, this.MAGNITUDE_LIMIT);
  IDM.addTaskable(builder, this.TASKABLE);

  return IDM.endIDM(builder);
}
}
