// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { KMLAltitudeMode } from './KMLAltitudeMode.js';
import { KMLResourceMapAlias, KMLResourceMapAliasT } from './KMLResourceMapAlias.js';


/**
 * 3D Model geometry
 */
export class KMLModel implements flatbuffers.IUnpackableObject<KMLModelT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):KMLModel {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsKMLModel(bb:flatbuffers.ByteBuffer, obj?:KMLModel):KMLModel {
  return (obj || new KMLModel()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsKMLModel(bb:flatbuffers.ByteBuffer, obj?:KMLModel):KMLModel {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new KMLModel()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Altitude mode
 */
ALTITUDE_MODE():KMLAltitudeMode {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : KMLAltitudeMode.CLAMP_TO_GROUND;
}

/**
 * Location longitude
 */
LOCATION_LON():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Location latitude
 */
LOCATION_LAT():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Location altitude
 */
LOCATION_ALT():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Orientation heading
 */
ORIENTATION_HEADING():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Orientation tilt
 */
ORIENTATION_TILT():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Orientation roll
 */
ORIENTATION_ROLL():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Scale X
 */
SCALE_X():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Scale Y
 */
SCALE_Y():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Scale Z
 */
SCALE_Z():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Link to 3D model file
 */
LINK_HREF():string|null
LINK_HREF(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
LINK_HREF(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Resource map aliases
 */
RESOURCE_MAP(index: number, obj?:KMLResourceMapAlias):KMLResourceMapAlias|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? (obj || new KMLResourceMapAlias()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

resourceMapLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startKMLModel(builder:flatbuffers.Builder) {
  builder.startObject(12);
}

static addAltitudeMode(builder:flatbuffers.Builder, ALTITUDE_MODE:KMLAltitudeMode) {
  builder.addFieldInt8(0, ALTITUDE_MODE, KMLAltitudeMode.CLAMP_TO_GROUND);
}

static addLocationLon(builder:flatbuffers.Builder, LOCATION_LON:number) {
  builder.addFieldFloat64(1, LOCATION_LON, 0.0);
}

static addLocationLat(builder:flatbuffers.Builder, LOCATION_LAT:number) {
  builder.addFieldFloat64(2, LOCATION_LAT, 0.0);
}

static addLocationAlt(builder:flatbuffers.Builder, LOCATION_ALT:number) {
  builder.addFieldFloat64(3, LOCATION_ALT, 0.0);
}

static addOrientationHeading(builder:flatbuffers.Builder, ORIENTATION_HEADING:number) {
  builder.addFieldFloat64(4, ORIENTATION_HEADING, 0.0);
}

static addOrientationTilt(builder:flatbuffers.Builder, ORIENTATION_TILT:number) {
  builder.addFieldFloat64(5, ORIENTATION_TILT, 0.0);
}

static addOrientationRoll(builder:flatbuffers.Builder, ORIENTATION_ROLL:number) {
  builder.addFieldFloat64(6, ORIENTATION_ROLL, 0.0);
}

static addScaleX(builder:flatbuffers.Builder, SCALE_X:number) {
  builder.addFieldFloat64(7, SCALE_X, 0.0);
}

static addScaleY(builder:flatbuffers.Builder, SCALE_Y:number) {
  builder.addFieldFloat64(8, SCALE_Y, 0.0);
}

static addScaleZ(builder:flatbuffers.Builder, SCALE_Z:number) {
  builder.addFieldFloat64(9, SCALE_Z, 0.0);
}

static addLinkHref(builder:flatbuffers.Builder, LINK_HREFOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, LINK_HREFOffset, 0);
}

static addResourceMap(builder:flatbuffers.Builder, RESOURCE_MAPOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, RESOURCE_MAPOffset, 0);
}

static createResourceMapVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startResourceMapVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endKMLModel(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createKMLModel(builder:flatbuffers.Builder, ALTITUDE_MODE:KMLAltitudeMode, LOCATION_LON:number, LOCATION_LAT:number, LOCATION_ALT:number, ORIENTATION_HEADING:number, ORIENTATION_TILT:number, ORIENTATION_ROLL:number, SCALE_X:number, SCALE_Y:number, SCALE_Z:number, LINK_HREFOffset:flatbuffers.Offset, RESOURCE_MAPOffset:flatbuffers.Offset):flatbuffers.Offset {
  KMLModel.startKMLModel(builder);
  KMLModel.addAltitudeMode(builder, ALTITUDE_MODE);
  KMLModel.addLocationLon(builder, LOCATION_LON);
  KMLModel.addLocationLat(builder, LOCATION_LAT);
  KMLModel.addLocationAlt(builder, LOCATION_ALT);
  KMLModel.addOrientationHeading(builder, ORIENTATION_HEADING);
  KMLModel.addOrientationTilt(builder, ORIENTATION_TILT);
  KMLModel.addOrientationRoll(builder, ORIENTATION_ROLL);
  KMLModel.addScaleX(builder, SCALE_X);
  KMLModel.addScaleY(builder, SCALE_Y);
  KMLModel.addScaleZ(builder, SCALE_Z);
  KMLModel.addLinkHref(builder, LINK_HREFOffset);
  KMLModel.addResourceMap(builder, RESOURCE_MAPOffset);
  return KMLModel.endKMLModel(builder);
}

unpack(): KMLModelT {
  return new KMLModelT(
    this.ALTITUDE_MODE(),
    this.LOCATION_LON(),
    this.LOCATION_LAT(),
    this.LOCATION_ALT(),
    this.ORIENTATION_HEADING(),
    this.ORIENTATION_TILT(),
    this.ORIENTATION_ROLL(),
    this.SCALE_X(),
    this.SCALE_Y(),
    this.SCALE_Z(),
    this.LINK_HREF(),
    this.bb!.createObjList<KMLResourceMapAlias, KMLResourceMapAliasT>(this.RESOURCE_MAP.bind(this), this.resourceMapLength())
  );
}


unpackTo(_o: KMLModelT): void {
  _o.ALTITUDE_MODE = this.ALTITUDE_MODE();
  _o.LOCATION_LON = this.LOCATION_LON();
  _o.LOCATION_LAT = this.LOCATION_LAT();
  _o.LOCATION_ALT = this.LOCATION_ALT();
  _o.ORIENTATION_HEADING = this.ORIENTATION_HEADING();
  _o.ORIENTATION_TILT = this.ORIENTATION_TILT();
  _o.ORIENTATION_ROLL = this.ORIENTATION_ROLL();
  _o.SCALE_X = this.SCALE_X();
  _o.SCALE_Y = this.SCALE_Y();
  _o.SCALE_Z = this.SCALE_Z();
  _o.LINK_HREF = this.LINK_HREF();
  _o.RESOURCE_MAP = this.bb!.createObjList<KMLResourceMapAlias, KMLResourceMapAliasT>(this.RESOURCE_MAP.bind(this), this.resourceMapLength());
}
}

export class KMLModelT implements flatbuffers.IGeneratedObject {
constructor(
  public ALTITUDE_MODE: KMLAltitudeMode = KMLAltitudeMode.CLAMP_TO_GROUND,
  public LOCATION_LON: number = 0.0,
  public LOCATION_LAT: number = 0.0,
  public LOCATION_ALT: number = 0.0,
  public ORIENTATION_HEADING: number = 0.0,
  public ORIENTATION_TILT: number = 0.0,
  public ORIENTATION_ROLL: number = 0.0,
  public SCALE_X: number = 0.0,
  public SCALE_Y: number = 0.0,
  public SCALE_Z: number = 0.0,
  public LINK_HREF: string|Uint8Array|null = null,
  public RESOURCE_MAP: (KMLResourceMapAliasT)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const LINK_HREF = (this.LINK_HREF !== null ? builder.createString(this.LINK_HREF!) : 0);
  const RESOURCE_MAP = KMLModel.createResourceMapVector(builder, builder.createObjectOffsetList(this.RESOURCE_MAP));

  return KMLModel.createKMLModel(builder,
    this.ALTITUDE_MODE,
    this.LOCATION_LON,
    this.LOCATION_LAT,
    this.LOCATION_ALT,
    this.ORIENTATION_HEADING,
    this.ORIENTATION_TILT,
    this.ORIENTATION_ROLL,
    this.SCALE_X,
    this.SCALE_Y,
    this.SCALE_Z,
    LINK_HREF,
    RESOURCE_MAP
  );
}
}
