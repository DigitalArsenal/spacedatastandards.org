// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Level of Detail parameters
 */
export class KMLLod implements flatbuffers.IUnpackableObject<KMLLodT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):KMLLod {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsKMLLod(bb:flatbuffers.ByteBuffer, obj?:KMLLod):KMLLod {
  return (obj || new KMLLod()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsKMLLod(bb:flatbuffers.ByteBuffer, obj?:KMLLod):KMLLod {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new KMLLod()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Minimum LOD pixels
 */
MIN_LOD_PIXELS():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Maximum LOD pixels (-1 = infinite)
 */
MAX_LOD_PIXELS():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Minimum fade extent
 */
MIN_FADE_EXTENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Maximum fade extent
 */
MAX_FADE_EXTENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

static startKMLLod(builder:flatbuffers.Builder) {
  builder.startObject(4);
}

static addMinLodPixels(builder:flatbuffers.Builder, MIN_LOD_PIXELS:number) {
  builder.addFieldFloat64(0, MIN_LOD_PIXELS, 0.0);
}

static addMaxLodPixels(builder:flatbuffers.Builder, MAX_LOD_PIXELS:number) {
  builder.addFieldFloat64(1, MAX_LOD_PIXELS, 0.0);
}

static addMinFadeExtent(builder:flatbuffers.Builder, MIN_FADE_EXTENT:number) {
  builder.addFieldFloat64(2, MIN_FADE_EXTENT, 0.0);
}

static addMaxFadeExtent(builder:flatbuffers.Builder, MAX_FADE_EXTENT:number) {
  builder.addFieldFloat64(3, MAX_FADE_EXTENT, 0.0);
}

static endKMLLod(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createKMLLod(builder:flatbuffers.Builder, MIN_LOD_PIXELS:number, MAX_LOD_PIXELS:number, MIN_FADE_EXTENT:number, MAX_FADE_EXTENT:number):flatbuffers.Offset {
  KMLLod.startKMLLod(builder);
  KMLLod.addMinLodPixels(builder, MIN_LOD_PIXELS);
  KMLLod.addMaxLodPixels(builder, MAX_LOD_PIXELS);
  KMLLod.addMinFadeExtent(builder, MIN_FADE_EXTENT);
  KMLLod.addMaxFadeExtent(builder, MAX_FADE_EXTENT);
  return KMLLod.endKMLLod(builder);
}

unpack(): KMLLodT {
  return new KMLLodT(
    this.MIN_LOD_PIXELS(),
    this.MAX_LOD_PIXELS(),
    this.MIN_FADE_EXTENT(),
    this.MAX_FADE_EXTENT()
  );
}


unpackTo(_o: KMLLodT): void {
  _o.MIN_LOD_PIXELS = this.MIN_LOD_PIXELS();
  _o.MAX_LOD_PIXELS = this.MAX_LOD_PIXELS();
  _o.MIN_FADE_EXTENT = this.MIN_FADE_EXTENT();
  _o.MAX_FADE_EXTENT = this.MAX_FADE_EXTENT();
}
}

export class KMLLodT implements flatbuffers.IGeneratedObject {
constructor(
  public MIN_LOD_PIXELS: number = 0.0,
  public MAX_LOD_PIXELS: number = 0.0,
  public MIN_FADE_EXTENT: number = 0.0,
  public MAX_FADE_EXTENT: number = 0.0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return KMLLod.createKMLLod(builder,
    this.MIN_LOD_PIXELS,
    this.MAX_LOD_PIXELS,
    this.MIN_FADE_EXTENT,
    this.MAX_FADE_EXTENT
  );
}
}
