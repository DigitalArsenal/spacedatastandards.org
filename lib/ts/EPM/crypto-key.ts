// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { KeyType } from './key-type.js';


/**
 * Represents cryptographic key information
 */
export class CryptoKey implements flatbuffers.IUnpackableObject<CryptoKeyT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):CryptoKey {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsCryptoKey(bb:flatbuffers.ByteBuffer, obj?:CryptoKey):CryptoKey {
  return (obj || new CryptoKey()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsCryptoKey(bb:flatbuffers.ByteBuffer, obj?:CryptoKey):CryptoKey {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new CryptoKey()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Public part of the cryptographic key, in hexidecimal format
 */
publicKey():string|null
publicKey(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
publicKey(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Extended public key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
 */
xpub():string|null
xpub(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
xpub(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Private part of the cryptographic key in hexidecimal format, should be kept secret 
 */
privateKey():string|null
privateKey(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
privateKey(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Extended private key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
 */
xpriv():string|null
xpriv(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
xpriv(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Address generated from the cryptographic key
 */
keyAddress():string|null
keyAddress(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
keyAddress(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Type of the address generated from the cryptographic key
 */
addressType():string|null
addressType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
addressType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Type of the cryptographic key (signing or encryption)
 */
keyType():KeyType {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : KeyType.Signing;
}

static startCryptoKey(builder:flatbuffers.Builder) {
  builder.startObject(7);
}

static addPublicKey(builder:flatbuffers.Builder, publicKeyOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, publicKeyOffset, 0);
}

static addXpub(builder:flatbuffers.Builder, xpubOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, xpubOffset, 0);
}

static addPrivateKey(builder:flatbuffers.Builder, privateKeyOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, privateKeyOffset, 0);
}

static addXpriv(builder:flatbuffers.Builder, xprivOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, xprivOffset, 0);
}

static addKeyAddress(builder:flatbuffers.Builder, keyAddressOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, keyAddressOffset, 0);
}

static addAddressType(builder:flatbuffers.Builder, addressTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, addressTypeOffset, 0);
}

static addKeyType(builder:flatbuffers.Builder, keyType:KeyType) {
  builder.addFieldInt8(6, keyType, KeyType.Signing);
}

static endCryptoKey(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createCryptoKey(builder:flatbuffers.Builder, publicKeyOffset:flatbuffers.Offset, xpubOffset:flatbuffers.Offset, privateKeyOffset:flatbuffers.Offset, xprivOffset:flatbuffers.Offset, keyAddressOffset:flatbuffers.Offset, addressTypeOffset:flatbuffers.Offset, keyType:KeyType):flatbuffers.Offset {
  CryptoKey.startCryptoKey(builder);
  CryptoKey.addPublicKey(builder, publicKeyOffset);
  CryptoKey.addXpub(builder, xpubOffset);
  CryptoKey.addPrivateKey(builder, privateKeyOffset);
  CryptoKey.addXpriv(builder, xprivOffset);
  CryptoKey.addKeyAddress(builder, keyAddressOffset);
  CryptoKey.addAddressType(builder, addressTypeOffset);
  CryptoKey.addKeyType(builder, keyType);
  return CryptoKey.endCryptoKey(builder);
}

unpack(): CryptoKeyT {
  return new CryptoKeyT(
    this.publicKey(),
    this.xpub(),
    this.privateKey(),
    this.xpriv(),
    this.keyAddress(),
    this.addressType(),
    this.keyType()
  );
}


unpackTo(_o: CryptoKeyT): void {
  _o.publicKey = this.publicKey();
  _o.xpub = this.xpub();
  _o.privateKey = this.privateKey();
  _o.xpriv = this.xpriv();
  _o.keyAddress = this.keyAddress();
  _o.addressType = this.addressType();
  _o.keyType = this.keyType();
}
}

export class CryptoKeyT implements flatbuffers.IGeneratedObject {
constructor(
  public publicKey: string|Uint8Array|null = null,
  public xpub: string|Uint8Array|null = null,
  public privateKey: string|Uint8Array|null = null,
  public xpriv: string|Uint8Array|null = null,
  public keyAddress: string|Uint8Array|null = null,
  public addressType: string|Uint8Array|null = null,
  public keyType: KeyType = KeyType.Signing
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const publicKey = (this.publicKey !== null ? builder.createString(this.publicKey!) : 0);
  const xpub = (this.xpub !== null ? builder.createString(this.xpub!) : 0);
  const privateKey = (this.privateKey !== null ? builder.createString(this.privateKey!) : 0);
  const xpriv = (this.xpriv !== null ? builder.createString(this.xpriv!) : 0);
  const keyAddress = (this.keyAddress !== null ? builder.createString(this.keyAddress!) : 0);
  const addressType = (this.addressType !== null ? builder.createString(this.addressType!) : 0);

  return CryptoKey.createCryptoKey(builder,
    publicKey,
    xpub,
    privateKey,
    xpriv,
    keyAddress,
    addressType,
    this.keyType
  );
}
}
