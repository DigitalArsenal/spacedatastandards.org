// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { meanElementTheory } from './mean-element-theory.js';


/**
 * Minimum Propagatable Element Set
 */
export class MPE implements flatbuffers.IUnpackableObject<MPET> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):MPE {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsMPE(bb:flatbuffers.ByteBuffer, obj?:MPE):MPE {
  return (obj || new MPE()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsMPE(bb:flatbuffers.ByteBuffer, obj?:MPE):MPE {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new MPE()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$MPE');
}

/**
 * Unique ID as a String [no units]
 */
entityId():string|null
entityId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
entityId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Epoch of Mean Keplerian elements (UNIX timestamp) [numeric seconds since 1970-01-01T00:00:00 UTC]
 */
epoch():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Mean motion in rev/day [M if chosen to represent orbit size for SGP/SGP4 elements]
 */
meanMotion():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Eccentricity (unitless)
 */
eccentricity():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Inclination in degrees
 */
inclination():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Right ascension of ascending node in degrees
 */
raOfAscNode():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Argument of pericenter in degrees
 */
argOfPericenter():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Mean anomaly in degrees
 */
meanAnomaly():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * SGP/SGP4 drag-like coefficient (BSTAR) in units of 1/[Earth radii]
 */
bstar():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Description of the Mean Element Theory (SGP4, DSST, USM)
 */
meanElementTheory():meanElementTheory {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : meanElementTheory.SGP4;
}

static startMPE(builder:flatbuffers.Builder) {
  builder.startObject(10);
}

static addEntityId(builder:flatbuffers.Builder, entityIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, entityIdOffset, 0);
}

static addEpoch(builder:flatbuffers.Builder, epoch:number) {
  builder.addFieldFloat64(1, epoch, 0.0);
}

static addMeanMotion(builder:flatbuffers.Builder, meanMotion:number) {
  builder.addFieldFloat64(2, meanMotion, 0.0);
}

static addEccentricity(builder:flatbuffers.Builder, eccentricity:number) {
  builder.addFieldFloat64(3, eccentricity, 0.0);
}

static addInclination(builder:flatbuffers.Builder, inclination:number) {
  builder.addFieldFloat64(4, inclination, 0.0);
}

static addRaOfAscNode(builder:flatbuffers.Builder, raOfAscNode:number) {
  builder.addFieldFloat64(5, raOfAscNode, 0.0);
}

static addArgOfPericenter(builder:flatbuffers.Builder, argOfPericenter:number) {
  builder.addFieldFloat64(6, argOfPericenter, 0.0);
}

static addMeanAnomaly(builder:flatbuffers.Builder, meanAnomaly:number) {
  builder.addFieldFloat64(7, meanAnomaly, 0.0);
}

static addBstar(builder:flatbuffers.Builder, bstar:number) {
  builder.addFieldFloat64(8, bstar, 0.0);
}

static addMeanElementTheory(builder:flatbuffers.Builder, meanElementTheory:meanElementTheory) {
  builder.addFieldInt8(9, meanElementTheory, meanElementTheory.SGP4);
}

static endMPE(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishMPEBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$MPE');
}

static finishSizePrefixedMPEBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$MPE', true);
}

static createMPE(builder:flatbuffers.Builder, entityIdOffset:flatbuffers.Offset, epoch:number, meanMotion:number, eccentricity:number, inclination:number, raOfAscNode:number, argOfPericenter:number, meanAnomaly:number, bstar:number, meanElementTheory:meanElementTheory):flatbuffers.Offset {
  MPE.startMPE(builder);
  MPE.addEntityId(builder, entityIdOffset);
  MPE.addEpoch(builder, epoch);
  MPE.addMeanMotion(builder, meanMotion);
  MPE.addEccentricity(builder, eccentricity);
  MPE.addInclination(builder, inclination);
  MPE.addRaOfAscNode(builder, raOfAscNode);
  MPE.addArgOfPericenter(builder, argOfPericenter);
  MPE.addMeanAnomaly(builder, meanAnomaly);
  MPE.addBstar(builder, bstar);
  MPE.addMeanElementTheory(builder, meanElementTheory);
  return MPE.endMPE(builder);
}

unpack(): MPET {
  return new MPET(
    this.entityId(),
    this.epoch(),
    this.meanMotion(),
    this.eccentricity(),
    this.inclination(),
    this.raOfAscNode(),
    this.argOfPericenter(),
    this.meanAnomaly(),
    this.bstar(),
    this.meanElementTheory()
  );
}


unpackTo(_o: MPET): void {
  _o.entityId = this.entityId();
  _o.epoch = this.epoch();
  _o.meanMotion = this.meanMotion();
  _o.eccentricity = this.eccentricity();
  _o.inclination = this.inclination();
  _o.raOfAscNode = this.raOfAscNode();
  _o.argOfPericenter = this.argOfPericenter();
  _o.meanAnomaly = this.meanAnomaly();
  _o.bstar = this.bstar();
  _o.meanElementTheory = this.meanElementTheory();
}
}

export class MPET implements flatbuffers.IGeneratedObject {
constructor(
  public entityId: string|Uint8Array|null = null,
  public epoch: number = 0.0,
  public meanMotion: number = 0.0,
  public eccentricity: number = 0.0,
  public inclination: number = 0.0,
  public raOfAscNode: number = 0.0,
  public argOfPericenter: number = 0.0,
  public meanAnomaly: number = 0.0,
  public bstar: number = 0.0,
  public meanElementTheory: meanElementTheory = meanElementTheory.SGP4
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const entityId = (this.entityId !== null ? builder.createString(this.entityId!) : 0);

  return MPE.createMPE(builder,
    entityId,
    this.epoch,
    this.meanMotion,
    this.eccentricity,
    this.inclination,
    this.raOfAscNode,
    this.argOfPericenter,
    this.meanAnomaly,
    this.bstar,
    this.meanElementTheory
  );
}
}
