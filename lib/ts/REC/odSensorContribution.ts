// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Sensor contribution to an orbit determination solution
 */
export class odSensorContribution implements flatbuffers.IUnpackableObject<odSensorContributionT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):odSensorContribution {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsodSensorContribution(bb:flatbuffers.ByteBuffer, obj?:odSensorContribution):odSensorContribution {
  return (obj || new odSensorContribution()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsodSensorContribution(bb:flatbuffers.ByteBuffer, obj?:odSensorContribution):odSensorContribution {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new odSensorContribution()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Sensor identifier
 */
SENSOR_ID():string|null
SENSOR_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SENSOR_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Original sensor identifier
 */
ORIG_SENSOR_ID():string|null
ORIG_SENSOR_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIG_SENSOR_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Number of accepted observations from this sensor
 */
NUM_ACCEPTED():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * Number of rejected observations from this sensor
 */
NUM_REJECTED():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * Weighted RMS for this sensor's observations
 */
WRMS():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Observation types from this sensor
 */
OB_TYPES(index: number):string
OB_TYPES(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
OB_TYPES(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

obTypesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startodSensorContribution(builder:flatbuffers.Builder) {
  builder.startObject(6);
}

static addSensorId(builder:flatbuffers.Builder, SENSOR_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, SENSOR_IDOffset, 0);
}

static addOrigSensorId(builder:flatbuffers.Builder, ORIG_SENSOR_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, ORIG_SENSOR_IDOffset, 0);
}

static addNumAccepted(builder:flatbuffers.Builder, NUM_ACCEPTED:number) {
  builder.addFieldInt32(2, NUM_ACCEPTED, 0);
}

static addNumRejected(builder:flatbuffers.Builder, NUM_REJECTED:number) {
  builder.addFieldInt32(3, NUM_REJECTED, 0);
}

static addWrms(builder:flatbuffers.Builder, WRMS:number) {
  builder.addFieldFloat64(4, WRMS, 0.0);
}

static addObTypes(builder:flatbuffers.Builder, OB_TYPESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, OB_TYPESOffset, 0);
}

static createObTypesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startObTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endodSensorContribution(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createodSensorContribution(builder:flatbuffers.Builder, SENSOR_IDOffset:flatbuffers.Offset, ORIG_SENSOR_IDOffset:flatbuffers.Offset, NUM_ACCEPTED:number, NUM_REJECTED:number, WRMS:number, OB_TYPESOffset:flatbuffers.Offset):flatbuffers.Offset {
  odSensorContribution.startodSensorContribution(builder);
  odSensorContribution.addSensorId(builder, SENSOR_IDOffset);
  odSensorContribution.addOrigSensorId(builder, ORIG_SENSOR_IDOffset);
  odSensorContribution.addNumAccepted(builder, NUM_ACCEPTED);
  odSensorContribution.addNumRejected(builder, NUM_REJECTED);
  odSensorContribution.addWrms(builder, WRMS);
  odSensorContribution.addObTypes(builder, OB_TYPESOffset);
  return odSensorContribution.endodSensorContribution(builder);
}

unpack(): odSensorContributionT {
  return new odSensorContributionT(
    this.SENSOR_ID(),
    this.ORIG_SENSOR_ID(),
    this.NUM_ACCEPTED(),
    this.NUM_REJECTED(),
    this.WRMS(),
    this.bb!.createScalarList<string>(this.OB_TYPES.bind(this), this.obTypesLength())
  );
}


unpackTo(_o: odSensorContributionT): void {
  _o.SENSOR_ID = this.SENSOR_ID();
  _o.ORIG_SENSOR_ID = this.ORIG_SENSOR_ID();
  _o.NUM_ACCEPTED = this.NUM_ACCEPTED();
  _o.NUM_REJECTED = this.NUM_REJECTED();
  _o.WRMS = this.WRMS();
  _o.OB_TYPES = this.bb!.createScalarList<string>(this.OB_TYPES.bind(this), this.obTypesLength());
}
}

export class odSensorContributionT implements flatbuffers.IGeneratedObject {
constructor(
  public SENSOR_ID: string|Uint8Array|null = null,
  public ORIG_SENSOR_ID: string|Uint8Array|null = null,
  public NUM_ACCEPTED: number = 0,
  public NUM_REJECTED: number = 0,
  public WRMS: number = 0.0,
  public OB_TYPES: (string)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const SENSOR_ID = (this.SENSOR_ID !== null ? builder.createString(this.SENSOR_ID!) : 0);
  const ORIG_SENSOR_ID = (this.ORIG_SENSOR_ID !== null ? builder.createString(this.ORIG_SENSOR_ID!) : 0);
  const OB_TYPES = odSensorContribution.createObTypesVector(builder, builder.createObjectOffsetList(this.OB_TYPES));

  return odSensorContribution.createodSensorContribution(builder,
    SENSOR_ID,
    ORIG_SENSOR_ID,
    this.NUM_ACCEPTED,
    this.NUM_REJECTED,
    this.WRMS,
    OB_TYPES
  );
}
}
