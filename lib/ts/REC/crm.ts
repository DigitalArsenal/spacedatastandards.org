// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Collection Request Message
 */
export class CRM implements flatbuffers.IUnpackableObject<CRMT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):CRM {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsCRM(bb:flatbuffers.ByteBuffer, obj?:CRM):CRM {
  return (obj || new CRM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsCRM(bb:flatbuffers.ByteBuffer, obj?:CRM):CRM {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new CRM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$CRM');
}

/**
 * Unique identifier of the record, auto-generated by the system.
 */
id():string|null
id(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
id(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 */
classification():string|null
classification(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
classification(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The type of this collect or contact request.
 */
type():string|null
type(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
type(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique identifier of the parent plan or schedule associated with this request.
 */
idPlan():string|null
idPlan(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idPlan(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Index number for records within a collection plan or schedule.
 */
planIndex():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Task ID associated with this request.
 */
taskId():string|null
taskId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
taskId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The dwell ID associated with this request.
 */
dwellId():string|null
dwellId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
dwellId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional ID from external systems.
 */
externalId():string|null
externalId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
externalId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique identifier of the requested/scheduled/planned sensor associated with this request.
 */
idSensor():string|null
idSensor(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idSensor(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request.
 */
origSensorId():string|null
origSensorId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origSensorId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional type of observation requested.
 */
obType():string|null
obType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
obType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The priority of the collect request.
 */
priority():string|null
priority(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
priority(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The tasking category associated with this request.
 */
taskCategory():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The tasking suffix associated with this request.
 */
suffix():string|null
suffix(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
suffix(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Boolean indicating that this collect request is UCT follow-up.
 */
uctFollowUp():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The start time of the collect or contact request window, in ISO 8601 UTC format.
 */
startTime():string|null
startTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
startTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The end time of the collect or contact request window, in ISO 8601 UTC format.
 */
endTime():string|null
endTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
endTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Satellite/catalog number of the target on-orbit object for this request.
 */
noradCatId():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * Optional identifier provided by the data source to indicate the target object of this request.
 */
origObjectId():string|null
origObjectId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origObjectId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The tasking group to which the target object is assigned.
 */
taskGroup():string|null
taskGroup(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
taskGroup(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Inter-Range Operations Number.
 */
iron():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The orbit regime of the target.
 */
orbitRegime():string|null
orbitRegime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
orbitRegime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The minimum object (diameter) size, in meters, to be reported.
 */
targetSize():number {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The minimum Radar Cross-Section of the target, in m^2.
 */
rcsMin():number {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The Radar Cross-Section of the target, in m^2.
 */
rcs():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum Radar Cross-Section of the target, in m^2.
 */
rcsMax():number {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The minimum frequency of interest, in MHz.
 */
freqMin():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The estimated or expected emission frequency of the target, in MHz.
 */
freq():number {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum frequency of interest, in MHz.
 */
freqMax():number {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The RF polarization.
 */
polarization():string|null
polarization(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
polarization(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).
 */
visMagMin():number {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The estimated or expected visual magnitude of the target, in Magnitudes (M).
 */
visMag():number {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
 */
visMagMax():number {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The spectral model used for the irradiance calculation.
 */
spectralModel():string|null
spectralModel(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
spectralModel(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The fraction of solar energy reflected from target.
 */
reflectance():number {
  const offset = this.bb!.__offset(this.bb_pos, 72);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The target object irradiance value.
 */
irradiance():number {
  const offset = this.bb!.__offset(this.bb_pos, 74);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For optical sensors, the requested number of frames to capture at each sensor step.
 */
numFrames():number {
  const offset = this.bb!.__offset(this.bb_pos, 76);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * For optical sensors, the frame rate of the camera, in Hz.
 */
frameRate():number {
  const offset = this.bb!.__offset(this.bb_pos, 78);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For optical sensors, the integration time per camera frame, in milliseconds.
 */
integrationTime():number {
  const offset = this.bb!.__offset(this.bb_pos, 80);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The number of requested tracks on the target.
 */
numTracks():number {
  const offset = this.bb!.__offset(this.bb_pos, 82);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The number of requested observations on the target.
 */
numObs():number {
  const offset = this.bb!.__offset(this.bb_pos, 84);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The duration of the collect request, in seconds.
 */
duration():number {
  const offset = this.bb!.__offset(this.bb_pos, 86);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The search pattern to be executed for this request.
 */
srchPattern():string|null
srchPattern(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
srchPattern(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 88);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
 */
scenario():string|null
scenario(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
scenario(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 90);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the Elset of the object associated with this request.
 */
idElset():string|null
idElset(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idElset(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 92);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the Manifold Elset of the object associated with this request.
 */
idManifold():string|null
idManifold(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idManifold(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 94);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the State Vector of the object or central vector associated with this request.
 */
idStateVector():string|null
idStateVector(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idStateVector(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 96);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the Ephemeris Set of the object associated with this request.
 */
esId():string|null
esId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
esId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 98);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Epoch time, in ISO 8601 UTC format, of the orbital elements.
 */
epoch():string|null
epoch(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
epoch(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 100);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The average of the periapsis and apoapsis distances, in kilometers.
 */
semiMajorAxis():number {
  const offset = this.bb!.__offset(this.bb_pos, 102);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The orbital eccentricity of an astronomical object.
 */
eccentricity():number {
  const offset = this.bb!.__offset(this.bb_pos, 104);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The angle, in degrees, between the equator and the orbit plane.
 */
inclination():number {
  const offset = this.bb!.__offset(this.bb_pos, 106);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Right ascension of the ascending node, in degrees.
 */
raan():number {
  const offset = this.bb!.__offset(this.bb_pos, 108);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The argument of perigee, in degrees.
 */
argOfPerigee():number {
  const offset = this.bb!.__offset(this.bb_pos, 110);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The mean anomaly defines the angular position, in degrees, of the object on its orbital path.
 */
meanAnomaly():number {
  const offset = this.bb!.__offset(this.bb_pos, 112);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed right ascension angle, in degrees.
 */
ra():number {
  const offset = this.bb!.__offset(this.bb_pos, 114);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed declination angle, in degrees.
 */
dec():number {
  const offset = this.bb!.__offset(this.bb_pos, 116);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed azimuth angle, in degrees.
 */
az():number {
  const offset = this.bb!.__offset(this.bb_pos, 118);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed elevation angle, in degrees.
 */
el():number {
  const offset = this.bb!.__offset(this.bb_pos, 120);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected acquisition range or defined center range, in km.
 */
range():number {
  const offset = this.bb!.__offset(this.bb_pos, 122);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The extent of the azimuth angle, in degrees, from center azimuth.
 */
extentAz():number {
  const offset = this.bb!.__offset(this.bb_pos, 124);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The extent of the elevation angle, in degrees, from center elevation.
 */
extentEl():number {
  const offset = this.bb!.__offset(this.bb_pos, 126);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The extent of the range, in km, from center range.
 */
extentRange():number {
  const offset = this.bb!.__offset(this.bb_pos, 128);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * WGS-84 latitude, in degrees.
 */
lat():number {
  const offset = this.bb!.__offset(this.bb_pos, 130);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * WGS-84 longitude, in degrees.
 */
lon():number {
  const offset = this.bb!.__offset(this.bb_pos, 132);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Height above WGS-84 ellipsoid (HAE), in kilometers.
 */
alt():number {
  const offset = this.bb!.__offset(this.bb_pos, 134);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The stopping WGS-84 latitude of a volume definition, in degrees.
 */
stopLat():number {
  const offset = this.bb!.__offset(this.bb_pos, 136);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The stopping WGS-84 longitude of a volume definition, in degrees.
 */
stopLon():number {
  const offset = this.bb!.__offset(this.bb_pos, 138);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The stopping HAE WGS-84 height above ellipsoid (HAE), in kilometers.
 */
stopAlt():number {
  const offset = this.bb!.__offset(this.bb_pos, 140);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum inclination, in degrees, to be used in search operations.
 */
srchInc():number {
  const offset = this.bb!.__offset(this.bb_pos, 142);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The angular distance, in degrees, in the sensor-x direction from scan center.
 */
xAngle():number {
  const offset = this.bb!.__offset(this.bb_pos, 144);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The angular distance, in degrees, in the sensor-y direction from scan center.
 */
yAngle():number {
  const offset = this.bb!.__offset(this.bb_pos, 146);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.
 */
orientAngle():number {
  const offset = this.bb!.__offset(this.bb_pos, 148);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The customer for this request.
 */
customer():string|null
customer(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
customer(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 150);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Notes or comments associated with this request.
 */
notes():string|null
notes(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
notes(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 152);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 *  Source of the data.
 */
source():string|null
source(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
source(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 154);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 *  Originating system or organization which produced the data, if different from the source.
 */
origin():string|null
origin(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origin(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 156);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 *  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data.
 */
dataMode():string|null
dataMode(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
dataMode(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 158);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startCRM(builder:flatbuffers.Builder) {
  builder.startObject(78);
}

static addId(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idOffset, 0);
}

static addClassification(builder:flatbuffers.Builder, classificationOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, classificationOffset, 0);
}

static addType(builder:flatbuffers.Builder, typeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, typeOffset, 0);
}

static addIdPlan(builder:flatbuffers.Builder, idPlanOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, idPlanOffset, 0);
}

static addPlanIndex(builder:flatbuffers.Builder, planIndex:number) {
  builder.addFieldInt32(4, planIndex, 0);
}

static addTaskId(builder:flatbuffers.Builder, taskIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, taskIdOffset, 0);
}

static addDwellId(builder:flatbuffers.Builder, dwellIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, dwellIdOffset, 0);
}

static addExternalId(builder:flatbuffers.Builder, externalIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, externalIdOffset, 0);
}

static addIdSensor(builder:flatbuffers.Builder, idSensorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, idSensorOffset, 0);
}

static addOrigSensorId(builder:flatbuffers.Builder, origSensorIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, origSensorIdOffset, 0);
}

static addObType(builder:flatbuffers.Builder, obTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, obTypeOffset, 0);
}

static addPriority(builder:flatbuffers.Builder, priorityOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, priorityOffset, 0);
}

static addTaskCategory(builder:flatbuffers.Builder, taskCategory:number) {
  builder.addFieldInt32(12, taskCategory, 0);
}

static addSuffix(builder:flatbuffers.Builder, suffixOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, suffixOffset, 0);
}

static addUctFollowUp(builder:flatbuffers.Builder, uctFollowUp:boolean) {
  builder.addFieldInt8(14, +uctFollowUp, +false);
}

static addStartTime(builder:flatbuffers.Builder, startTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, startTimeOffset, 0);
}

static addEndTime(builder:flatbuffers.Builder, endTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, endTimeOffset, 0);
}

static addNoradCatId(builder:flatbuffers.Builder, noradCatId:number) {
  builder.addFieldInt32(17, noradCatId, 0);
}

static addOrigObjectId(builder:flatbuffers.Builder, origObjectIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(18, origObjectIdOffset, 0);
}

static addTaskGroup(builder:flatbuffers.Builder, taskGroupOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, taskGroupOffset, 0);
}

static addIron(builder:flatbuffers.Builder, iron:number) {
  builder.addFieldInt32(20, iron, 0);
}

static addOrbitRegime(builder:flatbuffers.Builder, orbitRegimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(21, orbitRegimeOffset, 0);
}

static addTargetSize(builder:flatbuffers.Builder, targetSize:number) {
  builder.addFieldFloat64(22, targetSize, 0.0);
}

static addRcsMin(builder:flatbuffers.Builder, rcsMin:number) {
  builder.addFieldFloat64(23, rcsMin, 0.0);
}

static addRcs(builder:flatbuffers.Builder, rcs:number) {
  builder.addFieldFloat64(24, rcs, 0.0);
}

static addRcsMax(builder:flatbuffers.Builder, rcsMax:number) {
  builder.addFieldFloat64(25, rcsMax, 0.0);
}

static addFreqMin(builder:flatbuffers.Builder, freqMin:number) {
  builder.addFieldFloat64(26, freqMin, 0.0);
}

static addFreq(builder:flatbuffers.Builder, freq:number) {
  builder.addFieldFloat64(27, freq, 0.0);
}

static addFreqMax(builder:flatbuffers.Builder, freqMax:number) {
  builder.addFieldFloat64(28, freqMax, 0.0);
}

static addPolarization(builder:flatbuffers.Builder, polarizationOffset:flatbuffers.Offset) {
  builder.addFieldOffset(29, polarizationOffset, 0);
}

static addVisMagMin(builder:flatbuffers.Builder, visMagMin:number) {
  builder.addFieldFloat64(30, visMagMin, 0.0);
}

static addVisMag(builder:flatbuffers.Builder, visMag:number) {
  builder.addFieldFloat64(31, visMag, 0.0);
}

static addVisMagMax(builder:flatbuffers.Builder, visMagMax:number) {
  builder.addFieldFloat64(32, visMagMax, 0.0);
}

static addSpectralModel(builder:flatbuffers.Builder, spectralModelOffset:flatbuffers.Offset) {
  builder.addFieldOffset(33, spectralModelOffset, 0);
}

static addReflectance(builder:flatbuffers.Builder, reflectance:number) {
  builder.addFieldFloat64(34, reflectance, 0.0);
}

static addIrradiance(builder:flatbuffers.Builder, irradiance:number) {
  builder.addFieldFloat64(35, irradiance, 0.0);
}

static addNumFrames(builder:flatbuffers.Builder, numFrames:number) {
  builder.addFieldInt32(36, numFrames, 0);
}

static addFrameRate(builder:flatbuffers.Builder, frameRate:number) {
  builder.addFieldFloat64(37, frameRate, 0.0);
}

static addIntegrationTime(builder:flatbuffers.Builder, integrationTime:number) {
  builder.addFieldFloat64(38, integrationTime, 0.0);
}

static addNumTracks(builder:flatbuffers.Builder, numTracks:number) {
  builder.addFieldInt32(39, numTracks, 0);
}

static addNumObs(builder:flatbuffers.Builder, numObs:number) {
  builder.addFieldInt32(40, numObs, 0);
}

static addDuration(builder:flatbuffers.Builder, duration:number) {
  builder.addFieldInt32(41, duration, 0);
}

static addSrchPattern(builder:flatbuffers.Builder, srchPatternOffset:flatbuffers.Offset) {
  builder.addFieldOffset(42, srchPatternOffset, 0);
}

static addScenario(builder:flatbuffers.Builder, scenarioOffset:flatbuffers.Offset) {
  builder.addFieldOffset(43, scenarioOffset, 0);
}

static addIdElset(builder:flatbuffers.Builder, idElsetOffset:flatbuffers.Offset) {
  builder.addFieldOffset(44, idElsetOffset, 0);
}

static addIdManifold(builder:flatbuffers.Builder, idManifoldOffset:flatbuffers.Offset) {
  builder.addFieldOffset(45, idManifoldOffset, 0);
}

static addIdStateVector(builder:flatbuffers.Builder, idStateVectorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(46, idStateVectorOffset, 0);
}

static addEsId(builder:flatbuffers.Builder, esIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(47, esIdOffset, 0);
}

static addEpoch(builder:flatbuffers.Builder, epochOffset:flatbuffers.Offset) {
  builder.addFieldOffset(48, epochOffset, 0);
}

static addSemiMajorAxis(builder:flatbuffers.Builder, semiMajorAxis:number) {
  builder.addFieldFloat64(49, semiMajorAxis, 0.0);
}

static addEccentricity(builder:flatbuffers.Builder, eccentricity:number) {
  builder.addFieldFloat64(50, eccentricity, 0.0);
}

static addInclination(builder:flatbuffers.Builder, inclination:number) {
  builder.addFieldFloat64(51, inclination, 0.0);
}

static addRaan(builder:flatbuffers.Builder, raan:number) {
  builder.addFieldFloat64(52, raan, 0.0);
}

static addArgOfPerigee(builder:flatbuffers.Builder, argOfPerigee:number) {
  builder.addFieldFloat64(53, argOfPerigee, 0.0);
}

static addMeanAnomaly(builder:flatbuffers.Builder, meanAnomaly:number) {
  builder.addFieldFloat64(54, meanAnomaly, 0.0);
}

static addRa(builder:flatbuffers.Builder, ra:number) {
  builder.addFieldFloat64(55, ra, 0.0);
}

static addDec(builder:flatbuffers.Builder, dec:number) {
  builder.addFieldFloat64(56, dec, 0.0);
}

static addAz(builder:flatbuffers.Builder, az:number) {
  builder.addFieldFloat64(57, az, 0.0);
}

static addEl(builder:flatbuffers.Builder, el:number) {
  builder.addFieldFloat64(58, el, 0.0);
}

static addRange(builder:flatbuffers.Builder, range:number) {
  builder.addFieldFloat64(59, range, 0.0);
}

static addExtentAz(builder:flatbuffers.Builder, extentAz:number) {
  builder.addFieldFloat64(60, extentAz, 0.0);
}

static addExtentEl(builder:flatbuffers.Builder, extentEl:number) {
  builder.addFieldFloat64(61, extentEl, 0.0);
}

static addExtentRange(builder:flatbuffers.Builder, extentRange:number) {
  builder.addFieldFloat64(62, extentRange, 0.0);
}

static addLat(builder:flatbuffers.Builder, lat:number) {
  builder.addFieldFloat64(63, lat, 0.0);
}

static addLon(builder:flatbuffers.Builder, lon:number) {
  builder.addFieldFloat64(64, lon, 0.0);
}

static addAlt(builder:flatbuffers.Builder, alt:number) {
  builder.addFieldFloat64(65, alt, 0.0);
}

static addStopLat(builder:flatbuffers.Builder, stopLat:number) {
  builder.addFieldFloat64(66, stopLat, 0.0);
}

static addStopLon(builder:flatbuffers.Builder, stopLon:number) {
  builder.addFieldFloat64(67, stopLon, 0.0);
}

static addStopAlt(builder:flatbuffers.Builder, stopAlt:number) {
  builder.addFieldFloat64(68, stopAlt, 0.0);
}

static addSrchInc(builder:flatbuffers.Builder, srchInc:number) {
  builder.addFieldFloat64(69, srchInc, 0.0);
}

static addXAngle(builder:flatbuffers.Builder, xAngle:number) {
  builder.addFieldFloat64(70, xAngle, 0.0);
}

static addYAngle(builder:flatbuffers.Builder, yAngle:number) {
  builder.addFieldFloat64(71, yAngle, 0.0);
}

static addOrientAngle(builder:flatbuffers.Builder, orientAngle:number) {
  builder.addFieldFloat64(72, orientAngle, 0.0);
}

static addCustomer(builder:flatbuffers.Builder, customerOffset:flatbuffers.Offset) {
  builder.addFieldOffset(73, customerOffset, 0);
}

static addNotes(builder:flatbuffers.Builder, notesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(74, notesOffset, 0);
}

static addSource(builder:flatbuffers.Builder, sourceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(75, sourceOffset, 0);
}

static addOrigin(builder:flatbuffers.Builder, originOffset:flatbuffers.Offset) {
  builder.addFieldOffset(76, originOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, dataModeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(77, dataModeOffset, 0);
}

static endCRM(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishCRMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$CRM');
}

static finishSizePrefixedCRMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$CRM', true);
}

static createCRM(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset, classificationOffset:flatbuffers.Offset, typeOffset:flatbuffers.Offset, idPlanOffset:flatbuffers.Offset, planIndex:number, taskIdOffset:flatbuffers.Offset, dwellIdOffset:flatbuffers.Offset, externalIdOffset:flatbuffers.Offset, idSensorOffset:flatbuffers.Offset, origSensorIdOffset:flatbuffers.Offset, obTypeOffset:flatbuffers.Offset, priorityOffset:flatbuffers.Offset, taskCategory:number, suffixOffset:flatbuffers.Offset, uctFollowUp:boolean, startTimeOffset:flatbuffers.Offset, endTimeOffset:flatbuffers.Offset, noradCatId:number, origObjectIdOffset:flatbuffers.Offset, taskGroupOffset:flatbuffers.Offset, iron:number, orbitRegimeOffset:flatbuffers.Offset, targetSize:number, rcsMin:number, rcs:number, rcsMax:number, freqMin:number, freq:number, freqMax:number, polarizationOffset:flatbuffers.Offset, visMagMin:number, visMag:number, visMagMax:number, spectralModelOffset:flatbuffers.Offset, reflectance:number, irradiance:number, numFrames:number, frameRate:number, integrationTime:number, numTracks:number, numObs:number, duration:number, srchPatternOffset:flatbuffers.Offset, scenarioOffset:flatbuffers.Offset, idElsetOffset:flatbuffers.Offset, idManifoldOffset:flatbuffers.Offset, idStateVectorOffset:flatbuffers.Offset, esIdOffset:flatbuffers.Offset, epochOffset:flatbuffers.Offset, semiMajorAxis:number, eccentricity:number, inclination:number, raan:number, argOfPerigee:number, meanAnomaly:number, ra:number, dec:number, az:number, el:number, range:number, extentAz:number, extentEl:number, extentRange:number, lat:number, lon:number, alt:number, stopLat:number, stopLon:number, stopAlt:number, srchInc:number, xAngle:number, yAngle:number, orientAngle:number, customerOffset:flatbuffers.Offset, notesOffset:flatbuffers.Offset, sourceOffset:flatbuffers.Offset, originOffset:flatbuffers.Offset, dataModeOffset:flatbuffers.Offset):flatbuffers.Offset {
  CRM.startCRM(builder);
  CRM.addId(builder, idOffset);
  CRM.addClassification(builder, classificationOffset);
  CRM.addType(builder, typeOffset);
  CRM.addIdPlan(builder, idPlanOffset);
  CRM.addPlanIndex(builder, planIndex);
  CRM.addTaskId(builder, taskIdOffset);
  CRM.addDwellId(builder, dwellIdOffset);
  CRM.addExternalId(builder, externalIdOffset);
  CRM.addIdSensor(builder, idSensorOffset);
  CRM.addOrigSensorId(builder, origSensorIdOffset);
  CRM.addObType(builder, obTypeOffset);
  CRM.addPriority(builder, priorityOffset);
  CRM.addTaskCategory(builder, taskCategory);
  CRM.addSuffix(builder, suffixOffset);
  CRM.addUctFollowUp(builder, uctFollowUp);
  CRM.addStartTime(builder, startTimeOffset);
  CRM.addEndTime(builder, endTimeOffset);
  CRM.addNoradCatId(builder, noradCatId);
  CRM.addOrigObjectId(builder, origObjectIdOffset);
  CRM.addTaskGroup(builder, taskGroupOffset);
  CRM.addIron(builder, iron);
  CRM.addOrbitRegime(builder, orbitRegimeOffset);
  CRM.addTargetSize(builder, targetSize);
  CRM.addRcsMin(builder, rcsMin);
  CRM.addRcs(builder, rcs);
  CRM.addRcsMax(builder, rcsMax);
  CRM.addFreqMin(builder, freqMin);
  CRM.addFreq(builder, freq);
  CRM.addFreqMax(builder, freqMax);
  CRM.addPolarization(builder, polarizationOffset);
  CRM.addVisMagMin(builder, visMagMin);
  CRM.addVisMag(builder, visMag);
  CRM.addVisMagMax(builder, visMagMax);
  CRM.addSpectralModel(builder, spectralModelOffset);
  CRM.addReflectance(builder, reflectance);
  CRM.addIrradiance(builder, irradiance);
  CRM.addNumFrames(builder, numFrames);
  CRM.addFrameRate(builder, frameRate);
  CRM.addIntegrationTime(builder, integrationTime);
  CRM.addNumTracks(builder, numTracks);
  CRM.addNumObs(builder, numObs);
  CRM.addDuration(builder, duration);
  CRM.addSrchPattern(builder, srchPatternOffset);
  CRM.addScenario(builder, scenarioOffset);
  CRM.addIdElset(builder, idElsetOffset);
  CRM.addIdManifold(builder, idManifoldOffset);
  CRM.addIdStateVector(builder, idStateVectorOffset);
  CRM.addEsId(builder, esIdOffset);
  CRM.addEpoch(builder, epochOffset);
  CRM.addSemiMajorAxis(builder, semiMajorAxis);
  CRM.addEccentricity(builder, eccentricity);
  CRM.addInclination(builder, inclination);
  CRM.addRaan(builder, raan);
  CRM.addArgOfPerigee(builder, argOfPerigee);
  CRM.addMeanAnomaly(builder, meanAnomaly);
  CRM.addRa(builder, ra);
  CRM.addDec(builder, dec);
  CRM.addAz(builder, az);
  CRM.addEl(builder, el);
  CRM.addRange(builder, range);
  CRM.addExtentAz(builder, extentAz);
  CRM.addExtentEl(builder, extentEl);
  CRM.addExtentRange(builder, extentRange);
  CRM.addLat(builder, lat);
  CRM.addLon(builder, lon);
  CRM.addAlt(builder, alt);
  CRM.addStopLat(builder, stopLat);
  CRM.addStopLon(builder, stopLon);
  CRM.addStopAlt(builder, stopAlt);
  CRM.addSrchInc(builder, srchInc);
  CRM.addXAngle(builder, xAngle);
  CRM.addYAngle(builder, yAngle);
  CRM.addOrientAngle(builder, orientAngle);
  CRM.addCustomer(builder, customerOffset);
  CRM.addNotes(builder, notesOffset);
  CRM.addSource(builder, sourceOffset);
  CRM.addOrigin(builder, originOffset);
  CRM.addDataMode(builder, dataModeOffset);
  return CRM.endCRM(builder);
}

unpack(): CRMT {
  return new CRMT(
    this.id(),
    this.classification(),
    this.type(),
    this.idPlan(),
    this.planIndex(),
    this.taskId(),
    this.dwellId(),
    this.externalId(),
    this.idSensor(),
    this.origSensorId(),
    this.obType(),
    this.priority(),
    this.taskCategory(),
    this.suffix(),
    this.uctFollowUp(),
    this.startTime(),
    this.endTime(),
    this.noradCatId(),
    this.origObjectId(),
    this.taskGroup(),
    this.iron(),
    this.orbitRegime(),
    this.targetSize(),
    this.rcsMin(),
    this.rcs(),
    this.rcsMax(),
    this.freqMin(),
    this.freq(),
    this.freqMax(),
    this.polarization(),
    this.visMagMin(),
    this.visMag(),
    this.visMagMax(),
    this.spectralModel(),
    this.reflectance(),
    this.irradiance(),
    this.numFrames(),
    this.frameRate(),
    this.integrationTime(),
    this.numTracks(),
    this.numObs(),
    this.duration(),
    this.srchPattern(),
    this.scenario(),
    this.idElset(),
    this.idManifold(),
    this.idStateVector(),
    this.esId(),
    this.epoch(),
    this.semiMajorAxis(),
    this.eccentricity(),
    this.inclination(),
    this.raan(),
    this.argOfPerigee(),
    this.meanAnomaly(),
    this.ra(),
    this.dec(),
    this.az(),
    this.el(),
    this.range(),
    this.extentAz(),
    this.extentEl(),
    this.extentRange(),
    this.lat(),
    this.lon(),
    this.alt(),
    this.stopLat(),
    this.stopLon(),
    this.stopAlt(),
    this.srchInc(),
    this.xAngle(),
    this.yAngle(),
    this.orientAngle(),
    this.customer(),
    this.notes(),
    this.source(),
    this.origin(),
    this.dataMode()
  );
}


unpackTo(_o: CRMT): void {
  _o.id = this.id();
  _o.classification = this.classification();
  _o.type = this.type();
  _o.idPlan = this.idPlan();
  _o.planIndex = this.planIndex();
  _o.taskId = this.taskId();
  _o.dwellId = this.dwellId();
  _o.externalId = this.externalId();
  _o.idSensor = this.idSensor();
  _o.origSensorId = this.origSensorId();
  _o.obType = this.obType();
  _o.priority = this.priority();
  _o.taskCategory = this.taskCategory();
  _o.suffix = this.suffix();
  _o.uctFollowUp = this.uctFollowUp();
  _o.startTime = this.startTime();
  _o.endTime = this.endTime();
  _o.noradCatId = this.noradCatId();
  _o.origObjectId = this.origObjectId();
  _o.taskGroup = this.taskGroup();
  _o.iron = this.iron();
  _o.orbitRegime = this.orbitRegime();
  _o.targetSize = this.targetSize();
  _o.rcsMin = this.rcsMin();
  _o.rcs = this.rcs();
  _o.rcsMax = this.rcsMax();
  _o.freqMin = this.freqMin();
  _o.freq = this.freq();
  _o.freqMax = this.freqMax();
  _o.polarization = this.polarization();
  _o.visMagMin = this.visMagMin();
  _o.visMag = this.visMag();
  _o.visMagMax = this.visMagMax();
  _o.spectralModel = this.spectralModel();
  _o.reflectance = this.reflectance();
  _o.irradiance = this.irradiance();
  _o.numFrames = this.numFrames();
  _o.frameRate = this.frameRate();
  _o.integrationTime = this.integrationTime();
  _o.numTracks = this.numTracks();
  _o.numObs = this.numObs();
  _o.duration = this.duration();
  _o.srchPattern = this.srchPattern();
  _o.scenario = this.scenario();
  _o.idElset = this.idElset();
  _o.idManifold = this.idManifold();
  _o.idStateVector = this.idStateVector();
  _o.esId = this.esId();
  _o.epoch = this.epoch();
  _o.semiMajorAxis = this.semiMajorAxis();
  _o.eccentricity = this.eccentricity();
  _o.inclination = this.inclination();
  _o.raan = this.raan();
  _o.argOfPerigee = this.argOfPerigee();
  _o.meanAnomaly = this.meanAnomaly();
  _o.ra = this.ra();
  _o.dec = this.dec();
  _o.az = this.az();
  _o.el = this.el();
  _o.range = this.range();
  _o.extentAz = this.extentAz();
  _o.extentEl = this.extentEl();
  _o.extentRange = this.extentRange();
  _o.lat = this.lat();
  _o.lon = this.lon();
  _o.alt = this.alt();
  _o.stopLat = this.stopLat();
  _o.stopLon = this.stopLon();
  _o.stopAlt = this.stopAlt();
  _o.srchInc = this.srchInc();
  _o.xAngle = this.xAngle();
  _o.yAngle = this.yAngle();
  _o.orientAngle = this.orientAngle();
  _o.customer = this.customer();
  _o.notes = this.notes();
  _o.source = this.source();
  _o.origin = this.origin();
  _o.dataMode = this.dataMode();
}
}

export class CRMT implements flatbuffers.IGeneratedObject {
constructor(
  public id: string|Uint8Array|null = null,
  public classification: string|Uint8Array|null = null,
  public type: string|Uint8Array|null = null,
  public idPlan: string|Uint8Array|null = null,
  public planIndex: number = 0,
  public taskId: string|Uint8Array|null = null,
  public dwellId: string|Uint8Array|null = null,
  public externalId: string|Uint8Array|null = null,
  public idSensor: string|Uint8Array|null = null,
  public origSensorId: string|Uint8Array|null = null,
  public obType: string|Uint8Array|null = null,
  public priority: string|Uint8Array|null = null,
  public taskCategory: number = 0,
  public suffix: string|Uint8Array|null = null,
  public uctFollowUp: boolean = false,
  public startTime: string|Uint8Array|null = null,
  public endTime: string|Uint8Array|null = null,
  public noradCatId: number = 0,
  public origObjectId: string|Uint8Array|null = null,
  public taskGroup: string|Uint8Array|null = null,
  public iron: number = 0,
  public orbitRegime: string|Uint8Array|null = null,
  public targetSize: number = 0.0,
  public rcsMin: number = 0.0,
  public rcs: number = 0.0,
  public rcsMax: number = 0.0,
  public freqMin: number = 0.0,
  public freq: number = 0.0,
  public freqMax: number = 0.0,
  public polarization: string|Uint8Array|null = null,
  public visMagMin: number = 0.0,
  public visMag: number = 0.0,
  public visMagMax: number = 0.0,
  public spectralModel: string|Uint8Array|null = null,
  public reflectance: number = 0.0,
  public irradiance: number = 0.0,
  public numFrames: number = 0,
  public frameRate: number = 0.0,
  public integrationTime: number = 0.0,
  public numTracks: number = 0,
  public numObs: number = 0,
  public duration: number = 0,
  public srchPattern: string|Uint8Array|null = null,
  public scenario: string|Uint8Array|null = null,
  public idElset: string|Uint8Array|null = null,
  public idManifold: string|Uint8Array|null = null,
  public idStateVector: string|Uint8Array|null = null,
  public esId: string|Uint8Array|null = null,
  public epoch: string|Uint8Array|null = null,
  public semiMajorAxis: number = 0.0,
  public eccentricity: number = 0.0,
  public inclination: number = 0.0,
  public raan: number = 0.0,
  public argOfPerigee: number = 0.0,
  public meanAnomaly: number = 0.0,
  public ra: number = 0.0,
  public dec: number = 0.0,
  public az: number = 0.0,
  public el: number = 0.0,
  public range: number = 0.0,
  public extentAz: number = 0.0,
  public extentEl: number = 0.0,
  public extentRange: number = 0.0,
  public lat: number = 0.0,
  public lon: number = 0.0,
  public alt: number = 0.0,
  public stopLat: number = 0.0,
  public stopLon: number = 0.0,
  public stopAlt: number = 0.0,
  public srchInc: number = 0.0,
  public xAngle: number = 0.0,
  public yAngle: number = 0.0,
  public orientAngle: number = 0.0,
  public customer: string|Uint8Array|null = null,
  public notes: string|Uint8Array|null = null,
  public source: string|Uint8Array|null = null,
  public origin: string|Uint8Array|null = null,
  public dataMode: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const id = (this.id !== null ? builder.createString(this.id!) : 0);
  const classification = (this.classification !== null ? builder.createString(this.classification!) : 0);
  const type = (this.type !== null ? builder.createString(this.type!) : 0);
  const idPlan = (this.idPlan !== null ? builder.createString(this.idPlan!) : 0);
  const taskId = (this.taskId !== null ? builder.createString(this.taskId!) : 0);
  const dwellId = (this.dwellId !== null ? builder.createString(this.dwellId!) : 0);
  const externalId = (this.externalId !== null ? builder.createString(this.externalId!) : 0);
  const idSensor = (this.idSensor !== null ? builder.createString(this.idSensor!) : 0);
  const origSensorId = (this.origSensorId !== null ? builder.createString(this.origSensorId!) : 0);
  const obType = (this.obType !== null ? builder.createString(this.obType!) : 0);
  const priority = (this.priority !== null ? builder.createString(this.priority!) : 0);
  const suffix = (this.suffix !== null ? builder.createString(this.suffix!) : 0);
  const startTime = (this.startTime !== null ? builder.createString(this.startTime!) : 0);
  const endTime = (this.endTime !== null ? builder.createString(this.endTime!) : 0);
  const origObjectId = (this.origObjectId !== null ? builder.createString(this.origObjectId!) : 0);
  const taskGroup = (this.taskGroup !== null ? builder.createString(this.taskGroup!) : 0);
  const orbitRegime = (this.orbitRegime !== null ? builder.createString(this.orbitRegime!) : 0);
  const polarization = (this.polarization !== null ? builder.createString(this.polarization!) : 0);
  const spectralModel = (this.spectralModel !== null ? builder.createString(this.spectralModel!) : 0);
  const srchPattern = (this.srchPattern !== null ? builder.createString(this.srchPattern!) : 0);
  const scenario = (this.scenario !== null ? builder.createString(this.scenario!) : 0);
  const idElset = (this.idElset !== null ? builder.createString(this.idElset!) : 0);
  const idManifold = (this.idManifold !== null ? builder.createString(this.idManifold!) : 0);
  const idStateVector = (this.idStateVector !== null ? builder.createString(this.idStateVector!) : 0);
  const esId = (this.esId !== null ? builder.createString(this.esId!) : 0);
  const epoch = (this.epoch !== null ? builder.createString(this.epoch!) : 0);
  const customer = (this.customer !== null ? builder.createString(this.customer!) : 0);
  const notes = (this.notes !== null ? builder.createString(this.notes!) : 0);
  const source = (this.source !== null ? builder.createString(this.source!) : 0);
  const origin = (this.origin !== null ? builder.createString(this.origin!) : 0);
  const dataMode = (this.dataMode !== null ? builder.createString(this.dataMode!) : 0);

  return CRM.createCRM(builder,
    id,
    classification,
    type,
    idPlan,
    this.planIndex,
    taskId,
    dwellId,
    externalId,
    idSensor,
    origSensorId,
    obType,
    priority,
    this.taskCategory,
    suffix,
    this.uctFollowUp,
    startTime,
    endTime,
    this.noradCatId,
    origObjectId,
    taskGroup,
    this.iron,
    orbitRegime,
    this.targetSize,
    this.rcsMin,
    this.rcs,
    this.rcsMax,
    this.freqMin,
    this.freq,
    this.freqMax,
    polarization,
    this.visMagMin,
    this.visMag,
    this.visMagMax,
    spectralModel,
    this.reflectance,
    this.irradiance,
    this.numFrames,
    this.frameRate,
    this.integrationTime,
    this.numTracks,
    this.numObs,
    this.duration,
    srchPattern,
    scenario,
    idElset,
    idManifold,
    idStateVector,
    esId,
    epoch,
    this.semiMajorAxis,
    this.eccentricity,
    this.inclination,
    this.raan,
    this.argOfPerigee,
    this.meanAnomaly,
    this.ra,
    this.dec,
    this.az,
    this.el,
    this.range,
    this.extentAz,
    this.extentEl,
    this.extentRange,
    this.lat,
    this.lon,
    this.alt,
    this.stopLat,
    this.stopLon,
    this.stopAlt,
    this.srchInc,
    this.xAngle,
    this.yAngle,
    this.orientAngle,
    customer,
    notes,
    source,
    origin,
    dataMode
  );
}
}
