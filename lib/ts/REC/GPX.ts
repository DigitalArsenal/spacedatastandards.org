// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { GPXLink, GPXLinkT } from './GPXLink.js';
import { GPXRoute, GPXRouteT } from './GPXRoute.js';
import { GPXTrack, GPXTrackT } from './GPXTrack.js';
import { GPXWaypoint, GPXWaypointT } from './GPXWaypoint.js';


/**
 * GPX Document
 */
export class GPX implements flatbuffers.IUnpackableObject<GPXT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):GPX {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsGPX(bb:flatbuffers.ByteBuffer, obj?:GPX):GPX {
  return (obj || new GPX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsGPX(bb:flatbuffers.ByteBuffer, obj?:GPX):GPX {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GPX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$GPX');
}

/**
 * GPX schema version
 */
VERSION():string|null
VERSION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
VERSION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Creator software/organization
 */
CREATOR():string|null
CREATOR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CREATOR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * File name
 */
NAME():string|null
NAME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
NAME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * File description
 */
DESCRIPTION():string|null
DESCRIPTION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
DESCRIPTION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Person or organization who created the file
 */
AUTHOR_NAME():string|null
AUTHOR_NAME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
AUTHOR_NAME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Author email
 */
AUTHOR_EMAIL():string|null
AUTHOR_EMAIL(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
AUTHOR_EMAIL(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Author link
 */
AUTHOR_LINK(obj?:GPXLink):GPXLink|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? (obj || new GPXLink()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Copyright holder
 */
COPYRIGHT_AUTHOR():string|null
COPYRIGHT_AUTHOR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
COPYRIGHT_AUTHOR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Copyright year
 */
COPYRIGHT_YEAR():string|null
COPYRIGHT_YEAR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
COPYRIGHT_YEAR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Copyright license URL
 */
COPYRIGHT_LICENSE():string|null
COPYRIGHT_LICENSE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
COPYRIGHT_LICENSE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Links to additional information
 */
LINKS(index: number, obj?:GPXLink):GPXLink|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? (obj || new GPXLink()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

linksLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Creation timestamp (ISO 8601)
 */
TIME():string|null
TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Keywords
 */
KEYWORDS():string|null
KEYWORDS(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
KEYWORDS(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Minimum latitude of bounding box
 */
BOUNDS_MIN_LAT():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Minimum longitude of bounding box
 */
BOUNDS_MIN_LON():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Maximum latitude of bounding box
 */
BOUNDS_MAX_LAT():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Maximum longitude of bounding box
 */
BOUNDS_MAX_LON():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Waypoints
 */
WAYPOINTS(index: number, obj?:GPXWaypoint):GPXWaypoint|null {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? (obj || new GPXWaypoint()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

waypointsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Routes
 */
ROUTES(index: number, obj?:GPXRoute):GPXRoute|null {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? (obj || new GPXRoute()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

routesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Tracks
 */
TRACKS(index: number, obj?:GPXTrack):GPXTrack|null {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? (obj || new GPXTrack()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

tracksLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startGPX(builder:flatbuffers.Builder) {
  builder.startObject(20);
}

static addVersion(builder:flatbuffers.Builder, VERSIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, VERSIONOffset, 0);
}

static addCreator(builder:flatbuffers.Builder, CREATOROffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, CREATOROffset, 0);
}

static addName(builder:flatbuffers.Builder, NAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, NAMEOffset, 0);
}

static addDescription(builder:flatbuffers.Builder, DESCRIPTIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, DESCRIPTIONOffset, 0);
}

static addAuthorName(builder:flatbuffers.Builder, AUTHOR_NAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, AUTHOR_NAMEOffset, 0);
}

static addAuthorEmail(builder:flatbuffers.Builder, AUTHOR_EMAILOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, AUTHOR_EMAILOffset, 0);
}

static addAuthorLink(builder:flatbuffers.Builder, AUTHOR_LINKOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, AUTHOR_LINKOffset, 0);
}

static addCopyrightAuthor(builder:flatbuffers.Builder, COPYRIGHT_AUTHOROffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, COPYRIGHT_AUTHOROffset, 0);
}

static addCopyrightYear(builder:flatbuffers.Builder, COPYRIGHT_YEAROffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, COPYRIGHT_YEAROffset, 0);
}

static addCopyrightLicense(builder:flatbuffers.Builder, COPYRIGHT_LICENSEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, COPYRIGHT_LICENSEOffset, 0);
}

static addLinks(builder:flatbuffers.Builder, LINKSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, LINKSOffset, 0);
}

static createLinksVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startLinksVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addTime(builder:flatbuffers.Builder, TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, TIMEOffset, 0);
}

static addKeywords(builder:flatbuffers.Builder, KEYWORDSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(12, KEYWORDSOffset, 0);
}

static addBoundsMinLat(builder:flatbuffers.Builder, BOUNDS_MIN_LAT:number) {
  builder.addFieldFloat64(13, BOUNDS_MIN_LAT, 0.0);
}

static addBoundsMinLon(builder:flatbuffers.Builder, BOUNDS_MIN_LON:number) {
  builder.addFieldFloat64(14, BOUNDS_MIN_LON, 0.0);
}

static addBoundsMaxLat(builder:flatbuffers.Builder, BOUNDS_MAX_LAT:number) {
  builder.addFieldFloat64(15, BOUNDS_MAX_LAT, 0.0);
}

static addBoundsMaxLon(builder:flatbuffers.Builder, BOUNDS_MAX_LON:number) {
  builder.addFieldFloat64(16, BOUNDS_MAX_LON, 0.0);
}

static addWaypoints(builder:flatbuffers.Builder, WAYPOINTSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(17, WAYPOINTSOffset, 0);
}

static createWaypointsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startWaypointsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addRoutes(builder:flatbuffers.Builder, ROUTESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(18, ROUTESOffset, 0);
}

static createRoutesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startRoutesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addTracks(builder:flatbuffers.Builder, TRACKSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, TRACKSOffset, 0);
}

static createTracksVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTracksVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endGPX(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishGPXBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$GPX');
}

static finishSizePrefixedGPXBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$GPX', true);
}


unpack(): GPXT {
  return new GPXT(
    this.VERSION(),
    this.CREATOR(),
    this.NAME(),
    this.DESCRIPTION(),
    this.AUTHOR_NAME(),
    this.AUTHOR_EMAIL(),
    (this.AUTHOR_LINK() !== null ? this.AUTHOR_LINK()!.unpack() : null),
    this.COPYRIGHT_AUTHOR(),
    this.COPYRIGHT_YEAR(),
    this.COPYRIGHT_LICENSE(),
    this.bb!.createObjList<GPXLink, GPXLinkT>(this.LINKS.bind(this), this.linksLength()),
    this.TIME(),
    this.KEYWORDS(),
    this.BOUNDS_MIN_LAT(),
    this.BOUNDS_MIN_LON(),
    this.BOUNDS_MAX_LAT(),
    this.BOUNDS_MAX_LON(),
    this.bb!.createObjList<GPXWaypoint, GPXWaypointT>(this.WAYPOINTS.bind(this), this.waypointsLength()),
    this.bb!.createObjList<GPXRoute, GPXRouteT>(this.ROUTES.bind(this), this.routesLength()),
    this.bb!.createObjList<GPXTrack, GPXTrackT>(this.TRACKS.bind(this), this.tracksLength())
  );
}


unpackTo(_o: GPXT): void {
  _o.VERSION = this.VERSION();
  _o.CREATOR = this.CREATOR();
  _o.NAME = this.NAME();
  _o.DESCRIPTION = this.DESCRIPTION();
  _o.AUTHOR_NAME = this.AUTHOR_NAME();
  _o.AUTHOR_EMAIL = this.AUTHOR_EMAIL();
  _o.AUTHOR_LINK = (this.AUTHOR_LINK() !== null ? this.AUTHOR_LINK()!.unpack() : null);
  _o.COPYRIGHT_AUTHOR = this.COPYRIGHT_AUTHOR();
  _o.COPYRIGHT_YEAR = this.COPYRIGHT_YEAR();
  _o.COPYRIGHT_LICENSE = this.COPYRIGHT_LICENSE();
  _o.LINKS = this.bb!.createObjList<GPXLink, GPXLinkT>(this.LINKS.bind(this), this.linksLength());
  _o.TIME = this.TIME();
  _o.KEYWORDS = this.KEYWORDS();
  _o.BOUNDS_MIN_LAT = this.BOUNDS_MIN_LAT();
  _o.BOUNDS_MIN_LON = this.BOUNDS_MIN_LON();
  _o.BOUNDS_MAX_LAT = this.BOUNDS_MAX_LAT();
  _o.BOUNDS_MAX_LON = this.BOUNDS_MAX_LON();
  _o.WAYPOINTS = this.bb!.createObjList<GPXWaypoint, GPXWaypointT>(this.WAYPOINTS.bind(this), this.waypointsLength());
  _o.ROUTES = this.bb!.createObjList<GPXRoute, GPXRouteT>(this.ROUTES.bind(this), this.routesLength());
  _o.TRACKS = this.bb!.createObjList<GPXTrack, GPXTrackT>(this.TRACKS.bind(this), this.tracksLength());
}
}

export class GPXT implements flatbuffers.IGeneratedObject {
constructor(
  public VERSION: string|Uint8Array|null = null,
  public CREATOR: string|Uint8Array|null = null,
  public NAME: string|Uint8Array|null = null,
  public DESCRIPTION: string|Uint8Array|null = null,
  public AUTHOR_NAME: string|Uint8Array|null = null,
  public AUTHOR_EMAIL: string|Uint8Array|null = null,
  public AUTHOR_LINK: GPXLinkT|null = null,
  public COPYRIGHT_AUTHOR: string|Uint8Array|null = null,
  public COPYRIGHT_YEAR: string|Uint8Array|null = null,
  public COPYRIGHT_LICENSE: string|Uint8Array|null = null,
  public LINKS: (GPXLinkT)[] = [],
  public TIME: string|Uint8Array|null = null,
  public KEYWORDS: string|Uint8Array|null = null,
  public BOUNDS_MIN_LAT: number = 0.0,
  public BOUNDS_MIN_LON: number = 0.0,
  public BOUNDS_MAX_LAT: number = 0.0,
  public BOUNDS_MAX_LON: number = 0.0,
  public WAYPOINTS: (GPXWaypointT)[] = [],
  public ROUTES: (GPXRouteT)[] = [],
  public TRACKS: (GPXTrackT)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const VERSION = (this.VERSION !== null ? builder.createString(this.VERSION!) : 0);
  const CREATOR = (this.CREATOR !== null ? builder.createString(this.CREATOR!) : 0);
  const NAME = (this.NAME !== null ? builder.createString(this.NAME!) : 0);
  const DESCRIPTION = (this.DESCRIPTION !== null ? builder.createString(this.DESCRIPTION!) : 0);
  const AUTHOR_NAME = (this.AUTHOR_NAME !== null ? builder.createString(this.AUTHOR_NAME!) : 0);
  const AUTHOR_EMAIL = (this.AUTHOR_EMAIL !== null ? builder.createString(this.AUTHOR_EMAIL!) : 0);
  const AUTHOR_LINK = (this.AUTHOR_LINK !== null ? this.AUTHOR_LINK!.pack(builder) : 0);
  const COPYRIGHT_AUTHOR = (this.COPYRIGHT_AUTHOR !== null ? builder.createString(this.COPYRIGHT_AUTHOR!) : 0);
  const COPYRIGHT_YEAR = (this.COPYRIGHT_YEAR !== null ? builder.createString(this.COPYRIGHT_YEAR!) : 0);
  const COPYRIGHT_LICENSE = (this.COPYRIGHT_LICENSE !== null ? builder.createString(this.COPYRIGHT_LICENSE!) : 0);
  const LINKS = GPX.createLinksVector(builder, builder.createObjectOffsetList(this.LINKS));
  const TIME = (this.TIME !== null ? builder.createString(this.TIME!) : 0);
  const KEYWORDS = (this.KEYWORDS !== null ? builder.createString(this.KEYWORDS!) : 0);
  const WAYPOINTS = GPX.createWaypointsVector(builder, builder.createObjectOffsetList(this.WAYPOINTS));
  const ROUTES = GPX.createRoutesVector(builder, builder.createObjectOffsetList(this.ROUTES));
  const TRACKS = GPX.createTracksVector(builder, builder.createObjectOffsetList(this.TRACKS));

  GPX.startGPX(builder);
  GPX.addVersion(builder, VERSION);
  GPX.addCreator(builder, CREATOR);
  GPX.addName(builder, NAME);
  GPX.addDescription(builder, DESCRIPTION);
  GPX.addAuthorName(builder, AUTHOR_NAME);
  GPX.addAuthorEmail(builder, AUTHOR_EMAIL);
  GPX.addAuthorLink(builder, AUTHOR_LINK);
  GPX.addCopyrightAuthor(builder, COPYRIGHT_AUTHOR);
  GPX.addCopyrightYear(builder, COPYRIGHT_YEAR);
  GPX.addCopyrightLicense(builder, COPYRIGHT_LICENSE);
  GPX.addLinks(builder, LINKS);
  GPX.addTime(builder, TIME);
  GPX.addKeywords(builder, KEYWORDS);
  GPX.addBoundsMinLat(builder, this.BOUNDS_MIN_LAT);
  GPX.addBoundsMinLon(builder, this.BOUNDS_MIN_LON);
  GPX.addBoundsMaxLat(builder, this.BOUNDS_MAX_LAT);
  GPX.addBoundsMaxLon(builder, this.BOUNDS_MAX_LON);
  GPX.addWaypoints(builder, WAYPOINTS);
  GPX.addRoutes(builder, ROUTES);
  GPX.addTracks(builder, TRACKS);

  return GPX.endGPX(builder);
}
}
