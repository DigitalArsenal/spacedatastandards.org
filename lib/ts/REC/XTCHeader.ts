// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Document header information
 */
export class XTCHeader implements flatbuffers.IUnpackableObject<XTCHeaderT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):XTCHeader {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsXTCHeader(bb:flatbuffers.ByteBuffer, obj?:XTCHeader):XTCHeader {
  return (obj || new XTCHeader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsXTCHeader(bb:flatbuffers.ByteBuffer, obj?:XTCHeader):XTCHeader {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new XTCHeader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Version of this XTCE document
 */
VERSION():string|null
VERSION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
VERSION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Date of document creation (ISO 8601)
 */
DATE():string|null
DATE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
DATE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification level
 */
CLASSIFICATION():string|null
CLASSIFICATION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CLASSIFICATION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Validation status
 */
VALIDATION_STATUS():string|null
VALIDATION_STATUS(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
VALIDATION_STATUS(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Author information
 */
AUTHOR():string|null
AUTHOR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
AUTHOR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Notes/comments
 */
NOTES(index: number):string
NOTES(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
NOTES(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

notesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startXTCHeader(builder:flatbuffers.Builder) {
  builder.startObject(6);
}

static addVersion(builder:flatbuffers.Builder, VERSIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, VERSIONOffset, 0);
}

static addDate(builder:flatbuffers.Builder, DATEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, DATEOffset, 0);
}

static addClassification(builder:flatbuffers.Builder, CLASSIFICATIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, CLASSIFICATIONOffset, 0);
}

static addValidationStatus(builder:flatbuffers.Builder, VALIDATION_STATUSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, VALIDATION_STATUSOffset, 0);
}

static addAuthor(builder:flatbuffers.Builder, AUTHOROffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, AUTHOROffset, 0);
}

static addNotes(builder:flatbuffers.Builder, NOTESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, NOTESOffset, 0);
}

static createNotesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startNotesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endXTCHeader(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createXTCHeader(builder:flatbuffers.Builder, VERSIONOffset:flatbuffers.Offset, DATEOffset:flatbuffers.Offset, CLASSIFICATIONOffset:flatbuffers.Offset, VALIDATION_STATUSOffset:flatbuffers.Offset, AUTHOROffset:flatbuffers.Offset, NOTESOffset:flatbuffers.Offset):flatbuffers.Offset {
  XTCHeader.startXTCHeader(builder);
  XTCHeader.addVersion(builder, VERSIONOffset);
  XTCHeader.addDate(builder, DATEOffset);
  XTCHeader.addClassification(builder, CLASSIFICATIONOffset);
  XTCHeader.addValidationStatus(builder, VALIDATION_STATUSOffset);
  XTCHeader.addAuthor(builder, AUTHOROffset);
  XTCHeader.addNotes(builder, NOTESOffset);
  return XTCHeader.endXTCHeader(builder);
}

unpack(): XTCHeaderT {
  return new XTCHeaderT(
    this.VERSION(),
    this.DATE(),
    this.CLASSIFICATION(),
    this.VALIDATION_STATUS(),
    this.AUTHOR(),
    this.bb!.createScalarList<string>(this.NOTES.bind(this), this.notesLength())
  );
}


unpackTo(_o: XTCHeaderT): void {
  _o.VERSION = this.VERSION();
  _o.DATE = this.DATE();
  _o.CLASSIFICATION = this.CLASSIFICATION();
  _o.VALIDATION_STATUS = this.VALIDATION_STATUS();
  _o.AUTHOR = this.AUTHOR();
  _o.NOTES = this.bb!.createScalarList<string>(this.NOTES.bind(this), this.notesLength());
}
}

export class XTCHeaderT implements flatbuffers.IGeneratedObject {
constructor(
  public VERSION: string|Uint8Array|null = null,
  public DATE: string|Uint8Array|null = null,
  public CLASSIFICATION: string|Uint8Array|null = null,
  public VALIDATION_STATUS: string|Uint8Array|null = null,
  public AUTHOR: string|Uint8Array|null = null,
  public NOTES: (string)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const VERSION = (this.VERSION !== null ? builder.createString(this.VERSION!) : 0);
  const DATE = (this.DATE !== null ? builder.createString(this.DATE!) : 0);
  const CLASSIFICATION = (this.CLASSIFICATION !== null ? builder.createString(this.CLASSIFICATION!) : 0);
  const VALIDATION_STATUS = (this.VALIDATION_STATUS !== null ? builder.createString(this.VALIDATION_STATUS!) : 0);
  const AUTHOR = (this.AUTHOR !== null ? builder.createString(this.AUTHOR!) : 0);
  const NOTES = XTCHeader.createNotesVector(builder, builder.createObjectOffsetList(this.NOTES));

  return XTCHeader.createXTCHeader(builder,
    VERSION,
    DATE,
    CLASSIFICATION,
    VALIDATION_STATUS,
    AUTHOR,
    NOTES
  );
}
}
