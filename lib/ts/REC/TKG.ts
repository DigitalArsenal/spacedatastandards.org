// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Tracking and Data Fusion
 */
export class TKG implements flatbuffers.IUnpackableObject<TKGT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):TKG {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsTKG(bb:flatbuffers.ByteBuffer, obj?:TKG):TKG {
  return (obj || new TKG()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsTKG(bb:flatbuffers.ByteBuffer, obj?:TKG):TKG {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new TKG()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$TKG');
}

COMMAND():string|null
COMMAND(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
COMMAND(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

FILTER_CONFIG():string|null
FILTER_CONFIG(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
FILTER_CONFIG(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

IMM_CONFIG():string|null
IMM_CONFIG(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
IMM_CONFIG(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

MHT_CONFIG():string|null
MHT_CONFIG(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
MHT_CONFIG(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

JPDA_CONFIG():string|null
JPDA_CONFIG(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
JPDA_CONFIG(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

FUSION_CONFIG():string|null
FUSION_CONFIG(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
FUSION_CONFIG(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

MEASUREMENTS():string|null
MEASUREMENTS(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
MEASUREMENTS(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

INITIAL_STATE():string|null
INITIAL_STATE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
INITIAL_STATE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

TRACK_TO_UPDATE():string|null
TRACK_TO_UPDATE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TRACK_TO_UPDATE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

TRACKS_TO_CORRELATE(index: number):string
TRACKS_TO_CORRELATE(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
TRACKS_TO_CORRELATE(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

tracksToCorrelateLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startTKG(builder:flatbuffers.Builder) {
  builder.startObject(10);
}

static addCommand(builder:flatbuffers.Builder, COMMANDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, COMMANDOffset, 0);
}

static addFilterConfig(builder:flatbuffers.Builder, FILTER_CONFIGOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, FILTER_CONFIGOffset, 0);
}

static addImmConfig(builder:flatbuffers.Builder, IMM_CONFIGOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, IMM_CONFIGOffset, 0);
}

static addMhtConfig(builder:flatbuffers.Builder, MHT_CONFIGOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, MHT_CONFIGOffset, 0);
}

static addJpdaConfig(builder:flatbuffers.Builder, JPDA_CONFIGOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, JPDA_CONFIGOffset, 0);
}

static addFusionConfig(builder:flatbuffers.Builder, FUSION_CONFIGOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, FUSION_CONFIGOffset, 0);
}

static addMeasurements(builder:flatbuffers.Builder, MEASUREMENTSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, MEASUREMENTSOffset, 0);
}

static addInitialState(builder:flatbuffers.Builder, INITIAL_STATEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, INITIAL_STATEOffset, 0);
}

static addTrackToUpdate(builder:flatbuffers.Builder, TRACK_TO_UPDATEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, TRACK_TO_UPDATEOffset, 0);
}

static addTracksToCorrelate(builder:flatbuffers.Builder, TRACKS_TO_CORRELATEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, TRACKS_TO_CORRELATEOffset, 0);
}

static createTracksToCorrelateVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTracksToCorrelateVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endTKG(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishTKGBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$TKG');
}

static finishSizePrefixedTKGBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$TKG', true);
}

static createTKG(builder:flatbuffers.Builder, COMMANDOffset:flatbuffers.Offset, FILTER_CONFIGOffset:flatbuffers.Offset, IMM_CONFIGOffset:flatbuffers.Offset, MHT_CONFIGOffset:flatbuffers.Offset, JPDA_CONFIGOffset:flatbuffers.Offset, FUSION_CONFIGOffset:flatbuffers.Offset, MEASUREMENTSOffset:flatbuffers.Offset, INITIAL_STATEOffset:flatbuffers.Offset, TRACK_TO_UPDATEOffset:flatbuffers.Offset, TRACKS_TO_CORRELATEOffset:flatbuffers.Offset):flatbuffers.Offset {
  TKG.startTKG(builder);
  TKG.addCommand(builder, COMMANDOffset);
  TKG.addFilterConfig(builder, FILTER_CONFIGOffset);
  TKG.addImmConfig(builder, IMM_CONFIGOffset);
  TKG.addMhtConfig(builder, MHT_CONFIGOffset);
  TKG.addJpdaConfig(builder, JPDA_CONFIGOffset);
  TKG.addFusionConfig(builder, FUSION_CONFIGOffset);
  TKG.addMeasurements(builder, MEASUREMENTSOffset);
  TKG.addInitialState(builder, INITIAL_STATEOffset);
  TKG.addTrackToUpdate(builder, TRACK_TO_UPDATEOffset);
  TKG.addTracksToCorrelate(builder, TRACKS_TO_CORRELATEOffset);
  return TKG.endTKG(builder);
}

unpack(): TKGT {
  return new TKGT(
    this.COMMAND(),
    this.FILTER_CONFIG(),
    this.IMM_CONFIG(),
    this.MHT_CONFIG(),
    this.JPDA_CONFIG(),
    this.FUSION_CONFIG(),
    this.MEASUREMENTS(),
    this.INITIAL_STATE(),
    this.TRACK_TO_UPDATE(),
    this.bb!.createScalarList<string>(this.TRACKS_TO_CORRELATE.bind(this), this.tracksToCorrelateLength())
  );
}


unpackTo(_o: TKGT): void {
  _o.COMMAND = this.COMMAND();
  _o.FILTER_CONFIG = this.FILTER_CONFIG();
  _o.IMM_CONFIG = this.IMM_CONFIG();
  _o.MHT_CONFIG = this.MHT_CONFIG();
  _o.JPDA_CONFIG = this.JPDA_CONFIG();
  _o.FUSION_CONFIG = this.FUSION_CONFIG();
  _o.MEASUREMENTS = this.MEASUREMENTS();
  _o.INITIAL_STATE = this.INITIAL_STATE();
  _o.TRACK_TO_UPDATE = this.TRACK_TO_UPDATE();
  _o.TRACKS_TO_CORRELATE = this.bb!.createScalarList<string>(this.TRACKS_TO_CORRELATE.bind(this), this.tracksToCorrelateLength());
}
}

export class TKGT implements flatbuffers.IGeneratedObject {
constructor(
  public COMMAND: string|Uint8Array|null = null,
  public FILTER_CONFIG: string|Uint8Array|null = null,
  public IMM_CONFIG: string|Uint8Array|null = null,
  public MHT_CONFIG: string|Uint8Array|null = null,
  public JPDA_CONFIG: string|Uint8Array|null = null,
  public FUSION_CONFIG: string|Uint8Array|null = null,
  public MEASUREMENTS: string|Uint8Array|null = null,
  public INITIAL_STATE: string|Uint8Array|null = null,
  public TRACK_TO_UPDATE: string|Uint8Array|null = null,
  public TRACKS_TO_CORRELATE: (string)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const COMMAND = (this.COMMAND !== null ? builder.createString(this.COMMAND!) : 0);
  const FILTER_CONFIG = (this.FILTER_CONFIG !== null ? builder.createString(this.FILTER_CONFIG!) : 0);
  const IMM_CONFIG = (this.IMM_CONFIG !== null ? builder.createString(this.IMM_CONFIG!) : 0);
  const MHT_CONFIG = (this.MHT_CONFIG !== null ? builder.createString(this.MHT_CONFIG!) : 0);
  const JPDA_CONFIG = (this.JPDA_CONFIG !== null ? builder.createString(this.JPDA_CONFIG!) : 0);
  const FUSION_CONFIG = (this.FUSION_CONFIG !== null ? builder.createString(this.FUSION_CONFIG!) : 0);
  const MEASUREMENTS = (this.MEASUREMENTS !== null ? builder.createString(this.MEASUREMENTS!) : 0);
  const INITIAL_STATE = (this.INITIAL_STATE !== null ? builder.createString(this.INITIAL_STATE!) : 0);
  const TRACK_TO_UPDATE = (this.TRACK_TO_UPDATE !== null ? builder.createString(this.TRACK_TO_UPDATE!) : 0);
  const TRACKS_TO_CORRELATE = TKG.createTracksToCorrelateVector(builder, builder.createObjectOffsetList(this.TRACKS_TO_CORRELATE));

  return TKG.createTKG(builder,
    COMMAND,
    FILTER_CONFIG,
    IMM_CONFIG,
    MHT_CONFIG,
    JPDA_CONFIG,
    FUSION_CONFIG,
    MEASUREMENTS,
    INITIAL_STATE,
    TRACK_TO_UPDATE,
    TRACKS_TO_CORRELATE
  );
}
}
