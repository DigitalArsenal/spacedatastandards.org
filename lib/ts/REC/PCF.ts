// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Propagator Configuration
 */
export class PCF implements flatbuffers.IUnpackableObject<PCFT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):PCF {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsPCF(bb:flatbuffers.ByteBuffer, obj?:PCF):PCF {
  return (obj || new PCF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsPCF(bb:flatbuffers.ByteBuffer, obj?:PCF):PCF {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new PCF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$PCF');
}

STEP_SIZE():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

TOLERANCE():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

MIN_STEP():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

MAX_STEP():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

MAX_ITERATIONS():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

GRAVITY_DEGREE():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

GRAVITY_ORDER():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

INTEGRATOR():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

OUTPUT_FRAME():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

FORCE_FLAGS():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

DRAG_COEFFICIENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

SRP_COEFFICIENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

AREA_MASS_RATIO():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

RESERVED(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

reservedLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

reservedArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startPCF(builder:flatbuffers.Builder) {
  builder.startObject(14);
}

static addStepSize(builder:flatbuffers.Builder, STEP_SIZE:number) {
  builder.addFieldFloat64(0, STEP_SIZE, 0.0);
}

static addTolerance(builder:flatbuffers.Builder, TOLERANCE:number) {
  builder.addFieldFloat64(1, TOLERANCE, 0.0);
}

static addMinStep(builder:flatbuffers.Builder, MIN_STEP:number) {
  builder.addFieldFloat64(2, MIN_STEP, 0.0);
}

static addMaxStep(builder:flatbuffers.Builder, MAX_STEP:number) {
  builder.addFieldFloat64(3, MAX_STEP, 0.0);
}

static addMaxIterations(builder:flatbuffers.Builder, MAX_ITERATIONS:number) {
  builder.addFieldInt32(4, MAX_ITERATIONS, 0);
}

static addGravityDegree(builder:flatbuffers.Builder, GRAVITY_DEGREE:number) {
  builder.addFieldInt16(5, GRAVITY_DEGREE, 0);
}

static addGravityOrder(builder:flatbuffers.Builder, GRAVITY_ORDER:number) {
  builder.addFieldInt16(6, GRAVITY_ORDER, 0);
}

static addIntegrator(builder:flatbuffers.Builder, INTEGRATOR:number) {
  builder.addFieldInt8(7, INTEGRATOR, 0);
}

static addOutputFrame(builder:flatbuffers.Builder, OUTPUT_FRAME:number) {
  builder.addFieldInt8(8, OUTPUT_FRAME, 0);
}

static addForceFlags(builder:flatbuffers.Builder, FORCE_FLAGS:number) {
  builder.addFieldInt16(9, FORCE_FLAGS, 0);
}

static addDragCoefficient(builder:flatbuffers.Builder, DRAG_COEFFICIENT:number) {
  builder.addFieldFloat32(10, DRAG_COEFFICIENT, 0.0);
}

static addSrpCoefficient(builder:flatbuffers.Builder, SRP_COEFFICIENT:number) {
  builder.addFieldFloat32(11, SRP_COEFFICIENT, 0.0);
}

static addAreaMassRatio(builder:flatbuffers.Builder, AREA_MASS_RATIO:number) {
  builder.addFieldFloat32(12, AREA_MASS_RATIO, 0.0);
}

static addReserved(builder:flatbuffers.Builder, RESERVEDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, RESERVEDOffset, 0);
}

static createReservedVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startReservedVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static endPCF(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishPCFBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$PCF');
}

static finishSizePrefixedPCFBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$PCF', true);
}

static createPCF(builder:flatbuffers.Builder, STEP_SIZE:number, TOLERANCE:number, MIN_STEP:number, MAX_STEP:number, MAX_ITERATIONS:number, GRAVITY_DEGREE:number, GRAVITY_ORDER:number, INTEGRATOR:number, OUTPUT_FRAME:number, FORCE_FLAGS:number, DRAG_COEFFICIENT:number, SRP_COEFFICIENT:number, AREA_MASS_RATIO:number, RESERVEDOffset:flatbuffers.Offset):flatbuffers.Offset {
  PCF.startPCF(builder);
  PCF.addStepSize(builder, STEP_SIZE);
  PCF.addTolerance(builder, TOLERANCE);
  PCF.addMinStep(builder, MIN_STEP);
  PCF.addMaxStep(builder, MAX_STEP);
  PCF.addMaxIterations(builder, MAX_ITERATIONS);
  PCF.addGravityDegree(builder, GRAVITY_DEGREE);
  PCF.addGravityOrder(builder, GRAVITY_ORDER);
  PCF.addIntegrator(builder, INTEGRATOR);
  PCF.addOutputFrame(builder, OUTPUT_FRAME);
  PCF.addForceFlags(builder, FORCE_FLAGS);
  PCF.addDragCoefficient(builder, DRAG_COEFFICIENT);
  PCF.addSrpCoefficient(builder, SRP_COEFFICIENT);
  PCF.addAreaMassRatio(builder, AREA_MASS_RATIO);
  PCF.addReserved(builder, RESERVEDOffset);
  return PCF.endPCF(builder);
}

unpack(): PCFT {
  return new PCFT(
    this.STEP_SIZE(),
    this.TOLERANCE(),
    this.MIN_STEP(),
    this.MAX_STEP(),
    this.MAX_ITERATIONS(),
    this.GRAVITY_DEGREE(),
    this.GRAVITY_ORDER(),
    this.INTEGRATOR(),
    this.OUTPUT_FRAME(),
    this.FORCE_FLAGS(),
    this.DRAG_COEFFICIENT(),
    this.SRP_COEFFICIENT(),
    this.AREA_MASS_RATIO(),
    this.bb!.createScalarList<number>(this.RESERVED.bind(this), this.reservedLength())
  );
}


unpackTo(_o: PCFT): void {
  _o.STEP_SIZE = this.STEP_SIZE();
  _o.TOLERANCE = this.TOLERANCE();
  _o.MIN_STEP = this.MIN_STEP();
  _o.MAX_STEP = this.MAX_STEP();
  _o.MAX_ITERATIONS = this.MAX_ITERATIONS();
  _o.GRAVITY_DEGREE = this.GRAVITY_DEGREE();
  _o.GRAVITY_ORDER = this.GRAVITY_ORDER();
  _o.INTEGRATOR = this.INTEGRATOR();
  _o.OUTPUT_FRAME = this.OUTPUT_FRAME();
  _o.FORCE_FLAGS = this.FORCE_FLAGS();
  _o.DRAG_COEFFICIENT = this.DRAG_COEFFICIENT();
  _o.SRP_COEFFICIENT = this.SRP_COEFFICIENT();
  _o.AREA_MASS_RATIO = this.AREA_MASS_RATIO();
  _o.RESERVED = this.bb!.createScalarList<number>(this.RESERVED.bind(this), this.reservedLength());
}
}

export class PCFT implements flatbuffers.IGeneratedObject {
constructor(
  public STEP_SIZE: number = 0.0,
  public TOLERANCE: number = 0.0,
  public MIN_STEP: number = 0.0,
  public MAX_STEP: number = 0.0,
  public MAX_ITERATIONS: number = 0,
  public GRAVITY_DEGREE: number = 0,
  public GRAVITY_ORDER: number = 0,
  public INTEGRATOR: number = 0,
  public OUTPUT_FRAME: number = 0,
  public FORCE_FLAGS: number = 0,
  public DRAG_COEFFICIENT: number = 0.0,
  public SRP_COEFFICIENT: number = 0.0,
  public AREA_MASS_RATIO: number = 0.0,
  public RESERVED: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const RESERVED = PCF.createReservedVector(builder, this.RESERVED);

  return PCF.createPCF(builder,
    this.STEP_SIZE,
    this.TOLERANCE,
    this.MIN_STEP,
    this.MAX_STEP,
    this.MAX_ITERATIONS,
    this.GRAVITY_DEGREE,
    this.GRAVITY_ORDER,
    this.INTEGRATOR,
    this.OUTPUT_FRAME,
    this.FORCE_FLAGS,
    this.DRAG_COEFFICIENT,
    this.SRP_COEFFICIENT,
    this.AREA_MASS_RATIO,
    RESERVED
  );
}
}
