// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { BOV, BOVT } from './BOV.js';
import { CAT, CATT } from './CAT.js';
import { CDM, CDMT } from './CDM.js';
import { CRM, CRMT } from './CRM.js';
import { CSM, CSMT } from './CSM.js';
import { CTR, CTRT } from './CTR.js';
import { EME, EMET } from './EME.js';
import { EOO, EOOT } from './EOO.js';
import { EOP, EOPT } from './EOP.js';
import { EPM, EPMT } from './EPM.js';
import { HYP, HYPT } from './HYP.js';
import { IDM, IDMT } from './IDM.js';
import { LCC, LCCT } from './LCC.js';
import { LDM, LDMT } from './LDM.js';
import { MET, METT } from './MET.js';
import { MPE, MPET } from './MPE.js';
import { OCM, OCMT } from './OCM.js';
import { OEM, OEMT } from './OEM.js';
import { OMM, OMMT } from './OMM.js';
import { OSM, OSMT } from './OSM.js';
import { PLD, PLDT } from './PLD.js';
import { PNM, PNMT } from './PNM.js';
import { PRG, PRGT } from './PRG.js';
import { RFM, RFMT } from './RFM.js';
import { ROC, ROCT } from './ROC.js';
import { RecordType, unionToRecordType, unionListToRecordType } from './RecordType.js';
import { SCM, SCMT } from './SCM.js';
import { SIT, SITT } from './SIT.js';
import { TDM, TDMT } from './TDM.js';
import { TIM, TIMT } from './TIM.js';
import { VCM, VCMT } from './VCM.js';


export class Record implements flatbuffers.IUnpackableObject<RecordT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Record {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsRecord(bb:flatbuffers.ByteBuffer, obj?:Record):Record {
  return (obj || new Record()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsRecord(bb:flatbuffers.ByteBuffer, obj?:Record):Record {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Record()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

valueType():RecordType {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : RecordType.NONE;
}

value<T extends flatbuffers.Table>(obj:any):any|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
}

standard():string|null
standard(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
standard(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startRecord(builder:flatbuffers.Builder) {
  builder.startObject(3);
}

static addValueType(builder:flatbuffers.Builder, valueType:RecordType) {
  builder.addFieldInt8(0, valueType, RecordType.NONE);
}

static addValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, valueOffset, 0);
}

static addStandard(builder:flatbuffers.Builder, standardOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, standardOffset, 0);
}

static endRecord(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createRecord(builder:flatbuffers.Builder, valueType:RecordType, valueOffset:flatbuffers.Offset, standardOffset:flatbuffers.Offset):flatbuffers.Offset {
  Record.startRecord(builder);
  Record.addValueType(builder, valueType);
  Record.addValue(builder, valueOffset);
  Record.addStandard(builder, standardOffset);
  return Record.endRecord(builder);
}

unpack(): RecordT {
  return new RecordT(
    this.valueType(),
    (() => {
      const temp = unionToRecordType(this.valueType(), this.value.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })(),
    this.standard()
  );
}


unpackTo(_o: RecordT): void {
  _o.valueType = this.valueType();
  _o.value = (() => {
      const temp = unionToRecordType(this.valueType(), this.value.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })();
  _o.standard = this.standard();
}
}

export class RecordT implements flatbuffers.IGeneratedObject {
constructor(
  public valueType: RecordType = RecordType.NONE,
  public value: BOVT|CATT|CDMT|CRMT|CSMT|CTRT|EMET|EOOT|EOPT|EPMT|HYPT|IDMT|LCCT|LDMT|METT|MPET|OCMT|OEMT|OMMT|OSMT|PLDT|PNMT|PRGT|RFMT|ROCT|SCMT|SITT|TDMT|TIMT|VCMT|null = null,
  public standard: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const value = builder.createObjectOffset(this.value);
  const standard = (this.standard !== null ? builder.createString(this.standard!) : 0);

  return Record.createRecord(builder,
    this.valueType,
    value,
    standard
  );
}
}
