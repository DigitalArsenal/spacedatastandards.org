// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { StringEncodingType } from './StringEncodingType.js';
import { StringSizeType } from './StringSizeType.js';


/**
 * String data encoding specification
 */
export class StringDataEncoding implements flatbuffers.IUnpackableObject<StringDataEncodingT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):StringDataEncoding {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsStringDataEncoding(bb:flatbuffers.ByteBuffer, obj?:StringDataEncoding):StringDataEncoding {
  return (obj || new StringDataEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsStringDataEncoding(bb:flatbuffers.ByteBuffer, obj?:StringDataEncoding):StringDataEncoding {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new StringDataEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Character encoding
 */
ENCODING():StringEncodingType {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : StringEncodingType.UTF_8;
}

/**
 * Size type specification
 */
SIZE_TYPE():StringSizeType {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : StringSizeType.FIXED;
}

/**
 * Fixed size in bits (when SIZE_TYPE=FIXED)
 */
SIZE_IN_BITS():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

/**
 * Termination character (when SIZE_TYPE=TERMINATION_CHAR)
 */
TERMINATION_CHAR():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

/**
 * Maximum size in bits (for variable length)
 */
MAX_SIZE_IN_BITS():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

/**
 * Leading size field bits (when SIZE_TYPE=LEADING_SIZE)
 */
LEADING_SIZE_BITS():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

static startStringDataEncoding(builder:flatbuffers.Builder) {
  builder.startObject(6);
}

static addEncoding(builder:flatbuffers.Builder, ENCODING:StringEncodingType) {
  builder.addFieldInt8(0, ENCODING, StringEncodingType.UTF_8);
}

static addSizeType(builder:flatbuffers.Builder, SIZE_TYPE:StringSizeType) {
  builder.addFieldInt8(1, SIZE_TYPE, StringSizeType.FIXED);
}

static addSizeInBits(builder:flatbuffers.Builder, SIZE_IN_BITS:number) {
  builder.addFieldInt16(2, SIZE_IN_BITS, 0);
}

static addTerminationChar(builder:flatbuffers.Builder, TERMINATION_CHAR:number) {
  builder.addFieldInt8(3, TERMINATION_CHAR, 0);
}

static addMaxSizeInBits(builder:flatbuffers.Builder, MAX_SIZE_IN_BITS:number) {
  builder.addFieldInt16(4, MAX_SIZE_IN_BITS, 0);
}

static addLeadingSizeBits(builder:flatbuffers.Builder, LEADING_SIZE_BITS:number) {
  builder.addFieldInt8(5, LEADING_SIZE_BITS, 0);
}

static endStringDataEncoding(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createStringDataEncoding(builder:flatbuffers.Builder, ENCODING:StringEncodingType, SIZE_TYPE:StringSizeType, SIZE_IN_BITS:number, TERMINATION_CHAR:number, MAX_SIZE_IN_BITS:number, LEADING_SIZE_BITS:number):flatbuffers.Offset {
  StringDataEncoding.startStringDataEncoding(builder);
  StringDataEncoding.addEncoding(builder, ENCODING);
  StringDataEncoding.addSizeType(builder, SIZE_TYPE);
  StringDataEncoding.addSizeInBits(builder, SIZE_IN_BITS);
  StringDataEncoding.addTerminationChar(builder, TERMINATION_CHAR);
  StringDataEncoding.addMaxSizeInBits(builder, MAX_SIZE_IN_BITS);
  StringDataEncoding.addLeadingSizeBits(builder, LEADING_SIZE_BITS);
  return StringDataEncoding.endStringDataEncoding(builder);
}

unpack(): StringDataEncodingT {
  return new StringDataEncodingT(
    this.ENCODING(),
    this.SIZE_TYPE(),
    this.SIZE_IN_BITS(),
    this.TERMINATION_CHAR(),
    this.MAX_SIZE_IN_BITS(),
    this.LEADING_SIZE_BITS()
  );
}


unpackTo(_o: StringDataEncodingT): void {
  _o.ENCODING = this.ENCODING();
  _o.SIZE_TYPE = this.SIZE_TYPE();
  _o.SIZE_IN_BITS = this.SIZE_IN_BITS();
  _o.TERMINATION_CHAR = this.TERMINATION_CHAR();
  _o.MAX_SIZE_IN_BITS = this.MAX_SIZE_IN_BITS();
  _o.LEADING_SIZE_BITS = this.LEADING_SIZE_BITS();
}
}

export class StringDataEncodingT implements flatbuffers.IGeneratedObject {
constructor(
  public ENCODING: StringEncodingType = StringEncodingType.UTF_8,
  public SIZE_TYPE: StringSizeType = StringSizeType.FIXED,
  public SIZE_IN_BITS: number = 0,
  public TERMINATION_CHAR: number = 0,
  public MAX_SIZE_IN_BITS: number = 0,
  public LEADING_SIZE_BITS: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return StringDataEncoding.createStringDataEncoding(builder,
    this.ENCODING,
    this.SIZE_TYPE,
    this.SIZE_IN_BITS,
    this.TERMINATION_CHAR,
    this.MAX_SIZE_IN_BITS,
    this.LEADING_SIZE_BITS
  );
}
}
