// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Temporal coverage definition
 */
export class TemporalCoverage implements flatbuffers.IUnpackableObject<TemporalCoverageT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):TemporalCoverage {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsTemporalCoverage(bb:flatbuffers.ByteBuffer, obj?:TemporalCoverage):TemporalCoverage {
  return (obj || new TemporalCoverage()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsTemporalCoverage(bb:flatbuffers.ByteBuffer, obj?:TemporalCoverage):TemporalCoverage {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new TemporalCoverage()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Start epoch in ISO 8601 format
 */
START_EPOCH():string|null
START_EPOCH(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
START_EPOCH(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * End epoch in ISO 8601 format
 */
END_EPOCH():string|null
END_EPOCH(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
END_EPOCH(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Update frequency: "realtime", "hourly", "daily"
 */
UPDATE_FREQUENCY():string|null
UPDATE_FREQUENCY(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
UPDATE_FREQUENCY(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Days of historical data available
 */
HISTORICAL_DEPTH():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

static startTemporalCoverage(builder:flatbuffers.Builder) {
  builder.startObject(4);
}

static addStartEpoch(builder:flatbuffers.Builder, START_EPOCHOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, START_EPOCHOffset, 0);
}

static addEndEpoch(builder:flatbuffers.Builder, END_EPOCHOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, END_EPOCHOffset, 0);
}

static addUpdateFrequency(builder:flatbuffers.Builder, UPDATE_FREQUENCYOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, UPDATE_FREQUENCYOffset, 0);
}

static addHistoricalDepth(builder:flatbuffers.Builder, HISTORICAL_DEPTH:number) {
  builder.addFieldInt32(3, HISTORICAL_DEPTH, 0);
}

static endTemporalCoverage(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createTemporalCoverage(builder:flatbuffers.Builder, START_EPOCHOffset:flatbuffers.Offset, END_EPOCHOffset:flatbuffers.Offset, UPDATE_FREQUENCYOffset:flatbuffers.Offset, HISTORICAL_DEPTH:number):flatbuffers.Offset {
  TemporalCoverage.startTemporalCoverage(builder);
  TemporalCoverage.addStartEpoch(builder, START_EPOCHOffset);
  TemporalCoverage.addEndEpoch(builder, END_EPOCHOffset);
  TemporalCoverage.addUpdateFrequency(builder, UPDATE_FREQUENCYOffset);
  TemporalCoverage.addHistoricalDepth(builder, HISTORICAL_DEPTH);
  return TemporalCoverage.endTemporalCoverage(builder);
}

unpack(): TemporalCoverageT {
  return new TemporalCoverageT(
    this.START_EPOCH(),
    this.END_EPOCH(),
    this.UPDATE_FREQUENCY(),
    this.HISTORICAL_DEPTH()
  );
}


unpackTo(_o: TemporalCoverageT): void {
  _o.START_EPOCH = this.START_EPOCH();
  _o.END_EPOCH = this.END_EPOCH();
  _o.UPDATE_FREQUENCY = this.UPDATE_FREQUENCY();
  _o.HISTORICAL_DEPTH = this.HISTORICAL_DEPTH();
}
}

export class TemporalCoverageT implements flatbuffers.IGeneratedObject {
constructor(
  public START_EPOCH: string|Uint8Array|null = null,
  public END_EPOCH: string|Uint8Array|null = null,
  public UPDATE_FREQUENCY: string|Uint8Array|null = null,
  public HISTORICAL_DEPTH: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const START_EPOCH = (this.START_EPOCH !== null ? builder.createString(this.START_EPOCH!) : 0);
  const END_EPOCH = (this.END_EPOCH !== null ? builder.createString(this.END_EPOCH!) : 0);
  const UPDATE_FREQUENCY = (this.UPDATE_FREQUENCY !== null ? builder.createString(this.UPDATE_FREQUENCY!) : 0);

  return TemporalCoverage.createTemporalCoverage(builder,
    START_EPOCH,
    END_EPOCH,
    UPDATE_FREQUENCY,
    this.HISTORICAL_DEPTH
  );
}
}
