// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';



/**
 * Observation Stability Message
 */
export class OSM implements flatbuffers.IUnpackableObject<OSMT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):OSM {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsOSM(bb:flatbuffers.ByteBuffer, obj?:OSM):OSM {
  return (obj || new OSM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsOSM(bb:flatbuffers.ByteBuffer, obj?:OSM):OSM {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new OSM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$OSM');
}

/**
 * Indicates whether the observation is stable or not
 */
IS_STABLE():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The number of observations
 */
NUM_OBS():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Unique identifier for the object being observed
 */
OBJECT_ID():string|null
OBJECT_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
OBJECT_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Identifier of the sensor
 */
ID_SENSOR():string|null
ID_SENSOR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID_SENSOR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Timestamp of data creation
 */
PASS_START():string|null
PASS_START(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PASS_START(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Duration of the observation pass in seconds
 */
PASS_DURATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

static startOSM(builder:flatbuffers.Builder) {
  builder.startObject(6);
}

static addIsStable(builder:flatbuffers.Builder, IS_STABLE:boolean) {
  builder.addFieldInt8(0, +IS_STABLE, +false);
}

static addNumObs(builder:flatbuffers.Builder, NUM_OBS:number) {
  builder.addFieldInt32(1, NUM_OBS, 0);
}

static addObjectId(builder:flatbuffers.Builder, OBJECT_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, OBJECT_IDOffset, 0);
}

static addIdSensor(builder:flatbuffers.Builder, ID_SENSOROffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, ID_SENSOROffset, 0);
}

static addPassStart(builder:flatbuffers.Builder, PASS_STARTOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, PASS_STARTOffset, 0);
}

static addPassDuration(builder:flatbuffers.Builder, PASS_DURATION:number) {
  builder.addFieldInt32(5, PASS_DURATION, 0);
}

static endOSM(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishOSMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$OSM');
}

static finishSizePrefixedOSMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$OSM', true);
}

static createOSM(builder:flatbuffers.Builder, IS_STABLE:boolean, NUM_OBS:number, OBJECT_IDOffset:flatbuffers.Offset, ID_SENSOROffset:flatbuffers.Offset, PASS_STARTOffset:flatbuffers.Offset, PASS_DURATION:number):flatbuffers.Offset {
  OSM.startOSM(builder);
  OSM.addIsStable(builder, IS_STABLE);
  OSM.addNumObs(builder, NUM_OBS);
  OSM.addObjectId(builder, OBJECT_IDOffset);
  OSM.addIdSensor(builder, ID_SENSOROffset);
  OSM.addPassStart(builder, PASS_STARTOffset);
  OSM.addPassDuration(builder, PASS_DURATION);
  return OSM.endOSM(builder);
}

unpack(): OSMT {
  return new OSMT(
    this.IS_STABLE(),
    this.NUM_OBS(),
    this.OBJECT_ID(),
    this.ID_SENSOR(),
    this.PASS_START(),
    this.PASS_DURATION()
  );
}


unpackTo(_o: OSMT): void {
  _o.IS_STABLE = this.IS_STABLE();
  _o.NUM_OBS = this.NUM_OBS();
  _o.OBJECT_ID = this.OBJECT_ID();
  _o.ID_SENSOR = this.ID_SENSOR();
  _o.PASS_START = this.PASS_START();
  _o.PASS_DURATION = this.PASS_DURATION();
}
}

export class OSMT implements flatbuffers.IGeneratedObject {
constructor(
  public IS_STABLE: boolean = false,
  public NUM_OBS: number = 0,
  public OBJECT_ID: string|Uint8Array|null = null,
  public ID_SENSOR: string|Uint8Array|null = null,
  public PASS_START: string|Uint8Array|null = null,
  public PASS_DURATION: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const OBJECT_ID = (this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID!) : 0);
  const ID_SENSOR = (this.ID_SENSOR !== null ? builder.createString(this.ID_SENSOR!) : 0);
  const PASS_START = (this.PASS_START !== null ? builder.createString(this.PASS_START!) : 0);

  return OSM.createOSM(builder,
    this.IS_STABLE,
    this.NUM_OBS,
    OBJECT_ID,
    ID_SENSOR,
    PASS_START,
    this.PASS_DURATION
  );
}
}
