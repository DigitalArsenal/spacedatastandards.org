// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Weapons and Munitions
 */
export class WPN implements flatbuffers.IUnpackableObject<WPNT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):WPN {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsWPN(bb:flatbuffers.ByteBuffer, obj?:WPN):WPN {
  return (obj || new WPN()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsWPN(bb:flatbuffers.ByteBuffer, obj?:WPN):WPN {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new WPN()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$WPN');
}

CALIBER():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

MUZZLE_VELOCITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

RATE_OF_FIRE():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

DISPERSION():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

AMMO_CAPACITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

BURST_LENGTH():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

RELOAD_TIME():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

OVERHEAT_ROUNDS():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

COOLDOWN_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

ELEVATION_MIN():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

ELEVATION_MAX():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

TRAVERSE_MIN():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

TRAVERSE_MAX():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

SLEW_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

WEAPON_TYPE():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

FUZE_TYPE():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

RESERVED(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

reservedLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

reservedArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startWPN(builder:flatbuffers.Builder) {
  builder.startObject(17);
}

static addCaliber(builder:flatbuffers.Builder, CALIBER:number) {
  builder.addFieldFloat32(0, CALIBER, 0.0);
}

static addMuzzleVelocity(builder:flatbuffers.Builder, MUZZLE_VELOCITY:number) {
  builder.addFieldFloat32(1, MUZZLE_VELOCITY, 0.0);
}

static addRateOfFire(builder:flatbuffers.Builder, RATE_OF_FIRE:number) {
  builder.addFieldFloat32(2, RATE_OF_FIRE, 0.0);
}

static addDispersion(builder:flatbuffers.Builder, DISPERSION:number) {
  builder.addFieldFloat32(3, DISPERSION, 0.0);
}

static addAmmoCapacity(builder:flatbuffers.Builder, AMMO_CAPACITY:number) {
  builder.addFieldInt16(4, AMMO_CAPACITY, 0);
}

static addBurstLength(builder:flatbuffers.Builder, BURST_LENGTH:number) {
  builder.addFieldInt16(5, BURST_LENGTH, 0);
}

static addReloadTime(builder:flatbuffers.Builder, RELOAD_TIME:number) {
  builder.addFieldFloat32(6, RELOAD_TIME, 0.0);
}

static addOverheatRounds(builder:flatbuffers.Builder, OVERHEAT_ROUNDS:number) {
  builder.addFieldInt16(7, OVERHEAT_ROUNDS, 0);
}

static addCooldownRate(builder:flatbuffers.Builder, COOLDOWN_RATE:number) {
  builder.addFieldFloat32(8, COOLDOWN_RATE, 0.0);
}

static addElevationMin(builder:flatbuffers.Builder, ELEVATION_MIN:number) {
  builder.addFieldFloat32(9, ELEVATION_MIN, 0.0);
}

static addElevationMax(builder:flatbuffers.Builder, ELEVATION_MAX:number) {
  builder.addFieldFloat32(10, ELEVATION_MAX, 0.0);
}

static addTraverseMin(builder:flatbuffers.Builder, TRAVERSE_MIN:number) {
  builder.addFieldFloat32(11, TRAVERSE_MIN, 0.0);
}

static addTraverseMax(builder:flatbuffers.Builder, TRAVERSE_MAX:number) {
  builder.addFieldFloat32(12, TRAVERSE_MAX, 0.0);
}

static addSlewRate(builder:flatbuffers.Builder, SLEW_RATE:number) {
  builder.addFieldFloat32(13, SLEW_RATE, 0.0);
}

static addWeaponType(builder:flatbuffers.Builder, WEAPON_TYPE:number) {
  builder.addFieldInt8(14, WEAPON_TYPE, 0);
}

static addFuzeType(builder:flatbuffers.Builder, FUZE_TYPE:number) {
  builder.addFieldInt8(15, FUZE_TYPE, 0);
}

static addReserved(builder:flatbuffers.Builder, RESERVEDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, RESERVEDOffset, 0);
}

static createReservedVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startReservedVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static endWPN(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishWPNBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$WPN');
}

static finishSizePrefixedWPNBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$WPN', true);
}

static createWPN(builder:flatbuffers.Builder, CALIBER:number, MUZZLE_VELOCITY:number, RATE_OF_FIRE:number, DISPERSION:number, AMMO_CAPACITY:number, BURST_LENGTH:number, RELOAD_TIME:number, OVERHEAT_ROUNDS:number, COOLDOWN_RATE:number, ELEVATION_MIN:number, ELEVATION_MAX:number, TRAVERSE_MIN:number, TRAVERSE_MAX:number, SLEW_RATE:number, WEAPON_TYPE:number, FUZE_TYPE:number, RESERVEDOffset:flatbuffers.Offset):flatbuffers.Offset {
  WPN.startWPN(builder);
  WPN.addCaliber(builder, CALIBER);
  WPN.addMuzzleVelocity(builder, MUZZLE_VELOCITY);
  WPN.addRateOfFire(builder, RATE_OF_FIRE);
  WPN.addDispersion(builder, DISPERSION);
  WPN.addAmmoCapacity(builder, AMMO_CAPACITY);
  WPN.addBurstLength(builder, BURST_LENGTH);
  WPN.addReloadTime(builder, RELOAD_TIME);
  WPN.addOverheatRounds(builder, OVERHEAT_ROUNDS);
  WPN.addCooldownRate(builder, COOLDOWN_RATE);
  WPN.addElevationMin(builder, ELEVATION_MIN);
  WPN.addElevationMax(builder, ELEVATION_MAX);
  WPN.addTraverseMin(builder, TRAVERSE_MIN);
  WPN.addTraverseMax(builder, TRAVERSE_MAX);
  WPN.addSlewRate(builder, SLEW_RATE);
  WPN.addWeaponType(builder, WEAPON_TYPE);
  WPN.addFuzeType(builder, FUZE_TYPE);
  WPN.addReserved(builder, RESERVEDOffset);
  return WPN.endWPN(builder);
}

unpack(): WPNT {
  return new WPNT(
    this.CALIBER(),
    this.MUZZLE_VELOCITY(),
    this.RATE_OF_FIRE(),
    this.DISPERSION(),
    this.AMMO_CAPACITY(),
    this.BURST_LENGTH(),
    this.RELOAD_TIME(),
    this.OVERHEAT_ROUNDS(),
    this.COOLDOWN_RATE(),
    this.ELEVATION_MIN(),
    this.ELEVATION_MAX(),
    this.TRAVERSE_MIN(),
    this.TRAVERSE_MAX(),
    this.SLEW_RATE(),
    this.WEAPON_TYPE(),
    this.FUZE_TYPE(),
    this.bb!.createScalarList<number>(this.RESERVED.bind(this), this.reservedLength())
  );
}


unpackTo(_o: WPNT): void {
  _o.CALIBER = this.CALIBER();
  _o.MUZZLE_VELOCITY = this.MUZZLE_VELOCITY();
  _o.RATE_OF_FIRE = this.RATE_OF_FIRE();
  _o.DISPERSION = this.DISPERSION();
  _o.AMMO_CAPACITY = this.AMMO_CAPACITY();
  _o.BURST_LENGTH = this.BURST_LENGTH();
  _o.RELOAD_TIME = this.RELOAD_TIME();
  _o.OVERHEAT_ROUNDS = this.OVERHEAT_ROUNDS();
  _o.COOLDOWN_RATE = this.COOLDOWN_RATE();
  _o.ELEVATION_MIN = this.ELEVATION_MIN();
  _o.ELEVATION_MAX = this.ELEVATION_MAX();
  _o.TRAVERSE_MIN = this.TRAVERSE_MIN();
  _o.TRAVERSE_MAX = this.TRAVERSE_MAX();
  _o.SLEW_RATE = this.SLEW_RATE();
  _o.WEAPON_TYPE = this.WEAPON_TYPE();
  _o.FUZE_TYPE = this.FUZE_TYPE();
  _o.RESERVED = this.bb!.createScalarList<number>(this.RESERVED.bind(this), this.reservedLength());
}
}

export class WPNT implements flatbuffers.IGeneratedObject {
constructor(
  public CALIBER: number = 0.0,
  public MUZZLE_VELOCITY: number = 0.0,
  public RATE_OF_FIRE: number = 0.0,
  public DISPERSION: number = 0.0,
  public AMMO_CAPACITY: number = 0,
  public BURST_LENGTH: number = 0,
  public RELOAD_TIME: number = 0.0,
  public OVERHEAT_ROUNDS: number = 0,
  public COOLDOWN_RATE: number = 0.0,
  public ELEVATION_MIN: number = 0.0,
  public ELEVATION_MAX: number = 0.0,
  public TRAVERSE_MIN: number = 0.0,
  public TRAVERSE_MAX: number = 0.0,
  public SLEW_RATE: number = 0.0,
  public WEAPON_TYPE: number = 0,
  public FUZE_TYPE: number = 0,
  public RESERVED: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const RESERVED = WPN.createReservedVector(builder, this.RESERVED);

  return WPN.createWPN(builder,
    this.CALIBER,
    this.MUZZLE_VELOCITY,
    this.RATE_OF_FIRE,
    this.DISPERSION,
    this.AMMO_CAPACITY,
    this.BURST_LENGTH,
    this.RELOAD_TIME,
    this.OVERHEAT_ROUNDS,
    this.COOLDOWN_RATE,
    this.ELEVATION_MIN,
    this.ELEVATION_MAX,
    this.TRAVERSE_MIN,
    this.TRAVERSE_MAX,
    this.SLEW_RATE,
    this.WEAPON_TYPE,
    this.FUZE_TYPE,
    RESERVED
  );
}
}
