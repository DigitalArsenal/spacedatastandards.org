// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { CollectMethod } from './CollectMethod.js';
import { DataMode } from './DataMode.js';
import { DeviceType } from './DeviceType.js';
import { ObservationPosition } from './ObservationPosition.js';
import { refFrame } from './refFrame.js';


/**
 * Electro-Optical Observation
 */
export class EOO implements flatbuffers.IUnpackableObject<EOOT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):EOO {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsEOO(bb:flatbuffers.ByteBuffer, obj?:EOO):EOO {
  return (obj || new EOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsEOO(bb:flatbuffers.ByteBuffer, obj?:EOO):EOO {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new EOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$EOO');
}

/**
 * Unique identifier of the record.
 */
ID():string|null
ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 */
CLASSIFICATION():string|null
CLASSIFICATION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CLASSIFICATION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Ob detection time in ISO 8601 UTC (YYYY-MM-DDTHH:MM:SS.ssssssZ), up to microsecond precision.
 */
OB_TIME():string|null
OB_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
OB_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Correlation score of the observation when compared to a known orbit state.
 */
CORR_QUALITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Server will auto-populate with SAT_NO if available.
 */
ID_ON_ORBIT():string|null
ID_ON_ORBIT(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID_ON_ORBIT(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique ID of the sensor. Must have a corresponding sensor record on the server.
 */
SENSOR_ID():string|null
SENSOR_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SENSOR_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Accepted Collection Method
 */
COLLECT_METHOD():CollectMethod {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : CollectMethod.SIDEREAL;
}

/**
 * 18SDS satellite number. Only list if correlated against the 18SDS catalog.
 */
NORAD_CAT_ID():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Identifier for the collectRequest message if the collection was in response to tasking.
 */
TASK_ID():string|null
TASK_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TASK_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional identifier to track a transaction.
 */
TRANSACTION_ID():string|null
TRANSACTION_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TRANSACTION_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Identifier of the track to which this observation belongs, if applicable.
 */
TRACK_ID():string|null
TRACK_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TRACK_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).
 */
OB_POSITION():ObservationPosition {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : ObservationPosition.FENCE;
}

/**
 * Provider maintained ID. May not be consistent with 18SDS SAT_NO.
 */
ORIG_OBJECT_ID():string|null
ORIG_OBJECT_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIG_OBJECT_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Sensor ID.
 */
ORIG_SENSOR_ID():string|null
ORIG_SENSOR_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIG_SENSOR_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Required if correlation is attempted. Indicates whether correlation succeeded.
 */
UCT():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Line of sight azimuth angle in degrees and topocentric frame.
 */
AZIMUTH():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight azimuth angle, in degrees.
 */
AZIMUTH_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor line of sight azimuth angle bias in degrees.
 */
AZIMUTH_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Rate of change of the line of sight azimuth in degrees per second.
 */
AZIMUTH_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Line of sight elevation in degrees and topocentric frame.
 */
ELEVATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight elevation angle, in degrees.
 */
ELEVATION_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor line of sight elevation bias in degrees.
 */
ELEVATION_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Rate of change of the line of sight elevation in degrees per second.
 */
ELEVATION_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Line of sight range in km. Reported value should include all applicable corrections.
 */
RANGE():number {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight range, in km.
 */
RANGE_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor line of sight range bias in km.
 */
RANGE_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Range rate in km/s. Reported value should include all applicable corrections.
 */
RANGE_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight range rate, in km/sec.
 */
RANGE_RATE_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Right ascension in degrees. Required metric reporting field for EO observations.
 */
RA():number {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Line of sight right ascension rate of change, in degrees/sec.
 */
RA_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight right ascension angle, in degrees.
 */
RA_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor line of sight right ascension bias in degrees.
 */
RA_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Declination in degrees. Required metric reporting field for EO observations.
 */
DECLINATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Line of sight declination rate of change, in degrees/sec.
 */
DECLINATION_RATE():number {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line of sight declination angle, in degrees.
 */
DECLINATION_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 72);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor line of sight declination angle bias in degrees.
 */
DECLINATION_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 74);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * X-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
 */
LOSX():number {
  const offset = this.bb!.__offset(this.bb_pos, 76);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Y-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
 */
LOSY():number {
  const offset = this.bb!.__offset(this.bb_pos, 78);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Z-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
 */
LOSZ():number {
  const offset = this.bb!.__offset(this.bb_pos, 80);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * One sigma uncertainty in the line-of-sight direction vector components.
 */
LOS_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 82);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * X-component of the velocity vector along the line of sight, in km/s.
 */
LOSXVEL():number {
  const offset = this.bb!.__offset(this.bb_pos, 84);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Y-component of the velocity vector along the line of sight, in km/s.
 */
LOSYVEL():number {
  const offset = this.bb!.__offset(this.bb_pos, 86);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Z-component of the velocity vector along the line of sight, in km/s.
 */
LOSZVEL():number {
  const offset = this.bb!.__offset(this.bb_pos, 88);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * WGS-84 latitude in decimal degrees at the time of the observation.
 */
SENLAT():number {
  const offset = this.bb!.__offset(this.bb_pos, 90);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * WGS-84 longitude in decimal degrees at the time of the observation.
 */
SENLON():number {
  const offset = this.bb!.__offset(this.bb_pos, 92);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor height in km relative to the WGS-84 ellipsoid at the time of the observation.
 */
SENALT():number {
  const offset = this.bb!.__offset(this.bb_pos, 94);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Cartesian X position in km at the time of the observation.
 */
SENX():number {
  const offset = this.bb!.__offset(this.bb_pos, 96);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Cartesian Y position in km at the time of the observation.
 */
SENY():number {
  const offset = this.bb!.__offset(this.bb_pos, 98);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Cartesian Z position in km at the time of the observation.
 */
SENZ():number {
  const offset = this.bb!.__offset(this.bb_pos, 100);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Total number of satellites in the field of view.
 */
FOV_COUNT():number {
  const offset = this.bb!.__offset(this.bb_pos, 102);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Number of uncorrelated satellites in the field of view (JCO).
 */
FOV_COUNT_UCTS():number {
  const offset = this.bb!.__offset(this.bb_pos, 104);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Image exposure duration in seconds. For observations performed using frame stacking or synthetic tracking methods, 
 * the exposure duration should be the total integration time. This field is highly recommended / required if the 
 * observations are going to be used for photometric processing.
 */
EXP_DURATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 106);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Formula: 2.5 * log_10 (zero_mag_counts / EXP_DURATION).
 */
ZEROPTD():number {
  const offset = this.bb!.__offset(this.bb_pos, 108);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Net object signature = counts / EXP_DURATION.
 */
NET_OBJ_SIG():number {
  const offset = this.bb!.__offset(this.bb_pos, 110);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Net object signature uncertainty = counts uncertainty / EXP_DURATION.
 */
NET_OBJ_SIG_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 112);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Measure of observed brightness calibrated against the Gaia G-band.
 */
MAG():number {
  const offset = this.bb!.__offset(this.bb_pos, 114);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Uncertainty of the observed brightness.
 */
MAG_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 116);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * [Definition needed].
 */
MAG_NORM_RANGE():number {
  const offset = this.bb!.__offset(this.bb_pos, 118);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Computed estimate of the latitude, positive degrees north. It should be computed based on the assumed slant range 
 * and corresponding viewing geometry. It must NOT be computed from the orbit state.
 */
GEOLAT():number {
  const offset = this.bb!.__offset(this.bb_pos, 120);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Computed estimate of the longitude as +/- 180 degrees east. It should be computed based on the assumed slant range 
 * and viewing geometry. It must NOT be computed from the orbit state.
 */
GEOLON():number {
  const offset = this.bb!.__offset(this.bb_pos, 122);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Computed estimate of satellite altitude in km at the reported location. It must NOT be computed from the orbit state.
 */
GEOALT():number {
  const offset = this.bb!.__offset(this.bb_pos, 124);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Computed estimate of the slant range in km. It must NOT be computed from the orbit state.
 */
GEORANGE():number {
  const offset = this.bb!.__offset(this.bb_pos, 126);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently 
 * empty part of the night sky.
 */
SKY_BKGRND():number {
  const offset = this.bb!.__offset(this.bb_pos, 128);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass 
 * to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general, 
 * describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical 
 * object and the observer.
 */
PRIMARY_EXTINCTION():number {
  const offset = this.bb!.__offset(this.bb_pos, 130);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Primary Extinction Coefficient Uncertainty, in Magnitudes.
 */
PRIMARY_EXTINCTION_UNC():number {
  const offset = this.bb!.__offset(this.bb_pos, 132);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * The angle, in degrees, between the target-to-observer vector and the target-to-sun vector. Recommend using the 
 * calculation listed in the EOSSA documentation, pg 106 of the EOSSA spec.
 */
SOLAR_PHASE_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 134);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector 
 * onto the equatorial plane. The convention used is negative when closing (i.e., before the opposition) 
 * and positive when opening (after the opposition).
 */
SOLAR_EQ_PHASE_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 136);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Angle from the sun to the equatorial plane.
 */
SOLAR_DEC_ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 138);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Shutter delay in seconds.
 */
SHUTTER_DELAY():number {
  const offset = this.bb!.__offset(this.bb_pos, 140);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Sensor timing bias in seconds.
 */
TIMING_BIAS():number {
  const offset = this.bb!.__offset(this.bb_pos, 142);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Optional URI location in the document repository of the raw file parsed by the system to produce this record. 
 */
RAW_FILE_URI():string|null
RAW_FILE_URI(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
RAW_FILE_URI(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 144);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Intensity of the target for IR observations, in kw/sr/em.
 */
INTENSITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 146);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Background intensity for IR observations, in kw/sr/um.
 */
BG_INTENSITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 148);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Optional source-provided and searchable metadata or descriptor of the data.
 */
DESCRIPTOR():string|null
DESCRIPTOR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
DESCRIPTOR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 150);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Source of the data.
 */
SOURCE():string|null
SOURCE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SOURCE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 152);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Originating system or organization which produced the data, if different from the source.
 * The origin may be different than the source if the source was a mediating system which forwarded 
 * the data on behalf of the origin system. If null, the source may be assumed to be the origin.
 */
ORIGIN():string|null
ORIGIN(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIGIN(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 154);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST.
 */
DATA_MODE():DataMode {
  const offset = this.bb!.__offset(this.bb_pos, 156);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : DataMode.EXERCISE;
}

/**
 * Time the row was created in the database, auto-populated by the system.
 */
CREATED_AT():string|null
CREATED_AT(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CREATED_AT(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 158);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Application user who created the row in the database, auto-populated by the system.
 */
CREATED_BY():string|null
CREATED_BY(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CREATED_BY(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 160);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * EO observations are assumed to be topocentric J2000 coordinates ('J2000') as defined by the IAU, unless otherwise specified.
 */
REFERENCE_FRAME():refFrame {
  const offset = this.bb!.__offset(this.bb_pos, 162);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : refFrame.ECEF;
}

/**
 * The sensor reference frame is assumed to be the International Terrestrial Reference Frame (ITRF), 
 * unless otherwise specified. (ITRF is equivalent to Earth-Centered Earth-Fixed (ECEF) for this purpose). 
 * Lat / long / height values should be reported using the WGS-84 ellipsoid, where applicable.
 */
SEN_REFERENCE_FRAME():refFrame {
  const offset = this.bb!.__offset(this.bb_pos, 164);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : refFrame.ECEF;
}

/**
 * Boolean indicating that the target object was in umbral eclipse at the time of this observation.
 */
UMBRA():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 166);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
 * This field is highly recommended if the observations will be used for photometric processing.
 */
PENUMBRA():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 168);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The originating source network on which this record was created, auto-populated by the system.
 */
ORIG_NETWORK():string|null
ORIG_NETWORK(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ORIG_NETWORK(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 170);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The source from which this record was received.
 */
SOURCE_DL():string|null
SOURCE_DL(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SOURCE_DL(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 172);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Device Type
 */
TYPE():DeviceType {
  const offset = this.bb!.__offset(this.bb_pos, 174);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : DeviceType.UNKNOWN;
}

/**
 * True if measured, false if computed. Required if azimuth is reported.
 */
AZIMUTH_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 176);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if measured, false if computed. Required if elevation is reported.
 */
ELEVATION_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 178);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if measured, false if computed. Required if range is reported.
 */
RANGE_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 180);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if measured, false if computed. Required if range-rate is reported.
 */
RANGERATE_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 182);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if measured, false if computed. Required if right ascension is reported.
 */
RA_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 184);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True if measured, false if computed. Required if declination is reported.
 */
DECLINATION_MEASURED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 186);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

static startEOO(builder:flatbuffers.Builder) {
  builder.startObject(92);
}

static addId(builder:flatbuffers.Builder, IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, IDOffset, 0);
}

static addClassification(builder:flatbuffers.Builder, CLASSIFICATIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, CLASSIFICATIONOffset, 0);
}

static addObTime(builder:flatbuffers.Builder, OB_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, OB_TIMEOffset, 0);
}

static addCorrQuality(builder:flatbuffers.Builder, CORR_QUALITY:number) {
  builder.addFieldFloat32(3, CORR_QUALITY, 0.0);
}

static addIdOnOrbit(builder:flatbuffers.Builder, ID_ON_ORBITOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, ID_ON_ORBITOffset, 0);
}

static addSensorId(builder:flatbuffers.Builder, SENSOR_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, SENSOR_IDOffset, 0);
}

static addCollectMethod(builder:flatbuffers.Builder, COLLECT_METHOD:CollectMethod) {
  builder.addFieldInt8(6, COLLECT_METHOD, CollectMethod.SIDEREAL);
}

static addNoradCatId(builder:flatbuffers.Builder, NORAD_CAT_ID:number) {
  builder.addFieldInt32(7, NORAD_CAT_ID, 0);
}

static addTaskId(builder:flatbuffers.Builder, TASK_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, TASK_IDOffset, 0);
}

static addTransactionId(builder:flatbuffers.Builder, TRANSACTION_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, TRANSACTION_IDOffset, 0);
}

static addTrackId(builder:flatbuffers.Builder, TRACK_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, TRACK_IDOffset, 0);
}

static addObPosition(builder:flatbuffers.Builder, OB_POSITION:ObservationPosition) {
  builder.addFieldInt8(11, OB_POSITION, ObservationPosition.FENCE);
}

static addOrigObjectId(builder:flatbuffers.Builder, ORIG_OBJECT_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(12, ORIG_OBJECT_IDOffset, 0);
}

static addOrigSensorId(builder:flatbuffers.Builder, ORIG_SENSOR_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, ORIG_SENSOR_IDOffset, 0);
}

static addUct(builder:flatbuffers.Builder, UCT:boolean) {
  builder.addFieldInt8(14, +UCT, +false);
}

static addAzimuth(builder:flatbuffers.Builder, AZIMUTH:number) {
  builder.addFieldFloat32(15, AZIMUTH, 0.0);
}

static addAzimuthUnc(builder:flatbuffers.Builder, AZIMUTH_UNC:number) {
  builder.addFieldFloat32(16, AZIMUTH_UNC, 0.0);
}

static addAzimuthBias(builder:flatbuffers.Builder, AZIMUTH_BIAS:number) {
  builder.addFieldFloat32(17, AZIMUTH_BIAS, 0.0);
}

static addAzimuthRate(builder:flatbuffers.Builder, AZIMUTH_RATE:number) {
  builder.addFieldFloat32(18, AZIMUTH_RATE, 0.0);
}

static addElevation(builder:flatbuffers.Builder, ELEVATION:number) {
  builder.addFieldFloat32(19, ELEVATION, 0.0);
}

static addElevationUnc(builder:flatbuffers.Builder, ELEVATION_UNC:number) {
  builder.addFieldFloat32(20, ELEVATION_UNC, 0.0);
}

static addElevationBias(builder:flatbuffers.Builder, ELEVATION_BIAS:number) {
  builder.addFieldFloat32(21, ELEVATION_BIAS, 0.0);
}

static addElevationRate(builder:flatbuffers.Builder, ELEVATION_RATE:number) {
  builder.addFieldFloat32(22, ELEVATION_RATE, 0.0);
}

static addRange(builder:flatbuffers.Builder, RANGE:number) {
  builder.addFieldFloat32(23, RANGE, 0.0);
}

static addRangeUnc(builder:flatbuffers.Builder, RANGE_UNC:number) {
  builder.addFieldFloat32(24, RANGE_UNC, 0.0);
}

static addRangeBias(builder:flatbuffers.Builder, RANGE_BIAS:number) {
  builder.addFieldFloat32(25, RANGE_BIAS, 0.0);
}

static addRangeRate(builder:flatbuffers.Builder, RANGE_RATE:number) {
  builder.addFieldFloat32(26, RANGE_RATE, 0.0);
}

static addRangeRateUnc(builder:flatbuffers.Builder, RANGE_RATE_UNC:number) {
  builder.addFieldFloat32(27, RANGE_RATE_UNC, 0.0);
}

static addRa(builder:flatbuffers.Builder, RA:number) {
  builder.addFieldFloat32(28, RA, 0.0);
}

static addRaRate(builder:flatbuffers.Builder, RA_RATE:number) {
  builder.addFieldFloat32(29, RA_RATE, 0.0);
}

static addRaUnc(builder:flatbuffers.Builder, RA_UNC:number) {
  builder.addFieldFloat32(30, RA_UNC, 0.0);
}

static addRaBias(builder:flatbuffers.Builder, RA_BIAS:number) {
  builder.addFieldFloat32(31, RA_BIAS, 0.0);
}

static addDeclination(builder:flatbuffers.Builder, DECLINATION:number) {
  builder.addFieldFloat32(32, DECLINATION, 0.0);
}

static addDeclinationRate(builder:flatbuffers.Builder, DECLINATION_RATE:number) {
  builder.addFieldFloat32(33, DECLINATION_RATE, 0.0);
}

static addDeclinationUnc(builder:flatbuffers.Builder, DECLINATION_UNC:number) {
  builder.addFieldFloat32(34, DECLINATION_UNC, 0.0);
}

static addDeclinationBias(builder:flatbuffers.Builder, DECLINATION_BIAS:number) {
  builder.addFieldFloat32(35, DECLINATION_BIAS, 0.0);
}

static addLosx(builder:flatbuffers.Builder, LOSX:number) {
  builder.addFieldFloat32(36, LOSX, 0.0);
}

static addLosy(builder:flatbuffers.Builder, LOSY:number) {
  builder.addFieldFloat32(37, LOSY, 0.0);
}

static addLosz(builder:flatbuffers.Builder, LOSZ:number) {
  builder.addFieldFloat32(38, LOSZ, 0.0);
}

static addLosUnc(builder:flatbuffers.Builder, LOS_UNC:number) {
  builder.addFieldFloat32(39, LOS_UNC, 0.0);
}

static addLosxvel(builder:flatbuffers.Builder, LOSXVEL:number) {
  builder.addFieldFloat32(40, LOSXVEL, 0.0);
}

static addLosyvel(builder:flatbuffers.Builder, LOSYVEL:number) {
  builder.addFieldFloat32(41, LOSYVEL, 0.0);
}

static addLoszvel(builder:flatbuffers.Builder, LOSZVEL:number) {
  builder.addFieldFloat32(42, LOSZVEL, 0.0);
}

static addSenlat(builder:flatbuffers.Builder, SENLAT:number) {
  builder.addFieldFloat32(43, SENLAT, 0.0);
}

static addSenlon(builder:flatbuffers.Builder, SENLON:number) {
  builder.addFieldFloat32(44, SENLON, 0.0);
}

static addSenalt(builder:flatbuffers.Builder, SENALT:number) {
  builder.addFieldFloat32(45, SENALT, 0.0);
}

static addSenx(builder:flatbuffers.Builder, SENX:number) {
  builder.addFieldFloat32(46, SENX, 0.0);
}

static addSeny(builder:flatbuffers.Builder, SENY:number) {
  builder.addFieldFloat32(47, SENY, 0.0);
}

static addSenz(builder:flatbuffers.Builder, SENZ:number) {
  builder.addFieldFloat32(48, SENZ, 0.0);
}

static addFovCount(builder:flatbuffers.Builder, FOV_COUNT:number) {
  builder.addFieldInt32(49, FOV_COUNT, 0);
}

static addFovCountUcts(builder:flatbuffers.Builder, FOV_COUNT_UCTS:number) {
  builder.addFieldInt32(50, FOV_COUNT_UCTS, 0);
}

static addExpDuration(builder:flatbuffers.Builder, EXP_DURATION:number) {
  builder.addFieldFloat32(51, EXP_DURATION, 0.0);
}

static addZeroptd(builder:flatbuffers.Builder, ZEROPTD:number) {
  builder.addFieldFloat32(52, ZEROPTD, 0.0);
}

static addNetObjSig(builder:flatbuffers.Builder, NET_OBJ_SIG:number) {
  builder.addFieldFloat32(53, NET_OBJ_SIG, 0.0);
}

static addNetObjSigUnc(builder:flatbuffers.Builder, NET_OBJ_SIG_UNC:number) {
  builder.addFieldFloat32(54, NET_OBJ_SIG_UNC, 0.0);
}

static addMag(builder:flatbuffers.Builder, MAG:number) {
  builder.addFieldFloat32(55, MAG, 0.0);
}

static addMagUnc(builder:flatbuffers.Builder, MAG_UNC:number) {
  builder.addFieldFloat32(56, MAG_UNC, 0.0);
}

static addMagNormRange(builder:flatbuffers.Builder, MAG_NORM_RANGE:number) {
  builder.addFieldFloat32(57, MAG_NORM_RANGE, 0.0);
}

static addGeolat(builder:flatbuffers.Builder, GEOLAT:number) {
  builder.addFieldFloat32(58, GEOLAT, 0.0);
}

static addGeolon(builder:flatbuffers.Builder, GEOLON:number) {
  builder.addFieldFloat32(59, GEOLON, 0.0);
}

static addGeoalt(builder:flatbuffers.Builder, GEOALT:number) {
  builder.addFieldFloat32(60, GEOALT, 0.0);
}

static addGeorange(builder:flatbuffers.Builder, GEORANGE:number) {
  builder.addFieldFloat32(61, GEORANGE, 0.0);
}

static addSkyBkgrnd(builder:flatbuffers.Builder, SKY_BKGRND:number) {
  builder.addFieldFloat32(62, SKY_BKGRND, 0.0);
}

static addPrimaryExtinction(builder:flatbuffers.Builder, PRIMARY_EXTINCTION:number) {
  builder.addFieldFloat32(63, PRIMARY_EXTINCTION, 0.0);
}

static addPrimaryExtinctionUnc(builder:flatbuffers.Builder, PRIMARY_EXTINCTION_UNC:number) {
  builder.addFieldFloat32(64, PRIMARY_EXTINCTION_UNC, 0.0);
}

static addSolarPhaseAngle(builder:flatbuffers.Builder, SOLAR_PHASE_ANGLE:number) {
  builder.addFieldFloat32(65, SOLAR_PHASE_ANGLE, 0.0);
}

static addSolarEqPhaseAngle(builder:flatbuffers.Builder, SOLAR_EQ_PHASE_ANGLE:number) {
  builder.addFieldFloat32(66, SOLAR_EQ_PHASE_ANGLE, 0.0);
}

static addSolarDecAngle(builder:flatbuffers.Builder, SOLAR_DEC_ANGLE:number) {
  builder.addFieldFloat32(67, SOLAR_DEC_ANGLE, 0.0);
}

static addShutterDelay(builder:flatbuffers.Builder, SHUTTER_DELAY:number) {
  builder.addFieldFloat32(68, SHUTTER_DELAY, 0.0);
}

static addTimingBias(builder:flatbuffers.Builder, TIMING_BIAS:number) {
  builder.addFieldFloat32(69, TIMING_BIAS, 0.0);
}

static addRawFileUri(builder:flatbuffers.Builder, RAW_FILE_URIOffset:flatbuffers.Offset) {
  builder.addFieldOffset(70, RAW_FILE_URIOffset, 0);
}

static addIntensity(builder:flatbuffers.Builder, INTENSITY:number) {
  builder.addFieldFloat32(71, INTENSITY, 0.0);
}

static addBgIntensity(builder:flatbuffers.Builder, BG_INTENSITY:number) {
  builder.addFieldFloat32(72, BG_INTENSITY, 0.0);
}

static addDescriptor(builder:flatbuffers.Builder, DESCRIPTOROffset:flatbuffers.Offset) {
  builder.addFieldOffset(73, DESCRIPTOROffset, 0);
}

static addSource(builder:flatbuffers.Builder, SOURCEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(74, SOURCEOffset, 0);
}

static addOrigin(builder:flatbuffers.Builder, ORIGINOffset:flatbuffers.Offset) {
  builder.addFieldOffset(75, ORIGINOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, DATA_MODE:DataMode) {
  builder.addFieldInt8(76, DATA_MODE, DataMode.EXERCISE);
}

static addCreatedAt(builder:flatbuffers.Builder, CREATED_ATOffset:flatbuffers.Offset) {
  builder.addFieldOffset(77, CREATED_ATOffset, 0);
}

static addCreatedBy(builder:flatbuffers.Builder, CREATED_BYOffset:flatbuffers.Offset) {
  builder.addFieldOffset(78, CREATED_BYOffset, 0);
}

static addReferenceFrame(builder:flatbuffers.Builder, REFERENCE_FRAME:refFrame) {
  builder.addFieldInt8(79, REFERENCE_FRAME, refFrame.ECEF);
}

static addSenReferenceFrame(builder:flatbuffers.Builder, SEN_REFERENCE_FRAME:refFrame) {
  builder.addFieldInt8(80, SEN_REFERENCE_FRAME, refFrame.ECEF);
}

static addUmbra(builder:flatbuffers.Builder, UMBRA:boolean) {
  builder.addFieldInt8(81, +UMBRA, +false);
}

static addPenumbra(builder:flatbuffers.Builder, PENUMBRA:boolean) {
  builder.addFieldInt8(82, +PENUMBRA, +false);
}

static addOrigNetwork(builder:flatbuffers.Builder, ORIG_NETWORKOffset:flatbuffers.Offset) {
  builder.addFieldOffset(83, ORIG_NETWORKOffset, 0);
}

static addSourceDl(builder:flatbuffers.Builder, SOURCE_DLOffset:flatbuffers.Offset) {
  builder.addFieldOffset(84, SOURCE_DLOffset, 0);
}

static addType(builder:flatbuffers.Builder, TYPE:DeviceType) {
  builder.addFieldInt8(85, TYPE, DeviceType.UNKNOWN);
}

static addAzimuthMeasured(builder:flatbuffers.Builder, AZIMUTH_MEASURED:boolean) {
  builder.addFieldInt8(86, +AZIMUTH_MEASURED, +false);
}

static addElevationMeasured(builder:flatbuffers.Builder, ELEVATION_MEASURED:boolean) {
  builder.addFieldInt8(87, +ELEVATION_MEASURED, +false);
}

static addRangeMeasured(builder:flatbuffers.Builder, RANGE_MEASURED:boolean) {
  builder.addFieldInt8(88, +RANGE_MEASURED, +false);
}

static addRangerateMeasured(builder:flatbuffers.Builder, RANGERATE_MEASURED:boolean) {
  builder.addFieldInt8(89, +RANGERATE_MEASURED, +false);
}

static addRaMeasured(builder:flatbuffers.Builder, RA_MEASURED:boolean) {
  builder.addFieldInt8(90, +RA_MEASURED, +false);
}

static addDeclinationMeasured(builder:flatbuffers.Builder, DECLINATION_MEASURED:boolean) {
  builder.addFieldInt8(91, +DECLINATION_MEASURED, +false);
}

static endEOO(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishEOOBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EOO');
}

static finishSizePrefixedEOOBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EOO', true);
}

static createEOO(builder:flatbuffers.Builder, IDOffset:flatbuffers.Offset, CLASSIFICATIONOffset:flatbuffers.Offset, OB_TIMEOffset:flatbuffers.Offset, CORR_QUALITY:number, ID_ON_ORBITOffset:flatbuffers.Offset, SENSOR_IDOffset:flatbuffers.Offset, COLLECT_METHOD:CollectMethod, NORAD_CAT_ID:number, TASK_IDOffset:flatbuffers.Offset, TRANSACTION_IDOffset:flatbuffers.Offset, TRACK_IDOffset:flatbuffers.Offset, OB_POSITION:ObservationPosition, ORIG_OBJECT_IDOffset:flatbuffers.Offset, ORIG_SENSOR_IDOffset:flatbuffers.Offset, UCT:boolean, AZIMUTH:number, AZIMUTH_UNC:number, AZIMUTH_BIAS:number, AZIMUTH_RATE:number, ELEVATION:number, ELEVATION_UNC:number, ELEVATION_BIAS:number, ELEVATION_RATE:number, RANGE:number, RANGE_UNC:number, RANGE_BIAS:number, RANGE_RATE:number, RANGE_RATE_UNC:number, RA:number, RA_RATE:number, RA_UNC:number, RA_BIAS:number, DECLINATION:number, DECLINATION_RATE:number, DECLINATION_UNC:number, DECLINATION_BIAS:number, LOSX:number, LOSY:number, LOSZ:number, LOS_UNC:number, LOSXVEL:number, LOSYVEL:number, LOSZVEL:number, SENLAT:number, SENLON:number, SENALT:number, SENX:number, SENY:number, SENZ:number, FOV_COUNT:number, FOV_COUNT_UCTS:number, EXP_DURATION:number, ZEROPTD:number, NET_OBJ_SIG:number, NET_OBJ_SIG_UNC:number, MAG:number, MAG_UNC:number, MAG_NORM_RANGE:number, GEOLAT:number, GEOLON:number, GEOALT:number, GEORANGE:number, SKY_BKGRND:number, PRIMARY_EXTINCTION:number, PRIMARY_EXTINCTION_UNC:number, SOLAR_PHASE_ANGLE:number, SOLAR_EQ_PHASE_ANGLE:number, SOLAR_DEC_ANGLE:number, SHUTTER_DELAY:number, TIMING_BIAS:number, RAW_FILE_URIOffset:flatbuffers.Offset, INTENSITY:number, BG_INTENSITY:number, DESCRIPTOROffset:flatbuffers.Offset, SOURCEOffset:flatbuffers.Offset, ORIGINOffset:flatbuffers.Offset, DATA_MODE:DataMode, CREATED_ATOffset:flatbuffers.Offset, CREATED_BYOffset:flatbuffers.Offset, REFERENCE_FRAME:refFrame, SEN_REFERENCE_FRAME:refFrame, UMBRA:boolean, PENUMBRA:boolean, ORIG_NETWORKOffset:flatbuffers.Offset, SOURCE_DLOffset:flatbuffers.Offset, TYPE:DeviceType, AZIMUTH_MEASURED:boolean, ELEVATION_MEASURED:boolean, RANGE_MEASURED:boolean, RANGERATE_MEASURED:boolean, RA_MEASURED:boolean, DECLINATION_MEASURED:boolean):flatbuffers.Offset {
  EOO.startEOO(builder);
  EOO.addId(builder, IDOffset);
  EOO.addClassification(builder, CLASSIFICATIONOffset);
  EOO.addObTime(builder, OB_TIMEOffset);
  EOO.addCorrQuality(builder, CORR_QUALITY);
  EOO.addIdOnOrbit(builder, ID_ON_ORBITOffset);
  EOO.addSensorId(builder, SENSOR_IDOffset);
  EOO.addCollectMethod(builder, COLLECT_METHOD);
  EOO.addNoradCatId(builder, NORAD_CAT_ID);
  EOO.addTaskId(builder, TASK_IDOffset);
  EOO.addTransactionId(builder, TRANSACTION_IDOffset);
  EOO.addTrackId(builder, TRACK_IDOffset);
  EOO.addObPosition(builder, OB_POSITION);
  EOO.addOrigObjectId(builder, ORIG_OBJECT_IDOffset);
  EOO.addOrigSensorId(builder, ORIG_SENSOR_IDOffset);
  EOO.addUct(builder, UCT);
  EOO.addAzimuth(builder, AZIMUTH);
  EOO.addAzimuthUnc(builder, AZIMUTH_UNC);
  EOO.addAzimuthBias(builder, AZIMUTH_BIAS);
  EOO.addAzimuthRate(builder, AZIMUTH_RATE);
  EOO.addElevation(builder, ELEVATION);
  EOO.addElevationUnc(builder, ELEVATION_UNC);
  EOO.addElevationBias(builder, ELEVATION_BIAS);
  EOO.addElevationRate(builder, ELEVATION_RATE);
  EOO.addRange(builder, RANGE);
  EOO.addRangeUnc(builder, RANGE_UNC);
  EOO.addRangeBias(builder, RANGE_BIAS);
  EOO.addRangeRate(builder, RANGE_RATE);
  EOO.addRangeRateUnc(builder, RANGE_RATE_UNC);
  EOO.addRa(builder, RA);
  EOO.addRaRate(builder, RA_RATE);
  EOO.addRaUnc(builder, RA_UNC);
  EOO.addRaBias(builder, RA_BIAS);
  EOO.addDeclination(builder, DECLINATION);
  EOO.addDeclinationRate(builder, DECLINATION_RATE);
  EOO.addDeclinationUnc(builder, DECLINATION_UNC);
  EOO.addDeclinationBias(builder, DECLINATION_BIAS);
  EOO.addLosx(builder, LOSX);
  EOO.addLosy(builder, LOSY);
  EOO.addLosz(builder, LOSZ);
  EOO.addLosUnc(builder, LOS_UNC);
  EOO.addLosxvel(builder, LOSXVEL);
  EOO.addLosyvel(builder, LOSYVEL);
  EOO.addLoszvel(builder, LOSZVEL);
  EOO.addSenlat(builder, SENLAT);
  EOO.addSenlon(builder, SENLON);
  EOO.addSenalt(builder, SENALT);
  EOO.addSenx(builder, SENX);
  EOO.addSeny(builder, SENY);
  EOO.addSenz(builder, SENZ);
  EOO.addFovCount(builder, FOV_COUNT);
  EOO.addFovCountUcts(builder, FOV_COUNT_UCTS);
  EOO.addExpDuration(builder, EXP_DURATION);
  EOO.addZeroptd(builder, ZEROPTD);
  EOO.addNetObjSig(builder, NET_OBJ_SIG);
  EOO.addNetObjSigUnc(builder, NET_OBJ_SIG_UNC);
  EOO.addMag(builder, MAG);
  EOO.addMagUnc(builder, MAG_UNC);
  EOO.addMagNormRange(builder, MAG_NORM_RANGE);
  EOO.addGeolat(builder, GEOLAT);
  EOO.addGeolon(builder, GEOLON);
  EOO.addGeoalt(builder, GEOALT);
  EOO.addGeorange(builder, GEORANGE);
  EOO.addSkyBkgrnd(builder, SKY_BKGRND);
  EOO.addPrimaryExtinction(builder, PRIMARY_EXTINCTION);
  EOO.addPrimaryExtinctionUnc(builder, PRIMARY_EXTINCTION_UNC);
  EOO.addSolarPhaseAngle(builder, SOLAR_PHASE_ANGLE);
  EOO.addSolarEqPhaseAngle(builder, SOLAR_EQ_PHASE_ANGLE);
  EOO.addSolarDecAngle(builder, SOLAR_DEC_ANGLE);
  EOO.addShutterDelay(builder, SHUTTER_DELAY);
  EOO.addTimingBias(builder, TIMING_BIAS);
  EOO.addRawFileUri(builder, RAW_FILE_URIOffset);
  EOO.addIntensity(builder, INTENSITY);
  EOO.addBgIntensity(builder, BG_INTENSITY);
  EOO.addDescriptor(builder, DESCRIPTOROffset);
  EOO.addSource(builder, SOURCEOffset);
  EOO.addOrigin(builder, ORIGINOffset);
  EOO.addDataMode(builder, DATA_MODE);
  EOO.addCreatedAt(builder, CREATED_ATOffset);
  EOO.addCreatedBy(builder, CREATED_BYOffset);
  EOO.addReferenceFrame(builder, REFERENCE_FRAME);
  EOO.addSenReferenceFrame(builder, SEN_REFERENCE_FRAME);
  EOO.addUmbra(builder, UMBRA);
  EOO.addPenumbra(builder, PENUMBRA);
  EOO.addOrigNetwork(builder, ORIG_NETWORKOffset);
  EOO.addSourceDl(builder, SOURCE_DLOffset);
  EOO.addType(builder, TYPE);
  EOO.addAzimuthMeasured(builder, AZIMUTH_MEASURED);
  EOO.addElevationMeasured(builder, ELEVATION_MEASURED);
  EOO.addRangeMeasured(builder, RANGE_MEASURED);
  EOO.addRangerateMeasured(builder, RANGERATE_MEASURED);
  EOO.addRaMeasured(builder, RA_MEASURED);
  EOO.addDeclinationMeasured(builder, DECLINATION_MEASURED);
  return EOO.endEOO(builder);
}

unpack(): EOOT {
  return new EOOT(
    this.ID(),
    this.CLASSIFICATION(),
    this.OB_TIME(),
    this.CORR_QUALITY(),
    this.ID_ON_ORBIT(),
    this.SENSOR_ID(),
    this.COLLECT_METHOD(),
    this.NORAD_CAT_ID(),
    this.TASK_ID(),
    this.TRANSACTION_ID(),
    this.TRACK_ID(),
    this.OB_POSITION(),
    this.ORIG_OBJECT_ID(),
    this.ORIG_SENSOR_ID(),
    this.UCT(),
    this.AZIMUTH(),
    this.AZIMUTH_UNC(),
    this.AZIMUTH_BIAS(),
    this.AZIMUTH_RATE(),
    this.ELEVATION(),
    this.ELEVATION_UNC(),
    this.ELEVATION_BIAS(),
    this.ELEVATION_RATE(),
    this.RANGE(),
    this.RANGE_UNC(),
    this.RANGE_BIAS(),
    this.RANGE_RATE(),
    this.RANGE_RATE_UNC(),
    this.RA(),
    this.RA_RATE(),
    this.RA_UNC(),
    this.RA_BIAS(),
    this.DECLINATION(),
    this.DECLINATION_RATE(),
    this.DECLINATION_UNC(),
    this.DECLINATION_BIAS(),
    this.LOSX(),
    this.LOSY(),
    this.LOSZ(),
    this.LOS_UNC(),
    this.LOSXVEL(),
    this.LOSYVEL(),
    this.LOSZVEL(),
    this.SENLAT(),
    this.SENLON(),
    this.SENALT(),
    this.SENX(),
    this.SENY(),
    this.SENZ(),
    this.FOV_COUNT(),
    this.FOV_COUNT_UCTS(),
    this.EXP_DURATION(),
    this.ZEROPTD(),
    this.NET_OBJ_SIG(),
    this.NET_OBJ_SIG_UNC(),
    this.MAG(),
    this.MAG_UNC(),
    this.MAG_NORM_RANGE(),
    this.GEOLAT(),
    this.GEOLON(),
    this.GEOALT(),
    this.GEORANGE(),
    this.SKY_BKGRND(),
    this.PRIMARY_EXTINCTION(),
    this.PRIMARY_EXTINCTION_UNC(),
    this.SOLAR_PHASE_ANGLE(),
    this.SOLAR_EQ_PHASE_ANGLE(),
    this.SOLAR_DEC_ANGLE(),
    this.SHUTTER_DELAY(),
    this.TIMING_BIAS(),
    this.RAW_FILE_URI(),
    this.INTENSITY(),
    this.BG_INTENSITY(),
    this.DESCRIPTOR(),
    this.SOURCE(),
    this.ORIGIN(),
    this.DATA_MODE(),
    this.CREATED_AT(),
    this.CREATED_BY(),
    this.REFERENCE_FRAME(),
    this.SEN_REFERENCE_FRAME(),
    this.UMBRA(),
    this.PENUMBRA(),
    this.ORIG_NETWORK(),
    this.SOURCE_DL(),
    this.TYPE(),
    this.AZIMUTH_MEASURED(),
    this.ELEVATION_MEASURED(),
    this.RANGE_MEASURED(),
    this.RANGERATE_MEASURED(),
    this.RA_MEASURED(),
    this.DECLINATION_MEASURED()
  );
}


unpackTo(_o: EOOT): void {
  _o.ID = this.ID();
  _o.CLASSIFICATION = this.CLASSIFICATION();
  _o.OB_TIME = this.OB_TIME();
  _o.CORR_QUALITY = this.CORR_QUALITY();
  _o.ID_ON_ORBIT = this.ID_ON_ORBIT();
  _o.SENSOR_ID = this.SENSOR_ID();
  _o.COLLECT_METHOD = this.COLLECT_METHOD();
  _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
  _o.TASK_ID = this.TASK_ID();
  _o.TRANSACTION_ID = this.TRANSACTION_ID();
  _o.TRACK_ID = this.TRACK_ID();
  _o.OB_POSITION = this.OB_POSITION();
  _o.ORIG_OBJECT_ID = this.ORIG_OBJECT_ID();
  _o.ORIG_SENSOR_ID = this.ORIG_SENSOR_ID();
  _o.UCT = this.UCT();
  _o.AZIMUTH = this.AZIMUTH();
  _o.AZIMUTH_UNC = this.AZIMUTH_UNC();
  _o.AZIMUTH_BIAS = this.AZIMUTH_BIAS();
  _o.AZIMUTH_RATE = this.AZIMUTH_RATE();
  _o.ELEVATION = this.ELEVATION();
  _o.ELEVATION_UNC = this.ELEVATION_UNC();
  _o.ELEVATION_BIAS = this.ELEVATION_BIAS();
  _o.ELEVATION_RATE = this.ELEVATION_RATE();
  _o.RANGE = this.RANGE();
  _o.RANGE_UNC = this.RANGE_UNC();
  _o.RANGE_BIAS = this.RANGE_BIAS();
  _o.RANGE_RATE = this.RANGE_RATE();
  _o.RANGE_RATE_UNC = this.RANGE_RATE_UNC();
  _o.RA = this.RA();
  _o.RA_RATE = this.RA_RATE();
  _o.RA_UNC = this.RA_UNC();
  _o.RA_BIAS = this.RA_BIAS();
  _o.DECLINATION = this.DECLINATION();
  _o.DECLINATION_RATE = this.DECLINATION_RATE();
  _o.DECLINATION_UNC = this.DECLINATION_UNC();
  _o.DECLINATION_BIAS = this.DECLINATION_BIAS();
  _o.LOSX = this.LOSX();
  _o.LOSY = this.LOSY();
  _o.LOSZ = this.LOSZ();
  _o.LOS_UNC = this.LOS_UNC();
  _o.LOSXVEL = this.LOSXVEL();
  _o.LOSYVEL = this.LOSYVEL();
  _o.LOSZVEL = this.LOSZVEL();
  _o.SENLAT = this.SENLAT();
  _o.SENLON = this.SENLON();
  _o.SENALT = this.SENALT();
  _o.SENX = this.SENX();
  _o.SENY = this.SENY();
  _o.SENZ = this.SENZ();
  _o.FOV_COUNT = this.FOV_COUNT();
  _o.FOV_COUNT_UCTS = this.FOV_COUNT_UCTS();
  _o.EXP_DURATION = this.EXP_DURATION();
  _o.ZEROPTD = this.ZEROPTD();
  _o.NET_OBJ_SIG = this.NET_OBJ_SIG();
  _o.NET_OBJ_SIG_UNC = this.NET_OBJ_SIG_UNC();
  _o.MAG = this.MAG();
  _o.MAG_UNC = this.MAG_UNC();
  _o.MAG_NORM_RANGE = this.MAG_NORM_RANGE();
  _o.GEOLAT = this.GEOLAT();
  _o.GEOLON = this.GEOLON();
  _o.GEOALT = this.GEOALT();
  _o.GEORANGE = this.GEORANGE();
  _o.SKY_BKGRND = this.SKY_BKGRND();
  _o.PRIMARY_EXTINCTION = this.PRIMARY_EXTINCTION();
  _o.PRIMARY_EXTINCTION_UNC = this.PRIMARY_EXTINCTION_UNC();
  _o.SOLAR_PHASE_ANGLE = this.SOLAR_PHASE_ANGLE();
  _o.SOLAR_EQ_PHASE_ANGLE = this.SOLAR_EQ_PHASE_ANGLE();
  _o.SOLAR_DEC_ANGLE = this.SOLAR_DEC_ANGLE();
  _o.SHUTTER_DELAY = this.SHUTTER_DELAY();
  _o.TIMING_BIAS = this.TIMING_BIAS();
  _o.RAW_FILE_URI = this.RAW_FILE_URI();
  _o.INTENSITY = this.INTENSITY();
  _o.BG_INTENSITY = this.BG_INTENSITY();
  _o.DESCRIPTOR = this.DESCRIPTOR();
  _o.SOURCE = this.SOURCE();
  _o.ORIGIN = this.ORIGIN();
  _o.DATA_MODE = this.DATA_MODE();
  _o.CREATED_AT = this.CREATED_AT();
  _o.CREATED_BY = this.CREATED_BY();
  _o.REFERENCE_FRAME = this.REFERENCE_FRAME();
  _o.SEN_REFERENCE_FRAME = this.SEN_REFERENCE_FRAME();
  _o.UMBRA = this.UMBRA();
  _o.PENUMBRA = this.PENUMBRA();
  _o.ORIG_NETWORK = this.ORIG_NETWORK();
  _o.SOURCE_DL = this.SOURCE_DL();
  _o.TYPE = this.TYPE();
  _o.AZIMUTH_MEASURED = this.AZIMUTH_MEASURED();
  _o.ELEVATION_MEASURED = this.ELEVATION_MEASURED();
  _o.RANGE_MEASURED = this.RANGE_MEASURED();
  _o.RANGERATE_MEASURED = this.RANGERATE_MEASURED();
  _o.RA_MEASURED = this.RA_MEASURED();
  _o.DECLINATION_MEASURED = this.DECLINATION_MEASURED();
}
}

export class EOOT implements flatbuffers.IGeneratedObject {
constructor(
  public ID: string|Uint8Array|null = null,
  public CLASSIFICATION: string|Uint8Array|null = null,
  public OB_TIME: string|Uint8Array|null = null,
  public CORR_QUALITY: number = 0.0,
  public ID_ON_ORBIT: string|Uint8Array|null = null,
  public SENSOR_ID: string|Uint8Array|null = null,
  public COLLECT_METHOD: CollectMethod = CollectMethod.SIDEREAL,
  public NORAD_CAT_ID: number = 0,
  public TASK_ID: string|Uint8Array|null = null,
  public TRANSACTION_ID: string|Uint8Array|null = null,
  public TRACK_ID: string|Uint8Array|null = null,
  public OB_POSITION: ObservationPosition = ObservationPosition.FENCE,
  public ORIG_OBJECT_ID: string|Uint8Array|null = null,
  public ORIG_SENSOR_ID: string|Uint8Array|null = null,
  public UCT: boolean = false,
  public AZIMUTH: number = 0.0,
  public AZIMUTH_UNC: number = 0.0,
  public AZIMUTH_BIAS: number = 0.0,
  public AZIMUTH_RATE: number = 0.0,
  public ELEVATION: number = 0.0,
  public ELEVATION_UNC: number = 0.0,
  public ELEVATION_BIAS: number = 0.0,
  public ELEVATION_RATE: number = 0.0,
  public RANGE: number = 0.0,
  public RANGE_UNC: number = 0.0,
  public RANGE_BIAS: number = 0.0,
  public RANGE_RATE: number = 0.0,
  public RANGE_RATE_UNC: number = 0.0,
  public RA: number = 0.0,
  public RA_RATE: number = 0.0,
  public RA_UNC: number = 0.0,
  public RA_BIAS: number = 0.0,
  public DECLINATION: number = 0.0,
  public DECLINATION_RATE: number = 0.0,
  public DECLINATION_UNC: number = 0.0,
  public DECLINATION_BIAS: number = 0.0,
  public LOSX: number = 0.0,
  public LOSY: number = 0.0,
  public LOSZ: number = 0.0,
  public LOS_UNC: number = 0.0,
  public LOSXVEL: number = 0.0,
  public LOSYVEL: number = 0.0,
  public LOSZVEL: number = 0.0,
  public SENLAT: number = 0.0,
  public SENLON: number = 0.0,
  public SENALT: number = 0.0,
  public SENX: number = 0.0,
  public SENY: number = 0.0,
  public SENZ: number = 0.0,
  public FOV_COUNT: number = 0,
  public FOV_COUNT_UCTS: number = 0,
  public EXP_DURATION: number = 0.0,
  public ZEROPTD: number = 0.0,
  public NET_OBJ_SIG: number = 0.0,
  public NET_OBJ_SIG_UNC: number = 0.0,
  public MAG: number = 0.0,
  public MAG_UNC: number = 0.0,
  public MAG_NORM_RANGE: number = 0.0,
  public GEOLAT: number = 0.0,
  public GEOLON: number = 0.0,
  public GEOALT: number = 0.0,
  public GEORANGE: number = 0.0,
  public SKY_BKGRND: number = 0.0,
  public PRIMARY_EXTINCTION: number = 0.0,
  public PRIMARY_EXTINCTION_UNC: number = 0.0,
  public SOLAR_PHASE_ANGLE: number = 0.0,
  public SOLAR_EQ_PHASE_ANGLE: number = 0.0,
  public SOLAR_DEC_ANGLE: number = 0.0,
  public SHUTTER_DELAY: number = 0.0,
  public TIMING_BIAS: number = 0.0,
  public RAW_FILE_URI: string|Uint8Array|null = null,
  public INTENSITY: number = 0.0,
  public BG_INTENSITY: number = 0.0,
  public DESCRIPTOR: string|Uint8Array|null = null,
  public SOURCE: string|Uint8Array|null = null,
  public ORIGIN: string|Uint8Array|null = null,
  public DATA_MODE: DataMode = DataMode.EXERCISE,
  public CREATED_AT: string|Uint8Array|null = null,
  public CREATED_BY: string|Uint8Array|null = null,
  public REFERENCE_FRAME: refFrame = refFrame.ECEF,
  public SEN_REFERENCE_FRAME: refFrame = refFrame.ECEF,
  public UMBRA: boolean = false,
  public PENUMBRA: boolean = false,
  public ORIG_NETWORK: string|Uint8Array|null = null,
  public SOURCE_DL: string|Uint8Array|null = null,
  public TYPE: DeviceType = DeviceType.UNKNOWN,
  public AZIMUTH_MEASURED: boolean = false,
  public ELEVATION_MEASURED: boolean = false,
  public RANGE_MEASURED: boolean = false,
  public RANGERATE_MEASURED: boolean = false,
  public RA_MEASURED: boolean = false,
  public DECLINATION_MEASURED: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const ID = (this.ID !== null ? builder.createString(this.ID!) : 0);
  const CLASSIFICATION = (this.CLASSIFICATION !== null ? builder.createString(this.CLASSIFICATION!) : 0);
  const OB_TIME = (this.OB_TIME !== null ? builder.createString(this.OB_TIME!) : 0);
  const ID_ON_ORBIT = (this.ID_ON_ORBIT !== null ? builder.createString(this.ID_ON_ORBIT!) : 0);
  const SENSOR_ID = (this.SENSOR_ID !== null ? builder.createString(this.SENSOR_ID!) : 0);
  const TASK_ID = (this.TASK_ID !== null ? builder.createString(this.TASK_ID!) : 0);
  const TRANSACTION_ID = (this.TRANSACTION_ID !== null ? builder.createString(this.TRANSACTION_ID!) : 0);
  const TRACK_ID = (this.TRACK_ID !== null ? builder.createString(this.TRACK_ID!) : 0);
  const ORIG_OBJECT_ID = (this.ORIG_OBJECT_ID !== null ? builder.createString(this.ORIG_OBJECT_ID!) : 0);
  const ORIG_SENSOR_ID = (this.ORIG_SENSOR_ID !== null ? builder.createString(this.ORIG_SENSOR_ID!) : 0);
  const RAW_FILE_URI = (this.RAW_FILE_URI !== null ? builder.createString(this.RAW_FILE_URI!) : 0);
  const DESCRIPTOR = (this.DESCRIPTOR !== null ? builder.createString(this.DESCRIPTOR!) : 0);
  const SOURCE = (this.SOURCE !== null ? builder.createString(this.SOURCE!) : 0);
  const ORIGIN = (this.ORIGIN !== null ? builder.createString(this.ORIGIN!) : 0);
  const CREATED_AT = (this.CREATED_AT !== null ? builder.createString(this.CREATED_AT!) : 0);
  const CREATED_BY = (this.CREATED_BY !== null ? builder.createString(this.CREATED_BY!) : 0);
  const ORIG_NETWORK = (this.ORIG_NETWORK !== null ? builder.createString(this.ORIG_NETWORK!) : 0);
  const SOURCE_DL = (this.SOURCE_DL !== null ? builder.createString(this.SOURCE_DL!) : 0);

  return EOO.createEOO(builder,
    ID,
    CLASSIFICATION,
    OB_TIME,
    this.CORR_QUALITY,
    ID_ON_ORBIT,
    SENSOR_ID,
    this.COLLECT_METHOD,
    this.NORAD_CAT_ID,
    TASK_ID,
    TRANSACTION_ID,
    TRACK_ID,
    this.OB_POSITION,
    ORIG_OBJECT_ID,
    ORIG_SENSOR_ID,
    this.UCT,
    this.AZIMUTH,
    this.AZIMUTH_UNC,
    this.AZIMUTH_BIAS,
    this.AZIMUTH_RATE,
    this.ELEVATION,
    this.ELEVATION_UNC,
    this.ELEVATION_BIAS,
    this.ELEVATION_RATE,
    this.RANGE,
    this.RANGE_UNC,
    this.RANGE_BIAS,
    this.RANGE_RATE,
    this.RANGE_RATE_UNC,
    this.RA,
    this.RA_RATE,
    this.RA_UNC,
    this.RA_BIAS,
    this.DECLINATION,
    this.DECLINATION_RATE,
    this.DECLINATION_UNC,
    this.DECLINATION_BIAS,
    this.LOSX,
    this.LOSY,
    this.LOSZ,
    this.LOS_UNC,
    this.LOSXVEL,
    this.LOSYVEL,
    this.LOSZVEL,
    this.SENLAT,
    this.SENLON,
    this.SENALT,
    this.SENX,
    this.SENY,
    this.SENZ,
    this.FOV_COUNT,
    this.FOV_COUNT_UCTS,
    this.EXP_DURATION,
    this.ZEROPTD,
    this.NET_OBJ_SIG,
    this.NET_OBJ_SIG_UNC,
    this.MAG,
    this.MAG_UNC,
    this.MAG_NORM_RANGE,
    this.GEOLAT,
    this.GEOLON,
    this.GEOALT,
    this.GEORANGE,
    this.SKY_BKGRND,
    this.PRIMARY_EXTINCTION,
    this.PRIMARY_EXTINCTION_UNC,
    this.SOLAR_PHASE_ANGLE,
    this.SOLAR_EQ_PHASE_ANGLE,
    this.SOLAR_DEC_ANGLE,
    this.SHUTTER_DELAY,
    this.TIMING_BIAS,
    RAW_FILE_URI,
    this.INTENSITY,
    this.BG_INTENSITY,
    DESCRIPTOR,
    SOURCE,
    ORIGIN,
    this.DATA_MODE,
    CREATED_AT,
    CREATED_BY,
    this.REFERENCE_FRAME,
    this.SEN_REFERENCE_FRAME,
    this.UMBRA,
    this.PENUMBRA,
    ORIG_NETWORK,
    SOURCE_DL,
    this.TYPE,
    this.AZIMUTH_MEASURED,
    this.ELEVATION_MEASURED,
    this.RANGE_MEASURED,
    this.RANGERATE_MEASURED,
    this.RA_MEASURED,
    this.DECLINATION_MEASURED
  );
}
}
