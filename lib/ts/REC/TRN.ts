// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { TerrainDataSource } from './TerrainDataSource.js';
import { TerrainInterpolation } from './TerrainInterpolation.js';


/**
 * Terrain Models
 */
export class TRN implements flatbuffers.IUnpackableObject<TRNT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):TRN {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsTRN(bb:flatbuffers.ByteBuffer, obj?:TRN):TRN {
  return (obj || new TRN()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsTRN(bb:flatbuffers.ByteBuffer, obj?:TRN):TRN {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new TRN()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$TRN');
}

SOURCES(index: number):TerrainDataSource|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

sourcesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

sourcesArray():Int8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

INTERPOLATION():TerrainInterpolation {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : TerrainInterpolation.BILINEAR;
}

CACHE_ENABLED():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : true;
}

MAX_CACHE_TILES():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 100;
}

VERTICAL_EXAGGERATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 1.0;
}

static startTRN(builder:flatbuffers.Builder) {
  builder.startObject(5);
}

static addSources(builder:flatbuffers.Builder, SOURCESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, SOURCESOffset, 0);
}

static createSourcesVector(builder:flatbuffers.Builder, data:TerrainDataSource[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startSourcesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addInterpolation(builder:flatbuffers.Builder, INTERPOLATION:TerrainInterpolation) {
  builder.addFieldInt8(1, INTERPOLATION, TerrainInterpolation.BILINEAR);
}

static addCacheEnabled(builder:flatbuffers.Builder, CACHE_ENABLED:boolean) {
  builder.addFieldInt8(2, +CACHE_ENABLED, +true);
}

static addMaxCacheTiles(builder:flatbuffers.Builder, MAX_CACHE_TILES:number) {
  builder.addFieldInt16(3, MAX_CACHE_TILES, 100);
}

static addVerticalExaggeration(builder:flatbuffers.Builder, VERTICAL_EXAGGERATION:number) {
  builder.addFieldFloat64(4, VERTICAL_EXAGGERATION, 1.0);
}

static endTRN(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishTRNBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$TRN');
}

static finishSizePrefixedTRNBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$TRN', true);
}

static createTRN(builder:flatbuffers.Builder, SOURCESOffset:flatbuffers.Offset, INTERPOLATION:TerrainInterpolation, CACHE_ENABLED:boolean, MAX_CACHE_TILES:number, VERTICAL_EXAGGERATION:number):flatbuffers.Offset {
  TRN.startTRN(builder);
  TRN.addSources(builder, SOURCESOffset);
  TRN.addInterpolation(builder, INTERPOLATION);
  TRN.addCacheEnabled(builder, CACHE_ENABLED);
  TRN.addMaxCacheTiles(builder, MAX_CACHE_TILES);
  TRN.addVerticalExaggeration(builder, VERTICAL_EXAGGERATION);
  return TRN.endTRN(builder);
}

unpack(): TRNT {
  return new TRNT(
    this.bb!.createScalarList<TerrainDataSource>(this.SOURCES.bind(this), this.sourcesLength()),
    this.INTERPOLATION(),
    this.CACHE_ENABLED(),
    this.MAX_CACHE_TILES(),
    this.VERTICAL_EXAGGERATION()
  );
}


unpackTo(_o: TRNT): void {
  _o.SOURCES = this.bb!.createScalarList<TerrainDataSource>(this.SOURCES.bind(this), this.sourcesLength());
  _o.INTERPOLATION = this.INTERPOLATION();
  _o.CACHE_ENABLED = this.CACHE_ENABLED();
  _o.MAX_CACHE_TILES = this.MAX_CACHE_TILES();
  _o.VERTICAL_EXAGGERATION = this.VERTICAL_EXAGGERATION();
}
}

export class TRNT implements flatbuffers.IGeneratedObject {
constructor(
  public SOURCES: (TerrainDataSource)[] = [],
  public INTERPOLATION: TerrainInterpolation = TerrainInterpolation.BILINEAR,
  public CACHE_ENABLED: boolean = true,
  public MAX_CACHE_TILES: number = 100,
  public VERTICAL_EXAGGERATION: number = 1.0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const SOURCES = TRN.createSourcesVector(builder, this.SOURCES);

  return TRN.createTRN(builder,
    SOURCES,
    this.INTERPOLATION,
    this.CACHE_ENABLED,
    this.MAX_CACHE_TILES,
    this.VERTICAL_EXAGGERATION
  );
}
}
