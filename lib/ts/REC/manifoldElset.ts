// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Manifold Element Set
 */
export class manifoldElset implements flatbuffers.IUnpackableObject<manifoldElsetT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):manifoldElset {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsmanifoldElset(bb:flatbuffers.ByteBuffer, obj?:manifoldElset):manifoldElset {
  return (obj || new manifoldElset()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsmanifoldElset(bb:flatbuffers.ByteBuffer, obj?:manifoldElset):manifoldElset {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new manifoldElset()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Epoch of element set (ISO 8601)
 */
EPOCH():string|null
EPOCH(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
EPOCH(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Semi-major axis in km
 */
SEMI_MAJOR_AXIS():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Eccentricity
 */
ECCENTRICITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Inclination in degrees
 */
INCLINATION():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Right ascension of ascending node in degrees
 */
RA_OF_ASC_NODE():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Argument of pericenter in degrees
 */
ARG_OF_PERICENTER():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Mean anomaly in degrees
 */
MEAN_ANOMALY():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Applied delta-V in m/s
 */
DELTA_V():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Applied delta-T in seconds
 */
DELTA_T():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Delta-V direction X (unit vector)
 */
DV_X():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Delta-V direction Y (unit vector)
 */
DV_Y():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Delta-V direction Z (unit vector)
 */
DV_Z():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Probability weight (0.0-1.0)
 */
WEIGHT():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Apogee altitude in km
 */
APOGEE():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Perigee altitude in km
 */
PERIGEE():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Period in minutes
 */
PERIOD():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

static startmanifoldElset(builder:flatbuffers.Builder) {
  builder.startObject(16);
}

static addEpoch(builder:flatbuffers.Builder, EPOCHOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, EPOCHOffset, 0);
}

static addSemiMajorAxis(builder:flatbuffers.Builder, SEMI_MAJOR_AXIS:number) {
  builder.addFieldFloat64(1, SEMI_MAJOR_AXIS, 0.0);
}

static addEccentricity(builder:flatbuffers.Builder, ECCENTRICITY:number) {
  builder.addFieldFloat64(2, ECCENTRICITY, 0.0);
}

static addInclination(builder:flatbuffers.Builder, INCLINATION:number) {
  builder.addFieldFloat64(3, INCLINATION, 0.0);
}

static addRaOfAscNode(builder:flatbuffers.Builder, RA_OF_ASC_NODE:number) {
  builder.addFieldFloat64(4, RA_OF_ASC_NODE, 0.0);
}

static addArgOfPericenter(builder:flatbuffers.Builder, ARG_OF_PERICENTER:number) {
  builder.addFieldFloat64(5, ARG_OF_PERICENTER, 0.0);
}

static addMeanAnomaly(builder:flatbuffers.Builder, MEAN_ANOMALY:number) {
  builder.addFieldFloat64(6, MEAN_ANOMALY, 0.0);
}

static addDeltaV(builder:flatbuffers.Builder, DELTA_V:number) {
  builder.addFieldFloat64(7, DELTA_V, 0.0);
}

static addDeltaT(builder:flatbuffers.Builder, DELTA_T:number) {
  builder.addFieldFloat64(8, DELTA_T, 0.0);
}

static addDvX(builder:flatbuffers.Builder, DV_X:number) {
  builder.addFieldFloat64(9, DV_X, 0.0);
}

static addDvY(builder:flatbuffers.Builder, DV_Y:number) {
  builder.addFieldFloat64(10, DV_Y, 0.0);
}

static addDvZ(builder:flatbuffers.Builder, DV_Z:number) {
  builder.addFieldFloat64(11, DV_Z, 0.0);
}

static addWeight(builder:flatbuffers.Builder, WEIGHT:number) {
  builder.addFieldFloat64(12, WEIGHT, 0.0);
}

static addApogee(builder:flatbuffers.Builder, APOGEE:number) {
  builder.addFieldFloat64(13, APOGEE, 0.0);
}

static addPerigee(builder:flatbuffers.Builder, PERIGEE:number) {
  builder.addFieldFloat64(14, PERIGEE, 0.0);
}

static addPeriod(builder:flatbuffers.Builder, PERIOD:number) {
  builder.addFieldFloat64(15, PERIOD, 0.0);
}

static endmanifoldElset(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createmanifoldElset(builder:flatbuffers.Builder, EPOCHOffset:flatbuffers.Offset, SEMI_MAJOR_AXIS:number, ECCENTRICITY:number, INCLINATION:number, RA_OF_ASC_NODE:number, ARG_OF_PERICENTER:number, MEAN_ANOMALY:number, DELTA_V:number, DELTA_T:number, DV_X:number, DV_Y:number, DV_Z:number, WEIGHT:number, APOGEE:number, PERIGEE:number, PERIOD:number):flatbuffers.Offset {
  manifoldElset.startmanifoldElset(builder);
  manifoldElset.addEpoch(builder, EPOCHOffset);
  manifoldElset.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
  manifoldElset.addEccentricity(builder, ECCENTRICITY);
  manifoldElset.addInclination(builder, INCLINATION);
  manifoldElset.addRaOfAscNode(builder, RA_OF_ASC_NODE);
  manifoldElset.addArgOfPericenter(builder, ARG_OF_PERICENTER);
  manifoldElset.addMeanAnomaly(builder, MEAN_ANOMALY);
  manifoldElset.addDeltaV(builder, DELTA_V);
  manifoldElset.addDeltaT(builder, DELTA_T);
  manifoldElset.addDvX(builder, DV_X);
  manifoldElset.addDvY(builder, DV_Y);
  manifoldElset.addDvZ(builder, DV_Z);
  manifoldElset.addWeight(builder, WEIGHT);
  manifoldElset.addApogee(builder, APOGEE);
  manifoldElset.addPerigee(builder, PERIGEE);
  manifoldElset.addPeriod(builder, PERIOD);
  return manifoldElset.endmanifoldElset(builder);
}

unpack(): manifoldElsetT {
  return new manifoldElsetT(
    this.EPOCH(),
    this.SEMI_MAJOR_AXIS(),
    this.ECCENTRICITY(),
    this.INCLINATION(),
    this.RA_OF_ASC_NODE(),
    this.ARG_OF_PERICENTER(),
    this.MEAN_ANOMALY(),
    this.DELTA_V(),
    this.DELTA_T(),
    this.DV_X(),
    this.DV_Y(),
    this.DV_Z(),
    this.WEIGHT(),
    this.APOGEE(),
    this.PERIGEE(),
    this.PERIOD()
  );
}


unpackTo(_o: manifoldElsetT): void {
  _o.EPOCH = this.EPOCH();
  _o.SEMI_MAJOR_AXIS = this.SEMI_MAJOR_AXIS();
  _o.ECCENTRICITY = this.ECCENTRICITY();
  _o.INCLINATION = this.INCLINATION();
  _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
  _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
  _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
  _o.DELTA_V = this.DELTA_V();
  _o.DELTA_T = this.DELTA_T();
  _o.DV_X = this.DV_X();
  _o.DV_Y = this.DV_Y();
  _o.DV_Z = this.DV_Z();
  _o.WEIGHT = this.WEIGHT();
  _o.APOGEE = this.APOGEE();
  _o.PERIGEE = this.PERIGEE();
  _o.PERIOD = this.PERIOD();
}
}

export class manifoldElsetT implements flatbuffers.IGeneratedObject {
constructor(
  public EPOCH: string|Uint8Array|null = null,
  public SEMI_MAJOR_AXIS: number = 0.0,
  public ECCENTRICITY: number = 0.0,
  public INCLINATION: number = 0.0,
  public RA_OF_ASC_NODE: number = 0.0,
  public ARG_OF_PERICENTER: number = 0.0,
  public MEAN_ANOMALY: number = 0.0,
  public DELTA_V: number = 0.0,
  public DELTA_T: number = 0.0,
  public DV_X: number = 0.0,
  public DV_Y: number = 0.0,
  public DV_Z: number = 0.0,
  public WEIGHT: number = 0.0,
  public APOGEE: number = 0.0,
  public PERIGEE: number = 0.0,
  public PERIOD: number = 0.0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const EPOCH = (this.EPOCH !== null ? builder.createString(this.EPOCH!) : 0);

  return manifoldElset.createmanifoldElset(builder,
    EPOCH,
    this.SEMI_MAJOR_AXIS,
    this.ECCENTRICITY,
    this.INCLINATION,
    this.RA_OF_ASC_NODE,
    this.ARG_OF_PERICENTER,
    this.MEAN_ANOMALY,
    this.DELTA_V,
    this.DELTA_T,
    this.DV_X,
    this.DV_Y,
    this.DV_Z,
    this.WEIGHT,
    this.APOGEE,
    this.PERIGEE,
    this.PERIOD
  );
}
}
