// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Armor and Protection
 */
export class ARM implements flatbuffers.IUnpackableObject<ARMT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ARM {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsARM(bb:flatbuffers.ByteBuffer, obj?:ARM):ARM {
  return (obj || new ARM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsARM(bb:flatbuffers.ByteBuffer, obj?:ARM):ARM {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ARM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$ARM');
}

THICKNESS():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

ANGLE():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

MATERIAL():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

HARDNESS():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

QUALITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

ERA_TYPE():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

ERA_EFFECTIVENESS():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

ERA_VS_KE():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

RHA_EQUIVALENT():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

NORMAL_X():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

NORMAL_Y():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

NORMAL_Z():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

RESERVED(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

reservedLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

reservedArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startARM(builder:flatbuffers.Builder) {
  builder.startObject(13);
}

static addThickness(builder:flatbuffers.Builder, THICKNESS:number) {
  builder.addFieldFloat64(0, THICKNESS, 0.0);
}

static addAngle(builder:flatbuffers.Builder, ANGLE:number) {
  builder.addFieldFloat64(1, ANGLE, 0.0);
}

static addMaterial(builder:flatbuffers.Builder, MATERIAL:number) {
  builder.addFieldInt8(2, MATERIAL, 0);
}

static addHardness(builder:flatbuffers.Builder, HARDNESS:number) {
  builder.addFieldInt8(3, HARDNESS, 0);
}

static addQuality(builder:flatbuffers.Builder, QUALITY:number) {
  builder.addFieldInt8(4, QUALITY, 0);
}

static addEraType(builder:flatbuffers.Builder, ERA_TYPE:number) {
  builder.addFieldInt8(5, ERA_TYPE, 0);
}

static addEraEffectiveness(builder:flatbuffers.Builder, ERA_EFFECTIVENESS:number) {
  builder.addFieldFloat32(6, ERA_EFFECTIVENESS, 0.0);
}

static addEraVsKe(builder:flatbuffers.Builder, ERA_VS_KE:number) {
  builder.addFieldFloat32(7, ERA_VS_KE, 0.0);
}

static addRhaEquivalent(builder:flatbuffers.Builder, RHA_EQUIVALENT:number) {
  builder.addFieldFloat32(8, RHA_EQUIVALENT, 0.0);
}

static addNormalX(builder:flatbuffers.Builder, NORMAL_X:number) {
  builder.addFieldFloat64(9, NORMAL_X, 0.0);
}

static addNormalY(builder:flatbuffers.Builder, NORMAL_Y:number) {
  builder.addFieldFloat64(10, NORMAL_Y, 0.0);
}

static addNormalZ(builder:flatbuffers.Builder, NORMAL_Z:number) {
  builder.addFieldFloat64(11, NORMAL_Z, 0.0);
}

static addReserved(builder:flatbuffers.Builder, RESERVEDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(12, RESERVEDOffset, 0);
}

static createReservedVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startReservedVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static endARM(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishARMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$ARM');
}

static finishSizePrefixedARMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$ARM', true);
}

static createARM(builder:flatbuffers.Builder, THICKNESS:number, ANGLE:number, MATERIAL:number, HARDNESS:number, QUALITY:number, ERA_TYPE:number, ERA_EFFECTIVENESS:number, ERA_VS_KE:number, RHA_EQUIVALENT:number, NORMAL_X:number, NORMAL_Y:number, NORMAL_Z:number, RESERVEDOffset:flatbuffers.Offset):flatbuffers.Offset {
  ARM.startARM(builder);
  ARM.addThickness(builder, THICKNESS);
  ARM.addAngle(builder, ANGLE);
  ARM.addMaterial(builder, MATERIAL);
  ARM.addHardness(builder, HARDNESS);
  ARM.addQuality(builder, QUALITY);
  ARM.addEraType(builder, ERA_TYPE);
  ARM.addEraEffectiveness(builder, ERA_EFFECTIVENESS);
  ARM.addEraVsKe(builder, ERA_VS_KE);
  ARM.addRhaEquivalent(builder, RHA_EQUIVALENT);
  ARM.addNormalX(builder, NORMAL_X);
  ARM.addNormalY(builder, NORMAL_Y);
  ARM.addNormalZ(builder, NORMAL_Z);
  ARM.addReserved(builder, RESERVEDOffset);
  return ARM.endARM(builder);
}

unpack(): ARMT {
  return new ARMT(
    this.THICKNESS(),
    this.ANGLE(),
    this.MATERIAL(),
    this.HARDNESS(),
    this.QUALITY(),
    this.ERA_TYPE(),
    this.ERA_EFFECTIVENESS(),
    this.ERA_VS_KE(),
    this.RHA_EQUIVALENT(),
    this.NORMAL_X(),
    this.NORMAL_Y(),
    this.NORMAL_Z(),
    this.bb!.createScalarList<number>(this.RESERVED.bind(this), this.reservedLength())
  );
}


unpackTo(_o: ARMT): void {
  _o.THICKNESS = this.THICKNESS();
  _o.ANGLE = this.ANGLE();
  _o.MATERIAL = this.MATERIAL();
  _o.HARDNESS = this.HARDNESS();
  _o.QUALITY = this.QUALITY();
  _o.ERA_TYPE = this.ERA_TYPE();
  _o.ERA_EFFECTIVENESS = this.ERA_EFFECTIVENESS();
  _o.ERA_VS_KE = this.ERA_VS_KE();
  _o.RHA_EQUIVALENT = this.RHA_EQUIVALENT();
  _o.NORMAL_X = this.NORMAL_X();
  _o.NORMAL_Y = this.NORMAL_Y();
  _o.NORMAL_Z = this.NORMAL_Z();
  _o.RESERVED = this.bb!.createScalarList<number>(this.RESERVED.bind(this), this.reservedLength());
}
}

export class ARMT implements flatbuffers.IGeneratedObject {
constructor(
  public THICKNESS: number = 0.0,
  public ANGLE: number = 0.0,
  public MATERIAL: number = 0,
  public HARDNESS: number = 0,
  public QUALITY: number = 0,
  public ERA_TYPE: number = 0,
  public ERA_EFFECTIVENESS: number = 0.0,
  public ERA_VS_KE: number = 0.0,
  public RHA_EQUIVALENT: number = 0.0,
  public NORMAL_X: number = 0.0,
  public NORMAL_Y: number = 0.0,
  public NORMAL_Z: number = 0.0,
  public RESERVED: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const RESERVED = ARM.createReservedVector(builder, this.RESERVED);

  return ARM.createARM(builder,
    this.THICKNESS,
    this.ANGLE,
    this.MATERIAL,
    this.HARDNESS,
    this.QUALITY,
    this.ERA_TYPE,
    this.ERA_EFFECTIVENESS,
    this.ERA_VS_KE,
    this.RHA_EQUIVALENT,
    this.NORMAL_X,
    this.NORMAL_Y,
    this.NORMAL_Z,
    RESERVED
  );
}
}
