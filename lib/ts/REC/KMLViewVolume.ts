// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * ViewVolume for PhotoOverlay
 */
export class KMLViewVolume implements flatbuffers.IUnpackableObject<KMLViewVolumeT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):KMLViewVolume {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsKMLViewVolume(bb:flatbuffers.ByteBuffer, obj?:KMLViewVolume):KMLViewVolume {
  return (obj || new KMLViewVolume()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsKMLViewVolume(bb:flatbuffers.ByteBuffer, obj?:KMLViewVolume):KMLViewVolume {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new KMLViewVolume()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Left field of view angle
 */
LEFT_FOV():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Right field of view angle
 */
RIGHT_FOV():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Bottom field of view angle
 */
BOTTOM_FOV():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Top field of view angle
 */
TOP_FOV():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Near clipping plane
 */
NEAR():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

static startKMLViewVolume(builder:flatbuffers.Builder) {
  builder.startObject(5);
}

static addLeftFov(builder:flatbuffers.Builder, LEFT_FOV:number) {
  builder.addFieldFloat64(0, LEFT_FOV, 0.0);
}

static addRightFov(builder:flatbuffers.Builder, RIGHT_FOV:number) {
  builder.addFieldFloat64(1, RIGHT_FOV, 0.0);
}

static addBottomFov(builder:flatbuffers.Builder, BOTTOM_FOV:number) {
  builder.addFieldFloat64(2, BOTTOM_FOV, 0.0);
}

static addTopFov(builder:flatbuffers.Builder, TOP_FOV:number) {
  builder.addFieldFloat64(3, TOP_FOV, 0.0);
}

static addNear(builder:flatbuffers.Builder, NEAR:number) {
  builder.addFieldFloat64(4, NEAR, 0.0);
}

static endKMLViewVolume(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createKMLViewVolume(builder:flatbuffers.Builder, LEFT_FOV:number, RIGHT_FOV:number, BOTTOM_FOV:number, TOP_FOV:number, NEAR:number):flatbuffers.Offset {
  KMLViewVolume.startKMLViewVolume(builder);
  KMLViewVolume.addLeftFov(builder, LEFT_FOV);
  KMLViewVolume.addRightFov(builder, RIGHT_FOV);
  KMLViewVolume.addBottomFov(builder, BOTTOM_FOV);
  KMLViewVolume.addTopFov(builder, TOP_FOV);
  KMLViewVolume.addNear(builder, NEAR);
  return KMLViewVolume.endKMLViewVolume(builder);
}

unpack(): KMLViewVolumeT {
  return new KMLViewVolumeT(
    this.LEFT_FOV(),
    this.RIGHT_FOV(),
    this.BOTTOM_FOV(),
    this.TOP_FOV(),
    this.NEAR()
  );
}


unpackTo(_o: KMLViewVolumeT): void {
  _o.LEFT_FOV = this.LEFT_FOV();
  _o.RIGHT_FOV = this.RIGHT_FOV();
  _o.BOTTOM_FOV = this.BOTTOM_FOV();
  _o.TOP_FOV = this.TOP_FOV();
  _o.NEAR = this.NEAR();
}
}

export class KMLViewVolumeT implements flatbuffers.IGeneratedObject {
constructor(
  public LEFT_FOV: number = 0.0,
  public RIGHT_FOV: number = 0.0,
  public BOTTOM_FOV: number = 0.0,
  public TOP_FOV: number = 0.0,
  public NEAR: number = 0.0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return KMLViewVolume.createKMLViewVolume(builder,
    this.LEFT_FOV,
    this.RIGHT_FOV,
    this.BOTTOM_FOV,
    this.TOP_FOV,
    this.NEAR
  );
}
}
