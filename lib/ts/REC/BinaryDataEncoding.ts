// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Binary data encoding specification
 */
export class BinaryDataEncoding implements flatbuffers.IUnpackableObject<BinaryDataEncodingT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):BinaryDataEncoding {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsBinaryDataEncoding(bb:flatbuffers.ByteBuffer, obj?:BinaryDataEncoding):BinaryDataEncoding {
  return (obj || new BinaryDataEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsBinaryDataEncoding(bb:flatbuffers.ByteBuffer, obj?:BinaryDataEncoding):BinaryDataEncoding {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new BinaryDataEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Fixed size in bits
 */
SIZE_IN_BITS():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

/**
 * Maximum size in bits (for variable length)
 */
MAX_SIZE_IN_BITS():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

/**
 * Leading size field bits (for variable length)
 */
LEADING_SIZE_BITS():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
}

static startBinaryDataEncoding(builder:flatbuffers.Builder) {
  builder.startObject(3);
}

static addSizeInBits(builder:flatbuffers.Builder, SIZE_IN_BITS:number) {
  builder.addFieldInt16(0, SIZE_IN_BITS, 0);
}

static addMaxSizeInBits(builder:flatbuffers.Builder, MAX_SIZE_IN_BITS:number) {
  builder.addFieldInt16(1, MAX_SIZE_IN_BITS, 0);
}

static addLeadingSizeBits(builder:flatbuffers.Builder, LEADING_SIZE_BITS:number) {
  builder.addFieldInt8(2, LEADING_SIZE_BITS, 0);
}

static endBinaryDataEncoding(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createBinaryDataEncoding(builder:flatbuffers.Builder, SIZE_IN_BITS:number, MAX_SIZE_IN_BITS:number, LEADING_SIZE_BITS:number):flatbuffers.Offset {
  BinaryDataEncoding.startBinaryDataEncoding(builder);
  BinaryDataEncoding.addSizeInBits(builder, SIZE_IN_BITS);
  BinaryDataEncoding.addMaxSizeInBits(builder, MAX_SIZE_IN_BITS);
  BinaryDataEncoding.addLeadingSizeBits(builder, LEADING_SIZE_BITS);
  return BinaryDataEncoding.endBinaryDataEncoding(builder);
}

unpack(): BinaryDataEncodingT {
  return new BinaryDataEncodingT(
    this.SIZE_IN_BITS(),
    this.MAX_SIZE_IN_BITS(),
    this.LEADING_SIZE_BITS()
  );
}


unpackTo(_o: BinaryDataEncodingT): void {
  _o.SIZE_IN_BITS = this.SIZE_IN_BITS();
  _o.MAX_SIZE_IN_BITS = this.MAX_SIZE_IN_BITS();
  _o.LEADING_SIZE_BITS = this.LEADING_SIZE_BITS();
}
}

export class BinaryDataEncodingT implements flatbuffers.IGeneratedObject {
constructor(
  public SIZE_IN_BITS: number = 0,
  public MAX_SIZE_IN_BITS: number = 0,
  public LEADING_SIZE_BITS: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return BinaryDataEncoding.createBinaryDataEncoding(builder,
    this.SIZE_IN_BITS,
    this.MAX_SIZE_IN_BITS,
    this.LEADING_SIZE_BITS
  );
}
}
