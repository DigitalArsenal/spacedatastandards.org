// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Encrypted Message Envelope
 */
export class EME implements flatbuffers.IUnpackableObject<EMET> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):EME {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsEME(bb:flatbuffers.ByteBuffer, obj?:EME):EME {
  return (obj || new EME()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsEME(bb:flatbuffers.ByteBuffer, obj?:EME):EME {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new EME()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$EME');
}

/**
 * Encrypted data blob, containing the ciphertext of the original plaintext message.
 */
encryptedBlob(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

encryptedBlobLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

encryptedBlobArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Temporary public key used for the encryption session, contributing to the derivation of the shared secret.
 */
ephemeralPublicKey():string|null
ephemeralPublicKey(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ephemeralPublicKey(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Message Authentication Code to verify the integrity and authenticity of the encrypted message.
 */
mac():string|null
mac(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
mac(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique value used to ensure that the same plaintext produces a different ciphertext for each encryption.
 */
nonce():string|null
nonce(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
nonce(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Additional authentication tag used in some encryption schemes for integrity and authenticity verification.
 */
tag():string|null
tag(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
tag(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Initialization vector used to introduce randomness in the encryption process, enhancing security.
 */
iv():string|null
iv(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
iv(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Identifier for the public key used, aiding in recipient key management and message decryption.
 */
publicKeyIdentifier():string|null
publicKeyIdentifier(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
publicKeyIdentifier(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Specifies the set of cryptographic algorithms used in the encryption process.
 */
cipherSuite():string|null
cipherSuite(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
cipherSuite(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Parameters for the Key Derivation Function, guiding the process of deriving keys from the shared secret.
 */
kdfParameters():string|null
kdfParameters(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
kdfParameters(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Parameters defining specific settings for the encryption algorithm, such as block size or operation mode.
 */
encryptionAlgorithmParameters():string|null
encryptionAlgorithmParameters(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
encryptionAlgorithmParameters(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startEME(builder:flatbuffers.Builder) {
  builder.startObject(10);
}

static addEncryptedBlob(builder:flatbuffers.Builder, encryptedBlobOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, encryptedBlobOffset, 0);
}

static createEncryptedBlobVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startEncryptedBlobVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addEphemeralPublicKey(builder:flatbuffers.Builder, ephemeralPublicKeyOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, ephemeralPublicKeyOffset, 0);
}

static addMac(builder:flatbuffers.Builder, macOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, macOffset, 0);
}

static addNonce(builder:flatbuffers.Builder, nonceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, nonceOffset, 0);
}

static addTag(builder:flatbuffers.Builder, tagOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, tagOffset, 0);
}

static addIv(builder:flatbuffers.Builder, ivOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, ivOffset, 0);
}

static addPublicKeyIdentifier(builder:flatbuffers.Builder, publicKeyIdentifierOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, publicKeyIdentifierOffset, 0);
}

static addCipherSuite(builder:flatbuffers.Builder, cipherSuiteOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, cipherSuiteOffset, 0);
}

static addKdfParameters(builder:flatbuffers.Builder, kdfParametersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, kdfParametersOffset, 0);
}

static addEncryptionAlgorithmParameters(builder:flatbuffers.Builder, encryptionAlgorithmParametersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, encryptionAlgorithmParametersOffset, 0);
}

static endEME(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishEMEBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EME');
}

static finishSizePrefixedEMEBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$EME', true);
}

static createEME(builder:flatbuffers.Builder, encryptedBlobOffset:flatbuffers.Offset, ephemeralPublicKeyOffset:flatbuffers.Offset, macOffset:flatbuffers.Offset, nonceOffset:flatbuffers.Offset, tagOffset:flatbuffers.Offset, ivOffset:flatbuffers.Offset, publicKeyIdentifierOffset:flatbuffers.Offset, cipherSuiteOffset:flatbuffers.Offset, kdfParametersOffset:flatbuffers.Offset, encryptionAlgorithmParametersOffset:flatbuffers.Offset):flatbuffers.Offset {
  EME.startEME(builder);
  EME.addEncryptedBlob(builder, encryptedBlobOffset);
  EME.addEphemeralPublicKey(builder, ephemeralPublicKeyOffset);
  EME.addMac(builder, macOffset);
  EME.addNonce(builder, nonceOffset);
  EME.addTag(builder, tagOffset);
  EME.addIv(builder, ivOffset);
  EME.addPublicKeyIdentifier(builder, publicKeyIdentifierOffset);
  EME.addCipherSuite(builder, cipherSuiteOffset);
  EME.addKdfParameters(builder, kdfParametersOffset);
  EME.addEncryptionAlgorithmParameters(builder, encryptionAlgorithmParametersOffset);
  return EME.endEME(builder);
}

unpack(): EMET {
  return new EMET(
    this.bb!.createScalarList<number>(this.encryptedBlob.bind(this), this.encryptedBlobLength()),
    this.ephemeralPublicKey(),
    this.mac(),
    this.nonce(),
    this.tag(),
    this.iv(),
    this.publicKeyIdentifier(),
    this.cipherSuite(),
    this.kdfParameters(),
    this.encryptionAlgorithmParameters()
  );
}


unpackTo(_o: EMET): void {
  _o.encryptedBlob = this.bb!.createScalarList<number>(this.encryptedBlob.bind(this), this.encryptedBlobLength());
  _o.ephemeralPublicKey = this.ephemeralPublicKey();
  _o.mac = this.mac();
  _o.nonce = this.nonce();
  _o.tag = this.tag();
  _o.iv = this.iv();
  _o.publicKeyIdentifier = this.publicKeyIdentifier();
  _o.cipherSuite = this.cipherSuite();
  _o.kdfParameters = this.kdfParameters();
  _o.encryptionAlgorithmParameters = this.encryptionAlgorithmParameters();
}
}

export class EMET implements flatbuffers.IGeneratedObject {
constructor(
  public encryptedBlob: (number)[] = [],
  public ephemeralPublicKey: string|Uint8Array|null = null,
  public mac: string|Uint8Array|null = null,
  public nonce: string|Uint8Array|null = null,
  public tag: string|Uint8Array|null = null,
  public iv: string|Uint8Array|null = null,
  public publicKeyIdentifier: string|Uint8Array|null = null,
  public cipherSuite: string|Uint8Array|null = null,
  public kdfParameters: string|Uint8Array|null = null,
  public encryptionAlgorithmParameters: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const encryptedBlob = EME.createEncryptedBlobVector(builder, this.encryptedBlob);
  const ephemeralPublicKey = (this.ephemeralPublicKey !== null ? builder.createString(this.ephemeralPublicKey!) : 0);
  const mac = (this.mac !== null ? builder.createString(this.mac!) : 0);
  const nonce = (this.nonce !== null ? builder.createString(this.nonce!) : 0);
  const tag = (this.tag !== null ? builder.createString(this.tag!) : 0);
  const iv = (this.iv !== null ? builder.createString(this.iv!) : 0);
  const publicKeyIdentifier = (this.publicKeyIdentifier !== null ? builder.createString(this.publicKeyIdentifier!) : 0);
  const cipherSuite = (this.cipherSuite !== null ? builder.createString(this.cipherSuite!) : 0);
  const kdfParameters = (this.kdfParameters !== null ? builder.createString(this.kdfParameters!) : 0);
  const encryptionAlgorithmParameters = (this.encryptionAlgorithmParameters !== null ? builder.createString(this.encryptionAlgorithmParameters!) : 0);

  return EME.createEME(builder,
    encryptedBlob,
    ephemeralPublicKey,
    mac,
    nonce,
    tag,
    iv,
    publicKeyIdentifier,
    cipherSuite,
    kdfParameters,
    encryptionAlgorithmParameters
  );
}
}
