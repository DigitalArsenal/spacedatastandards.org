// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { BOV, BOVT } from './bov.js';
import { CAT, CATT } from './cat.js';
import { CDM, CDMT } from './cdm.js';
import { CRM, CRMT } from './crm.js';
import { CSM, CSMT } from './csm.js';
import { CTR, CTRT } from './ctr.js';
import { EME, EMET } from './eme.js';
import { EOO, EOOT } from './eoo.js';
import { EOP, EOPT } from './eop.js';
import { EPM, EPMT } from './epm.js';
import { HYP, HYPT } from './hyp.js';
import { IDM, IDMT } from './idm.js';
import { LCC, LCCT } from './lcc.js';
import { LDM, LDMT } from './ldm.js';
import { MET, METT } from './met.js';
import { MPE, MPET } from './mpe.js';
import { OCM, OCMT } from './ocm.js';
import { OEM, OEMT } from './oem.js';
import { OMM, OMMT } from './omm.js';
import { OSM, OSMT } from './osm.js';
import { PLD, PLDT } from './pld.js';
import { PNM, PNMT } from './pnm.js';
import { PRG, PRGT } from './prg.js';
import { RFM, RFMT } from './rfm.js';
import { ROC, ROCT } from './roc.js';
import { RecordType, unionToRecordType, unionListToRecordType } from './record-type.js';
import { SCM, SCMT } from './scm.js';
import { SIT, SITT } from './sit.js';
import { SPW, SPWT } from './spw.js';
import { TDM, TDMT } from './tdm.js';
import { TIM, TIMT } from './tim.js';
import { VCM, VCMT } from './vcm.js';


export class Record implements flatbuffers.IUnpackableObject<RecordT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Record {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsRecord(bb:flatbuffers.ByteBuffer, obj?:Record):Record {
  return (obj || new Record()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsRecord(bb:flatbuffers.ByteBuffer, obj?:Record):Record {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Record()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

valueType():RecordType {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : RecordType.NONE;
}

value<T extends flatbuffers.Table>(obj:any):any|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
}

static startRecord(builder:flatbuffers.Builder) {
  builder.startObject(2);
}

static addValueType(builder:flatbuffers.Builder, valueType:RecordType) {
  builder.addFieldInt8(0, valueType, RecordType.NONE);
}

static addValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, valueOffset, 0);
}

static endRecord(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createRecord(builder:flatbuffers.Builder, valueType:RecordType, valueOffset:flatbuffers.Offset):flatbuffers.Offset {
  Record.startRecord(builder);
  Record.addValueType(builder, valueType);
  Record.addValue(builder, valueOffset);
  return Record.endRecord(builder);
}

unpack(): RecordT {
  return new RecordT(
    this.valueType(),
    (() => {
      const temp = unionToRecordType(this.valueType(), this.value.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })()
  );
}


unpackTo(_o: RecordT): void {
  _o.valueType = this.valueType();
  _o.value = (() => {
      const temp = unionToRecordType(this.valueType(), this.value.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })();
}
}

export class RecordT implements flatbuffers.IGeneratedObject {
constructor(
  public valueType: RecordType = RecordType.NONE,
  public value: BOVT|CATT|CDMT|CRMT|CSMT|CTRT|EMET|EOOT|EOPT|EPMT|HYPT|IDMT|LCCT|LDMT|METT|MPET|OCMT|OEMT|OMMT|OSMT|PLDT|PNMT|PRGT|RFMT|ROCT|SCMT|SITT|SPWT|TDMT|TIMT|VCMT|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const value = builder.createObjectOffset(this.value);

  return Record.createRecord(builder,
    this.valueType,
    value
  );
}
}
