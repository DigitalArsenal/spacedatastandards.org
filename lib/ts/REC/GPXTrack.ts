// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { GPXLink, GPXLinkT } from './GPXLink.js';
import { GPXTrackSegment, GPXTrackSegmentT } from './GPXTrackSegment.js';


/**
 * Track (ordered list of track segments)
 */
export class GPXTrack implements flatbuffers.IUnpackableObject<GPXTrackT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):GPXTrack {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsGPXTrack(bb:flatbuffers.ByteBuffer, obj?:GPXTrack):GPXTrack {
  return (obj || new GPXTrack()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsGPXTrack(bb:flatbuffers.ByteBuffer, obj?:GPXTrack):GPXTrack {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GPXTrack()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Track name
 */
NAME():string|null
NAME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
NAME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Comment
 */
COMMENT():string|null
COMMENT(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
COMMENT(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Description
 */
DESCRIPTION():string|null
DESCRIPTION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
DESCRIPTION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Source of data
 */
SOURCE():string|null
SOURCE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SOURCE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Links to additional information
 */
LINKS(index: number, obj?:GPXLink):GPXLink|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new GPXLink()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

linksLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Track number
 */
NUMBER():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * Type/category
 */
TYPE():string|null
TYPE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TYPE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Track segments
 */
SEGMENTS(index: number, obj?:GPXTrackSegment):GPXTrackSegment|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? (obj || new GPXTrackSegment()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

segmentsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startGPXTrack(builder:flatbuffers.Builder) {
  builder.startObject(8);
}

static addName(builder:flatbuffers.Builder, NAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, NAMEOffset, 0);
}

static addComment(builder:flatbuffers.Builder, COMMENTOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, COMMENTOffset, 0);
}

static addDescription(builder:flatbuffers.Builder, DESCRIPTIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, DESCRIPTIONOffset, 0);
}

static addSource(builder:flatbuffers.Builder, SOURCEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, SOURCEOffset, 0);
}

static addLinks(builder:flatbuffers.Builder, LINKSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, LINKSOffset, 0);
}

static createLinksVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startLinksVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addNumber(builder:flatbuffers.Builder, NUMBER:number) {
  builder.addFieldInt32(5, NUMBER, 0);
}

static addType(builder:flatbuffers.Builder, TYPEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, TYPEOffset, 0);
}

static addSegments(builder:flatbuffers.Builder, SEGMENTSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, SEGMENTSOffset, 0);
}

static createSegmentsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startSegmentsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endGPXTrack(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createGPXTrack(builder:flatbuffers.Builder, NAMEOffset:flatbuffers.Offset, COMMENTOffset:flatbuffers.Offset, DESCRIPTIONOffset:flatbuffers.Offset, SOURCEOffset:flatbuffers.Offset, LINKSOffset:flatbuffers.Offset, NUMBER:number, TYPEOffset:flatbuffers.Offset, SEGMENTSOffset:flatbuffers.Offset):flatbuffers.Offset {
  GPXTrack.startGPXTrack(builder);
  GPXTrack.addName(builder, NAMEOffset);
  GPXTrack.addComment(builder, COMMENTOffset);
  GPXTrack.addDescription(builder, DESCRIPTIONOffset);
  GPXTrack.addSource(builder, SOURCEOffset);
  GPXTrack.addLinks(builder, LINKSOffset);
  GPXTrack.addNumber(builder, NUMBER);
  GPXTrack.addType(builder, TYPEOffset);
  GPXTrack.addSegments(builder, SEGMENTSOffset);
  return GPXTrack.endGPXTrack(builder);
}

unpack(): GPXTrackT {
  return new GPXTrackT(
    this.NAME(),
    this.COMMENT(),
    this.DESCRIPTION(),
    this.SOURCE(),
    this.bb!.createObjList<GPXLink, GPXLinkT>(this.LINKS.bind(this), this.linksLength()),
    this.NUMBER(),
    this.TYPE(),
    this.bb!.createObjList<GPXTrackSegment, GPXTrackSegmentT>(this.SEGMENTS.bind(this), this.segmentsLength())
  );
}


unpackTo(_o: GPXTrackT): void {
  _o.NAME = this.NAME();
  _o.COMMENT = this.COMMENT();
  _o.DESCRIPTION = this.DESCRIPTION();
  _o.SOURCE = this.SOURCE();
  _o.LINKS = this.bb!.createObjList<GPXLink, GPXLinkT>(this.LINKS.bind(this), this.linksLength());
  _o.NUMBER = this.NUMBER();
  _o.TYPE = this.TYPE();
  _o.SEGMENTS = this.bb!.createObjList<GPXTrackSegment, GPXTrackSegmentT>(this.SEGMENTS.bind(this), this.segmentsLength());
}
}

export class GPXTrackT implements flatbuffers.IGeneratedObject {
constructor(
  public NAME: string|Uint8Array|null = null,
  public COMMENT: string|Uint8Array|null = null,
  public DESCRIPTION: string|Uint8Array|null = null,
  public SOURCE: string|Uint8Array|null = null,
  public LINKS: (GPXLinkT)[] = [],
  public NUMBER: number = 0,
  public TYPE: string|Uint8Array|null = null,
  public SEGMENTS: (GPXTrackSegmentT)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const NAME = (this.NAME !== null ? builder.createString(this.NAME!) : 0);
  const COMMENT = (this.COMMENT !== null ? builder.createString(this.COMMENT!) : 0);
  const DESCRIPTION = (this.DESCRIPTION !== null ? builder.createString(this.DESCRIPTION!) : 0);
  const SOURCE = (this.SOURCE !== null ? builder.createString(this.SOURCE!) : 0);
  const LINKS = GPXTrack.createLinksVector(builder, builder.createObjectOffsetList(this.LINKS));
  const TYPE = (this.TYPE !== null ? builder.createString(this.TYPE!) : 0);
  const SEGMENTS = GPXTrack.createSegmentsVector(builder, builder.createObjectOffsetList(this.SEGMENTS));

  return GPXTrack.createGPXTrack(builder,
    NAME,
    COMMENT,
    DESCRIPTION,
    SOURCE,
    LINKS,
    this.NUMBER,
    TYPE,
    SEGMENTS
  );
}
}
