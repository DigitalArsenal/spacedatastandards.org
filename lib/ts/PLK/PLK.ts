// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { licenseType } from './licenseType.js';


/**
 * Plugin License Key - Issued license for plugin access
 * Uses ECIES: both parties derive symmetric key via X25519 ECDH
 * Key derivation: X25519(private, peer_public) → HKDF-SHA256 → AES-256-GCM
 */
export class PLK implements flatbuffers.IUnpackableObject<PLKT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):PLK {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsPLK(bb:flatbuffers.ByteBuffer, obj?:PLK):PLK {
  return (obj || new PLK()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsPLK(bb:flatbuffers.ByteBuffer, obj?:PLK):PLK {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new PLK()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$PLK');
}

/**
 * Unique license key identifier
 */
LICENSE_ID():string|null
LICENSE_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
LICENSE_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Plugin ID this license is for
 */
PLUGIN_ID():string|null
PLUGIN_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PLUGIN_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Plugin version or version range (semver)
 */
PLUGIN_VERSION():string|null
PLUGIN_VERSION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PLUGIN_VERSION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Licensee organization name
 */
LICENSEE_ORG():string|null
LICENSEE_ORG(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
LICENSEE_ORG(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Licensee contact email
 */
LICENSEE_EMAIL():string|null
LICENSEE_EMAIL(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
LICENSEE_EMAIL(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Licensee's SDN Peer ID
 */
LICENSEE_PEER_ID():string|null
LICENSEE_PEER_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
LICENSEE_PEER_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Licensee's X25519 public key (32 bytes)
 */
LICENSEE_PUBKEY(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

licenseePubkeyLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

licenseePubkeyArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Issuer's X25519 public key (32 bytes)
 * Used with licensee's private key to derive shared secret via ECDH
 */
ISSUER_PUBKEY(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

issuerPubkeyLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

issuerPubkeyArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Domain restrictions (empty = any domain allowed)
 */
ALLOWED_DOMAINS(index: number):string
ALLOWED_DOMAINS(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
ALLOWED_DOMAINS(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

allowedDomainsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * TLD restrictions (e.g., ".gov", ".mil", ".edu")
 */
ALLOWED_TLDS(index: number):string
ALLOWED_TLDS(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
ALLOWED_TLDS(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

allowedTldsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Type of license
 */
LICENSE_TYPE():licenseType {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : licenseType.Trial;
}

/**
 * Maximum concurrent activations (0 = unlimited)
 */
MAX_ACTIVATIONS():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * Unix timestamp when license was issued
 */
ISSUED_AT():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

/**
 * Unix timestamp when license becomes valid
 */
VALID_FROM():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

/**
 * Unix timestamp when license expires (0 = never expires)
 */
EXPIRES_AT():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

/**
 * Peer ID of the license issuer (OrbPro)
 */
ISSUER_PEER_ID():string|null
ISSUER_PEER_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ISSUER_PEER_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Ed25519 signature from issuer over all fields (except SIGNATURE)
 */
SIGNATURE(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

signatureLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

signatureArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startPLK(builder:flatbuffers.Builder) {
  builder.startObject(17);
}

static addLicenseId(builder:flatbuffers.Builder, LICENSE_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, LICENSE_IDOffset, 0);
}

static addPluginId(builder:flatbuffers.Builder, PLUGIN_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, PLUGIN_IDOffset, 0);
}

static addPluginVersion(builder:flatbuffers.Builder, PLUGIN_VERSIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, PLUGIN_VERSIONOffset, 0);
}

static addLicenseeOrg(builder:flatbuffers.Builder, LICENSEE_ORGOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, LICENSEE_ORGOffset, 0);
}

static addLicenseeEmail(builder:flatbuffers.Builder, LICENSEE_EMAILOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, LICENSEE_EMAILOffset, 0);
}

static addLicenseePeerId(builder:flatbuffers.Builder, LICENSEE_PEER_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, LICENSEE_PEER_IDOffset, 0);
}

static addLicenseePubkey(builder:flatbuffers.Builder, LICENSEE_PUBKEYOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, LICENSEE_PUBKEYOffset, 0);
}

static createLicenseePubkeyVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startLicenseePubkeyVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addIssuerPubkey(builder:flatbuffers.Builder, ISSUER_PUBKEYOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, ISSUER_PUBKEYOffset, 0);
}

static createIssuerPubkeyVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startIssuerPubkeyVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addAllowedDomains(builder:flatbuffers.Builder, ALLOWED_DOMAINSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, ALLOWED_DOMAINSOffset, 0);
}

static createAllowedDomainsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startAllowedDomainsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addAllowedTlds(builder:flatbuffers.Builder, ALLOWED_TLDSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, ALLOWED_TLDSOffset, 0);
}

static createAllowedTldsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startAllowedTldsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addLicenseType(builder:flatbuffers.Builder, LICENSE_TYPE:licenseType) {
  builder.addFieldInt8(10, LICENSE_TYPE, licenseType.Trial);
}

static addMaxActivations(builder:flatbuffers.Builder, MAX_ACTIVATIONS:number) {
  builder.addFieldInt32(11, MAX_ACTIVATIONS, 0);
}

static addIssuedAt(builder:flatbuffers.Builder, ISSUED_AT:bigint) {
  builder.addFieldInt64(12, ISSUED_AT, BigInt('0'));
}

static addValidFrom(builder:flatbuffers.Builder, VALID_FROM:bigint) {
  builder.addFieldInt64(13, VALID_FROM, BigInt('0'));
}

static addExpiresAt(builder:flatbuffers.Builder, EXPIRES_AT:bigint) {
  builder.addFieldInt64(14, EXPIRES_AT, BigInt('0'));
}

static addIssuerPeerId(builder:flatbuffers.Builder, ISSUER_PEER_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, ISSUER_PEER_IDOffset, 0);
}

static addSignature(builder:flatbuffers.Builder, SIGNATUREOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, SIGNATUREOffset, 0);
}

static createSignatureVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startSignatureVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static endPLK(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 4) // LICENSE_ID
  builder.requiredField(offset, 6) // PLUGIN_ID
  builder.requiredField(offset, 10) // LICENSEE_ORG
  return offset;
}

static finishPLKBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$PLK');
}

static finishSizePrefixedPLKBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$PLK', true);
}

static createPLK(builder:flatbuffers.Builder, LICENSE_IDOffset:flatbuffers.Offset, PLUGIN_IDOffset:flatbuffers.Offset, PLUGIN_VERSIONOffset:flatbuffers.Offset, LICENSEE_ORGOffset:flatbuffers.Offset, LICENSEE_EMAILOffset:flatbuffers.Offset, LICENSEE_PEER_IDOffset:flatbuffers.Offset, LICENSEE_PUBKEYOffset:flatbuffers.Offset, ISSUER_PUBKEYOffset:flatbuffers.Offset, ALLOWED_DOMAINSOffset:flatbuffers.Offset, ALLOWED_TLDSOffset:flatbuffers.Offset, LICENSE_TYPE:licenseType, MAX_ACTIVATIONS:number, ISSUED_AT:bigint, VALID_FROM:bigint, EXPIRES_AT:bigint, ISSUER_PEER_IDOffset:flatbuffers.Offset, SIGNATUREOffset:flatbuffers.Offset):flatbuffers.Offset {
  PLK.startPLK(builder);
  PLK.addLicenseId(builder, LICENSE_IDOffset);
  PLK.addPluginId(builder, PLUGIN_IDOffset);
  PLK.addPluginVersion(builder, PLUGIN_VERSIONOffset);
  PLK.addLicenseeOrg(builder, LICENSEE_ORGOffset);
  PLK.addLicenseeEmail(builder, LICENSEE_EMAILOffset);
  PLK.addLicenseePeerId(builder, LICENSEE_PEER_IDOffset);
  PLK.addLicenseePubkey(builder, LICENSEE_PUBKEYOffset);
  PLK.addIssuerPubkey(builder, ISSUER_PUBKEYOffset);
  PLK.addAllowedDomains(builder, ALLOWED_DOMAINSOffset);
  PLK.addAllowedTlds(builder, ALLOWED_TLDSOffset);
  PLK.addLicenseType(builder, LICENSE_TYPE);
  PLK.addMaxActivations(builder, MAX_ACTIVATIONS);
  PLK.addIssuedAt(builder, ISSUED_AT);
  PLK.addValidFrom(builder, VALID_FROM);
  PLK.addExpiresAt(builder, EXPIRES_AT);
  PLK.addIssuerPeerId(builder, ISSUER_PEER_IDOffset);
  PLK.addSignature(builder, SIGNATUREOffset);
  return PLK.endPLK(builder);
}

unpack(): PLKT {
  return new PLKT(
    this.LICENSE_ID(),
    this.PLUGIN_ID(),
    this.PLUGIN_VERSION(),
    this.LICENSEE_ORG(),
    this.LICENSEE_EMAIL(),
    this.LICENSEE_PEER_ID(),
    this.bb!.createScalarList<number>(this.LICENSEE_PUBKEY.bind(this), this.licenseePubkeyLength()),
    this.bb!.createScalarList<number>(this.ISSUER_PUBKEY.bind(this), this.issuerPubkeyLength()),
    this.bb!.createScalarList<string>(this.ALLOWED_DOMAINS.bind(this), this.allowedDomainsLength()),
    this.bb!.createScalarList<string>(this.ALLOWED_TLDS.bind(this), this.allowedTldsLength()),
    this.LICENSE_TYPE(),
    this.MAX_ACTIVATIONS(),
    this.ISSUED_AT(),
    this.VALID_FROM(),
    this.EXPIRES_AT(),
    this.ISSUER_PEER_ID(),
    this.bb!.createScalarList<number>(this.SIGNATURE.bind(this), this.signatureLength())
  );
}


unpackTo(_o: PLKT): void {
  _o.LICENSE_ID = this.LICENSE_ID();
  _o.PLUGIN_ID = this.PLUGIN_ID();
  _o.PLUGIN_VERSION = this.PLUGIN_VERSION();
  _o.LICENSEE_ORG = this.LICENSEE_ORG();
  _o.LICENSEE_EMAIL = this.LICENSEE_EMAIL();
  _o.LICENSEE_PEER_ID = this.LICENSEE_PEER_ID();
  _o.LICENSEE_PUBKEY = this.bb!.createScalarList<number>(this.LICENSEE_PUBKEY.bind(this), this.licenseePubkeyLength());
  _o.ISSUER_PUBKEY = this.bb!.createScalarList<number>(this.ISSUER_PUBKEY.bind(this), this.issuerPubkeyLength());
  _o.ALLOWED_DOMAINS = this.bb!.createScalarList<string>(this.ALLOWED_DOMAINS.bind(this), this.allowedDomainsLength());
  _o.ALLOWED_TLDS = this.bb!.createScalarList<string>(this.ALLOWED_TLDS.bind(this), this.allowedTldsLength());
  _o.LICENSE_TYPE = this.LICENSE_TYPE();
  _o.MAX_ACTIVATIONS = this.MAX_ACTIVATIONS();
  _o.ISSUED_AT = this.ISSUED_AT();
  _o.VALID_FROM = this.VALID_FROM();
  _o.EXPIRES_AT = this.EXPIRES_AT();
  _o.ISSUER_PEER_ID = this.ISSUER_PEER_ID();
  _o.SIGNATURE = this.bb!.createScalarList<number>(this.SIGNATURE.bind(this), this.signatureLength());
}
}

export class PLKT implements flatbuffers.IGeneratedObject {
constructor(
  public LICENSE_ID: string|Uint8Array|null = null,
  public PLUGIN_ID: string|Uint8Array|null = null,
  public PLUGIN_VERSION: string|Uint8Array|null = null,
  public LICENSEE_ORG: string|Uint8Array|null = null,
  public LICENSEE_EMAIL: string|Uint8Array|null = null,
  public LICENSEE_PEER_ID: string|Uint8Array|null = null,
  public LICENSEE_PUBKEY: (number)[] = [],
  public ISSUER_PUBKEY: (number)[] = [],
  public ALLOWED_DOMAINS: (string)[] = [],
  public ALLOWED_TLDS: (string)[] = [],
  public LICENSE_TYPE: licenseType = licenseType.Trial,
  public MAX_ACTIVATIONS: number = 0,
  public ISSUED_AT: bigint = BigInt('0'),
  public VALID_FROM: bigint = BigInt('0'),
  public EXPIRES_AT: bigint = BigInt('0'),
  public ISSUER_PEER_ID: string|Uint8Array|null = null,
  public SIGNATURE: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const LICENSE_ID = (this.LICENSE_ID !== null ? builder.createString(this.LICENSE_ID!) : 0);
  const PLUGIN_ID = (this.PLUGIN_ID !== null ? builder.createString(this.PLUGIN_ID!) : 0);
  const PLUGIN_VERSION = (this.PLUGIN_VERSION !== null ? builder.createString(this.PLUGIN_VERSION!) : 0);
  const LICENSEE_ORG = (this.LICENSEE_ORG !== null ? builder.createString(this.LICENSEE_ORG!) : 0);
  const LICENSEE_EMAIL = (this.LICENSEE_EMAIL !== null ? builder.createString(this.LICENSEE_EMAIL!) : 0);
  const LICENSEE_PEER_ID = (this.LICENSEE_PEER_ID !== null ? builder.createString(this.LICENSEE_PEER_ID!) : 0);
  const LICENSEE_PUBKEY = PLK.createLicenseePubkeyVector(builder, this.LICENSEE_PUBKEY);
  const ISSUER_PUBKEY = PLK.createIssuerPubkeyVector(builder, this.ISSUER_PUBKEY);
  const ALLOWED_DOMAINS = PLK.createAllowedDomainsVector(builder, builder.createObjectOffsetList(this.ALLOWED_DOMAINS));
  const ALLOWED_TLDS = PLK.createAllowedTldsVector(builder, builder.createObjectOffsetList(this.ALLOWED_TLDS));
  const ISSUER_PEER_ID = (this.ISSUER_PEER_ID !== null ? builder.createString(this.ISSUER_PEER_ID!) : 0);
  const SIGNATURE = PLK.createSignatureVector(builder, this.SIGNATURE);

  return PLK.createPLK(builder,
    LICENSE_ID,
    PLUGIN_ID,
    PLUGIN_VERSION,
    LICENSEE_ORG,
    LICENSEE_EMAIL,
    LICENSEE_PEER_ID,
    LICENSEE_PUBKEY,
    ISSUER_PUBKEY,
    ALLOWED_DOMAINS,
    ALLOWED_TLDS,
    this.LICENSE_TYPE,
    this.MAX_ACTIVATIONS,
    this.ISSUED_AT,
    this.VALID_FROM,
    this.EXPIRES_AT,
    ISSUER_PEER_ID,
    SIGNATURE
  );
}
}
