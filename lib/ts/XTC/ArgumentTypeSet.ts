// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { AggregateArgumentType, AggregateArgumentTypeT } from './AggregateArgumentType.js';
import { BinaryArgumentType, BinaryArgumentTypeT } from './BinaryArgumentType.js';
import { BooleanArgumentType, BooleanArgumentTypeT } from './BooleanArgumentType.js';
import { EnumeratedArgumentType, EnumeratedArgumentTypeT } from './EnumeratedArgumentType.js';
import { FloatArgumentType, FloatArgumentTypeT } from './FloatArgumentType.js';
import { IntegerArgumentType, IntegerArgumentTypeT } from './IntegerArgumentType.js';
import { StringArgumentType, StringArgumentTypeT } from './StringArgumentType.js';


/**
 * Collection of argument types
 */
export class ArgumentTypeSet implements flatbuffers.IUnpackableObject<ArgumentTypeSetT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ArgumentTypeSet {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsArgumentTypeSet(bb:flatbuffers.ByteBuffer, obj?:ArgumentTypeSet):ArgumentTypeSet {
  return (obj || new ArgumentTypeSet()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsArgumentTypeSet(bb:flatbuffers.ByteBuffer, obj?:ArgumentTypeSet):ArgumentTypeSet {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ArgumentTypeSet()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Integer argument types
 */
INTEGER_TYPES(index: number, obj?:IntegerArgumentType):IntegerArgumentType|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new IntegerArgumentType()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

integerTypesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Float argument types
 */
FLOAT_TYPES(index: number, obj?:FloatArgumentType):FloatArgumentType|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new FloatArgumentType()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

floatTypesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * String argument types
 */
STRING_TYPES(index: number, obj?:StringArgumentType):StringArgumentType|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new StringArgumentType()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

stringTypesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Boolean argument types
 */
BOOLEAN_TYPES(index: number, obj?:BooleanArgumentType):BooleanArgumentType|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new BooleanArgumentType()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

booleanTypesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Enumerated argument types
 */
ENUMERATED_TYPES(index: number, obj?:EnumeratedArgumentType):EnumeratedArgumentType|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new EnumeratedArgumentType()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

enumeratedTypesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Binary argument types
 */
BINARY_TYPES(index: number, obj?:BinaryArgumentType):BinaryArgumentType|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? (obj || new BinaryArgumentType()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

binaryTypesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Aggregate argument types
 */
AGGREGATE_TYPES(index: number, obj?:AggregateArgumentType):AggregateArgumentType|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? (obj || new AggregateArgumentType()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

aggregateTypesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startArgumentTypeSet(builder:flatbuffers.Builder) {
  builder.startObject(7);
}

static addIntegerTypes(builder:flatbuffers.Builder, INTEGER_TYPESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, INTEGER_TYPESOffset, 0);
}

static createIntegerTypesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startIntegerTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addFloatTypes(builder:flatbuffers.Builder, FLOAT_TYPESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, FLOAT_TYPESOffset, 0);
}

static createFloatTypesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startFloatTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addStringTypes(builder:flatbuffers.Builder, STRING_TYPESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, STRING_TYPESOffset, 0);
}

static createStringTypesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startStringTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addBooleanTypes(builder:flatbuffers.Builder, BOOLEAN_TYPESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, BOOLEAN_TYPESOffset, 0);
}

static createBooleanTypesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startBooleanTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addEnumeratedTypes(builder:flatbuffers.Builder, ENUMERATED_TYPESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, ENUMERATED_TYPESOffset, 0);
}

static createEnumeratedTypesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEnumeratedTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addBinaryTypes(builder:flatbuffers.Builder, BINARY_TYPESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, BINARY_TYPESOffset, 0);
}

static createBinaryTypesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startBinaryTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addAggregateTypes(builder:flatbuffers.Builder, AGGREGATE_TYPESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, AGGREGATE_TYPESOffset, 0);
}

static createAggregateTypesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startAggregateTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endArgumentTypeSet(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createArgumentTypeSet(builder:flatbuffers.Builder, INTEGER_TYPESOffset:flatbuffers.Offset, FLOAT_TYPESOffset:flatbuffers.Offset, STRING_TYPESOffset:flatbuffers.Offset, BOOLEAN_TYPESOffset:flatbuffers.Offset, ENUMERATED_TYPESOffset:flatbuffers.Offset, BINARY_TYPESOffset:flatbuffers.Offset, AGGREGATE_TYPESOffset:flatbuffers.Offset):flatbuffers.Offset {
  ArgumentTypeSet.startArgumentTypeSet(builder);
  ArgumentTypeSet.addIntegerTypes(builder, INTEGER_TYPESOffset);
  ArgumentTypeSet.addFloatTypes(builder, FLOAT_TYPESOffset);
  ArgumentTypeSet.addStringTypes(builder, STRING_TYPESOffset);
  ArgumentTypeSet.addBooleanTypes(builder, BOOLEAN_TYPESOffset);
  ArgumentTypeSet.addEnumeratedTypes(builder, ENUMERATED_TYPESOffset);
  ArgumentTypeSet.addBinaryTypes(builder, BINARY_TYPESOffset);
  ArgumentTypeSet.addAggregateTypes(builder, AGGREGATE_TYPESOffset);
  return ArgumentTypeSet.endArgumentTypeSet(builder);
}

unpack(): ArgumentTypeSetT {
  return new ArgumentTypeSetT(
    this.bb!.createObjList<IntegerArgumentType, IntegerArgumentTypeT>(this.INTEGER_TYPES.bind(this), this.integerTypesLength()),
    this.bb!.createObjList<FloatArgumentType, FloatArgumentTypeT>(this.FLOAT_TYPES.bind(this), this.floatTypesLength()),
    this.bb!.createObjList<StringArgumentType, StringArgumentTypeT>(this.STRING_TYPES.bind(this), this.stringTypesLength()),
    this.bb!.createObjList<BooleanArgumentType, BooleanArgumentTypeT>(this.BOOLEAN_TYPES.bind(this), this.booleanTypesLength()),
    this.bb!.createObjList<EnumeratedArgumentType, EnumeratedArgumentTypeT>(this.ENUMERATED_TYPES.bind(this), this.enumeratedTypesLength()),
    this.bb!.createObjList<BinaryArgumentType, BinaryArgumentTypeT>(this.BINARY_TYPES.bind(this), this.binaryTypesLength()),
    this.bb!.createObjList<AggregateArgumentType, AggregateArgumentTypeT>(this.AGGREGATE_TYPES.bind(this), this.aggregateTypesLength())
  );
}


unpackTo(_o: ArgumentTypeSetT): void {
  _o.INTEGER_TYPES = this.bb!.createObjList<IntegerArgumentType, IntegerArgumentTypeT>(this.INTEGER_TYPES.bind(this), this.integerTypesLength());
  _o.FLOAT_TYPES = this.bb!.createObjList<FloatArgumentType, FloatArgumentTypeT>(this.FLOAT_TYPES.bind(this), this.floatTypesLength());
  _o.STRING_TYPES = this.bb!.createObjList<StringArgumentType, StringArgumentTypeT>(this.STRING_TYPES.bind(this), this.stringTypesLength());
  _o.BOOLEAN_TYPES = this.bb!.createObjList<BooleanArgumentType, BooleanArgumentTypeT>(this.BOOLEAN_TYPES.bind(this), this.booleanTypesLength());
  _o.ENUMERATED_TYPES = this.bb!.createObjList<EnumeratedArgumentType, EnumeratedArgumentTypeT>(this.ENUMERATED_TYPES.bind(this), this.enumeratedTypesLength());
  _o.BINARY_TYPES = this.bb!.createObjList<BinaryArgumentType, BinaryArgumentTypeT>(this.BINARY_TYPES.bind(this), this.binaryTypesLength());
  _o.AGGREGATE_TYPES = this.bb!.createObjList<AggregateArgumentType, AggregateArgumentTypeT>(this.AGGREGATE_TYPES.bind(this), this.aggregateTypesLength());
}
}

export class ArgumentTypeSetT implements flatbuffers.IGeneratedObject {
constructor(
  public INTEGER_TYPES: (IntegerArgumentTypeT)[] = [],
  public FLOAT_TYPES: (FloatArgumentTypeT)[] = [],
  public STRING_TYPES: (StringArgumentTypeT)[] = [],
  public BOOLEAN_TYPES: (BooleanArgumentTypeT)[] = [],
  public ENUMERATED_TYPES: (EnumeratedArgumentTypeT)[] = [],
  public BINARY_TYPES: (BinaryArgumentTypeT)[] = [],
  public AGGREGATE_TYPES: (AggregateArgumentTypeT)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const INTEGER_TYPES = ArgumentTypeSet.createIntegerTypesVector(builder, builder.createObjectOffsetList(this.INTEGER_TYPES));
  const FLOAT_TYPES = ArgumentTypeSet.createFloatTypesVector(builder, builder.createObjectOffsetList(this.FLOAT_TYPES));
  const STRING_TYPES = ArgumentTypeSet.createStringTypesVector(builder, builder.createObjectOffsetList(this.STRING_TYPES));
  const BOOLEAN_TYPES = ArgumentTypeSet.createBooleanTypesVector(builder, builder.createObjectOffsetList(this.BOOLEAN_TYPES));
  const ENUMERATED_TYPES = ArgumentTypeSet.createEnumeratedTypesVector(builder, builder.createObjectOffsetList(this.ENUMERATED_TYPES));
  const BINARY_TYPES = ArgumentTypeSet.createBinaryTypesVector(builder, builder.createObjectOffsetList(this.BINARY_TYPES));
  const AGGREGATE_TYPES = ArgumentTypeSet.createAggregateTypesVector(builder, builder.createObjectOffsetList(this.AGGREGATE_TYPES));

  return ArgumentTypeSet.createArgumentTypeSet(builder,
    INTEGER_TYPES,
    FLOAT_TYPES,
    STRING_TYPES,
    BOOLEAN_TYPES,
    ENUMERATED_TYPES,
    BINARY_TYPES,
    AGGREGATE_TYPES
  );
}
}
