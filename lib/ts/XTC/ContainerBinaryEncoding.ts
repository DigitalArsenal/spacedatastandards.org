// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { ErrorDetectionType } from './ErrorDetectionType.js';


/**
 * Binary encoding specification for container
 */
export class ContainerBinaryEncoding implements flatbuffers.IUnpackableObject<ContainerBinaryEncodingT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ContainerBinaryEncoding {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsContainerBinaryEncoding(bb:flatbuffers.ByteBuffer, obj?:ContainerBinaryEncoding):ContainerBinaryEncoding {
  return (obj || new ContainerBinaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsContainerBinaryEncoding(bb:flatbuffers.ByteBuffer, obj?:ContainerBinaryEncoding):ContainerBinaryEncoding {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ContainerBinaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Error detection type
 */
ERROR_DETECTION():ErrorDetectionType {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : ErrorDetectionType.NONE;
}

/**
 * CRC polynomial (for CRC error detection)
 */
CRC_POLYNOMIAL():string|null
CRC_POLYNOMIAL(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CRC_POLYNOMIAL(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Size in bits
 */
SIZE_IN_BITS():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

static startContainerBinaryEncoding(builder:flatbuffers.Builder) {
  builder.startObject(3);
}

static addErrorDetection(builder:flatbuffers.Builder, ERROR_DETECTION:ErrorDetectionType) {
  builder.addFieldInt8(0, ERROR_DETECTION, ErrorDetectionType.NONE);
}

static addCrcPolynomial(builder:flatbuffers.Builder, CRC_POLYNOMIALOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, CRC_POLYNOMIALOffset, 0);
}

static addSizeInBits(builder:flatbuffers.Builder, SIZE_IN_BITS:number) {
  builder.addFieldInt32(2, SIZE_IN_BITS, 0);
}

static endContainerBinaryEncoding(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createContainerBinaryEncoding(builder:flatbuffers.Builder, ERROR_DETECTION:ErrorDetectionType, CRC_POLYNOMIALOffset:flatbuffers.Offset, SIZE_IN_BITS:number):flatbuffers.Offset {
  ContainerBinaryEncoding.startContainerBinaryEncoding(builder);
  ContainerBinaryEncoding.addErrorDetection(builder, ERROR_DETECTION);
  ContainerBinaryEncoding.addCrcPolynomial(builder, CRC_POLYNOMIALOffset);
  ContainerBinaryEncoding.addSizeInBits(builder, SIZE_IN_BITS);
  return ContainerBinaryEncoding.endContainerBinaryEncoding(builder);
}

unpack(): ContainerBinaryEncodingT {
  return new ContainerBinaryEncodingT(
    this.ERROR_DETECTION(),
    this.CRC_POLYNOMIAL(),
    this.SIZE_IN_BITS()
  );
}


unpackTo(_o: ContainerBinaryEncodingT): void {
  _o.ERROR_DETECTION = this.ERROR_DETECTION();
  _o.CRC_POLYNOMIAL = this.CRC_POLYNOMIAL();
  _o.SIZE_IN_BITS = this.SIZE_IN_BITS();
}
}

export class ContainerBinaryEncodingT implements flatbuffers.IGeneratedObject {
constructor(
  public ERROR_DETECTION: ErrorDetectionType = ErrorDetectionType.NONE,
  public CRC_POLYNOMIAL: string|Uint8Array|null = null,
  public SIZE_IN_BITS: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const CRC_POLYNOMIAL = (this.CRC_POLYNOMIAL !== null ? builder.createString(this.CRC_POLYNOMIAL!) : 0);

  return ContainerBinaryEncoding.createContainerBinaryEncoding(builder,
    this.ERROR_DETECTION,
    CRC_POLYNOMIAL,
    this.SIZE_IN_BITS
  );
}
}
