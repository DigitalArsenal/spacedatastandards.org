// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class AEMSegment implements flatbuffers.IUnpackableObject<AEMSegmentT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):AEMSegment {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsAEMSegment(bb:flatbuffers.ByteBuffer, obj?:AEMSegment):AEMSegment {
  return (obj || new AEMSegment()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsAEMSegment(bb:flatbuffers.ByteBuffer, obj?:AEMSegment):AEMSegment {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new AEMSegment()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

OBJECT_NAME():string|null
OBJECT_NAME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
OBJECT_NAME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

OBJECT_ID():string|null
OBJECT_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
OBJECT_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

REF_FRAME_A():string|null
REF_FRAME_A(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
REF_FRAME_A(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

REF_FRAME_B():string|null
REF_FRAME_B(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
REF_FRAME_B(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

ATTITUDE_DIR():string|null
ATTITUDE_DIR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ATTITUDE_DIR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

TIME_SYSTEM():string|null
TIME_SYSTEM(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
TIME_SYSTEM(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

ATTITUDE_TYPE():string|null
ATTITUDE_TYPE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ATTITUDE_TYPE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

START_TIME():string|null
START_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
START_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

STOP_TIME():string|null
STOP_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
STOP_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Time interval between attitude states in seconds (required).
 */
STEP_SIZE():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Number of components per attitude state.
 * 7 = quaternion + angular rates (Q1, Q2, Q3, QC, RATE_X, RATE_Y, RATE_Z)
 * 4 = quaternion only (Q1, Q2, Q3, QC)
 */
ATTITUDE_COMPONENTS():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 7;
}

/**
 * Attitude data as row-major array of doubles.
 * Layout: [Q1_0, Q2_0, Q3_0, QC_0, RATE_X_0, RATE_Y_0, RATE_Z_0, Q1_1, ...]
 * Time reconstruction: epoch[i] = START_TIME + (i * STEP_SIZE)
 * Length must be divisible by ATTITUDE_COMPONENTS.
 */
ATTITUDE_DATA(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;
}

attitudeDataLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

attitudeDataArray():Float64Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startAEMSegment(builder:flatbuffers.Builder) {
  builder.startObject(12);
}

static addObjectName(builder:flatbuffers.Builder, OBJECT_NAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, OBJECT_NAMEOffset, 0);
}

static addObjectId(builder:flatbuffers.Builder, OBJECT_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, OBJECT_IDOffset, 0);
}

static addRefFrameA(builder:flatbuffers.Builder, REF_FRAME_AOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, REF_FRAME_AOffset, 0);
}

static addRefFrameB(builder:flatbuffers.Builder, REF_FRAME_BOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, REF_FRAME_BOffset, 0);
}

static addAttitudeDir(builder:flatbuffers.Builder, ATTITUDE_DIROffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, ATTITUDE_DIROffset, 0);
}

static addTimeSystem(builder:flatbuffers.Builder, TIME_SYSTEMOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, TIME_SYSTEMOffset, 0);
}

static addAttitudeType(builder:flatbuffers.Builder, ATTITUDE_TYPEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, ATTITUDE_TYPEOffset, 0);
}

static addStartTime(builder:flatbuffers.Builder, START_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, START_TIMEOffset, 0);
}

static addStopTime(builder:flatbuffers.Builder, STOP_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, STOP_TIMEOffset, 0);
}

static addStepSize(builder:flatbuffers.Builder, STEP_SIZE:number) {
  builder.addFieldFloat64(9, STEP_SIZE, 0.0);
}

static addAttitudeComponents(builder:flatbuffers.Builder, ATTITUDE_COMPONENTS:number) {
  builder.addFieldInt8(10, ATTITUDE_COMPONENTS, 7);
}

static addAttitudeData(builder:flatbuffers.Builder, ATTITUDE_DATAOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, ATTITUDE_DATAOffset, 0);
}

static createAttitudeDataVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createAttitudeDataVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createAttitudeDataVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat64(data[i]!);
  }
  return builder.endVector();
}

static startAttitudeDataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static endAEMSegment(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createAEMSegment(builder:flatbuffers.Builder, OBJECT_NAMEOffset:flatbuffers.Offset, OBJECT_IDOffset:flatbuffers.Offset, REF_FRAME_AOffset:flatbuffers.Offset, REF_FRAME_BOffset:flatbuffers.Offset, ATTITUDE_DIROffset:flatbuffers.Offset, TIME_SYSTEMOffset:flatbuffers.Offset, ATTITUDE_TYPEOffset:flatbuffers.Offset, START_TIMEOffset:flatbuffers.Offset, STOP_TIMEOffset:flatbuffers.Offset, STEP_SIZE:number, ATTITUDE_COMPONENTS:number, ATTITUDE_DATAOffset:flatbuffers.Offset):flatbuffers.Offset {
  AEMSegment.startAEMSegment(builder);
  AEMSegment.addObjectName(builder, OBJECT_NAMEOffset);
  AEMSegment.addObjectId(builder, OBJECT_IDOffset);
  AEMSegment.addRefFrameA(builder, REF_FRAME_AOffset);
  AEMSegment.addRefFrameB(builder, REF_FRAME_BOffset);
  AEMSegment.addAttitudeDir(builder, ATTITUDE_DIROffset);
  AEMSegment.addTimeSystem(builder, TIME_SYSTEMOffset);
  AEMSegment.addAttitudeType(builder, ATTITUDE_TYPEOffset);
  AEMSegment.addStartTime(builder, START_TIMEOffset);
  AEMSegment.addStopTime(builder, STOP_TIMEOffset);
  AEMSegment.addStepSize(builder, STEP_SIZE);
  AEMSegment.addAttitudeComponents(builder, ATTITUDE_COMPONENTS);
  AEMSegment.addAttitudeData(builder, ATTITUDE_DATAOffset);
  return AEMSegment.endAEMSegment(builder);
}

unpack(): AEMSegmentT {
  return new AEMSegmentT(
    this.OBJECT_NAME(),
    this.OBJECT_ID(),
    this.REF_FRAME_A(),
    this.REF_FRAME_B(),
    this.ATTITUDE_DIR(),
    this.TIME_SYSTEM(),
    this.ATTITUDE_TYPE(),
    this.START_TIME(),
    this.STOP_TIME(),
    this.STEP_SIZE(),
    this.ATTITUDE_COMPONENTS(),
    this.bb!.createScalarList<number>(this.ATTITUDE_DATA.bind(this), this.attitudeDataLength())
  );
}


unpackTo(_o: AEMSegmentT): void {
  _o.OBJECT_NAME = this.OBJECT_NAME();
  _o.OBJECT_ID = this.OBJECT_ID();
  _o.REF_FRAME_A = this.REF_FRAME_A();
  _o.REF_FRAME_B = this.REF_FRAME_B();
  _o.ATTITUDE_DIR = this.ATTITUDE_DIR();
  _o.TIME_SYSTEM = this.TIME_SYSTEM();
  _o.ATTITUDE_TYPE = this.ATTITUDE_TYPE();
  _o.START_TIME = this.START_TIME();
  _o.STOP_TIME = this.STOP_TIME();
  _o.STEP_SIZE = this.STEP_SIZE();
  _o.ATTITUDE_COMPONENTS = this.ATTITUDE_COMPONENTS();
  _o.ATTITUDE_DATA = this.bb!.createScalarList<number>(this.ATTITUDE_DATA.bind(this), this.attitudeDataLength());
}
}

export class AEMSegmentT implements flatbuffers.IGeneratedObject {
constructor(
  public OBJECT_NAME: string|Uint8Array|null = null,
  public OBJECT_ID: string|Uint8Array|null = null,
  public REF_FRAME_A: string|Uint8Array|null = null,
  public REF_FRAME_B: string|Uint8Array|null = null,
  public ATTITUDE_DIR: string|Uint8Array|null = null,
  public TIME_SYSTEM: string|Uint8Array|null = null,
  public ATTITUDE_TYPE: string|Uint8Array|null = null,
  public START_TIME: string|Uint8Array|null = null,
  public STOP_TIME: string|Uint8Array|null = null,
  public STEP_SIZE: number = 0.0,
  public ATTITUDE_COMPONENTS: number = 7,
  public ATTITUDE_DATA: (number)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const OBJECT_NAME = (this.OBJECT_NAME !== null ? builder.createString(this.OBJECT_NAME!) : 0);
  const OBJECT_ID = (this.OBJECT_ID !== null ? builder.createString(this.OBJECT_ID!) : 0);
  const REF_FRAME_A = (this.REF_FRAME_A !== null ? builder.createString(this.REF_FRAME_A!) : 0);
  const REF_FRAME_B = (this.REF_FRAME_B !== null ? builder.createString(this.REF_FRAME_B!) : 0);
  const ATTITUDE_DIR = (this.ATTITUDE_DIR !== null ? builder.createString(this.ATTITUDE_DIR!) : 0);
  const TIME_SYSTEM = (this.TIME_SYSTEM !== null ? builder.createString(this.TIME_SYSTEM!) : 0);
  const ATTITUDE_TYPE = (this.ATTITUDE_TYPE !== null ? builder.createString(this.ATTITUDE_TYPE!) : 0);
  const START_TIME = (this.START_TIME !== null ? builder.createString(this.START_TIME!) : 0);
  const STOP_TIME = (this.STOP_TIME !== null ? builder.createString(this.STOP_TIME!) : 0);
  const ATTITUDE_DATA = AEMSegment.createAttitudeDataVector(builder, this.ATTITUDE_DATA);

  return AEMSegment.createAEMSegment(builder,
    OBJECT_NAME,
    OBJECT_ID,
    REF_FRAME_A,
    REF_FRAME_B,
    ATTITUDE_DIR,
    TIME_SYSTEM,
    ATTITUDE_TYPE,
    START_TIME,
    STOP_TIME,
    this.STEP_SIZE,
    this.ATTITUDE_COMPONENTS,
    ATTITUDE_DATA
  );
}
}
