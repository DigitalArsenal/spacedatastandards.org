// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * Publish Notification Message
 */
export class PNM implements flatbuffers.IUnpackableObject<PNMT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):PNM {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsPNM(bb:flatbuffers.ByteBuffer, obj?:PNM):PNM {
  return (obj || new PNM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsPNM(bb:flatbuffers.ByteBuffer, obj?:PNM):PNM {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new PNM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$PNM');
}

/**
 * Multiformat Address
 * https://multiformats.io/multiaddr/
 * A universal address format for representing multiple network protocols. Examples include:
 * - /ip4/192.168.1.1/tcp/80 for an IPv4 address with TCP protocol
 * - /ip6zone/x/ip6/::1 for an IPv6 address with a zone
 * - /dns4/example.com for a domain name resolvable only to IPv4 addresses
 * - /ipfs/bafybeiccfclkdtucu6y4yc5cpr6y3yuinr67svmii46v5cfcrkp47ihehy/README.txt -IPFS address w/CID and path to `README.txt`.
 */
multiformatAddress():string|null
multiformatAddress(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
multiformatAddress(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Publish Time OF THE Publish Notification Message
 */
publishTimestamp():string|null
publishTimestamp(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
publishTimestamp(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Concatenated Content Identifier (CID)
 * This field is a unique ID for distributed systems (CID).
 * The CID provides a unique identifier within distributed systems, as detailed at https://github.com/multiformats/cid. 
 */
cid():string|null
cid(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
cid(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * File ID
 * This field is the Name
 */
fileName():string|null
fileName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
fileName(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * File ID
 * This field is the file ID / Standard Type
 */
fileId():string|null
fileId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
fileId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Digital Signature of the CID
 * This is the digital signature of the CID, signed using the specified cryptographic method.
 */
signature():string|null
signature(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
signature(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Timestamp Signature
 * Digital signature of the publish timestamp, using the specified cryptographic method for timestamp verification.
 */
timestampSignature():string|null
timestampSignature(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
timestampSignature(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Type of Cryptographic Signature Used
 * Specifies the type of cryptographic signature used for the SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
 */
signatureType():string|null
signatureType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
signatureType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Type of Cryptographic Signature Used for Timestamp
 * Specifies the type of cryptographic signature used for the TIMESTAMP_SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
 */
timestampSignatureType():string|null
timestampSignatureType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
timestampSignatureType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startPNM(builder:flatbuffers.Builder) {
  builder.startObject(9);
}

static addMultiformatAddress(builder:flatbuffers.Builder, multiformatAddressOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, multiformatAddressOffset, 0);
}

static addPublishTimestamp(builder:flatbuffers.Builder, publishTimestampOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, publishTimestampOffset, 0);
}

static addCid(builder:flatbuffers.Builder, cidOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, cidOffset, 0);
}

static addFileName(builder:flatbuffers.Builder, fileNameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, fileNameOffset, 0);
}

static addFileId(builder:flatbuffers.Builder, fileIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, fileIdOffset, 0);
}

static addSignature(builder:flatbuffers.Builder, signatureOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, signatureOffset, 0);
}

static addTimestampSignature(builder:flatbuffers.Builder, timestampSignatureOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, timestampSignatureOffset, 0);
}

static addSignatureType(builder:flatbuffers.Builder, signatureTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, signatureTypeOffset, 0);
}

static addTimestampSignatureType(builder:flatbuffers.Builder, timestampSignatureTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, timestampSignatureTypeOffset, 0);
}

static endPNM(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishPNMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$PNM');
}

static finishSizePrefixedPNMBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$PNM', true);
}

static createPNM(builder:flatbuffers.Builder, multiformatAddressOffset:flatbuffers.Offset, publishTimestampOffset:flatbuffers.Offset, cidOffset:flatbuffers.Offset, fileNameOffset:flatbuffers.Offset, fileIdOffset:flatbuffers.Offset, signatureOffset:flatbuffers.Offset, timestampSignatureOffset:flatbuffers.Offset, signatureTypeOffset:flatbuffers.Offset, timestampSignatureTypeOffset:flatbuffers.Offset):flatbuffers.Offset {
  PNM.startPNM(builder);
  PNM.addMultiformatAddress(builder, multiformatAddressOffset);
  PNM.addPublishTimestamp(builder, publishTimestampOffset);
  PNM.addCid(builder, cidOffset);
  PNM.addFileName(builder, fileNameOffset);
  PNM.addFileId(builder, fileIdOffset);
  PNM.addSignature(builder, signatureOffset);
  PNM.addTimestampSignature(builder, timestampSignatureOffset);
  PNM.addSignatureType(builder, signatureTypeOffset);
  PNM.addTimestampSignatureType(builder, timestampSignatureTypeOffset);
  return PNM.endPNM(builder);
}

unpack(): PNMT {
  return new PNMT(
    this.multiformatAddress(),
    this.publishTimestamp(),
    this.cid(),
    this.fileName(),
    this.fileId(),
    this.signature(),
    this.timestampSignature(),
    this.signatureType(),
    this.timestampSignatureType()
  );
}


unpackTo(_o: PNMT): void {
  _o.multiformatAddress = this.multiformatAddress();
  _o.publishTimestamp = this.publishTimestamp();
  _o.cid = this.cid();
  _o.fileName = this.fileName();
  _o.fileId = this.fileId();
  _o.signature = this.signature();
  _o.timestampSignature = this.timestampSignature();
  _o.signatureType = this.signatureType();
  _o.timestampSignatureType = this.timestampSignatureType();
}
}

export class PNMT implements flatbuffers.IGeneratedObject {
constructor(
  public multiformatAddress: string|Uint8Array|null = null,
  public publishTimestamp: string|Uint8Array|null = null,
  public cid: string|Uint8Array|null = null,
  public fileName: string|Uint8Array|null = null,
  public fileId: string|Uint8Array|null = null,
  public signature: string|Uint8Array|null = null,
  public timestampSignature: string|Uint8Array|null = null,
  public signatureType: string|Uint8Array|null = null,
  public timestampSignatureType: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const multiformatAddress = (this.multiformatAddress !== null ? builder.createString(this.multiformatAddress!) : 0);
  const publishTimestamp = (this.publishTimestamp !== null ? builder.createString(this.publishTimestamp!) : 0);
  const cid = (this.cid !== null ? builder.createString(this.cid!) : 0);
  const fileName = (this.fileName !== null ? builder.createString(this.fileName!) : 0);
  const fileId = (this.fileId !== null ? builder.createString(this.fileId!) : 0);
  const signature = (this.signature !== null ? builder.createString(this.signature!) : 0);
  const timestampSignature = (this.timestampSignature !== null ? builder.createString(this.timestampSignature!) : 0);
  const signatureType = (this.signatureType !== null ? builder.createString(this.signatureType!) : 0);
  const timestampSignatureType = (this.timestampSignatureType !== null ? builder.createString(this.timestampSignatureType!) : 0);

  return PNM.createPNM(builder,
    multiformatAddress,
    publishTimestamp,
    cid,
    fileName,
    fileId,
    signature,
    timestampSignature,
    signatureType,
    timestampSignatureType
  );
}
}
