// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { CAT, CATT } from './CAT.js';
import { RFM, RFMT } from './RFM.js';
import { covarianceMatrixLine, covarianceMatrixLineT } from './covarianceMatrixLine.js';
import { ephemerisDataLine, ephemerisDataLineT } from './ephemerisDataLine.js';
import { timeSystem } from './timeSystem.js';


/**
 * OEM Ephemeris Data Block
 */
export class ephemerisDataBlock implements flatbuffers.IUnpackableObject<ephemerisDataBlockT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ephemerisDataBlock {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsephemerisDataBlock(bb:flatbuffers.ByteBuffer, obj?:ephemerisDataBlock):ephemerisDataBlock {
  return (obj || new ephemerisDataBlock()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsephemerisDataBlock(bb:flatbuffers.ByteBuffer, obj?:ephemerisDataBlock):ephemerisDataBlock {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ephemerisDataBlock()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * Plain-Text Comment
 */
COMMENT():string|null
COMMENT(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
COMMENT(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Satellite name for the first object
 */
OBJECT(obj?:CAT):CAT|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new CAT()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Origin of reference frame (EARTH, MARS, MOON, etc.)
 */
CENTER_NAME():string|null
CENTER_NAME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
CENTER_NAME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Name of the reference frame (TEME, EME2000, etc.)
 */
REFERENCE_FRAME(obj?:RFM):RFM|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new RFM()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Epoch of reference frame, if not intrinsic to the definition of the reference frame
 */
REFERENCE_FRAME_EPOCH():string|null
REFERENCE_FRAME_EPOCH(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
REFERENCE_FRAME_EPOCH(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Reference frame for the covariance matrix
 */
COV_REFERENCE_FRAME(obj?:RFM):RFM|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? (obj || new RFM()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * Time system used for the orbit state and covariance matrix. (UTC)
 */
TIME_SYSTEM():timeSystem {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : timeSystem.GMST;
}

/**
 * Start of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
 */
START_TIME():string|null
START_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
START_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional start USEABLE time span covered by ephemeris data (ISO 8601)
 */
USEABLE_START_TIME():string|null
USEABLE_START_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
USEABLE_START_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional end of USEABLE time span covered by ephemeris data (ISO 8601)
 */
USEABLE_STOP_TIME():string|null
USEABLE_STOP_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
USEABLE_STOP_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * End of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
 */
STOP_TIME():string|null
STOP_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
STOP_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Recommended interpolation method for ephemeris data (Hermite, Linear, Lagrange, etc.)
 */
INTERPOLATION():string|null
INTERPOLATION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
INTERPOLATION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Recommended interpolation degree for ephemeris data
 */
INTERPOLATION_DEGREE():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * Time interval between ephemeris states in seconds.
 * If > 0: Use compact EPHEMERIS_DATA array (times are implicit).
 * If 0 or omitted: Use EPHEMERIS_DATA_LINES with explicit epochs.
 */
STEP_SIZE():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Number of components per state vector in EPHEMERIS_DATA array.
 * 6 = position + velocity (X, Y, Z, X_DOT, Y_DOT, Z_DOT)
 * 9 = position + velocity + acceleration (adds X_DDOT, Y_DDOT, Z_DDOT)
 * Only used when STEP_SIZE > 0. Default is 6.
 */
STATE_VECTOR_SIZE():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : 6;
}

/**
 * Compact ephemeris data as row-major array of doubles.
 * Only used when STEP_SIZE > 0.
 * Layout: [x0,y0,z0,xdot0,ydot0,zdot0, x1,y1,z1,xdot1,ydot1,zdot1, ...]
 * Units: position in km, velocity in km/s, acceleration in km/sÂ²
 * Length must be divisible by STATE_VECTOR_SIZE.
 * Number of states = length(EPHEMERIS_DATA) / STATE_VECTOR_SIZE
 */
EPHEMERIS_DATA(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;
}

ephemerisDataLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

ephemerisDataArray():Float64Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Array of ephemeris data lines with explicit epochs.
 * Only used when STEP_SIZE == 0 or omitted (non-uniform time steps).
 * Each line contains its own EPOCH timestamp.
 */
EPHEMERIS_DATA_LINES(index: number, obj?:ephemerisDataLine):ephemerisDataLine|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? (obj || new ephemerisDataLine()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

ephemerisDataLinesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of covariance matrix lines (optional)
 */
COVARIANCE_MATRIX_LINES(index: number, obj?:covarianceMatrixLine):covarianceMatrixLine|null {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? (obj || new covarianceMatrixLine()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

covarianceMatrixLinesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startephemerisDataBlock(builder:flatbuffers.Builder) {
  builder.startObject(18);
}

static addComment(builder:flatbuffers.Builder, COMMENTOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, COMMENTOffset, 0);
}

static addObject(builder:flatbuffers.Builder, OBJECTOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, OBJECTOffset, 0);
}

static addCenterName(builder:flatbuffers.Builder, CENTER_NAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, CENTER_NAMEOffset, 0);
}

static addReferenceFrame(builder:flatbuffers.Builder, REFERENCE_FRAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, REFERENCE_FRAMEOffset, 0);
}

static addReferenceFrameEpoch(builder:flatbuffers.Builder, REFERENCE_FRAME_EPOCHOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, REFERENCE_FRAME_EPOCHOffset, 0);
}

static addCovReferenceFrame(builder:flatbuffers.Builder, COV_REFERENCE_FRAMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, COV_REFERENCE_FRAMEOffset, 0);
}

static addTimeSystem(builder:flatbuffers.Builder, TIME_SYSTEM:timeSystem) {
  builder.addFieldInt8(6, TIME_SYSTEM, timeSystem.GMST);
}

static addStartTime(builder:flatbuffers.Builder, START_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, START_TIMEOffset, 0);
}

static addUseableStartTime(builder:flatbuffers.Builder, USEABLE_START_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, USEABLE_START_TIMEOffset, 0);
}

static addUseableStopTime(builder:flatbuffers.Builder, USEABLE_STOP_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, USEABLE_STOP_TIMEOffset, 0);
}

static addStopTime(builder:flatbuffers.Builder, STOP_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, STOP_TIMEOffset, 0);
}

static addInterpolation(builder:flatbuffers.Builder, INTERPOLATIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, INTERPOLATIONOffset, 0);
}

static addInterpolationDegree(builder:flatbuffers.Builder, INTERPOLATION_DEGREE:number) {
  builder.addFieldInt32(12, INTERPOLATION_DEGREE, 0);
}

static addStepSize(builder:flatbuffers.Builder, STEP_SIZE:number) {
  builder.addFieldFloat64(13, STEP_SIZE, 0.0);
}

static addStateVectorSize(builder:flatbuffers.Builder, STATE_VECTOR_SIZE:number) {
  builder.addFieldInt8(14, STATE_VECTOR_SIZE, 6);
}

static addEphemerisData(builder:flatbuffers.Builder, EPHEMERIS_DATAOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, EPHEMERIS_DATAOffset, 0);
}

static createEphemerisDataVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createEphemerisDataVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createEphemerisDataVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat64(data[i]!);
  }
  return builder.endVector();
}

static startEphemerisDataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static addEphemerisDataLines(builder:flatbuffers.Builder, EPHEMERIS_DATA_LINESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, EPHEMERIS_DATA_LINESOffset, 0);
}

static createEphemerisDataLinesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEphemerisDataLinesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addCovarianceMatrixLines(builder:flatbuffers.Builder, COVARIANCE_MATRIX_LINESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(17, COVARIANCE_MATRIX_LINESOffset, 0);
}

static createCovarianceMatrixLinesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startCovarianceMatrixLinesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endephemerisDataBlock(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}


unpack(): ephemerisDataBlockT {
  return new ephemerisDataBlockT(
    this.COMMENT(),
    (this.OBJECT() !== null ? this.OBJECT()!.unpack() : null),
    this.CENTER_NAME(),
    (this.REFERENCE_FRAME() !== null ? this.REFERENCE_FRAME()!.unpack() : null),
    this.REFERENCE_FRAME_EPOCH(),
    (this.COV_REFERENCE_FRAME() !== null ? this.COV_REFERENCE_FRAME()!.unpack() : null),
    this.TIME_SYSTEM(),
    this.START_TIME(),
    this.USEABLE_START_TIME(),
    this.USEABLE_STOP_TIME(),
    this.STOP_TIME(),
    this.INTERPOLATION(),
    this.INTERPOLATION_DEGREE(),
    this.STEP_SIZE(),
    this.STATE_VECTOR_SIZE(),
    this.bb!.createScalarList<number>(this.EPHEMERIS_DATA.bind(this), this.ephemerisDataLength()),
    this.bb!.createObjList<ephemerisDataLine, ephemerisDataLineT>(this.EPHEMERIS_DATA_LINES.bind(this), this.ephemerisDataLinesLength()),
    this.bb!.createObjList<covarianceMatrixLine, covarianceMatrixLineT>(this.COVARIANCE_MATRIX_LINES.bind(this), this.covarianceMatrixLinesLength())
  );
}


unpackTo(_o: ephemerisDataBlockT): void {
  _o.COMMENT = this.COMMENT();
  _o.OBJECT = (this.OBJECT() !== null ? this.OBJECT()!.unpack() : null);
  _o.CENTER_NAME = this.CENTER_NAME();
  _o.REFERENCE_FRAME = (this.REFERENCE_FRAME() !== null ? this.REFERENCE_FRAME()!.unpack() : null);
  _o.REFERENCE_FRAME_EPOCH = this.REFERENCE_FRAME_EPOCH();
  _o.COV_REFERENCE_FRAME = (this.COV_REFERENCE_FRAME() !== null ? this.COV_REFERENCE_FRAME()!.unpack() : null);
  _o.TIME_SYSTEM = this.TIME_SYSTEM();
  _o.START_TIME = this.START_TIME();
  _o.USEABLE_START_TIME = this.USEABLE_START_TIME();
  _o.USEABLE_STOP_TIME = this.USEABLE_STOP_TIME();
  _o.STOP_TIME = this.STOP_TIME();
  _o.INTERPOLATION = this.INTERPOLATION();
  _o.INTERPOLATION_DEGREE = this.INTERPOLATION_DEGREE();
  _o.STEP_SIZE = this.STEP_SIZE();
  _o.STATE_VECTOR_SIZE = this.STATE_VECTOR_SIZE();
  _o.EPHEMERIS_DATA = this.bb!.createScalarList<number>(this.EPHEMERIS_DATA.bind(this), this.ephemerisDataLength());
  _o.EPHEMERIS_DATA_LINES = this.bb!.createObjList<ephemerisDataLine, ephemerisDataLineT>(this.EPHEMERIS_DATA_LINES.bind(this), this.ephemerisDataLinesLength());
  _o.COVARIANCE_MATRIX_LINES = this.bb!.createObjList<covarianceMatrixLine, covarianceMatrixLineT>(this.COVARIANCE_MATRIX_LINES.bind(this), this.covarianceMatrixLinesLength());
}
}

export class ephemerisDataBlockT implements flatbuffers.IGeneratedObject {
constructor(
  public COMMENT: string|Uint8Array|null = null,
  public OBJECT: CATT|null = null,
  public CENTER_NAME: string|Uint8Array|null = null,
  public REFERENCE_FRAME: RFMT|null = null,
  public REFERENCE_FRAME_EPOCH: string|Uint8Array|null = null,
  public COV_REFERENCE_FRAME: RFMT|null = null,
  public TIME_SYSTEM: timeSystem = timeSystem.GMST,
  public START_TIME: string|Uint8Array|null = null,
  public USEABLE_START_TIME: string|Uint8Array|null = null,
  public USEABLE_STOP_TIME: string|Uint8Array|null = null,
  public STOP_TIME: string|Uint8Array|null = null,
  public INTERPOLATION: string|Uint8Array|null = null,
  public INTERPOLATION_DEGREE: number = 0,
  public STEP_SIZE: number = 0.0,
  public STATE_VECTOR_SIZE: number = 6,
  public EPHEMERIS_DATA: (number)[] = [],
  public EPHEMERIS_DATA_LINES: (ephemerisDataLineT)[] = [],
  public COVARIANCE_MATRIX_LINES: (covarianceMatrixLineT)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const COMMENT = (this.COMMENT !== null ? builder.createString(this.COMMENT!) : 0);
  const OBJECT = (this.OBJECT !== null ? this.OBJECT!.pack(builder) : 0);
  const CENTER_NAME = (this.CENTER_NAME !== null ? builder.createString(this.CENTER_NAME!) : 0);
  const REFERENCE_FRAME = (this.REFERENCE_FRAME !== null ? this.REFERENCE_FRAME!.pack(builder) : 0);
  const REFERENCE_FRAME_EPOCH = (this.REFERENCE_FRAME_EPOCH !== null ? builder.createString(this.REFERENCE_FRAME_EPOCH!) : 0);
  const COV_REFERENCE_FRAME = (this.COV_REFERENCE_FRAME !== null ? this.COV_REFERENCE_FRAME!.pack(builder) : 0);
  const START_TIME = (this.START_TIME !== null ? builder.createString(this.START_TIME!) : 0);
  const USEABLE_START_TIME = (this.USEABLE_START_TIME !== null ? builder.createString(this.USEABLE_START_TIME!) : 0);
  const USEABLE_STOP_TIME = (this.USEABLE_STOP_TIME !== null ? builder.createString(this.USEABLE_STOP_TIME!) : 0);
  const STOP_TIME = (this.STOP_TIME !== null ? builder.createString(this.STOP_TIME!) : 0);
  const INTERPOLATION = (this.INTERPOLATION !== null ? builder.createString(this.INTERPOLATION!) : 0);
  const EPHEMERIS_DATA = ephemerisDataBlock.createEphemerisDataVector(builder, this.EPHEMERIS_DATA);
  const EPHEMERIS_DATA_LINES = ephemerisDataBlock.createEphemerisDataLinesVector(builder, builder.createObjectOffsetList(this.EPHEMERIS_DATA_LINES));
  const COVARIANCE_MATRIX_LINES = ephemerisDataBlock.createCovarianceMatrixLinesVector(builder, builder.createObjectOffsetList(this.COVARIANCE_MATRIX_LINES));

  ephemerisDataBlock.startephemerisDataBlock(builder);
  ephemerisDataBlock.addComment(builder, COMMENT);
  ephemerisDataBlock.addObject(builder, OBJECT);
  ephemerisDataBlock.addCenterName(builder, CENTER_NAME);
  ephemerisDataBlock.addReferenceFrame(builder, REFERENCE_FRAME);
  ephemerisDataBlock.addReferenceFrameEpoch(builder, REFERENCE_FRAME_EPOCH);
  ephemerisDataBlock.addCovReferenceFrame(builder, COV_REFERENCE_FRAME);
  ephemerisDataBlock.addTimeSystem(builder, this.TIME_SYSTEM);
  ephemerisDataBlock.addStartTime(builder, START_TIME);
  ephemerisDataBlock.addUseableStartTime(builder, USEABLE_START_TIME);
  ephemerisDataBlock.addUseableStopTime(builder, USEABLE_STOP_TIME);
  ephemerisDataBlock.addStopTime(builder, STOP_TIME);
  ephemerisDataBlock.addInterpolation(builder, INTERPOLATION);
  ephemerisDataBlock.addInterpolationDegree(builder, this.INTERPOLATION_DEGREE);
  ephemerisDataBlock.addStepSize(builder, this.STEP_SIZE);
  ephemerisDataBlock.addStateVectorSize(builder, this.STATE_VECTOR_SIZE);
  ephemerisDataBlock.addEphemerisData(builder, EPHEMERIS_DATA);
  ephemerisDataBlock.addEphemerisDataLines(builder, EPHEMERIS_DATA_LINES);
  ephemerisDataBlock.addCovarianceMatrixLines(builder, COVARIANCE_MATRIX_LINES);

  return ephemerisDataBlock.endephemerisDataBlock(builder);
}
}
