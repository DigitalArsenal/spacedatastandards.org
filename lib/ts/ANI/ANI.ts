// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { analyticType } from './analyticType.js';


/**
 * Analytic Imagery Product
 */
export class ANI implements flatbuffers.IUnpackableObject<ANIT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ANI {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsANI(bb:flatbuffers.ByteBuffer, obj?:ANI):ANI {
  return (obj || new ANI()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsANI(bb:flatbuffers.ByteBuffer, obj?:ANI):ANI {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ANI()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('$ANI');
}

/**
 * Unique identifier
 */
ID():string|null
ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Reference to source imagery (e.g., SKI, GDI, EOO)
 */
SOURCE_ID():string|null
SOURCE_ID(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SOURCE_ID(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Source imagery type
 */
SOURCE_TYPE():string|null
SOURCE_TYPE(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
SOURCE_TYPE(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Analytic product type
 */
ANALYTIC_TYPE():analyticType {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : analyticType.SPECTRAL;
}

/**
 * Processing algorithm or pipeline name
 */
ALGORITHM():string|null
ALGORITHM(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ALGORITHM(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Algorithm version
 */
ALGORITHM_VERSION():string|null
ALGORITHM_VERSION(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ALGORITHM_VERSION(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Processing epoch (ISO 8601)
 */
PROCESSING_TIME():string|null
PROCESSING_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
PROCESSING_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Original observation epoch (ISO 8601)
 */
OBS_TIME():string|null
OBS_TIME(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
OBS_TIME(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Target satellite number (if applicable)
 */
SAT_NO():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * Target object designator
 */
OBJECT_DESIGNATOR():string|null
OBJECT_DESIGNATOR(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
OBJECT_DESIGNATOR(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Center right ascension in degrees
 */
RA():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Center declination in degrees
 */
DEC():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Field of view in degrees
 */
FOV():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Visual magnitude estimate
 */
VISUAL_MAG():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Magnitude uncertainty
 */
MAG_UNCERTAINTY():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Detected object count
 */
OBJECT_COUNT():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

/**
 * Classification labels
 */
LABELS(index: number):string
LABELS(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
LABELS(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

labelsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Classification confidence scores (0.0-1.0)
 */
CONFIDENCE(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;
}

confidenceLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

confidenceArray():Float64Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Feature vector or extracted parameters
 */
FEATURES(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;
}

featuresLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

featuresArray():Float64Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

/**
 * Quality score (0.0-1.0)
 */
QUALITY():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Additional notes
 */
NOTES():string|null
NOTES(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
NOTES(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startANI(builder:flatbuffers.Builder) {
  builder.startObject(21);
}

static addId(builder:flatbuffers.Builder, IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, IDOffset, 0);
}

static addSourceId(builder:flatbuffers.Builder, SOURCE_IDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, SOURCE_IDOffset, 0);
}

static addSourceType(builder:flatbuffers.Builder, SOURCE_TYPEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, SOURCE_TYPEOffset, 0);
}

static addAnalyticType(builder:flatbuffers.Builder, ANALYTIC_TYPE:analyticType) {
  builder.addFieldInt8(3, ANALYTIC_TYPE, analyticType.SPECTRAL);
}

static addAlgorithm(builder:flatbuffers.Builder, ALGORITHMOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, ALGORITHMOffset, 0);
}

static addAlgorithmVersion(builder:flatbuffers.Builder, ALGORITHM_VERSIONOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, ALGORITHM_VERSIONOffset, 0);
}

static addProcessingTime(builder:flatbuffers.Builder, PROCESSING_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, PROCESSING_TIMEOffset, 0);
}

static addObsTime(builder:flatbuffers.Builder, OBS_TIMEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, OBS_TIMEOffset, 0);
}

static addSatNo(builder:flatbuffers.Builder, SAT_NO:number) {
  builder.addFieldInt32(8, SAT_NO, 0);
}

static addObjectDesignator(builder:flatbuffers.Builder, OBJECT_DESIGNATOROffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, OBJECT_DESIGNATOROffset, 0);
}

static addRa(builder:flatbuffers.Builder, RA:number) {
  builder.addFieldFloat64(10, RA, 0.0);
}

static addDec(builder:flatbuffers.Builder, DEC:number) {
  builder.addFieldFloat64(11, DEC, 0.0);
}

static addFov(builder:flatbuffers.Builder, FOV:number) {
  builder.addFieldFloat64(12, FOV, 0.0);
}

static addVisualMag(builder:flatbuffers.Builder, VISUAL_MAG:number) {
  builder.addFieldFloat64(13, VISUAL_MAG, 0.0);
}

static addMagUncertainty(builder:flatbuffers.Builder, MAG_UNCERTAINTY:number) {
  builder.addFieldFloat64(14, MAG_UNCERTAINTY, 0.0);
}

static addObjectCount(builder:flatbuffers.Builder, OBJECT_COUNT:number) {
  builder.addFieldInt32(15, OBJECT_COUNT, 0);
}

static addLabels(builder:flatbuffers.Builder, LABELSOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, LABELSOffset, 0);
}

static createLabelsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startLabelsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addConfidence(builder:flatbuffers.Builder, CONFIDENCEOffset:flatbuffers.Offset) {
  builder.addFieldOffset(17, CONFIDENCEOffset, 0);
}

static createConfidenceVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createConfidenceVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createConfidenceVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat64(data[i]!);
  }
  return builder.endVector();
}

static startConfidenceVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static addFeatures(builder:flatbuffers.Builder, FEATURESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(18, FEATURESOffset, 0);
}

static createFeaturesVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createFeaturesVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createFeaturesVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat64(data[i]!);
  }
  return builder.endVector();
}

static startFeaturesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static addQuality(builder:flatbuffers.Builder, QUALITY:number) {
  builder.addFieldFloat64(19, QUALITY, 0.0);
}

static addNotes(builder:flatbuffers.Builder, NOTESOffset:flatbuffers.Offset) {
  builder.addFieldOffset(20, NOTESOffset, 0);
}

static endANI(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishANIBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$ANI');
}

static finishSizePrefixedANIBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, '$ANI', true);
}

static createANI(builder:flatbuffers.Builder, IDOffset:flatbuffers.Offset, SOURCE_IDOffset:flatbuffers.Offset, SOURCE_TYPEOffset:flatbuffers.Offset, ANALYTIC_TYPE:analyticType, ALGORITHMOffset:flatbuffers.Offset, ALGORITHM_VERSIONOffset:flatbuffers.Offset, PROCESSING_TIMEOffset:flatbuffers.Offset, OBS_TIMEOffset:flatbuffers.Offset, SAT_NO:number, OBJECT_DESIGNATOROffset:flatbuffers.Offset, RA:number, DEC:number, FOV:number, VISUAL_MAG:number, MAG_UNCERTAINTY:number, OBJECT_COUNT:number, LABELSOffset:flatbuffers.Offset, CONFIDENCEOffset:flatbuffers.Offset, FEATURESOffset:flatbuffers.Offset, QUALITY:number, NOTESOffset:flatbuffers.Offset):flatbuffers.Offset {
  ANI.startANI(builder);
  ANI.addId(builder, IDOffset);
  ANI.addSourceId(builder, SOURCE_IDOffset);
  ANI.addSourceType(builder, SOURCE_TYPEOffset);
  ANI.addAnalyticType(builder, ANALYTIC_TYPE);
  ANI.addAlgorithm(builder, ALGORITHMOffset);
  ANI.addAlgorithmVersion(builder, ALGORITHM_VERSIONOffset);
  ANI.addProcessingTime(builder, PROCESSING_TIMEOffset);
  ANI.addObsTime(builder, OBS_TIMEOffset);
  ANI.addSatNo(builder, SAT_NO);
  ANI.addObjectDesignator(builder, OBJECT_DESIGNATOROffset);
  ANI.addRa(builder, RA);
  ANI.addDec(builder, DEC);
  ANI.addFov(builder, FOV);
  ANI.addVisualMag(builder, VISUAL_MAG);
  ANI.addMagUncertainty(builder, MAG_UNCERTAINTY);
  ANI.addObjectCount(builder, OBJECT_COUNT);
  ANI.addLabels(builder, LABELSOffset);
  ANI.addConfidence(builder, CONFIDENCEOffset);
  ANI.addFeatures(builder, FEATURESOffset);
  ANI.addQuality(builder, QUALITY);
  ANI.addNotes(builder, NOTESOffset);
  return ANI.endANI(builder);
}

unpack(): ANIT {
  return new ANIT(
    this.ID(),
    this.SOURCE_ID(),
    this.SOURCE_TYPE(),
    this.ANALYTIC_TYPE(),
    this.ALGORITHM(),
    this.ALGORITHM_VERSION(),
    this.PROCESSING_TIME(),
    this.OBS_TIME(),
    this.SAT_NO(),
    this.OBJECT_DESIGNATOR(),
    this.RA(),
    this.DEC(),
    this.FOV(),
    this.VISUAL_MAG(),
    this.MAG_UNCERTAINTY(),
    this.OBJECT_COUNT(),
    this.bb!.createScalarList<string>(this.LABELS.bind(this), this.labelsLength()),
    this.bb!.createScalarList<number>(this.CONFIDENCE.bind(this), this.confidenceLength()),
    this.bb!.createScalarList<number>(this.FEATURES.bind(this), this.featuresLength()),
    this.QUALITY(),
    this.NOTES()
  );
}


unpackTo(_o: ANIT): void {
  _o.ID = this.ID();
  _o.SOURCE_ID = this.SOURCE_ID();
  _o.SOURCE_TYPE = this.SOURCE_TYPE();
  _o.ANALYTIC_TYPE = this.ANALYTIC_TYPE();
  _o.ALGORITHM = this.ALGORITHM();
  _o.ALGORITHM_VERSION = this.ALGORITHM_VERSION();
  _o.PROCESSING_TIME = this.PROCESSING_TIME();
  _o.OBS_TIME = this.OBS_TIME();
  _o.SAT_NO = this.SAT_NO();
  _o.OBJECT_DESIGNATOR = this.OBJECT_DESIGNATOR();
  _o.RA = this.RA();
  _o.DEC = this.DEC();
  _o.FOV = this.FOV();
  _o.VISUAL_MAG = this.VISUAL_MAG();
  _o.MAG_UNCERTAINTY = this.MAG_UNCERTAINTY();
  _o.OBJECT_COUNT = this.OBJECT_COUNT();
  _o.LABELS = this.bb!.createScalarList<string>(this.LABELS.bind(this), this.labelsLength());
  _o.CONFIDENCE = this.bb!.createScalarList<number>(this.CONFIDENCE.bind(this), this.confidenceLength());
  _o.FEATURES = this.bb!.createScalarList<number>(this.FEATURES.bind(this), this.featuresLength());
  _o.QUALITY = this.QUALITY();
  _o.NOTES = this.NOTES();
}
}

export class ANIT implements flatbuffers.IGeneratedObject {
constructor(
  public ID: string|Uint8Array|null = null,
  public SOURCE_ID: string|Uint8Array|null = null,
  public SOURCE_TYPE: string|Uint8Array|null = null,
  public ANALYTIC_TYPE: analyticType = analyticType.SPECTRAL,
  public ALGORITHM: string|Uint8Array|null = null,
  public ALGORITHM_VERSION: string|Uint8Array|null = null,
  public PROCESSING_TIME: string|Uint8Array|null = null,
  public OBS_TIME: string|Uint8Array|null = null,
  public SAT_NO: number = 0,
  public OBJECT_DESIGNATOR: string|Uint8Array|null = null,
  public RA: number = 0.0,
  public DEC: number = 0.0,
  public FOV: number = 0.0,
  public VISUAL_MAG: number = 0.0,
  public MAG_UNCERTAINTY: number = 0.0,
  public OBJECT_COUNT: number = 0,
  public LABELS: (string)[] = [],
  public CONFIDENCE: (number)[] = [],
  public FEATURES: (number)[] = [],
  public QUALITY: number = 0.0,
  public NOTES: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const ID = (this.ID !== null ? builder.createString(this.ID!) : 0);
  const SOURCE_ID = (this.SOURCE_ID !== null ? builder.createString(this.SOURCE_ID!) : 0);
  const SOURCE_TYPE = (this.SOURCE_TYPE !== null ? builder.createString(this.SOURCE_TYPE!) : 0);
  const ALGORITHM = (this.ALGORITHM !== null ? builder.createString(this.ALGORITHM!) : 0);
  const ALGORITHM_VERSION = (this.ALGORITHM_VERSION !== null ? builder.createString(this.ALGORITHM_VERSION!) : 0);
  const PROCESSING_TIME = (this.PROCESSING_TIME !== null ? builder.createString(this.PROCESSING_TIME!) : 0);
  const OBS_TIME = (this.OBS_TIME !== null ? builder.createString(this.OBS_TIME!) : 0);
  const OBJECT_DESIGNATOR = (this.OBJECT_DESIGNATOR !== null ? builder.createString(this.OBJECT_DESIGNATOR!) : 0);
  const LABELS = ANI.createLabelsVector(builder, builder.createObjectOffsetList(this.LABELS));
  const CONFIDENCE = ANI.createConfidenceVector(builder, this.CONFIDENCE);
  const FEATURES = ANI.createFeaturesVector(builder, this.FEATURES);
  const NOTES = (this.NOTES !== null ? builder.createString(this.NOTES!) : 0);

  return ANI.createANI(builder,
    ID,
    SOURCE_ID,
    SOURCE_TYPE,
    this.ANALYTIC_TYPE,
    ALGORITHM,
    ALGORITHM_VERSION,
    PROCESSING_TIME,
    OBS_TIME,
    this.SAT_NO,
    OBJECT_DESIGNATOR,
    this.RA,
    this.DEC,
    this.FOV,
    this.VISUAL_MAG,
    this.MAG_UNCERTAINTY,
    this.OBJECT_COUNT,
    LABELS,
    CONFIDENCE,
    FEATURES,
    this.QUALITY,
    NOTES
  );
}
}
