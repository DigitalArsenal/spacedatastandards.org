// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package MFE

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Manifold Element Set
type MFE struct {
	_tab flatbuffers.Table
}

const MFEIdentifier = "$MFE"

func GetRootAsMFE(buf []byte, offset flatbuffers.UOffsetT) *MFE {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MFE{}
	x.Init(buf, n+offset)
	return x
}

func FinishMFEBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(MFEIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func MFEBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, MFEIdentifier)
}

func GetSizePrefixedRootAsMFE(buf []byte, offset flatbuffers.UOffsetT) *MFE {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &MFE{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedMFEBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(MFEIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedMFEBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, MFEIdentifier)
}

func (rcv *MFE) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MFE) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *MFE) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MFE) TMP_SAT_NO() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MFE) MutateTMP_SAT_NO(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *MFE) EPOCH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MFE) MEAN_MOTION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutateMEAN_MOTION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

func (rcv *MFE) ECCENTRICITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutateECCENTRICITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

func (rcv *MFE) INCLINATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutateINCLINATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

func (rcv *MFE) RAAN() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutateRAAN(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

func (rcv *MFE) ARG_OF_PERIGEE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutateARG_OF_PERIGEE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

func (rcv *MFE) MEAN_ANOMALY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutateMEAN_ANOMALY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

func (rcv *MFE) REV_NO() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MFE) MutateREV_NO(n int32) bool {
	return rcv._tab.MutateInt32Slot(22, n)
}

func (rcv *MFE) B_STAR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutateB_STAR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

func (rcv *MFE) MEAN_MOTION_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutateMEAN_MOTION_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

func (rcv *MFE) MEAN_MOTION_DDOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutateMEAN_MOTION_DDOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

func (rcv *MFE) SEMI_MAJOR_AXIS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutateSEMI_MAJOR_AXIS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(30, n)
}

func (rcv *MFE) PERIOD() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutatePERIOD(n float64) bool {
	return rcv._tab.MutateFloat64Slot(32, n)
}

func (rcv *MFE) APOGEE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutateAPOGEE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(34, n)
}

func (rcv *MFE) PERIGEE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MFE) MutatePERIGEE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(36, n)
}

func (rcv *MFE) LINE1() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MFE) LINE2() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func MFEStart(builder *flatbuffers.Builder) {
	builder.StartObject(19)
}
func MFEAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func MFEAddTMP_SAT_NO(builder *flatbuffers.Builder, TMP_SAT_NO int32) {
	builder.PrependInt32Slot(1, TMP_SAT_NO, 0)
}
func MFEAddEPOCH(builder *flatbuffers.Builder, EPOCH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(EPOCH), 0)
}
func MFEAddMEAN_MOTION(builder *flatbuffers.Builder, MEAN_MOTION float64) {
	builder.PrependFloat64Slot(3, MEAN_MOTION, 0.0)
}
func MFEAddECCENTRICITY(builder *flatbuffers.Builder, ECCENTRICITY float64) {
	builder.PrependFloat64Slot(4, ECCENTRICITY, 0.0)
}
func MFEAddINCLINATION(builder *flatbuffers.Builder, INCLINATION float64) {
	builder.PrependFloat64Slot(5, INCLINATION, 0.0)
}
func MFEAddRAAN(builder *flatbuffers.Builder, RAAN float64) {
	builder.PrependFloat64Slot(6, RAAN, 0.0)
}
func MFEAddARG_OF_PERIGEE(builder *flatbuffers.Builder, ARG_OF_PERIGEE float64) {
	builder.PrependFloat64Slot(7, ARG_OF_PERIGEE, 0.0)
}
func MFEAddMEAN_ANOMALY(builder *flatbuffers.Builder, MEAN_ANOMALY float64) {
	builder.PrependFloat64Slot(8, MEAN_ANOMALY, 0.0)
}
func MFEAddREV_NO(builder *flatbuffers.Builder, REV_NO int32) {
	builder.PrependInt32Slot(9, REV_NO, 0)
}
func MFEAddB_STAR(builder *flatbuffers.Builder, B_STAR float64) {
	builder.PrependFloat64Slot(10, B_STAR, 0.0)
}
func MFEAddMEAN_MOTION_DOT(builder *flatbuffers.Builder, MEAN_MOTION_DOT float64) {
	builder.PrependFloat64Slot(11, MEAN_MOTION_DOT, 0.0)
}
func MFEAddMEAN_MOTION_DDOT(builder *flatbuffers.Builder, MEAN_MOTION_DDOT float64) {
	builder.PrependFloat64Slot(12, MEAN_MOTION_DDOT, 0.0)
}
func MFEAddSEMI_MAJOR_AXIS(builder *flatbuffers.Builder, SEMI_MAJOR_AXIS float64) {
	builder.PrependFloat64Slot(13, SEMI_MAJOR_AXIS, 0.0)
}
func MFEAddPERIOD(builder *flatbuffers.Builder, PERIOD float64) {
	builder.PrependFloat64Slot(14, PERIOD, 0.0)
}
func MFEAddAPOGEE(builder *flatbuffers.Builder, APOGEE float64) {
	builder.PrependFloat64Slot(15, APOGEE, 0.0)
}
func MFEAddPERIGEE(builder *flatbuffers.Builder, PERIGEE float64) {
	builder.PrependFloat64Slot(16, PERIGEE, 0.0)
}
func MFEAddLINE1(builder *flatbuffers.Builder, LINE1 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(LINE1), 0)
}
func MFEAddLINE2(builder *flatbuffers.Builder, LINE2 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(18, flatbuffers.UOffsetT(LINE2), 0)
}
func MFEEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
