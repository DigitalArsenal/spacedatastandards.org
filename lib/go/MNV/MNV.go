// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package MNV

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Spacecraft Maneuver
type MNV struct {
	_tab flatbuffers.Table
}

const MNVIdentifier = "$MNV"

func GetRootAsMNV(buf []byte, offset flatbuffers.UOffsetT) *MNV {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MNV{}
	x.Init(buf, n+offset)
	return x
}

func FinishMNVBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(MNVIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func MNVBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, MNVIdentifier)
}

func GetSizePrefixedRootAsMNV(buf []byte, offset flatbuffers.UOffsetT) *MNV {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &MNV{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedMNVBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(MNVIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedMNVBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, MNVIdentifier)
}

func (rcv *MNV) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MNV) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier
func (rcv *MNV) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier
/// Satellite catalog number
func (rcv *MNV) SAT_NO() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Satellite catalog number
func (rcv *MNV) MutateSAT_NO(n uint32) bool {
	return rcv._tab.MutateUint32Slot(6, n)
}

/// International designator
func (rcv *MNV) ORIG_OBJECT_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// International designator
/// On-orbit reference
func (rcv *MNV) ON_ORBIT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// On-orbit reference
/// Maneuver status
func (rcv *MNV) STATUS() maneuverStatus {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return maneuverStatus(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Maneuver status
func (rcv *MNV) MutateSTATUS(n maneuverStatus) bool {
	return rcv._tab.MutateInt8Slot(12, int8(n))
}

/// Maneuver characterization
func (rcv *MNV) CHARACTERIZATION() maneuverCharacterization {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return maneuverCharacterization(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Maneuver characterization
func (rcv *MNV) MutateCHARACTERIZATION(n maneuverCharacterization) bool {
	return rcv._tab.MutateInt8Slot(14, int8(n))
}

/// Characterization uncertainty (0-1)
func (rcv *MNV) CHARACTERIZATION_UNC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Characterization uncertainty (0-1)
func (rcv *MNV) MutateCHARACTERIZATION_UNC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// Detection report time (ISO 8601)
func (rcv *MNV) REPORT_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Detection report time (ISO 8601)
/// Maneuver start time (ISO 8601)
func (rcv *MNV) EVENT_START_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Maneuver start time (ISO 8601)
/// Maneuver end time (ISO 8601)
func (rcv *MNV) EVENT_END_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Maneuver end time (ISO 8601)
/// Total burn time (seconds)
func (rcv *MNV) TOTAL_BURN_TIME() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Total burn time (seconds)
func (rcv *MNV) MutateTOTAL_BURN_TIME(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// OD fit end time (ISO 8601)
func (rcv *MNV) OD_FIT_END_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// OD fit end time (ISO 8601)
/// Detecting sensor identifier
func (rcv *MNV) ID_SENSOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Detecting sensor identifier
/// Original sensor identifier
func (rcv *MNV) ORIG_SENSOR_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Original sensor identifier
/// Maneuver event identifier
func (rcv *MNV) EVENT_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Maneuver event identifier
/// True if object is uncorrelated
func (rcv *MNV) UCT() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if object is uncorrelated
func (rcv *MNV) MutateUCT(n bool) bool {
	return rcv._tab.MutateBoolSlot(34, n)
}

/// Maneuver detection uncertainty (km)
func (rcv *MNV) MANEUVER_UNC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Maneuver detection uncertainty (km)
func (rcv *MNV) MutateMANEUVER_UNC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(36, n)
}

/// Total delta-V magnitude (km/s)
func (rcv *MNV) DELTA_VEL() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Total delta-V magnitude (km/s)
func (rcv *MNV) MutateDELTA_VEL(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

/// Delta-V along-track/U component (km/s)
func (rcv *MNV) DELTA_VEL_U() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Delta-V along-track/U component (km/s)
func (rcv *MNV) MutateDELTA_VEL_U(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// Delta-V cross-track/V component (km/s)
func (rcv *MNV) DELTA_VEL_V() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Delta-V cross-track/V component (km/s)
func (rcv *MNV) MutateDELTA_VEL_V(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// Delta-V radial/W component (km/s)
func (rcv *MNV) DELTA_VEL_W() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Delta-V radial/W component (km/s)
func (rcv *MNV) MutateDELTA_VEL_W(n float64) bool {
	return rcv._tab.MutateFloat64Slot(44, n)
}

/// Total delta position (km)
func (rcv *MNV) DELTA_POS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Total delta position (km)
func (rcv *MNV) MutateDELTA_POS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(46, n)
}

/// Delta position U component (km)
func (rcv *MNV) DELTA_POS_U() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Delta position U component (km)
func (rcv *MNV) MutateDELTA_POS_U(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

/// Delta position V component (km)
func (rcv *MNV) DELTA_POS_V() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Delta position V component (km)
func (rcv *MNV) MutateDELTA_POS_V(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

/// Delta position W component (km)
func (rcv *MNV) DELTA_POS_W() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Delta position W component (km)
func (rcv *MNV) MutateDELTA_POS_W(n float64) bool {
	return rcv._tab.MutateFloat64Slot(52, n)
}

/// Propellant mass consumed (kg)
func (rcv *MNV) DELTA_MASS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Propellant mass consumed (kg)
func (rcv *MNV) MutateDELTA_MASS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(54, n)
}

/// Pre-maneuver orbital state
func (rcv *MNV) PRE_EVENT(obj *mnvOrbitalState) *mnvOrbitalState {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(mnvOrbitalState)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Pre-maneuver orbital state
/// Post-maneuver orbital state
func (rcv *MNV) POST_EVENT(obj *mnvOrbitalState) *mnvOrbitalState {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(mnvOrbitalState)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Post-maneuver orbital state
/// Post-maneuver mass (kg)
func (rcv *MNV) POST_MASS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Post-maneuver mass (kg)
func (rcv *MNV) MutatePOST_MASS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(60, n)
}

/// Post-maneuver cross-sectional area (m^2)
func (rcv *MNV) POST_AREA() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Post-maneuver cross-sectional area (m^2)
func (rcv *MNV) MutatePOST_AREA(n float64) bool {
	return rcv._tab.MutateFloat64Slot(62, n)
}

/// 6x6 covariance matrix (upper triangle, row-major)
func (rcv *MNV) COV(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *MNV) COVLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// 6x6 covariance matrix (upper triangle, row-major)
func (rcv *MNV) MutateCOV(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// Number of observations used
func (rcv *MNV) NUM_OBS() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of observations used
func (rcv *MNV) MutateNUM_OBS(n uint32) bool {
	return rcv._tab.MutateUint32Slot(66, n)
}

/// State model used
func (rcv *MNV) STATE_MODEL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// State model used
/// State model version
func (rcv *MNV) STATE_MODEL_VERSION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// State model version
func (rcv *MNV) MutateSTATE_MODEL_VERSION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(70, n)
}

/// Number of acceleration profile points
func (rcv *MNV) NUM_ACCEL_POINTS() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of acceleration profile points
func (rcv *MNV) MutateNUM_ACCEL_POINTS(n uint16) bool {
	return rcv._tab.MutateUint16Slot(72, n)
}

/// Acceleration profile times (ISO 8601)
func (rcv *MNV) MNVR_ACCEL_TIMES(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *MNV) MNVR_ACCEL_TIMESLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Acceleration profile times (ISO 8601)
/// Acceleration values (km/s^2, 3 components per point)
func (rcv *MNV) MNVR_ACCELS(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *MNV) MNVR_ACCELSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Acceleration values (km/s^2, 3 components per point)
func (rcv *MNV) MutateMNVR_ACCELS(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// Acceleration uncertainties (km/s^2)
func (rcv *MNV) MNVR_ACCEL_UNCS(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *MNV) MNVR_ACCEL_UNCSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Acceleration uncertainties (km/s^2)
func (rcv *MNV) MutateMNVR_ACCEL_UNCS(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// Description
func (rcv *MNV) DESCRIPTION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Description
/// Event descriptor
func (rcv *MNV) DESCRIPTOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Event descriptor
/// Algorithm used for detection
func (rcv *MNV) ALGORITHM() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Algorithm used for detection
/// Associated tags
func (rcv *MNV) TAGS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *MNV) TAGSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Associated tags
/// Sourced data references
func (rcv *MNV) SOURCED_DATA(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *MNV) SOURCED_DATALength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Sourced data references
/// Sourced data types
func (rcv *MNV) SOURCED_DATA_TYPES() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(90))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Sourced data types
/// Transaction identifier
func (rcv *MNV) TRANSACTION_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(92))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Transaction identifier
func MNVStart(builder *flatbuffers.Builder) {
	builder.StartObject(45)
}
func MNVAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func MNVAddSAT_NO(builder *flatbuffers.Builder, SAT_NO uint32) {
	builder.PrependUint32Slot(1, SAT_NO, 0)
}
func MNVAddORIG_OBJECT_ID(builder *flatbuffers.Builder, ORIG_OBJECT_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(ORIG_OBJECT_ID), 0)
}
func MNVAddON_ORBIT(builder *flatbuffers.Builder, ON_ORBIT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(ON_ORBIT), 0)
}
func MNVAddSTATUS(builder *flatbuffers.Builder, STATUS maneuverStatus) {
	builder.PrependInt8Slot(4, int8(STATUS), 0)
}
func MNVAddCHARACTERIZATION(builder *flatbuffers.Builder, CHARACTERIZATION maneuverCharacterization) {
	builder.PrependInt8Slot(5, int8(CHARACTERIZATION), 0)
}
func MNVAddCHARACTERIZATION_UNC(builder *flatbuffers.Builder, CHARACTERIZATION_UNC float64) {
	builder.PrependFloat64Slot(6, CHARACTERIZATION_UNC, 0.0)
}
func MNVAddREPORT_TIME(builder *flatbuffers.Builder, REPORT_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(REPORT_TIME), 0)
}
func MNVAddEVENT_START_TIME(builder *flatbuffers.Builder, EVENT_START_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(EVENT_START_TIME), 0)
}
func MNVAddEVENT_END_TIME(builder *flatbuffers.Builder, EVENT_END_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(EVENT_END_TIME), 0)
}
func MNVAddTOTAL_BURN_TIME(builder *flatbuffers.Builder, TOTAL_BURN_TIME float64) {
	builder.PrependFloat64Slot(10, TOTAL_BURN_TIME, 0.0)
}
func MNVAddOD_FIT_END_TIME(builder *flatbuffers.Builder, OD_FIT_END_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(OD_FIT_END_TIME), 0)
}
func MNVAddID_SENSOR(builder *flatbuffers.Builder, ID_SENSOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(ID_SENSOR), 0)
}
func MNVAddORIG_SENSOR_ID(builder *flatbuffers.Builder, ORIG_SENSOR_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(ORIG_SENSOR_ID), 0)
}
func MNVAddEVENT_ID(builder *flatbuffers.Builder, EVENT_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(EVENT_ID), 0)
}
func MNVAddUCT(builder *flatbuffers.Builder, UCT bool) {
	builder.PrependBoolSlot(15, UCT, false)
}
func MNVAddMANEUVER_UNC(builder *flatbuffers.Builder, MANEUVER_UNC float64) {
	builder.PrependFloat64Slot(16, MANEUVER_UNC, 0.0)
}
func MNVAddDELTA_VEL(builder *flatbuffers.Builder, DELTA_VEL float64) {
	builder.PrependFloat64Slot(17, DELTA_VEL, 0.0)
}
func MNVAddDELTA_VEL_U(builder *flatbuffers.Builder, DELTA_VEL_U float64) {
	builder.PrependFloat64Slot(18, DELTA_VEL_U, 0.0)
}
func MNVAddDELTA_VEL_V(builder *flatbuffers.Builder, DELTA_VEL_V float64) {
	builder.PrependFloat64Slot(19, DELTA_VEL_V, 0.0)
}
func MNVAddDELTA_VEL_W(builder *flatbuffers.Builder, DELTA_VEL_W float64) {
	builder.PrependFloat64Slot(20, DELTA_VEL_W, 0.0)
}
func MNVAddDELTA_POS(builder *flatbuffers.Builder, DELTA_POS float64) {
	builder.PrependFloat64Slot(21, DELTA_POS, 0.0)
}
func MNVAddDELTA_POS_U(builder *flatbuffers.Builder, DELTA_POS_U float64) {
	builder.PrependFloat64Slot(22, DELTA_POS_U, 0.0)
}
func MNVAddDELTA_POS_V(builder *flatbuffers.Builder, DELTA_POS_V float64) {
	builder.PrependFloat64Slot(23, DELTA_POS_V, 0.0)
}
func MNVAddDELTA_POS_W(builder *flatbuffers.Builder, DELTA_POS_W float64) {
	builder.PrependFloat64Slot(24, DELTA_POS_W, 0.0)
}
func MNVAddDELTA_MASS(builder *flatbuffers.Builder, DELTA_MASS float64) {
	builder.PrependFloat64Slot(25, DELTA_MASS, 0.0)
}
func MNVAddPRE_EVENT(builder *flatbuffers.Builder, PRE_EVENT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(26, flatbuffers.UOffsetT(PRE_EVENT), 0)
}
func MNVAddPOST_EVENT(builder *flatbuffers.Builder, POST_EVENT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(27, flatbuffers.UOffsetT(POST_EVENT), 0)
}
func MNVAddPOST_MASS(builder *flatbuffers.Builder, POST_MASS float64) {
	builder.PrependFloat64Slot(28, POST_MASS, 0.0)
}
func MNVAddPOST_AREA(builder *flatbuffers.Builder, POST_AREA float64) {
	builder.PrependFloat64Slot(29, POST_AREA, 0.0)
}
func MNVAddCOV(builder *flatbuffers.Builder, COV flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(30, flatbuffers.UOffsetT(COV), 0)
}
func MNVStartCOVVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func MNVAddNUM_OBS(builder *flatbuffers.Builder, NUM_OBS uint32) {
	builder.PrependUint32Slot(31, NUM_OBS, 0)
}
func MNVAddSTATE_MODEL(builder *flatbuffers.Builder, STATE_MODEL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(32, flatbuffers.UOffsetT(STATE_MODEL), 0)
}
func MNVAddSTATE_MODEL_VERSION(builder *flatbuffers.Builder, STATE_MODEL_VERSION float64) {
	builder.PrependFloat64Slot(33, STATE_MODEL_VERSION, 0.0)
}
func MNVAddNUM_ACCEL_POINTS(builder *flatbuffers.Builder, NUM_ACCEL_POINTS uint16) {
	builder.PrependUint16Slot(34, NUM_ACCEL_POINTS, 0)
}
func MNVAddMNVR_ACCEL_TIMES(builder *flatbuffers.Builder, MNVR_ACCEL_TIMES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(35, flatbuffers.UOffsetT(MNVR_ACCEL_TIMES), 0)
}
func MNVStartMNVR_ACCEL_TIMESVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MNVAddMNVR_ACCELS(builder *flatbuffers.Builder, MNVR_ACCELS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(36, flatbuffers.UOffsetT(MNVR_ACCELS), 0)
}
func MNVStartMNVR_ACCELSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func MNVAddMNVR_ACCEL_UNCS(builder *flatbuffers.Builder, MNVR_ACCEL_UNCS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(37, flatbuffers.UOffsetT(MNVR_ACCEL_UNCS), 0)
}
func MNVStartMNVR_ACCEL_UNCSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func MNVAddDESCRIPTION(builder *flatbuffers.Builder, DESCRIPTION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(38, flatbuffers.UOffsetT(DESCRIPTION), 0)
}
func MNVAddDESCRIPTOR(builder *flatbuffers.Builder, DESCRIPTOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(39, flatbuffers.UOffsetT(DESCRIPTOR), 0)
}
func MNVAddALGORITHM(builder *flatbuffers.Builder, ALGORITHM flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(40, flatbuffers.UOffsetT(ALGORITHM), 0)
}
func MNVAddTAGS(builder *flatbuffers.Builder, TAGS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(41, flatbuffers.UOffsetT(TAGS), 0)
}
func MNVStartTAGSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MNVAddSOURCED_DATA(builder *flatbuffers.Builder, SOURCED_DATA flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(42, flatbuffers.UOffsetT(SOURCED_DATA), 0)
}
func MNVStartSOURCED_DATAVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MNVAddSOURCED_DATA_TYPES(builder *flatbuffers.Builder, SOURCED_DATA_TYPES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(43, flatbuffers.UOffsetT(SOURCED_DATA_TYPES), 0)
}
func MNVAddTRANSACTION_ID(builder *flatbuffers.Builder, TRANSACTION_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(44, flatbuffers.UOffsetT(TRANSACTION_ID), 0)
}
func MNVEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
