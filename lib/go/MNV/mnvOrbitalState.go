// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package MNV

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Pre/post-maneuver orbital state
type mnvOrbitalState struct {
	_tab flatbuffers.Table
}

func GetRootAsmnvOrbitalState(buf []byte, offset flatbuffers.UOffsetT) *mnvOrbitalState {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &mnvOrbitalState{}
	x.Init(buf, n+offset)
	return x
}

func FinishmnvOrbitalStateBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsmnvOrbitalState(buf []byte, offset flatbuffers.UOffsetT) *mnvOrbitalState {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &mnvOrbitalState{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedmnvOrbitalStateBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *mnvOrbitalState) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *mnvOrbitalState) Table() flatbuffers.Table {
	return rcv._tab
}

/// Element set identifier
func (rcv *mnvOrbitalState) ID_ELSET() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Element set identifier
/// Element set data reference
func (rcv *mnvOrbitalState) ELSET() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Element set data reference
/// State vector identifier
func (rcv *mnvOrbitalState) ID_STATE_VECTOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// State vector identifier
/// State vector data reference
func (rcv *mnvOrbitalState) STATE_VECTOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// State vector data reference
/// Position X (km)
func (rcv *mnvOrbitalState) POS_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Position X (km)
func (rcv *mnvOrbitalState) MutatePOS_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

/// Position Y (km)
func (rcv *mnvOrbitalState) POS_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Position Y (km)
func (rcv *mnvOrbitalState) MutatePOS_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

/// Position Z (km)
func (rcv *mnvOrbitalState) POS_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Position Z (km)
func (rcv *mnvOrbitalState) MutatePOS_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// Velocity X (km/s)
func (rcv *mnvOrbitalState) VEL_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Velocity X (km/s)
func (rcv *mnvOrbitalState) MutateVEL_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

/// Velocity Y (km/s)
func (rcv *mnvOrbitalState) VEL_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Velocity Y (km/s)
func (rcv *mnvOrbitalState) MutateVEL_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

/// Velocity Z (km/s)
func (rcv *mnvOrbitalState) VEL_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Velocity Z (km/s)
func (rcv *mnvOrbitalState) MutateVEL_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

/// Radiation pressure coefficient (Cr)
func (rcv *mnvOrbitalState) RADIATION_PRESS_COEFF() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Radiation pressure coefficient (Cr)
func (rcv *mnvOrbitalState) MutateRADIATION_PRESS_COEFF(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// Ballistic coefficient (m^2/kg)
func (rcv *mnvOrbitalState) BALLISTIC_COEFF() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Ballistic coefficient (m^2/kg)
func (rcv *mnvOrbitalState) MutateBALLISTIC_COEFF(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// Apogee altitude (km)
func (rcv *mnvOrbitalState) APOGEE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Apogee altitude (km)
func (rcv *mnvOrbitalState) MutateAPOGEE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

/// Perigee altitude (km)
func (rcv *mnvOrbitalState) PERIGEE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Perigee altitude (km)
func (rcv *mnvOrbitalState) MutatePERIGEE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(30, n)
}

/// Inclination (degrees)
func (rcv *mnvOrbitalState) INCLINATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Inclination (degrees)
func (rcv *mnvOrbitalState) MutateINCLINATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(32, n)
}

/// Eccentricity
func (rcv *mnvOrbitalState) ECCENTRICITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Eccentricity
func (rcv *mnvOrbitalState) MutateECCENTRICITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(34, n)
}

/// Orbital period (minutes)
func (rcv *mnvOrbitalState) PERIOD() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Orbital period (minutes)
func (rcv *mnvOrbitalState) MutatePERIOD(n float64) bool {
	return rcv._tab.MutateFloat64Slot(36, n)
}

/// Right ascension of ascending node (degrees)
func (rcv *mnvOrbitalState) RAAN() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Right ascension of ascending node (degrees)
func (rcv *mnvOrbitalState) MutateRAAN(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

/// Semi-major axis (km)
func (rcv *mnvOrbitalState) SMA() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Semi-major axis (km)
func (rcv *mnvOrbitalState) MutateSMA(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// GEO longitude (degrees east)
func (rcv *mnvOrbitalState) GEO_LONGITUDE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// GEO longitude (degrees east)
func (rcv *mnvOrbitalState) MutateGEO_LONGITUDE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// Longitude drift rate (degrees/day)
func (rcv *mnvOrbitalState) DRIFT_RATE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Longitude drift rate (degrees/day)
func (rcv *mnvOrbitalState) MutateDRIFT_RATE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(44, n)
}

/// Position uncertainty U (km, 1-sigma)
func (rcv *mnvOrbitalState) SIGMA_U() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Position uncertainty U (km, 1-sigma)
func (rcv *mnvOrbitalState) MutateSIGMA_U(n float64) bool {
	return rcv._tab.MutateFloat64Slot(46, n)
}

/// Position uncertainty V (km, 1-sigma)
func (rcv *mnvOrbitalState) SIGMA_V() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Position uncertainty V (km, 1-sigma)
func (rcv *mnvOrbitalState) MutateSIGMA_V(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

/// Position uncertainty W (km, 1-sigma)
func (rcv *mnvOrbitalState) SIGMA_W() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Position uncertainty W (km, 1-sigma)
func (rcv *mnvOrbitalState) MutateSIGMA_W(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

func mnvOrbitalStateStart(builder *flatbuffers.Builder) {
	builder.StartObject(24)
}
func mnvOrbitalStateAddID_ELSET(builder *flatbuffers.Builder, ID_ELSET flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID_ELSET), 0)
}
func mnvOrbitalStateAddELSET(builder *flatbuffers.Builder, ELSET flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(ELSET), 0)
}
func mnvOrbitalStateAddID_STATE_VECTOR(builder *flatbuffers.Builder, ID_STATE_VECTOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(ID_STATE_VECTOR), 0)
}
func mnvOrbitalStateAddSTATE_VECTOR(builder *flatbuffers.Builder, STATE_VECTOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(STATE_VECTOR), 0)
}
func mnvOrbitalStateAddPOS_X(builder *flatbuffers.Builder, POS_X float64) {
	builder.PrependFloat64Slot(4, POS_X, 0.0)
}
func mnvOrbitalStateAddPOS_Y(builder *flatbuffers.Builder, POS_Y float64) {
	builder.PrependFloat64Slot(5, POS_Y, 0.0)
}
func mnvOrbitalStateAddPOS_Z(builder *flatbuffers.Builder, POS_Z float64) {
	builder.PrependFloat64Slot(6, POS_Z, 0.0)
}
func mnvOrbitalStateAddVEL_X(builder *flatbuffers.Builder, VEL_X float64) {
	builder.PrependFloat64Slot(7, VEL_X, 0.0)
}
func mnvOrbitalStateAddVEL_Y(builder *flatbuffers.Builder, VEL_Y float64) {
	builder.PrependFloat64Slot(8, VEL_Y, 0.0)
}
func mnvOrbitalStateAddVEL_Z(builder *flatbuffers.Builder, VEL_Z float64) {
	builder.PrependFloat64Slot(9, VEL_Z, 0.0)
}
func mnvOrbitalStateAddRADIATION_PRESS_COEFF(builder *flatbuffers.Builder, RADIATION_PRESS_COEFF float64) {
	builder.PrependFloat64Slot(10, RADIATION_PRESS_COEFF, 0.0)
}
func mnvOrbitalStateAddBALLISTIC_COEFF(builder *flatbuffers.Builder, BALLISTIC_COEFF float64) {
	builder.PrependFloat64Slot(11, BALLISTIC_COEFF, 0.0)
}
func mnvOrbitalStateAddAPOGEE(builder *flatbuffers.Builder, APOGEE float64) {
	builder.PrependFloat64Slot(12, APOGEE, 0.0)
}
func mnvOrbitalStateAddPERIGEE(builder *flatbuffers.Builder, PERIGEE float64) {
	builder.PrependFloat64Slot(13, PERIGEE, 0.0)
}
func mnvOrbitalStateAddINCLINATION(builder *flatbuffers.Builder, INCLINATION float64) {
	builder.PrependFloat64Slot(14, INCLINATION, 0.0)
}
func mnvOrbitalStateAddECCENTRICITY(builder *flatbuffers.Builder, ECCENTRICITY float64) {
	builder.PrependFloat64Slot(15, ECCENTRICITY, 0.0)
}
func mnvOrbitalStateAddPERIOD(builder *flatbuffers.Builder, PERIOD float64) {
	builder.PrependFloat64Slot(16, PERIOD, 0.0)
}
func mnvOrbitalStateAddRAAN(builder *flatbuffers.Builder, RAAN float64) {
	builder.PrependFloat64Slot(17, RAAN, 0.0)
}
func mnvOrbitalStateAddSMA(builder *flatbuffers.Builder, SMA float64) {
	builder.PrependFloat64Slot(18, SMA, 0.0)
}
func mnvOrbitalStateAddGEO_LONGITUDE(builder *flatbuffers.Builder, GEO_LONGITUDE float64) {
	builder.PrependFloat64Slot(19, GEO_LONGITUDE, 0.0)
}
func mnvOrbitalStateAddDRIFT_RATE(builder *flatbuffers.Builder, DRIFT_RATE float64) {
	builder.PrependFloat64Slot(20, DRIFT_RATE, 0.0)
}
func mnvOrbitalStateAddSIGMA_U(builder *flatbuffers.Builder, SIGMA_U float64) {
	builder.PrependFloat64Slot(21, SIGMA_U, 0.0)
}
func mnvOrbitalStateAddSIGMA_V(builder *flatbuffers.Builder, SIGMA_V float64) {
	builder.PrependFloat64Slot(22, SIGMA_V, 0.0)
}
func mnvOrbitalStateAddSIGMA_W(builder *flatbuffers.Builder, SIGMA_W float64) {
	builder.PrependFloat64Slot(23, SIGMA_W, 0.0)
}
func mnvOrbitalStateEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
