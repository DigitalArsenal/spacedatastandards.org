// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package CDM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type CDMObject struct {
	_tab flatbuffers.Table
}

func GetRootAsCDMObject(buf []byte, offset flatbuffers.UOffsetT) *CDMObject {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CDMObject{}
	x.Init(buf, n+offset)
	return x
}

func FinishCDMObjectBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsCDMObject(buf []byte, offset flatbuffers.UOffsetT) *CDMObject {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CDMObject{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedCDMObjectBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *CDMObject) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CDMObject) Table() flatbuffers.Table {
	return rcv._tab
}

/// A comment
func (rcv *CDMObject) COMMENT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// A comment
func (rcv *CDMObject) OBJECT(obj *CAT) *CAT {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CAT)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Point of Contact
func (rcv *CDMObject) POC(obj *EPM) *EPM {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(EPM)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Point of Contact
/// Operator contact position
func (rcv *CDMObject) OPERATOR_CONTACT_POSITION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Operator contact position
/// Operator organization
func (rcv *CDMObject) OPERATOR_ORGANIZATION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Operator organization
/// Ephemeris name
func (rcv *CDMObject) EPHEMERIS_NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Ephemeris name
/// Covariance method
func (rcv *CDMObject) COVARIANCE_METHOD() covarianceMethod {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return covarianceMethod(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Covariance method
func (rcv *CDMObject) MutateCOVARIANCE_METHOD(n covarianceMethod) bool {
	return rcv._tab.MutateInt8Slot(16, int8(n))
}

/// Reference Frame in which the object position is defined
func (rcv *CDMObject) REFERENCE_FRAME(obj *RFM) *RFM {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(RFM)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Reference Frame in which the object position is defined
/// Gravity model
func (rcv *CDMObject) GRAVITY_MODEL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Gravity model
/// Atmospheric model
func (rcv *CDMObject) ATMOSPHERIC_MODEL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Atmospheric model
/// N-body perturbations
func (rcv *CDMObject) N_BODY_PERTURBATIONS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// N-body perturbations
/// Solar radiation pressure
func (rcv *CDMObject) SOLAR_RAD_PRESSURE() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Solar radiation pressure
func (rcv *CDMObject) MutateSOLAR_RAD_PRESSURE(n bool) bool {
	return rcv._tab.MutateBoolSlot(26, n)
}

/// Earth tides
func (rcv *CDMObject) EARTH_TIDES() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Earth tides
func (rcv *CDMObject) MutateEARTH_TIDES(n bool) bool {
	return rcv._tab.MutateBoolSlot(28, n)
}

/// Intrack thrust
func (rcv *CDMObject) INTRACK_THRUST() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Intrack thrust
func (rcv *CDMObject) MutateINTRACK_THRUST(n bool) bool {
	return rcv._tab.MutateBoolSlot(30, n)
}

/// Time of last observation start
func (rcv *CDMObject) TIME_LASTOB_START() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time of last observation start
/// Time of last observation end
func (rcv *CDMObject) TIME_LASTOB_END() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time of last observation end
/// Recommended observation data span
func (rcv *CDMObject) RECOMMENDED_OD_SPAN() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Recommended observation data span
func (rcv *CDMObject) MutateRECOMMENDED_OD_SPAN(n float64) bool {
	return rcv._tab.MutateFloat64Slot(36, n)
}

/// Actual observation data span
func (rcv *CDMObject) ACTUAL_OD_SPAN() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Actual observation data span
func (rcv *CDMObject) MutateACTUAL_OD_SPAN(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

/// Number of observations available
func (rcv *CDMObject) OBS_AVAILABLE() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of observations available
func (rcv *CDMObject) MutateOBS_AVAILABLE(n uint32) bool {
	return rcv._tab.MutateUint32Slot(40, n)
}

/// Number of observations used
func (rcv *CDMObject) OBS_USED() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of observations used
func (rcv *CDMObject) MutateOBS_USED(n uint32) bool {
	return rcv._tab.MutateUint32Slot(42, n)
}

/// Number of tracks available
func (rcv *CDMObject) TRACKS_AVAILABLE() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of tracks available
func (rcv *CDMObject) MutateTRACKS_AVAILABLE(n uint32) bool {
	return rcv._tab.MutateUint32Slot(44, n)
}

/// Number of tracks used
func (rcv *CDMObject) TRACKS_USED() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of tracks used
func (rcv *CDMObject) MutateTRACKS_USED(n uint32) bool {
	return rcv._tab.MutateUint32Slot(46, n)
}

/// Residuals accepted
func (rcv *CDMObject) RESIDUALS_ACCEPTED() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Residuals accepted
func (rcv *CDMObject) MutateRESIDUALS_ACCEPTED(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

/// Weighted root mean square
func (rcv *CDMObject) WEIGHTED_RMS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Weighted root mean square
func (rcv *CDMObject) MutateWEIGHTED_RMS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

/// Area of the object
func (rcv *CDMObject) AREA_PC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Area of the object
func (rcv *CDMObject) MutateAREA_PC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(52, n)
}

/// Area of the object drag
func (rcv *CDMObject) AREA_DRG() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Area of the object drag
func (rcv *CDMObject) MutateAREA_DRG(n float64) bool {
	return rcv._tab.MutateFloat64Slot(54, n)
}

/// Area of the object solar radiation pressure
func (rcv *CDMObject) AREA_SRP() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Area of the object solar radiation pressure
func (rcv *CDMObject) MutateAREA_SRP(n float64) bool {
	return rcv._tab.MutateFloat64Slot(56, n)
}

/// Object's area-to-mass ratio
func (rcv *CDMObject) CR_AREA_OVER_MASS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Object's area-to-mass ratio
func (rcv *CDMObject) MutateCR_AREA_OVER_MASS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(58, n)
}

/// Object's thrust acceleration
func (rcv *CDMObject) THRUST_ACCELERATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Object's thrust acceleration
func (rcv *CDMObject) MutateTHRUST_ACCELERATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(60, n)
}

/// Object's solar flux
func (rcv *CDMObject) SEDR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Object's solar flux
func (rcv *CDMObject) MutateSEDR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(62, n)
}

/// X-coordinate of the object's position in RTN coordinates
func (rcv *CDMObject) X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// X-coordinate of the object's position in RTN coordinates
func (rcv *CDMObject) MutateX(n float64) bool {
	return rcv._tab.MutateFloat64Slot(64, n)
}

/// Y-coordinate of the object's position in RTN
func (rcv *CDMObject) Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Y-coordinate of the object's position in RTN
func (rcv *CDMObject) MutateY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(66, n)
}

/// Z-coordinate of the object's position in RTN
func (rcv *CDMObject) Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Z-coordinate of the object's position in RTN
func (rcv *CDMObject) MutateZ(n float64) bool {
	return rcv._tab.MutateFloat64Slot(68, n)
}

/// X-coordinate of the object's position in RTN coordinates
func (rcv *CDMObject) X_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// X-coordinate of the object's position in RTN coordinates
func (rcv *CDMObject) MutateX_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(70, n)
}

/// Y-coordinate of the object's position in RTN
func (rcv *CDMObject) Y_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Y-coordinate of the object's position in RTN
func (rcv *CDMObject) MutateY_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(72, n)
}

/// Z-coordinate of the object's position in RTN
func (rcv *CDMObject) Z_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Z-coordinate of the object's position in RTN
func (rcv *CDMObject) MutateZ_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(74, n)
}

/// Covariance matrix as flat array (9x9 lower triangular = 45 elements).
/// Order: [CR_R, CT_R, CT_T, CN_R, CN_T, CN_N, CRDOT_R, CRDOT_T, CRDOT_N, CRDOT_RDOT,
///         CTDOT_R, CTDOT_T, CTDOT_N, CTDOT_RDOT, CTDOT_TDOT,
///         CNDOT_R, CNDOT_T, CNDOT_N, CNDOT_RDOT, CNDOT_TDOT, CNDOT_NDOT,
///         CDRG_R, CDRG_T, CDRG_N, CDRG_RDOT, CDRG_TDOT, CDRG_NDOT, CDRG_DRG,
///         CSRP_R, CSRP_T, CSRP_N, CSRP_RDOT, CSRP_TDOT, CSRP_NDOT, CSRP_DRG, CSRP_SRP,
///         CTHR_R, CTHR_T, CTHR_N, CTHR_RDOT, CTHR_TDOT, CTHR_NDOT, CTHR_DRG, CTHR_SRP, CTHR_THR]
func (rcv *CDMObject) COVARIANCE(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *CDMObject) COVARIANCELength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Covariance matrix as flat array (9x9 lower triangular = 45 elements).
/// Order: [CR_R, CT_R, CT_T, CN_R, CN_T, CN_N, CRDOT_R, CRDOT_T, CRDOT_N, CRDOT_RDOT,
///         CTDOT_R, CTDOT_T, CTDOT_N, CTDOT_RDOT, CTDOT_TDOT,
///         CNDOT_R, CNDOT_T, CNDOT_N, CNDOT_RDOT, CNDOT_TDOT, CNDOT_NDOT,
///         CDRG_R, CDRG_T, CDRG_N, CDRG_RDOT, CDRG_TDOT, CDRG_NDOT, CDRG_DRG,
///         CSRP_R, CSRP_T, CSRP_N, CSRP_RDOT, CSRP_TDOT, CSRP_NDOT, CSRP_DRG, CSRP_SRP,
///         CTHR_R, CTHR_T, CTHR_N, CTHR_RDOT, CTHR_TDOT, CTHR_NDOT, CTHR_DRG, CTHR_SRP, CTHR_THR]
func (rcv *CDMObject) MutateCOVARIANCE(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func CDMObjectStart(builder *flatbuffers.Builder) {
	builder.StartObject(37)
}
func CDMObjectAddCOMMENT(builder *flatbuffers.Builder, COMMENT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(COMMENT), 0)
}
func CDMObjectAddOBJECT(builder *flatbuffers.Builder, OBJECT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(OBJECT), 0)
}
func CDMObjectAddPOC(builder *flatbuffers.Builder, POC flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(POC), 0)
}
func CDMObjectAddOPERATOR_CONTACT_POSITION(builder *flatbuffers.Builder, OPERATOR_CONTACT_POSITION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(OPERATOR_CONTACT_POSITION), 0)
}
func CDMObjectAddOPERATOR_ORGANIZATION(builder *flatbuffers.Builder, OPERATOR_ORGANIZATION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(OPERATOR_ORGANIZATION), 0)
}
func CDMObjectAddEPHEMERIS_NAME(builder *flatbuffers.Builder, EPHEMERIS_NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(EPHEMERIS_NAME), 0)
}
func CDMObjectAddCOVARIANCE_METHOD(builder *flatbuffers.Builder, COVARIANCE_METHOD covarianceMethod) {
	builder.PrependInt8Slot(6, int8(COVARIANCE_METHOD), 0)
}
func CDMObjectAddREFERENCE_FRAME(builder *flatbuffers.Builder, REFERENCE_FRAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(REFERENCE_FRAME), 0)
}
func CDMObjectAddGRAVITY_MODEL(builder *flatbuffers.Builder, GRAVITY_MODEL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(GRAVITY_MODEL), 0)
}
func CDMObjectAddATMOSPHERIC_MODEL(builder *flatbuffers.Builder, ATMOSPHERIC_MODEL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(ATMOSPHERIC_MODEL), 0)
}
func CDMObjectAddN_BODY_PERTURBATIONS(builder *flatbuffers.Builder, N_BODY_PERTURBATIONS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(N_BODY_PERTURBATIONS), 0)
}
func CDMObjectAddSOLAR_RAD_PRESSURE(builder *flatbuffers.Builder, SOLAR_RAD_PRESSURE bool) {
	builder.PrependBoolSlot(11, SOLAR_RAD_PRESSURE, false)
}
func CDMObjectAddEARTH_TIDES(builder *flatbuffers.Builder, EARTH_TIDES bool) {
	builder.PrependBoolSlot(12, EARTH_TIDES, false)
}
func CDMObjectAddINTRACK_THRUST(builder *flatbuffers.Builder, INTRACK_THRUST bool) {
	builder.PrependBoolSlot(13, INTRACK_THRUST, false)
}
func CDMObjectAddTIME_LASTOB_START(builder *flatbuffers.Builder, TIME_LASTOB_START flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(TIME_LASTOB_START), 0)
}
func CDMObjectAddTIME_LASTOB_END(builder *flatbuffers.Builder, TIME_LASTOB_END flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(TIME_LASTOB_END), 0)
}
func CDMObjectAddRECOMMENDED_OD_SPAN(builder *flatbuffers.Builder, RECOMMENDED_OD_SPAN float64) {
	builder.PrependFloat64Slot(16, RECOMMENDED_OD_SPAN, 0.0)
}
func CDMObjectAddACTUAL_OD_SPAN(builder *flatbuffers.Builder, ACTUAL_OD_SPAN float64) {
	builder.PrependFloat64Slot(17, ACTUAL_OD_SPAN, 0.0)
}
func CDMObjectAddOBS_AVAILABLE(builder *flatbuffers.Builder, OBS_AVAILABLE uint32) {
	builder.PrependUint32Slot(18, OBS_AVAILABLE, 0)
}
func CDMObjectAddOBS_USED(builder *flatbuffers.Builder, OBS_USED uint32) {
	builder.PrependUint32Slot(19, OBS_USED, 0)
}
func CDMObjectAddTRACKS_AVAILABLE(builder *flatbuffers.Builder, TRACKS_AVAILABLE uint32) {
	builder.PrependUint32Slot(20, TRACKS_AVAILABLE, 0)
}
func CDMObjectAddTRACKS_USED(builder *flatbuffers.Builder, TRACKS_USED uint32) {
	builder.PrependUint32Slot(21, TRACKS_USED, 0)
}
func CDMObjectAddRESIDUALS_ACCEPTED(builder *flatbuffers.Builder, RESIDUALS_ACCEPTED float64) {
	builder.PrependFloat64Slot(22, RESIDUALS_ACCEPTED, 0.0)
}
func CDMObjectAddWEIGHTED_RMS(builder *flatbuffers.Builder, WEIGHTED_RMS float64) {
	builder.PrependFloat64Slot(23, WEIGHTED_RMS, 0.0)
}
func CDMObjectAddAREA_PC(builder *flatbuffers.Builder, AREA_PC float64) {
	builder.PrependFloat64Slot(24, AREA_PC, 0.0)
}
func CDMObjectAddAREA_DRG(builder *flatbuffers.Builder, AREA_DRG float64) {
	builder.PrependFloat64Slot(25, AREA_DRG, 0.0)
}
func CDMObjectAddAREA_SRP(builder *flatbuffers.Builder, AREA_SRP float64) {
	builder.PrependFloat64Slot(26, AREA_SRP, 0.0)
}
func CDMObjectAddCR_AREA_OVER_MASS(builder *flatbuffers.Builder, CR_AREA_OVER_MASS float64) {
	builder.PrependFloat64Slot(27, CR_AREA_OVER_MASS, 0.0)
}
func CDMObjectAddTHRUST_ACCELERATION(builder *flatbuffers.Builder, THRUST_ACCELERATION float64) {
	builder.PrependFloat64Slot(28, THRUST_ACCELERATION, 0.0)
}
func CDMObjectAddSEDR(builder *flatbuffers.Builder, SEDR float64) {
	builder.PrependFloat64Slot(29, SEDR, 0.0)
}
func CDMObjectAddX(builder *flatbuffers.Builder, X float64) {
	builder.PrependFloat64Slot(30, X, 0.0)
}
func CDMObjectAddY(builder *flatbuffers.Builder, Y float64) {
	builder.PrependFloat64Slot(31, Y, 0.0)
}
func CDMObjectAddZ(builder *flatbuffers.Builder, Z float64) {
	builder.PrependFloat64Slot(32, Z, 0.0)
}
func CDMObjectAddX_DOT(builder *flatbuffers.Builder, X_DOT float64) {
	builder.PrependFloat64Slot(33, X_DOT, 0.0)
}
func CDMObjectAddY_DOT(builder *flatbuffers.Builder, Y_DOT float64) {
	builder.PrependFloat64Slot(34, Y_DOT, 0.0)
}
func CDMObjectAddZ_DOT(builder *flatbuffers.Builder, Z_DOT float64) {
	builder.PrependFloat64Slot(35, Z_DOT, 0.0)
}
func CDMObjectAddCOVARIANCE(builder *flatbuffers.Builder, COVARIANCE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(36, flatbuffers.UOffsetT(COVARIANCE), 0)
}
func CDMObjectStartCOVARIANCEVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func CDMObjectEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
