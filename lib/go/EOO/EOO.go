// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package EOO

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Electro-Optical Observation
type EOO struct {
	_tab flatbuffers.Table
}

const EOOIdentifier = "$EOO"

func GetRootAsEOO(buf []byte, offset flatbuffers.UOffsetT) *EOO {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &EOO{}
	x.Init(buf, n+offset)
	return x
}

func FinishEOOBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(EOOIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func EOOBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, EOOIdentifier)
}

func GetSizePrefixedRootAsEOO(buf []byte, offset flatbuffers.UOffsetT) *EOO {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &EOO{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedEOOBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(EOOIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedEOOBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, EOOIdentifier)
}

func (rcv *EOO) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *EOO) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier of the record.
func (rcv *EOO) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier of the record.
/// Classification marking of the data in IC/CAPCO Portion-marked format.
func (rcv *EOO) CLASSIFICATION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Classification marking of the data in IC/CAPCO Portion-marked format.
/// Ob detection time in ISO 8601 UTC (YYYY-MM-DDTHH:MM:SS.ssssssZ), up to microsecond precision.
func (rcv *EOO) OB_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Ob detection time in ISO 8601 UTC (YYYY-MM-DDTHH:MM:SS.ssssssZ), up to microsecond precision.
/// Correlation score of the observation when compared to a known orbit state.
func (rcv *EOO) CORR_QUALITY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Correlation score of the observation when compared to a known orbit state.
func (rcv *EOO) MutateCORR_QUALITY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(10, n)
}

/// Server will auto-populate with SAT_NO if available.
func (rcv *EOO) ID_ON_ORBIT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Server will auto-populate with SAT_NO if available.
/// Unique ID of the sensor. Must have a corresponding sensor record on the server.
func (rcv *EOO) SENSOR_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique ID of the sensor. Must have a corresponding sensor record on the server.
/// Accepted Collection Method
func (rcv *EOO) COLLECT_METHOD() CollectMethod {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return CollectMethod(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Accepted Collection Method
func (rcv *EOO) MutateCOLLECT_METHOD(n CollectMethod) bool {
	return rcv._tab.MutateInt8Slot(16, int8(n))
}

/// 18SDS satellite number. Only list if correlated against the 18SDS catalog.
func (rcv *EOO) NORAD_CAT_ID() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// 18SDS satellite number. Only list if correlated against the 18SDS catalog.
func (rcv *EOO) MutateNORAD_CAT_ID(n int32) bool {
	return rcv._tab.MutateInt32Slot(18, n)
}

/// Identifier for the collectRequest message if the collection was in response to tasking.
func (rcv *EOO) TASK_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Identifier for the collectRequest message if the collection was in response to tasking.
/// Optional identifier to track a transaction.
func (rcv *EOO) TRANSACTION_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional identifier to track a transaction.
/// Identifier of the track to which this observation belongs, if applicable.
func (rcv *EOO) TRACK_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Identifier of the track to which this observation belongs, if applicable.
/// The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).
func (rcv *EOO) OB_POSITION() ObservationPosition {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return ObservationPosition(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).
func (rcv *EOO) MutateOB_POSITION(n ObservationPosition) bool {
	return rcv._tab.MutateInt8Slot(26, int8(n))
}

/// Provider maintained ID. May not be consistent with 18SDS SAT_NO.
func (rcv *EOO) ORIG_OBJECT_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Provider maintained ID. May not be consistent with 18SDS SAT_NO.
/// Sensor ID.
func (rcv *EOO) ORIG_SENSOR_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Sensor ID.
/// Required if correlation is attempted. Indicates whether correlation succeeded.
func (rcv *EOO) UCT() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Required if correlation is attempted. Indicates whether correlation succeeded.
func (rcv *EOO) MutateUCT(n bool) bool {
	return rcv._tab.MutateBoolSlot(32, n)
}

/// Line of sight azimuth angle in degrees and topocentric frame.
func (rcv *EOO) AZIMUTH() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Line of sight azimuth angle in degrees and topocentric frame.
func (rcv *EOO) MutateAZIMUTH(n float32) bool {
	return rcv._tab.MutateFloat32Slot(34, n)
}

/// One sigma uncertainty in the line of sight azimuth angle, in degrees.
func (rcv *EOO) AZIMUTH_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight azimuth angle, in degrees.
func (rcv *EOO) MutateAZIMUTH_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(36, n)
}

/// Sensor line of sight azimuth angle bias in degrees.
func (rcv *EOO) AZIMUTH_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor line of sight azimuth angle bias in degrees.
func (rcv *EOO) MutateAZIMUTH_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(38, n)
}

/// Rate of change of the line of sight azimuth in degrees per second.
func (rcv *EOO) AZIMUTH_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Rate of change of the line of sight azimuth in degrees per second.
func (rcv *EOO) MutateAZIMUTH_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(40, n)
}

/// Line of sight elevation in degrees and topocentric frame.
func (rcv *EOO) ELEVATION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Line of sight elevation in degrees and topocentric frame.
func (rcv *EOO) MutateELEVATION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(42, n)
}

/// One sigma uncertainty in the line of sight elevation angle, in degrees.
func (rcv *EOO) ELEVATION_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight elevation angle, in degrees.
func (rcv *EOO) MutateELEVATION_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(44, n)
}

/// Sensor line of sight elevation bias in degrees.
func (rcv *EOO) ELEVATION_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor line of sight elevation bias in degrees.
func (rcv *EOO) MutateELEVATION_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(46, n)
}

/// Rate of change of the line of sight elevation in degrees per second.
func (rcv *EOO) ELEVATION_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Rate of change of the line of sight elevation in degrees per second.
func (rcv *EOO) MutateELEVATION_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(48, n)
}

/// Line of sight range in km. Reported value should include all applicable corrections.
func (rcv *EOO) RANGE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Line of sight range in km. Reported value should include all applicable corrections.
func (rcv *EOO) MutateRANGE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(50, n)
}

/// One sigma uncertainty in the line of sight range, in km.
func (rcv *EOO) RANGE_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight range, in km.
func (rcv *EOO) MutateRANGE_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(52, n)
}

/// Sensor line of sight range bias in km.
func (rcv *EOO) RANGE_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor line of sight range bias in km.
func (rcv *EOO) MutateRANGE_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(54, n)
}

/// Range rate in km/s. Reported value should include all applicable corrections.
func (rcv *EOO) RANGE_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Range rate in km/s. Reported value should include all applicable corrections.
func (rcv *EOO) MutateRANGE_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(56, n)
}

/// One sigma uncertainty in the line of sight range rate, in km/sec.
func (rcv *EOO) RANGE_RATE_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight range rate, in km/sec.
func (rcv *EOO) MutateRANGE_RATE_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(58, n)
}

/// Right ascension in degrees. Required metric reporting field for EO observations.
func (rcv *EOO) RA() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Right ascension in degrees. Required metric reporting field for EO observations.
func (rcv *EOO) MutateRA(n float32) bool {
	return rcv._tab.MutateFloat32Slot(60, n)
}

/// Line of sight right ascension rate of change, in degrees/sec.
func (rcv *EOO) RA_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Line of sight right ascension rate of change, in degrees/sec.
func (rcv *EOO) MutateRA_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(62, n)
}

/// One sigma uncertainty in the line of sight right ascension angle, in degrees.
func (rcv *EOO) RA_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight right ascension angle, in degrees.
func (rcv *EOO) MutateRA_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(64, n)
}

/// Sensor line of sight right ascension bias in degrees.
func (rcv *EOO) RA_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor line of sight right ascension bias in degrees.
func (rcv *EOO) MutateRA_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(66, n)
}

/// Declination in degrees. Required metric reporting field for EO observations.
func (rcv *EOO) DECLINATION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Declination in degrees. Required metric reporting field for EO observations.
func (rcv *EOO) MutateDECLINATION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(68, n)
}

/// Line of sight declination rate of change, in degrees/sec.
func (rcv *EOO) DECLINATION_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Line of sight declination rate of change, in degrees/sec.
func (rcv *EOO) MutateDECLINATION_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(70, n)
}

/// One sigma uncertainty in the line of sight declination angle, in degrees.
func (rcv *EOO) DECLINATION_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight declination angle, in degrees.
func (rcv *EOO) MutateDECLINATION_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(72, n)
}

/// Sensor line of sight declination angle bias in degrees.
func (rcv *EOO) DECLINATION_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor line of sight declination angle bias in degrees.
func (rcv *EOO) MutateDECLINATION_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(74, n)
}

/// X-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) LOSX() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// X-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) MutateLOSX(n float32) bool {
	return rcv._tab.MutateFloat32Slot(76, n)
}

/// Y-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) LOSY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Y-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) MutateLOSY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(78, n)
}

/// Z-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) LOSZ() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Z-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) MutateLOSZ(n float32) bool {
	return rcv._tab.MutateFloat32Slot(80, n)
}

/// One sigma uncertainty in the line-of-sight direction vector components.
func (rcv *EOO) LOS_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line-of-sight direction vector components.
func (rcv *EOO) MutateLOS_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(82, n)
}

/// X-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) LOSXVEL() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// X-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) MutateLOSXVEL(n float32) bool {
	return rcv._tab.MutateFloat32Slot(84, n)
}

/// Y-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) LOSYVEL() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Y-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) MutateLOSYVEL(n float32) bool {
	return rcv._tab.MutateFloat32Slot(86, n)
}

/// Z-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) LOSZVEL() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Z-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) MutateLOSZVEL(n float32) bool {
	return rcv._tab.MutateFloat32Slot(88, n)
}

/// WGS-84 latitude in decimal degrees at the time of the observation.
func (rcv *EOO) SENLAT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(90))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// WGS-84 latitude in decimal degrees at the time of the observation.
func (rcv *EOO) MutateSENLAT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(90, n)
}

/// WGS-84 longitude in decimal degrees at the time of the observation.
func (rcv *EOO) SENLON() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(92))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// WGS-84 longitude in decimal degrees at the time of the observation.
func (rcv *EOO) MutateSENLON(n float32) bool {
	return rcv._tab.MutateFloat32Slot(92, n)
}

/// Sensor height in km relative to the WGS-84 ellipsoid at the time of the observation.
func (rcv *EOO) SENALT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(94))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor height in km relative to the WGS-84 ellipsoid at the time of the observation.
func (rcv *EOO) MutateSENALT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(94, n)
}

/// Cartesian X position in km at the time of the observation.
func (rcv *EOO) SENX() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(96))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Cartesian X position in km at the time of the observation.
func (rcv *EOO) MutateSENX(n float32) bool {
	return rcv._tab.MutateFloat32Slot(96, n)
}

/// Cartesian Y position in km at the time of the observation.
func (rcv *EOO) SENY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Cartesian Y position in km at the time of the observation.
func (rcv *EOO) MutateSENY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(98, n)
}

/// Cartesian Z position in km at the time of the observation.
func (rcv *EOO) SENZ() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(100))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Cartesian Z position in km at the time of the observation.
func (rcv *EOO) MutateSENZ(n float32) bool {
	return rcv._tab.MutateFloat32Slot(100, n)
}

/// Total number of satellites in the field of view.
func (rcv *EOO) FOV_COUNT() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Total number of satellites in the field of view.
func (rcv *EOO) MutateFOV_COUNT(n int32) bool {
	return rcv._tab.MutateInt32Slot(102, n)
}

/// Number of uncorrelated satellites in the field of view (JCO).
func (rcv *EOO) FOV_COUNT_UCTS() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of uncorrelated satellites in the field of view (JCO).
func (rcv *EOO) MutateFOV_COUNT_UCTS(n int32) bool {
	return rcv._tab.MutateInt32Slot(104, n)
}

/// Image exposure duration in seconds. For observations performed using frame stacking or synthetic tracking methods, 
/// the exposure duration should be the total integration time. This field is highly recommended / required if the 
/// observations are going to be used for photometric processing.
func (rcv *EOO) EXP_DURATION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Image exposure duration in seconds. For observations performed using frame stacking or synthetic tracking methods, 
/// the exposure duration should be the total integration time. This field is highly recommended / required if the 
/// observations are going to be used for photometric processing.
func (rcv *EOO) MutateEXP_DURATION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(106, n)
}

/// Formula: 2.5 * log_10 (zero_mag_counts / EXP_DURATION).
func (rcv *EOO) ZEROPTD() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Formula: 2.5 * log_10 (zero_mag_counts / EXP_DURATION).
func (rcv *EOO) MutateZEROPTD(n float32) bool {
	return rcv._tab.MutateFloat32Slot(108, n)
}

/// Net object signature = counts / EXP_DURATION.
func (rcv *EOO) NET_OBJ_SIG() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Net object signature = counts / EXP_DURATION.
func (rcv *EOO) MutateNET_OBJ_SIG(n float32) bool {
	return rcv._tab.MutateFloat32Slot(110, n)
}

/// Net object signature uncertainty = counts uncertainty / EXP_DURATION.
func (rcv *EOO) NET_OBJ_SIG_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Net object signature uncertainty = counts uncertainty / EXP_DURATION.
func (rcv *EOO) MutateNET_OBJ_SIG_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(112, n)
}

/// Measure of observed brightness calibrated against the Gaia G-band.
func (rcv *EOO) MAG() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Measure of observed brightness calibrated against the Gaia G-band.
func (rcv *EOO) MutateMAG(n float32) bool {
	return rcv._tab.MutateFloat32Slot(114, n)
}

/// Uncertainty of the observed brightness.
func (rcv *EOO) MAG_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Uncertainty of the observed brightness.
func (rcv *EOO) MutateMAG_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(116, n)
}

/// [Definition needed].
func (rcv *EOO) MAG_NORM_RANGE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// [Definition needed].
func (rcv *EOO) MutateMAG_NORM_RANGE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(118, n)
}

/// Computed estimate of the latitude, positive degrees north. It should be computed based on the assumed slant range 
/// and corresponding viewing geometry. It must NOT be computed from the orbit state.
func (rcv *EOO) GEOLAT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(120))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Computed estimate of the latitude, positive degrees north. It should be computed based on the assumed slant range 
/// and corresponding viewing geometry. It must NOT be computed from the orbit state.
func (rcv *EOO) MutateGEOLAT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(120, n)
}

/// Computed estimate of the longitude as +/- 180 degrees east. It should be computed based on the assumed slant range 
/// and viewing geometry. It must NOT be computed from the orbit state.
func (rcv *EOO) GEOLON() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(122))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Computed estimate of the longitude as +/- 180 degrees east. It should be computed based on the assumed slant range 
/// and viewing geometry. It must NOT be computed from the orbit state.
func (rcv *EOO) MutateGEOLON(n float32) bool {
	return rcv._tab.MutateFloat32Slot(122, n)
}

/// Computed estimate of satellite altitude in km at the reported location. It must NOT be computed from the orbit state.
func (rcv *EOO) GEOALT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(124))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Computed estimate of satellite altitude in km at the reported location. It must NOT be computed from the orbit state.
func (rcv *EOO) MutateGEOALT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(124, n)
}

/// Computed estimate of the slant range in km. It must NOT be computed from the orbit state.
func (rcv *EOO) GEORANGE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(126))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Computed estimate of the slant range in km. It must NOT be computed from the orbit state.
func (rcv *EOO) MutateGEORANGE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(126, n)
}

/// Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently 
/// empty part of the night sky.
func (rcv *EOO) SKY_BKGRND() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(128))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently 
/// empty part of the night sky.
func (rcv *EOO) MutateSKY_BKGRND(n float32) bool {
	return rcv._tab.MutateFloat32Slot(128, n)
}

/// Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass 
/// to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general, 
/// describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical 
/// object and the observer.
func (rcv *EOO) PRIMARY_EXTINCTION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(130))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass 
/// to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general, 
/// describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical 
/// object and the observer.
func (rcv *EOO) MutatePRIMARY_EXTINCTION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(130, n)
}

/// Primary Extinction Coefficient Uncertainty, in Magnitudes.
func (rcv *EOO) PRIMARY_EXTINCTION_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(132))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Primary Extinction Coefficient Uncertainty, in Magnitudes.
func (rcv *EOO) MutatePRIMARY_EXTINCTION_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(132, n)
}

/// The angle, in degrees, between the target-to-observer vector and the target-to-sun vector. Recommend using the 
/// calculation listed in the EOSSA documentation, pg 106 of the EOSSA spec.
func (rcv *EOO) SOLAR_PHASE_ANGLE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(134))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The angle, in degrees, between the target-to-observer vector and the target-to-sun vector. Recommend using the 
/// calculation listed in the EOSSA documentation, pg 106 of the EOSSA spec.
func (rcv *EOO) MutateSOLAR_PHASE_ANGLE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(134, n)
}

/// The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector 
/// onto the equatorial plane. The convention used is negative when closing (i.e., before the opposition) 
/// and positive when opening (after the opposition).
func (rcv *EOO) SOLAR_EQ_PHASE_ANGLE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(136))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector 
/// onto the equatorial plane. The convention used is negative when closing (i.e., before the opposition) 
/// and positive when opening (after the opposition).
func (rcv *EOO) MutateSOLAR_EQ_PHASE_ANGLE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(136, n)
}

/// Angle from the sun to the equatorial plane.
func (rcv *EOO) SOLAR_DEC_ANGLE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(138))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Angle from the sun to the equatorial plane.
func (rcv *EOO) MutateSOLAR_DEC_ANGLE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(138, n)
}

/// Shutter delay in seconds.
func (rcv *EOO) SHUTTER_DELAY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(140))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Shutter delay in seconds.
func (rcv *EOO) MutateSHUTTER_DELAY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(140, n)
}

/// Sensor timing bias in seconds.
func (rcv *EOO) TIMING_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(142))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor timing bias in seconds.
func (rcv *EOO) MutateTIMING_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(142, n)
}

/// Optional URI location in the document repository of the raw file parsed by the system to produce this record. 
func (rcv *EOO) RAW_FILE_URI() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(144))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional URI location in the document repository of the raw file parsed by the system to produce this record. 
/// Intensity of the target for IR observations, in kw/sr/em.
func (rcv *EOO) INTENSITY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(146))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Intensity of the target for IR observations, in kw/sr/em.
func (rcv *EOO) MutateINTENSITY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(146, n)
}

/// Background intensity for IR observations, in kw/sr/um.
func (rcv *EOO) BG_INTENSITY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(148))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Background intensity for IR observations, in kw/sr/um.
func (rcv *EOO) MutateBG_INTENSITY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(148, n)
}

/// Optional source-provided and searchable metadata or descriptor of the data.
func (rcv *EOO) DESCRIPTOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(150))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional source-provided and searchable metadata or descriptor of the data.
/// Source of the data.
func (rcv *EOO) SOURCE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(152))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Source of the data.
/// Originating system or organization which produced the data, if different from the source.
/// The origin may be different than the source if the source was a mediating system which forwarded 
/// the data on behalf of the origin system. If null, the source may be assumed to be the origin.
func (rcv *EOO) ORIGIN() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(154))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Originating system or organization which produced the data, if different from the source.
/// The origin may be different than the source if the source was a mediating system which forwarded 
/// the data on behalf of the origin system. If null, the source may be assumed to be the origin.
/// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST.
func (rcv *EOO) DATA_MODE() DataMode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(156))
	if o != 0 {
		return DataMode(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST.
func (rcv *EOO) MutateDATA_MODE(n DataMode) bool {
	return rcv._tab.MutateInt8Slot(156, int8(n))
}

/// Time the row was created in the database, auto-populated by the system.
func (rcv *EOO) CREATED_AT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(158))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time the row was created in the database, auto-populated by the system.
/// Application user who created the row in the database, auto-populated by the system.
func (rcv *EOO) CREATED_BY() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(160))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Application user who created the row in the database, auto-populated by the system.
/// EO observations are assumed to be topocentric J2000 coordinates ('J2000') as defined by the IAU, unless otherwise specified.
func (rcv *EOO) REFERENCE_FRAME() refFrame {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(162))
	if o != 0 {
		return refFrame(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// EO observations are assumed to be topocentric J2000 coordinates ('J2000') as defined by the IAU, unless otherwise specified.
func (rcv *EOO) MutateREFERENCE_FRAME(n refFrame) bool {
	return rcv._tab.MutateInt8Slot(162, int8(n))
}

/// The sensor reference frame is assumed to be the International Terrestrial Reference Frame (ITRF), 
/// unless otherwise specified. (ITRF is equivalent to Earth-Centered Earth-Fixed (ECEF) for this purpose). 
/// Lat / long / height values should be reported using the WGS-84 ellipsoid, where applicable.
func (rcv *EOO) SEN_REFERENCE_FRAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(164))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The sensor reference frame is assumed to be the International Terrestrial Reference Frame (ITRF), 
/// unless otherwise specified. (ITRF is equivalent to Earth-Centered Earth-Fixed (ECEF) for this purpose). 
/// Lat / long / height values should be reported using the WGS-84 ellipsoid, where applicable.
/// Boolean indicating that the target object was in umbral eclipse at the time of this observation.
func (rcv *EOO) UMBRA() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(166))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Boolean indicating that the target object was in umbral eclipse at the time of this observation.
func (rcv *EOO) MutateUMBRA(n bool) bool {
	return rcv._tab.MutateBoolSlot(166, n)
}

/// Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
/// This field is highly recommended if the observations will be used for photometric processing.
func (rcv *EOO) PENUMBRA() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(168))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
/// This field is highly recommended if the observations will be used for photometric processing.
func (rcv *EOO) MutatePENUMBRA(n bool) bool {
	return rcv._tab.MutateBoolSlot(168, n)
}

/// The originating source network on which this record was created, auto-populated by the system.
func (rcv *EOO) ORIG_NETWORK() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(170))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The originating source network on which this record was created, auto-populated by the system.
/// The source from which this record was received.
func (rcv *EOO) SOURCE_DL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(172))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The source from which this record was received.
/// Device Type
func (rcv *EOO) TYPE() DeviceType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(174))
	if o != 0 {
		return DeviceType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Device Type
func (rcv *EOO) MutateTYPE(n DeviceType) bool {
	return rcv._tab.MutateInt8Slot(174, int8(n))
}

/// True if measured, false if computed. Required if azimuth is reported.
func (rcv *EOO) AZIMUTH_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(176))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if azimuth is reported.
func (rcv *EOO) MutateAZIMUTH_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(176, n)
}

/// True if measured, false if computed. Required if elevation is reported.
func (rcv *EOO) ELEVATION_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(178))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if elevation is reported.
func (rcv *EOO) MutateELEVATION_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(178, n)
}

/// True if measured, false if computed. Required if range is reported.
func (rcv *EOO) RANGE_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(180))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if range is reported.
func (rcv *EOO) MutateRANGE_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(180, n)
}

/// True if measured, false if computed. Required if range-rate is reported.
func (rcv *EOO) RANGERATE_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(182))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if range-rate is reported.
func (rcv *EOO) MutateRANGERATE_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(182, n)
}

/// True if measured, false if computed. Required if right ascension is reported.
func (rcv *EOO) RA_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(184))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if right ascension is reported.
func (rcv *EOO) MutateRA_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(184, n)
}

/// True if measured, false if computed. Required if declination is reported.
func (rcv *EOO) DECLINATION_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(186))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if declination is reported.
func (rcv *EOO) MutateDECLINATION_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(186, n)
}

func EOOStart(builder *flatbuffers.Builder) {
	builder.StartObject(92)
}
func EOOAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func EOOAddCLASSIFICATION(builder *flatbuffers.Builder, CLASSIFICATION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(CLASSIFICATION), 0)
}
func EOOAddOB_TIME(builder *flatbuffers.Builder, OB_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(OB_TIME), 0)
}
func EOOAddCORR_QUALITY(builder *flatbuffers.Builder, CORR_QUALITY float32) {
	builder.PrependFloat32Slot(3, CORR_QUALITY, 0.0)
}
func EOOAddID_ON_ORBIT(builder *flatbuffers.Builder, ID_ON_ORBIT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(ID_ON_ORBIT), 0)
}
func EOOAddSENSOR_ID(builder *flatbuffers.Builder, SENSOR_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(SENSOR_ID), 0)
}
func EOOAddCOLLECT_METHOD(builder *flatbuffers.Builder, COLLECT_METHOD CollectMethod) {
	builder.PrependInt8Slot(6, int8(COLLECT_METHOD), 0)
}
func EOOAddNORAD_CAT_ID(builder *flatbuffers.Builder, NORAD_CAT_ID int32) {
	builder.PrependInt32Slot(7, NORAD_CAT_ID, 0)
}
func EOOAddTASK_ID(builder *flatbuffers.Builder, TASK_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(TASK_ID), 0)
}
func EOOAddTRANSACTION_ID(builder *flatbuffers.Builder, TRANSACTION_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(TRANSACTION_ID), 0)
}
func EOOAddTRACK_ID(builder *flatbuffers.Builder, TRACK_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(TRACK_ID), 0)
}
func EOOAddOB_POSITION(builder *flatbuffers.Builder, OB_POSITION ObservationPosition) {
	builder.PrependInt8Slot(11, int8(OB_POSITION), 0)
}
func EOOAddORIG_OBJECT_ID(builder *flatbuffers.Builder, ORIG_OBJECT_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(ORIG_OBJECT_ID), 0)
}
func EOOAddORIG_SENSOR_ID(builder *flatbuffers.Builder, ORIG_SENSOR_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(ORIG_SENSOR_ID), 0)
}
func EOOAddUCT(builder *flatbuffers.Builder, UCT bool) {
	builder.PrependBoolSlot(14, UCT, false)
}
func EOOAddAZIMUTH(builder *flatbuffers.Builder, AZIMUTH float32) {
	builder.PrependFloat32Slot(15, AZIMUTH, 0.0)
}
func EOOAddAZIMUTH_UNC(builder *flatbuffers.Builder, AZIMUTH_UNC float32) {
	builder.PrependFloat32Slot(16, AZIMUTH_UNC, 0.0)
}
func EOOAddAZIMUTH_BIAS(builder *flatbuffers.Builder, AZIMUTH_BIAS float32) {
	builder.PrependFloat32Slot(17, AZIMUTH_BIAS, 0.0)
}
func EOOAddAZIMUTH_RATE(builder *flatbuffers.Builder, AZIMUTH_RATE float32) {
	builder.PrependFloat32Slot(18, AZIMUTH_RATE, 0.0)
}
func EOOAddELEVATION(builder *flatbuffers.Builder, ELEVATION float32) {
	builder.PrependFloat32Slot(19, ELEVATION, 0.0)
}
func EOOAddELEVATION_UNC(builder *flatbuffers.Builder, ELEVATION_UNC float32) {
	builder.PrependFloat32Slot(20, ELEVATION_UNC, 0.0)
}
func EOOAddELEVATION_BIAS(builder *flatbuffers.Builder, ELEVATION_BIAS float32) {
	builder.PrependFloat32Slot(21, ELEVATION_BIAS, 0.0)
}
func EOOAddELEVATION_RATE(builder *flatbuffers.Builder, ELEVATION_RATE float32) {
	builder.PrependFloat32Slot(22, ELEVATION_RATE, 0.0)
}
func EOOAddRANGE(builder *flatbuffers.Builder, RANGE float32) {
	builder.PrependFloat32Slot(23, RANGE, 0.0)
}
func EOOAddRANGE_UNC(builder *flatbuffers.Builder, RANGE_UNC float32) {
	builder.PrependFloat32Slot(24, RANGE_UNC, 0.0)
}
func EOOAddRANGE_BIAS(builder *flatbuffers.Builder, RANGE_BIAS float32) {
	builder.PrependFloat32Slot(25, RANGE_BIAS, 0.0)
}
func EOOAddRANGE_RATE(builder *flatbuffers.Builder, RANGE_RATE float32) {
	builder.PrependFloat32Slot(26, RANGE_RATE, 0.0)
}
func EOOAddRANGE_RATE_UNC(builder *flatbuffers.Builder, RANGE_RATE_UNC float32) {
	builder.PrependFloat32Slot(27, RANGE_RATE_UNC, 0.0)
}
func EOOAddRA(builder *flatbuffers.Builder, RA float32) {
	builder.PrependFloat32Slot(28, RA, 0.0)
}
func EOOAddRA_RATE(builder *flatbuffers.Builder, RA_RATE float32) {
	builder.PrependFloat32Slot(29, RA_RATE, 0.0)
}
func EOOAddRA_UNC(builder *flatbuffers.Builder, RA_UNC float32) {
	builder.PrependFloat32Slot(30, RA_UNC, 0.0)
}
func EOOAddRA_BIAS(builder *flatbuffers.Builder, RA_BIAS float32) {
	builder.PrependFloat32Slot(31, RA_BIAS, 0.0)
}
func EOOAddDECLINATION(builder *flatbuffers.Builder, DECLINATION float32) {
	builder.PrependFloat32Slot(32, DECLINATION, 0.0)
}
func EOOAddDECLINATION_RATE(builder *flatbuffers.Builder, DECLINATION_RATE float32) {
	builder.PrependFloat32Slot(33, DECLINATION_RATE, 0.0)
}
func EOOAddDECLINATION_UNC(builder *flatbuffers.Builder, DECLINATION_UNC float32) {
	builder.PrependFloat32Slot(34, DECLINATION_UNC, 0.0)
}
func EOOAddDECLINATION_BIAS(builder *flatbuffers.Builder, DECLINATION_BIAS float32) {
	builder.PrependFloat32Slot(35, DECLINATION_BIAS, 0.0)
}
func EOOAddLOSX(builder *flatbuffers.Builder, LOSX float32) {
	builder.PrependFloat32Slot(36, LOSX, 0.0)
}
func EOOAddLOSY(builder *flatbuffers.Builder, LOSY float32) {
	builder.PrependFloat32Slot(37, LOSY, 0.0)
}
func EOOAddLOSZ(builder *flatbuffers.Builder, LOSZ float32) {
	builder.PrependFloat32Slot(38, LOSZ, 0.0)
}
func EOOAddLOS_UNC(builder *flatbuffers.Builder, LOS_UNC float32) {
	builder.PrependFloat32Slot(39, LOS_UNC, 0.0)
}
func EOOAddLOSXVEL(builder *flatbuffers.Builder, LOSXVEL float32) {
	builder.PrependFloat32Slot(40, LOSXVEL, 0.0)
}
func EOOAddLOSYVEL(builder *flatbuffers.Builder, LOSYVEL float32) {
	builder.PrependFloat32Slot(41, LOSYVEL, 0.0)
}
func EOOAddLOSZVEL(builder *flatbuffers.Builder, LOSZVEL float32) {
	builder.PrependFloat32Slot(42, LOSZVEL, 0.0)
}
func EOOAddSENLAT(builder *flatbuffers.Builder, SENLAT float32) {
	builder.PrependFloat32Slot(43, SENLAT, 0.0)
}
func EOOAddSENLON(builder *flatbuffers.Builder, SENLON float32) {
	builder.PrependFloat32Slot(44, SENLON, 0.0)
}
func EOOAddSENALT(builder *flatbuffers.Builder, SENALT float32) {
	builder.PrependFloat32Slot(45, SENALT, 0.0)
}
func EOOAddSENX(builder *flatbuffers.Builder, SENX float32) {
	builder.PrependFloat32Slot(46, SENX, 0.0)
}
func EOOAddSENY(builder *flatbuffers.Builder, SENY float32) {
	builder.PrependFloat32Slot(47, SENY, 0.0)
}
func EOOAddSENZ(builder *flatbuffers.Builder, SENZ float32) {
	builder.PrependFloat32Slot(48, SENZ, 0.0)
}
func EOOAddFOV_COUNT(builder *flatbuffers.Builder, FOV_COUNT int32) {
	builder.PrependInt32Slot(49, FOV_COUNT, 0)
}
func EOOAddFOV_COUNT_UCTS(builder *flatbuffers.Builder, FOV_COUNT_UCTS int32) {
	builder.PrependInt32Slot(50, FOV_COUNT_UCTS, 0)
}
func EOOAddEXP_DURATION(builder *flatbuffers.Builder, EXP_DURATION float32) {
	builder.PrependFloat32Slot(51, EXP_DURATION, 0.0)
}
func EOOAddZEROPTD(builder *flatbuffers.Builder, ZEROPTD float32) {
	builder.PrependFloat32Slot(52, ZEROPTD, 0.0)
}
func EOOAddNET_OBJ_SIG(builder *flatbuffers.Builder, NET_OBJ_SIG float32) {
	builder.PrependFloat32Slot(53, NET_OBJ_SIG, 0.0)
}
func EOOAddNET_OBJ_SIG_UNC(builder *flatbuffers.Builder, NET_OBJ_SIG_UNC float32) {
	builder.PrependFloat32Slot(54, NET_OBJ_SIG_UNC, 0.0)
}
func EOOAddMAG(builder *flatbuffers.Builder, MAG float32) {
	builder.PrependFloat32Slot(55, MAG, 0.0)
}
func EOOAddMAG_UNC(builder *flatbuffers.Builder, MAG_UNC float32) {
	builder.PrependFloat32Slot(56, MAG_UNC, 0.0)
}
func EOOAddMAG_NORM_RANGE(builder *flatbuffers.Builder, MAG_NORM_RANGE float32) {
	builder.PrependFloat32Slot(57, MAG_NORM_RANGE, 0.0)
}
func EOOAddGEOLAT(builder *flatbuffers.Builder, GEOLAT float32) {
	builder.PrependFloat32Slot(58, GEOLAT, 0.0)
}
func EOOAddGEOLON(builder *flatbuffers.Builder, GEOLON float32) {
	builder.PrependFloat32Slot(59, GEOLON, 0.0)
}
func EOOAddGEOALT(builder *flatbuffers.Builder, GEOALT float32) {
	builder.PrependFloat32Slot(60, GEOALT, 0.0)
}
func EOOAddGEORANGE(builder *flatbuffers.Builder, GEORANGE float32) {
	builder.PrependFloat32Slot(61, GEORANGE, 0.0)
}
func EOOAddSKY_BKGRND(builder *flatbuffers.Builder, SKY_BKGRND float32) {
	builder.PrependFloat32Slot(62, SKY_BKGRND, 0.0)
}
func EOOAddPRIMARY_EXTINCTION(builder *flatbuffers.Builder, PRIMARY_EXTINCTION float32) {
	builder.PrependFloat32Slot(63, PRIMARY_EXTINCTION, 0.0)
}
func EOOAddPRIMARY_EXTINCTION_UNC(builder *flatbuffers.Builder, PRIMARY_EXTINCTION_UNC float32) {
	builder.PrependFloat32Slot(64, PRIMARY_EXTINCTION_UNC, 0.0)
}
func EOOAddSOLAR_PHASE_ANGLE(builder *flatbuffers.Builder, SOLAR_PHASE_ANGLE float32) {
	builder.PrependFloat32Slot(65, SOLAR_PHASE_ANGLE, 0.0)
}
func EOOAddSOLAR_EQ_PHASE_ANGLE(builder *flatbuffers.Builder, SOLAR_EQ_PHASE_ANGLE float32) {
	builder.PrependFloat32Slot(66, SOLAR_EQ_PHASE_ANGLE, 0.0)
}
func EOOAddSOLAR_DEC_ANGLE(builder *flatbuffers.Builder, SOLAR_DEC_ANGLE float32) {
	builder.PrependFloat32Slot(67, SOLAR_DEC_ANGLE, 0.0)
}
func EOOAddSHUTTER_DELAY(builder *flatbuffers.Builder, SHUTTER_DELAY float32) {
	builder.PrependFloat32Slot(68, SHUTTER_DELAY, 0.0)
}
func EOOAddTIMING_BIAS(builder *flatbuffers.Builder, TIMING_BIAS float32) {
	builder.PrependFloat32Slot(69, TIMING_BIAS, 0.0)
}
func EOOAddRAW_FILE_URI(builder *flatbuffers.Builder, RAW_FILE_URI flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(70, flatbuffers.UOffsetT(RAW_FILE_URI), 0)
}
func EOOAddINTENSITY(builder *flatbuffers.Builder, INTENSITY float32) {
	builder.PrependFloat32Slot(71, INTENSITY, 0.0)
}
func EOOAddBG_INTENSITY(builder *flatbuffers.Builder, BG_INTENSITY float32) {
	builder.PrependFloat32Slot(72, BG_INTENSITY, 0.0)
}
func EOOAddDESCRIPTOR(builder *flatbuffers.Builder, DESCRIPTOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(73, flatbuffers.UOffsetT(DESCRIPTOR), 0)
}
func EOOAddSOURCE(builder *flatbuffers.Builder, SOURCE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(74, flatbuffers.UOffsetT(SOURCE), 0)
}
func EOOAddORIGIN(builder *flatbuffers.Builder, ORIGIN flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(75, flatbuffers.UOffsetT(ORIGIN), 0)
}
func EOOAddDATA_MODE(builder *flatbuffers.Builder, DATA_MODE DataMode) {
	builder.PrependInt8Slot(76, int8(DATA_MODE), 0)
}
func EOOAddCREATED_AT(builder *flatbuffers.Builder, CREATED_AT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(77, flatbuffers.UOffsetT(CREATED_AT), 0)
}
func EOOAddCREATED_BY(builder *flatbuffers.Builder, CREATED_BY flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(78, flatbuffers.UOffsetT(CREATED_BY), 0)
}
func EOOAddREFERENCE_FRAME(builder *flatbuffers.Builder, REFERENCE_FRAME refFrame) {
	builder.PrependInt8Slot(79, int8(REFERENCE_FRAME), 0)
}
func EOOAddSEN_REFERENCE_FRAME(builder *flatbuffers.Builder, SEN_REFERENCE_FRAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(80, flatbuffers.UOffsetT(SEN_REFERENCE_FRAME), 0)
}
func EOOAddUMBRA(builder *flatbuffers.Builder, UMBRA bool) {
	builder.PrependBoolSlot(81, UMBRA, false)
}
func EOOAddPENUMBRA(builder *flatbuffers.Builder, PENUMBRA bool) {
	builder.PrependBoolSlot(82, PENUMBRA, false)
}
func EOOAddORIG_NETWORK(builder *flatbuffers.Builder, ORIG_NETWORK flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(83, flatbuffers.UOffsetT(ORIG_NETWORK), 0)
}
func EOOAddSOURCE_DL(builder *flatbuffers.Builder, SOURCE_DL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(84, flatbuffers.UOffsetT(SOURCE_DL), 0)
}
func EOOAddTYPE(builder *flatbuffers.Builder, TYPE DeviceType) {
	builder.PrependInt8Slot(85, int8(TYPE), 0)
}
func EOOAddAZIMUTH_MEASURED(builder *flatbuffers.Builder, AZIMUTH_MEASURED bool) {
	builder.PrependBoolSlot(86, AZIMUTH_MEASURED, false)
}
func EOOAddELEVATION_MEASURED(builder *flatbuffers.Builder, ELEVATION_MEASURED bool) {
	builder.PrependBoolSlot(87, ELEVATION_MEASURED, false)
}
func EOOAddRANGE_MEASURED(builder *flatbuffers.Builder, RANGE_MEASURED bool) {
	builder.PrependBoolSlot(88, RANGE_MEASURED, false)
}
func EOOAddRANGERATE_MEASURED(builder *flatbuffers.Builder, RANGERATE_MEASURED bool) {
	builder.PrependBoolSlot(89, RANGERATE_MEASURED, false)
}
func EOOAddRA_MEASURED(builder *flatbuffers.Builder, RA_MEASURED bool) {
	builder.PrependBoolSlot(90, RA_MEASURED, false)
}
func EOOAddDECLINATION_MEASURED(builder *flatbuffers.Builder, DECLINATION_MEASURED bool) {
	builder.PrependBoolSlot(91, DECLINATION_MEASURED, false)
}
func EOOEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
