// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package CSM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Conjunction Summary Message
type CSM struct {
	_tab flatbuffers.Table
}

func GetRootAsCSM(buf []byte, offset flatbuffers.UOffsetT) *CSM {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CSM{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCSM(buf []byte, offset flatbuffers.UOffsetT) *CSM {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CSM{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CSM) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CSM) Table() flatbuffers.Table {
	return rcv._tab
}

/// Satellite name for the first object
func (rcv *CSM) OBJECT_1(obj *CAT) *CAT {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CAT)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Satellite name for the first object
/// Days since epoch for the first object
func (rcv *CSM) DSE_1() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Days since epoch for the first object
func (rcv *CSM) MutateDSE_1(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

/// Satellite name for the second object
func (rcv *CSM) OBJECT_2(obj *CAT) *CAT {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CAT)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Satellite name for the second object
/// Days since epoch for the second object
func (rcv *CSM) DSE_2() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Days since epoch for the second object
func (rcv *CSM) MutateDSE_2(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

/// Time of closest approach as a Unix timestamp
func (rcv *CSM) TCA() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Time of closest approach as a Unix timestamp
func (rcv *CSM) MutateTCA(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

/// The distance or range between the two objects at TCA
func (rcv *CSM) TCA_RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The distance or range between the two objects at TCA
func (rcv *CSM) MutateTCA_RANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

/// The magnitude of the relative velocity at TCA
func (rcv *CSM) TCA_RELATIVE_SPEED() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The magnitude of the relative velocity at TCA
func (rcv *CSM) MutateTCA_RELATIVE_SPEED(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// Maximum probability
func (rcv *CSM) MAX_PROB() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Maximum probability
func (rcv *CSM) MutateMAX_PROB(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

/// Standard deviation that produces the maximum probability
func (rcv *CSM) DILUTION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Standard deviation that produces the maximum probability
func (rcv *CSM) MutateDILUTION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

func CSMStart(builder *flatbuffers.Builder) {
	builder.StartObject(9)
}
func CSMAddOBJECT_1(builder *flatbuffers.Builder, OBJECT_1 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(OBJECT_1), 0)
}
func CSMAddDSE_1(builder *flatbuffers.Builder, DSE_1 float64) {
	builder.PrependFloat64Slot(1, DSE_1, 0.0)
}
func CSMAddOBJECT_2(builder *flatbuffers.Builder, OBJECT_2 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(OBJECT_2), 0)
}
func CSMAddDSE_2(builder *flatbuffers.Builder, DSE_2 float64) {
	builder.PrependFloat64Slot(3, DSE_2, 0.0)
}
func CSMAddTCA(builder *flatbuffers.Builder, TCA float64) {
	builder.PrependFloat64Slot(4, TCA, 0.0)
}
func CSMAddTCA_RANGE(builder *flatbuffers.Builder, TCA_RANGE float64) {
	builder.PrependFloat64Slot(5, TCA_RANGE, 0.0)
}
func CSMAddTCA_RELATIVE_SPEED(builder *flatbuffers.Builder, TCA_RELATIVE_SPEED float64) {
	builder.PrependFloat64Slot(6, TCA_RELATIVE_SPEED, 0.0)
}
func CSMAddMAX_PROB(builder *flatbuffers.Builder, MAX_PROB float64) {
	builder.PrependFloat64Slot(7, MAX_PROB, 0.0)
}
func CSMAddDILUTION(builder *flatbuffers.Builder, DILUTION float64) {
	builder.PrependFloat64Slot(8, DILUTION, 0.0)
}
func CSMEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
