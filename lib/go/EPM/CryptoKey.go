// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package EPM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Represents cryptographic key information
type CryptoKey struct {
	_tab flatbuffers.Table
}

func GetRootAsCryptoKey(buf []byte, offset flatbuffers.UOffsetT) *CryptoKey {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CryptoKey{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCryptoKey(buf []byte, offset flatbuffers.UOffsetT) *CryptoKey {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CryptoKey{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CryptoKey) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CryptoKey) Table() flatbuffers.Table {
	return rcv._tab
}

/// Public part of the cryptographic key, in hexidecimal format
func (rcv *CryptoKey) PUBLIC_KEY() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Public part of the cryptographic key, in hexidecimal format
/// Extended public key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
func (rcv *CryptoKey) XPUB() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Extended public key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
/// Private part of the cryptographic key in hexidecimal format, should be kept secret 
func (rcv *CryptoKey) PRIVATE_KEY() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Private part of the cryptographic key in hexidecimal format, should be kept secret 
/// Extended private key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
func (rcv *CryptoKey) XPRIV() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Extended private key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
/// Address generated from the cryptographic key
func (rcv *CryptoKey) KEY_ADDRESS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Address generated from the cryptographic key
/// Type of the address generated from the cryptographic key
func (rcv *CryptoKey) ADDRESS_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Type of the address generated from the cryptographic key
/// Type of the cryptographic key (signing or encryption)
func (rcv *CryptoKey) KEY_TYPE() KeyType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return KeyType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Type of the cryptographic key (signing or encryption)
func (rcv *CryptoKey) MutateKEY_TYPE(n KeyType) bool {
	return rcv._tab.MutateInt8Slot(16, int8(n))
}

func CryptoKeyStart(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func CryptoKeyAddPUBLIC_KEY(builder *flatbuffers.Builder, PUBLIC_KEY flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(PUBLIC_KEY), 0)
}
func CryptoKeyAddXPUB(builder *flatbuffers.Builder, XPUB flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(XPUB), 0)
}
func CryptoKeyAddPRIVATE_KEY(builder *flatbuffers.Builder, PRIVATE_KEY flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(PRIVATE_KEY), 0)
}
func CryptoKeyAddXPRIV(builder *flatbuffers.Builder, XPRIV flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(XPRIV), 0)
}
func CryptoKeyAddKEY_ADDRESS(builder *flatbuffers.Builder, KEY_ADDRESS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(KEY_ADDRESS), 0)
}
func CryptoKeyAddADDRESS_TYPE(builder *flatbuffers.Builder, ADDRESS_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(ADDRESS_TYPE), 0)
}
func CryptoKeyAddKEY_TYPE(builder *flatbuffers.Builder, KEY_TYPE KeyType) {
	builder.PrependInt8Slot(6, int8(KEY_TYPE), 0)
}
func CryptoKeyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
