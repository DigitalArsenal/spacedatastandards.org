// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package EPM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Represents cryptographic key information
type CryptoKey struct {
	_tab flatbuffers.Table
}

func GetRootAsCryptoKey(buf []byte, offset flatbuffers.UOffsetT) *CryptoKey {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CryptoKey{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCryptoKey(buf []byte, offset flatbuffers.UOffsetT) *CryptoKey {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CryptoKey{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CryptoKey) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CryptoKey) Table() flatbuffers.Table {
	return rcv._tab
}

/// Public part of the cryptographic key
func (rcv *CryptoKey) PUBLIC_KEY() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Public part of the cryptographic key
/// Extended public key
func (rcv *CryptoKey) XPUB() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Extended public key
/// Private part of the cryptographic key, should be kept secret
func (rcv *CryptoKey) PRIVATE_KEY() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Private part of the cryptographic key, should be kept secret
/// Extended private key
func (rcv *CryptoKey) XPRIV() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Extended private key
/// Address generated from the cryptographic key
func (rcv *CryptoKey) KEY_ADDRESS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Address generated from the cryptographic key
/// Numerical type of the address generated from the cryptographic key
func (rcv *CryptoKey) ADDRESS_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Numerical type of the address generated from the cryptographic key
func CryptoKeyStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func CryptoKeyAddPUBLIC_KEY(builder *flatbuffers.Builder, PUBLIC_KEY flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(PUBLIC_KEY), 0)
}
func CryptoKeyAddXPUB(builder *flatbuffers.Builder, XPUB flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(XPUB), 0)
}
func CryptoKeyAddPRIVATE_KEY(builder *flatbuffers.Builder, PRIVATE_KEY flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(PRIVATE_KEY), 0)
}
func CryptoKeyAddXPRIV(builder *flatbuffers.Builder, XPRIV flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(XPRIV), 0)
}
func CryptoKeyAddKEY_ADDRESS(builder *flatbuffers.Builder, KEY_ADDRESS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(KEY_ADDRESS), 0)
}
func CryptoKeyAddADDRESS_TYPE(builder *flatbuffers.Builder, ADDRESS_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(ADDRESS_TYPE), 0)
}
func CryptoKeyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
