// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package EWR

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Electronic Warfare
type EWR struct {
	_tab flatbuffers.Table
}

const EWRIdentifier = "$EWR"

func GetRootAsEWR(buf []byte, offset flatbuffers.UOffsetT) *EWR {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &EWR{}
	x.Init(buf, n+offset)
	return x
}

func FinishEWRBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(EWRIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func EWRBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, EWRIdentifier)
}

func GetSizePrefixedRootAsEWR(buf []byte, offset flatbuffers.UOffsetT) *EWR {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &EWR{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedEWRBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(EWRIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedEWRBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, EWRIdentifier)
}

func (rcv *EWR) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *EWR) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *EWR) SYSTEM_ID() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *EWR) MutateSYSTEM_ID(n uint32) bool {
	return rcv._tab.MutateUint32Slot(4, n)
}

func (rcv *EWR) ENTITY_ID() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *EWR) MutateENTITY_ID(n uint32) bool {
	return rcv._tab.MutateUint32Slot(6, n)
}

func (rcv *EWR) ESM_ACTIVE() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *EWR) MutateESM_ACTIVE(n bool) bool {
	return rcv._tab.MutateBoolSlot(8, n)
}

func (rcv *EWR) ECM_ACTIVE() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *EWR) MutateECM_ACTIVE(n bool) bool {
	return rcv._tab.MutateBoolSlot(10, n)
}

func (rcv *EWR) RWR_ACTIVE() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *EWR) MutateRWR_ACTIVE(n bool) bool {
	return rcv._tab.MutateBoolSlot(12, n)
}

func (rcv *EWR) ESM_CONTACTS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *EWR) ESM_CONTACTSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *EWR) ACTIVE_JAMMING(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *EWR) ACTIVE_JAMMINGLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *EWR) COUNTERMEASURES() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *EWR) THREAT_WARNINGS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *EWR) THREAT_WARNINGSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *EWR) EMCON_LEVEL() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *EWR) MutateEMCON_LEVEL(n byte) bool {
	return rcv._tab.MutateByteSlot(22, n)
}

func (rcv *EWR) LAST_UPDATE_MS() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *EWR) MutateLAST_UPDATE_MS(n int64) bool {
	return rcv._tab.MutateInt64Slot(24, n)
}

func EWRStart(builder *flatbuffers.Builder) {
	builder.StartObject(11)
}
func EWRAddSYSTEM_ID(builder *flatbuffers.Builder, SYSTEM_ID uint32) {
	builder.PrependUint32Slot(0, SYSTEM_ID, 0)
}
func EWRAddENTITY_ID(builder *flatbuffers.Builder, ENTITY_ID uint32) {
	builder.PrependUint32Slot(1, ENTITY_ID, 0)
}
func EWRAddESM_ACTIVE(builder *flatbuffers.Builder, ESM_ACTIVE bool) {
	builder.PrependBoolSlot(2, ESM_ACTIVE, false)
}
func EWRAddECM_ACTIVE(builder *flatbuffers.Builder, ECM_ACTIVE bool) {
	builder.PrependBoolSlot(3, ECM_ACTIVE, false)
}
func EWRAddRWR_ACTIVE(builder *flatbuffers.Builder, RWR_ACTIVE bool) {
	builder.PrependBoolSlot(4, RWR_ACTIVE, false)
}
func EWRAddESM_CONTACTS(builder *flatbuffers.Builder, ESM_CONTACTS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(ESM_CONTACTS), 0)
}
func EWRStartESM_CONTACTSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func EWRAddACTIVE_JAMMING(builder *flatbuffers.Builder, ACTIVE_JAMMING flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(ACTIVE_JAMMING), 0)
}
func EWRStartACTIVE_JAMMINGVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func EWRAddCOUNTERMEASURES(builder *flatbuffers.Builder, COUNTERMEASURES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(COUNTERMEASURES), 0)
}
func EWRAddTHREAT_WARNINGS(builder *flatbuffers.Builder, THREAT_WARNINGS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(THREAT_WARNINGS), 0)
}
func EWRStartTHREAT_WARNINGSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func EWRAddEMCON_LEVEL(builder *flatbuffers.Builder, EMCON_LEVEL byte) {
	builder.PrependByteSlot(9, EMCON_LEVEL, 0)
}
func EWRAddLAST_UPDATE_MS(builder *flatbuffers.Builder, LAST_UPDATE_MS int64) {
	builder.PrependInt64Slot(10, LAST_UPDATE_MS, 0)
}
func EWREnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
