// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package LDM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Launch Data Message
type LDM struct {
	_tab flatbuffers.Table
}

func GetRootAsLDM(buf []byte, offset flatbuffers.UOffsetT) *LDM {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &LDM{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsLDM(buf []byte, offset flatbuffers.UOffsetT) *LDM {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &LDM{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *LDM) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *LDM) Table() flatbuffers.Table {
	return rcv._tab
}

/// Launch Site Information
func (rcv *LDM) SITE(obj *SIT) *SIT {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(SIT)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Launch Site Information
/// Azimuth at Launch (in Degrees)
func (rcv *LDM) AZIMUTH() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Azimuth at Launch (in Degrees)
func (rcv *LDM) MutateAZIMUTH(n float32) bool {
	return rcv._tab.MutateFloat32Slot(6, n)
}

/// References for Launch Data
func (rcv *LDM) REFERENCES() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// References for Launch Data
/// Launching Agency Name
func (rcv *LDM) AGENCY_NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Launching Agency Name
/// Points of Contact for Launch
func (rcv *LDM) POINTS_OF_CONTACT(obj *EPM, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *LDM) POINTS_OF_CONTACTLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Points of Contact for Launch
/// Operations Points of Contact for Launch
func (rcv *LDM) OPERATIONS_POINTS_OF_CONTACT(obj *EPM, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *LDM) OPERATIONS_POINTS_OF_CONTACTLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Operations Points of Contact for Launch
/// Net Launch Time (UTC Format)
func (rcv *LDM) NET() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Net Launch Time (UTC Format)
/// Rocket Configuration Details
func (rcv *LDM) ROCKET_CONFIGURATION(obj *ROC) *ROC {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ROC)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Rocket Configuration Details
/// Mission Name
func (rcv *LDM) MISSION_NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Mission Name
/// Description of the Mission
func (rcv *LDM) MISSION_DESCRIPTION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Description of the Mission
/// Type of the Mission (e.g., Test Flight, Satellite Deployment)
func (rcv *LDM) MISSION_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Type of the Mission (e.g., Test Flight, Satellite Deployment)
/// Target Orbit Type (e.g., LEO, GEO)
func (rcv *LDM) ORBIT_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Target Orbit Type (e.g., LEO, GEO)
/// Weather and Environmental Conditions at Launch
func (rcv *LDM) WEATHER_CONDITIONS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Weather and Environmental Conditions at Launch
/// Launch Outcome and Status (e.g., Successful, Failed)
func (rcv *LDM) LAUNCH_STATUS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Launch Outcome and Status (e.g., Successful, Failed)
/// Webcast URL for the Launch
func (rcv *LDM) WEBCAST_URL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Webcast URL for the Launch
/// Media Links Related to the Launch
func (rcv *LDM) MEDIA_LINKS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *LDM) MEDIA_LINKSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Media Links Related to the Launch
/// Earliest Possible Launch Times
func (rcv *LDM) EARLIEST_LAUNCH_TIMES(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *LDM) EARLIEST_LAUNCH_TIMESLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Earliest Possible Launch Times
/// Latest Possible Launch Times
func (rcv *LDM) LATEST_LAUNCH_TIMES(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *LDM) LATEST_LAUNCH_TIMESLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Latest Possible Launch Times
/// Launch Collision Avoidance Information
func (rcv *LDM) LCOLA_WINDOW_CLOSURES(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *LDM) LCOLA_WINDOW_CLOSURESLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Launch Collision Avoidance Information
/// Payload Information (Catalog Entities)
func (rcv *LDM) OBJECTS(obj *CAT, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *LDM) OBJECTSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Payload Information (Catalog Entities)
/// Tracking and Collision Avoidance Requirements
func (rcv *LDM) TRACKING_REQUIREMENTS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *LDM) TRACKING_REQUIREMENTSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Tracking and Collision Avoidance Requirements
/// Duration of Collision Avoidance Screen (in Seconds)
func (rcv *LDM) COLA_SCREEN_DURATION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Duration of Collision Avoidance Screen (in Seconds)
/// Probability of Collision Threshold (Percentage)
func (rcv *LDM) PROBABILITY_OF_COLLISION_THRESHOLD() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Probability of Collision Threshold (Percentage)
/// Number of Required Collision Avoidance Runs
func (rcv *LDM) COLA_RUNS_REQUIRED() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Number of Required Collision Avoidance Runs
/// Points of Contact for Collision Avoidance
func (rcv *LDM) COLA_POINTS_OF_CONTACT(obj *EPM, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *LDM) COLA_POINTS_OF_CONTACTLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Points of Contact for Collision Avoidance
/// Orbital Parameters of the Launch
func (rcv *LDM) ORBITAL_PARAMETERS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *LDM) ORBITAL_PARAMETERSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Orbital Parameters of the Launch
/// Burn Out Vectors for the Launch
func (rcv *LDM) BURN_OUT_VECTORS(obj *BOV, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *LDM) BURN_OUT_VECTORSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Burn Out Vectors for the Launch
func LDMStart(builder *flatbuffers.Builder) {
	builder.StartObject(27)
}
func LDMAddSITE(builder *flatbuffers.Builder, SITE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(SITE), 0)
}
func LDMAddAZIMUTH(builder *flatbuffers.Builder, AZIMUTH float32) {
	builder.PrependFloat32Slot(1, AZIMUTH, 0.0)
}
func LDMAddREFERENCES(builder *flatbuffers.Builder, REFERENCES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(REFERENCES), 0)
}
func LDMAddAGENCY_NAME(builder *flatbuffers.Builder, AGENCY_NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(AGENCY_NAME), 0)
}
func LDMAddPOINTS_OF_CONTACT(builder *flatbuffers.Builder, POINTS_OF_CONTACT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(POINTS_OF_CONTACT), 0)
}
func LDMStartPOINTS_OF_CONTACTVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LDMAddOPERATIONS_POINTS_OF_CONTACT(builder *flatbuffers.Builder, OPERATIONS_POINTS_OF_CONTACT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(OPERATIONS_POINTS_OF_CONTACT), 0)
}
func LDMStartOPERATIONS_POINTS_OF_CONTACTVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LDMAddNET(builder *flatbuffers.Builder, NET flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(NET), 0)
}
func LDMAddROCKET_CONFIGURATION(builder *flatbuffers.Builder, ROCKET_CONFIGURATION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(ROCKET_CONFIGURATION), 0)
}
func LDMAddMISSION_NAME(builder *flatbuffers.Builder, MISSION_NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(MISSION_NAME), 0)
}
func LDMAddMISSION_DESCRIPTION(builder *flatbuffers.Builder, MISSION_DESCRIPTION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(MISSION_DESCRIPTION), 0)
}
func LDMAddMISSION_TYPE(builder *flatbuffers.Builder, MISSION_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(MISSION_TYPE), 0)
}
func LDMAddORBIT_TYPE(builder *flatbuffers.Builder, ORBIT_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(ORBIT_TYPE), 0)
}
func LDMAddWEATHER_CONDITIONS(builder *flatbuffers.Builder, WEATHER_CONDITIONS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(WEATHER_CONDITIONS), 0)
}
func LDMAddLAUNCH_STATUS(builder *flatbuffers.Builder, LAUNCH_STATUS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(LAUNCH_STATUS), 0)
}
func LDMAddWEBCAST_URL(builder *flatbuffers.Builder, WEBCAST_URL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(WEBCAST_URL), 0)
}
func LDMAddMEDIA_LINKS(builder *flatbuffers.Builder, MEDIA_LINKS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(MEDIA_LINKS), 0)
}
func LDMStartMEDIA_LINKSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LDMAddEARLIEST_LAUNCH_TIMES(builder *flatbuffers.Builder, EARLIEST_LAUNCH_TIMES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(EARLIEST_LAUNCH_TIMES), 0)
}
func LDMStartEARLIEST_LAUNCH_TIMESVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LDMAddLATEST_LAUNCH_TIMES(builder *flatbuffers.Builder, LATEST_LAUNCH_TIMES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(LATEST_LAUNCH_TIMES), 0)
}
func LDMStartLATEST_LAUNCH_TIMESVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LDMAddLCOLA_WINDOW_CLOSURES(builder *flatbuffers.Builder, LCOLA_WINDOW_CLOSURES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(18, flatbuffers.UOffsetT(LCOLA_WINDOW_CLOSURES), 0)
}
func LDMStartLCOLA_WINDOW_CLOSURESVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LDMAddOBJECTS(builder *flatbuffers.Builder, OBJECTS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(19, flatbuffers.UOffsetT(OBJECTS), 0)
}
func LDMStartOBJECTSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LDMAddTRACKING_REQUIREMENTS(builder *flatbuffers.Builder, TRACKING_REQUIREMENTS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(20, flatbuffers.UOffsetT(TRACKING_REQUIREMENTS), 0)
}
func LDMStartTRACKING_REQUIREMENTSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LDMAddCOLA_SCREEN_DURATION(builder *flatbuffers.Builder, COLA_SCREEN_DURATION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(COLA_SCREEN_DURATION), 0)
}
func LDMAddPROBABILITY_OF_COLLISION_THRESHOLD(builder *flatbuffers.Builder, PROBABILITY_OF_COLLISION_THRESHOLD flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(22, flatbuffers.UOffsetT(PROBABILITY_OF_COLLISION_THRESHOLD), 0)
}
func LDMAddCOLA_RUNS_REQUIRED(builder *flatbuffers.Builder, COLA_RUNS_REQUIRED flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(23, flatbuffers.UOffsetT(COLA_RUNS_REQUIRED), 0)
}
func LDMAddCOLA_POINTS_OF_CONTACT(builder *flatbuffers.Builder, COLA_POINTS_OF_CONTACT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(24, flatbuffers.UOffsetT(COLA_POINTS_OF_CONTACT), 0)
}
func LDMStartCOLA_POINTS_OF_CONTACTVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LDMAddORBITAL_PARAMETERS(builder *flatbuffers.Builder, ORBITAL_PARAMETERS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(25, flatbuffers.UOffsetT(ORBITAL_PARAMETERS), 0)
}
func LDMStartORBITAL_PARAMETERSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LDMAddBURN_OUT_VECTORS(builder *flatbuffers.Builder, BURN_OUT_VECTORS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(26, flatbuffers.UOffsetT(BURN_OUT_VECTORS), 0)
}
func LDMStartBURN_OUT_VECTORSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LDMEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
