// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package CTR

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Country Identity Message
type CTR struct {
	_tab flatbuffers.Table
}

func GetRootAsCTR(buf []byte, offset flatbuffers.UOffsetT) *CTR {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CTR{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCTR(buf []byte, offset flatbuffers.UOffsetT) *CTR {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CTR{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CTR) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CTR) Table() flatbuffers.Table {
	return rcv._tab
}

/// ISO 3166 Numeric code
func (rcv *CTR) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// ISO 3166 Numeric code
/// Country name
func (rcv *CTR) NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Country name
/// GENC code
func (rcv *CTR) GENC_CODE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// GENC code
/// ISO 3166 Alpha-2 code
func (rcv *CTR) ALPHA_2_CODE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// ISO 3166 Alpha-2 code
/// ISO 3166 Alpha-3 code
func (rcv *CTR) ALPHA_3_CODE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// ISO 3166 Alpha-3 code
/// Stanag code
func (rcv *CTR) STANAG_CODE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Stanag code
/// Internet country code top-level domain (ccTLD)
func (rcv *CTR) INTERNET_CCTLD() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Internet country code top-level domain (ccTLD)
/// Additional comments
func (rcv *CTR) COMMENT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Additional comments
func CTRStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func CTRAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func CTRAddNAME(builder *flatbuffers.Builder, NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(NAME), 0)
}
func CTRAddGENC_CODE(builder *flatbuffers.Builder, GENC_CODE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(GENC_CODE), 0)
}
func CTRAddALPHA_2_CODE(builder *flatbuffers.Builder, ALPHA_2_CODE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(ALPHA_2_CODE), 0)
}
func CTRAddALPHA_3_CODE(builder *flatbuffers.Builder, ALPHA_3_CODE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(ALPHA_3_CODE), 0)
}
func CTRAddSTANAG_CODE(builder *flatbuffers.Builder, STANAG_CODE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(STANAG_CODE), 0)
}
func CTRAddINTERNET_CCTLD(builder *flatbuffers.Builder, INTERNET_CCTLD flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(INTERNET_CCTLD), 0)
}
func CTRAddCOMMENT(builder *flatbuffers.Builder, COMMENT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(COMMENT), 0)
}
func CTREnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
