// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package STF

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Spatial coverage definition
type SpatialCoverage struct {
	_tab flatbuffers.Table
}

func GetRootAsSpatialCoverage(buf []byte, offset flatbuffers.UOffsetT) *SpatialCoverage {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SpatialCoverage{}
	x.Init(buf, n+offset)
	return x
}

func FinishSpatialCoverageBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsSpatialCoverage(buf []byte, offset flatbuffers.UOffsetT) *SpatialCoverage {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SpatialCoverage{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedSpatialCoverageBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *SpatialCoverage) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SpatialCoverage) Table() flatbuffers.Table {
	return rcv._tab
}

/// Type of coverage: "global", "region", "object_list"
func (rcv *SpatialCoverage) TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Type of coverage: "global", "region", "object_list"
/// Regions covered, e.g., ["LEO", "GEO", "MEO"]
func (rcv *SpatialCoverage) REGIONS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *SpatialCoverage) REGIONSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Regions covered, e.g., ["LEO", "GEO", "MEO"]
/// Specific NORAD IDs or catalog numbers
func (rcv *SpatialCoverage) OBJECT_IDS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *SpatialCoverage) OBJECT_IDSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Specific NORAD IDs or catalog numbers
func SpatialCoverageStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func SpatialCoverageAddTYPE(builder *flatbuffers.Builder, TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(TYPE), 0)
}
func SpatialCoverageAddREGIONS(builder *flatbuffers.Builder, REGIONS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(REGIONS), 0)
}
func SpatialCoverageStartREGIONSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SpatialCoverageAddOBJECT_IDS(builder *flatbuffers.Builder, OBJECT_IDS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(OBJECT_IDS), 0)
}
func SpatialCoverageStartOBJECT_IDSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SpatialCoverageEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
