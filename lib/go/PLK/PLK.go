// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package PLK

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Plugin License Key - Issued license for plugin access
/// Uses ECIES: both parties derive symmetric key via X25519 ECDH
/// Key derivation: X25519(private, peer_public) → HKDF-SHA256 → AES-256-GCM
type PLK struct {
	_tab flatbuffers.Table
}

const PLKIdentifier = "$PLK"

func GetRootAsPLK(buf []byte, offset flatbuffers.UOffsetT) *PLK {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PLK{}
	x.Init(buf, n+offset)
	return x
}

func FinishPLKBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(PLKIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func PLKBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, PLKIdentifier)
}

func GetSizePrefixedRootAsPLK(buf []byte, offset flatbuffers.UOffsetT) *PLK {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &PLK{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedPLKBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(PLKIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedPLKBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, PLKIdentifier)
}

func (rcv *PLK) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PLK) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique license key identifier
func (rcv *PLK) LICENSE_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique license key identifier
/// Plugin ID this license is for
func (rcv *PLK) PLUGIN_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Plugin ID this license is for
/// Plugin version or version range (semver)
func (rcv *PLK) PLUGIN_VERSION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Plugin version or version range (semver)
/// Licensee organization name
func (rcv *PLK) LICENSEE_ORG() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Licensee organization name
/// Licensee contact email
func (rcv *PLK) LICENSEE_EMAIL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Licensee contact email
/// Licensee's SDN Peer ID
func (rcv *PLK) LICENSEE_PEER_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Licensee's SDN Peer ID
/// Licensee's X25519 public key (32 bytes)
func (rcv *PLK) LICENSEE_PUBKEY(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *PLK) LICENSEE_PUBKEYLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *PLK) LICENSEE_PUBKEYBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Licensee's X25519 public key (32 bytes)
func (rcv *PLK) MutateLICENSEE_PUBKEY(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

/// Issuer's X25519 public key (32 bytes)
/// Used with licensee's private key to derive shared secret via ECDH
func (rcv *PLK) ISSUER_PUBKEY(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *PLK) ISSUER_PUBKEYLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *PLK) ISSUER_PUBKEYBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Issuer's X25519 public key (32 bytes)
/// Used with licensee's private key to derive shared secret via ECDH
func (rcv *PLK) MutateISSUER_PUBKEY(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

/// Domain restrictions (empty = any domain allowed)
func (rcv *PLK) ALLOWED_DOMAINS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *PLK) ALLOWED_DOMAINSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Domain restrictions (empty = any domain allowed)
/// TLD restrictions (e.g., ".gov", ".mil", ".edu")
func (rcv *PLK) ALLOWED_TLDS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *PLK) ALLOWED_TLDSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// TLD restrictions (e.g., ".gov", ".mil", ".edu")
/// Type of license
func (rcv *PLK) LICENSE_TYPE() licenseType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return licenseType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Type of license
func (rcv *PLK) MutateLICENSE_TYPE(n licenseType) bool {
	return rcv._tab.MutateInt8Slot(24, int8(n))
}

/// Maximum concurrent activations (0 = unlimited)
func (rcv *PLK) MAX_ACTIVATIONS() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Maximum concurrent activations (0 = unlimited)
func (rcv *PLK) MutateMAX_ACTIVATIONS(n uint32) bool {
	return rcv._tab.MutateUint32Slot(26, n)
}

/// Unix timestamp when license was issued
func (rcv *PLK) ISSUED_AT() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Unix timestamp when license was issued
func (rcv *PLK) MutateISSUED_AT(n uint64) bool {
	return rcv._tab.MutateUint64Slot(28, n)
}

/// Unix timestamp when license becomes valid
func (rcv *PLK) VALID_FROM() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Unix timestamp when license becomes valid
func (rcv *PLK) MutateVALID_FROM(n uint64) bool {
	return rcv._tab.MutateUint64Slot(30, n)
}

/// Unix timestamp when license expires (0 = never expires)
func (rcv *PLK) EXPIRES_AT() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Unix timestamp when license expires (0 = never expires)
func (rcv *PLK) MutateEXPIRES_AT(n uint64) bool {
	return rcv._tab.MutateUint64Slot(32, n)
}

/// Peer ID of the license issuer (OrbPro)
func (rcv *PLK) ISSUER_PEER_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Peer ID of the license issuer (OrbPro)
/// Ed25519 signature from issuer over all fields (except SIGNATURE)
func (rcv *PLK) SIGNATURE(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *PLK) SIGNATURELength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *PLK) SIGNATUREBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Ed25519 signature from issuer over all fields (except SIGNATURE)
func (rcv *PLK) MutateSIGNATURE(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func PLKStart(builder *flatbuffers.Builder) {
	builder.StartObject(17)
}
func PLKAddLICENSE_ID(builder *flatbuffers.Builder, LICENSE_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(LICENSE_ID), 0)
}
func PLKAddPLUGIN_ID(builder *flatbuffers.Builder, PLUGIN_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(PLUGIN_ID), 0)
}
func PLKAddPLUGIN_VERSION(builder *flatbuffers.Builder, PLUGIN_VERSION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(PLUGIN_VERSION), 0)
}
func PLKAddLICENSEE_ORG(builder *flatbuffers.Builder, LICENSEE_ORG flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(LICENSEE_ORG), 0)
}
func PLKAddLICENSEE_EMAIL(builder *flatbuffers.Builder, LICENSEE_EMAIL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(LICENSEE_EMAIL), 0)
}
func PLKAddLICENSEE_PEER_ID(builder *flatbuffers.Builder, LICENSEE_PEER_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(LICENSEE_PEER_ID), 0)
}
func PLKAddLICENSEE_PUBKEY(builder *flatbuffers.Builder, LICENSEE_PUBKEY flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(LICENSEE_PUBKEY), 0)
}
func PLKStartLICENSEE_PUBKEYVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func PLKAddISSUER_PUBKEY(builder *flatbuffers.Builder, ISSUER_PUBKEY flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(ISSUER_PUBKEY), 0)
}
func PLKStartISSUER_PUBKEYVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func PLKAddALLOWED_DOMAINS(builder *flatbuffers.Builder, ALLOWED_DOMAINS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(ALLOWED_DOMAINS), 0)
}
func PLKStartALLOWED_DOMAINSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func PLKAddALLOWED_TLDS(builder *flatbuffers.Builder, ALLOWED_TLDS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(ALLOWED_TLDS), 0)
}
func PLKStartALLOWED_TLDSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func PLKAddLICENSE_TYPE(builder *flatbuffers.Builder, LICENSE_TYPE licenseType) {
	builder.PrependInt8Slot(10, int8(LICENSE_TYPE), 0)
}
func PLKAddMAX_ACTIVATIONS(builder *flatbuffers.Builder, MAX_ACTIVATIONS uint32) {
	builder.PrependUint32Slot(11, MAX_ACTIVATIONS, 0)
}
func PLKAddISSUED_AT(builder *flatbuffers.Builder, ISSUED_AT uint64) {
	builder.PrependUint64Slot(12, ISSUED_AT, 0)
}
func PLKAddVALID_FROM(builder *flatbuffers.Builder, VALID_FROM uint64) {
	builder.PrependUint64Slot(13, VALID_FROM, 0)
}
func PLKAddEXPIRES_AT(builder *flatbuffers.Builder, EXPIRES_AT uint64) {
	builder.PrependUint64Slot(14, EXPIRES_AT, 0)
}
func PLKAddISSUER_PEER_ID(builder *flatbuffers.Builder, ISSUER_PEER_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(ISSUER_PEER_ID), 0)
}
func PLKAddSIGNATURE(builder *flatbuffers.Builder, SIGNATURE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(SIGNATURE), 0)
}
func PLKStartSIGNATUREVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func PLKEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
