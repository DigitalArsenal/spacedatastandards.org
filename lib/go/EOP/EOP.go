// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package EOP

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Earth Orientation Parameters
type EOP struct {
	_tab flatbuffers.Table
}

func GetRootAsEOP(buf []byte, offset flatbuffers.UOffsetT) *EOP {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &EOP{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsEOP(buf []byte, offset flatbuffers.UOffsetT) *EOP {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &EOP{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *EOP) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *EOP) Table() flatbuffers.Table {
	return rcv._tab
}

///  Date in ISO 8601 format, e.g., "2018-01-01T00:00:00Z"
func (rcv *EOP) DATE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

///  Date in ISO 8601 format, e.g., "2018-01-01T00:00:00Z"
///  Modified Julian Date in UTC, e.g., 58119
func (rcv *EOP) MJD() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

///  Modified Julian Date in UTC, e.g., 58119
func (rcv *EOP) MutateMJD(n uint32) bool {
	return rcv._tab.MutateUint32Slot(6, n)
}

///  x component of Pole Wander in radians, e.g., 2.872908911518888E-7
func (rcv *EOP) X_POLE_WANDER_RADIANS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

///  x component of Pole Wander in radians, e.g., 2.872908911518888E-7
func (rcv *EOP) MutateX_POLE_WANDER_RADIANS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(8, n)
}

///  y component of Pole Wander in radians, e.g., 1.2003259523750447E-6
func (rcv *EOP) Y_POLE_WANDER_RADIANS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

///  y component of Pole Wander in radians, e.g., 1.2003259523750447E-6
func (rcv *EOP) MutateY_POLE_WANDER_RADIANS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(10, n)
}

///  x component of Celestial Pole Offset in radians, e.g., 5.720801437092525E-10
func (rcv *EOP) X_CELESTIAL_POLE_OFFSET_RADIANS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

///  x component of Celestial Pole Offset in radians, e.g., 5.720801437092525E-10
func (rcv *EOP) MutateX_CELESTIAL_POLE_OFFSET_RADIANS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(12, n)
}

///  y component of Celestial Pole Offset in radians, e.g., -8.484239419416879E-10
func (rcv *EOP) Y_CELESTIAL_POLE_OFFSET_RADIANS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

///  y component of Celestial Pole Offset in radians, e.g., -8.484239419416879E-10
func (rcv *EOP) MutateY_CELESTIAL_POLE_OFFSET_RADIANS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(14, n)
}

///  UT1 minus UTC in seconds, e.g., 0.2163567
func (rcv *EOP) UT1_MINUS_UTC_SECONDS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

///  UT1 minus UTC in seconds, e.g., 0.2163567
func (rcv *EOP) MutateUT1_MINUS_UTC_SECONDS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(16, n)
}

///  TAI minus UTC in seconds, e.g., 37
func (rcv *EOP) TAI_MINUS_UTC_SECONDS() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

///  TAI minus UTC in seconds, e.g., 37
func (rcv *EOP) MutateTAI_MINUS_UTC_SECONDS(n uint16) bool {
	return rcv._tab.MutateUint16Slot(18, n)
}

///  Correction to Length of Day in seconds, e.g., 8.094E-4
func (rcv *EOP) LENGTH_OF_DAY_CORRECTION_SECONDS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

///  Correction to Length of Day in seconds, e.g., 8.094E-4
func (rcv *EOP) MutateLENGTH_OF_DAY_CORRECTION_SECONDS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(20, n)
}

///  Data type (O = Observed, P = Predicted)
func (rcv *EOP) DATA_TYPE() DataType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return DataType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

///  Data type (O = Observed, P = Predicted)
func (rcv *EOP) MutateDATA_TYPE(n DataType) bool {
	return rcv._tab.MutateInt8Slot(22, int8(n))
}

func EOPStart(builder *flatbuffers.Builder) {
	builder.StartObject(10)
}
func EOPAddDATE(builder *flatbuffers.Builder, DATE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(DATE), 0)
}
func EOPAddMJD(builder *flatbuffers.Builder, MJD uint32) {
	builder.PrependUint32Slot(1, MJD, 0)
}
func EOPAddX_POLE_WANDER_RADIANS(builder *flatbuffers.Builder, X_POLE_WANDER_RADIANS float32) {
	builder.PrependFloat32Slot(2, X_POLE_WANDER_RADIANS, 0.0)
}
func EOPAddY_POLE_WANDER_RADIANS(builder *flatbuffers.Builder, Y_POLE_WANDER_RADIANS float32) {
	builder.PrependFloat32Slot(3, Y_POLE_WANDER_RADIANS, 0.0)
}
func EOPAddX_CELESTIAL_POLE_OFFSET_RADIANS(builder *flatbuffers.Builder, X_CELESTIAL_POLE_OFFSET_RADIANS float32) {
	builder.PrependFloat32Slot(4, X_CELESTIAL_POLE_OFFSET_RADIANS, 0.0)
}
func EOPAddY_CELESTIAL_POLE_OFFSET_RADIANS(builder *flatbuffers.Builder, Y_CELESTIAL_POLE_OFFSET_RADIANS float32) {
	builder.PrependFloat32Slot(5, Y_CELESTIAL_POLE_OFFSET_RADIANS, 0.0)
}
func EOPAddUT1_MINUS_UTC_SECONDS(builder *flatbuffers.Builder, UT1_MINUS_UTC_SECONDS float32) {
	builder.PrependFloat32Slot(6, UT1_MINUS_UTC_SECONDS, 0.0)
}
func EOPAddTAI_MINUS_UTC_SECONDS(builder *flatbuffers.Builder, TAI_MINUS_UTC_SECONDS uint16) {
	builder.PrependUint16Slot(7, TAI_MINUS_UTC_SECONDS, 0)
}
func EOPAddLENGTH_OF_DAY_CORRECTION_SECONDS(builder *flatbuffers.Builder, LENGTH_OF_DAY_CORRECTION_SECONDS float32) {
	builder.PrependFloat32Slot(8, LENGTH_OF_DAY_CORRECTION_SECONDS, 0.0)
}
func EOPAddDATA_TYPE(builder *flatbuffers.Builder, DATA_TYPE DataType) {
	builder.PrependInt8Slot(9, int8(DATA_TYPE), 0)
}
func EOPEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
