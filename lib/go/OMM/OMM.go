// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package OMM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Orbit Mean Elements Message
type OMM struct {
	_tab flatbuffers.Table
}

func GetRootAsOMM(buf []byte, offset flatbuffers.UOffsetT) *OMM {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &OMM{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsOMM(buf []byte, offset flatbuffers.UOffsetT) *OMM {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &OMM{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *OMM) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *OMM) Table() flatbuffers.Table {
	return rcv._tab
}

/// OMM Header
func (rcv *OMM) CCSDS_OMM_VERS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// OMM Header
func (rcv *OMM) MutateCCSDS_OMM_VERS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(4, n)
}

/// Creation Date
func (rcv *OMM) CREATION_DATE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Creation Date
/// Originator
func (rcv *OMM) ORIGINATOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Originator
/// OMM Metadata
/// Satellite Name(s)
func (rcv *OMM) OBJECT_NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// OMM Metadata
/// Satellite Name(s)
/// International Designator (YYYY-NNNAAA)
func (rcv *OMM) OBJECT_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// International Designator (YYYY-NNNAAA)
/// Origin of reference frame (EARTH, MARS, MOON, etc.)
func (rcv *OMM) CENTER_NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Origin of reference frame (EARTH, MARS, MOON, etc.)
/// Name of the reference frame (TEME, EME2000, etc.)
func (rcv *OMM) REF_FRAME() referenceFrame {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return referenceFrame(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 9
}

/// Name of the reference frame (TEME, EME2000, etc.)
func (rcv *OMM) MutateREF_FRAME(n referenceFrame) bool {
	return rcv._tab.MutateInt8Slot(16, int8(n))
}

/// REF_FRAME_EPOCH
func (rcv *OMM) REF_FRAME_EPOCH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// REF_FRAME_EPOCH
/// Time system used for the orbit state and covariance matrix. (UTC)
func (rcv *OMM) TIME_SYSTEM() timeSystem {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return timeSystem(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 11
}

/// Time system used for the orbit state and covariance matrix. (UTC)
func (rcv *OMM) MutateTIME_SYSTEM(n timeSystem) bool {
	return rcv._tab.MutateInt8Slot(20, int8(n))
}

/// Description of the Mean Element Theory. (SGP4,DSST,USM)
func (rcv *OMM) MEAN_ELEMENT_THEORY() meanElementTheory {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return meanElementTheory(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Description of the Mean Element Theory. (SGP4,DSST,USM)
func (rcv *OMM) MutateMEAN_ELEMENT_THEORY(n meanElementTheory) bool {
	return rcv._tab.MutateInt8Slot(22, int8(n))
}

/// Mean Keplerian Elements in the Specified Reference Frame
/// Plain-Text Comment
func (rcv *OMM) COMMENT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Mean Keplerian Elements in the Specified Reference Frame
/// Plain-Text Comment
/// Epoch of Mean Keplerian elements. (ISO 8601)
func (rcv *OMM) EPOCH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Epoch of Mean Keplerian elements. (ISO 8601)
/// Semi-major axis in km or mean motion in rev/day
func (rcv *OMM) SEMI_MAJOR_AXIS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Semi-major axis in km or mean motion in rev/day
func (rcv *OMM) MutateSEMI_MAJOR_AXIS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

/// Mean motion
func (rcv *OMM) MEAN_MOTION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Mean motion
func (rcv *OMM) MutateMEAN_MOTION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(30, n)
}

/// Eccentricity
func (rcv *OMM) ECCENTRICITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Eccentricity
func (rcv *OMM) MutateECCENTRICITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(32, n)
}

/// Inclination
func (rcv *OMM) INCLINATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Inclination
func (rcv *OMM) MutateINCLINATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(34, n)
}

/// Right ascension of ascending node
func (rcv *OMM) RA_OF_ASC_NODE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Right ascension of ascending node
func (rcv *OMM) MutateRA_OF_ASC_NODE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(36, n)
}

/// Argument of pericenter
func (rcv *OMM) ARG_OF_PERICENTER() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Argument of pericenter
func (rcv *OMM) MutateARG_OF_PERICENTER(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

/// Mean anomaly
func (rcv *OMM) MEAN_ANOMALY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Mean anomaly
func (rcv *OMM) MutateMEAN_ANOMALY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// Gravitational Coefficient (Gravitational Constant x Central Mass)
func (rcv *OMM) GM() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Gravitational Coefficient (Gravitational Constant x Central Mass)
func (rcv *OMM) MutateGM(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// Spacecraft Parameters
/// S/C Mass
func (rcv *OMM) MASS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Spacecraft Parameters
/// S/C Mass
func (rcv *OMM) MutateMASS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(44, n)
}

/// Solar Radiation Pressure Area (AR) m**2
func (rcv *OMM) SOLAR_RAD_AREA() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Solar Radiation Pressure Area (AR) m**2
func (rcv *OMM) MutateSOLAR_RAD_AREA(n float64) bool {
	return rcv._tab.MutateFloat64Slot(46, n)
}

/// Solar Radiation Pressure Coefficient (CR)
func (rcv *OMM) SOLAR_RAD_COEFF() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Solar Radiation Pressure Coefficient (CR)
func (rcv *OMM) MutateSOLAR_RAD_COEFF(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

/// Drag Area (AD) m**2
func (rcv *OMM) DRAG_AREA() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Drag Area (AD) m**2
func (rcv *OMM) MutateDRAG_AREA(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

/// Drag Coefficient (CD)
func (rcv *OMM) DRAG_COEFF() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Drag Coefficient (CD)
func (rcv *OMM) MutateDRAG_COEFF(n float64) bool {
	return rcv._tab.MutateFloat64Slot(52, n)
}

/// TLE Related Parameters (This section is only required if MEAN_ELEMENT_THEORY=SGP/SGP4)
/// Default value = 0
func (rcv *OMM) EPHEMERIS_TYPE() ephemerisType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return ephemerisType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 1
}

/// TLE Related Parameters (This section is only required if MEAN_ELEMENT_THEORY=SGP/SGP4)
/// Default value = 0
func (rcv *OMM) MutateEPHEMERIS_TYPE(n ephemerisType) bool {
	return rcv._tab.MutateInt8Slot(54, int8(n))
}

/// Default value = U
func (rcv *OMM) CLASSIFICATION_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Default value = U
/// NORAD Catalog Number (Satellite Number) an integer
func (rcv *OMM) NORAD_CAT_ID() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// NORAD Catalog Number (Satellite Number) an integer
func (rcv *OMM) MutateNORAD_CAT_ID(n uint32) bool {
	return rcv._tab.MutateUint32Slot(58, n)
}

/// Element set number for this satellite
func (rcv *OMM) ELEMENT_SET_NO() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Element set number for this satellite
func (rcv *OMM) MutateELEMENT_SET_NO(n uint32) bool {
	return rcv._tab.MutateUint32Slot(60, n)
}

/// Revolution Number
func (rcv *OMM) REV_AT_EPOCH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Revolution Number
func (rcv *OMM) MutateREV_AT_EPOCH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(62, n)
}

/// SGP/SGP4 drag-like coefficient (in units 1/[Earth radii])
func (rcv *OMM) BSTAR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// SGP/SGP4 drag-like coefficient (in units 1/[Earth radii])
func (rcv *OMM) MutateBSTAR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(64, n)
}

/// First Time Derivative of the Mean Motion
func (rcv *OMM) MEAN_MOTION_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// First Time Derivative of the Mean Motion
func (rcv *OMM) MutateMEAN_MOTION_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(66, n)
}

/// Second Time Derivative of Mean Motion
func (rcv *OMM) MEAN_MOTION_DDOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Second Time Derivative of Mean Motion
func (rcv *OMM) MutateMEAN_MOTION_DDOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(68, n)
}

/// Position/Velocity Covariance Matrix
/// Reference frame for the covariance matrix
func (rcv *OMM) COV_REF_FRAME() manCovRefFrame {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return manCovRefFrame(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Position/Velocity Covariance Matrix
/// Reference frame for the covariance matrix
func (rcv *OMM) MutateCOV_REF_FRAME(n manCovRefFrame) bool {
	return rcv._tab.MutateInt8Slot(70, int8(n))
}

/// Covariance matrix [1,1] km**2
func (rcv *OMM) CX_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [1,1] km**2
func (rcv *OMM) MutateCX_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(72, n)
}

/// Covariance matrix [2,1] km**2
func (rcv *OMM) CY_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [2,1] km**2
func (rcv *OMM) MutateCY_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(74, n)
}

/// Covariance matrix [2,2] km**2
func (rcv *OMM) CY_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [2,2] km**2
func (rcv *OMM) MutateCY_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(76, n)
}

/// Covariance matrix [3,1] km**2
func (rcv *OMM) CZ_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [3,1] km**2
func (rcv *OMM) MutateCZ_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(78, n)
}

/// Covariance matrix [3,2] km**2
func (rcv *OMM) CZ_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [3,2] km**2
func (rcv *OMM) MutateCZ_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(80, n)
}

/// Covariance matrix [3,3] km**2
func (rcv *OMM) CZ_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [3,3] km**2
func (rcv *OMM) MutateCZ_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(82, n)
}

/// Covariance matrix [4,1] km**2/s
func (rcv *OMM) CX_DOT_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [4,1] km**2/s
func (rcv *OMM) MutateCX_DOT_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(84, n)
}

/// Covariance matrix [4,2] km**2/s
func (rcv *OMM) CX_DOT_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [4,2] km**2/s
func (rcv *OMM) MutateCX_DOT_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(86, n)
}

/// Covariance matrix [4,3] km**2/s
func (rcv *OMM) CX_DOT_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [4,3] km**2/s
func (rcv *OMM) MutateCX_DOT_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(88, n)
}

/// Covariance matrix [4,4] km**2/s**2
func (rcv *OMM) CX_DOT_X_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(90))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [4,4] km**2/s**2
func (rcv *OMM) MutateCX_DOT_X_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(90, n)
}

/// Covariance matrix [5,1] km**2/s
func (rcv *OMM) CY_DOT_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(92))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [5,1] km**2/s
func (rcv *OMM) MutateCY_DOT_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(92, n)
}

/// Covariance matrix [5,2] km**2/s
func (rcv *OMM) CY_DOT_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(94))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [5,2] km**2/s
func (rcv *OMM) MutateCY_DOT_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(94, n)
}

/// Covariance matrix [5,3] km**2/s
func (rcv *OMM) CY_DOT_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(96))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [5,3] km**2/s
func (rcv *OMM) MutateCY_DOT_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(96, n)
}

/// Covariance matrix [5,4] km**2/s**2
func (rcv *OMM) CY_DOT_X_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [5,4] km**2/s**2
func (rcv *OMM) MutateCY_DOT_X_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(98, n)
}

/// Covariance matrix [5,5] km**2/s**2
func (rcv *OMM) CY_DOT_Y_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(100))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [5,5] km**2/s**2
func (rcv *OMM) MutateCY_DOT_Y_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(100, n)
}

/// Covariance matrix [6,1] km**2/s
func (rcv *OMM) CZ_DOT_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [6,1] km**2/s
func (rcv *OMM) MutateCZ_DOT_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(102, n)
}

/// Covariance matrix [6,2] km**2/s
func (rcv *OMM) CZ_DOT_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [6,2] km**2/s
func (rcv *OMM) MutateCZ_DOT_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(104, n)
}

/// Covariance matrix [6,3] km**2/s
func (rcv *OMM) CZ_DOT_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [6,3] km**2/s
func (rcv *OMM) MutateCZ_DOT_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(106, n)
}

/// Covariance matrix [6,4] km**2/s**2
func (rcv *OMM) CZ_DOT_X_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [6,4] km**2/s**2
func (rcv *OMM) MutateCZ_DOT_X_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(108, n)
}

/// Covariance matrix [6,5] km**2/s**2
func (rcv *OMM) CZ_DOT_Y_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [6,5] km**2/s**2
func (rcv *OMM) MutateCZ_DOT_Y_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(110, n)
}

/// Covariance matrix [6,6] km**2/s**2
func (rcv *OMM) CZ_DOT_Z_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Covariance matrix [6,6] km**2/s**2
func (rcv *OMM) MutateCZ_DOT_Z_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(112, n)
}

/// User defined parameter, must be described in an ICD
func (rcv *OMM) USER_DEFINED_BIP_0044_TYPE() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// User defined parameter, must be described in an ICD
func (rcv *OMM) MutateUSER_DEFINED_BIP_0044_TYPE(n uint32) bool {
	return rcv._tab.MutateUint32Slot(114, n)
}

/// User defined parameter, must be described in an ICD
func (rcv *OMM) USER_DEFINED_OBJECT_DESIGNATOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// User defined parameter, must be described in an ICD
/// User defined parameter, must be described in an ICD
func (rcv *OMM) USER_DEFINED_EARTH_MODEL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// User defined parameter, must be described in an ICD
/// User defined parameter, must be described in an ICD
func (rcv *OMM) USER_DEFINED_EPOCH_TIMESTAMP() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(120))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// User defined parameter, must be described in an ICD
func (rcv *OMM) MutateUSER_DEFINED_EPOCH_TIMESTAMP(n float64) bool {
	return rcv._tab.MutateFloat64Slot(120, n)
}

/// User defined parameter, must be described in an ICD
func (rcv *OMM) USER_DEFINED_MICROSECONDS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(122))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// User defined parameter, must be described in an ICD
func (rcv *OMM) MutateUSER_DEFINED_MICROSECONDS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(122, n)
}

func OMMStart(builder *flatbuffers.Builder) {
	builder.StartObject(60)
}
func OMMAddCCSDS_OMM_VERS(builder *flatbuffers.Builder, CCSDS_OMM_VERS float64) {
	builder.PrependFloat64Slot(0, CCSDS_OMM_VERS, 0.0)
}
func OMMAddCREATION_DATE(builder *flatbuffers.Builder, CREATION_DATE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(CREATION_DATE), 0)
}
func OMMAddORIGINATOR(builder *flatbuffers.Builder, ORIGINATOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(ORIGINATOR), 0)
}
func OMMAddOBJECT_NAME(builder *flatbuffers.Builder, OBJECT_NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(OBJECT_NAME), 0)
}
func OMMAddOBJECT_ID(builder *flatbuffers.Builder, OBJECT_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(OBJECT_ID), 0)
}
func OMMAddCENTER_NAME(builder *flatbuffers.Builder, CENTER_NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(CENTER_NAME), 0)
}
func OMMAddREF_FRAME(builder *flatbuffers.Builder, REF_FRAME referenceFrame) {
	builder.PrependInt8Slot(6, int8(REF_FRAME), 9)
}
func OMMAddREF_FRAME_EPOCH(builder *flatbuffers.Builder, REF_FRAME_EPOCH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(REF_FRAME_EPOCH), 0)
}
func OMMAddTIME_SYSTEM(builder *flatbuffers.Builder, TIME_SYSTEM timeSystem) {
	builder.PrependInt8Slot(8, int8(TIME_SYSTEM), 11)
}
func OMMAddMEAN_ELEMENT_THEORY(builder *flatbuffers.Builder, MEAN_ELEMENT_THEORY meanElementTheory) {
	builder.PrependInt8Slot(9, int8(MEAN_ELEMENT_THEORY), 0)
}
func OMMAddCOMMENT(builder *flatbuffers.Builder, COMMENT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(COMMENT), 0)
}
func OMMAddEPOCH(builder *flatbuffers.Builder, EPOCH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(EPOCH), 0)
}
func OMMAddSEMI_MAJOR_AXIS(builder *flatbuffers.Builder, SEMI_MAJOR_AXIS float64) {
	builder.PrependFloat64Slot(12, SEMI_MAJOR_AXIS, 0.0)
}
func OMMAddMEAN_MOTION(builder *flatbuffers.Builder, MEAN_MOTION float64) {
	builder.PrependFloat64Slot(13, MEAN_MOTION, 0.0)
}
func OMMAddECCENTRICITY(builder *flatbuffers.Builder, ECCENTRICITY float64) {
	builder.PrependFloat64Slot(14, ECCENTRICITY, 0.0)
}
func OMMAddINCLINATION(builder *flatbuffers.Builder, INCLINATION float64) {
	builder.PrependFloat64Slot(15, INCLINATION, 0.0)
}
func OMMAddRA_OF_ASC_NODE(builder *flatbuffers.Builder, RA_OF_ASC_NODE float64) {
	builder.PrependFloat64Slot(16, RA_OF_ASC_NODE, 0.0)
}
func OMMAddARG_OF_PERICENTER(builder *flatbuffers.Builder, ARG_OF_PERICENTER float64) {
	builder.PrependFloat64Slot(17, ARG_OF_PERICENTER, 0.0)
}
func OMMAddMEAN_ANOMALY(builder *flatbuffers.Builder, MEAN_ANOMALY float64) {
	builder.PrependFloat64Slot(18, MEAN_ANOMALY, 0.0)
}
func OMMAddGM(builder *flatbuffers.Builder, GM float64) {
	builder.PrependFloat64Slot(19, GM, 0.0)
}
func OMMAddMASS(builder *flatbuffers.Builder, MASS float64) {
	builder.PrependFloat64Slot(20, MASS, 0.0)
}
func OMMAddSOLAR_RAD_AREA(builder *flatbuffers.Builder, SOLAR_RAD_AREA float64) {
	builder.PrependFloat64Slot(21, SOLAR_RAD_AREA, 0.0)
}
func OMMAddSOLAR_RAD_COEFF(builder *flatbuffers.Builder, SOLAR_RAD_COEFF float64) {
	builder.PrependFloat64Slot(22, SOLAR_RAD_COEFF, 0.0)
}
func OMMAddDRAG_AREA(builder *flatbuffers.Builder, DRAG_AREA float64) {
	builder.PrependFloat64Slot(23, DRAG_AREA, 0.0)
}
func OMMAddDRAG_COEFF(builder *flatbuffers.Builder, DRAG_COEFF float64) {
	builder.PrependFloat64Slot(24, DRAG_COEFF, 0.0)
}
func OMMAddEPHEMERIS_TYPE(builder *flatbuffers.Builder, EPHEMERIS_TYPE ephemerisType) {
	builder.PrependInt8Slot(25, int8(EPHEMERIS_TYPE), 1)
}
func OMMAddCLASSIFICATION_TYPE(builder *flatbuffers.Builder, CLASSIFICATION_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(26, flatbuffers.UOffsetT(CLASSIFICATION_TYPE), 0)
}
func OMMAddNORAD_CAT_ID(builder *flatbuffers.Builder, NORAD_CAT_ID uint32) {
	builder.PrependUint32Slot(27, NORAD_CAT_ID, 0)
}
func OMMAddELEMENT_SET_NO(builder *flatbuffers.Builder, ELEMENT_SET_NO uint32) {
	builder.PrependUint32Slot(28, ELEMENT_SET_NO, 0)
}
func OMMAddREV_AT_EPOCH(builder *flatbuffers.Builder, REV_AT_EPOCH float64) {
	builder.PrependFloat64Slot(29, REV_AT_EPOCH, 0.0)
}
func OMMAddBSTAR(builder *flatbuffers.Builder, BSTAR float64) {
	builder.PrependFloat64Slot(30, BSTAR, 0.0)
}
func OMMAddMEAN_MOTION_DOT(builder *flatbuffers.Builder, MEAN_MOTION_DOT float64) {
	builder.PrependFloat64Slot(31, MEAN_MOTION_DOT, 0.0)
}
func OMMAddMEAN_MOTION_DDOT(builder *flatbuffers.Builder, MEAN_MOTION_DDOT float64) {
	builder.PrependFloat64Slot(32, MEAN_MOTION_DDOT, 0.0)
}
func OMMAddCOV_REF_FRAME(builder *flatbuffers.Builder, COV_REF_FRAME manCovRefFrame) {
	builder.PrependInt8Slot(33, int8(COV_REF_FRAME), 0)
}
func OMMAddCX_X(builder *flatbuffers.Builder, CX_X float64) {
	builder.PrependFloat64Slot(34, CX_X, 0.0)
}
func OMMAddCY_X(builder *flatbuffers.Builder, CY_X float64) {
	builder.PrependFloat64Slot(35, CY_X, 0.0)
}
func OMMAddCY_Y(builder *flatbuffers.Builder, CY_Y float64) {
	builder.PrependFloat64Slot(36, CY_Y, 0.0)
}
func OMMAddCZ_X(builder *flatbuffers.Builder, CZ_X float64) {
	builder.PrependFloat64Slot(37, CZ_X, 0.0)
}
func OMMAddCZ_Y(builder *flatbuffers.Builder, CZ_Y float64) {
	builder.PrependFloat64Slot(38, CZ_Y, 0.0)
}
func OMMAddCZ_Z(builder *flatbuffers.Builder, CZ_Z float64) {
	builder.PrependFloat64Slot(39, CZ_Z, 0.0)
}
func OMMAddCX_DOT_X(builder *flatbuffers.Builder, CX_DOT_X float64) {
	builder.PrependFloat64Slot(40, CX_DOT_X, 0.0)
}
func OMMAddCX_DOT_Y(builder *flatbuffers.Builder, CX_DOT_Y float64) {
	builder.PrependFloat64Slot(41, CX_DOT_Y, 0.0)
}
func OMMAddCX_DOT_Z(builder *flatbuffers.Builder, CX_DOT_Z float64) {
	builder.PrependFloat64Slot(42, CX_DOT_Z, 0.0)
}
func OMMAddCX_DOT_X_DOT(builder *flatbuffers.Builder, CX_DOT_X_DOT float64) {
	builder.PrependFloat64Slot(43, CX_DOT_X_DOT, 0.0)
}
func OMMAddCY_DOT_X(builder *flatbuffers.Builder, CY_DOT_X float64) {
	builder.PrependFloat64Slot(44, CY_DOT_X, 0.0)
}
func OMMAddCY_DOT_Y(builder *flatbuffers.Builder, CY_DOT_Y float64) {
	builder.PrependFloat64Slot(45, CY_DOT_Y, 0.0)
}
func OMMAddCY_DOT_Z(builder *flatbuffers.Builder, CY_DOT_Z float64) {
	builder.PrependFloat64Slot(46, CY_DOT_Z, 0.0)
}
func OMMAddCY_DOT_X_DOT(builder *flatbuffers.Builder, CY_DOT_X_DOT float64) {
	builder.PrependFloat64Slot(47, CY_DOT_X_DOT, 0.0)
}
func OMMAddCY_DOT_Y_DOT(builder *flatbuffers.Builder, CY_DOT_Y_DOT float64) {
	builder.PrependFloat64Slot(48, CY_DOT_Y_DOT, 0.0)
}
func OMMAddCZ_DOT_X(builder *flatbuffers.Builder, CZ_DOT_X float64) {
	builder.PrependFloat64Slot(49, CZ_DOT_X, 0.0)
}
func OMMAddCZ_DOT_Y(builder *flatbuffers.Builder, CZ_DOT_Y float64) {
	builder.PrependFloat64Slot(50, CZ_DOT_Y, 0.0)
}
func OMMAddCZ_DOT_Z(builder *flatbuffers.Builder, CZ_DOT_Z float64) {
	builder.PrependFloat64Slot(51, CZ_DOT_Z, 0.0)
}
func OMMAddCZ_DOT_X_DOT(builder *flatbuffers.Builder, CZ_DOT_X_DOT float64) {
	builder.PrependFloat64Slot(52, CZ_DOT_X_DOT, 0.0)
}
func OMMAddCZ_DOT_Y_DOT(builder *flatbuffers.Builder, CZ_DOT_Y_DOT float64) {
	builder.PrependFloat64Slot(53, CZ_DOT_Y_DOT, 0.0)
}
func OMMAddCZ_DOT_Z_DOT(builder *flatbuffers.Builder, CZ_DOT_Z_DOT float64) {
	builder.PrependFloat64Slot(54, CZ_DOT_Z_DOT, 0.0)
}
func OMMAddUSER_DEFINED_BIP_0044_TYPE(builder *flatbuffers.Builder, USER_DEFINED_BIP_0044_TYPE uint32) {
	builder.PrependUint32Slot(55, USER_DEFINED_BIP_0044_TYPE, 0)
}
func OMMAddUSER_DEFINED_OBJECT_DESIGNATOR(builder *flatbuffers.Builder, USER_DEFINED_OBJECT_DESIGNATOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(56, flatbuffers.UOffsetT(USER_DEFINED_OBJECT_DESIGNATOR), 0)
}
func OMMAddUSER_DEFINED_EARTH_MODEL(builder *flatbuffers.Builder, USER_DEFINED_EARTH_MODEL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(57, flatbuffers.UOffsetT(USER_DEFINED_EARTH_MODEL), 0)
}
func OMMAddUSER_DEFINED_EPOCH_TIMESTAMP(builder *flatbuffers.Builder, USER_DEFINED_EPOCH_TIMESTAMP float64) {
	builder.PrependFloat64Slot(58, USER_DEFINED_EPOCH_TIMESTAMP, 0.0)
}
func OMMAddUSER_DEFINED_MICROSECONDS(builder *flatbuffers.Builder, USER_DEFINED_MICROSECONDS float64) {
	builder.PrependFloat64Slot(59, USER_DEFINED_MICROSECONDS, 0.0)
}
func OMMEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
