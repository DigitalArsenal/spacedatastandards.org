// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package OMM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Orbit Mean Elements Message
type OMM struct {
	_tab flatbuffers.Table
}

const OMMIdentifier = "$OMM"

func GetRootAsOMM(buf []byte, offset flatbuffers.UOffsetT) *OMM {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &OMM{}
	x.Init(buf, n+offset)
	return x
}

func FinishOMMBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(OMMIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func OMMBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, OMMIdentifier)
}

func GetSizePrefixedRootAsOMM(buf []byte, offset flatbuffers.UOffsetT) *OMM {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &OMM{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedOMMBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(OMMIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedOMMBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, OMMIdentifier)
}

func (rcv *OMM) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *OMM) Table() flatbuffers.Table {
	return rcv._tab
}

/// CCSDS OMM Version 
func (rcv *OMM) CCSDS_OMM_VERS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CCSDS OMM Version 
func (rcv *OMM) MutateCCSDS_OMM_VERS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(4, n)
}

/// Creation Date (ISO 8601 UTC format) 
func (rcv *OMM) CREATION_DATE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Creation Date (ISO 8601 UTC format) 
/// Originator 
func (rcv *OMM) ORIGINATOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Originator 
/// Satellite Name(s)
func (rcv *OMM) OBJECT_NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Satellite Name(s)
/// International Designator (YYYY-NNNAAA)
func (rcv *OMM) OBJECT_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// International Designator (YYYY-NNNAAA)
/// Center Name (e.g. EARTH, MARS)
func (rcv *OMM) CENTER_NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Center Name (e.g. EARTH, MARS)
/// Reference Frame
func (rcv *OMM) REFERENCE_FRAME() refFrame {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return refFrame(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 2
}

/// Reference Frame
func (rcv *OMM) MutateREFERENCE_FRAME(n refFrame) bool {
	return rcv._tab.MutateInt8Slot(16, int8(n))
}

/// Reference Frame Epoch (ISO 8601 UTC format)
func (rcv *OMM) REFERENCE_FRAME_EPOCH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Reference Frame Epoch (ISO 8601 UTC format)
/// Time System [M, UTC]
func (rcv *OMM) TIME_SYSTEM() timeSystem {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return timeSystem(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 11
}

/// Time System [M, UTC]
func (rcv *OMM) MutateTIME_SYSTEM(n timeSystem) bool {
	return rcv._tab.MutateInt8Slot(20, int8(n))
}

/// Mean Element Theory
func (rcv *OMM) MEAN_ELEMENT_THEORY() meanElementTheory {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return meanElementTheory(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Mean Element Theory
func (rcv *OMM) MutateMEAN_ELEMENT_THEORY(n meanElementTheory) bool {
	return rcv._tab.MutateInt8Slot(22, int8(n))
}

/// COMMENT (O)
func (rcv *OMM) COMMENT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// COMMENT (O)
/// EPOCH of Mean Keplerian elements (ISO 8601 UTC format)
func (rcv *OMM) EPOCH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// EPOCH of Mean Keplerian elements (ISO 8601 UTC format)
/// Semi-major axis in km or Mean Motion in rev/day
func (rcv *OMM) SEMI_MAJOR_AXIS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Semi-major axis in km or Mean Motion in rev/day
func (rcv *OMM) MutateSEMI_MAJOR_AXIS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

/// Mean motion in rev/day if MEAN_ELEMENT_THEORY=SGP/SGP4 else unused
func (rcv *OMM) MEAN_MOTION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Mean motion in rev/day if MEAN_ELEMENT_THEORY=SGP/SGP4 else unused
func (rcv *OMM) MutateMEAN_MOTION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(30, n)
}

/// Eccentricity (unitless)
func (rcv *OMM) ECCENTRICITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Eccentricity (unitless)
func (rcv *OMM) MutateECCENTRICITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(32, n)
}

/// Inclination in degrees
func (rcv *OMM) INCLINATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Inclination in degrees
func (rcv *OMM) MutateINCLINATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(34, n)
}

/// RA_OF_ASC_NODE in degrees
func (rcv *OMM) RA_OF_ASC_NODE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// RA_OF_ASC_NODE in degrees
func (rcv *OMM) MutateRA_OF_ASC_NODE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(36, n)
}

/// ARG_OF_PERICENTER in degrees
func (rcv *OMM) ARG_OF_PERICENTER() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// ARG_OF_PERICENTER in degrees
func (rcv *OMM) MutateARG_OF_PERICENTER(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

/// MEAN_ANOMALY in degrees
func (rcv *OMM) MEAN_ANOMALY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// MEAN_ANOMALY in degrees
func (rcv *OMM) MutateMEAN_ANOMALY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// GM in km**3/s**2
func (rcv *OMM) GM() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// GM in km**3/s**2
func (rcv *OMM) MutateGM(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// MASS in kg
func (rcv *OMM) MASS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// MASS in kg
func (rcv *OMM) MutateMASS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(44, n)
}

/// SOLAR_RAD_AREA in m**2
func (rcv *OMM) SOLAR_RAD_AREA() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// SOLAR_RAD_AREA in m**2
func (rcv *OMM) MutateSOLAR_RAD_AREA(n float64) bool {
	return rcv._tab.MutateFloat64Slot(46, n)
}

/// SOLAR_RAD_COEFF (unitless)
func (rcv *OMM) SOLAR_RAD_COEFF() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// SOLAR_RAD_COEFF (unitless)
func (rcv *OMM) MutateSOLAR_RAD_COEFF(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

/// DRAG_AREA in m**2
func (rcv *OMM) DRAG_AREA() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// DRAG_AREA in m**2
func (rcv *OMM) MutateDRAG_AREA(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

/// DRAG_COEFF (unitless)
func (rcv *OMM) DRAG_COEFF() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// DRAG_COEFF (unitless)
func (rcv *OMM) MutateDRAG_COEFF(n float64) bool {
	return rcv._tab.MutateFloat64Slot(52, n)
}

/// TLE Related Parameters (Only if MEAN_ELEMENT_THEORY=SGP/SGP4)
/// EPHEMERIS_TYPE Default=0
func (rcv *OMM) EPHEMERIS_TYPE() ephemerisType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return ephemerisType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 1
}

/// TLE Related Parameters (Only if MEAN_ELEMENT_THEORY=SGP/SGP4)
/// EPHEMERIS_TYPE Default=0
func (rcv *OMM) MutateEPHEMERIS_TYPE(n ephemerisType) bool {
	return rcv._tab.MutateInt8Slot(54, int8(n))
}

/// CLASSIFICATION_TYPE Default=U
func (rcv *OMM) CLASSIFICATION_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// CLASSIFICATION_TYPE Default=U
/// NORAD_CAT_ID (integer) [O if SGP/SGP4]
func (rcv *OMM) NORAD_CAT_ID() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// NORAD_CAT_ID (integer) [O if SGP/SGP4]
func (rcv *OMM) MutateNORAD_CAT_ID(n uint32) bool {
	return rcv._tab.MutateUint32Slot(58, n)
}

/// ELEMENT_SET_NO [O if SGP/SGP4]
func (rcv *OMM) ELEMENT_SET_NO() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// ELEMENT_SET_NO [O if SGP/SGP4]
func (rcv *OMM) MutateELEMENT_SET_NO(n uint32) bool {
	return rcv._tab.MutateUint32Slot(60, n)
}

/// REV_AT_EPOCH [O if SGP/SGP4]
func (rcv *OMM) REV_AT_EPOCH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// REV_AT_EPOCH [O if SGP/SGP4]
func (rcv *OMM) MutateREV_AT_EPOCH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(62, n)
}

/// BSTAR in 1/Earth radii or BTERM in m²/kg depending on MEAN_ELEMENT_THEORY [C]
func (rcv *OMM) BSTAR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// BSTAR in 1/Earth radii or BTERM in m²/kg depending on MEAN_ELEMENT_THEORY [C]
func (rcv *OMM) MutateBSTAR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(64, n)
}

/// MEAN_MOTION_DOT in rev/day² [C if SGP or PPT3]
func (rcv *OMM) MEAN_MOTION_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// MEAN_MOTION_DOT in rev/day² [C if SGP or PPT3]
func (rcv *OMM) MutateMEAN_MOTION_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(66, n)
}

/// MEAN_MOTION_DDOT in rev/day³ if SGP/PPT3 or AGOM in m²/kg if SGP4-XP [C]
func (rcv *OMM) MEAN_MOTION_DDOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// MEAN_MOTION_DDOT in rev/day³ if SGP/PPT3 or AGOM in m²/kg if SGP4-XP [C]
func (rcv *OMM) MutateMEAN_MOTION_DDOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(68, n)
}

/// Position/Velocity Covariance Matrix (6x6 Lower Triangular) [C if any covariance provided]
/// COV_REF_FRAME reference frame for covariance [C if covariance given]
func (rcv *OMM) COV_REFERENCE_FRAME() refFrame {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return refFrame(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 23
}

/// Position/Velocity Covariance Matrix (6x6 Lower Triangular) [C if any covariance provided]
/// COV_REF_FRAME reference frame for covariance [C if covariance given]
func (rcv *OMM) MutateCOV_REFERENCE_FRAME(n refFrame) bool {
	return rcv._tab.MutateInt8Slot(70, int8(n))
}

/// CX_X [km**2]
func (rcv *OMM) CX_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CX_X [km**2]
func (rcv *OMM) MutateCX_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(72, n)
}

/// CY_X [km**2]
func (rcv *OMM) CY_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CY_X [km**2]
func (rcv *OMM) MutateCY_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(74, n)
}

/// CY_Y [km**2]
func (rcv *OMM) CY_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CY_Y [km**2]
func (rcv *OMM) MutateCY_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(76, n)
}

/// CZ_X [km**2]
func (rcv *OMM) CZ_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CZ_X [km**2]
func (rcv *OMM) MutateCZ_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(78, n)
}

/// CZ_Y [km**2]
func (rcv *OMM) CZ_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CZ_Y [km**2]
func (rcv *OMM) MutateCZ_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(80, n)
}

/// CZ_Z [km**2]
func (rcv *OMM) CZ_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CZ_Z [km**2]
func (rcv *OMM) MutateCZ_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(82, n)
}

/// CX_DOT_X [km**2/s]
func (rcv *OMM) CX_DOT_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CX_DOT_X [km**2/s]
func (rcv *OMM) MutateCX_DOT_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(84, n)
}

/// CX_DOT_Y [km**2/s]
func (rcv *OMM) CX_DOT_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CX_DOT_Y [km**2/s]
func (rcv *OMM) MutateCX_DOT_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(86, n)
}

/// CX_DOT_Z [km**2/s]
func (rcv *OMM) CX_DOT_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CX_DOT_Z [km**2/s]
func (rcv *OMM) MutateCX_DOT_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(88, n)
}

/// CX_DOT_X_DOT [km**2/s**2]
func (rcv *OMM) CX_DOT_X_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(90))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CX_DOT_X_DOT [km**2/s**2]
func (rcv *OMM) MutateCX_DOT_X_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(90, n)
}

/// CY_DOT_X [km**2/s]
func (rcv *OMM) CY_DOT_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(92))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CY_DOT_X [km**2/s]
func (rcv *OMM) MutateCY_DOT_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(92, n)
}

/// CY_DOT_Y [km**2/s]
func (rcv *OMM) CY_DOT_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(94))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CY_DOT_Y [km**2/s]
func (rcv *OMM) MutateCY_DOT_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(94, n)
}

/// CY_DOT_Z [km**2/s]
func (rcv *OMM) CY_DOT_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(96))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CY_DOT_Z [km**2/s]
func (rcv *OMM) MutateCY_DOT_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(96, n)
}

/// CY_DOT_X_DOT [km**2/s**2]
func (rcv *OMM) CY_DOT_X_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CY_DOT_X_DOT [km**2/s**2]
func (rcv *OMM) MutateCY_DOT_X_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(98, n)
}

/// CY_DOT_Y_DOT [km**2/s**2]
func (rcv *OMM) CY_DOT_Y_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(100))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CY_DOT_Y_DOT [km**2/s**2]
func (rcv *OMM) MutateCY_DOT_Y_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(100, n)
}

/// CZ_DOT_X [km**2/s]
func (rcv *OMM) CZ_DOT_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CZ_DOT_X [km**2/s]
func (rcv *OMM) MutateCZ_DOT_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(102, n)
}

/// CZ_DOT_Y [km**2/s]
func (rcv *OMM) CZ_DOT_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CZ_DOT_Y [km**2/s]
func (rcv *OMM) MutateCZ_DOT_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(104, n)
}

/// CZ_DOT_Z [km**2/s]
func (rcv *OMM) CZ_DOT_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CZ_DOT_Z [km**2/s]
func (rcv *OMM) MutateCZ_DOT_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(106, n)
}

/// CZ_DOT_X_DOT [km**2/s**2]
func (rcv *OMM) CZ_DOT_X_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CZ_DOT_X_DOT [km**2/s**2]
func (rcv *OMM) MutateCZ_DOT_X_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(108, n)
}

/// CZ_DOT_Y_DOT [km**2/s**2]
func (rcv *OMM) CZ_DOT_Y_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CZ_DOT_Y_DOT [km**2/s**2]
func (rcv *OMM) MutateCZ_DOT_Y_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(110, n)
}

/// CZ_DOT_Z_DOT [km**2/s**2]
func (rcv *OMM) CZ_DOT_Z_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// CZ_DOT_Z_DOT [km**2/s**2]
func (rcv *OMM) MutateCZ_DOT_Z_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(112, n)
}

/// USER_DEFINED_BIP_0044_TYPE [O, units per ICD]
func (rcv *OMM) USER_DEFINED_BIP_0044_TYPE() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// USER_DEFINED_BIP_0044_TYPE [O, units per ICD]
func (rcv *OMM) MutateUSER_DEFINED_BIP_0044_TYPE(n uint32) bool {
	return rcv._tab.MutateUint32Slot(114, n)
}

/// USER_DEFINED_OBJECT_DESIGNATOR [O, units per ICD]
func (rcv *OMM) USER_DEFINED_OBJECT_DESIGNATOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// USER_DEFINED_OBJECT_DESIGNATOR [O, units per ICD]
/// USER_DEFINED_EARTH_MODEL [O, units per ICD]
func (rcv *OMM) USER_DEFINED_EARTH_MODEL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// USER_DEFINED_EARTH_MODEL [O, units per ICD]
/// USER_DEFINED_EPOCH_TIMESTAMP [O, units per ICD]
func (rcv *OMM) USER_DEFINED_EPOCH_TIMESTAMP() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(120))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// USER_DEFINED_EPOCH_TIMESTAMP [O, units per ICD]
func (rcv *OMM) MutateUSER_DEFINED_EPOCH_TIMESTAMP(n float64) bool {
	return rcv._tab.MutateFloat64Slot(120, n)
}

/// USER_DEFINED_MICROSECONDS [O, units per ICD]
func (rcv *OMM) USER_DEFINED_MICROSECONDS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(122))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// USER_DEFINED_MICROSECONDS [O, units per ICD]
func (rcv *OMM) MutateUSER_DEFINED_MICROSECONDS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(122, n)
}

func OMMStart(builder *flatbuffers.Builder) {
	builder.StartObject(60)
}
func OMMAddCCSDS_OMM_VERS(builder *flatbuffers.Builder, CCSDS_OMM_VERS float64) {
	builder.PrependFloat64Slot(0, CCSDS_OMM_VERS, 0.0)
}
func OMMAddCREATION_DATE(builder *flatbuffers.Builder, CREATION_DATE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(CREATION_DATE), 0)
}
func OMMAddORIGINATOR(builder *flatbuffers.Builder, ORIGINATOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(ORIGINATOR), 0)
}
func OMMAddOBJECT_NAME(builder *flatbuffers.Builder, OBJECT_NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(OBJECT_NAME), 0)
}
func OMMAddOBJECT_ID(builder *flatbuffers.Builder, OBJECT_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(OBJECT_ID), 0)
}
func OMMAddCENTER_NAME(builder *flatbuffers.Builder, CENTER_NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(CENTER_NAME), 0)
}
func OMMAddREFERENCE_FRAME(builder *flatbuffers.Builder, REFERENCE_FRAME refFrame) {
	builder.PrependInt8Slot(6, int8(REFERENCE_FRAME), 2)
}
func OMMAddREFERENCE_FRAME_EPOCH(builder *flatbuffers.Builder, REFERENCE_FRAME_EPOCH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(REFERENCE_FRAME_EPOCH), 0)
}
func OMMAddTIME_SYSTEM(builder *flatbuffers.Builder, TIME_SYSTEM timeSystem) {
	builder.PrependInt8Slot(8, int8(TIME_SYSTEM), 11)
}
func OMMAddMEAN_ELEMENT_THEORY(builder *flatbuffers.Builder, MEAN_ELEMENT_THEORY meanElementTheory) {
	builder.PrependInt8Slot(9, int8(MEAN_ELEMENT_THEORY), 0)
}
func OMMAddCOMMENT(builder *flatbuffers.Builder, COMMENT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(COMMENT), 0)
}
func OMMAddEPOCH(builder *flatbuffers.Builder, EPOCH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(EPOCH), 0)
}
func OMMAddSEMI_MAJOR_AXIS(builder *flatbuffers.Builder, SEMI_MAJOR_AXIS float64) {
	builder.PrependFloat64Slot(12, SEMI_MAJOR_AXIS, 0.0)
}
func OMMAddMEAN_MOTION(builder *flatbuffers.Builder, MEAN_MOTION float64) {
	builder.PrependFloat64Slot(13, MEAN_MOTION, 0.0)
}
func OMMAddECCENTRICITY(builder *flatbuffers.Builder, ECCENTRICITY float64) {
	builder.PrependFloat64Slot(14, ECCENTRICITY, 0.0)
}
func OMMAddINCLINATION(builder *flatbuffers.Builder, INCLINATION float64) {
	builder.PrependFloat64Slot(15, INCLINATION, 0.0)
}
func OMMAddRA_OF_ASC_NODE(builder *flatbuffers.Builder, RA_OF_ASC_NODE float64) {
	builder.PrependFloat64Slot(16, RA_OF_ASC_NODE, 0.0)
}
func OMMAddARG_OF_PERICENTER(builder *flatbuffers.Builder, ARG_OF_PERICENTER float64) {
	builder.PrependFloat64Slot(17, ARG_OF_PERICENTER, 0.0)
}
func OMMAddMEAN_ANOMALY(builder *flatbuffers.Builder, MEAN_ANOMALY float64) {
	builder.PrependFloat64Slot(18, MEAN_ANOMALY, 0.0)
}
func OMMAddGM(builder *flatbuffers.Builder, GM float64) {
	builder.PrependFloat64Slot(19, GM, 0.0)
}
func OMMAddMASS(builder *flatbuffers.Builder, MASS float64) {
	builder.PrependFloat64Slot(20, MASS, 0.0)
}
func OMMAddSOLAR_RAD_AREA(builder *flatbuffers.Builder, SOLAR_RAD_AREA float64) {
	builder.PrependFloat64Slot(21, SOLAR_RAD_AREA, 0.0)
}
func OMMAddSOLAR_RAD_COEFF(builder *flatbuffers.Builder, SOLAR_RAD_COEFF float64) {
	builder.PrependFloat64Slot(22, SOLAR_RAD_COEFF, 0.0)
}
func OMMAddDRAG_AREA(builder *flatbuffers.Builder, DRAG_AREA float64) {
	builder.PrependFloat64Slot(23, DRAG_AREA, 0.0)
}
func OMMAddDRAG_COEFF(builder *flatbuffers.Builder, DRAG_COEFF float64) {
	builder.PrependFloat64Slot(24, DRAG_COEFF, 0.0)
}
func OMMAddEPHEMERIS_TYPE(builder *flatbuffers.Builder, EPHEMERIS_TYPE ephemerisType) {
	builder.PrependInt8Slot(25, int8(EPHEMERIS_TYPE), 1)
}
func OMMAddCLASSIFICATION_TYPE(builder *flatbuffers.Builder, CLASSIFICATION_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(26, flatbuffers.UOffsetT(CLASSIFICATION_TYPE), 0)
}
func OMMAddNORAD_CAT_ID(builder *flatbuffers.Builder, NORAD_CAT_ID uint32) {
	builder.PrependUint32Slot(27, NORAD_CAT_ID, 0)
}
func OMMAddELEMENT_SET_NO(builder *flatbuffers.Builder, ELEMENT_SET_NO uint32) {
	builder.PrependUint32Slot(28, ELEMENT_SET_NO, 0)
}
func OMMAddREV_AT_EPOCH(builder *flatbuffers.Builder, REV_AT_EPOCH float64) {
	builder.PrependFloat64Slot(29, REV_AT_EPOCH, 0.0)
}
func OMMAddBSTAR(builder *flatbuffers.Builder, BSTAR float64) {
	builder.PrependFloat64Slot(30, BSTAR, 0.0)
}
func OMMAddMEAN_MOTION_DOT(builder *flatbuffers.Builder, MEAN_MOTION_DOT float64) {
	builder.PrependFloat64Slot(31, MEAN_MOTION_DOT, 0.0)
}
func OMMAddMEAN_MOTION_DDOT(builder *flatbuffers.Builder, MEAN_MOTION_DDOT float64) {
	builder.PrependFloat64Slot(32, MEAN_MOTION_DDOT, 0.0)
}
func OMMAddCOV_REFERENCE_FRAME(builder *flatbuffers.Builder, COV_REFERENCE_FRAME refFrame) {
	builder.PrependInt8Slot(33, int8(COV_REFERENCE_FRAME), 23)
}
func OMMAddCX_X(builder *flatbuffers.Builder, CX_X float64) {
	builder.PrependFloat64Slot(34, CX_X, 0.0)
}
func OMMAddCY_X(builder *flatbuffers.Builder, CY_X float64) {
	builder.PrependFloat64Slot(35, CY_X, 0.0)
}
func OMMAddCY_Y(builder *flatbuffers.Builder, CY_Y float64) {
	builder.PrependFloat64Slot(36, CY_Y, 0.0)
}
func OMMAddCZ_X(builder *flatbuffers.Builder, CZ_X float64) {
	builder.PrependFloat64Slot(37, CZ_X, 0.0)
}
func OMMAddCZ_Y(builder *flatbuffers.Builder, CZ_Y float64) {
	builder.PrependFloat64Slot(38, CZ_Y, 0.0)
}
func OMMAddCZ_Z(builder *flatbuffers.Builder, CZ_Z float64) {
	builder.PrependFloat64Slot(39, CZ_Z, 0.0)
}
func OMMAddCX_DOT_X(builder *flatbuffers.Builder, CX_DOT_X float64) {
	builder.PrependFloat64Slot(40, CX_DOT_X, 0.0)
}
func OMMAddCX_DOT_Y(builder *flatbuffers.Builder, CX_DOT_Y float64) {
	builder.PrependFloat64Slot(41, CX_DOT_Y, 0.0)
}
func OMMAddCX_DOT_Z(builder *flatbuffers.Builder, CX_DOT_Z float64) {
	builder.PrependFloat64Slot(42, CX_DOT_Z, 0.0)
}
func OMMAddCX_DOT_X_DOT(builder *flatbuffers.Builder, CX_DOT_X_DOT float64) {
	builder.PrependFloat64Slot(43, CX_DOT_X_DOT, 0.0)
}
func OMMAddCY_DOT_X(builder *flatbuffers.Builder, CY_DOT_X float64) {
	builder.PrependFloat64Slot(44, CY_DOT_X, 0.0)
}
func OMMAddCY_DOT_Y(builder *flatbuffers.Builder, CY_DOT_Y float64) {
	builder.PrependFloat64Slot(45, CY_DOT_Y, 0.0)
}
func OMMAddCY_DOT_Z(builder *flatbuffers.Builder, CY_DOT_Z float64) {
	builder.PrependFloat64Slot(46, CY_DOT_Z, 0.0)
}
func OMMAddCY_DOT_X_DOT(builder *flatbuffers.Builder, CY_DOT_X_DOT float64) {
	builder.PrependFloat64Slot(47, CY_DOT_X_DOT, 0.0)
}
func OMMAddCY_DOT_Y_DOT(builder *flatbuffers.Builder, CY_DOT_Y_DOT float64) {
	builder.PrependFloat64Slot(48, CY_DOT_Y_DOT, 0.0)
}
func OMMAddCZ_DOT_X(builder *flatbuffers.Builder, CZ_DOT_X float64) {
	builder.PrependFloat64Slot(49, CZ_DOT_X, 0.0)
}
func OMMAddCZ_DOT_Y(builder *flatbuffers.Builder, CZ_DOT_Y float64) {
	builder.PrependFloat64Slot(50, CZ_DOT_Y, 0.0)
}
func OMMAddCZ_DOT_Z(builder *flatbuffers.Builder, CZ_DOT_Z float64) {
	builder.PrependFloat64Slot(51, CZ_DOT_Z, 0.0)
}
func OMMAddCZ_DOT_X_DOT(builder *flatbuffers.Builder, CZ_DOT_X_DOT float64) {
	builder.PrependFloat64Slot(52, CZ_DOT_X_DOT, 0.0)
}
func OMMAddCZ_DOT_Y_DOT(builder *flatbuffers.Builder, CZ_DOT_Y_DOT float64) {
	builder.PrependFloat64Slot(53, CZ_DOT_Y_DOT, 0.0)
}
func OMMAddCZ_DOT_Z_DOT(builder *flatbuffers.Builder, CZ_DOT_Z_DOT float64) {
	builder.PrependFloat64Slot(54, CZ_DOT_Z_DOT, 0.0)
}
func OMMAddUSER_DEFINED_BIP_0044_TYPE(builder *flatbuffers.Builder, USER_DEFINED_BIP_0044_TYPE uint32) {
	builder.PrependUint32Slot(55, USER_DEFINED_BIP_0044_TYPE, 0)
}
func OMMAddUSER_DEFINED_OBJECT_DESIGNATOR(builder *flatbuffers.Builder, USER_DEFINED_OBJECT_DESIGNATOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(56, flatbuffers.UOffsetT(USER_DEFINED_OBJECT_DESIGNATOR), 0)
}
func OMMAddUSER_DEFINED_EARTH_MODEL(builder *flatbuffers.Builder, USER_DEFINED_EARTH_MODEL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(57, flatbuffers.UOffsetT(USER_DEFINED_EARTH_MODEL), 0)
}
func OMMAddUSER_DEFINED_EPOCH_TIMESTAMP(builder *flatbuffers.Builder, USER_DEFINED_EPOCH_TIMESTAMP float64) {
	builder.PrependFloat64Slot(58, USER_DEFINED_EPOCH_TIMESTAMP, 0.0)
}
func OMMAddUSER_DEFINED_MICROSECONDS(builder *flatbuffers.Builder, USER_DEFINED_MICROSECONDS float64) {
	builder.PrependFloat64Slot(59, USER_DEFINED_MICROSECONDS, 0.0)
}
func OMMEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
