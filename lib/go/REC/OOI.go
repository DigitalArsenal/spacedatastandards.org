// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Object of Interest
type OOI struct {
	_tab flatbuffers.Table
}

const OOIIdentifier = "$OOI"

func GetRootAsOOI(buf []byte, offset flatbuffers.UOffsetT) *OOI {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &OOI{}
	x.Init(buf, n+offset)
	return x
}

func FinishOOIBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(OOIIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func OOIBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, OOIIdentifier)
}

func GetSizePrefixedRootAsOOI(buf []byte, offset flatbuffers.UOffsetT) *OOI {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &OOI{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedOOIBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(OOIIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedOOIBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, OOIIdentifier)
}

func (rcv *OOI) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *OOI) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *OOI) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) SAT_NO() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *OOI) MutateSAT_NO(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *OOI) NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) SENSOR_TASKING_START_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) SENSOR_TASKING_STOP_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) PRIORITY() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *OOI) MutatePRIORITY(n int32) bool {
	return rcv._tab.MutateInt32Slot(14, n)
}

func (rcv *OOI) STATUS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) STATUS_DATE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) DESCRIPTION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) LAST_OB_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) MISSED_OB_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) DELTA_VS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *OOI) DELTA_VSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *OOI) DELTA_TS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *OOI) DELTA_TSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *OOI) SV_EPOCH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateX(n float64) bool {
	return rcv._tab.MutateFloat64Slot(32, n)
}

func (rcv *OOI) Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(34, n)
}

func (rcv *OOI) Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateZ(n float64) bool {
	return rcv._tab.MutateFloat64Slot(36, n)
}

func (rcv *OOI) XVEL() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateXVEL(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

func (rcv *OOI) YVEL() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateYVEL(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

func (rcv *OOI) ZVEL() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateZVEL(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

func (rcv *OOI) ELSET_EPOCH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) MEAN_MOTION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateMEAN_MOTION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(46, n)
}

func (rcv *OOI) ECCENTRICITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateECCENTRICITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

func (rcv *OOI) INCLINATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateINCLINATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

func (rcv *OOI) RAAN() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateRAAN(n float64) bool {
	return rcv._tab.MutateFloat64Slot(52, n)
}

func (rcv *OOI) ARG_OF_PERIGEE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateARG_OF_PERIGEE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(54, n)
}

func (rcv *OOI) MEAN_ANOMALY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateMEAN_ANOMALY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(56, n)
}

func (rcv *OOI) REV_NO() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *OOI) MutateREV_NO(n int32) bool {
	return rcv._tab.MutateInt32Slot(58, n)
}

func (rcv *OOI) B_STAR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateB_STAR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(60, n)
}

func (rcv *OOI) MEAN_MOTION_DOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateMEAN_MOTION_DOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(62, n)
}

func (rcv *OOI) MEAN_MOTION_DDOT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateMEAN_MOTION_DDOT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(64, n)
}

func (rcv *OOI) SEMI_MAJOR_AXIS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateSEMI_MAJOR_AXIS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(66, n)
}

func (rcv *OOI) PERIOD() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutatePERIOD(n float64) bool {
	return rcv._tab.MutateFloat64Slot(68, n)
}

func (rcv *OOI) APOGEE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutateAPOGEE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(70, n)
}

func (rcv *OOI) PERIGEE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *OOI) MutatePERIGEE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(72, n)
}

func (rcv *OOI) AFFECTED_OBJECTS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *OOI) AFFECTED_OBJECTSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *OOI) ON_ORBIT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *OOI) MANIFOLDS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *OOI) MANIFOLDSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func OOIStart(builder *flatbuffers.Builder) {
	builder.StartObject(38)
}
func OOIAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func OOIAddSAT_NO(builder *flatbuffers.Builder, SAT_NO int32) {
	builder.PrependInt32Slot(1, SAT_NO, 0)
}
func OOIAddNAME(builder *flatbuffers.Builder, NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(NAME), 0)
}
func OOIAddSENSOR_TASKING_START_TIME(builder *flatbuffers.Builder, SENSOR_TASKING_START_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(SENSOR_TASKING_START_TIME), 0)
}
func OOIAddSENSOR_TASKING_STOP_TIME(builder *flatbuffers.Builder, SENSOR_TASKING_STOP_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(SENSOR_TASKING_STOP_TIME), 0)
}
func OOIAddPRIORITY(builder *flatbuffers.Builder, PRIORITY int32) {
	builder.PrependInt32Slot(5, PRIORITY, 0)
}
func OOIAddSTATUS(builder *flatbuffers.Builder, STATUS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(STATUS), 0)
}
func OOIAddSTATUS_DATE(builder *flatbuffers.Builder, STATUS_DATE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(STATUS_DATE), 0)
}
func OOIAddDESCRIPTION(builder *flatbuffers.Builder, DESCRIPTION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(DESCRIPTION), 0)
}
func OOIAddLAST_OB_TIME(builder *flatbuffers.Builder, LAST_OB_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(LAST_OB_TIME), 0)
}
func OOIAddMISSED_OB_TIME(builder *flatbuffers.Builder, MISSED_OB_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(MISSED_OB_TIME), 0)
}
func OOIAddDELTA_VS(builder *flatbuffers.Builder, DELTA_VS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(DELTA_VS), 0)
}
func OOIStartDELTA_VSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func OOIAddDELTA_TS(builder *flatbuffers.Builder, DELTA_TS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(DELTA_TS), 0)
}
func OOIStartDELTA_TSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func OOIAddSV_EPOCH(builder *flatbuffers.Builder, SV_EPOCH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(SV_EPOCH), 0)
}
func OOIAddX(builder *flatbuffers.Builder, X float64) {
	builder.PrependFloat64Slot(14, X, 0.0)
}
func OOIAddY(builder *flatbuffers.Builder, Y float64) {
	builder.PrependFloat64Slot(15, Y, 0.0)
}
func OOIAddZ(builder *flatbuffers.Builder, Z float64) {
	builder.PrependFloat64Slot(16, Z, 0.0)
}
func OOIAddXVEL(builder *flatbuffers.Builder, XVEL float64) {
	builder.PrependFloat64Slot(17, XVEL, 0.0)
}
func OOIAddYVEL(builder *flatbuffers.Builder, YVEL float64) {
	builder.PrependFloat64Slot(18, YVEL, 0.0)
}
func OOIAddZVEL(builder *flatbuffers.Builder, ZVEL float64) {
	builder.PrependFloat64Slot(19, ZVEL, 0.0)
}
func OOIAddELSET_EPOCH(builder *flatbuffers.Builder, ELSET_EPOCH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(20, flatbuffers.UOffsetT(ELSET_EPOCH), 0)
}
func OOIAddMEAN_MOTION(builder *flatbuffers.Builder, MEAN_MOTION float64) {
	builder.PrependFloat64Slot(21, MEAN_MOTION, 0.0)
}
func OOIAddECCENTRICITY(builder *flatbuffers.Builder, ECCENTRICITY float64) {
	builder.PrependFloat64Slot(22, ECCENTRICITY, 0.0)
}
func OOIAddINCLINATION(builder *flatbuffers.Builder, INCLINATION float64) {
	builder.PrependFloat64Slot(23, INCLINATION, 0.0)
}
func OOIAddRAAN(builder *flatbuffers.Builder, RAAN float64) {
	builder.PrependFloat64Slot(24, RAAN, 0.0)
}
func OOIAddARG_OF_PERIGEE(builder *flatbuffers.Builder, ARG_OF_PERIGEE float64) {
	builder.PrependFloat64Slot(25, ARG_OF_PERIGEE, 0.0)
}
func OOIAddMEAN_ANOMALY(builder *flatbuffers.Builder, MEAN_ANOMALY float64) {
	builder.PrependFloat64Slot(26, MEAN_ANOMALY, 0.0)
}
func OOIAddREV_NO(builder *flatbuffers.Builder, REV_NO int32) {
	builder.PrependInt32Slot(27, REV_NO, 0)
}
func OOIAddB_STAR(builder *flatbuffers.Builder, B_STAR float64) {
	builder.PrependFloat64Slot(28, B_STAR, 0.0)
}
func OOIAddMEAN_MOTION_DOT(builder *flatbuffers.Builder, MEAN_MOTION_DOT float64) {
	builder.PrependFloat64Slot(29, MEAN_MOTION_DOT, 0.0)
}
func OOIAddMEAN_MOTION_DDOT(builder *flatbuffers.Builder, MEAN_MOTION_DDOT float64) {
	builder.PrependFloat64Slot(30, MEAN_MOTION_DDOT, 0.0)
}
func OOIAddSEMI_MAJOR_AXIS(builder *flatbuffers.Builder, SEMI_MAJOR_AXIS float64) {
	builder.PrependFloat64Slot(31, SEMI_MAJOR_AXIS, 0.0)
}
func OOIAddPERIOD(builder *flatbuffers.Builder, PERIOD float64) {
	builder.PrependFloat64Slot(32, PERIOD, 0.0)
}
func OOIAddAPOGEE(builder *flatbuffers.Builder, APOGEE float64) {
	builder.PrependFloat64Slot(33, APOGEE, 0.0)
}
func OOIAddPERIGEE(builder *flatbuffers.Builder, PERIGEE float64) {
	builder.PrependFloat64Slot(34, PERIGEE, 0.0)
}
func OOIAddAFFECTED_OBJECTS(builder *flatbuffers.Builder, AFFECTED_OBJECTS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(35, flatbuffers.UOffsetT(AFFECTED_OBJECTS), 0)
}
func OOIStartAFFECTED_OBJECTSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func OOIAddON_ORBIT(builder *flatbuffers.Builder, ON_ORBIT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(36, flatbuffers.UOffsetT(ON_ORBIT), 0)
}
func OOIAddMANIFOLDS(builder *flatbuffers.Builder, MANIFOLDS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(37, flatbuffers.UOffsetT(MANIFOLDS), 0)
}
func OOIStartMANIFOLDSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func OOIEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
