// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// RF Observation
type RFO struct {
	_tab flatbuffers.Table
}

const RFOIdentifier = "$RFO"

func GetRootAsRFO(buf []byte, offset flatbuffers.UOffsetT) *RFO {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &RFO{}
	x.Init(buf, n+offset)
	return x
}

func FinishRFOBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(RFOIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func RFOBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, RFOIdentifier)
}

func GetSizePrefixedRootAsRFO(buf []byte, offset flatbuffers.UOffsetT) *RFO {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &RFO{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedRFOBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(RFOIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedRFOBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, RFOIdentifier)
}

func (rcv *RFO) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *RFO) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier
func (rcv *RFO) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier
/// Observation time (ISO 8601)
func (rcv *RFO) OB_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Observation time (ISO 8601)
/// Sensor identifier
func (rcv *RFO) ID_SENSOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Sensor identifier
/// Original sensor identifier
func (rcv *RFO) ORIG_SENSOR_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Original sensor identifier
/// Observation type
func (rcv *RFO) OBS_TYPE() rfObsType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rfObsType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Observation type
func (rcv *RFO) MutateOBS_TYPE(n rfObsType) bool {
	return rcv._tab.MutateInt8Slot(12, int8(n))
}

/// Satellite catalog number
func (rcv *RFO) SAT_NO() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Satellite catalog number
func (rcv *RFO) MutateSAT_NO(n uint32) bool {
	return rcv._tab.MutateUint32Slot(14, n)
}

/// International designator
func (rcv *RFO) ORIG_OBJECT_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// International designator
/// On-orbit reference
func (rcv *RFO) ON_ORBIT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// On-orbit reference
/// True if uncorrelated target
func (rcv *RFO) UCT() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if uncorrelated target
func (rcv *RFO) MutateUCT(n bool) bool {
	return rcv._tab.MutateBoolSlot(20, n)
}

/// Task identifier
func (rcv *RFO) TASK_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Task identifier
/// Transaction identifier
func (rcv *RFO) TRANSACTION_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Transaction identifier
/// Track identifier
func (rcv *RFO) TRACK_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Track identifier
/// Transponder identifier
func (rcv *RFO) TRANSPONDER() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Transponder identifier
/// Detection status
func (rcv *RFO) DETECTION_STATUS() rfDetectionStatus {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rfDetectionStatus(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Detection status
func (rcv *RFO) MutateDETECTION_STATUS(n rfDetectionStatus) bool {
	return rcv._tab.MutateInt8Slot(30, int8(n))
}

/// Azimuth angle (degrees)
func (rcv *RFO) AZIMUTH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Azimuth angle (degrees)
func (rcv *RFO) MutateAZIMUTH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(32, n)
}

/// Azimuth uncertainty (degrees, 1-sigma)
func (rcv *RFO) AZIMUTH_UNC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Azimuth uncertainty (degrees, 1-sigma)
func (rcv *RFO) MutateAZIMUTH_UNC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(34, n)
}

/// Azimuth rate (degrees/s)
func (rcv *RFO) AZIMUTH_RATE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Azimuth rate (degrees/s)
func (rcv *RFO) MutateAZIMUTH_RATE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(36, n)
}

/// Elevation angle (degrees)
func (rcv *RFO) ELEVATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Elevation angle (degrees)
func (rcv *RFO) MutateELEVATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

/// Elevation uncertainty (degrees, 1-sigma)
func (rcv *RFO) ELEVATION_UNC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Elevation uncertainty (degrees, 1-sigma)
func (rcv *RFO) MutateELEVATION_UNC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// Elevation rate (degrees/s)
func (rcv *RFO) ELEVATION_RATE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Elevation rate (degrees/s)
func (rcv *RFO) MutateELEVATION_RATE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// Slant range (km)
func (rcv *RFO) RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Slant range (km)
func (rcv *RFO) MutateRANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(44, n)
}

/// Range uncertainty (km, 1-sigma)
func (rcv *RFO) RANGE_UNC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Range uncertainty (km, 1-sigma)
func (rcv *RFO) MutateRANGE_UNC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(46, n)
}

/// Range rate (km/s)
func (rcv *RFO) RANGE_RATE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Range rate (km/s)
func (rcv *RFO) MutateRANGE_RATE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

/// Range rate uncertainty (km/s, 1-sigma)
func (rcv *RFO) RANGE_RATE_UNC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Range rate uncertainty (km/s, 1-sigma)
func (rcv *RFO) MutateRANGE_RATE_UNC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

/// Track range (km)
func (rcv *RFO) TRACK_RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Track range (km)
func (rcv *RFO) MutateTRACK_RANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(52, n)
}

/// Sensor latitude (degrees)
func (rcv *RFO) SENLAT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor latitude (degrees)
func (rcv *RFO) MutateSENLAT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(54, n)
}

/// Sensor longitude (degrees)
func (rcv *RFO) SENLON() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor longitude (degrees)
func (rcv *RFO) MutateSENLON(n float64) bool {
	return rcv._tab.MutateFloat64Slot(56, n)
}

/// Sensor altitude (km)
func (rcv *RFO) SENALT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor altitude (km)
func (rcv *RFO) MutateSENALT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(58, n)
}

/// ELNOT (Electronic Intelligence Notation)
func (rcv *RFO) ELNOT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// ELNOT (Electronic Intelligence Notation)
/// Antenna name
func (rcv *RFO) ANTENNA_NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Antenna name
/// Collection mode
func (rcv *RFO) COLLECTION_MODE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Collection mode
/// Measured center frequency (MHz)
func (rcv *RFO) FREQUENCY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Measured center frequency (MHz)
func (rcv *RFO) MutateFREQUENCY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(66, n)
}

/// Nominal center frequency (MHz)
func (rcv *RFO) NOMINAL_FREQUENCY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Nominal center frequency (MHz)
func (rcv *RFO) MutateNOMINAL_FREQUENCY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(68, n)
}

/// Start frequency of emission (MHz)
func (rcv *RFO) START_FREQUENCY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Start frequency of emission (MHz)
func (rcv *RFO) MutateSTART_FREQUENCY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(70, n)
}

/// End frequency of emission (MHz)
func (rcv *RFO) END_FREQUENCY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// End frequency of emission (MHz)
func (rcv *RFO) MutateEND_FREQUENCY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(72, n)
}

/// Frequency shift from nominal (MHz)
func (rcv *RFO) FREQUENCY_SHIFT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Frequency shift from nominal (MHz)
func (rcv *RFO) MutateFREQUENCY_SHIFT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(74, n)
}

/// Measured bandwidth (MHz)
func (rcv *RFO) BANDWIDTH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Measured bandwidth (MHz)
func (rcv *RFO) MutateBANDWIDTH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(76, n)
}

/// Nominal bandwidth (MHz)
func (rcv *RFO) NOMINAL_BANDWIDTH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Nominal bandwidth (MHz)
func (rcv *RFO) MutateNOMINAL_BANDWIDTH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(78, n)
}

/// Resolution bandwidth (MHz)
func (rcv *RFO) RESOLUTION_BANDWIDTH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Resolution bandwidth (MHz)
func (rcv *RFO) MutateRESOLUTION_BANDWIDTH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(80, n)
}

/// Video bandwidth (MHz)
func (rcv *RFO) VIDEO_BANDWIDTH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Video bandwidth (MHz)
func (rcv *RFO) MutateVIDEO_BANDWIDTH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(82, n)
}

/// Relative carrier power (dBm)
func (rcv *RFO) RELATIVE_CARRIER_POWER() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Relative carrier power (dBm)
func (rcv *RFO) MutateRELATIVE_CARRIER_POWER(n float64) bool {
	return rcv._tab.MutateFloat64Slot(84, n)
}

/// Spectrum analyzer power (dBm)
func (rcv *RFO) SPECTRUM_ANALYZER_POWER() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Spectrum analyzer power (dBm)
func (rcv *RFO) MutateSPECTRUM_ANALYZER_POWER(n float64) bool {
	return rcv._tab.MutateFloat64Slot(86, n)
}

/// Relative noise floor (dBm)
func (rcv *RFO) RELATIVE_NOISE_FLOOR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Relative noise floor (dBm)
func (rcv *RFO) MutateRELATIVE_NOISE_FLOOR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(88, n)
}

/// Reference level (dBm)
func (rcv *RFO) REFERENCE_LEVEL() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(90))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Reference level (dBm)
func (rcv *RFO) MutateREFERENCE_LEVEL(n float64) bool {
	return rcv._tab.MutateFloat64Slot(90, n)
}

/// Noise power density (dBm/Hz)
func (rcv *RFO) NOISE_PWR_DENSITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(92))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Noise power density (dBm/Hz)
func (rcv *RFO) MutateNOISE_PWR_DENSITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(92, n)
}

/// PGRI (Pulse Group Repetition Interval, microseconds)
func (rcv *RFO) PGRI() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(94))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// PGRI (Pulse Group Repetition Interval, microseconds)
func (rcv *RFO) MutatePGRI(n float64) bool {
	return rcv._tab.MutateFloat64Slot(94, n)
}

/// Effective isotropic radiated power (dBW)
func (rcv *RFO) EIRP() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(96))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Effective isotropic radiated power (dBW)
func (rcv *RFO) MutateEIRP(n float64) bool {
	return rcv._tab.MutateFloat64Slot(96, n)
}

/// Nominal EIRP (dBW)
func (rcv *RFO) NOMINAL_EIRP() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Nominal EIRP (dBW)
func (rcv *RFO) MutateNOMINAL_EIRP(n float64) bool {
	return rcv._tab.MutateFloat64Slot(98, n)
}

/// Minimum power spectral density (dBm/Hz)
func (rcv *RFO) MIN_PSD() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(100))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Minimum power spectral density (dBm/Hz)
func (rcv *RFO) MutateMIN_PSD(n float64) bool {
	return rcv._tab.MutateFloat64Slot(100, n)
}

/// Maximum power spectral density (dBm/Hz)
func (rcv *RFO) MAX_PSD() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Maximum power spectral density (dBm/Hz)
func (rcv *RFO) MutateMAX_PSD(n float64) bool {
	return rcv._tab.MutateFloat64Slot(102, n)
}

/// Signal-to-noise ratio (dB)
func (rcv *RFO) SNR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Signal-to-noise ratio (dB)
func (rcv *RFO) MutateSNR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(104, n)
}

/// Nominal SNR (dB)
func (rcv *RFO) NOMINAL_SNR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Nominal SNR (dB)
func (rcv *RFO) MutateNOMINAL_SNR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(106, n)
}

/// Power over noise (dB)
func (rcv *RFO) POWER_OVER_NOISE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Power over noise (dB)
func (rcv *RFO) MutatePOWER_OVER_NOISE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(108, n)
}

/// Nominal power over noise (dB)
func (rcv *RFO) NOMINAL_POWER_OVER_NOISE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Nominal power over noise (dB)
func (rcv *RFO) MutateNOMINAL_POWER_OVER_NOISE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(110, n)
}

/// Polarity angle (degrees)
func (rcv *RFO) POLARITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Polarity angle (degrees)
func (rcv *RFO) MutatePOLARITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(112, n)
}

/// Polarization type (e.g., LHCP, RHCP, LINEAR)
func (rcv *RFO) POLARITY_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Polarization type (e.g., LHCP, RHCP, LINEAR)
/// Channel number
func (rcv *RFO) CHANNEL() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

/// Channel number
func (rcv *RFO) MutateCHANNEL(n uint16) bool {
	return rcv._tab.MutateUint16Slot(116, n)
}

/// Baud rate (symbols/s)
func (rcv *RFO) BAUD_RATE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Baud rate (symbols/s)
func (rcv *RFO) MutateBAUD_RATE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(118, n)
}

/// Symbol-to-noise ratio (dB)
func (rcv *RFO) SYMBOL_TO_NOISE_RATIO() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(120))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Symbol-to-noise ratio (dB)
func (rcv *RFO) MutateSYMBOL_TO_NOISE_RATIO(n float64) bool {
	return rcv._tab.MutateFloat64Slot(120, n)
}

/// Bit error rate
func (rcv *RFO) BIT_ERROR_RATE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(122))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Bit error rate
func (rcv *RFO) MutateBIT_ERROR_RATE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(122, n)
}

/// True if peak measurement
func (rcv *RFO) PEAK() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(124))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if peak measurement
func (rcv *RFO) MutatePEAK(n bool) bool {
	return rcv._tab.MutateBoolSlot(124, n)
}

/// True if incoming signal
func (rcv *RFO) INCOMING() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(126))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if incoming signal
func (rcv *RFO) MutateINCOMING(n bool) bool {
	return rcv._tab.MutateBoolSlot(126, n)
}

/// Switch point number
func (rcv *RFO) SWITCH_POINT() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(128))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

/// Switch point number
func (rcv *RFO) MutateSWITCH_POINT(n uint16) bool {
	return rcv._tab.MutateUint16Slot(128, n)
}

/// Confidence score (0-1)
func (rcv *RFO) CONFIDENCE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(130))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Confidence score (0-1)
func (rcv *RFO) MutateCONFIDENCE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(130, n)
}

/// Carrier standard (e.g., DVB-S, DVB-S2)
func (rcv *RFO) CARRIER_STANDARD() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(132))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Carrier standard (e.g., DVB-S, DVB-S2)
/// Modulation type
func (rcv *RFO) MODULATION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(134))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Modulation type
/// Inner FEC coding rate denominator
func (rcv *RFO) INNER_CODING_RATE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(136))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Inner FEC coding rate denominator
func (rcv *RFO) MutateINNER_CODING_RATE(n byte) bool {
	return rcv._tab.MutateByteSlot(136, n)
}

/// Outer FEC coding rate denominator
func (rcv *RFO) OUTER_CODING_RATE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(138))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Outer FEC coding rate denominator
func (rcv *RFO) MutateOUTER_CODING_RATE(n byte) bool {
	return rcv._tab.MutateByteSlot(138, n)
}

/// Transmit filter type
func (rcv *RFO) TRANSMIT_FILTER_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(140))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Transmit filter type
/// Transmit filter roll-off factor
func (rcv *RFO) TRANSMIT_FILTER_ROLL_OFF() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(142))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Transmit filter roll-off factor
func (rcv *RFO) MutateTRANSMIT_FILTER_ROLL_OFF(n float64) bool {
	return rcv._tab.MutateFloat64Slot(142, n)
}

/// Reference to raw data file
func (rcv *RFO) RAW_FILE_URI() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(144))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Reference to raw data file
/// Event descriptor
func (rcv *RFO) DESCRIPTOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(146))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Event descriptor
/// Reference URL
func (rcv *RFO) URL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(148))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Reference URL
/// Associated tags
func (rcv *RFO) TAGS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(150))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *RFO) TAGSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(150))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Associated tags
func RFOStart(builder *flatbuffers.Builder) {
	builder.StartObject(74)
}
func RFOAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func RFOAddOB_TIME(builder *flatbuffers.Builder, OB_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(OB_TIME), 0)
}
func RFOAddID_SENSOR(builder *flatbuffers.Builder, ID_SENSOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(ID_SENSOR), 0)
}
func RFOAddORIG_SENSOR_ID(builder *flatbuffers.Builder, ORIG_SENSOR_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(ORIG_SENSOR_ID), 0)
}
func RFOAddOBS_TYPE(builder *flatbuffers.Builder, OBS_TYPE rfObsType) {
	builder.PrependInt8Slot(4, int8(OBS_TYPE), 0)
}
func RFOAddSAT_NO(builder *flatbuffers.Builder, SAT_NO uint32) {
	builder.PrependUint32Slot(5, SAT_NO, 0)
}
func RFOAddORIG_OBJECT_ID(builder *flatbuffers.Builder, ORIG_OBJECT_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(ORIG_OBJECT_ID), 0)
}
func RFOAddON_ORBIT(builder *flatbuffers.Builder, ON_ORBIT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(ON_ORBIT), 0)
}
func RFOAddUCT(builder *flatbuffers.Builder, UCT bool) {
	builder.PrependBoolSlot(8, UCT, false)
}
func RFOAddTASK_ID(builder *flatbuffers.Builder, TASK_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(TASK_ID), 0)
}
func RFOAddTRANSACTION_ID(builder *flatbuffers.Builder, TRANSACTION_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(TRANSACTION_ID), 0)
}
func RFOAddTRACK_ID(builder *flatbuffers.Builder, TRACK_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(TRACK_ID), 0)
}
func RFOAddTRANSPONDER(builder *flatbuffers.Builder, TRANSPONDER flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(TRANSPONDER), 0)
}
func RFOAddDETECTION_STATUS(builder *flatbuffers.Builder, DETECTION_STATUS rfDetectionStatus) {
	builder.PrependInt8Slot(13, int8(DETECTION_STATUS), 0)
}
func RFOAddAZIMUTH(builder *flatbuffers.Builder, AZIMUTH float64) {
	builder.PrependFloat64Slot(14, AZIMUTH, 0.0)
}
func RFOAddAZIMUTH_UNC(builder *flatbuffers.Builder, AZIMUTH_UNC float64) {
	builder.PrependFloat64Slot(15, AZIMUTH_UNC, 0.0)
}
func RFOAddAZIMUTH_RATE(builder *flatbuffers.Builder, AZIMUTH_RATE float64) {
	builder.PrependFloat64Slot(16, AZIMUTH_RATE, 0.0)
}
func RFOAddELEVATION(builder *flatbuffers.Builder, ELEVATION float64) {
	builder.PrependFloat64Slot(17, ELEVATION, 0.0)
}
func RFOAddELEVATION_UNC(builder *flatbuffers.Builder, ELEVATION_UNC float64) {
	builder.PrependFloat64Slot(18, ELEVATION_UNC, 0.0)
}
func RFOAddELEVATION_RATE(builder *flatbuffers.Builder, ELEVATION_RATE float64) {
	builder.PrependFloat64Slot(19, ELEVATION_RATE, 0.0)
}
func RFOAddRANGE(builder *flatbuffers.Builder, RANGE float64) {
	builder.PrependFloat64Slot(20, RANGE, 0.0)
}
func RFOAddRANGE_UNC(builder *flatbuffers.Builder, RANGE_UNC float64) {
	builder.PrependFloat64Slot(21, RANGE_UNC, 0.0)
}
func RFOAddRANGE_RATE(builder *flatbuffers.Builder, RANGE_RATE float64) {
	builder.PrependFloat64Slot(22, RANGE_RATE, 0.0)
}
func RFOAddRANGE_RATE_UNC(builder *flatbuffers.Builder, RANGE_RATE_UNC float64) {
	builder.PrependFloat64Slot(23, RANGE_RATE_UNC, 0.0)
}
func RFOAddTRACK_RANGE(builder *flatbuffers.Builder, TRACK_RANGE float64) {
	builder.PrependFloat64Slot(24, TRACK_RANGE, 0.0)
}
func RFOAddSENLAT(builder *flatbuffers.Builder, SENLAT float64) {
	builder.PrependFloat64Slot(25, SENLAT, 0.0)
}
func RFOAddSENLON(builder *flatbuffers.Builder, SENLON float64) {
	builder.PrependFloat64Slot(26, SENLON, 0.0)
}
func RFOAddSENALT(builder *flatbuffers.Builder, SENALT float64) {
	builder.PrependFloat64Slot(27, SENALT, 0.0)
}
func RFOAddELNOT(builder *flatbuffers.Builder, ELNOT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(28, flatbuffers.UOffsetT(ELNOT), 0)
}
func RFOAddANTENNA_NAME(builder *flatbuffers.Builder, ANTENNA_NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(29, flatbuffers.UOffsetT(ANTENNA_NAME), 0)
}
func RFOAddCOLLECTION_MODE(builder *flatbuffers.Builder, COLLECTION_MODE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(30, flatbuffers.UOffsetT(COLLECTION_MODE), 0)
}
func RFOAddFREQUENCY(builder *flatbuffers.Builder, FREQUENCY float64) {
	builder.PrependFloat64Slot(31, FREQUENCY, 0.0)
}
func RFOAddNOMINAL_FREQUENCY(builder *flatbuffers.Builder, NOMINAL_FREQUENCY float64) {
	builder.PrependFloat64Slot(32, NOMINAL_FREQUENCY, 0.0)
}
func RFOAddSTART_FREQUENCY(builder *flatbuffers.Builder, START_FREQUENCY float64) {
	builder.PrependFloat64Slot(33, START_FREQUENCY, 0.0)
}
func RFOAddEND_FREQUENCY(builder *flatbuffers.Builder, END_FREQUENCY float64) {
	builder.PrependFloat64Slot(34, END_FREQUENCY, 0.0)
}
func RFOAddFREQUENCY_SHIFT(builder *flatbuffers.Builder, FREQUENCY_SHIFT float64) {
	builder.PrependFloat64Slot(35, FREQUENCY_SHIFT, 0.0)
}
func RFOAddBANDWIDTH(builder *flatbuffers.Builder, BANDWIDTH float64) {
	builder.PrependFloat64Slot(36, BANDWIDTH, 0.0)
}
func RFOAddNOMINAL_BANDWIDTH(builder *flatbuffers.Builder, NOMINAL_BANDWIDTH float64) {
	builder.PrependFloat64Slot(37, NOMINAL_BANDWIDTH, 0.0)
}
func RFOAddRESOLUTION_BANDWIDTH(builder *flatbuffers.Builder, RESOLUTION_BANDWIDTH float64) {
	builder.PrependFloat64Slot(38, RESOLUTION_BANDWIDTH, 0.0)
}
func RFOAddVIDEO_BANDWIDTH(builder *flatbuffers.Builder, VIDEO_BANDWIDTH float64) {
	builder.PrependFloat64Slot(39, VIDEO_BANDWIDTH, 0.0)
}
func RFOAddRELATIVE_CARRIER_POWER(builder *flatbuffers.Builder, RELATIVE_CARRIER_POWER float64) {
	builder.PrependFloat64Slot(40, RELATIVE_CARRIER_POWER, 0.0)
}
func RFOAddSPECTRUM_ANALYZER_POWER(builder *flatbuffers.Builder, SPECTRUM_ANALYZER_POWER float64) {
	builder.PrependFloat64Slot(41, SPECTRUM_ANALYZER_POWER, 0.0)
}
func RFOAddRELATIVE_NOISE_FLOOR(builder *flatbuffers.Builder, RELATIVE_NOISE_FLOOR float64) {
	builder.PrependFloat64Slot(42, RELATIVE_NOISE_FLOOR, 0.0)
}
func RFOAddREFERENCE_LEVEL(builder *flatbuffers.Builder, REFERENCE_LEVEL float64) {
	builder.PrependFloat64Slot(43, REFERENCE_LEVEL, 0.0)
}
func RFOAddNOISE_PWR_DENSITY(builder *flatbuffers.Builder, NOISE_PWR_DENSITY float64) {
	builder.PrependFloat64Slot(44, NOISE_PWR_DENSITY, 0.0)
}
func RFOAddPGRI(builder *flatbuffers.Builder, PGRI float64) {
	builder.PrependFloat64Slot(45, PGRI, 0.0)
}
func RFOAddEIRP(builder *flatbuffers.Builder, EIRP float64) {
	builder.PrependFloat64Slot(46, EIRP, 0.0)
}
func RFOAddNOMINAL_EIRP(builder *flatbuffers.Builder, NOMINAL_EIRP float64) {
	builder.PrependFloat64Slot(47, NOMINAL_EIRP, 0.0)
}
func RFOAddMIN_PSD(builder *flatbuffers.Builder, MIN_PSD float64) {
	builder.PrependFloat64Slot(48, MIN_PSD, 0.0)
}
func RFOAddMAX_PSD(builder *flatbuffers.Builder, MAX_PSD float64) {
	builder.PrependFloat64Slot(49, MAX_PSD, 0.0)
}
func RFOAddSNR(builder *flatbuffers.Builder, SNR float64) {
	builder.PrependFloat64Slot(50, SNR, 0.0)
}
func RFOAddNOMINAL_SNR(builder *flatbuffers.Builder, NOMINAL_SNR float64) {
	builder.PrependFloat64Slot(51, NOMINAL_SNR, 0.0)
}
func RFOAddPOWER_OVER_NOISE(builder *flatbuffers.Builder, POWER_OVER_NOISE float64) {
	builder.PrependFloat64Slot(52, POWER_OVER_NOISE, 0.0)
}
func RFOAddNOMINAL_POWER_OVER_NOISE(builder *flatbuffers.Builder, NOMINAL_POWER_OVER_NOISE float64) {
	builder.PrependFloat64Slot(53, NOMINAL_POWER_OVER_NOISE, 0.0)
}
func RFOAddPOLARITY(builder *flatbuffers.Builder, POLARITY float64) {
	builder.PrependFloat64Slot(54, POLARITY, 0.0)
}
func RFOAddPOLARITY_TYPE(builder *flatbuffers.Builder, POLARITY_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(55, flatbuffers.UOffsetT(POLARITY_TYPE), 0)
}
func RFOAddCHANNEL(builder *flatbuffers.Builder, CHANNEL uint16) {
	builder.PrependUint16Slot(56, CHANNEL, 0)
}
func RFOAddBAUD_RATE(builder *flatbuffers.Builder, BAUD_RATE float64) {
	builder.PrependFloat64Slot(57, BAUD_RATE, 0.0)
}
func RFOAddSYMBOL_TO_NOISE_RATIO(builder *flatbuffers.Builder, SYMBOL_TO_NOISE_RATIO float64) {
	builder.PrependFloat64Slot(58, SYMBOL_TO_NOISE_RATIO, 0.0)
}
func RFOAddBIT_ERROR_RATE(builder *flatbuffers.Builder, BIT_ERROR_RATE float64) {
	builder.PrependFloat64Slot(59, BIT_ERROR_RATE, 0.0)
}
func RFOAddPEAK(builder *flatbuffers.Builder, PEAK bool) {
	builder.PrependBoolSlot(60, PEAK, false)
}
func RFOAddINCOMING(builder *flatbuffers.Builder, INCOMING bool) {
	builder.PrependBoolSlot(61, INCOMING, false)
}
func RFOAddSWITCH_POINT(builder *flatbuffers.Builder, SWITCH_POINT uint16) {
	builder.PrependUint16Slot(62, SWITCH_POINT, 0)
}
func RFOAddCONFIDENCE(builder *flatbuffers.Builder, CONFIDENCE float64) {
	builder.PrependFloat64Slot(63, CONFIDENCE, 0.0)
}
func RFOAddCARRIER_STANDARD(builder *flatbuffers.Builder, CARRIER_STANDARD flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(64, flatbuffers.UOffsetT(CARRIER_STANDARD), 0)
}
func RFOAddMODULATION(builder *flatbuffers.Builder, MODULATION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(65, flatbuffers.UOffsetT(MODULATION), 0)
}
func RFOAddINNER_CODING_RATE(builder *flatbuffers.Builder, INNER_CODING_RATE byte) {
	builder.PrependByteSlot(66, INNER_CODING_RATE, 0)
}
func RFOAddOUTER_CODING_RATE(builder *flatbuffers.Builder, OUTER_CODING_RATE byte) {
	builder.PrependByteSlot(67, OUTER_CODING_RATE, 0)
}
func RFOAddTRANSMIT_FILTER_TYPE(builder *flatbuffers.Builder, TRANSMIT_FILTER_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(68, flatbuffers.UOffsetT(TRANSMIT_FILTER_TYPE), 0)
}
func RFOAddTRANSMIT_FILTER_ROLL_OFF(builder *flatbuffers.Builder, TRANSMIT_FILTER_ROLL_OFF float64) {
	builder.PrependFloat64Slot(69, TRANSMIT_FILTER_ROLL_OFF, 0.0)
}
func RFOAddRAW_FILE_URI(builder *flatbuffers.Builder, RAW_FILE_URI flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(70, flatbuffers.UOffsetT(RAW_FILE_URI), 0)
}
func RFOAddDESCRIPTOR(builder *flatbuffers.Builder, DESCRIPTOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(71, flatbuffers.UOffsetT(DESCRIPTOR), 0)
}
func RFOAddURL(builder *flatbuffers.Builder, URL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(72, flatbuffers.UOffsetT(URL), 0)
}
func RFOAddTAGS(builder *flatbuffers.Builder, TAGS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(73, flatbuffers.UOffsetT(TAGS), 0)
}
func RFOStartTAGSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func RFOEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
