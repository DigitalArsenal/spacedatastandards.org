// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Sensor Systems
type SNR struct {
	_tab flatbuffers.Table
}

const SNRIdentifier = "$SNR"

func GetRootAsSNR(buf []byte, offset flatbuffers.UOffsetT) *SNR {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SNR{}
	x.Init(buf, n+offset)
	return x
}

func FinishSNRBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(SNRIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func SNRBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, SNRIdentifier)
}

func GetSizePrefixedRootAsSNR(buf []byte, offset flatbuffers.UOffsetT) *SNR {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SNR{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedSNRBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(SNRIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedSNRBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, SNRIdentifier)
}

func (rcv *SNR) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SNR) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SNR) TYPE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SNR) MutateTYPE(n byte) bool {
	return rcv._tab.MutateByteSlot(4, n)
}

func (rcv *SNR) MODE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SNR) MutateMODE(n byte) bool {
	return rcv._tab.MutateByteSlot(6, n)
}

func (rcv *SNR) RESERVED1() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SNR) MutateRESERVED1(n uint16) bool {
	return rcv._tab.MutateUint16Slot(8, n)
}

func (rcv *SNR) MAX_RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutateMAX_RANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

func (rcv *SNR) MIN_RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutateMIN_RANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

func (rcv *SNR) FOV_AZIMUTH() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutateFOV_AZIMUTH(n float32) bool {
	return rcv._tab.MutateFloat32Slot(14, n)
}

func (rcv *SNR) FOV_ELEVATION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutateFOV_ELEVATION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(16, n)
}

func (rcv *SNR) ANGULAR_RESOLUTION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutateANGULAR_RESOLUTION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(18, n)
}

func (rcv *SNR) RANGE_RESOLUTION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutateRANGE_RESOLUTION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(20, n)
}

func (rcv *SNR) UPDATE_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutateUPDATE_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(22, n)
}

func (rcv *SNR) DETECTION_THRESHOLD() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutateDETECTION_THRESHOLD(n float32) bool {
	return rcv._tab.MutateFloat32Slot(24, n)
}

func (rcv *SNR) AZIMUTH_SCAN_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutateAZIMUTH_SCAN_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(26, n)
}

func (rcv *SNR) ELEVATION_SCAN_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutateELEVATION_SCAN_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(28, n)
}

func (rcv *SNR) POWER() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutatePOWER(n float32) bool {
	return rcv._tab.MutateFloat32Slot(30, n)
}

func (rcv *SNR) FREQUENCY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *SNR) MutateFREQUENCY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(32, n)
}

func (rcv *SNR) RESERVED(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *SNR) RESERVEDLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SNR) RESERVEDBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *SNR) MutateRESERVED(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func SNRStart(builder *flatbuffers.Builder) {
	builder.StartObject(16)
}
func SNRAddTYPE(builder *flatbuffers.Builder, TYPE byte) {
	builder.PrependByteSlot(0, TYPE, 0)
}
func SNRAddMODE(builder *flatbuffers.Builder, MODE byte) {
	builder.PrependByteSlot(1, MODE, 0)
}
func SNRAddRESERVED1(builder *flatbuffers.Builder, RESERVED1 uint16) {
	builder.PrependUint16Slot(2, RESERVED1, 0)
}
func SNRAddMAX_RANGE(builder *flatbuffers.Builder, MAX_RANGE float64) {
	builder.PrependFloat64Slot(3, MAX_RANGE, 0.0)
}
func SNRAddMIN_RANGE(builder *flatbuffers.Builder, MIN_RANGE float64) {
	builder.PrependFloat64Slot(4, MIN_RANGE, 0.0)
}
func SNRAddFOV_AZIMUTH(builder *flatbuffers.Builder, FOV_AZIMUTH float32) {
	builder.PrependFloat32Slot(5, FOV_AZIMUTH, 0.0)
}
func SNRAddFOV_ELEVATION(builder *flatbuffers.Builder, FOV_ELEVATION float32) {
	builder.PrependFloat32Slot(6, FOV_ELEVATION, 0.0)
}
func SNRAddANGULAR_RESOLUTION(builder *flatbuffers.Builder, ANGULAR_RESOLUTION float32) {
	builder.PrependFloat32Slot(7, ANGULAR_RESOLUTION, 0.0)
}
func SNRAddRANGE_RESOLUTION(builder *flatbuffers.Builder, RANGE_RESOLUTION float32) {
	builder.PrependFloat32Slot(8, RANGE_RESOLUTION, 0.0)
}
func SNRAddUPDATE_RATE(builder *flatbuffers.Builder, UPDATE_RATE float32) {
	builder.PrependFloat32Slot(9, UPDATE_RATE, 0.0)
}
func SNRAddDETECTION_THRESHOLD(builder *flatbuffers.Builder, DETECTION_THRESHOLD float32) {
	builder.PrependFloat32Slot(10, DETECTION_THRESHOLD, 0.0)
}
func SNRAddAZIMUTH_SCAN_RATE(builder *flatbuffers.Builder, AZIMUTH_SCAN_RATE float32) {
	builder.PrependFloat32Slot(11, AZIMUTH_SCAN_RATE, 0.0)
}
func SNRAddELEVATION_SCAN_RATE(builder *flatbuffers.Builder, ELEVATION_SCAN_RATE float32) {
	builder.PrependFloat32Slot(12, ELEVATION_SCAN_RATE, 0.0)
}
func SNRAddPOWER(builder *flatbuffers.Builder, POWER float32) {
	builder.PrependFloat32Slot(13, POWER, 0.0)
}
func SNRAddFREQUENCY(builder *flatbuffers.Builder, FREQUENCY float32) {
	builder.PrependFloat32Slot(14, FREQUENCY, 0.0)
}
func SNRAddRESERVED(builder *flatbuffers.Builder, RESERVED flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(RESERVED), 0)
}
func SNRStartRESERVEDVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func SNREnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
