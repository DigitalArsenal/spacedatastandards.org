// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Ionospheric Observation
type ION struct {
	_tab flatbuffers.Table
}

const IONIdentifier = "$ION"

func GetRootAsION(buf []byte, offset flatbuffers.UOffsetT) *ION {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ION{}
	x.Init(buf, n+offset)
	return x
}

func FinishIONBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(IONIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func IONBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, IONIdentifier)
}

func GetSizePrefixedRootAsION(buf []byte, offset flatbuffers.UOffsetT) *ION {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ION{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedIONBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(IONIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedIONBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, IONIdentifier)
}

func (rcv *ION) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ION) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier
func (rcv *ION) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier
/// Data source type
func (rcv *ION) SOURCE() ionoSource {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return ionoSource(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Data source type
func (rcv *ION) MutateSOURCE(n ionoSource) bool {
	return rcv._tab.MutateInt8Slot(6, int8(n))
}

/// Station or sensor identifier
func (rcv *ION) STATION_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Station or sensor identifier
/// Station name
func (rcv *ION) STATION_NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Station name
/// Station geodetic latitude in degrees
func (rcv *ION) LATITUDE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Station geodetic latitude in degrees
func (rcv *ION) MutateLATITUDE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

/// Station geodetic longitude in degrees
func (rcv *ION) LONGITUDE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Station geodetic longitude in degrees
func (rcv *ION) MutateLONGITUDE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

/// Station altitude in meters
func (rcv *ION) ALTITUDE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Station altitude in meters
func (rcv *ION) MutateALTITUDE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// Observation start time (ISO 8601)
func (rcv *ION) START_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Observation start time (ISO 8601)
/// Observation stop time (ISO 8601)
func (rcv *ION) STOP_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Observation stop time (ISO 8601)
/// foF2 critical frequency in MHz
func (rcv *ION) FOF2() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// foF2 critical frequency in MHz
func (rcv *ION) MutateFOF2(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

/// foF1 critical frequency in MHz
func (rcv *ION) FOF1() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// foF1 critical frequency in MHz
func (rcv *ION) MutateFOF1(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// foE critical frequency in MHz
func (rcv *ION) FOE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// foE critical frequency in MHz
func (rcv *ION) MutateFOE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// foEs sporadic E critical frequency in MHz
func (rcv *ION) FOES() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// foEs sporadic E critical frequency in MHz
func (rcv *ION) MutateFOES(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

/// hmF2 peak height of F2 layer in km
func (rcv *ION) HMF2() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// hmF2 peak height of F2 layer in km
func (rcv *ION) MutateHMF2(n float64) bool {
	return rcv._tab.MutateFloat64Slot(30, n)
}

/// hmF1 peak height of F1 layer in km
func (rcv *ION) HMF1() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// hmF1 peak height of F1 layer in km
func (rcv *ION) MutateHMF1(n float64) bool {
	return rcv._tab.MutateFloat64Slot(32, n)
}

/// hmE peak height of E layer in km
func (rcv *ION) HME() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// hmE peak height of E layer in km
func (rcv *ION) MutateHME(n float64) bool {
	return rcv._tab.MutateFloat64Slot(34, n)
}

/// NmF2 peak density of F2 layer in electrons/m^3
func (rcv *ION) NMF2() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// NmF2 peak density of F2 layer in electrons/m^3
func (rcv *ION) MutateNMF2(n float64) bool {
	return rcv._tab.MutateFloat64Slot(36, n)
}

/// Vertical TEC in TECU
func (rcv *ION) VTEC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Vertical TEC in TECU
func (rcv *ION) MutateVTEC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

/// Slant TEC in TECU
func (rcv *ION) STEC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Slant TEC in TECU
func (rcv *ION) MutateSTEC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// Scintillation index S4
func (rcv *ION) S4() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Scintillation index S4
func (rcv *ION) MutateS4(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// Observation data points
func (rcv *ION) DATA_POINTS(obj *ionoDataPoint, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ION) DATA_POINTSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Observation data points
/// Electron density profiles
func (rcv *ION) DENSITY_PROFILES(obj *ionoDensityProfile, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ION) DENSITY_PROFILESLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Electron density profiles
/// Data quality indicator (0-9, 9=best)
func (rcv *ION) QUALITY() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Data quality indicator (0-9, 9=best)
func (rcv *ION) MutateQUALITY(n byte) bool {
	return rcv._tab.MutateByteSlot(48, n)
}

/// Additional notes
func (rcv *ION) NOTES() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Additional notes
func IONStart(builder *flatbuffers.Builder) {
	builder.StartObject(24)
}
func IONAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func IONAddSOURCE(builder *flatbuffers.Builder, SOURCE ionoSource) {
	builder.PrependInt8Slot(1, int8(SOURCE), 0)
}
func IONAddSTATION_ID(builder *flatbuffers.Builder, STATION_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(STATION_ID), 0)
}
func IONAddSTATION_NAME(builder *flatbuffers.Builder, STATION_NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(STATION_NAME), 0)
}
func IONAddLATITUDE(builder *flatbuffers.Builder, LATITUDE float64) {
	builder.PrependFloat64Slot(4, LATITUDE, 0.0)
}
func IONAddLONGITUDE(builder *flatbuffers.Builder, LONGITUDE float64) {
	builder.PrependFloat64Slot(5, LONGITUDE, 0.0)
}
func IONAddALTITUDE(builder *flatbuffers.Builder, ALTITUDE float64) {
	builder.PrependFloat64Slot(6, ALTITUDE, 0.0)
}
func IONAddSTART_TIME(builder *flatbuffers.Builder, START_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(START_TIME), 0)
}
func IONAddSTOP_TIME(builder *flatbuffers.Builder, STOP_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(STOP_TIME), 0)
}
func IONAddFOF2(builder *flatbuffers.Builder, FOF2 float64) {
	builder.PrependFloat64Slot(9, FOF2, 0.0)
}
func IONAddFOF1(builder *flatbuffers.Builder, FOF1 float64) {
	builder.PrependFloat64Slot(10, FOF1, 0.0)
}
func IONAddFOE(builder *flatbuffers.Builder, FOE float64) {
	builder.PrependFloat64Slot(11, FOE, 0.0)
}
func IONAddFOES(builder *flatbuffers.Builder, FOES float64) {
	builder.PrependFloat64Slot(12, FOES, 0.0)
}
func IONAddHMF2(builder *flatbuffers.Builder, HMF2 float64) {
	builder.PrependFloat64Slot(13, HMF2, 0.0)
}
func IONAddHMF1(builder *flatbuffers.Builder, HMF1 float64) {
	builder.PrependFloat64Slot(14, HMF1, 0.0)
}
func IONAddHME(builder *flatbuffers.Builder, HME float64) {
	builder.PrependFloat64Slot(15, HME, 0.0)
}
func IONAddNMF2(builder *flatbuffers.Builder, NMF2 float64) {
	builder.PrependFloat64Slot(16, NMF2, 0.0)
}
func IONAddVTEC(builder *flatbuffers.Builder, VTEC float64) {
	builder.PrependFloat64Slot(17, VTEC, 0.0)
}
func IONAddSTEC(builder *flatbuffers.Builder, STEC float64) {
	builder.PrependFloat64Slot(18, STEC, 0.0)
}
func IONAddS4(builder *flatbuffers.Builder, S4 float64) {
	builder.PrependFloat64Slot(19, S4, 0.0)
}
func IONAddDATA_POINTS(builder *flatbuffers.Builder, DATA_POINTS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(20, flatbuffers.UOffsetT(DATA_POINTS), 0)
}
func IONStartDATA_POINTSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func IONAddDENSITY_PROFILES(builder *flatbuffers.Builder, DENSITY_PROFILES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(DENSITY_PROFILES), 0)
}
func IONStartDENSITY_PROFILESVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func IONAddQUALITY(builder *flatbuffers.Builder, QUALITY byte) {
	builder.PrependByteSlot(22, QUALITY, 0)
}
func IONAddNOTES(builder *flatbuffers.Builder, NOTES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(23, flatbuffers.UOffsetT(NOTES), 0)
}
func IONEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
