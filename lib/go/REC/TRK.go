// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Track
type TRK struct {
	_tab flatbuffers.Table
}

const TRKIdentifier = "$TRK"

func GetRootAsTRK(buf []byte, offset flatbuffers.UOffsetT) *TRK {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TRK{}
	x.Init(buf, n+offset)
	return x
}

func FinishTRKBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(TRKIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func TRKBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, TRKIdentifier)
}

func GetSizePrefixedRootAsTRK(buf []byte, offset flatbuffers.UOffsetT) *TRK {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TRK{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedTRKBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(TRKIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedTRKBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, TRKIdentifier)
}

func (rcv *TRK) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TRK) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier
func (rcv *TRK) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier
/// Contact reference
func (rcv *TRK) CNTCT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Contact reference
/// Message timestamp (ISO 8601)
func (rcv *TRK) MSG_TS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Message timestamp (ISO 8601)
/// Mission identifier
func (rcv *TRK) MSN_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Mission identifier
/// Asset nationality
func (rcv *TRK) ASSET_NAT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Asset nationality
/// Asset identifier
func (rcv *TRK) ASSET() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Asset identifier
/// Sensor identifier
func (rcv *TRK) SENSOR_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Sensor identifier
/// Sensor quality assessment
func (rcv *TRK) SEN_QUAL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Sensor quality assessment
/// Track identifier
func (rcv *TRK) TRK_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Track identifier
/// Track number
func (rcv *TRK) TRK_NUM() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Track number
/// Track status
func (rcv *TRK) TRK_STAT() TrkTrackStatus {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return TrkTrackStatus(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Track status
func (rcv *TRK) MutateTRK_STAT(n TrkTrackStatus) bool {
	return rcv._tab.MutateInt8Slot(24, int8(n))
}

/// Object nationality
func (rcv *TRK) OBJ_NAT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Object nationality
/// Object identifier
func (rcv *TRK) OBJ_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Object identifier
/// Object type classification
func (rcv *TRK) OBJ_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Object type classification
/// Object specific type
func (rcv *TRK) OBJ_SPEC() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Object specific type
/// Object platform type
func (rcv *TRK) OBJ_PLAT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Object platform type
/// Object activity
func (rcv *TRK) OBJ_ACT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Object activity
/// Mode type
func (rcv *TRK) MOD_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Mode type
/// Track item identifier
func (rcv *TRK) TRK_ITM_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Track item identifier
/// Track point timestamp (ISO 8601)
func (rcv *TRK) TS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Track point timestamp (ISO 8601)
/// Track quality (0-15)
func (rcv *TRK) TRK_QUAL() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Track quality (0-15)
func (rcv *TRK) MutateTRK_QUAL(n byte) bool {
	return rcv._tab.MutateByteSlot(44, n)
}

/// Track point type
func (rcv *TRK) TRK_PT_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Track point type
/// Object identity assessment
func (rcv *TRK) OBJ_IDENT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Object identity assessment
/// Identity credibility (1-6)
func (rcv *TRK) IDENT_CRED() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Identity credibility (1-6)
func (rcv *TRK) MutateIDENT_CRED(n byte) bool {
	return rcv._tab.MutateByteSlot(50, n)
}

/// Identity reliability (A-F)
func (rcv *TRK) IDENT_REL() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Identity reliability (A-F)
func (rcv *TRK) MutateIDENT_REL(n byte) bool {
	return rcv._tab.MutateByteSlot(52, n)
}

/// Identity amplification
func (rcv *TRK) IDENT_AMP() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Identity amplification
/// Track environment
func (rcv *TRK) ENVIRONMENT() trackEnvironment {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return trackEnvironment(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Track environment
func (rcv *TRK) MutateENVIRONMENT(n trackEnvironment) bool {
	return rcv._tab.MutateInt8Slot(56, int8(n))
}

/// Environment confidence (0-1)
func (rcv *TRK) ENVIRONMENT_CONF() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Environment confidence (0-1)
func (rcv *TRK) MutateENVIRONMENT_CONF(n float64) bool {
	return rcv._tab.MutateFloat64Slot(58, n)
}

/// Track confidence (0-1)
func (rcv *TRK) TRK_CONF() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Track confidence (0-1)
func (rcv *TRK) MutateTRK_CONF(n float64) bool {
	return rcv._tab.MutateFloat64Slot(60, n)
}

/// Latitude (degrees)
func (rcv *TRK) LAT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Latitude (degrees)
func (rcv *TRK) MutateLAT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(62, n)
}

/// Longitude (degrees)
func (rcv *TRK) LON() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Longitude (degrees)
func (rcv *TRK) MutateLON(n float64) bool {
	return rcv._tab.MutateFloat64Slot(64, n)
}

/// Altitude (km)
func (rcv *TRK) ALT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Altitude (km)
func (rcv *TRK) MutateALT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(66, n)
}

/// Speed (km/s)
func (rcv *TRK) SPD() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Speed (km/s)
func (rcv *TRK) MutateSPD(n float64) bool {
	return rcv._tab.MutateFloat64Slot(68, n)
}

/// Heading (degrees from north)
func (rcv *TRK) HDNG() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Heading (degrees from north)
func (rcv *TRK) MutateHDNG(n float64) bool {
	return rcv._tab.MutateFloat64Slot(70, n)
}

/// Course (degrees from north)
func (rcv *TRK) COURSE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Course (degrees from north)
func (rcv *TRK) MutateCOURSE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(72, n)
}

/// Source types
func (rcv *TRK) SRC_TYPS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *TRK) SRC_TYPSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Source types
/// Source identifiers
func (rcv *TRK) SRC_IDS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *TRK) SRC_IDSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Source identifiers
/// Call sign
func (rcv *TRK) CALL_SIGN() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Call sign
/// True if fused from multiple sources
func (rcv *TRK) MULTI_SOURCE() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if fused from multiple sources
func (rcv *TRK) MutateMULTI_SOURCE(n bool) bool {
	return rcv._tab.MutateBoolSlot(80, n)
}

/// J-series message type
func (rcv *TRK) J_SERIES() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// J-series message type
/// Force strength indicator
func (rcv *TRK) STRENGTH() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

/// Force strength indicator
func (rcv *TRK) MutateSTRENGTH(n uint16) bool {
	return rcv._tab.MutateUint16Slot(84, n)
}

/// Mode 1 code
func (rcv *TRK) M1() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

/// Mode 1 code
func (rcv *TRK) MutateM1(n uint16) bool {
	return rcv._tab.MutateUint16Slot(86, n)
}

/// Mode 1 validity
func (rcv *TRK) M1V() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Mode 1 validity
func (rcv *TRK) MutateM1V(n byte) bool {
	return rcv._tab.MutateByteSlot(88, n)
}

/// Mode 2 code
func (rcv *TRK) M2() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(90))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

/// Mode 2 code
func (rcv *TRK) MutateM2(n uint16) bool {
	return rcv._tab.MutateUint16Slot(90, n)
}

/// Mode 2 validity
func (rcv *TRK) M2V() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(92))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Mode 2 validity
func (rcv *TRK) MutateM2V(n byte) bool {
	return rcv._tab.MutateByteSlot(92, n)
}

/// Mode 3A code
func (rcv *TRK) M3A() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(94))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

/// Mode 3A code
func (rcv *TRK) MutateM3A(n uint16) bool {
	return rcv._tab.MutateUint16Slot(94, n)
}

/// Mode 3A validity
func (rcv *TRK) M3AV() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(96))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Mode 3A validity
func (rcv *TRK) MutateM3AV(n byte) bool {
	return rcv._tab.MutateByteSlot(96, n)
}

/// Associated tags
func (rcv *TRK) TAGS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *TRK) TAGSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Associated tags
/// Start time for track data (ISO 8601)
func (rcv *TRK) TRACK_START_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(100))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Start time for track data (ISO 8601)
/// Time interval between track points (seconds)
func (rcv *TRK) TRACK_STEP_SIZE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Time interval between track points (seconds)
func (rcv *TRK) MutateTRACK_STEP_SIZE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(102, n)
}

/// Number of components per point (default 3 for X, Y, Z)
func (rcv *TRK) TRACK_COMPONENTS() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 3
}

/// Number of components per point (default 3 for X, Y, Z)
func (rcv *TRK) MutateTRACK_COMPONENTS(n byte) bool {
	return rcv._tab.MutateByteSlot(104, n)
}

/// ECEF position as flat array [X0, Y0, Z0, X1, Y1, Z1, ...]
func (rcv *TRK) ECEF_POS(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *TRK) ECEF_POSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// ECEF position as flat array [X0, Y0, Z0, X1, Y1, Z1, ...]
func (rcv *TRK) MutateECEF_POS(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// ECEF velocity as flat array [VX0, VY0, VZ0, VX1, VY1, VZ1, ...]
func (rcv *TRK) ECEF_VEL(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *TRK) ECEF_VELLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// ECEF velocity as flat array [VX0, VY0, VZ0, VX1, VY1, VZ1, ...]
func (rcv *TRK) MutateECEF_VEL(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// ECEF acceleration as flat array [AX0, AY0, AZ0, AX1, AY1, AZ1, ...]
func (rcv *TRK) ECEF_ACC(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *TRK) ECEF_ACCLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// ECEF acceleration as flat array [AX0, AY0, AZ0, AX1, AY1, AZ1, ...]
func (rcv *TRK) MutateECEF_ACC(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// Local coordinate position as flat array
func (rcv *TRK) LC_POS(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *TRK) LC_POSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Local coordinate position as flat array
func (rcv *TRK) MutateLC_POS(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// Local coordinate velocity as flat array
func (rcv *TRK) LC_VEL(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *TRK) LC_VELLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Local coordinate velocity as flat array
func (rcv *TRK) MutateLC_VEL(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// Local coordinate acceleration as flat array
func (rcv *TRK) LC_ACC(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *TRK) LC_ACCLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Local coordinate acceleration as flat array
func (rcv *TRK) MutateLC_ACC(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// Covariance data (21 elements per point for 6x6 lower triangular)
func (rcv *TRK) COV(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *TRK) COVLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Covariance data (21 elements per point for 6x6 lower triangular)
func (rcv *TRK) MutateCOV(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// Error ellipse data (6 elements per point)
func (rcv *TRK) ERR_ELLP(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(120))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *TRK) ERR_ELLPLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(120))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Error ellipse data (6 elements per point)
func (rcv *TRK) MutateERR_ELLP(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(120))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func TRKStart(builder *flatbuffers.Builder) {
	builder.StartObject(59)
}
func TRKAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func TRKAddCNTCT(builder *flatbuffers.Builder, CNTCT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(CNTCT), 0)
}
func TRKAddMSG_TS(builder *flatbuffers.Builder, MSG_TS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(MSG_TS), 0)
}
func TRKAddMSN_ID(builder *flatbuffers.Builder, MSN_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(MSN_ID), 0)
}
func TRKAddASSET_NAT(builder *flatbuffers.Builder, ASSET_NAT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(ASSET_NAT), 0)
}
func TRKAddASSET(builder *flatbuffers.Builder, ASSET flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(ASSET), 0)
}
func TRKAddSENSOR_ID(builder *flatbuffers.Builder, SENSOR_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(SENSOR_ID), 0)
}
func TRKAddSEN_QUAL(builder *flatbuffers.Builder, SEN_QUAL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(SEN_QUAL), 0)
}
func TRKAddTRK_ID(builder *flatbuffers.Builder, TRK_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(TRK_ID), 0)
}
func TRKAddTRK_NUM(builder *flatbuffers.Builder, TRK_NUM flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(TRK_NUM), 0)
}
func TRKAddTRK_STAT(builder *flatbuffers.Builder, TRK_STAT TrkTrackStatus) {
	builder.PrependInt8Slot(10, int8(TRK_STAT), 0)
}
func TRKAddOBJ_NAT(builder *flatbuffers.Builder, OBJ_NAT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(OBJ_NAT), 0)
}
func TRKAddOBJ_ID(builder *flatbuffers.Builder, OBJ_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(OBJ_ID), 0)
}
func TRKAddOBJ_TYPE(builder *flatbuffers.Builder, OBJ_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(OBJ_TYPE), 0)
}
func TRKAddOBJ_SPEC(builder *flatbuffers.Builder, OBJ_SPEC flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(OBJ_SPEC), 0)
}
func TRKAddOBJ_PLAT(builder *flatbuffers.Builder, OBJ_PLAT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(OBJ_PLAT), 0)
}
func TRKAddOBJ_ACT(builder *flatbuffers.Builder, OBJ_ACT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(OBJ_ACT), 0)
}
func TRKAddMOD_TYPE(builder *flatbuffers.Builder, MOD_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(MOD_TYPE), 0)
}
func TRKAddTRK_ITM_ID(builder *flatbuffers.Builder, TRK_ITM_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(18, flatbuffers.UOffsetT(TRK_ITM_ID), 0)
}
func TRKAddTS(builder *flatbuffers.Builder, TS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(19, flatbuffers.UOffsetT(TS), 0)
}
func TRKAddTRK_QUAL(builder *flatbuffers.Builder, TRK_QUAL byte) {
	builder.PrependByteSlot(20, TRK_QUAL, 0)
}
func TRKAddTRK_PT_TYPE(builder *flatbuffers.Builder, TRK_PT_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(TRK_PT_TYPE), 0)
}
func TRKAddOBJ_IDENT(builder *flatbuffers.Builder, OBJ_IDENT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(22, flatbuffers.UOffsetT(OBJ_IDENT), 0)
}
func TRKAddIDENT_CRED(builder *flatbuffers.Builder, IDENT_CRED byte) {
	builder.PrependByteSlot(23, IDENT_CRED, 0)
}
func TRKAddIDENT_REL(builder *flatbuffers.Builder, IDENT_REL byte) {
	builder.PrependByteSlot(24, IDENT_REL, 0)
}
func TRKAddIDENT_AMP(builder *flatbuffers.Builder, IDENT_AMP flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(25, flatbuffers.UOffsetT(IDENT_AMP), 0)
}
func TRKAddENVIRONMENT(builder *flatbuffers.Builder, ENVIRONMENT trackEnvironment) {
	builder.PrependInt8Slot(26, int8(ENVIRONMENT), 0)
}
func TRKAddENVIRONMENT_CONF(builder *flatbuffers.Builder, ENVIRONMENT_CONF float64) {
	builder.PrependFloat64Slot(27, ENVIRONMENT_CONF, 0.0)
}
func TRKAddTRK_CONF(builder *flatbuffers.Builder, TRK_CONF float64) {
	builder.PrependFloat64Slot(28, TRK_CONF, 0.0)
}
func TRKAddLAT(builder *flatbuffers.Builder, LAT float64) {
	builder.PrependFloat64Slot(29, LAT, 0.0)
}
func TRKAddLON(builder *flatbuffers.Builder, LON float64) {
	builder.PrependFloat64Slot(30, LON, 0.0)
}
func TRKAddALT(builder *flatbuffers.Builder, ALT float64) {
	builder.PrependFloat64Slot(31, ALT, 0.0)
}
func TRKAddSPD(builder *flatbuffers.Builder, SPD float64) {
	builder.PrependFloat64Slot(32, SPD, 0.0)
}
func TRKAddHDNG(builder *flatbuffers.Builder, HDNG float64) {
	builder.PrependFloat64Slot(33, HDNG, 0.0)
}
func TRKAddCOURSE(builder *flatbuffers.Builder, COURSE float64) {
	builder.PrependFloat64Slot(34, COURSE, 0.0)
}
func TRKAddSRC_TYPS(builder *flatbuffers.Builder, SRC_TYPS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(35, flatbuffers.UOffsetT(SRC_TYPS), 0)
}
func TRKStartSRC_TYPSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TRKAddSRC_IDS(builder *flatbuffers.Builder, SRC_IDS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(36, flatbuffers.UOffsetT(SRC_IDS), 0)
}
func TRKStartSRC_IDSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TRKAddCALL_SIGN(builder *flatbuffers.Builder, CALL_SIGN flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(37, flatbuffers.UOffsetT(CALL_SIGN), 0)
}
func TRKAddMULTI_SOURCE(builder *flatbuffers.Builder, MULTI_SOURCE bool) {
	builder.PrependBoolSlot(38, MULTI_SOURCE, false)
}
func TRKAddJ_SERIES(builder *flatbuffers.Builder, J_SERIES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(39, flatbuffers.UOffsetT(J_SERIES), 0)
}
func TRKAddSTRENGTH(builder *flatbuffers.Builder, STRENGTH uint16) {
	builder.PrependUint16Slot(40, STRENGTH, 0)
}
func TRKAddM1(builder *flatbuffers.Builder, M1 uint16) {
	builder.PrependUint16Slot(41, M1, 0)
}
func TRKAddM1V(builder *flatbuffers.Builder, M1V byte) {
	builder.PrependByteSlot(42, M1V, 0)
}
func TRKAddM2(builder *flatbuffers.Builder, M2 uint16) {
	builder.PrependUint16Slot(43, M2, 0)
}
func TRKAddM2V(builder *flatbuffers.Builder, M2V byte) {
	builder.PrependByteSlot(44, M2V, 0)
}
func TRKAddM3A(builder *flatbuffers.Builder, M3A uint16) {
	builder.PrependUint16Slot(45, M3A, 0)
}
func TRKAddM3AV(builder *flatbuffers.Builder, M3AV byte) {
	builder.PrependByteSlot(46, M3AV, 0)
}
func TRKAddTAGS(builder *flatbuffers.Builder, TAGS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(47, flatbuffers.UOffsetT(TAGS), 0)
}
func TRKStartTAGSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TRKAddTRACK_START_TIME(builder *flatbuffers.Builder, TRACK_START_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(48, flatbuffers.UOffsetT(TRACK_START_TIME), 0)
}
func TRKAddTRACK_STEP_SIZE(builder *flatbuffers.Builder, TRACK_STEP_SIZE float64) {
	builder.PrependFloat64Slot(49, TRACK_STEP_SIZE, 0.0)
}
func TRKAddTRACK_COMPONENTS(builder *flatbuffers.Builder, TRACK_COMPONENTS byte) {
	builder.PrependByteSlot(50, TRACK_COMPONENTS, 3)
}
func TRKAddECEF_POS(builder *flatbuffers.Builder, ECEF_POS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(51, flatbuffers.UOffsetT(ECEF_POS), 0)
}
func TRKStartECEF_POSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TRKAddECEF_VEL(builder *flatbuffers.Builder, ECEF_VEL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(52, flatbuffers.UOffsetT(ECEF_VEL), 0)
}
func TRKStartECEF_VELVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TRKAddECEF_ACC(builder *flatbuffers.Builder, ECEF_ACC flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(53, flatbuffers.UOffsetT(ECEF_ACC), 0)
}
func TRKStartECEF_ACCVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TRKAddLC_POS(builder *flatbuffers.Builder, LC_POS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(54, flatbuffers.UOffsetT(LC_POS), 0)
}
func TRKStartLC_POSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TRKAddLC_VEL(builder *flatbuffers.Builder, LC_VEL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(55, flatbuffers.UOffsetT(LC_VEL), 0)
}
func TRKStartLC_VELVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TRKAddLC_ACC(builder *flatbuffers.Builder, LC_ACC flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(56, flatbuffers.UOffsetT(LC_ACC), 0)
}
func TRKStartLC_ACCVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TRKAddCOV(builder *flatbuffers.Builder, COV flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(57, flatbuffers.UOffsetT(COV), 0)
}
func TRKStartCOVVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TRKAddERR_ELLP(builder *flatbuffers.Builder, ERR_ELLP flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(58, flatbuffers.UOffsetT(ERR_ELLP), 0)
}
func TRKStartERR_ELLPVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func TRKEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
