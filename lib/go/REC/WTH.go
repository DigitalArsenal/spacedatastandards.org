// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Weather Data
type WTH struct {
	_tab flatbuffers.Table
}

const WTHIdentifier = "$WTH"

func GetRootAsWTH(buf []byte, offset flatbuffers.UOffsetT) *WTH {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &WTH{}
	x.Init(buf, n+offset)
	return x
}

func FinishWTHBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(WTHIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func WTHBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, WTHIdentifier)
}

func GetSizePrefixedRootAsWTH(buf []byte, offset flatbuffers.UOffsetT) *WTH {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &WTH{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedWTHBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(WTHIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedWTHBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, WTHIdentifier)
}

func (rcv *WTH) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *WTH) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *WTH) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *WTH) ID_SENSOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *WTH) ORIG_SENSOR_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *WTH) OB_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *WTH) SIG_PWRS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) SIG_PWRSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) NOISE_LVLS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) NOISE_LVLSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) SPEC_WIDTHS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) SPEC_WIDTHSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) FIRST_GUESS_AVGS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) FIRST_GUESS_AVGSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) QC_VALUE() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *WTH) MutateQC_VALUE(n int32) bool {
	return rcv._tab.MutateInt32Slot(20, n)
}

func (rcv *WTH) FILE_CREATION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *WTH) TERM_ALT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *WTH) MutateTERM_ALT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

func (rcv *WTH) AVG_TX_PWR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *WTH) MutateAVG_TX_PWR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

func (rcv *WTH) AVG_REF_PWR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *WTH) MutateAVG_REF_PWR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

func (rcv *WTH) SECTOR_NUM() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *WTH) MutateSECTOR_NUM(n int32) bool {
	return rcv._tab.MutateInt32Slot(30, n)
}

func (rcv *WTH) NUM_ELEMENTS() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *WTH) MutateNUM_ELEMENTS(n int32) bool {
	return rcv._tab.MutateInt32Slot(32, n)
}

func (rcv *WTH) TD_AVG_SAMPLE_NUMS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) TD_AVG_SAMPLE_NUMSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) CHECKSUM() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *WTH) MutateCHECKSUM(n int32) bool {
	return rcv._tab.MutateInt32Slot(36, n)
}

func (rcv *WTH) CO_INTEGS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) CO_INTEGSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) SPEC_AVGS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) SPEC_AVGSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) INTERPULSE_PERIODS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) INTERPULSE_PERIODSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) DOPP_VELS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) DOPP_VELSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) CONS_RECS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) CONS_RECSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) SNRS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) SNRSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) SIG_STRENGTH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *WTH) MutateSIG_STRENGTH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

func (rcv *WTH) SEMI_MAJOR_AXIS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *WTH) MutateSEMI_MAJOR_AXIS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(52, n)
}

func (rcv *WTH) SEMI_MINOR_AXIS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *WTH) MutateSEMI_MINOR_AXIS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(54, n)
}

func (rcv *WTH) ANGLE_ORIENTATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *WTH) MutateANGLE_ORIENTATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(56, n)
}

func (rcv *WTH) LIGHT_EVENT_NUM() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *WTH) MutateLIGHT_EVENT_NUM(n int32) bool {
	return rcv._tab.MutateInt32Slot(58, n)
}

func (rcv *WTH) LIGHT_DET_SENSORS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) LIGHT_DET_SENSORSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) POS_CONFIDENCE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *WTH) MutatePOS_CONFIDENCE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(62, n)
}

func (rcv *WTH) SRC_TYPS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) SRC_TYPSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WTH) SRC_IDS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WTH) SRC_IDSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func WTHStart(builder *flatbuffers.Builder) {
	builder.StartObject(32)
}
func WTHAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func WTHAddID_SENSOR(builder *flatbuffers.Builder, ID_SENSOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(ID_SENSOR), 0)
}
func WTHAddORIG_SENSOR_ID(builder *flatbuffers.Builder, ORIG_SENSOR_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(ORIG_SENSOR_ID), 0)
}
func WTHAddOB_TIME(builder *flatbuffers.Builder, OB_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(OB_TIME), 0)
}
func WTHAddSIG_PWRS(builder *flatbuffers.Builder, SIG_PWRS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(SIG_PWRS), 0)
}
func WTHStartSIG_PWRSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddNOISE_LVLS(builder *flatbuffers.Builder, NOISE_LVLS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(NOISE_LVLS), 0)
}
func WTHStartNOISE_LVLSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddSPEC_WIDTHS(builder *flatbuffers.Builder, SPEC_WIDTHS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(SPEC_WIDTHS), 0)
}
func WTHStartSPEC_WIDTHSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddFIRST_GUESS_AVGS(builder *flatbuffers.Builder, FIRST_GUESS_AVGS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(FIRST_GUESS_AVGS), 0)
}
func WTHStartFIRST_GUESS_AVGSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddQC_VALUE(builder *flatbuffers.Builder, QC_VALUE int32) {
	builder.PrependInt32Slot(8, QC_VALUE, 0)
}
func WTHAddFILE_CREATION(builder *flatbuffers.Builder, FILE_CREATION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(FILE_CREATION), 0)
}
func WTHAddTERM_ALT(builder *flatbuffers.Builder, TERM_ALT float64) {
	builder.PrependFloat64Slot(10, TERM_ALT, 0.0)
}
func WTHAddAVG_TX_PWR(builder *flatbuffers.Builder, AVG_TX_PWR float64) {
	builder.PrependFloat64Slot(11, AVG_TX_PWR, 0.0)
}
func WTHAddAVG_REF_PWR(builder *flatbuffers.Builder, AVG_REF_PWR float64) {
	builder.PrependFloat64Slot(12, AVG_REF_PWR, 0.0)
}
func WTHAddSECTOR_NUM(builder *flatbuffers.Builder, SECTOR_NUM int32) {
	builder.PrependInt32Slot(13, SECTOR_NUM, 0)
}
func WTHAddNUM_ELEMENTS(builder *flatbuffers.Builder, NUM_ELEMENTS int32) {
	builder.PrependInt32Slot(14, NUM_ELEMENTS, 0)
}
func WTHAddTD_AVG_SAMPLE_NUMS(builder *flatbuffers.Builder, TD_AVG_SAMPLE_NUMS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(TD_AVG_SAMPLE_NUMS), 0)
}
func WTHStartTD_AVG_SAMPLE_NUMSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddCHECKSUM(builder *flatbuffers.Builder, CHECKSUM int32) {
	builder.PrependInt32Slot(16, CHECKSUM, 0)
}
func WTHAddCO_INTEGS(builder *flatbuffers.Builder, CO_INTEGS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(CO_INTEGS), 0)
}
func WTHStartCO_INTEGSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddSPEC_AVGS(builder *flatbuffers.Builder, SPEC_AVGS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(18, flatbuffers.UOffsetT(SPEC_AVGS), 0)
}
func WTHStartSPEC_AVGSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddINTERPULSE_PERIODS(builder *flatbuffers.Builder, INTERPULSE_PERIODS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(19, flatbuffers.UOffsetT(INTERPULSE_PERIODS), 0)
}
func WTHStartINTERPULSE_PERIODSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddDOPP_VELS(builder *flatbuffers.Builder, DOPP_VELS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(20, flatbuffers.UOffsetT(DOPP_VELS), 0)
}
func WTHStartDOPP_VELSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddCONS_RECS(builder *flatbuffers.Builder, CONS_RECS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(CONS_RECS), 0)
}
func WTHStartCONS_RECSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddSNRS(builder *flatbuffers.Builder, SNRS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(22, flatbuffers.UOffsetT(SNRS), 0)
}
func WTHStartSNRSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddSIG_STRENGTH(builder *flatbuffers.Builder, SIG_STRENGTH float64) {
	builder.PrependFloat64Slot(23, SIG_STRENGTH, 0.0)
}
func WTHAddSEMI_MAJOR_AXIS(builder *flatbuffers.Builder, SEMI_MAJOR_AXIS float64) {
	builder.PrependFloat64Slot(24, SEMI_MAJOR_AXIS, 0.0)
}
func WTHAddSEMI_MINOR_AXIS(builder *flatbuffers.Builder, SEMI_MINOR_AXIS float64) {
	builder.PrependFloat64Slot(25, SEMI_MINOR_AXIS, 0.0)
}
func WTHAddANGLE_ORIENTATION(builder *flatbuffers.Builder, ANGLE_ORIENTATION float64) {
	builder.PrependFloat64Slot(26, ANGLE_ORIENTATION, 0.0)
}
func WTHAddLIGHT_EVENT_NUM(builder *flatbuffers.Builder, LIGHT_EVENT_NUM int32) {
	builder.PrependInt32Slot(27, LIGHT_EVENT_NUM, 0)
}
func WTHAddLIGHT_DET_SENSORS(builder *flatbuffers.Builder, LIGHT_DET_SENSORS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(28, flatbuffers.UOffsetT(LIGHT_DET_SENSORS), 0)
}
func WTHStartLIGHT_DET_SENSORSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddPOS_CONFIDENCE(builder *flatbuffers.Builder, POS_CONFIDENCE float64) {
	builder.PrependFloat64Slot(29, POS_CONFIDENCE, 0.0)
}
func WTHAddSRC_TYPS(builder *flatbuffers.Builder, SRC_TYPS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(30, flatbuffers.UOffsetT(SRC_TYPS), 0)
}
func WTHStartSRC_TYPSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHAddSRC_IDS(builder *flatbuffers.Builder, SRC_IDS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(31, flatbuffers.UOffsetT(SRC_IDS), 0)
}
func WTHStartSRC_IDSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WTHEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
