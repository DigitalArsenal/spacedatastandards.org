// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Minimum Propagatable Element Set
type MPE struct {
	_tab flatbuffers.Table
}

func GetRootAsMPE(buf []byte, offset flatbuffers.UOffsetT) *MPE {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MPE{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsMPE(buf []byte, offset flatbuffers.UOffsetT) *MPE {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &MPE{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *MPE) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MPE) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique ID as a String
func (rcv *MPE) ENTITY_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique ID as a String
/// Epoch of Mean Keplerian elements. (UNIX TimeStamp)
func (rcv *MPE) EPOCH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Epoch of Mean Keplerian elements. (UNIX TimeStamp)
func (rcv *MPE) MutateEPOCH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

/// Semi-major axis in km or mean motion in rev/day
func (rcv *MPE) MEAN_MOTION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Semi-major axis in km or mean motion in rev/day
func (rcv *MPE) MutateMEAN_MOTION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(8, n)
}

/// Eccentricity
func (rcv *MPE) ECCENTRICITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Eccentricity
func (rcv *MPE) MutateECCENTRICITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

/// Inclination
func (rcv *MPE) INCLINATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Inclination
func (rcv *MPE) MutateINCLINATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

/// Right ascension of ascending node
func (rcv *MPE) RA_OF_ASC_NODE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Right ascension of ascending node
func (rcv *MPE) MutateRA_OF_ASC_NODE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

/// Argument of pericenter
func (rcv *MPE) ARG_OF_PERICENTER() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Argument of pericenter
func (rcv *MPE) MutateARG_OF_PERICENTER(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// Mean anomaly
func (rcv *MPE) MEAN_ANOMALY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Mean anomaly
func (rcv *MPE) MutateMEAN_ANOMALY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

/// SGP/SGP4 drag-like coefficient (in units 1/[Earth radii])
func (rcv *MPE) BSTAR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// SGP/SGP4 drag-like coefficient (in units 1/[Earth radii])
func (rcv *MPE) MutateBSTAR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

/// Description of the Mean Element Theory. (SGP4,DSST,USM)
func (rcv *MPE) MEAN_ELEMENT_THEORY() meanElementTheory {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return meanElementTheory(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Description of the Mean Element Theory. (SGP4,DSST,USM)
func (rcv *MPE) MutateMEAN_ELEMENT_THEORY(n meanElementTheory) bool {
	return rcv._tab.MutateInt8Slot(22, int8(n))
}

func MPEStart(builder *flatbuffers.Builder) {
	builder.StartObject(10)
}
func MPEAddENTITY_ID(builder *flatbuffers.Builder, ENTITY_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ENTITY_ID), 0)
}
func MPEAddEPOCH(builder *flatbuffers.Builder, EPOCH float64) {
	builder.PrependFloat64Slot(1, EPOCH, 0.0)
}
func MPEAddMEAN_MOTION(builder *flatbuffers.Builder, MEAN_MOTION float64) {
	builder.PrependFloat64Slot(2, MEAN_MOTION, 0.0)
}
func MPEAddECCENTRICITY(builder *flatbuffers.Builder, ECCENTRICITY float64) {
	builder.PrependFloat64Slot(3, ECCENTRICITY, 0.0)
}
func MPEAddINCLINATION(builder *flatbuffers.Builder, INCLINATION float64) {
	builder.PrependFloat64Slot(4, INCLINATION, 0.0)
}
func MPEAddRA_OF_ASC_NODE(builder *flatbuffers.Builder, RA_OF_ASC_NODE float64) {
	builder.PrependFloat64Slot(5, RA_OF_ASC_NODE, 0.0)
}
func MPEAddARG_OF_PERICENTER(builder *flatbuffers.Builder, ARG_OF_PERICENTER float64) {
	builder.PrependFloat64Slot(6, ARG_OF_PERICENTER, 0.0)
}
func MPEAddMEAN_ANOMALY(builder *flatbuffers.Builder, MEAN_ANOMALY float64) {
	builder.PrependFloat64Slot(7, MEAN_ANOMALY, 0.0)
}
func MPEAddBSTAR(builder *flatbuffers.Builder, BSTAR float64) {
	builder.PrependFloat64Slot(8, BSTAR, 0.0)
}
func MPEAddMEAN_ELEMENT_THEORY(builder *flatbuffers.Builder, MEAN_ELEMENT_THEORY meanElementTheory) {
	builder.PrependInt8Slot(9, int8(MEAN_ELEMENT_THEORY), 0)
}
func MPEEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
