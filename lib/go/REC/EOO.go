// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Electro-Optical Observation
type EOO struct {
	_tab flatbuffers.Table
}

const EOOIdentifier = "$EOO"

func GetRootAsEOO(buf []byte, offset flatbuffers.UOffsetT) *EOO {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &EOO{}
	x.Init(buf, n+offset)
	return x
}

func FinishEOOBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(EOOIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func EOOBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, EOOIdentifier)
}

func GetSizePrefixedRootAsEOO(buf []byte, offset flatbuffers.UOffsetT) *EOO {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &EOO{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedEOOBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(EOOIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedEOOBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, EOOIdentifier)
}

func (rcv *EOO) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *EOO) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier of the record.
func (rcv *EOO) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier of the record.
/// Classification marking of the data in IC/CAPCO Portion-marked format.
func (rcv *EOO) CLASSIFICATION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Classification marking of the data in IC/CAPCO Portion-marked format.
/// Ob detection time in ISO 8601 UTC (YYYY-MM-DDTHH:MM:SS.ssssssZ), up to microsecond precision.
func (rcv *EOO) OB_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Ob detection time in ISO 8601 UTC (YYYY-MM-DDTHH:MM:SS.ssssssZ), up to microsecond precision.
/// Correlation score of the observation when compared to a known orbit state.
func (rcv *EOO) CORR_QUALITY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Correlation score of the observation when compared to a known orbit state.
func (rcv *EOO) MutateCORR_QUALITY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(10, n)
}

/// Server will auto-populate with SAT_NO if available.
func (rcv *EOO) ID_ON_ORBIT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Server will auto-populate with SAT_NO if available.
/// Unique ID of the sensor. Must have a corresponding sensor record on the server.
func (rcv *EOO) SENSOR_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique ID of the sensor. Must have a corresponding sensor record on the server.
/// Accepted Collection Method
func (rcv *EOO) COLLECT_METHOD() CollectMethod {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return CollectMethod(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Accepted Collection Method
func (rcv *EOO) MutateCOLLECT_METHOD(n CollectMethod) bool {
	return rcv._tab.MutateInt8Slot(16, int8(n))
}

/// 18SDS satellite number. Only list if correlated against the 18SDS catalog.
func (rcv *EOO) NORAD_CAT_ID() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// 18SDS satellite number. Only list if correlated against the 18SDS catalog.
func (rcv *EOO) MutateNORAD_CAT_ID(n int32) bool {
	return rcv._tab.MutateInt32Slot(18, n)
}

/// Identifier for the collectRequest message if the collection was in response to tasking.
func (rcv *EOO) TASK_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Identifier for the collectRequest message if the collection was in response to tasking.
/// Optional identifier to track a transaction.
func (rcv *EOO) TRANSACTION_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional identifier to track a transaction.
/// The user-defined set ID of a sequence of images.
func (rcv *EOO) IMAGE_SET_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The user-defined set ID of a sequence of images.
/// The number of images in an image set.
func (rcv *EOO) IMAGE_SET_LENGTH() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// The number of images in an image set.
func (rcv *EOO) MutateIMAGE_SET_LENGTH(n int32) bool {
	return rcv._tab.MutateInt32Slot(26, n)
}

/// The sequence ID of an image within an image set.
func (rcv *EOO) SEQUENCE_ID() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// The sequence ID of an image within an image set.
func (rcv *EOO) MutateSEQUENCE_ID(n int32) bool {
	return rcv._tab.MutateInt32Slot(28, n)
}

/// The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).
func (rcv *EOO) OB_POSITION() ObservationPosition {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return ObservationPosition(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).
func (rcv *EOO) MutateOB_POSITION(n ObservationPosition) bool {
	return rcv._tab.MutateInt8Slot(30, int8(n))
}

/// Provider maintained ID. May not be consistent with 18SDS SAT_NO.
func (rcv *EOO) ORIG_OBJECT_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Provider maintained ID. May not be consistent with 18SDS SAT_NO.
/// Sensor ID.
func (rcv *EOO) ORIG_SENSOR_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Sensor ID.
/// Required if correlation is attempted. Indicates whether correlation succeeded.
func (rcv *EOO) UCT() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Required if correlation is attempted. Indicates whether correlation succeeded.
func (rcv *EOO) MutateUCT(n bool) bool {
	return rcv._tab.MutateBoolSlot(36, n)
}

/// Line of sight azimuth angle in degrees and topocentric frame.
func (rcv *EOO) AZIMUTH() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Line of sight azimuth angle in degrees and topocentric frame.
func (rcv *EOO) MutateAZIMUTH(n float32) bool {
	return rcv._tab.MutateFloat32Slot(38, n)
}

/// One sigma uncertainty in the line of sight azimuth angle, in degrees.
func (rcv *EOO) AZIMUTH_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight azimuth angle, in degrees.
func (rcv *EOO) MutateAZIMUTH_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(40, n)
}

/// Sensor line of sight azimuth angle bias in degrees.
func (rcv *EOO) AZIMUTH_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor line of sight azimuth angle bias in degrees.
func (rcv *EOO) MutateAZIMUTH_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(42, n)
}

/// Rate of change of the line of sight azimuth in degrees per second.
func (rcv *EOO) AZIMUTH_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Rate of change of the line of sight azimuth in degrees per second.
func (rcv *EOO) MutateAZIMUTH_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(44, n)
}

/// Line of sight elevation in degrees and topocentric frame.
func (rcv *EOO) ELEVATION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Line of sight elevation in degrees and topocentric frame.
func (rcv *EOO) MutateELEVATION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(46, n)
}

/// One sigma uncertainty in the line of sight elevation angle, in degrees.
func (rcv *EOO) ELEVATION_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight elevation angle, in degrees.
func (rcv *EOO) MutateELEVATION_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(48, n)
}

/// Sensor line of sight elevation bias in degrees.
func (rcv *EOO) ELEVATION_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor line of sight elevation bias in degrees.
func (rcv *EOO) MutateELEVATION_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(50, n)
}

/// Rate of change of the line of sight elevation in degrees per second.
func (rcv *EOO) ELEVATION_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Rate of change of the line of sight elevation in degrees per second.
func (rcv *EOO) MutateELEVATION_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(52, n)
}

/// Line of sight range in km. Reported value should include all applicable corrections.
func (rcv *EOO) RANGE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Line of sight range in km. Reported value should include all applicable corrections.
func (rcv *EOO) MutateRANGE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(54, n)
}

/// One sigma uncertainty in the line of sight range, in km.
func (rcv *EOO) RANGE_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight range, in km.
func (rcv *EOO) MutateRANGE_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(56, n)
}

/// Sensor line of sight range bias in km.
func (rcv *EOO) RANGE_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor line of sight range bias in km.
func (rcv *EOO) MutateRANGE_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(58, n)
}

/// Range rate in km/s. Reported value should include all applicable corrections.
func (rcv *EOO) RANGE_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Range rate in km/s. Reported value should include all applicable corrections.
func (rcv *EOO) MutateRANGE_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(60, n)
}

/// One sigma uncertainty in the line of sight range rate, in km/sec.
func (rcv *EOO) RANGE_RATE_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight range rate, in km/sec.
func (rcv *EOO) MutateRANGE_RATE_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(62, n)
}

/// Right ascension in degrees. Required metric reporting field for EO observations.
func (rcv *EOO) RA() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Right ascension in degrees. Required metric reporting field for EO observations.
func (rcv *EOO) MutateRA(n float32) bool {
	return rcv._tab.MutateFloat32Slot(64, n)
}

/// Line of sight right ascension rate of change, in degrees/sec.
func (rcv *EOO) RA_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Line of sight right ascension rate of change, in degrees/sec.
func (rcv *EOO) MutateRA_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(66, n)
}

/// One sigma uncertainty in the line of sight right ascension angle, in degrees.
func (rcv *EOO) RA_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight right ascension angle, in degrees.
func (rcv *EOO) MutateRA_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(68, n)
}

/// Sensor line of sight right ascension bias in degrees.
func (rcv *EOO) RA_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor line of sight right ascension bias in degrees.
func (rcv *EOO) MutateRA_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(70, n)
}

/// Declination in degrees. Required metric reporting field for EO observations.
func (rcv *EOO) DECLINATION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Declination in degrees. Required metric reporting field for EO observations.
func (rcv *EOO) MutateDECLINATION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(72, n)
}

/// Line of sight declination rate of change, in degrees/sec.
func (rcv *EOO) DECLINATION_RATE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Line of sight declination rate of change, in degrees/sec.
func (rcv *EOO) MutateDECLINATION_RATE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(74, n)
}

/// One sigma uncertainty in the line of sight declination angle, in degrees.
func (rcv *EOO) DECLINATION_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line of sight declination angle, in degrees.
func (rcv *EOO) MutateDECLINATION_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(76, n)
}

/// Sensor line of sight declination angle bias in degrees.
func (rcv *EOO) DECLINATION_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor line of sight declination angle bias in degrees.
func (rcv *EOO) MutateDECLINATION_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(78, n)
}

/// X-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) LOSX() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// X-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) MutateLOSX(n float32) bool {
	return rcv._tab.MutateFloat32Slot(80, n)
}

/// Y-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) LOSY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Y-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) MutateLOSY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(82, n)
}

/// Z-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) LOSZ() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Z-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
func (rcv *EOO) MutateLOSZ(n float32) bool {
	return rcv._tab.MutateFloat32Slot(84, n)
}

/// One sigma uncertainty in the line-of-sight direction vector components.
func (rcv *EOO) LOS_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// One sigma uncertainty in the line-of-sight direction vector components.
func (rcv *EOO) MutateLOS_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(86, n)
}

/// X-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) LOSXVEL() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// X-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) MutateLOSXVEL(n float32) bool {
	return rcv._tab.MutateFloat32Slot(88, n)
}

/// Y-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) LOSYVEL() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(90))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Y-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) MutateLOSYVEL(n float32) bool {
	return rcv._tab.MutateFloat32Slot(90, n)
}

/// Z-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) LOSZVEL() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(92))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Z-component of the velocity vector along the line of sight, in km/s.
func (rcv *EOO) MutateLOSZVEL(n float32) bool {
	return rcv._tab.MutateFloat32Slot(92, n)
}

/// WGS-84 latitude in decimal degrees at the time of the observation.
func (rcv *EOO) SENLAT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(94))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// WGS-84 latitude in decimal degrees at the time of the observation.
func (rcv *EOO) MutateSENLAT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(94, n)
}

/// WGS-84 longitude in decimal degrees at the time of the observation.
func (rcv *EOO) SENLON() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(96))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// WGS-84 longitude in decimal degrees at the time of the observation.
func (rcv *EOO) MutateSENLON(n float32) bool {
	return rcv._tab.MutateFloat32Slot(96, n)
}

/// Sensor height in km relative to the WGS-84 ellipsoid at the time of the observation.
func (rcv *EOO) SENALT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor height in km relative to the WGS-84 ellipsoid at the time of the observation.
func (rcv *EOO) MutateSENALT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(98, n)
}

/// Cartesian X position in km at the time of the observation.
func (rcv *EOO) SENX() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(100))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Cartesian X position in km at the time of the observation.
func (rcv *EOO) MutateSENX(n float32) bool {
	return rcv._tab.MutateFloat32Slot(100, n)
}

/// Cartesian Y position in km at the time of the observation.
func (rcv *EOO) SENY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Cartesian Y position in km at the time of the observation.
func (rcv *EOO) MutateSENY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(102, n)
}

/// Cartesian Z position in km at the time of the observation.
func (rcv *EOO) SENZ() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Cartesian Z position in km at the time of the observation.
func (rcv *EOO) MutateSENZ(n float32) bool {
	return rcv._tab.MutateFloat32Slot(104, n)
}

/// Total number of satellites in the field of view.
func (rcv *EOO) FOV_COUNT() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Total number of satellites in the field of view.
func (rcv *EOO) MutateFOV_COUNT(n int32) bool {
	return rcv._tab.MutateInt32Slot(106, n)
}

/// Number of uncorrelated satellites in the field of view (JCO).
func (rcv *EOO) FOV_COUNT_UCTS() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of uncorrelated satellites in the field of view (JCO).
func (rcv *EOO) MutateFOV_COUNT_UCTS(n int32) bool {
	return rcv._tab.MutateInt32Slot(108, n)
}

/// Image exposure duration in seconds. For observations performed using frame stacking or synthetic tracking methods, 
/// the exposure duration should be the total integration time. This field is highly recommended / required if the 
/// observations are going to be used for photometric processing.
func (rcv *EOO) EXP_DURATION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Image exposure duration in seconds. For observations performed using frame stacking or synthetic tracking methods, 
/// the exposure duration should be the total integration time. This field is highly recommended / required if the 
/// observations are going to be used for photometric processing.
func (rcv *EOO) MutateEXP_DURATION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(110, n)
}

/// Formula: 2.5 * log_10 (zero_mag_counts / EXP_DURATION).
func (rcv *EOO) ZEROPTD() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Formula: 2.5 * log_10 (zero_mag_counts / EXP_DURATION).
func (rcv *EOO) MutateZEROPTD(n float32) bool {
	return rcv._tab.MutateFloat32Slot(112, n)
}

/// Net object signature = counts / EXP_DURATION.
func (rcv *EOO) NET_OBJ_SIG() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Net object signature = counts / EXP_DURATION.
func (rcv *EOO) MutateNET_OBJ_SIG(n float32) bool {
	return rcv._tab.MutateFloat32Slot(114, n)
}

/// Net object signature uncertainty = counts uncertainty / EXP_DURATION.
func (rcv *EOO) NET_OBJ_SIG_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Net object signature uncertainty = counts uncertainty / EXP_DURATION.
func (rcv *EOO) MutateNET_OBJ_SIG_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(116, n)
}

/// Measure of observed brightness calibrated against the Gaia G-band.
func (rcv *EOO) MAG() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Measure of observed brightness calibrated against the Gaia G-band.
func (rcv *EOO) MutateMAG(n float32) bool {
	return rcv._tab.MutateFloat32Slot(118, n)
}

/// Uncertainty of the observed brightness.
func (rcv *EOO) MAG_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(120))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Uncertainty of the observed brightness.
func (rcv *EOO) MutateMAG_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(120, n)
}

/// [Definition needed].
func (rcv *EOO) MAG_NORM_RANGE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(122))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// [Definition needed].
func (rcv *EOO) MutateMAG_NORM_RANGE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(122, n)
}

/// Computed estimate of the latitude, positive degrees north. It should be computed based on the assumed slant range 
/// and corresponding viewing geometry. It must NOT be computed from the orbit state.
func (rcv *EOO) GEOLAT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(124))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Computed estimate of the latitude, positive degrees north. It should be computed based on the assumed slant range 
/// and corresponding viewing geometry. It must NOT be computed from the orbit state.
func (rcv *EOO) MutateGEOLAT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(124, n)
}

/// Computed estimate of the longitude as +/- 180 degrees east. It should be computed based on the assumed slant range 
/// and viewing geometry. It must NOT be computed from the orbit state.
func (rcv *EOO) GEOLON() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(126))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Computed estimate of the longitude as +/- 180 degrees east. It should be computed based on the assumed slant range 
/// and viewing geometry. It must NOT be computed from the orbit state.
func (rcv *EOO) MutateGEOLON(n float32) bool {
	return rcv._tab.MutateFloat32Slot(126, n)
}

/// Computed estimate of satellite altitude in km at the reported location. It must NOT be computed from the orbit state.
func (rcv *EOO) GEOALT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(128))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Computed estimate of satellite altitude in km at the reported location. It must NOT be computed from the orbit state.
func (rcv *EOO) MutateGEOALT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(128, n)
}

/// Computed estimate of the slant range in km. It must NOT be computed from the orbit state.
func (rcv *EOO) GEORANGE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(130))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Computed estimate of the slant range in km. It must NOT be computed from the orbit state.
func (rcv *EOO) MutateGEORANGE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(130, n)
}

/// Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently 
/// empty part of the night sky.
func (rcv *EOO) SKY_BKGRND() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(132))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently 
/// empty part of the night sky.
func (rcv *EOO) MutateSKY_BKGRND(n float32) bool {
	return rcv._tab.MutateFloat32Slot(132, n)
}

/// Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass 
/// to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general, 
/// describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical 
/// object and the observer.
func (rcv *EOO) PRIMARY_EXTINCTION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(134))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass 
/// to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general, 
/// describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical 
/// object and the observer.
func (rcv *EOO) MutatePRIMARY_EXTINCTION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(134, n)
}

/// Primary Extinction Coefficient Uncertainty, in Magnitudes.
func (rcv *EOO) PRIMARY_EXTINCTION_UNC() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(136))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Primary Extinction Coefficient Uncertainty, in Magnitudes.
func (rcv *EOO) MutatePRIMARY_EXTINCTION_UNC(n float32) bool {
	return rcv._tab.MutateFloat32Slot(136, n)
}

/// The angle, in degrees, between the target-to-observer vector and the target-to-sun vector. Recommend using the 
/// calculation listed in the EOSSA documentation, pg 106 of the EOSSA spec.
func (rcv *EOO) SOLAR_PHASE_ANGLE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(138))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The angle, in degrees, between the target-to-observer vector and the target-to-sun vector. Recommend using the 
/// calculation listed in the EOSSA documentation, pg 106 of the EOSSA spec.
func (rcv *EOO) MutateSOLAR_PHASE_ANGLE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(138, n)
}

/// The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector 
/// onto the equatorial plane. The convention used is negative when closing (i.e., before the opposition) 
/// and positive when opening (after the opposition).
func (rcv *EOO) SOLAR_EQ_PHASE_ANGLE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(140))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector 
/// onto the equatorial plane. The convention used is negative when closing (i.e., before the opposition) 
/// and positive when opening (after the opposition).
func (rcv *EOO) MutateSOLAR_EQ_PHASE_ANGLE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(140, n)
}

/// Angle from the sun to the equatorial plane.
func (rcv *EOO) SOLAR_DEC_ANGLE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(142))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Angle from the sun to the equatorial plane.
func (rcv *EOO) MutateSOLAR_DEC_ANGLE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(142, n)
}

/// Shutter delay in seconds.
func (rcv *EOO) SHUTTER_DELAY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(144))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Shutter delay in seconds.
func (rcv *EOO) MutateSHUTTER_DELAY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(144, n)
}

/// Sensor timing bias in seconds.
func (rcv *EOO) TIMING_BIAS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(146))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor timing bias in seconds.
func (rcv *EOO) MutateTIMING_BIAS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(146, n)
}

/// Optional URI location in the document repository of the raw file parsed by the system to produce this record. 
func (rcv *EOO) RAW_FILE_URI() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(148))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional URI location in the document repository of the raw file parsed by the system to produce this record. 
/// Intensity of the target for IR observations, in kw/sr/em.
func (rcv *EOO) INTENSITY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(150))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Intensity of the target for IR observations, in kw/sr/em.
func (rcv *EOO) MutateINTENSITY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(150, n)
}

/// Background intensity for IR observations, in kw/sr/um.
func (rcv *EOO) BG_INTENSITY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(152))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Background intensity for IR observations, in kw/sr/um.
func (rcv *EOO) MutateBG_INTENSITY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(152, n)
}

/// Optional source-provided and searchable metadata or descriptor of the data.
func (rcv *EOO) DESCRIPTOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(154))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional source-provided and searchable metadata or descriptor of the data.
/// Source of the data.
func (rcv *EOO) SOURCE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(156))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Source of the data.
/// Originating system or organization which produced the data, if different from the source.
/// The origin may be different than the source if the source was a mediating system which forwarded 
/// the data on behalf of the origin system. If null, the source may be assumed to be the origin.
func (rcv *EOO) ORIGIN() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(158))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Originating system or organization which produced the data, if different from the source.
/// The origin may be different than the source if the source was a mediating system which forwarded 
/// the data on behalf of the origin system. If null, the source may be assumed to be the origin.
/// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST.
func (rcv *EOO) DATA_MODE() DataMode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(160))
	if o != 0 {
		return DataMode(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST.
func (rcv *EOO) MutateDATA_MODE(n DataMode) bool {
	return rcv._tab.MutateInt8Slot(160, int8(n))
}

/// Time the row was created in the database, auto-populated by the system.
func (rcv *EOO) CREATED_AT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(162))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time the row was created in the database, auto-populated by the system.
/// Application user who created the row in the database, auto-populated by the system.
func (rcv *EOO) CREATED_BY() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(164))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Application user who created the row in the database, auto-populated by the system.
/// EO observations are assumed to be topocentric J2000 coordinates ('J2000') as defined by the IAU, unless otherwise specified.
func (rcv *EOO) REFERENCE_FRAME() refFrame {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(166))
	if o != 0 {
		return refFrame(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// EO observations are assumed to be topocentric J2000 coordinates ('J2000') as defined by the IAU, unless otherwise specified.
func (rcv *EOO) MutateREFERENCE_FRAME(n refFrame) bool {
	return rcv._tab.MutateInt8Slot(166, int8(n))
}

/// The sensor reference frame is assumed to be the International Terrestrial Reference Frame (ITRF), 
/// unless otherwise specified. (ITRF is equivalent to Earth-Centered Earth-Fixed (ECEF) for this purpose). 
/// Lat / long / height values should be reported using the WGS-84 ellipsoid, where applicable.
func (rcv *EOO) SEN_REFERENCE_FRAME() refFrame {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(168))
	if o != 0 {
		return refFrame(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// The sensor reference frame is assumed to be the International Terrestrial Reference Frame (ITRF), 
/// unless otherwise specified. (ITRF is equivalent to Earth-Centered Earth-Fixed (ECEF) for this purpose). 
/// Lat / long / height values should be reported using the WGS-84 ellipsoid, where applicable.
func (rcv *EOO) MutateSEN_REFERENCE_FRAME(n refFrame) bool {
	return rcv._tab.MutateInt8Slot(168, int8(n))
}

/// Boolean indicating that the target object was in umbral eclipse at the time of this observation.
func (rcv *EOO) UMBRA() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(170))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Boolean indicating that the target object was in umbral eclipse at the time of this observation.
func (rcv *EOO) MutateUMBRA(n bool) bool {
	return rcv._tab.MutateBoolSlot(170, n)
}

/// Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
/// This field is highly recommended if the observations will be used for photometric processing.
func (rcv *EOO) PENUMBRA() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(172))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
/// This field is highly recommended if the observations will be used for photometric processing.
func (rcv *EOO) MutatePENUMBRA(n bool) bool {
	return rcv._tab.MutateBoolSlot(172, n)
}

/// The originating source network on which this record was created, auto-populated by the system.
func (rcv *EOO) ORIG_NETWORK() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(174))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The originating source network on which this record was created, auto-populated by the system.
/// The source from which this record was received.
func (rcv *EOO) SOURCE_DL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(176))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The source from which this record was received.
/// Device Type
func (rcv *EOO) TYPE() DeviceType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(178))
	if o != 0 {
		return DeviceType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Device Type
func (rcv *EOO) MutateTYPE(n DeviceType) bool {
	return rcv._tab.MutateInt8Slot(178, int8(n))
}

/// True if measured, false if computed. Required if azimuth is reported.
func (rcv *EOO) AZIMUTH_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(180))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if azimuth is reported.
func (rcv *EOO) MutateAZIMUTH_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(180, n)
}

/// True if measured, false if computed. Required if elevation is reported.
func (rcv *EOO) ELEVATION_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(182))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if elevation is reported.
func (rcv *EOO) MutateELEVATION_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(182, n)
}

/// True if measured, false if computed. Required if range is reported.
func (rcv *EOO) RANGE_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(184))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if range is reported.
func (rcv *EOO) MutateRANGE_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(184, n)
}

/// True if measured, false if computed. Required if range-rate is reported.
func (rcv *EOO) RANGERATE_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(186))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if range-rate is reported.
func (rcv *EOO) MutateRANGERATE_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(186, n)
}

/// True if measured, false if computed. Required if right ascension is reported.
func (rcv *EOO) RA_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(188))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if right ascension is reported.
func (rcv *EOO) MutateRA_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(188, n)
}

/// True if measured, false if computed. Required if declination is reported.
func (rcv *EOO) DECLINATION_MEASURED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(190))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if measured, false if computed. Required if declination is reported.
func (rcv *EOO) MutateDECLINATION_MEASURED(n bool) bool {
	return rcv._tab.MutateBoolSlot(190, n)
}

/// National Imagery Interpretability Rating Scale (NIIRS). Ranging from 0 (lowest) to 9 (highest).
func (rcv *EOO) NIIRS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(192))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// National Imagery Interpretability Rating Scale (NIIRS). Ranging from 0 (lowest) to 9 (highest).
func (rcv *EOO) MutateNIIRS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(192, n)
}

/// Ground sample distance in meters per pixel.
func (rcv *EOO) METERS_PER_PIXEL() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(194))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Ground sample distance in meters per pixel.
func (rcv *EOO) MutateMETERS_PER_PIXEL(n float32) bool {
	return rcv._tab.MutateFloat32Slot(194, n)
}

/// Signal-to-noise ratio of the image. Higher values indicate cleaner imagery.
func (rcv *EOO) IMAGE_SNR() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(196))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Signal-to-noise ratio of the image. Higher values indicate cleaner imagery.
func (rcv *EOO) MutateIMAGE_SNR(n float32) bool {
	return rcv._tab.MutateFloat32Slot(196, n)
}

/// Bit depth of the image (e.g., 8, 12, 16).
func (rcv *EOO) IMAGE_BIT_DEPTH() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(198))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Bit depth of the image (e.g., 8, 12, 16).
func (rcv *EOO) MutateIMAGE_BIT_DEPTH(n int32) bool {
	return rcv._tab.MutateInt32Slot(198, n)
}

/// Width of the image in pixels.
func (rcv *EOO) IMAGE_WIDTH() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(200))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Width of the image in pixels.
func (rcv *EOO) MutateIMAGE_WIDTH(n int32) bool {
	return rcv._tab.MutateInt32Slot(200, n)
}

/// Height of the image in pixels.
func (rcv *EOO) IMAGE_HEIGHT() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(202))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Height of the image in pixels.
func (rcv *EOO) MutateIMAGE_HEIGHT(n int32) bool {
	return rcv._tab.MutateInt32Slot(202, n)
}

/// Compression type used for the image, e.g., "JPEG", "PNG", "RAW", etc.
func (rcv *EOO) IMAGE_COMPRESSION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(204))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Compression type used for the image, e.g., "JPEG", "PNG", "RAW", etc.
/// Compression ratio used (original size / compressed size), if applicable.
func (rcv *EOO) IMAGE_COMPRESSION_RATIO() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(206))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Compression ratio used (original size / compressed size), if applicable.
func (rcv *EOO) MutateIMAGE_COMPRESSION_RATIO(n float32) bool {
	return rcv._tab.MutateFloat32Slot(206, n)
}

/// URI to the processed image used for this observation.
func (rcv *EOO) PROCESSED_IMAGE_URI() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(208))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// URI to the processed image used for this observation.
/// Flag indicating whether the image was auto-enhanced (e.g., contrast stretch, denoise).
func (rcv *EOO) IMAGE_AUTO_ENHANCED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(210))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Flag indicating whether the image was auto-enhanced (e.g., contrast stretch, denoise).
func (rcv *EOO) MutateIMAGE_AUTO_ENHANCED(n bool) bool {
	return rcv._tab.MutateBoolSlot(210, n)
}

/// True if the observation was taken with multiple frames stacked into one image.
func (rcv *EOO) MULTI_FRAME_STACKED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(212))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if the observation was taken with multiple frames stacked into one image.
func (rcv *EOO) MutateMULTI_FRAME_STACKED(n bool) bool {
	return rcv._tab.MutateBoolSlot(212, n)
}

/// True if synthetic tracking was used to create the image.
func (rcv *EOO) SYNTHETIC_TRACKING_USED() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(214))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// True if synthetic tracking was used to create the image.
func (rcv *EOO) MutateSYNTHETIC_TRACKING_USED(n bool) bool {
	return rcv._tab.MutateBoolSlot(214, n)
}

/// Sharpness metric of the image based on the Tenengrad method or variance of Laplacian. Higher values indicate sharper images.
func (rcv *EOO) IMAGE_SHARPNESS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(216))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sharpness metric of the image based on the Tenengrad method or variance of Laplacian. Higher values indicate sharper images.
func (rcv *EOO) MutateIMAGE_SHARPNESS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(216, n)
}

/// Noise level of the image, estimated via pixel intensity variance in background regions.
func (rcv *EOO) IMAGE_NOISE_STDDEV() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(218))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Noise level of the image, estimated via pixel intensity variance in background regions.
func (rcv *EOO) MutateIMAGE_NOISE_STDDEV(n float32) bool {
	return rcv._tab.MutateFloat32Slot(218, n)
}

/// Contrast metric of the image, such as Michelson contrast or RMS contrast.
func (rcv *EOO) IMAGE_CONTRAST() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(220))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Contrast metric of the image, such as Michelson contrast or RMS contrast.
func (rcv *EOO) MutateIMAGE_CONTRAST(n float32) bool {
	return rcv._tab.MutateFloat32Slot(220, n)
}

/// Dynamic range of the image (max pixel value / min pixel value), indicating tonal spread.
func (rcv *EOO) IMAGE_DYNAMIC_RANGE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(222))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Dynamic range of the image (max pixel value / min pixel value), indicating tonal spread.
func (rcv *EOO) MutateIMAGE_DYNAMIC_RANGE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(222, n)
}

/// Entropy of the image, representing the richness of information content. Higher entropy suggests higher texture detail.
func (rcv *EOO) IMAGE_ENTROPY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(224))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Entropy of the image, representing the richness of information content. Higher entropy suggests higher texture detail.
func (rcv *EOO) MutateIMAGE_ENTROPY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(224, n)
}

/// Background uniformity metric (e.g., mean gradient in background areas). Lower values indicate more uniform background.
func (rcv *EOO) BACKGROUND_UNIFORMITY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(226))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Background uniformity metric (e.g., mean gradient in background areas). Lower values indicate more uniform background.
func (rcv *EOO) MutateBACKGROUND_UNIFORMITY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(226, n)
}

/// Mean background level, computed from non-object regions in pixel units.
func (rcv *EOO) BACKGROUND_MEAN_LEVEL() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(228))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Mean background level, computed from non-object regions in pixel units.
func (rcv *EOO) MutateBACKGROUND_MEAN_LEVEL(n float32) bool {
	return rcv._tab.MutateFloat32Slot(228, n)
}

/// Percentage of saturated pixels in the image. Indicates overexposure when high.
func (rcv *EOO) SATURATED_PIXEL_PERCENT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(230))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Percentage of saturated pixels in the image. Indicates overexposure when high.
func (rcv *EOO) MutateSATURATED_PIXEL_PERCENT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(230, n)
}

/// Percentage of dead or zero-value pixels in the image. Indicates sensor defects or underexposure.
func (rcv *EOO) DEAD_PIXEL_PERCENT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(232))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Percentage of dead or zero-value pixels in the image. Indicates sensor defects or underexposure.
func (rcv *EOO) MutateDEAD_PIXEL_PERCENT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(232, n)
}

/// Estimated Point Spread Function (PSF) Full Width at Half Maximum (FWHM) in pixels. Indicates image blur or focus.
func (rcv *EOO) PSF_FWHM() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(234))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Estimated Point Spread Function (PSF) Full Width at Half Maximum (FWHM) in pixels. Indicates image blur or focus.
func (rcv *EOO) MutatePSF_FWHM(n float32) bool {
	return rcv._tab.MutateFloat32Slot(234, n)
}

/// Estimated percentage of cloud cover in the image. Derived using cloud detection algorithms such as Fmask or machine learning classifiers.
func (rcv *EOO) CLOUD_COVER_PERCENT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(236))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Estimated percentage of cloud cover in the image. Derived using cloud detection algorithms such as Fmask or machine learning classifiers.
func (rcv *EOO) MutateCLOUD_COVER_PERCENT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(236, n)
}

/// Confidence score of the cloud detection result, from 0 (low confidence) to 1 (high confidence).
func (rcv *EOO) CLOUD_DETECTION_CONFIDENCE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(238))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Confidence score of the cloud detection result, from 0 (low confidence) to 1 (high confidence).
func (rcv *EOO) MutateCLOUD_DETECTION_CONFIDENCE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(238, n)
}

/// Estimated percentage of the image obscured by haze or atmospheric scattering effects.
func (rcv *EOO) HAZE_PERCENT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(240))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Estimated percentage of the image obscured by haze or atmospheric scattering effects.
func (rcv *EOO) MutateHAZE_PERCENT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(240, n)
}

/// Estimated aerosol optical thickness (AOT) at 550 nm, indicating particulate matter in the atmosphere affecting image clarity.
func (rcv *EOO) AEROSOL_OPTICAL_THICKNESS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(242))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Estimated aerosol optical thickness (AOT) at 550 nm, indicating particulate matter in the atmosphere affecting image clarity.
func (rcv *EOO) MutateAEROSOL_OPTICAL_THICKNESS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(242, n)
}

/// Estimated water vapor content (e.g., total column precipitable water) at the time of imaging, in mm.
func (rcv *EOO) WATER_VAPOR_CONTENT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(244))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Estimated water vapor content (e.g., total column precipitable water) at the time of imaging, in mm.
func (rcv *EOO) MutateWATER_VAPOR_CONTENT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(244, n)
}

/// Sun elevation angle at the time of image capture, in degrees above the horizon.
func (rcv *EOO) SUN_ELEVATION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(246))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sun elevation angle at the time of image capture, in degrees above the horizon.
func (rcv *EOO) MutateSUN_ELEVATION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(246, n)
}

/// Sun azimuth angle at the time of image capture, in degrees from true north.
func (rcv *EOO) SUN_AZIMUTH() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(248))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sun azimuth angle at the time of image capture, in degrees from true north.
func (rcv *EOO) MutateSUN_AZIMUTH(n float32) bool {
	return rcv._tab.MutateFloat32Slot(248, n)
}

/// View zenith angle (sensor line-of-sight angle from nadir), in degrees.
func (rcv *EOO) VIEW_ZENITH_ANGLE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(250))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// View zenith angle (sensor line-of-sight angle from nadir), in degrees.
func (rcv *EOO) MutateVIEW_ZENITH_ANGLE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(250, n)
}

/// View azimuth angle (direction of sensor relative to north), in degrees.
func (rcv *EOO) VIEW_AZIMUTH_ANGLE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(252))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// View azimuth angle (direction of sensor relative to north), in degrees.
func (rcv *EOO) MutateVIEW_AZIMUTH_ANGLE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(252, n)
}

/// Off-nadir angle of the sensor at the time of image capture, in degrees.
func (rcv *EOO) OFF_NADIR_ANGLE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(254))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Off-nadir angle of the sensor at the time of image capture, in degrees.
func (rcv *EOO) MutateOFF_NADIR_ANGLE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(254, n)
}

/// Ground coverage width of the image swath in kilometers.
func (rcv *EOO) SWATH_WIDTH_KM() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(256))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Ground coverage width of the image swath in kilometers.
func (rcv *EOO) MutateSWATH_WIDTH_KM(n float32) bool {
	return rcv._tab.MutateFloat32Slot(256, n)
}

/// Mean terrain elevation in the image footprint, in meters above sea level.
func (rcv *EOO) MEAN_TERRAIN_ELEVATION() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(258))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Mean terrain elevation in the image footprint, in meters above sea level.
func (rcv *EOO) MutateMEAN_TERRAIN_ELEVATION(n float32) bool {
	return rcv._tab.MutateFloat32Slot(258, n)
}

/// Standard deviation of terrain elevation in the image footprint, in meters.
func (rcv *EOO) TERRAIN_ELEVATION_STDDEV() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(260))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Standard deviation of terrain elevation in the image footprint, in meters.
func (rcv *EOO) MutateTERRAIN_ELEVATION_STDDEV(n float32) bool {
	return rcv._tab.MutateFloat32Slot(260, n)
}

/// Percentage of the image affected by shadows, derived via topographic or object shadow detection.
func (rcv *EOO) SHADOW_COVER_PERCENT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(262))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Percentage of the image affected by shadows, derived via topographic or object shadow detection.
func (rcv *EOO) MutateSHADOW_COVER_PERCENT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(262, n)
}

/// Flag indicating whether sunglint is present in the image (true if high reflectance from water surface due to sun geometry).
func (rcv *EOO) SUNGLINT_PRESENT() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(264))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Flag indicating whether sunglint is present in the image (true if high reflectance from water surface due to sun geometry).
func (rcv *EOO) MutateSUNGLINT_PRESENT(n bool) bool {
	return rcv._tab.MutateBoolSlot(264, n)
}

/// Percentage of image affected by sunglint.
func (rcv *EOO) SUNGLINT_PERCENT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(266))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Percentage of image affected by sunglint.
func (rcv *EOO) MutateSUNGLINT_PERCENT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(266, n)
}

/// Estimated percentage of snow or ice coverage in the image footprint.
func (rcv *EOO) SNOW_ICE_COVER_PERCENT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(268))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Estimated percentage of snow or ice coverage in the image footprint.
func (rcv *EOO) MutateSNOW_ICE_COVER_PERCENT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(268, n)
}

/// Total area covered by valid data (non-masked, usable imagery) in square kilometers.
func (rcv *EOO) VALID_DATA_AREA_KM2() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(270))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Total area covered by valid data (non-masked, usable imagery) in square kilometers.
func (rcv *EOO) MutateVALID_DATA_AREA_KM2(n float32) bool {
	return rcv._tab.MutateFloat32Slot(270, n)
}

func EOOStart(builder *flatbuffers.Builder) {
	builder.StartObject(134)
}
func EOOAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func EOOAddCLASSIFICATION(builder *flatbuffers.Builder, CLASSIFICATION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(CLASSIFICATION), 0)
}
func EOOAddOB_TIME(builder *flatbuffers.Builder, OB_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(OB_TIME), 0)
}
func EOOAddCORR_QUALITY(builder *flatbuffers.Builder, CORR_QUALITY float32) {
	builder.PrependFloat32Slot(3, CORR_QUALITY, 0.0)
}
func EOOAddID_ON_ORBIT(builder *flatbuffers.Builder, ID_ON_ORBIT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(ID_ON_ORBIT), 0)
}
func EOOAddSENSOR_ID(builder *flatbuffers.Builder, SENSOR_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(SENSOR_ID), 0)
}
func EOOAddCOLLECT_METHOD(builder *flatbuffers.Builder, COLLECT_METHOD CollectMethod) {
	builder.PrependInt8Slot(6, int8(COLLECT_METHOD), 0)
}
func EOOAddNORAD_CAT_ID(builder *flatbuffers.Builder, NORAD_CAT_ID int32) {
	builder.PrependInt32Slot(7, NORAD_CAT_ID, 0)
}
func EOOAddTASK_ID(builder *flatbuffers.Builder, TASK_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(TASK_ID), 0)
}
func EOOAddTRANSACTION_ID(builder *flatbuffers.Builder, TRANSACTION_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(TRANSACTION_ID), 0)
}
func EOOAddIMAGE_SET_ID(builder *flatbuffers.Builder, IMAGE_SET_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(IMAGE_SET_ID), 0)
}
func EOOAddIMAGE_SET_LENGTH(builder *flatbuffers.Builder, IMAGE_SET_LENGTH int32) {
	builder.PrependInt32Slot(11, IMAGE_SET_LENGTH, 0)
}
func EOOAddSEQUENCE_ID(builder *flatbuffers.Builder, SEQUENCE_ID int32) {
	builder.PrependInt32Slot(12, SEQUENCE_ID, 0)
}
func EOOAddOB_POSITION(builder *flatbuffers.Builder, OB_POSITION ObservationPosition) {
	builder.PrependInt8Slot(13, int8(OB_POSITION), 0)
}
func EOOAddORIG_OBJECT_ID(builder *flatbuffers.Builder, ORIG_OBJECT_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(ORIG_OBJECT_ID), 0)
}
func EOOAddORIG_SENSOR_ID(builder *flatbuffers.Builder, ORIG_SENSOR_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(ORIG_SENSOR_ID), 0)
}
func EOOAddUCT(builder *flatbuffers.Builder, UCT bool) {
	builder.PrependBoolSlot(16, UCT, false)
}
func EOOAddAZIMUTH(builder *flatbuffers.Builder, AZIMUTH float32) {
	builder.PrependFloat32Slot(17, AZIMUTH, 0.0)
}
func EOOAddAZIMUTH_UNC(builder *flatbuffers.Builder, AZIMUTH_UNC float32) {
	builder.PrependFloat32Slot(18, AZIMUTH_UNC, 0.0)
}
func EOOAddAZIMUTH_BIAS(builder *flatbuffers.Builder, AZIMUTH_BIAS float32) {
	builder.PrependFloat32Slot(19, AZIMUTH_BIAS, 0.0)
}
func EOOAddAZIMUTH_RATE(builder *flatbuffers.Builder, AZIMUTH_RATE float32) {
	builder.PrependFloat32Slot(20, AZIMUTH_RATE, 0.0)
}
func EOOAddELEVATION(builder *flatbuffers.Builder, ELEVATION float32) {
	builder.PrependFloat32Slot(21, ELEVATION, 0.0)
}
func EOOAddELEVATION_UNC(builder *flatbuffers.Builder, ELEVATION_UNC float32) {
	builder.PrependFloat32Slot(22, ELEVATION_UNC, 0.0)
}
func EOOAddELEVATION_BIAS(builder *flatbuffers.Builder, ELEVATION_BIAS float32) {
	builder.PrependFloat32Slot(23, ELEVATION_BIAS, 0.0)
}
func EOOAddELEVATION_RATE(builder *flatbuffers.Builder, ELEVATION_RATE float32) {
	builder.PrependFloat32Slot(24, ELEVATION_RATE, 0.0)
}
func EOOAddRANGE(builder *flatbuffers.Builder, RANGE float32) {
	builder.PrependFloat32Slot(25, RANGE, 0.0)
}
func EOOAddRANGE_UNC(builder *flatbuffers.Builder, RANGE_UNC float32) {
	builder.PrependFloat32Slot(26, RANGE_UNC, 0.0)
}
func EOOAddRANGE_BIAS(builder *flatbuffers.Builder, RANGE_BIAS float32) {
	builder.PrependFloat32Slot(27, RANGE_BIAS, 0.0)
}
func EOOAddRANGE_RATE(builder *flatbuffers.Builder, RANGE_RATE float32) {
	builder.PrependFloat32Slot(28, RANGE_RATE, 0.0)
}
func EOOAddRANGE_RATE_UNC(builder *flatbuffers.Builder, RANGE_RATE_UNC float32) {
	builder.PrependFloat32Slot(29, RANGE_RATE_UNC, 0.0)
}
func EOOAddRA(builder *flatbuffers.Builder, RA float32) {
	builder.PrependFloat32Slot(30, RA, 0.0)
}
func EOOAddRA_RATE(builder *flatbuffers.Builder, RA_RATE float32) {
	builder.PrependFloat32Slot(31, RA_RATE, 0.0)
}
func EOOAddRA_UNC(builder *flatbuffers.Builder, RA_UNC float32) {
	builder.PrependFloat32Slot(32, RA_UNC, 0.0)
}
func EOOAddRA_BIAS(builder *flatbuffers.Builder, RA_BIAS float32) {
	builder.PrependFloat32Slot(33, RA_BIAS, 0.0)
}
func EOOAddDECLINATION(builder *flatbuffers.Builder, DECLINATION float32) {
	builder.PrependFloat32Slot(34, DECLINATION, 0.0)
}
func EOOAddDECLINATION_RATE(builder *flatbuffers.Builder, DECLINATION_RATE float32) {
	builder.PrependFloat32Slot(35, DECLINATION_RATE, 0.0)
}
func EOOAddDECLINATION_UNC(builder *flatbuffers.Builder, DECLINATION_UNC float32) {
	builder.PrependFloat32Slot(36, DECLINATION_UNC, 0.0)
}
func EOOAddDECLINATION_BIAS(builder *flatbuffers.Builder, DECLINATION_BIAS float32) {
	builder.PrependFloat32Slot(37, DECLINATION_BIAS, 0.0)
}
func EOOAddLOSX(builder *flatbuffers.Builder, LOSX float32) {
	builder.PrependFloat32Slot(38, LOSX, 0.0)
}
func EOOAddLOSY(builder *flatbuffers.Builder, LOSY float32) {
	builder.PrependFloat32Slot(39, LOSY, 0.0)
}
func EOOAddLOSZ(builder *flatbuffers.Builder, LOSZ float32) {
	builder.PrependFloat32Slot(40, LOSZ, 0.0)
}
func EOOAddLOS_UNC(builder *flatbuffers.Builder, LOS_UNC float32) {
	builder.PrependFloat32Slot(41, LOS_UNC, 0.0)
}
func EOOAddLOSXVEL(builder *flatbuffers.Builder, LOSXVEL float32) {
	builder.PrependFloat32Slot(42, LOSXVEL, 0.0)
}
func EOOAddLOSYVEL(builder *flatbuffers.Builder, LOSYVEL float32) {
	builder.PrependFloat32Slot(43, LOSYVEL, 0.0)
}
func EOOAddLOSZVEL(builder *flatbuffers.Builder, LOSZVEL float32) {
	builder.PrependFloat32Slot(44, LOSZVEL, 0.0)
}
func EOOAddSENLAT(builder *flatbuffers.Builder, SENLAT float32) {
	builder.PrependFloat32Slot(45, SENLAT, 0.0)
}
func EOOAddSENLON(builder *flatbuffers.Builder, SENLON float32) {
	builder.PrependFloat32Slot(46, SENLON, 0.0)
}
func EOOAddSENALT(builder *flatbuffers.Builder, SENALT float32) {
	builder.PrependFloat32Slot(47, SENALT, 0.0)
}
func EOOAddSENX(builder *flatbuffers.Builder, SENX float32) {
	builder.PrependFloat32Slot(48, SENX, 0.0)
}
func EOOAddSENY(builder *flatbuffers.Builder, SENY float32) {
	builder.PrependFloat32Slot(49, SENY, 0.0)
}
func EOOAddSENZ(builder *flatbuffers.Builder, SENZ float32) {
	builder.PrependFloat32Slot(50, SENZ, 0.0)
}
func EOOAddFOV_COUNT(builder *flatbuffers.Builder, FOV_COUNT int32) {
	builder.PrependInt32Slot(51, FOV_COUNT, 0)
}
func EOOAddFOV_COUNT_UCTS(builder *flatbuffers.Builder, FOV_COUNT_UCTS int32) {
	builder.PrependInt32Slot(52, FOV_COUNT_UCTS, 0)
}
func EOOAddEXP_DURATION(builder *flatbuffers.Builder, EXP_DURATION float32) {
	builder.PrependFloat32Slot(53, EXP_DURATION, 0.0)
}
func EOOAddZEROPTD(builder *flatbuffers.Builder, ZEROPTD float32) {
	builder.PrependFloat32Slot(54, ZEROPTD, 0.0)
}
func EOOAddNET_OBJ_SIG(builder *flatbuffers.Builder, NET_OBJ_SIG float32) {
	builder.PrependFloat32Slot(55, NET_OBJ_SIG, 0.0)
}
func EOOAddNET_OBJ_SIG_UNC(builder *flatbuffers.Builder, NET_OBJ_SIG_UNC float32) {
	builder.PrependFloat32Slot(56, NET_OBJ_SIG_UNC, 0.0)
}
func EOOAddMAG(builder *flatbuffers.Builder, MAG float32) {
	builder.PrependFloat32Slot(57, MAG, 0.0)
}
func EOOAddMAG_UNC(builder *flatbuffers.Builder, MAG_UNC float32) {
	builder.PrependFloat32Slot(58, MAG_UNC, 0.0)
}
func EOOAddMAG_NORM_RANGE(builder *flatbuffers.Builder, MAG_NORM_RANGE float32) {
	builder.PrependFloat32Slot(59, MAG_NORM_RANGE, 0.0)
}
func EOOAddGEOLAT(builder *flatbuffers.Builder, GEOLAT float32) {
	builder.PrependFloat32Slot(60, GEOLAT, 0.0)
}
func EOOAddGEOLON(builder *flatbuffers.Builder, GEOLON float32) {
	builder.PrependFloat32Slot(61, GEOLON, 0.0)
}
func EOOAddGEOALT(builder *flatbuffers.Builder, GEOALT float32) {
	builder.PrependFloat32Slot(62, GEOALT, 0.0)
}
func EOOAddGEORANGE(builder *flatbuffers.Builder, GEORANGE float32) {
	builder.PrependFloat32Slot(63, GEORANGE, 0.0)
}
func EOOAddSKY_BKGRND(builder *flatbuffers.Builder, SKY_BKGRND float32) {
	builder.PrependFloat32Slot(64, SKY_BKGRND, 0.0)
}
func EOOAddPRIMARY_EXTINCTION(builder *flatbuffers.Builder, PRIMARY_EXTINCTION float32) {
	builder.PrependFloat32Slot(65, PRIMARY_EXTINCTION, 0.0)
}
func EOOAddPRIMARY_EXTINCTION_UNC(builder *flatbuffers.Builder, PRIMARY_EXTINCTION_UNC float32) {
	builder.PrependFloat32Slot(66, PRIMARY_EXTINCTION_UNC, 0.0)
}
func EOOAddSOLAR_PHASE_ANGLE(builder *flatbuffers.Builder, SOLAR_PHASE_ANGLE float32) {
	builder.PrependFloat32Slot(67, SOLAR_PHASE_ANGLE, 0.0)
}
func EOOAddSOLAR_EQ_PHASE_ANGLE(builder *flatbuffers.Builder, SOLAR_EQ_PHASE_ANGLE float32) {
	builder.PrependFloat32Slot(68, SOLAR_EQ_PHASE_ANGLE, 0.0)
}
func EOOAddSOLAR_DEC_ANGLE(builder *flatbuffers.Builder, SOLAR_DEC_ANGLE float32) {
	builder.PrependFloat32Slot(69, SOLAR_DEC_ANGLE, 0.0)
}
func EOOAddSHUTTER_DELAY(builder *flatbuffers.Builder, SHUTTER_DELAY float32) {
	builder.PrependFloat32Slot(70, SHUTTER_DELAY, 0.0)
}
func EOOAddTIMING_BIAS(builder *flatbuffers.Builder, TIMING_BIAS float32) {
	builder.PrependFloat32Slot(71, TIMING_BIAS, 0.0)
}
func EOOAddRAW_FILE_URI(builder *flatbuffers.Builder, RAW_FILE_URI flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(72, flatbuffers.UOffsetT(RAW_FILE_URI), 0)
}
func EOOAddINTENSITY(builder *flatbuffers.Builder, INTENSITY float32) {
	builder.PrependFloat32Slot(73, INTENSITY, 0.0)
}
func EOOAddBG_INTENSITY(builder *flatbuffers.Builder, BG_INTENSITY float32) {
	builder.PrependFloat32Slot(74, BG_INTENSITY, 0.0)
}
func EOOAddDESCRIPTOR(builder *flatbuffers.Builder, DESCRIPTOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(75, flatbuffers.UOffsetT(DESCRIPTOR), 0)
}
func EOOAddSOURCE(builder *flatbuffers.Builder, SOURCE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(76, flatbuffers.UOffsetT(SOURCE), 0)
}
func EOOAddORIGIN(builder *flatbuffers.Builder, ORIGIN flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(77, flatbuffers.UOffsetT(ORIGIN), 0)
}
func EOOAddDATA_MODE(builder *flatbuffers.Builder, DATA_MODE DataMode) {
	builder.PrependInt8Slot(78, int8(DATA_MODE), 0)
}
func EOOAddCREATED_AT(builder *flatbuffers.Builder, CREATED_AT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(79, flatbuffers.UOffsetT(CREATED_AT), 0)
}
func EOOAddCREATED_BY(builder *flatbuffers.Builder, CREATED_BY flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(80, flatbuffers.UOffsetT(CREATED_BY), 0)
}
func EOOAddREFERENCE_FRAME(builder *flatbuffers.Builder, REFERENCE_FRAME refFrame) {
	builder.PrependInt8Slot(81, int8(REFERENCE_FRAME), 0)
}
func EOOAddSEN_REFERENCE_FRAME(builder *flatbuffers.Builder, SEN_REFERENCE_FRAME refFrame) {
	builder.PrependInt8Slot(82, int8(SEN_REFERENCE_FRAME), 0)
}
func EOOAddUMBRA(builder *flatbuffers.Builder, UMBRA bool) {
	builder.PrependBoolSlot(83, UMBRA, false)
}
func EOOAddPENUMBRA(builder *flatbuffers.Builder, PENUMBRA bool) {
	builder.PrependBoolSlot(84, PENUMBRA, false)
}
func EOOAddORIG_NETWORK(builder *flatbuffers.Builder, ORIG_NETWORK flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(85, flatbuffers.UOffsetT(ORIG_NETWORK), 0)
}
func EOOAddSOURCE_DL(builder *flatbuffers.Builder, SOURCE_DL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(86, flatbuffers.UOffsetT(SOURCE_DL), 0)
}
func EOOAddTYPE(builder *flatbuffers.Builder, TYPE DeviceType) {
	builder.PrependInt8Slot(87, int8(TYPE), 0)
}
func EOOAddAZIMUTH_MEASURED(builder *flatbuffers.Builder, AZIMUTH_MEASURED bool) {
	builder.PrependBoolSlot(88, AZIMUTH_MEASURED, false)
}
func EOOAddELEVATION_MEASURED(builder *flatbuffers.Builder, ELEVATION_MEASURED bool) {
	builder.PrependBoolSlot(89, ELEVATION_MEASURED, false)
}
func EOOAddRANGE_MEASURED(builder *flatbuffers.Builder, RANGE_MEASURED bool) {
	builder.PrependBoolSlot(90, RANGE_MEASURED, false)
}
func EOOAddRANGERATE_MEASURED(builder *flatbuffers.Builder, RANGERATE_MEASURED bool) {
	builder.PrependBoolSlot(91, RANGERATE_MEASURED, false)
}
func EOOAddRA_MEASURED(builder *flatbuffers.Builder, RA_MEASURED bool) {
	builder.PrependBoolSlot(92, RA_MEASURED, false)
}
func EOOAddDECLINATION_MEASURED(builder *flatbuffers.Builder, DECLINATION_MEASURED bool) {
	builder.PrependBoolSlot(93, DECLINATION_MEASURED, false)
}
func EOOAddNIIRS(builder *flatbuffers.Builder, NIIRS float32) {
	builder.PrependFloat32Slot(94, NIIRS, 0.0)
}
func EOOAddMETERS_PER_PIXEL(builder *flatbuffers.Builder, METERS_PER_PIXEL float32) {
	builder.PrependFloat32Slot(95, METERS_PER_PIXEL, 0.0)
}
func EOOAddIMAGE_SNR(builder *flatbuffers.Builder, IMAGE_SNR float32) {
	builder.PrependFloat32Slot(96, IMAGE_SNR, 0.0)
}
func EOOAddIMAGE_BIT_DEPTH(builder *flatbuffers.Builder, IMAGE_BIT_DEPTH int32) {
	builder.PrependInt32Slot(97, IMAGE_BIT_DEPTH, 0)
}
func EOOAddIMAGE_WIDTH(builder *flatbuffers.Builder, IMAGE_WIDTH int32) {
	builder.PrependInt32Slot(98, IMAGE_WIDTH, 0)
}
func EOOAddIMAGE_HEIGHT(builder *flatbuffers.Builder, IMAGE_HEIGHT int32) {
	builder.PrependInt32Slot(99, IMAGE_HEIGHT, 0)
}
func EOOAddIMAGE_COMPRESSION(builder *flatbuffers.Builder, IMAGE_COMPRESSION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(100, flatbuffers.UOffsetT(IMAGE_COMPRESSION), 0)
}
func EOOAddIMAGE_COMPRESSION_RATIO(builder *flatbuffers.Builder, IMAGE_COMPRESSION_RATIO float32) {
	builder.PrependFloat32Slot(101, IMAGE_COMPRESSION_RATIO, 0.0)
}
func EOOAddPROCESSED_IMAGE_URI(builder *flatbuffers.Builder, PROCESSED_IMAGE_URI flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(102, flatbuffers.UOffsetT(PROCESSED_IMAGE_URI), 0)
}
func EOOAddIMAGE_AUTO_ENHANCED(builder *flatbuffers.Builder, IMAGE_AUTO_ENHANCED bool) {
	builder.PrependBoolSlot(103, IMAGE_AUTO_ENHANCED, false)
}
func EOOAddMULTI_FRAME_STACKED(builder *flatbuffers.Builder, MULTI_FRAME_STACKED bool) {
	builder.PrependBoolSlot(104, MULTI_FRAME_STACKED, false)
}
func EOOAddSYNTHETIC_TRACKING_USED(builder *flatbuffers.Builder, SYNTHETIC_TRACKING_USED bool) {
	builder.PrependBoolSlot(105, SYNTHETIC_TRACKING_USED, false)
}
func EOOAddIMAGE_SHARPNESS(builder *flatbuffers.Builder, IMAGE_SHARPNESS float32) {
	builder.PrependFloat32Slot(106, IMAGE_SHARPNESS, 0.0)
}
func EOOAddIMAGE_NOISE_STDDEV(builder *flatbuffers.Builder, IMAGE_NOISE_STDDEV float32) {
	builder.PrependFloat32Slot(107, IMAGE_NOISE_STDDEV, 0.0)
}
func EOOAddIMAGE_CONTRAST(builder *flatbuffers.Builder, IMAGE_CONTRAST float32) {
	builder.PrependFloat32Slot(108, IMAGE_CONTRAST, 0.0)
}
func EOOAddIMAGE_DYNAMIC_RANGE(builder *flatbuffers.Builder, IMAGE_DYNAMIC_RANGE float32) {
	builder.PrependFloat32Slot(109, IMAGE_DYNAMIC_RANGE, 0.0)
}
func EOOAddIMAGE_ENTROPY(builder *flatbuffers.Builder, IMAGE_ENTROPY float32) {
	builder.PrependFloat32Slot(110, IMAGE_ENTROPY, 0.0)
}
func EOOAddBACKGROUND_UNIFORMITY(builder *flatbuffers.Builder, BACKGROUND_UNIFORMITY float32) {
	builder.PrependFloat32Slot(111, BACKGROUND_UNIFORMITY, 0.0)
}
func EOOAddBACKGROUND_MEAN_LEVEL(builder *flatbuffers.Builder, BACKGROUND_MEAN_LEVEL float32) {
	builder.PrependFloat32Slot(112, BACKGROUND_MEAN_LEVEL, 0.0)
}
func EOOAddSATURATED_PIXEL_PERCENT(builder *flatbuffers.Builder, SATURATED_PIXEL_PERCENT float32) {
	builder.PrependFloat32Slot(113, SATURATED_PIXEL_PERCENT, 0.0)
}
func EOOAddDEAD_PIXEL_PERCENT(builder *flatbuffers.Builder, DEAD_PIXEL_PERCENT float32) {
	builder.PrependFloat32Slot(114, DEAD_PIXEL_PERCENT, 0.0)
}
func EOOAddPSF_FWHM(builder *flatbuffers.Builder, PSF_FWHM float32) {
	builder.PrependFloat32Slot(115, PSF_FWHM, 0.0)
}
func EOOAddCLOUD_COVER_PERCENT(builder *flatbuffers.Builder, CLOUD_COVER_PERCENT float32) {
	builder.PrependFloat32Slot(116, CLOUD_COVER_PERCENT, 0.0)
}
func EOOAddCLOUD_DETECTION_CONFIDENCE(builder *flatbuffers.Builder, CLOUD_DETECTION_CONFIDENCE float32) {
	builder.PrependFloat32Slot(117, CLOUD_DETECTION_CONFIDENCE, 0.0)
}
func EOOAddHAZE_PERCENT(builder *flatbuffers.Builder, HAZE_PERCENT float32) {
	builder.PrependFloat32Slot(118, HAZE_PERCENT, 0.0)
}
func EOOAddAEROSOL_OPTICAL_THICKNESS(builder *flatbuffers.Builder, AEROSOL_OPTICAL_THICKNESS float32) {
	builder.PrependFloat32Slot(119, AEROSOL_OPTICAL_THICKNESS, 0.0)
}
func EOOAddWATER_VAPOR_CONTENT(builder *flatbuffers.Builder, WATER_VAPOR_CONTENT float32) {
	builder.PrependFloat32Slot(120, WATER_VAPOR_CONTENT, 0.0)
}
func EOOAddSUN_ELEVATION(builder *flatbuffers.Builder, SUN_ELEVATION float32) {
	builder.PrependFloat32Slot(121, SUN_ELEVATION, 0.0)
}
func EOOAddSUN_AZIMUTH(builder *flatbuffers.Builder, SUN_AZIMUTH float32) {
	builder.PrependFloat32Slot(122, SUN_AZIMUTH, 0.0)
}
func EOOAddVIEW_ZENITH_ANGLE(builder *flatbuffers.Builder, VIEW_ZENITH_ANGLE float32) {
	builder.PrependFloat32Slot(123, VIEW_ZENITH_ANGLE, 0.0)
}
func EOOAddVIEW_AZIMUTH_ANGLE(builder *flatbuffers.Builder, VIEW_AZIMUTH_ANGLE float32) {
	builder.PrependFloat32Slot(124, VIEW_AZIMUTH_ANGLE, 0.0)
}
func EOOAddOFF_NADIR_ANGLE(builder *flatbuffers.Builder, OFF_NADIR_ANGLE float32) {
	builder.PrependFloat32Slot(125, OFF_NADIR_ANGLE, 0.0)
}
func EOOAddSWATH_WIDTH_KM(builder *flatbuffers.Builder, SWATH_WIDTH_KM float32) {
	builder.PrependFloat32Slot(126, SWATH_WIDTH_KM, 0.0)
}
func EOOAddMEAN_TERRAIN_ELEVATION(builder *flatbuffers.Builder, MEAN_TERRAIN_ELEVATION float32) {
	builder.PrependFloat32Slot(127, MEAN_TERRAIN_ELEVATION, 0.0)
}
func EOOAddTERRAIN_ELEVATION_STDDEV(builder *flatbuffers.Builder, TERRAIN_ELEVATION_STDDEV float32) {
	builder.PrependFloat32Slot(128, TERRAIN_ELEVATION_STDDEV, 0.0)
}
func EOOAddSHADOW_COVER_PERCENT(builder *flatbuffers.Builder, SHADOW_COVER_PERCENT float32) {
	builder.PrependFloat32Slot(129, SHADOW_COVER_PERCENT, 0.0)
}
func EOOAddSUNGLINT_PRESENT(builder *flatbuffers.Builder, SUNGLINT_PRESENT bool) {
	builder.PrependBoolSlot(130, SUNGLINT_PRESENT, false)
}
func EOOAddSUNGLINT_PERCENT(builder *flatbuffers.Builder, SUNGLINT_PERCENT float32) {
	builder.PrependFloat32Slot(131, SUNGLINT_PERCENT, 0.0)
}
func EOOAddSNOW_ICE_COVER_PERCENT(builder *flatbuffers.Builder, SNOW_ICE_COVER_PERCENT float32) {
	builder.PrependFloat32Slot(132, SNOW_ICE_COVER_PERCENT, 0.0)
}
func EOOAddVALID_DATA_AREA_KM2(builder *flatbuffers.Builder, VALID_DATA_AREA_KM2 float32) {
	builder.PrependFloat32Slot(133, VALID_DATA_AREA_KM2, 0.0)
}
func EOOEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
