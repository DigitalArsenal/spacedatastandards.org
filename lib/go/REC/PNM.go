// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Publish Notification Message
type PNM struct {
	_tab flatbuffers.Table
}

const PNMIdentifier = "$PNM"

func GetRootAsPNM(buf []byte, offset flatbuffers.UOffsetT) *PNM {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PNM{}
	x.Init(buf, n+offset)
	return x
}

func FinishPNMBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(PNMIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func PNMBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, PNMIdentifier)
}

func GetSizePrefixedRootAsPNM(buf []byte, offset flatbuffers.UOffsetT) *PNM {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &PNM{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedPNMBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(PNMIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedPNMBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, PNMIdentifier)
}

func (rcv *PNM) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PNM) Table() flatbuffers.Table {
	return rcv._tab
}

/// Multiformat Address
/// https://multiformats.io/multiaddr/
/// A universal address format for representing multiple network protocols. Examples include:
/// - /ip4/192.168.1.1/tcp/80 for an IPv4 address with TCP protocol
/// - /ip6zone/x/ip6/::1 for an IPv6 address with a zone
/// - /dns4/example.com for a domain name resolvable only to IPv4 addresses
/// - /ipfs/bafybeiccfclkdtucu6y4yc5cpr6y3yuinr67svmii46v5cfcrkp47ihehy/README.txt -IPFS address w/CID and path to `README.txt`.
func (rcv *PNM) MULTIFORMAT_ADDRESS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Multiformat Address
/// https://multiformats.io/multiaddr/
/// A universal address format for representing multiple network protocols. Examples include:
/// - /ip4/192.168.1.1/tcp/80 for an IPv4 address with TCP protocol
/// - /ip6zone/x/ip6/::1 for an IPv6 address with a zone
/// - /dns4/example.com for a domain name resolvable only to IPv4 addresses
/// - /ipfs/bafybeiccfclkdtucu6y4yc5cpr6y3yuinr67svmii46v5cfcrkp47ihehy/README.txt -IPFS address w/CID and path to `README.txt`.
/// Publish Time OF THE Publish Notification Message
func (rcv *PNM) PUBLISH_TIMESTAMP() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Publish Time OF THE Publish Notification Message
/// Concatenated Content Identifier (CID)
/// This field is a unique ID for distributed systems (CID).
/// The CID provides a unique identifier within distributed systems, as detailed at https://github.com/multiformats/cid. 
func (rcv *PNM) CID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Concatenated Content Identifier (CID)
/// This field is a unique ID for distributed systems (CID).
/// The CID provides a unique identifier within distributed systems, as detailed at https://github.com/multiformats/cid. 
/// File ID
/// This field is the Name
func (rcv *PNM) FILE_NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// File ID
/// This field is the Name
/// File ID
/// This field is the file ID / Standard Type
func (rcv *PNM) FILE_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// File ID
/// This field is the file ID / Standard Type
/// Digital Signature of the CID
/// This is the digital signature of the CID, signed using the specified cryptographic method.
func (rcv *PNM) SIGNATURE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Digital Signature of the CID
/// This is the digital signature of the CID, signed using the specified cryptographic method.
/// Timestamp Signature
/// Digital signature of the publish timestamp, using the specified cryptographic method for timestamp verification.
func (rcv *PNM) TIMESTAMP_SIGNATURE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Timestamp Signature
/// Digital signature of the publish timestamp, using the specified cryptographic method for timestamp verification.
/// Type of Cryptographic Signature Used
/// Specifies the type of cryptographic signature used for the SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
func (rcv *PNM) SIGNATURE_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Type of Cryptographic Signature Used
/// Specifies the type of cryptographic signature used for the SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
/// Type of Cryptographic Signature Used for Timestamp
/// Specifies the type of cryptographic signature used for the TIMESTAMP_SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
func (rcv *PNM) TIMESTAMP_SIGNATURE_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Type of Cryptographic Signature Used for Timestamp
/// Specifies the type of cryptographic signature used for the TIMESTAMP_SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
func PNMStart(builder *flatbuffers.Builder) {
	builder.StartObject(9)
}
func PNMAddMULTIFORMAT_ADDRESS(builder *flatbuffers.Builder, MULTIFORMAT_ADDRESS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(MULTIFORMAT_ADDRESS), 0)
}
func PNMAddPUBLISH_TIMESTAMP(builder *flatbuffers.Builder, PUBLISH_TIMESTAMP flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(PUBLISH_TIMESTAMP), 0)
}
func PNMAddCID(builder *flatbuffers.Builder, CID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(CID), 0)
}
func PNMAddFILE_NAME(builder *flatbuffers.Builder, FILE_NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(FILE_NAME), 0)
}
func PNMAddFILE_ID(builder *flatbuffers.Builder, FILE_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(FILE_ID), 0)
}
func PNMAddSIGNATURE(builder *flatbuffers.Builder, SIGNATURE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(SIGNATURE), 0)
}
func PNMAddTIMESTAMP_SIGNATURE(builder *flatbuffers.Builder, TIMESTAMP_SIGNATURE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(TIMESTAMP_SIGNATURE), 0)
}
func PNMAddSIGNATURE_TYPE(builder *flatbuffers.Builder, SIGNATURE_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(SIGNATURE_TYPE), 0)
}
func PNMAddTIMESTAMP_SIGNATURE_TYPE(builder *flatbuffers.Builder, TIMESTAMP_SIGNATURE_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(TIMESTAMP_SIGNATURE_TYPE), 0)
}
func PNMEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
