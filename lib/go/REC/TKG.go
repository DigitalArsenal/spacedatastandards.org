// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Tracking and Data Fusion
type TKG struct {
	_tab flatbuffers.Table
}

const TKGIdentifier = "$TKG"

func GetRootAsTKG(buf []byte, offset flatbuffers.UOffsetT) *TKG {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TKG{}
	x.Init(buf, n+offset)
	return x
}

func FinishTKGBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(TKGIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func TKGBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, TKGIdentifier)
}

func GetSizePrefixedRootAsTKG(buf []byte, offset flatbuffers.UOffsetT) *TKG {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TKG{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedTKGBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(TKGIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedTKGBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, TKGIdentifier)
}

func (rcv *TKG) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TKG) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TKG) COMMAND() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TKG) FILTER_CONFIG() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TKG) IMM_CONFIG() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TKG) MHT_CONFIG() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TKG) JPDA_CONFIG() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TKG) FUSION_CONFIG() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TKG) MEASUREMENTS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TKG) INITIAL_STATE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TKG) TRACK_TO_UPDATE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TKG) TRACKS_TO_CORRELATE(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *TKG) TRACKS_TO_CORRELATELength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func TKGStart(builder *flatbuffers.Builder) {
	builder.StartObject(10)
}
func TKGAddCOMMAND(builder *flatbuffers.Builder, COMMAND flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(COMMAND), 0)
}
func TKGAddFILTER_CONFIG(builder *flatbuffers.Builder, FILTER_CONFIG flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(FILTER_CONFIG), 0)
}
func TKGAddIMM_CONFIG(builder *flatbuffers.Builder, IMM_CONFIG flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(IMM_CONFIG), 0)
}
func TKGAddMHT_CONFIG(builder *flatbuffers.Builder, MHT_CONFIG flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(MHT_CONFIG), 0)
}
func TKGAddJPDA_CONFIG(builder *flatbuffers.Builder, JPDA_CONFIG flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(JPDA_CONFIG), 0)
}
func TKGAddFUSION_CONFIG(builder *flatbuffers.Builder, FUSION_CONFIG flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(FUSION_CONFIG), 0)
}
func TKGAddMEASUREMENTS(builder *flatbuffers.Builder, MEASUREMENTS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(MEASUREMENTS), 0)
}
func TKGAddINITIAL_STATE(builder *flatbuffers.Builder, INITIAL_STATE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(INITIAL_STATE), 0)
}
func TKGAddTRACK_TO_UPDATE(builder *flatbuffers.Builder, TRACK_TO_UPDATE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(TRACK_TO_UPDATE), 0)
}
func TKGAddTRACKS_TO_CORRELATE(builder *flatbuffers.Builder, TRACKS_TO_CORRELATE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(TRACKS_TO_CORRELATE), 0)
}
func TKGStartTRACKS_TO_CORRELATEVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TKGEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
