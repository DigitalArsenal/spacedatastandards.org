// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Conjunction Data Message
type CDM struct {
	_tab flatbuffers.Table
}

const CDMIdentifier = "$CDM"

func GetRootAsCDM(buf []byte, offset flatbuffers.UOffsetT) *CDM {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CDM{}
	x.Init(buf, n+offset)
	return x
}

func FinishCDMBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(CDMIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func CDMBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, CDMIdentifier)
}

func GetSizePrefixedRootAsCDM(buf []byte, offset flatbuffers.UOffsetT) *CDM {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CDM{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedCDMBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(CDMIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedCDMBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, CDMIdentifier)
}

func (rcv *CDM) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CDM) Table() flatbuffers.Table {
	return rcv._tab
}

/// The version of the CCSDS CDM standard used
func (rcv *CDM) CCSDS_CDM_VERS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The version of the CCSDS CDM standard used
func (rcv *CDM) MutateCCSDS_CDM_VERS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(4, n)
}

/// The date the CDM message was created
func (rcv *CDM) CREATION_DATE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The date the CDM message was created
/// The originator of the CDM message
func (rcv *CDM) ORIGINATOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The originator of the CDM message
/// The intended recipient of the CDM message
func (rcv *CDM) MESSAGE_FOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The intended recipient of the CDM message
/// A unique identifier for the CDM message
func (rcv *CDM) MESSAGE_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// A unique identifier for the CDM message
/// Time of closest approach
func (rcv *CDM) TCA() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time of closest approach
/// The miss distance between the two objects
func (rcv *CDM) MISS_DISTANCE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The miss distance between the two objects
func (rcv *CDM) MutateMISS_DISTANCE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// The relative speed between the two objects
func (rcv *CDM) RELATIVE_SPEED() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative speed between the two objects
func (rcv *CDM) MutateRELATIVE_SPEED(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

/// The relative position R component
func (rcv *CDM) RELATIVE_POSITION_R() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative position R component
func (rcv *CDM) MutateRELATIVE_POSITION_R(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

/// The relative position T component
func (rcv *CDM) RELATIVE_POSITION_T() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative position T component
func (rcv *CDM) MutateRELATIVE_POSITION_T(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

/// The relative position N component
func (rcv *CDM) RELATIVE_POSITION_N() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative position N component
func (rcv *CDM) MutateRELATIVE_POSITION_N(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// The relative velocity R component
func (rcv *CDM) RELATIVE_VELOCITY_R() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative velocity R component
func (rcv *CDM) MutateRELATIVE_VELOCITY_R(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// The relative velocity T component
func (rcv *CDM) RELATIVE_VELOCITY_T() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative velocity T component
func (rcv *CDM) MutateRELATIVE_VELOCITY_T(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

/// The relative velocity N component
func (rcv *CDM) RELATIVE_VELOCITY_N() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative velocity N component
func (rcv *CDM) MutateRELATIVE_VELOCITY_N(n float64) bool {
	return rcv._tab.MutateFloat64Slot(30, n)
}

/// The start time of the screening period
func (rcv *CDM) START_SCREEN_PERIOD() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The start time of the screening period
/// The end time of the screening period
func (rcv *CDM) STOP_SCREEN_PERIOD() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The end time of the screening period
/// The reference frame for the screening volume
func (rcv *CDM) SCREEN_VOLUME_FRAME() refFrame {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return refFrame(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// The reference frame for the screening volume
func (rcv *CDM) MutateSCREEN_VOLUME_FRAME(n refFrame) bool {
	return rcv._tab.MutateInt8Slot(36, int8(n))
}

/// The shape of the screening volume
func (rcv *CDM) SCREEN_VOLUME_SHAPE() screeningVolumeShape {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return screeningVolumeShape(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// The shape of the screening volume
func (rcv *CDM) MutateSCREEN_VOLUME_SHAPE(n screeningVolumeShape) bool {
	return rcv._tab.MutateInt8Slot(38, int8(n))
}

/// The X dimension of the screening volume
func (rcv *CDM) SCREEN_VOLUME_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The X dimension of the screening volume
func (rcv *CDM) MutateSCREEN_VOLUME_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// The Y dimension of the screening volume
func (rcv *CDM) SCREEN_VOLUME_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The Y dimension of the screening volume
func (rcv *CDM) MutateSCREEN_VOLUME_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// The Z dimension of the screening volume
func (rcv *CDM) SCREEN_VOLUME_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The Z dimension of the screening volume
func (rcv *CDM) MutateSCREEN_VOLUME_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(44, n)
}

/// The time the objects entered the screening volume
func (rcv *CDM) SCREEN_ENTRY_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The time the objects entered the screening volume
/// The time the objects exited the screening volume
func (rcv *CDM) SCREEN_EXIT_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The time the objects exited the screening volume
/// The probability of collision between the two objects
func (rcv *CDM) COLLISION_PROBABILITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The probability of collision between the two objects
func (rcv *CDM) MutateCOLLISION_PROBABILITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

/// The method used to calculate the collision probability
func (rcv *CDM) COLLISION_PROBABILITY_METHOD() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The method used to calculate the collision probability
/// The first object in the CDM message
func (rcv *CDM) OBJECT1(obj *CDMObject) *CDMObject {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CDMObject)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// The first object in the CDM message
/// The second object in the CDM message
func (rcv *CDM) OBJECT2(obj *CDMObject) *CDMObject {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CDMObject)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// The second object in the CDM message
/// Data Source for the positional information for Object 1
func (rcv *CDM) OBJECT1_DATASOURCE(obj *PNM) *PNM {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(PNM)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Data Source for the positional information for Object 1
/// Data Source for the positional information for Object 2
func (rcv *CDM) OBJECT2_DATASOURCE(obj *PNM) *PNM {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(PNM)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Data Source for the positional information for Object 2
func CDMStart(builder *flatbuffers.Builder) {
	builder.StartObject(29)
}
func CDMAddCCSDS_CDM_VERS(builder *flatbuffers.Builder, CCSDS_CDM_VERS float64) {
	builder.PrependFloat64Slot(0, CCSDS_CDM_VERS, 0.0)
}
func CDMAddCREATION_DATE(builder *flatbuffers.Builder, CREATION_DATE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(CREATION_DATE), 0)
}
func CDMAddORIGINATOR(builder *flatbuffers.Builder, ORIGINATOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(ORIGINATOR), 0)
}
func CDMAddMESSAGE_FOR(builder *flatbuffers.Builder, MESSAGE_FOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(MESSAGE_FOR), 0)
}
func CDMAddMESSAGE_ID(builder *flatbuffers.Builder, MESSAGE_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(MESSAGE_ID), 0)
}
func CDMAddTCA(builder *flatbuffers.Builder, TCA flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(TCA), 0)
}
func CDMAddMISS_DISTANCE(builder *flatbuffers.Builder, MISS_DISTANCE float64) {
	builder.PrependFloat64Slot(6, MISS_DISTANCE, 0.0)
}
func CDMAddRELATIVE_SPEED(builder *flatbuffers.Builder, RELATIVE_SPEED float64) {
	builder.PrependFloat64Slot(7, RELATIVE_SPEED, 0.0)
}
func CDMAddRELATIVE_POSITION_R(builder *flatbuffers.Builder, RELATIVE_POSITION_R float64) {
	builder.PrependFloat64Slot(8, RELATIVE_POSITION_R, 0.0)
}
func CDMAddRELATIVE_POSITION_T(builder *flatbuffers.Builder, RELATIVE_POSITION_T float64) {
	builder.PrependFloat64Slot(9, RELATIVE_POSITION_T, 0.0)
}
func CDMAddRELATIVE_POSITION_N(builder *flatbuffers.Builder, RELATIVE_POSITION_N float64) {
	builder.PrependFloat64Slot(10, RELATIVE_POSITION_N, 0.0)
}
func CDMAddRELATIVE_VELOCITY_R(builder *flatbuffers.Builder, RELATIVE_VELOCITY_R float64) {
	builder.PrependFloat64Slot(11, RELATIVE_VELOCITY_R, 0.0)
}
func CDMAddRELATIVE_VELOCITY_T(builder *flatbuffers.Builder, RELATIVE_VELOCITY_T float64) {
	builder.PrependFloat64Slot(12, RELATIVE_VELOCITY_T, 0.0)
}
func CDMAddRELATIVE_VELOCITY_N(builder *flatbuffers.Builder, RELATIVE_VELOCITY_N float64) {
	builder.PrependFloat64Slot(13, RELATIVE_VELOCITY_N, 0.0)
}
func CDMAddSTART_SCREEN_PERIOD(builder *flatbuffers.Builder, START_SCREEN_PERIOD flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(START_SCREEN_PERIOD), 0)
}
func CDMAddSTOP_SCREEN_PERIOD(builder *flatbuffers.Builder, STOP_SCREEN_PERIOD flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(STOP_SCREEN_PERIOD), 0)
}
func CDMAddSCREEN_VOLUME_FRAME(builder *flatbuffers.Builder, SCREEN_VOLUME_FRAME refFrame) {
	builder.PrependInt8Slot(16, int8(SCREEN_VOLUME_FRAME), 0)
}
func CDMAddSCREEN_VOLUME_SHAPE(builder *flatbuffers.Builder, SCREEN_VOLUME_SHAPE screeningVolumeShape) {
	builder.PrependInt8Slot(17, int8(SCREEN_VOLUME_SHAPE), 0)
}
func CDMAddSCREEN_VOLUME_X(builder *flatbuffers.Builder, SCREEN_VOLUME_X float64) {
	builder.PrependFloat64Slot(18, SCREEN_VOLUME_X, 0.0)
}
func CDMAddSCREEN_VOLUME_Y(builder *flatbuffers.Builder, SCREEN_VOLUME_Y float64) {
	builder.PrependFloat64Slot(19, SCREEN_VOLUME_Y, 0.0)
}
func CDMAddSCREEN_VOLUME_Z(builder *flatbuffers.Builder, SCREEN_VOLUME_Z float64) {
	builder.PrependFloat64Slot(20, SCREEN_VOLUME_Z, 0.0)
}
func CDMAddSCREEN_ENTRY_TIME(builder *flatbuffers.Builder, SCREEN_ENTRY_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(SCREEN_ENTRY_TIME), 0)
}
func CDMAddSCREEN_EXIT_TIME(builder *flatbuffers.Builder, SCREEN_EXIT_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(22, flatbuffers.UOffsetT(SCREEN_EXIT_TIME), 0)
}
func CDMAddCOLLISION_PROBABILITY(builder *flatbuffers.Builder, COLLISION_PROBABILITY float64) {
	builder.PrependFloat64Slot(23, COLLISION_PROBABILITY, 0.0)
}
func CDMAddCOLLISION_PROBABILITY_METHOD(builder *flatbuffers.Builder, COLLISION_PROBABILITY_METHOD flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(24, flatbuffers.UOffsetT(COLLISION_PROBABILITY_METHOD), 0)
}
func CDMAddOBJECT1(builder *flatbuffers.Builder, OBJECT1 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(25, flatbuffers.UOffsetT(OBJECT1), 0)
}
func CDMAddOBJECT2(builder *flatbuffers.Builder, OBJECT2 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(26, flatbuffers.UOffsetT(OBJECT2), 0)
}
func CDMAddOBJECT1_DATASOURCE(builder *flatbuffers.Builder, OBJECT1_DATASOURCE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(27, flatbuffers.UOffsetT(OBJECT1_DATASOURCE), 0)
}
func CDMAddOBJECT2_DATASOURCE(builder *flatbuffers.Builder, OBJECT2_DATASOURCE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(28, flatbuffers.UOffsetT(OBJECT2_DATASOURCE), 0)
}
func CDMEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
