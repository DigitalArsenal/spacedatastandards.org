// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package REC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// KML Document
type KML struct {
	_tab flatbuffers.Table
}

const KMLIdentifier = "$KML"

func GetRootAsKML(buf []byte, offset flatbuffers.UOffsetT) *KML {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &KML{}
	x.Init(buf, n+offset)
	return x
}

func FinishKMLBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(KMLIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func KMLBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, KMLIdentifier)
}

func GetSizePrefixedRootAsKML(buf []byte, offset flatbuffers.UOffsetT) *KML {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &KML{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedKMLBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(KMLIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedKMLBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, KMLIdentifier)
}

func (rcv *KML) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *KML) Table() flatbuffers.Table {
	return rcv._tab
}

/// Document name
func (rcv *KML) NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Document name
/// Document description
func (rcv *KML) DESCRIPTION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Document description
/// Whether document is visible
func (rcv *KML) VISIBILITY() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Whether document is visible
func (rcv *KML) MutateVISIBILITY(n bool) bool {
	return rcv._tab.MutateBoolSlot(8, n)
}

/// Whether document is open in tree view
func (rcv *KML) OPEN() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Whether document is open in tree view
func (rcv *KML) MutateOPEN(n bool) bool {
	return rcv._tab.MutateBoolSlot(10, n)
}

/// Shared styles
func (rcv *KML) STYLES(obj *KMLStyle, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *KML) STYLESLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Shared styles
/// Style maps
func (rcv *KML) STYLE_MAPS(obj *KMLStyleMap, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *KML) STYLE_MAPSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Style maps
/// Top-level placemarks
func (rcv *KML) PLACEMARKS(obj *KMLPlacemark, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *KML) PLACEMARKSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Top-level placemarks
/// Top-level folders
func (rcv *KML) FOLDERS(obj *KMLFolder, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *KML) FOLDERSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Top-level folders
/// Network links
func (rcv *KML) NETWORK_LINKS(obj *KMLNetworkLink, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *KML) NETWORK_LINKSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Network links
/// Ground overlays
func (rcv *KML) GROUND_OVERLAYS(obj *KMLGroundOverlay, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *KML) GROUND_OVERLAYSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Ground overlays
/// Schemas
func (rcv *KML) SCHEMAS(obj *KMLSchema, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *KML) SCHEMASLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Schemas
/// Screen overlays
func (rcv *KML) SCREEN_OVERLAYS(obj *KMLScreenOverlay, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *KML) SCREEN_OVERLAYSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Screen overlays
/// Photo overlays
func (rcv *KML) PHOTO_OVERLAYS(obj *KMLPhotoOverlay, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *KML) PHOTO_OVERLAYSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Photo overlays
/// Tours
func (rcv *KML) TOURS(obj *KMLTour, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *KML) TOURSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Tours
/// NetworkLinkControl
func (rcv *KML) NETWORK_LINK_CONTROL(obj *KMLNetworkLinkControl) *KMLNetworkLinkControl {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(KMLNetworkLinkControl)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// NetworkLinkControl
func KMLStart(builder *flatbuffers.Builder) {
	builder.StartObject(15)
}
func KMLAddNAME(builder *flatbuffers.Builder, NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(NAME), 0)
}
func KMLAddDESCRIPTION(builder *flatbuffers.Builder, DESCRIPTION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(DESCRIPTION), 0)
}
func KMLAddVISIBILITY(builder *flatbuffers.Builder, VISIBILITY bool) {
	builder.PrependBoolSlot(2, VISIBILITY, false)
}
func KMLAddOPEN(builder *flatbuffers.Builder, OPEN bool) {
	builder.PrependBoolSlot(3, OPEN, false)
}
func KMLAddSTYLES(builder *flatbuffers.Builder, STYLES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(STYLES), 0)
}
func KMLStartSTYLESVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KMLAddSTYLE_MAPS(builder *flatbuffers.Builder, STYLE_MAPS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(STYLE_MAPS), 0)
}
func KMLStartSTYLE_MAPSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KMLAddPLACEMARKS(builder *flatbuffers.Builder, PLACEMARKS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(PLACEMARKS), 0)
}
func KMLStartPLACEMARKSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KMLAddFOLDERS(builder *flatbuffers.Builder, FOLDERS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(FOLDERS), 0)
}
func KMLStartFOLDERSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KMLAddNETWORK_LINKS(builder *flatbuffers.Builder, NETWORK_LINKS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(NETWORK_LINKS), 0)
}
func KMLStartNETWORK_LINKSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KMLAddGROUND_OVERLAYS(builder *flatbuffers.Builder, GROUND_OVERLAYS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(GROUND_OVERLAYS), 0)
}
func KMLStartGROUND_OVERLAYSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KMLAddSCHEMAS(builder *flatbuffers.Builder, SCHEMAS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(SCHEMAS), 0)
}
func KMLStartSCHEMASVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KMLAddSCREEN_OVERLAYS(builder *flatbuffers.Builder, SCREEN_OVERLAYS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(SCREEN_OVERLAYS), 0)
}
func KMLStartSCREEN_OVERLAYSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KMLAddPHOTO_OVERLAYS(builder *flatbuffers.Builder, PHOTO_OVERLAYS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(PHOTO_OVERLAYS), 0)
}
func KMLStartPHOTO_OVERLAYSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KMLAddTOURS(builder *flatbuffers.Builder, TOURS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(TOURS), 0)
}
func KMLStartTOURSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KMLAddNETWORK_LINK_CONTROL(builder *flatbuffers.Builder, NETWORK_LINK_CONTROL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(NETWORK_LINK_CONTROL), 0)
}
func KMLEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
