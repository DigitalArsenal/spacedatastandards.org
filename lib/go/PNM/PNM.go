// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package PNM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Publish Notification Message
/// This table includes a comprehensive set of cryptographic hashes and a digital signature for file publication.
type PNM struct {
	_tab flatbuffers.Table
}

func GetRootAsPNM(buf []byte, offset flatbuffers.UOffsetT) *PNM {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PNM{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsPNM(buf []byte, offset flatbuffers.UOffsetT) *PNM {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &PNM{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *PNM) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PNM) Table() flatbuffers.Table {
	return rcv._tab
}

/// IPFS Content Identifier (CID)
/// The hash of a file stored on the InterPlanetary File System (IPFS).
/// Refer to the section on IPFS integration for details.
func (rcv *PNM) IPFS_CID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// IPFS Content Identifier (CID)
/// The hash of a file stored on the InterPlanetary File System (IPFS).
/// Refer to the section on IPFS integration for details.
/// Ethereum Digital Signature
/// Digital signature of the IPFS file hash using Ethereum's signing mechanism.
/// Refer to the Ethereum Blockchain integration section for details.
func (rcv *PNM) ETH_DIGITAL_SIGNATURE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Ethereum Digital Signature
/// Digital signature of the IPFS file hash using Ethereum's signing mechanism.
/// Refer to the Ethereum Blockchain integration section for details.
/// SHA-512 File Hash
/// SHA-512 hash of the file for additional security verification.
/// Detailed in the security features section of the document.
func (rcv *PNM) SHA_512_FILE_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// SHA-512 File Hash
/// SHA-512 hash of the file for additional security verification.
/// Detailed in the security features section of the document.
/// SHA-256 File Hash
/// SHA-256 hash of the file for additional security verification.
/// Detailed in the security features section of the document.
func (rcv *PNM) SHA_256_FILE_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// SHA-256 File Hash
/// SHA-256 hash of the file for additional security verification.
/// Detailed in the security features section of the document.
/// MD5 File Digest
/// MD5 digest of the file for backward compatibility with older systems.
/// Located in the legacy support section of the document.
func (rcv *PNM) MD5_FILE_DIGEST() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// MD5 File Digest
/// MD5 digest of the file for backward compatibility with older systems.
/// Located in the legacy support section of the document.
/// SHA-1 File Hash
/// SHA-1 hash of the file, used in certain legacy systems for compatibility.
/// Refer to the legacy systems integration section for more information.
func (rcv *PNM) SHA_1_FILE_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// SHA-1 File Hash
/// SHA-1 hash of the file, used in certain legacy systems for compatibility.
/// Refer to the legacy systems integration section for more information.
/// Argon2 File Hash
/// Argon2 hash of the file, providing state-of-the-art password hashing.
/// This is mentioned in the advanced security measures section.
func (rcv *PNM) ARGON2_FILE_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Argon2 File Hash
/// Argon2 hash of the file, providing state-of-the-art password hashing.
/// This is mentioned in the advanced security measures section.
/// Blake2b File Hash
/// Blake2b hash of the file, known for high-speed cryptographic hashing.
/// Refer to the high-performance security solutions section.
func (rcv *PNM) BLAKE2B_FILE_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Blake2b File Hash
/// Blake2b hash of the file, known for high-speed cryptographic hashing.
/// Refer to the high-performance security solutions section.
/// SHA-3 File Hash
/// SHA-3 hash of the file, offering a stronger alternative to SHA-2.
/// Located in the modern cryptographic standards section.
func (rcv *PNM) SHA_3_FILE_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// SHA-3 File Hash
/// SHA-3 hash of the file, offering a stronger alternative to SHA-2.
/// Located in the modern cryptographic standards section.
/// RIPEMD-160 File Hash
/// RIPEMD-160 hash of the file, often used in blockchain applications for address generation.
/// Discussed in the blockchain compatibility section.
func (rcv *PNM) RIPEMD_160_FILE_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// RIPEMD-160 File Hash
/// RIPEMD-160 hash of the file, often used in blockchain applications for address generation.
/// Discussed in the blockchain compatibility section.
/// Whirlpool File Hash
/// Whirlpool hash of the file, designed for integrity protection and digital fingerprinting.
/// Refer to the data integrity and authentication section.
func (rcv *PNM) WHIRLPOOL_FILE_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Whirlpool File Hash
/// Whirlpool hash of the file, designed for integrity protection and digital fingerprinting.
/// Refer to the data integrity and authentication section.
/// Tiger File Hash
/// Tiger hash of the file, optimized for fast hashing on 64-bit platforms.
/// Detailed in the high-speed cryptographic operations section.
func (rcv *PNM) TIGER_FILE_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Tiger File Hash
/// Tiger hash of the file, optimized for fast hashing on 64-bit platforms.
/// Detailed in the high-speed cryptographic operations section.
/// Cyclic Redundancy Check (CRC) 32
/// Cyclic redundancy check with a length of 32 bits.
/// Refer to CRC section for more details.
func (rcv *PNM) CRC32() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Cyclic Redundancy Check (CRC) 32
/// Cyclic redundancy check with a length of 32 bits.
/// Refer to CRC section for more details.
/// Adler-32 Checksum
/// Adler-32 checksum with a length of 32 bits.
/// Refer to the checksum section for more details.
func (rcv *PNM) ADLER32_CHECKSUM() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Adler-32 Checksum
/// Adler-32 checksum with a length of 32 bits.
/// Refer to the checksum section for more details.
/// Universal Hash Function Family - Rabin Fingerprint
/// Variable-length hash function using Rabin fingerprinting.
/// Refer to the Universal hash function families section for details.
func (rcv *PNM) RABIN_FINGERPRINT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Universal Hash Function Family - Rabin Fingerprint
/// Variable-length hash function using Rabin fingerprinting.
/// Refer to the Universal hash function families section for details.
/// Non-Cryptographic Hash Function - Pearson Hashing
/// Non-cryptographic hash function with a length of 8 bits or more, using XOR or table lookup.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) PEARSON_HASHING() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - Pearson Hashing
/// Non-cryptographic hash function with a length of 8 bits or more, using XOR or table lookup.
/// Refer to the Non-cryptographic hash functions section for details.
/// Keyed Cryptographic Hash Function - BLAKE2
/// Keyed hash function (prefix-MAC) with variable length.
/// Refer to the Keyed cryptographic hash functions section for details.
func (rcv *PNM) BLAKE2_KEYED_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Keyed Cryptographic Hash Function - BLAKE2
/// Keyed hash function (prefix-MAC) with variable length.
/// Refer to the Keyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - BLAKE-256
/// Cryptographic hash function with a length of 256 bits, based on HAIFA structure.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) BLAKE_256() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - BLAKE-256
/// Cryptographic hash function with a length of 256 bits, based on HAIFA structure.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// CRC-8
/// Cyclic redundancy check with a length of 8 bits.
/// Refer to CRC section for more details.
func (rcv *PNM) CRC8() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// CRC-8
/// Cyclic redundancy check with a length of 8 bits.
/// Refer to CRC section for more details.
/// CRC-16
/// Cyclic redundancy check with a length of 16 bits.
/// Refer to CRC section for more details.
func (rcv *PNM) CRC16() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// CRC-16
/// Cyclic redundancy check with a length of 16 bits.
/// Refer to CRC section for more details.
/// CRC-64
/// Cyclic redundancy check with a length of 64 bits.
/// Refer to CRC section for more details.
func (rcv *PNM) CRC64() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// CRC-64
/// Cyclic redundancy check with a length of 64 bits.
/// Refer to CRC section for more details.
/// BSD Checksum
/// BSD checksum with a length of 16 bits.
/// Refer to the checksum section for more details.
func (rcv *PNM) BSD_CHECKSUM() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// BSD Checksum
/// BSD checksum with a length of 16 bits.
/// Refer to the checksum section for more details.
/// SYSV Checksum
/// SYSV checksum with a length of 16 bits.
/// Refer to the checksum section for more details.
func (rcv *PNM) SYSV_CHECKSUM() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// SYSV Checksum
/// SYSV checksum with a length of 16 bits.
/// Refer to the checksum section for more details.
/// Sum8
/// Sum with a length of 8 bits.
/// Refer to the checksum section for more details.
func (rcv *PNM) SUM8() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Sum8
/// Sum with a length of 8 bits.
/// Refer to the checksum section for more details.
/// Internet Checksum
/// Internet checksum with a length of 16 bits.
/// Refer to the checksum section for more details.
func (rcv *PNM) INTERNET_CHECKSUM() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Internet Checksum
/// Internet checksum with a length of 16 bits.
/// Refer to the checksum section for more details.
/// Sum24
/// Sum with a length of 24 bits.
/// Refer to the checksum section for more details.
func (rcv *PNM) SUM24() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Sum24
/// Sum with a length of 24 bits.
/// Refer to the checksum section for more details.
/// Sum32
/// Sum with a length of 32 bits.
/// Refer to the checksum section for more details.
func (rcv *PNM) SUM32() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Sum32
/// Sum with a length of 32 bits.
/// Refer to the checksum section for more details.
/// Fletcher-4
/// Sum with a length of 4 bits.
/// Refer to the checksum section for more details.
func (rcv *PNM) FLETCHER_4() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Fletcher-4
/// Sum with a length of 4 bits.
/// Refer to the checksum section for more details.
/// Fletcher-8
/// Sum with a length of 8 bits.
/// Refer to the checksum section for more details.
func (rcv *PNM) FLETCHER_8() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Fletcher-8
/// Sum with a length of 8 bits.
/// Refer to the checksum section for more details.
/// Fletcher-16
/// Sum with a length of 16 bits.
/// Refer to the checksum section for more details.
func (rcv *PNM) FLETCHER_16() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Fletcher-16
/// Sum with a length of 16 bits.
/// Refer to the checksum section for more details.
/// Fletcher-32
/// Sum with a length of 32 bits.
/// Refer to the checksum section for more details.
func (rcv *PNM) FLETCHER_32() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Fletcher-32
/// Sum with a length of 32 bits.
/// Refer to the checksum section for more details.
/// Luhn Algorithm
/// Luhn algorithm with a length of 1 decimal digit.
/// Refer to the checksum section for more details.
func (rcv *PNM) LUNH_ALGORITHM() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Luhn Algorithm
/// Luhn algorithm with a length of 1 decimal digit.
/// Refer to the checksum section for more details.
/// Verhoeff Algorithm
/// Verhoeff algorithm with a length of 1 decimal digit.
/// Refer to the checksum section for more details.
func (rcv *PNM) VERHOEFF_ALGORITHM() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Verhoeff Algorithm
/// Verhoeff algorithm with a length of 1 decimal digit.
/// Refer to the checksum section for more details.
/// Damm Algorithm
/// Damm algorithm with a length of 1 decimal digit.
/// Refer to the checksum section for more details.
func (rcv *PNM) DAMM_ALGORITHM() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Damm Algorithm
/// Damm algorithm with a length of 1 decimal digit.
/// Refer to the checksum section for more details.
/// Universal Hash Function Family - Tabulation Hashing
/// Variable-length hash function using tabulation hashing.
/// Refer to the Universal hash function families section for details.
func (rcv *PNM) TABULATION_HASHING() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Universal Hash Function Family - Tabulation Hashing
/// Variable-length hash function using tabulation hashing.
/// Refer to the Universal hash function families section for details.
/// Universal Hash Function Family - Universal One-Way Hash Function
/// Universal one-way hash function with arbitrary length.
/// Refer to the Universal hash function families section for details.
func (rcv *PNM) UNIVERSAL_ONE_WAY_HASH_FUNCTION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Universal Hash Function Family - Universal One-Way Hash Function
/// Universal one-way hash function with arbitrary length.
/// Refer to the Universal hash function families section for details.
/// Universal Hash Function Family - Zobrist Hashing
/// Variable-length hash function using Zobrist hashing.
/// Refer to the Universal hash function families section for details.
func (rcv *PNM) ZOBRIST_HASHING() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Universal Hash Function Family - Zobrist Hashing
/// Variable-length hash function using Zobrist hashing.
/// Refer to the Universal hash function families section for details.
/// Non-Cryptographic Hash Function - Paul Hsieh's SuperFastHash
/// Non-cryptographic hash function with a length of 32 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) PAUL_HSIEHS_SUPERFASTHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - Paul Hsieh's SuperFastHash
/// Non-cryptographic hash function with a length of 32 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - Buzhash
/// Non-cryptographic hash function with variable length.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) BUZHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - Buzhash
/// Non-cryptographic hash function with variable length.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - Fowler-Noll-Vo Hash Function (FNV Hash)
/// Non-cryptographic hash function with variable length.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) FNV_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - Fowler-Noll-Vo Hash Function (FNV Hash)
/// Non-cryptographic hash function with variable length.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - Jenkins Hash Function
/// Non-cryptographic hash function with a length of 32 or 64 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) JENKINS_HASH_FUNCTION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - Jenkins Hash Function
/// Non-cryptographic hash function with a length of 32 or 64 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - Bernstein's Hash (djb2)
/// Non-cryptographic hash function with a length of 32 or 64 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) BERNSTEINS_HASH_DJB2() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - Bernstein's Hash (djb2)
/// Non-cryptographic hash function with a length of 32 or 64 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - PJW Hash / Elf Hash
/// Non-cryptographic hash function with a length of 32 or 64 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) PJW_HASH_ELF_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - PJW Hash / Elf Hash
/// Non-cryptographic hash function with a length of 32 or 64 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - MurmurHash
/// Non-cryptographic hash function with a length of 32, 64, or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) MURMURHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(90))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - MurmurHash
/// Non-cryptographic hash function with a length of 32, 64, or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - Fast-Hash
/// Non-cryptographic hash function with a length of 32 or 64 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) FAST_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(92))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - Fast-Hash
/// Non-cryptographic hash function with a length of 32 or 64 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - SpookyHash
/// Non-cryptographic hash function with a length of 32, 64, or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) SPOOKYHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(94))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - SpookyHash
/// Non-cryptographic hash function with a length of 32, 64, or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - CityHash
/// Non-cryptographic hash function with a length of 32, 64, 128, or 256 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) CITYHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(96))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - CityHash
/// Non-cryptographic hash function with a length of 32, 64, 128, or 256 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - FarmHash
/// Non-cryptographic hash function with a length of 32, 64, or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) FARMHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - FarmHash
/// Non-cryptographic hash function with a length of 32, 64, or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - MetroHash
/// Non-cryptographic hash function with a length of 64 or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) METROHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(100))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - MetroHash
/// Non-cryptographic hash function with a length of 64 or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - Numeric Hash (nhash)
/// Non-cryptographic hash function with variable length.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) NUMERIC_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - Numeric Hash (nhash)
/// Non-cryptographic hash function with variable length.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - xxHash
/// Non-cryptographic hash function with a length of 32, 64, or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) XXHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - xxHash
/// Non-cryptographic hash function with a length of 32, 64, or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - t1ha (Fast Positive Hash)
/// Non-cryptographic hash function with a length of 64 or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) T1HA() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - t1ha (Fast Positive Hash)
/// Non-cryptographic hash function with a length of 64 or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - GxHash
/// Non-cryptographic hash function with a length of 32, 64, or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) GXHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - GxHash
/// Non-cryptographic hash function with a length of 32, 64, or 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - pHash
/// Non-cryptographic hash function with fixed or variable length.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) PHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - pHash
/// Non-cryptographic hash function with fixed or variable length.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - dhash
/// Non-cryptographic hash function with a length of 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) DHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - dhash
/// Non-cryptographic hash function with a length of 128 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Non-Cryptographic Hash Function - SDBM
/// Non-cryptographic hash function with a length of 32 or 64 bits.
/// Refer to the Non-cryptographic hash functions section for details.
func (rcv *PNM) SDBM() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Non-Cryptographic Hash Function - SDBM
/// Non-cryptographic hash function with a length of 32 or 64 bits.
/// Refer to the Non-cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - OSDB Hash
/// Cryptographic hash function with a length of 64 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) OSDB_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - OSDB Hash
/// Cryptographic hash function with a length of 64 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - komihash
/// Cryptographic hash function with a length of 64 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) KOMIHASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - komihash
/// Cryptographic hash function with a length of 64 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Keyed Cryptographic Hash Function - BLAKE3
/// Keyed hash function with arbitrary length.
/// Refer to the Keyed cryptographic hash functions section for details.
func (rcv *PNM) BLAKE3() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(120))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Keyed Cryptographic Hash Function - BLAKE3
/// Keyed hash function with arbitrary length.
/// Refer to the Keyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - ECOH
/// Cryptographic hash function with a length of 224 to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) ECOH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(122))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - ECOH
/// Cryptographic hash function with a length of 224 to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - FSB
/// Cryptographic hash function with a length of 160 to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) FSB() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(124))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - FSB
/// Cryptographic hash function with a length of 160 to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - GOST
/// Cryptographic hash function with a length of 256 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) GOST() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(126))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - GOST
/// Cryptographic hash function with a length of 256 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - Grøstl
/// Cryptographic hash function with a length of up to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) GROSTL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(128))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - Grøstl
/// Cryptographic hash function with a length of up to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - HAS-160
/// Cryptographic hash function with a length of 160 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) HAS_160() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(130))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - HAS-160
/// Cryptographic hash function with a length of 160 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - HAVAL
/// Cryptographic hash function with a length of 128 to 256 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) HAVAL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(132))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - HAVAL
/// Cryptographic hash function with a length of 128 to 256 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - JH
/// Cryptographic hash function with a length of 224 to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) JH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(134))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - JH
/// Cryptographic hash function with a length of 224 to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - LSH
/// Cryptographic hash function with a length of 256 to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) LSH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(136))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - LSH
/// Cryptographic hash function with a length of 256 to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - MD2
/// Cryptographic hash function with a length of 128 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) MD2() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(138))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - MD2
/// Cryptographic hash function with a length of 128 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - MD4
/// Cryptographic hash function with a length of 128 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) MD4() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(140))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - MD4
/// Cryptographic hash function with a length of 128 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - MD5
/// Cryptographic hash function with a length of 128 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) MD5() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(142))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - MD5
/// Cryptographic hash function with a length of 128 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - MD6
/// Cryptographic hash function with a length of up to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) MD6() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(144))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - MD6
/// Cryptographic hash function with a length of up to 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - RadioGatún
/// Cryptographic hash function with arbitrary length.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) RADIOGATUN() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(146))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - RadioGatún
/// Cryptographic hash function with arbitrary length.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - RIPEMD
/// Cryptographic hash function with a length of 128 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) RIPEMD() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(148))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - RIPEMD
/// Cryptographic hash function with a length of 128 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - RIPEMD-128
/// Cryptographic hash function with a length of 128 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) RIPEMD_128() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(150))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - RIPEMD-128
/// Cryptographic hash function with a length of 128 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - RIPEMD-256
/// Cryptographic hash function with a length of 256 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) RIPEMD_256() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(152))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - RIPEMD-256
/// Cryptographic hash function with a length of 256 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - RIPEMD-320
/// Cryptographic hash function with a length of 320 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) RIPEMD_320() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(154))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - RIPEMD-320
/// Cryptographic hash function with a length of 320 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - SHA-1
/// Cryptographic hash function with a length of 160 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) SHA_1() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(156))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - SHA-1
/// Cryptographic hash function with a length of 160 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - SHA-224
/// Cryptographic hash function with a length of 224 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) SHA_224() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(158))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - SHA-224
/// Cryptographic hash function with a length of 224 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - SHA-256
/// Cryptographic hash function with a length of 256 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) SHA_256() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(160))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - SHA-256
/// Cryptographic hash function with a length of 256 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - SHA-384
/// Cryptographic hash function with a length of 384 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) SHA_384() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(162))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - SHA-384
/// Cryptographic hash function with a length of 384 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - SHA-512
/// Cryptographic hash function with a length of 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) SHA_512() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(164))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - SHA-512
/// Cryptographic hash function with a length of 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - SHA-3
/// Cryptographic hash function with arbitrary length.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) SHA_3() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(166))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - SHA-3
/// Cryptographic hash function with arbitrary length.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - Skein
/// Cryptographic hash function with arbitrary length.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) SKEIN() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(168))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - Skein
/// Cryptographic hash function with arbitrary length.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - Snefru
/// Cryptographic hash function with a length of 128 or 256 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) SNEFRU() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(170))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - Snefru
/// Cryptographic hash function with a length of 128 or 256 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - Spectral Hash
/// Cryptographic hash function with a length of 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) SPECTRAL_HASH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(172))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - Spectral Hash
/// Cryptographic hash function with a length of 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - Streebog
/// Cryptographic hash function with a length of 256 or 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) STREEBOG() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(174))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - Streebog
/// Cryptographic hash function with a length of 256 or 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - SWIFFT
/// Cryptographic hash function with a length of 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) SWIFFT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(176))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - SWIFFT
/// Cryptographic hash function with a length of 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - Tiger
/// Cryptographic hash function with a length of 192 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) TIGER() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(178))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - Tiger
/// Cryptographic hash function with a length of 192 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
/// Unkeyed Cryptographic Hash Function - Whirlpool
/// Cryptographic hash function with a length of 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func (rcv *PNM) WHIRLPOOL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(180))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unkeyed Cryptographic Hash Function - Whirlpool
/// Cryptographic hash function with a length of 512 bits.
/// Refer to the Unkeyed cryptographic hash functions section for details.
func PNMStart(builder *flatbuffers.Builder) {
	builder.StartObject(89)
}
func PNMAddIPFS_CID(builder *flatbuffers.Builder, IPFS_CID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(IPFS_CID), 0)
}
func PNMAddETH_DIGITAL_SIGNATURE(builder *flatbuffers.Builder, ETH_DIGITAL_SIGNATURE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(ETH_DIGITAL_SIGNATURE), 0)
}
func PNMAddSHA_512_FILE_HASH(builder *flatbuffers.Builder, SHA_512_FILE_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(SHA_512_FILE_HASH), 0)
}
func PNMAddSHA_256_FILE_HASH(builder *flatbuffers.Builder, SHA_256_FILE_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(SHA_256_FILE_HASH), 0)
}
func PNMAddMD5_FILE_DIGEST(builder *flatbuffers.Builder, MD5_FILE_DIGEST flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(MD5_FILE_DIGEST), 0)
}
func PNMAddSHA_1_FILE_HASH(builder *flatbuffers.Builder, SHA_1_FILE_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(SHA_1_FILE_HASH), 0)
}
func PNMAddARGON2_FILE_HASH(builder *flatbuffers.Builder, ARGON2_FILE_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(ARGON2_FILE_HASH), 0)
}
func PNMAddBLAKE2B_FILE_HASH(builder *flatbuffers.Builder, BLAKE2B_FILE_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(BLAKE2B_FILE_HASH), 0)
}
func PNMAddSHA_3_FILE_HASH(builder *flatbuffers.Builder, SHA_3_FILE_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(SHA_3_FILE_HASH), 0)
}
func PNMAddRIPEMD_160_FILE_HASH(builder *flatbuffers.Builder, RIPEMD_160_FILE_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(RIPEMD_160_FILE_HASH), 0)
}
func PNMAddWHIRLPOOL_FILE_HASH(builder *flatbuffers.Builder, WHIRLPOOL_FILE_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(WHIRLPOOL_FILE_HASH), 0)
}
func PNMAddTIGER_FILE_HASH(builder *flatbuffers.Builder, TIGER_FILE_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(TIGER_FILE_HASH), 0)
}
func PNMAddCRC32(builder *flatbuffers.Builder, CRC32 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(CRC32), 0)
}
func PNMAddADLER32_CHECKSUM(builder *flatbuffers.Builder, ADLER32_CHECKSUM flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(ADLER32_CHECKSUM), 0)
}
func PNMAddRABIN_FINGERPRINT(builder *flatbuffers.Builder, RABIN_FINGERPRINT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(RABIN_FINGERPRINT), 0)
}
func PNMAddPEARSON_HASHING(builder *flatbuffers.Builder, PEARSON_HASHING flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(PEARSON_HASHING), 0)
}
func PNMAddBLAKE2_KEYED_HASH(builder *flatbuffers.Builder, BLAKE2_KEYED_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(BLAKE2_KEYED_HASH), 0)
}
func PNMAddBLAKE_256(builder *flatbuffers.Builder, BLAKE_256 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(BLAKE_256), 0)
}
func PNMAddCRC8(builder *flatbuffers.Builder, CRC8 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(18, flatbuffers.UOffsetT(CRC8), 0)
}
func PNMAddCRC16(builder *flatbuffers.Builder, CRC16 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(19, flatbuffers.UOffsetT(CRC16), 0)
}
func PNMAddCRC64(builder *flatbuffers.Builder, CRC64 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(20, flatbuffers.UOffsetT(CRC64), 0)
}
func PNMAddBSD_CHECKSUM(builder *flatbuffers.Builder, BSD_CHECKSUM flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(BSD_CHECKSUM), 0)
}
func PNMAddSYSV_CHECKSUM(builder *flatbuffers.Builder, SYSV_CHECKSUM flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(22, flatbuffers.UOffsetT(SYSV_CHECKSUM), 0)
}
func PNMAddSUM8(builder *flatbuffers.Builder, SUM8 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(23, flatbuffers.UOffsetT(SUM8), 0)
}
func PNMAddINTERNET_CHECKSUM(builder *flatbuffers.Builder, INTERNET_CHECKSUM flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(24, flatbuffers.UOffsetT(INTERNET_CHECKSUM), 0)
}
func PNMAddSUM24(builder *flatbuffers.Builder, SUM24 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(25, flatbuffers.UOffsetT(SUM24), 0)
}
func PNMAddSUM32(builder *flatbuffers.Builder, SUM32 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(26, flatbuffers.UOffsetT(SUM32), 0)
}
func PNMAddFLETCHER_4(builder *flatbuffers.Builder, FLETCHER_4 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(27, flatbuffers.UOffsetT(FLETCHER_4), 0)
}
func PNMAddFLETCHER_8(builder *flatbuffers.Builder, FLETCHER_8 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(28, flatbuffers.UOffsetT(FLETCHER_8), 0)
}
func PNMAddFLETCHER_16(builder *flatbuffers.Builder, FLETCHER_16 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(29, flatbuffers.UOffsetT(FLETCHER_16), 0)
}
func PNMAddFLETCHER_32(builder *flatbuffers.Builder, FLETCHER_32 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(30, flatbuffers.UOffsetT(FLETCHER_32), 0)
}
func PNMAddLUNH_ALGORITHM(builder *flatbuffers.Builder, LUNH_ALGORITHM flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(31, flatbuffers.UOffsetT(LUNH_ALGORITHM), 0)
}
func PNMAddVERHOEFF_ALGORITHM(builder *flatbuffers.Builder, VERHOEFF_ALGORITHM flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(32, flatbuffers.UOffsetT(VERHOEFF_ALGORITHM), 0)
}
func PNMAddDAMM_ALGORITHM(builder *flatbuffers.Builder, DAMM_ALGORITHM flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(33, flatbuffers.UOffsetT(DAMM_ALGORITHM), 0)
}
func PNMAddTABULATION_HASHING(builder *flatbuffers.Builder, TABULATION_HASHING flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(34, flatbuffers.UOffsetT(TABULATION_HASHING), 0)
}
func PNMAddUNIVERSAL_ONE_WAY_HASH_FUNCTION(builder *flatbuffers.Builder, UNIVERSAL_ONE_WAY_HASH_FUNCTION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(35, flatbuffers.UOffsetT(UNIVERSAL_ONE_WAY_HASH_FUNCTION), 0)
}
func PNMAddZOBRIST_HASHING(builder *flatbuffers.Builder, ZOBRIST_HASHING flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(36, flatbuffers.UOffsetT(ZOBRIST_HASHING), 0)
}
func PNMAddPAUL_HSIEHS_SUPERFASTHASH(builder *flatbuffers.Builder, PAUL_HSIEHS_SUPERFASTHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(37, flatbuffers.UOffsetT(PAUL_HSIEHS_SUPERFASTHASH), 0)
}
func PNMAddBUZHASH(builder *flatbuffers.Builder, BUZHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(38, flatbuffers.UOffsetT(BUZHASH), 0)
}
func PNMAddFNV_HASH(builder *flatbuffers.Builder, FNV_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(39, flatbuffers.UOffsetT(FNV_HASH), 0)
}
func PNMAddJENKINS_HASH_FUNCTION(builder *flatbuffers.Builder, JENKINS_HASH_FUNCTION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(40, flatbuffers.UOffsetT(JENKINS_HASH_FUNCTION), 0)
}
func PNMAddBERNSTEINS_HASH_DJB2(builder *flatbuffers.Builder, BERNSTEINS_HASH_DJB2 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(41, flatbuffers.UOffsetT(BERNSTEINS_HASH_DJB2), 0)
}
func PNMAddPJW_HASH_ELF_HASH(builder *flatbuffers.Builder, PJW_HASH_ELF_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(42, flatbuffers.UOffsetT(PJW_HASH_ELF_HASH), 0)
}
func PNMAddMURMURHASH(builder *flatbuffers.Builder, MURMURHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(43, flatbuffers.UOffsetT(MURMURHASH), 0)
}
func PNMAddFAST_HASH(builder *flatbuffers.Builder, FAST_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(44, flatbuffers.UOffsetT(FAST_HASH), 0)
}
func PNMAddSPOOKYHASH(builder *flatbuffers.Builder, SPOOKYHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(45, flatbuffers.UOffsetT(SPOOKYHASH), 0)
}
func PNMAddCITYHASH(builder *flatbuffers.Builder, CITYHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(46, flatbuffers.UOffsetT(CITYHASH), 0)
}
func PNMAddFARMHASH(builder *flatbuffers.Builder, FARMHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(47, flatbuffers.UOffsetT(FARMHASH), 0)
}
func PNMAddMETROHASH(builder *flatbuffers.Builder, METROHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(48, flatbuffers.UOffsetT(METROHASH), 0)
}
func PNMAddNUMERIC_HASH(builder *flatbuffers.Builder, NUMERIC_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(49, flatbuffers.UOffsetT(NUMERIC_HASH), 0)
}
func PNMAddXXHASH(builder *flatbuffers.Builder, XXHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(50, flatbuffers.UOffsetT(XXHASH), 0)
}
func PNMAddT1HA(builder *flatbuffers.Builder, T1HA flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(51, flatbuffers.UOffsetT(T1HA), 0)
}
func PNMAddGXHASH(builder *flatbuffers.Builder, GXHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(52, flatbuffers.UOffsetT(GXHASH), 0)
}
func PNMAddPHASH(builder *flatbuffers.Builder, PHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(53, flatbuffers.UOffsetT(PHASH), 0)
}
func PNMAddDHASH(builder *flatbuffers.Builder, DHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(54, flatbuffers.UOffsetT(DHASH), 0)
}
func PNMAddSDBM(builder *flatbuffers.Builder, SDBM flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(55, flatbuffers.UOffsetT(SDBM), 0)
}
func PNMAddOSDB_HASH(builder *flatbuffers.Builder, OSDB_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(56, flatbuffers.UOffsetT(OSDB_HASH), 0)
}
func PNMAddKOMIHASH(builder *flatbuffers.Builder, KOMIHASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(57, flatbuffers.UOffsetT(KOMIHASH), 0)
}
func PNMAddBLAKE3(builder *flatbuffers.Builder, BLAKE3 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(58, flatbuffers.UOffsetT(BLAKE3), 0)
}
func PNMAddECOH(builder *flatbuffers.Builder, ECOH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(59, flatbuffers.UOffsetT(ECOH), 0)
}
func PNMAddFSB(builder *flatbuffers.Builder, FSB flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(60, flatbuffers.UOffsetT(FSB), 0)
}
func PNMAddGOST(builder *flatbuffers.Builder, GOST flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(61, flatbuffers.UOffsetT(GOST), 0)
}
func PNMAddGROSTL(builder *flatbuffers.Builder, GROSTL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(62, flatbuffers.UOffsetT(GROSTL), 0)
}
func PNMAddHAS_160(builder *flatbuffers.Builder, HAS_160 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(63, flatbuffers.UOffsetT(HAS_160), 0)
}
func PNMAddHAVAL(builder *flatbuffers.Builder, HAVAL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(64, flatbuffers.UOffsetT(HAVAL), 0)
}
func PNMAddJH(builder *flatbuffers.Builder, JH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(65, flatbuffers.UOffsetT(JH), 0)
}
func PNMAddLSH(builder *flatbuffers.Builder, LSH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(66, flatbuffers.UOffsetT(LSH), 0)
}
func PNMAddMD2(builder *flatbuffers.Builder, MD2 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(67, flatbuffers.UOffsetT(MD2), 0)
}
func PNMAddMD4(builder *flatbuffers.Builder, MD4 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(68, flatbuffers.UOffsetT(MD4), 0)
}
func PNMAddMD5(builder *flatbuffers.Builder, MD5 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(69, flatbuffers.UOffsetT(MD5), 0)
}
func PNMAddMD6(builder *flatbuffers.Builder, MD6 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(70, flatbuffers.UOffsetT(MD6), 0)
}
func PNMAddRADIOGATUN(builder *flatbuffers.Builder, RADIOGATUN flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(71, flatbuffers.UOffsetT(RADIOGATUN), 0)
}
func PNMAddRIPEMD(builder *flatbuffers.Builder, RIPEMD flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(72, flatbuffers.UOffsetT(RIPEMD), 0)
}
func PNMAddRIPEMD_128(builder *flatbuffers.Builder, RIPEMD_128 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(73, flatbuffers.UOffsetT(RIPEMD_128), 0)
}
func PNMAddRIPEMD_256(builder *flatbuffers.Builder, RIPEMD_256 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(74, flatbuffers.UOffsetT(RIPEMD_256), 0)
}
func PNMAddRIPEMD_320(builder *flatbuffers.Builder, RIPEMD_320 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(75, flatbuffers.UOffsetT(RIPEMD_320), 0)
}
func PNMAddSHA_1(builder *flatbuffers.Builder, SHA_1 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(76, flatbuffers.UOffsetT(SHA_1), 0)
}
func PNMAddSHA_224(builder *flatbuffers.Builder, SHA_224 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(77, flatbuffers.UOffsetT(SHA_224), 0)
}
func PNMAddSHA_256(builder *flatbuffers.Builder, SHA_256 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(78, flatbuffers.UOffsetT(SHA_256), 0)
}
func PNMAddSHA_384(builder *flatbuffers.Builder, SHA_384 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(79, flatbuffers.UOffsetT(SHA_384), 0)
}
func PNMAddSHA_512(builder *flatbuffers.Builder, SHA_512 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(80, flatbuffers.UOffsetT(SHA_512), 0)
}
func PNMAddSHA_3(builder *flatbuffers.Builder, SHA_3 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(81, flatbuffers.UOffsetT(SHA_3), 0)
}
func PNMAddSKEIN(builder *flatbuffers.Builder, SKEIN flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(82, flatbuffers.UOffsetT(SKEIN), 0)
}
func PNMAddSNEFRU(builder *flatbuffers.Builder, SNEFRU flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(83, flatbuffers.UOffsetT(SNEFRU), 0)
}
func PNMAddSPECTRAL_HASH(builder *flatbuffers.Builder, SPECTRAL_HASH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(84, flatbuffers.UOffsetT(SPECTRAL_HASH), 0)
}
func PNMAddSTREEBOG(builder *flatbuffers.Builder, STREEBOG flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(85, flatbuffers.UOffsetT(STREEBOG), 0)
}
func PNMAddSWIFFT(builder *flatbuffers.Builder, SWIFFT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(86, flatbuffers.UOffsetT(SWIFFT), 0)
}
func PNMAddTIGER(builder *flatbuffers.Builder, TIGER flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(87, flatbuffers.UOffsetT(TIGER), 0)
}
func PNMAddWHIRLPOOL(builder *flatbuffers.Builder, WHIRLPOOL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(88, flatbuffers.UOffsetT(WHIRLPOOL), 0)
}
func PNMEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
