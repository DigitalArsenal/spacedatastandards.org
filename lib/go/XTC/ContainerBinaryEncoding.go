// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package XTC

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Binary encoding specification for container
type ContainerBinaryEncoding struct {
	_tab flatbuffers.Table
}

func GetRootAsContainerBinaryEncoding(buf []byte, offset flatbuffers.UOffsetT) *ContainerBinaryEncoding {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ContainerBinaryEncoding{}
	x.Init(buf, n+offset)
	return x
}

func FinishContainerBinaryEncodingBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsContainerBinaryEncoding(buf []byte, offset flatbuffers.UOffsetT) *ContainerBinaryEncoding {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ContainerBinaryEncoding{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedContainerBinaryEncodingBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *ContainerBinaryEncoding) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ContainerBinaryEncoding) Table() flatbuffers.Table {
	return rcv._tab
}

/// Error detection type
func (rcv *ContainerBinaryEncoding) ERROR_DETECTION() ErrorDetectionType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return ErrorDetectionType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Error detection type
func (rcv *ContainerBinaryEncoding) MutateERROR_DETECTION(n ErrorDetectionType) bool {
	return rcv._tab.MutateInt8Slot(4, int8(n))
}

/// CRC polynomial (for CRC error detection)
func (rcv *ContainerBinaryEncoding) CRC_POLYNOMIAL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// CRC polynomial (for CRC error detection)
/// Size in bits
func (rcv *ContainerBinaryEncoding) SIZE_IN_BITS() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Size in bits
func (rcv *ContainerBinaryEncoding) MutateSIZE_IN_BITS(n uint32) bool {
	return rcv._tab.MutateUint32Slot(8, n)
}

func ContainerBinaryEncodingStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ContainerBinaryEncodingAddERROR_DETECTION(builder *flatbuffers.Builder, ERROR_DETECTION ErrorDetectionType) {
	builder.PrependInt8Slot(0, int8(ERROR_DETECTION), 0)
}
func ContainerBinaryEncodingAddCRC_POLYNOMIAL(builder *flatbuffers.Builder, CRC_POLYNOMIAL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(CRC_POLYNOMIAL), 0)
}
func ContainerBinaryEncodingAddSIZE_IN_BITS(builder *flatbuffers.Builder, SIZE_IN_BITS uint32) {
	builder.PrependUint32Slot(2, SIZE_IN_BITS, 0)
}
func ContainerBinaryEncodingEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
