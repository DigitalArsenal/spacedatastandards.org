// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package XTCHeader

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Document header information
type XTCHeader struct {
	_tab flatbuffers.Table
}

func GetRootAsXTCHeader(buf []byte, offset flatbuffers.UOffsetT) *XTCHeader {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &XTCHeader{}
	x.Init(buf, n+offset)
	return x
}

func FinishXTCHeaderBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsXTCHeader(buf []byte, offset flatbuffers.UOffsetT) *XTCHeader {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &XTCHeader{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedXTCHeaderBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *XTCHeader) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *XTCHeader) Table() flatbuffers.Table {
	return rcv._tab
}

/// Version of this XTCE document
func (rcv *XTCHeader) VERSION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Version of this XTCE document
/// Date of document creation (ISO 8601)
func (rcv *XTCHeader) DATE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Date of document creation (ISO 8601)
/// Classification level
func (rcv *XTCHeader) CLASSIFICATION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Classification level
/// Validation status
func (rcv *XTCHeader) VALIDATION_STATUS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Validation status
/// Author information
func (rcv *XTCHeader) AUTHOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Author information
/// Notes/comments
func (rcv *XTCHeader) NOTES(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *XTCHeader) NOTESLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Notes/comments
func XTCHeaderStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func XTCHeaderAddVERSION(builder *flatbuffers.Builder, VERSION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(VERSION), 0)
}
func XTCHeaderAddDATE(builder *flatbuffers.Builder, DATE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(DATE), 0)
}
func XTCHeaderAddCLASSIFICATION(builder *flatbuffers.Builder, CLASSIFICATION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(CLASSIFICATION), 0)
}
func XTCHeaderAddVALIDATION_STATUS(builder *flatbuffers.Builder, VALIDATION_STATUS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(VALIDATION_STATUS), 0)
}
func XTCHeaderAddAUTHOR(builder *flatbuffers.Builder, AUTHOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(AUTHOR), 0)
}
func XTCHeaderAddNOTES(builder *flatbuffers.Builder, NOTES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(NOTES), 0)
}
func XTCHeaderStartNOTESVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func XTCHeaderEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
