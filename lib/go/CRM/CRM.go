// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package CRM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Collection Request Message
type CRM struct {
	_tab flatbuffers.Table
}

func GetRootAsCRM(buf []byte, offset flatbuffers.UOffsetT) *CRM {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CRM{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCRM(buf []byte, offset flatbuffers.UOffsetT) *CRM {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CRM{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CRM) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CRM) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier of the record, auto-generated by the system.
func (rcv *CRM) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier of the record, auto-generated by the system.
/// Classification marking of the data in IC/CAPCO Portion-marked format.
func (rcv *CRM) CLASSIFICATION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Classification marking of the data in IC/CAPCO Portion-marked format.
/// The type of this collect or contact request.
func (rcv *CRM) TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The type of this collect or contact request.
/// Unique identifier of the parent plan or schedule associated with this request.
func (rcv *CRM) ID_PLAN() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier of the parent plan or schedule associated with this request.
/// Index number for records within a collection plan or schedule.
func (rcv *CRM) PLAN_INDEX() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Index number for records within a collection plan or schedule.
func (rcv *CRM) MutatePLAN_INDEX(n int32) bool {
	return rcv._tab.MutateInt32Slot(12, n)
}

/// Task ID associated with this request.
func (rcv *CRM) TASK_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Task ID associated with this request.
/// The dwell ID associated with this request.
func (rcv *CRM) DWELL_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The dwell ID associated with this request.
/// Optional ID from external systems.
func (rcv *CRM) EXTERNAL_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional ID from external systems.
/// Unique identifier of the requested/scheduled/planned sensor associated with this request.
func (rcv *CRM) ID_SENSOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier of the requested/scheduled/planned sensor associated with this request.
/// Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request.
func (rcv *CRM) ORIG_SENSOR_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request.
/// Optional type of observation requested.
func (rcv *CRM) OB_TYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional type of observation requested.
/// The priority of the collect request.
func (rcv *CRM) PRIORITY() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The priority of the collect request.
/// The tasking category associated with this request.
func (rcv *CRM) TASK_CATEGORY() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// The tasking category associated with this request.
func (rcv *CRM) MutateTASK_CATEGORY(n int32) bool {
	return rcv._tab.MutateInt32Slot(28, n)
}

/// The tasking suffix associated with this request.
func (rcv *CRM) SUFFIX() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The tasking suffix associated with this request.
/// Boolean indicating that this collect request is UCT follow-up.
func (rcv *CRM) UCT_FOLLOW_UP() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Boolean indicating that this collect request is UCT follow-up.
func (rcv *CRM) MutateUCT_FOLLOW_UP(n bool) bool {
	return rcv._tab.MutateBoolSlot(32, n)
}

/// The start time of the collect or contact request window, in ISO 8601 UTC format.
func (rcv *CRM) START_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The start time of the collect or contact request window, in ISO 8601 UTC format.
/// The end time of the collect or contact request window, in ISO 8601 UTC format.
func (rcv *CRM) END_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The end time of the collect or contact request window, in ISO 8601 UTC format.
/// Satellite/catalog number of the target on-orbit object for this request.
func (rcv *CRM) NORAD_CAT_ID() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Satellite/catalog number of the target on-orbit object for this request.
func (rcv *CRM) MutateNORAD_CAT_ID(n uint32) bool {
	return rcv._tab.MutateUint32Slot(38, n)
}

/// Optional identifier provided by the data source to indicate the target object of this request.
func (rcv *CRM) ORIG_OBJECT_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional identifier provided by the data source to indicate the target object of this request.
/// The tasking group to which the target object is assigned.
func (rcv *CRM) TASK_GROUP() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The tasking group to which the target object is assigned.
/// Inter-Range Operations Number.
func (rcv *CRM) IRON() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Inter-Range Operations Number.
func (rcv *CRM) MutateIRON(n int32) bool {
	return rcv._tab.MutateInt32Slot(44, n)
}

/// The orbit regime of the target.
func (rcv *CRM) ORBIT_REGIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The orbit regime of the target.
/// The minimum object (diameter) size, in meters, to be reported.
func (rcv *CRM) TARGET_SIZE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The minimum object (diameter) size, in meters, to be reported.
func (rcv *CRM) MutateTARGET_SIZE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

/// The minimum Radar Cross-Section of the target, in m^2.
func (rcv *CRM) RCS_MIN() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The minimum Radar Cross-Section of the target, in m^2.
func (rcv *CRM) MutateRCS_MIN(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

/// The Radar Cross-Section of the target, in m^2.
func (rcv *CRM) RCS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The Radar Cross-Section of the target, in m^2.
func (rcv *CRM) MutateRCS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(52, n)
}

/// The maximum Radar Cross-Section of the target, in m^2.
func (rcv *CRM) RCS_MAX() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The maximum Radar Cross-Section of the target, in m^2.
func (rcv *CRM) MutateRCS_MAX(n float64) bool {
	return rcv._tab.MutateFloat64Slot(54, n)
}

/// The minimum frequency of interest, in MHz.
func (rcv *CRM) FREQ_MIN() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The minimum frequency of interest, in MHz.
func (rcv *CRM) MutateFREQ_MIN(n float64) bool {
	return rcv._tab.MutateFloat64Slot(56, n)
}

/// The estimated or expected emission frequency of the target, in MHz.
func (rcv *CRM) FREQ() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The estimated or expected emission frequency of the target, in MHz.
func (rcv *CRM) MutateFREQ(n float64) bool {
	return rcv._tab.MutateFloat64Slot(58, n)
}

/// The maximum frequency of interest, in MHz.
func (rcv *CRM) FREQ_MAX() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The maximum frequency of interest, in MHz.
func (rcv *CRM) MutateFREQ_MAX(n float64) bool {
	return rcv._tab.MutateFloat64Slot(60, n)
}

/// The RF polarization.
func (rcv *CRM) POLARIZATION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The RF polarization.
/// The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).
func (rcv *CRM) VIS_MAG_MIN() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).
func (rcv *CRM) MutateVIS_MAG_MIN(n float64) bool {
	return rcv._tab.MutateFloat64Slot(64, n)
}

/// The estimated or expected visual magnitude of the target, in Magnitudes (M).
func (rcv *CRM) VIS_MAG() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The estimated or expected visual magnitude of the target, in Magnitudes (M).
func (rcv *CRM) MutateVIS_MAG(n float64) bool {
	return rcv._tab.MutateFloat64Slot(66, n)
}

/// The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
func (rcv *CRM) VIS_MAG_MAX() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
func (rcv *CRM) MutateVIS_MAG_MAX(n float64) bool {
	return rcv._tab.MutateFloat64Slot(68, n)
}

/// The spectral model used for the irradiance calculation.
func (rcv *CRM) SPECTRAL_MODEL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The spectral model used for the irradiance calculation.
/// The fraction of solar energy reflected from target.
func (rcv *CRM) REFLECTANCE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The fraction of solar energy reflected from target.
func (rcv *CRM) MutateREFLECTANCE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(72, n)
}

/// The target object irradiance value.
func (rcv *CRM) IRRADIANCE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The target object irradiance value.
func (rcv *CRM) MutateIRRADIANCE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(74, n)
}

/// For optical sensors, the requested number of frames to capture at each sensor step.
func (rcv *CRM) NUM_FRAMES() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// For optical sensors, the requested number of frames to capture at each sensor step.
func (rcv *CRM) MutateNUM_FRAMES(n int32) bool {
	return rcv._tab.MutateInt32Slot(76, n)
}

/// For optical sensors, the frame rate of the camera, in Hz.
func (rcv *CRM) FRAME_RATE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// For optical sensors, the frame rate of the camera, in Hz.
func (rcv *CRM) MutateFRAME_RATE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(78, n)
}

/// For optical sensors, the integration time per camera frame, in milliseconds.
func (rcv *CRM) INTEGRATION_TIME() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// For optical sensors, the integration time per camera frame, in milliseconds.
func (rcv *CRM) MutateINTEGRATION_TIME(n float64) bool {
	return rcv._tab.MutateFloat64Slot(80, n)
}

/// The number of requested tracks on the target.
func (rcv *CRM) NUM_TRACKS() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// The number of requested tracks on the target.
func (rcv *CRM) MutateNUM_TRACKS(n int32) bool {
	return rcv._tab.MutateInt32Slot(82, n)
}

/// The number of requested observations on the target.
func (rcv *CRM) NUM_OBS() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// The number of requested observations on the target.
func (rcv *CRM) MutateNUM_OBS(n int32) bool {
	return rcv._tab.MutateInt32Slot(84, n)
}

/// The duration of the collect request, in seconds.
func (rcv *CRM) DURATION() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// The duration of the collect request, in seconds.
func (rcv *CRM) MutateDURATION(n int32) bool {
	return rcv._tab.MutateInt32Slot(86, n)
}

/// The search pattern to be executed for this request.
func (rcv *CRM) SRCH_PATTERN() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The search pattern to be executed for this request.
/// Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
func (rcv *CRM) SCENARIO() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(90))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
/// ID of the Elset of the object associated with this request.
func (rcv *CRM) ID_ELSET() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(92))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// ID of the Elset of the object associated with this request.
/// ID of the Manifold Elset of the object associated with this request.
func (rcv *CRM) ID_MANIFOLD() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(94))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// ID of the Manifold Elset of the object associated with this request.
/// ID of the State Vector of the object or central vector associated with this request.
func (rcv *CRM) ID_STATE_VECTOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(96))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// ID of the State Vector of the object or central vector associated with this request.
/// ID of the Ephemeris Set of the object associated with this request.
func (rcv *CRM) ES_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// ID of the Ephemeris Set of the object associated with this request.
/// Epoch time, in ISO 8601 UTC format, of the orbital elements.
func (rcv *CRM) EPOCH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(100))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Epoch time, in ISO 8601 UTC format, of the orbital elements.
/// The average of the periapsis and apoapsis distances, in kilometers.
func (rcv *CRM) SEMI_MAJOR_AXIS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The average of the periapsis and apoapsis distances, in kilometers.
func (rcv *CRM) MutateSEMI_MAJOR_AXIS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(102, n)
}

/// The orbital eccentricity of an astronomical object.
func (rcv *CRM) ECCENTRICITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The orbital eccentricity of an astronomical object.
func (rcv *CRM) MutateECCENTRICITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(104, n)
}

/// The angle, in degrees, between the equator and the orbit plane.
func (rcv *CRM) INCLINATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The angle, in degrees, between the equator and the orbit plane.
func (rcv *CRM) MutateINCLINATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(106, n)
}

/// Right ascension of the ascending node, in degrees.
func (rcv *CRM) RAAN() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Right ascension of the ascending node, in degrees.
func (rcv *CRM) MutateRAAN(n float64) bool {
	return rcv._tab.MutateFloat64Slot(108, n)
}

/// The argument of perigee, in degrees.
func (rcv *CRM) ARG_OF_PERIGEE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The argument of perigee, in degrees.
func (rcv *CRM) MutateARG_OF_PERIGEE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(110, n)
}

/// The mean anomaly defines the angular position, in degrees, of the object on its orbital path.
func (rcv *CRM) MEAN_ANOMALY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The mean anomaly defines the angular position, in degrees, of the object on its orbital path.
func (rcv *CRM) MutateMEAN_ANOMALY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(112, n)
}

/// The expected or directed right ascension angle, in degrees.
func (rcv *CRM) RA() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The expected or directed right ascension angle, in degrees.
func (rcv *CRM) MutateRA(n float64) bool {
	return rcv._tab.MutateFloat64Slot(114, n)
}

/// The expected or directed declination angle, in degrees.
func (rcv *CRM) DEC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The expected or directed declination angle, in degrees.
func (rcv *CRM) MutateDEC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(116, n)
}

/// The expected or directed azimuth angle, in degrees.
func (rcv *CRM) AZ() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The expected or directed azimuth angle, in degrees.
func (rcv *CRM) MutateAZ(n float64) bool {
	return rcv._tab.MutateFloat64Slot(118, n)
}

/// The expected or directed elevation angle, in degrees.
func (rcv *CRM) EL() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(120))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The expected or directed elevation angle, in degrees.
func (rcv *CRM) MutateEL(n float64) bool {
	return rcv._tab.MutateFloat64Slot(120, n)
}

/// The expected acquisition range or defined center range, in km.
func (rcv *CRM) RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(122))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The expected acquisition range or defined center range, in km.
func (rcv *CRM) MutateRANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(122, n)
}

/// The extent of the azimuth angle, in degrees, from center azimuth.
func (rcv *CRM) EXTENT_AZ() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(124))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The extent of the azimuth angle, in degrees, from center azimuth.
func (rcv *CRM) MutateEXTENT_AZ(n float64) bool {
	return rcv._tab.MutateFloat64Slot(124, n)
}

/// The extent of the elevation angle, in degrees, from center elevation.
func (rcv *CRM) EXTENT_EL() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(126))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The extent of the elevation angle, in degrees, from center elevation.
func (rcv *CRM) MutateEXTENT_EL(n float64) bool {
	return rcv._tab.MutateFloat64Slot(126, n)
}

/// The extent of the range, in km, from center range.
func (rcv *CRM) EXTENT_RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(128))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The extent of the range, in km, from center range.
func (rcv *CRM) MutateEXTENT_RANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(128, n)
}

/// WGS-84 latitude, in degrees.
func (rcv *CRM) LAT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(130))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// WGS-84 latitude, in degrees.
func (rcv *CRM) MutateLAT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(130, n)
}

/// WGS-84 longitude, in degrees.
func (rcv *CRM) LON() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(132))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// WGS-84 longitude, in degrees.
func (rcv *CRM) MutateLON(n float64) bool {
	return rcv._tab.MutateFloat64Slot(132, n)
}

/// Height above WGS-84 ellipsoid (HAE), in kilometers.
func (rcv *CRM) ALT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(134))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Height above WGS-84 ellipsoid (HAE), in kilometers.
func (rcv *CRM) MutateALT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(134, n)
}

/// The stopping WGS-84 latitude of a volume definition, in degrees.
func (rcv *CRM) STOP_LAT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(136))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The stopping WGS-84 latitude of a volume definition, in degrees.
func (rcv *CRM) MutateSTOP_LAT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(136, n)
}

/// The stopping WGS-84 longitude of a volume definition, in degrees.
func (rcv *CRM) STOP_LON() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(138))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The stopping WGS-84 longitude of a volume definition, in degrees.
func (rcv *CRM) MutateSTOP_LON(n float64) bool {
	return rcv._tab.MutateFloat64Slot(138, n)
}

/// The stopping HAE WGS-84 height above ellipsoid (HAE), in kilometers.
func (rcv *CRM) STOP_ALT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(140))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The stopping HAE WGS-84 height above ellipsoid (HAE), in kilometers.
func (rcv *CRM) MutateSTOP_ALT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(140, n)
}

/// The maximum inclination, in degrees, to be used in search operations.
func (rcv *CRM) SRCH_INC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(142))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The maximum inclination, in degrees, to be used in search operations.
func (rcv *CRM) MutateSRCH_INC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(142, n)
}

/// The angular distance, in degrees, in the sensor-x direction from scan center.
func (rcv *CRM) X_ANGLE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(144))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The angular distance, in degrees, in the sensor-x direction from scan center.
func (rcv *CRM) MutateX_ANGLE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(144, n)
}

/// The angular distance, in degrees, in the sensor-y direction from scan center.
func (rcv *CRM) Y_ANGLE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(146))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The angular distance, in degrees, in the sensor-y direction from scan center.
func (rcv *CRM) MutateY_ANGLE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(146, n)
}

/// The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.
func (rcv *CRM) ORIENT_ANGLE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(148))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.
func (rcv *CRM) MutateORIENT_ANGLE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(148, n)
}

/// The customer for this request.
func (rcv *CRM) CUSTOMER() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(150))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The customer for this request.
/// Notes or comments associated with this request.
func (rcv *CRM) NOTES() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(152))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Notes or comments associated with this request.
///  Source of the data.
func (rcv *CRM) SOURCE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(154))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

///  Source of the data.
///  Originating system or organization which produced the data, if different from the source.
func (rcv *CRM) ORIGIN() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(156))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

///  Originating system or organization which produced the data, if different from the source.
///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data.
func (rcv *CRM) DATA_MODE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(158))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data.
func CRMStart(builder *flatbuffers.Builder) {
	builder.StartObject(78)
}
func CRMAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func CRMAddCLASSIFICATION(builder *flatbuffers.Builder, CLASSIFICATION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(CLASSIFICATION), 0)
}
func CRMAddTYPE(builder *flatbuffers.Builder, TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(TYPE), 0)
}
func CRMAddID_PLAN(builder *flatbuffers.Builder, ID_PLAN flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(ID_PLAN), 0)
}
func CRMAddPLAN_INDEX(builder *flatbuffers.Builder, PLAN_INDEX int32) {
	builder.PrependInt32Slot(4, PLAN_INDEX, 0)
}
func CRMAddTASK_ID(builder *flatbuffers.Builder, TASK_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(TASK_ID), 0)
}
func CRMAddDWELL_ID(builder *flatbuffers.Builder, DWELL_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(DWELL_ID), 0)
}
func CRMAddEXTERNAL_ID(builder *flatbuffers.Builder, EXTERNAL_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(EXTERNAL_ID), 0)
}
func CRMAddID_SENSOR(builder *flatbuffers.Builder, ID_SENSOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(ID_SENSOR), 0)
}
func CRMAddORIG_SENSOR_ID(builder *flatbuffers.Builder, ORIG_SENSOR_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(ORIG_SENSOR_ID), 0)
}
func CRMAddOB_TYPE(builder *flatbuffers.Builder, OB_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(OB_TYPE), 0)
}
func CRMAddPRIORITY(builder *flatbuffers.Builder, PRIORITY flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(PRIORITY), 0)
}
func CRMAddTASK_CATEGORY(builder *flatbuffers.Builder, TASK_CATEGORY int32) {
	builder.PrependInt32Slot(12, TASK_CATEGORY, 0)
}
func CRMAddSUFFIX(builder *flatbuffers.Builder, SUFFIX flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(SUFFIX), 0)
}
func CRMAddUCT_FOLLOW_UP(builder *flatbuffers.Builder, UCT_FOLLOW_UP bool) {
	builder.PrependBoolSlot(14, UCT_FOLLOW_UP, false)
}
func CRMAddSTART_TIME(builder *flatbuffers.Builder, START_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(START_TIME), 0)
}
func CRMAddEND_TIME(builder *flatbuffers.Builder, END_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(END_TIME), 0)
}
func CRMAddNORAD_CAT_ID(builder *flatbuffers.Builder, NORAD_CAT_ID uint32) {
	builder.PrependUint32Slot(17, NORAD_CAT_ID, 0)
}
func CRMAddORIG_OBJECT_ID(builder *flatbuffers.Builder, ORIG_OBJECT_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(18, flatbuffers.UOffsetT(ORIG_OBJECT_ID), 0)
}
func CRMAddTASK_GROUP(builder *flatbuffers.Builder, TASK_GROUP flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(19, flatbuffers.UOffsetT(TASK_GROUP), 0)
}
func CRMAddIRON(builder *flatbuffers.Builder, IRON int32) {
	builder.PrependInt32Slot(20, IRON, 0)
}
func CRMAddORBIT_REGIME(builder *flatbuffers.Builder, ORBIT_REGIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(ORBIT_REGIME), 0)
}
func CRMAddTARGET_SIZE(builder *flatbuffers.Builder, TARGET_SIZE float64) {
	builder.PrependFloat64Slot(22, TARGET_SIZE, 0.0)
}
func CRMAddRCS_MIN(builder *flatbuffers.Builder, RCS_MIN float64) {
	builder.PrependFloat64Slot(23, RCS_MIN, 0.0)
}
func CRMAddRCS(builder *flatbuffers.Builder, RCS float64) {
	builder.PrependFloat64Slot(24, RCS, 0.0)
}
func CRMAddRCS_MAX(builder *flatbuffers.Builder, RCS_MAX float64) {
	builder.PrependFloat64Slot(25, RCS_MAX, 0.0)
}
func CRMAddFREQ_MIN(builder *flatbuffers.Builder, FREQ_MIN float64) {
	builder.PrependFloat64Slot(26, FREQ_MIN, 0.0)
}
func CRMAddFREQ(builder *flatbuffers.Builder, FREQ float64) {
	builder.PrependFloat64Slot(27, FREQ, 0.0)
}
func CRMAddFREQ_MAX(builder *flatbuffers.Builder, FREQ_MAX float64) {
	builder.PrependFloat64Slot(28, FREQ_MAX, 0.0)
}
func CRMAddPOLARIZATION(builder *flatbuffers.Builder, POLARIZATION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(29, flatbuffers.UOffsetT(POLARIZATION), 0)
}
func CRMAddVIS_MAG_MIN(builder *flatbuffers.Builder, VIS_MAG_MIN float64) {
	builder.PrependFloat64Slot(30, VIS_MAG_MIN, 0.0)
}
func CRMAddVIS_MAG(builder *flatbuffers.Builder, VIS_MAG float64) {
	builder.PrependFloat64Slot(31, VIS_MAG, 0.0)
}
func CRMAddVIS_MAG_MAX(builder *flatbuffers.Builder, VIS_MAG_MAX float64) {
	builder.PrependFloat64Slot(32, VIS_MAG_MAX, 0.0)
}
func CRMAddSPECTRAL_MODEL(builder *flatbuffers.Builder, SPECTRAL_MODEL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(33, flatbuffers.UOffsetT(SPECTRAL_MODEL), 0)
}
func CRMAddREFLECTANCE(builder *flatbuffers.Builder, REFLECTANCE float64) {
	builder.PrependFloat64Slot(34, REFLECTANCE, 0.0)
}
func CRMAddIRRADIANCE(builder *flatbuffers.Builder, IRRADIANCE float64) {
	builder.PrependFloat64Slot(35, IRRADIANCE, 0.0)
}
func CRMAddNUM_FRAMES(builder *flatbuffers.Builder, NUM_FRAMES int32) {
	builder.PrependInt32Slot(36, NUM_FRAMES, 0)
}
func CRMAddFRAME_RATE(builder *flatbuffers.Builder, FRAME_RATE float64) {
	builder.PrependFloat64Slot(37, FRAME_RATE, 0.0)
}
func CRMAddINTEGRATION_TIME(builder *flatbuffers.Builder, INTEGRATION_TIME float64) {
	builder.PrependFloat64Slot(38, INTEGRATION_TIME, 0.0)
}
func CRMAddNUM_TRACKS(builder *flatbuffers.Builder, NUM_TRACKS int32) {
	builder.PrependInt32Slot(39, NUM_TRACKS, 0)
}
func CRMAddNUM_OBS(builder *flatbuffers.Builder, NUM_OBS int32) {
	builder.PrependInt32Slot(40, NUM_OBS, 0)
}
func CRMAddDURATION(builder *flatbuffers.Builder, DURATION int32) {
	builder.PrependInt32Slot(41, DURATION, 0)
}
func CRMAddSRCH_PATTERN(builder *flatbuffers.Builder, SRCH_PATTERN flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(42, flatbuffers.UOffsetT(SRCH_PATTERN), 0)
}
func CRMAddSCENARIO(builder *flatbuffers.Builder, SCENARIO flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(43, flatbuffers.UOffsetT(SCENARIO), 0)
}
func CRMAddID_ELSET(builder *flatbuffers.Builder, ID_ELSET flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(44, flatbuffers.UOffsetT(ID_ELSET), 0)
}
func CRMAddID_MANIFOLD(builder *flatbuffers.Builder, ID_MANIFOLD flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(45, flatbuffers.UOffsetT(ID_MANIFOLD), 0)
}
func CRMAddID_STATE_VECTOR(builder *flatbuffers.Builder, ID_STATE_VECTOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(46, flatbuffers.UOffsetT(ID_STATE_VECTOR), 0)
}
func CRMAddES_ID(builder *flatbuffers.Builder, ES_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(47, flatbuffers.UOffsetT(ES_ID), 0)
}
func CRMAddEPOCH(builder *flatbuffers.Builder, EPOCH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(48, flatbuffers.UOffsetT(EPOCH), 0)
}
func CRMAddSEMI_MAJOR_AXIS(builder *flatbuffers.Builder, SEMI_MAJOR_AXIS float64) {
	builder.PrependFloat64Slot(49, SEMI_MAJOR_AXIS, 0.0)
}
func CRMAddECCENTRICITY(builder *flatbuffers.Builder, ECCENTRICITY float64) {
	builder.PrependFloat64Slot(50, ECCENTRICITY, 0.0)
}
func CRMAddINCLINATION(builder *flatbuffers.Builder, INCLINATION float64) {
	builder.PrependFloat64Slot(51, INCLINATION, 0.0)
}
func CRMAddRAAN(builder *flatbuffers.Builder, RAAN float64) {
	builder.PrependFloat64Slot(52, RAAN, 0.0)
}
func CRMAddARG_OF_PERIGEE(builder *flatbuffers.Builder, ARG_OF_PERIGEE float64) {
	builder.PrependFloat64Slot(53, ARG_OF_PERIGEE, 0.0)
}
func CRMAddMEAN_ANOMALY(builder *flatbuffers.Builder, MEAN_ANOMALY float64) {
	builder.PrependFloat64Slot(54, MEAN_ANOMALY, 0.0)
}
func CRMAddRA(builder *flatbuffers.Builder, RA float64) {
	builder.PrependFloat64Slot(55, RA, 0.0)
}
func CRMAddDEC(builder *flatbuffers.Builder, DEC float64) {
	builder.PrependFloat64Slot(56, DEC, 0.0)
}
func CRMAddAZ(builder *flatbuffers.Builder, AZ float64) {
	builder.PrependFloat64Slot(57, AZ, 0.0)
}
func CRMAddEL(builder *flatbuffers.Builder, EL float64) {
	builder.PrependFloat64Slot(58, EL, 0.0)
}
func CRMAddRANGE(builder *flatbuffers.Builder, RANGE float64) {
	builder.PrependFloat64Slot(59, RANGE, 0.0)
}
func CRMAddEXTENT_AZ(builder *flatbuffers.Builder, EXTENT_AZ float64) {
	builder.PrependFloat64Slot(60, EXTENT_AZ, 0.0)
}
func CRMAddEXTENT_EL(builder *flatbuffers.Builder, EXTENT_EL float64) {
	builder.PrependFloat64Slot(61, EXTENT_EL, 0.0)
}
func CRMAddEXTENT_RANGE(builder *flatbuffers.Builder, EXTENT_RANGE float64) {
	builder.PrependFloat64Slot(62, EXTENT_RANGE, 0.0)
}
func CRMAddLAT(builder *flatbuffers.Builder, LAT float64) {
	builder.PrependFloat64Slot(63, LAT, 0.0)
}
func CRMAddLON(builder *flatbuffers.Builder, LON float64) {
	builder.PrependFloat64Slot(64, LON, 0.0)
}
func CRMAddALT(builder *flatbuffers.Builder, ALT float64) {
	builder.PrependFloat64Slot(65, ALT, 0.0)
}
func CRMAddSTOP_LAT(builder *flatbuffers.Builder, STOP_LAT float64) {
	builder.PrependFloat64Slot(66, STOP_LAT, 0.0)
}
func CRMAddSTOP_LON(builder *flatbuffers.Builder, STOP_LON float64) {
	builder.PrependFloat64Slot(67, STOP_LON, 0.0)
}
func CRMAddSTOP_ALT(builder *flatbuffers.Builder, STOP_ALT float64) {
	builder.PrependFloat64Slot(68, STOP_ALT, 0.0)
}
func CRMAddSRCH_INC(builder *flatbuffers.Builder, SRCH_INC float64) {
	builder.PrependFloat64Slot(69, SRCH_INC, 0.0)
}
func CRMAddX_ANGLE(builder *flatbuffers.Builder, X_ANGLE float64) {
	builder.PrependFloat64Slot(70, X_ANGLE, 0.0)
}
func CRMAddY_ANGLE(builder *flatbuffers.Builder, Y_ANGLE float64) {
	builder.PrependFloat64Slot(71, Y_ANGLE, 0.0)
}
func CRMAddORIENT_ANGLE(builder *flatbuffers.Builder, ORIENT_ANGLE float64) {
	builder.PrependFloat64Slot(72, ORIENT_ANGLE, 0.0)
}
func CRMAddCUSTOMER(builder *flatbuffers.Builder, CUSTOMER flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(73, flatbuffers.UOffsetT(CUSTOMER), 0)
}
func CRMAddNOTES(builder *flatbuffers.Builder, NOTES flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(74, flatbuffers.UOffsetT(NOTES), 0)
}
func CRMAddSOURCE(builder *flatbuffers.Builder, SOURCE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(75, flatbuffers.UOffsetT(SOURCE), 0)
}
func CRMAddORIGIN(builder *flatbuffers.Builder, ORIGIN flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(76, flatbuffers.UOffsetT(ORIGIN), 0)
}
func CRMAddDATA_MODE(builder *flatbuffers.Builder, DATA_MODE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(77, flatbuffers.UOffsetT(DATA_MODE), 0)
}
func CRMEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
