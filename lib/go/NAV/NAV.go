// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package NAV

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Naval Vessels
type NAV struct {
	_tab flatbuffers.Table
}

const NAVIdentifier = "$NAV"

func GetRootAsNAV(buf []byte, offset flatbuffers.UOffsetT) *NAV {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &NAV{}
	x.Init(buf, n+offset)
	return x
}

func FinishNAVBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(NAVIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func NAVBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, NAVIdentifier)
}

func GetSizePrefixedRootAsNAV(buf []byte, offset flatbuffers.UOffsetT) *NAV {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &NAV{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedNAVBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(NAVIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedNAVBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, NAVIdentifier)
}

func (rcv *NAV) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *NAV) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *NAV) POSITION_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutatePOSITION_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(4, n)
}

func (rcv *NAV) POSITION_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutatePOSITION_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

func (rcv *NAV) POSITION_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutatePOSITION_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(8, n)
}

func (rcv *NAV) VELOCITY_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateVELOCITY_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

func (rcv *NAV) VELOCITY_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateVELOCITY_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

func (rcv *NAV) VELOCITY_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateVELOCITY_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

func (rcv *NAV) ATTITUDE_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateATTITUDE_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

func (rcv *NAV) ATTITUDE_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateATTITUDE_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

func (rcv *NAV) ATTITUDE_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateATTITUDE_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

func (rcv *NAV) ATTITUDE_W() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateATTITUDE_W(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

func (rcv *NAV) OMEGA_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateOMEGA_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

func (rcv *NAV) OMEGA_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateOMEGA_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

func (rcv *NAV) OMEGA_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateOMEGA_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

func (rcv *NAV) SPEED_KNOTS() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateSPEED_KNOTS(n float32) bool {
	return rcv._tab.MutateFloat32Slot(30, n)
}

func (rcv *NAV) HEADING() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateHEADING(n float32) bool {
	return rcv._tab.MutateFloat32Slot(32, n)
}

func (rcv *NAV) COURSE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateCOURSE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(34, n)
}

func (rcv *NAV) RUDDER_ANGLE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateRUDDER_ANGLE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(36, n)
}

func (rcv *NAV) HULL() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *NAV) PROPULSION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *NAV) DC_STATE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutateDC_STATE(n byte) bool {
	return rcv._tab.MutateByteSlot(42, n)
}

func (rcv *NAV) FIRES_ACTIVE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutateFIRES_ACTIVE(n byte) bool {
	return rcv._tab.MutateByteSlot(44, n)
}

func (rcv *NAV) FLOODING_ACTIVE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutateFLOODING_ACTIVE(n byte) bool {
	return rcv._tab.MutateByteSlot(46, n)
}

func (rcv *NAV) CREW_CASUALTIES() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutateCREW_CASUALTIES(n byte) bool {
	return rcv._tab.MutateByteSlot(48, n)
}

func (rcv *NAV) HULL_INTEGRITY() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateHULL_INTEGRITY(n float32) bool {
	return rcv._tab.MutateFloat32Slot(50, n)
}

func (rcv *NAV) POWER_AVAILABLE() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutatePOWER_AVAILABLE(n float32) bool {
	return rcv._tab.MutateFloat32Slot(52, n)
}

func (rcv *NAV) WEAPONS_ONLINE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutateWEAPONS_ONLINE(n byte) bool {
	return rcv._tab.MutateByteSlot(54, n)
}

func (rcv *NAV) SENSORS_ONLINE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutateSENSORS_ONLINE(n byte) bool {
	return rcv._tab.MutateByteSlot(56, n)
}

func (rcv *NAV) RESERVED1() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutateRESERVED1(n uint16) bool {
	return rcv._tab.MutateUint16Slot(58, n)
}

func (rcv *NAV) FUEL_REMAINING() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NAV) MutateFUEL_REMAINING(n float32) bool {
	return rcv._tab.MutateFloat32Slot(60, n)
}

func (rcv *NAV) AMMO_MAIN() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutateAMMO_MAIN(n uint16) bool {
	return rcv._tab.MutateUint16Slot(62, n)
}

func (rcv *NAV) MISSILES_REMAINING() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutateMISSILES_REMAINING(n byte) bool {
	return rcv._tab.MutateByteSlot(64, n)
}

func (rcv *NAV) TORPEDOES_REMAINING() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutateTORPEDOES_REMAINING(n byte) bool {
	return rcv._tab.MutateByteSlot(66, n)
}

func (rcv *NAV) VESSEL_TYPE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutateVESSEL_TYPE(n byte) bool {
	return rcv._tab.MutateByteSlot(68, n)
}

func (rcv *NAV) PROPULSION_TYPE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NAV) MutatePROPULSION_TYPE(n byte) bool {
	return rcv._tab.MutateByteSlot(70, n)
}

func (rcv *NAV) RESERVED(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *NAV) RESERVEDLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *NAV) RESERVEDBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *NAV) MutateRESERVED(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func NAVStart(builder *flatbuffers.Builder) {
	builder.StartObject(35)
}
func NAVAddPOSITION_X(builder *flatbuffers.Builder, POSITION_X float64) {
	builder.PrependFloat64Slot(0, POSITION_X, 0.0)
}
func NAVAddPOSITION_Y(builder *flatbuffers.Builder, POSITION_Y float64) {
	builder.PrependFloat64Slot(1, POSITION_Y, 0.0)
}
func NAVAddPOSITION_Z(builder *flatbuffers.Builder, POSITION_Z float64) {
	builder.PrependFloat64Slot(2, POSITION_Z, 0.0)
}
func NAVAddVELOCITY_X(builder *flatbuffers.Builder, VELOCITY_X float64) {
	builder.PrependFloat64Slot(3, VELOCITY_X, 0.0)
}
func NAVAddVELOCITY_Y(builder *flatbuffers.Builder, VELOCITY_Y float64) {
	builder.PrependFloat64Slot(4, VELOCITY_Y, 0.0)
}
func NAVAddVELOCITY_Z(builder *flatbuffers.Builder, VELOCITY_Z float64) {
	builder.PrependFloat64Slot(5, VELOCITY_Z, 0.0)
}
func NAVAddATTITUDE_X(builder *flatbuffers.Builder, ATTITUDE_X float64) {
	builder.PrependFloat64Slot(6, ATTITUDE_X, 0.0)
}
func NAVAddATTITUDE_Y(builder *flatbuffers.Builder, ATTITUDE_Y float64) {
	builder.PrependFloat64Slot(7, ATTITUDE_Y, 0.0)
}
func NAVAddATTITUDE_Z(builder *flatbuffers.Builder, ATTITUDE_Z float64) {
	builder.PrependFloat64Slot(8, ATTITUDE_Z, 0.0)
}
func NAVAddATTITUDE_W(builder *flatbuffers.Builder, ATTITUDE_W float64) {
	builder.PrependFloat64Slot(9, ATTITUDE_W, 0.0)
}
func NAVAddOMEGA_X(builder *flatbuffers.Builder, OMEGA_X float64) {
	builder.PrependFloat64Slot(10, OMEGA_X, 0.0)
}
func NAVAddOMEGA_Y(builder *flatbuffers.Builder, OMEGA_Y float64) {
	builder.PrependFloat64Slot(11, OMEGA_Y, 0.0)
}
func NAVAddOMEGA_Z(builder *flatbuffers.Builder, OMEGA_Z float64) {
	builder.PrependFloat64Slot(12, OMEGA_Z, 0.0)
}
func NAVAddSPEED_KNOTS(builder *flatbuffers.Builder, SPEED_KNOTS float32) {
	builder.PrependFloat32Slot(13, SPEED_KNOTS, 0.0)
}
func NAVAddHEADING(builder *flatbuffers.Builder, HEADING float32) {
	builder.PrependFloat32Slot(14, HEADING, 0.0)
}
func NAVAddCOURSE(builder *flatbuffers.Builder, COURSE float32) {
	builder.PrependFloat32Slot(15, COURSE, 0.0)
}
func NAVAddRUDDER_ANGLE(builder *flatbuffers.Builder, RUDDER_ANGLE float32) {
	builder.PrependFloat32Slot(16, RUDDER_ANGLE, 0.0)
}
func NAVAddHULL(builder *flatbuffers.Builder, HULL flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(HULL), 0)
}
func NAVAddPROPULSION(builder *flatbuffers.Builder, PROPULSION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(18, flatbuffers.UOffsetT(PROPULSION), 0)
}
func NAVAddDC_STATE(builder *flatbuffers.Builder, DC_STATE byte) {
	builder.PrependByteSlot(19, DC_STATE, 0)
}
func NAVAddFIRES_ACTIVE(builder *flatbuffers.Builder, FIRES_ACTIVE byte) {
	builder.PrependByteSlot(20, FIRES_ACTIVE, 0)
}
func NAVAddFLOODING_ACTIVE(builder *flatbuffers.Builder, FLOODING_ACTIVE byte) {
	builder.PrependByteSlot(21, FLOODING_ACTIVE, 0)
}
func NAVAddCREW_CASUALTIES(builder *flatbuffers.Builder, CREW_CASUALTIES byte) {
	builder.PrependByteSlot(22, CREW_CASUALTIES, 0)
}
func NAVAddHULL_INTEGRITY(builder *flatbuffers.Builder, HULL_INTEGRITY float32) {
	builder.PrependFloat32Slot(23, HULL_INTEGRITY, 0.0)
}
func NAVAddPOWER_AVAILABLE(builder *flatbuffers.Builder, POWER_AVAILABLE float32) {
	builder.PrependFloat32Slot(24, POWER_AVAILABLE, 0.0)
}
func NAVAddWEAPONS_ONLINE(builder *flatbuffers.Builder, WEAPONS_ONLINE byte) {
	builder.PrependByteSlot(25, WEAPONS_ONLINE, 0)
}
func NAVAddSENSORS_ONLINE(builder *flatbuffers.Builder, SENSORS_ONLINE byte) {
	builder.PrependByteSlot(26, SENSORS_ONLINE, 0)
}
func NAVAddRESERVED1(builder *flatbuffers.Builder, RESERVED1 uint16) {
	builder.PrependUint16Slot(27, RESERVED1, 0)
}
func NAVAddFUEL_REMAINING(builder *flatbuffers.Builder, FUEL_REMAINING float32) {
	builder.PrependFloat32Slot(28, FUEL_REMAINING, 0.0)
}
func NAVAddAMMO_MAIN(builder *flatbuffers.Builder, AMMO_MAIN uint16) {
	builder.PrependUint16Slot(29, AMMO_MAIN, 0)
}
func NAVAddMISSILES_REMAINING(builder *flatbuffers.Builder, MISSILES_REMAINING byte) {
	builder.PrependByteSlot(30, MISSILES_REMAINING, 0)
}
func NAVAddTORPEDOES_REMAINING(builder *flatbuffers.Builder, TORPEDOES_REMAINING byte) {
	builder.PrependByteSlot(31, TORPEDOES_REMAINING, 0)
}
func NAVAddVESSEL_TYPE(builder *flatbuffers.Builder, VESSEL_TYPE byte) {
	builder.PrependByteSlot(32, VESSEL_TYPE, 0)
}
func NAVAddPROPULSION_TYPE(builder *flatbuffers.Builder, PROPULSION_TYPE byte) {
	builder.PrependByteSlot(33, PROPULSION_TYPE, 0)
}
func NAVAddRESERVED(builder *flatbuffers.Builder, RESERVED flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(34, flatbuffers.UOffsetT(RESERVED), 0)
}
func NAVStartRESERVEDVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func NAVEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
