// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package OCM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type OrbitDetermination struct {
	_tab flatbuffers.Table
}

func GetRootAsOrbitDetermination(buf []byte, offset flatbuffers.UOffsetT) *OrbitDetermination {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &OrbitDetermination{}
	x.Init(buf, n+offset)
	return x
}

func FinishOrbitDeterminationBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsOrbitDetermination(buf []byte, offset flatbuffers.UOffsetT) *OrbitDetermination {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &OrbitDetermination{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedOrbitDeterminationBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *OrbitDetermination) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *OrbitDetermination) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier for the orbit determination.
func (rcv *OrbitDetermination) OD_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier for the orbit determination.
/// Identifier of the previous orbit determination.
func (rcv *OrbitDetermination) OD_PREV_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Identifier of the previous orbit determination.
/// Algorithm used for orbit determination.
func (rcv *OrbitDetermination) OD_ALGORITHM() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Algorithm used for orbit determination.
/// Method used for orbit determination.
func (rcv *OrbitDetermination) OD_METHOD() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Method used for orbit determination.
/// Epoch of the orbit determination.
func (rcv *OrbitDetermination) OD_EPOCH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Epoch of the orbit determination.
/// Time tag of the orbit determination.
func (rcv *OrbitDetermination) OD_TIME_TAG() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time tag of the orbit determination.
/// Process noise model used.
func (rcv *OrbitDetermination) OD_PROCESS_NOISE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Process noise model used.
/// Covariance reduction techniques used.
func (rcv *OrbitDetermination) OD_COV_REDUCTION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Covariance reduction techniques used.
/// Noise models used.
func (rcv *OrbitDetermination) OD_NOISE_MODELS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Noise models used.
/// Types of observations used (e.g., RANGE, DOPPLER).
func (rcv *OrbitDetermination) OD_OBSERVATIONS_TYPE(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *OrbitDetermination) OD_OBSERVATIONS_TYPELength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Types of observations used (e.g., RANGE, DOPPLER).
/// Number of observations used.
func (rcv *OrbitDetermination) OD_OBSERVATIONS_USED() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of observations used.
func (rcv *OrbitDetermination) MutateOD_OBSERVATIONS_USED(n int32) bool {
	return rcv._tab.MutateInt32Slot(24, n)
}

/// Number of tracks used.
func (rcv *OrbitDetermination) OD_TRACKS_USED() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of tracks used.
func (rcv *OrbitDetermination) MutateOD_TRACKS_USED(n int32) bool {
	return rcv._tab.MutateInt32Slot(26, n)
}

/// Data weighting scheme used.
func (rcv *OrbitDetermination) OD_DATA_WEIGHTING() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Data weighting scheme used.
/// Convergence criteria used.
func (rcv *OrbitDetermination) OD_CONVERGENCE_CRITERIA() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Convergence criteria used.
/// Parameters estimated during orbit determination.
func (rcv *OrbitDetermination) OD_EST_PARAMETERS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *OrbitDetermination) OD_EST_PARAMETERSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Parameters estimated during orbit determination.
/// A priori data used for orbit determination.
func (rcv *OrbitDetermination) OD_APRIORI_DATA() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// A priori data used for orbit determination.
/// Residuals from the orbit determination.
func (rcv *OrbitDetermination) OD_RESIDUALS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Residuals from the orbit determination.
func OrbitDeterminationStart(builder *flatbuffers.Builder) {
	builder.StartObject(17)
}
func OrbitDeterminationAddOD_ID(builder *flatbuffers.Builder, OD_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(OD_ID), 0)
}
func OrbitDeterminationAddOD_PREV_ID(builder *flatbuffers.Builder, OD_PREV_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(OD_PREV_ID), 0)
}
func OrbitDeterminationAddOD_ALGORITHM(builder *flatbuffers.Builder, OD_ALGORITHM flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(OD_ALGORITHM), 0)
}
func OrbitDeterminationAddOD_METHOD(builder *flatbuffers.Builder, OD_METHOD flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(OD_METHOD), 0)
}
func OrbitDeterminationAddOD_EPOCH(builder *flatbuffers.Builder, OD_EPOCH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(OD_EPOCH), 0)
}
func OrbitDeterminationAddOD_TIME_TAG(builder *flatbuffers.Builder, OD_TIME_TAG flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(OD_TIME_TAG), 0)
}
func OrbitDeterminationAddOD_PROCESS_NOISE(builder *flatbuffers.Builder, OD_PROCESS_NOISE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(OD_PROCESS_NOISE), 0)
}
func OrbitDeterminationAddOD_COV_REDUCTION(builder *flatbuffers.Builder, OD_COV_REDUCTION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(OD_COV_REDUCTION), 0)
}
func OrbitDeterminationAddOD_NOISE_MODELS(builder *flatbuffers.Builder, OD_NOISE_MODELS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(OD_NOISE_MODELS), 0)
}
func OrbitDeterminationAddOD_OBSERVATIONS_TYPE(builder *flatbuffers.Builder, OD_OBSERVATIONS_TYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(OD_OBSERVATIONS_TYPE), 0)
}
func OrbitDeterminationStartOD_OBSERVATIONS_TYPEVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func OrbitDeterminationAddOD_OBSERVATIONS_USED(builder *flatbuffers.Builder, OD_OBSERVATIONS_USED int32) {
	builder.PrependInt32Slot(10, OD_OBSERVATIONS_USED, 0)
}
func OrbitDeterminationAddOD_TRACKS_USED(builder *flatbuffers.Builder, OD_TRACKS_USED int32) {
	builder.PrependInt32Slot(11, OD_TRACKS_USED, 0)
}
func OrbitDeterminationAddOD_DATA_WEIGHTING(builder *flatbuffers.Builder, OD_DATA_WEIGHTING flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(OD_DATA_WEIGHTING), 0)
}
func OrbitDeterminationAddOD_CONVERGENCE_CRITERIA(builder *flatbuffers.Builder, OD_CONVERGENCE_CRITERIA flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(OD_CONVERGENCE_CRITERIA), 0)
}
func OrbitDeterminationAddOD_EST_PARAMETERS(builder *flatbuffers.Builder, OD_EST_PARAMETERS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(OD_EST_PARAMETERS), 0)
}
func OrbitDeterminationStartOD_EST_PARAMETERSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func OrbitDeterminationAddOD_APRIORI_DATA(builder *flatbuffers.Builder, OD_APRIORI_DATA flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(OD_APRIORI_DATA), 0)
}
func OrbitDeterminationAddOD_RESIDUALS(builder *flatbuffers.Builder, OD_RESIDUALS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(OD_RESIDUALS), 0)
}
func OrbitDeterminationEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
