// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package SAR

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// SAR Observation
type SAR struct {
	_tab flatbuffers.Table
}

const SARIdentifier = "$SAR"

func GetRootAsSAR(buf []byte, offset flatbuffers.UOffsetT) *SAR {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SAR{}
	x.Init(buf, n+offset)
	return x
}

func FinishSARBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(SARIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func SARBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, SARIdentifier)
}

func GetSizePrefixedRootAsSAR(buf []byte, offset flatbuffers.UOffsetT) *SAR {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SAR{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedSARBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(SARIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedSARBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, SARIdentifier)
}

func (rcv *SAR) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SAR) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier
func (rcv *SAR) ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier
/// Satellite catalog number (of SAR platform)
func (rcv *SAR) SAT_NO() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Satellite catalog number (of SAR platform)
func (rcv *SAR) MutateSAT_NO(n uint32) bool {
	return rcv._tab.MutateUint32Slot(6, n)
}

/// International designator
func (rcv *SAR) ORIG_OBJECT_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// International designator
/// On-orbit reference
func (rcv *SAR) ON_ORBIT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// On-orbit reference
/// Sensor identifier
func (rcv *SAR) ID_SENSOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Sensor identifier
/// Original sensor identifier
func (rcv *SAR) ORIG_SENSOR_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Original sensor identifier
/// External reference identifier
func (rcv *SAR) EXTERNAL_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// External reference identifier
/// Collection identifier
func (rcv *SAR) COLLECTION_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Collection identifier
/// Detection identifier
func (rcv *SAR) DETECTION_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Detection identifier
/// Collection start time (ISO 8601)
func (rcv *SAR) COLLECTION_START() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Collection start time (ISO 8601)
/// Collection end time (ISO 8601)
func (rcv *SAR) COLLECTION_END() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Collection end time (ISO 8601)
/// Center time of observation (ISO 8601)
func (rcv *SAR) CENTER_TIME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Center time of observation (ISO 8601)
/// Detection start time (ISO 8601)
func (rcv *SAR) DETECTION_START() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Detection start time (ISO 8601)
/// Detection end time (ISO 8601)
func (rcv *SAR) DETECTION_END() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Detection end time (ISO 8601)
/// Integration/dwell time (seconds)
func (rcv *SAR) DWELL_TIME() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Integration/dwell time (seconds)
func (rcv *SAR) MutateDWELL_TIME(n float64) bool {
	return rcv._tab.MutateFloat64Slot(32, n)
}

/// Orbit state description
func (rcv *SAR) ORBIT_STATE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Orbit state description
/// SAR imaging mode
func (rcv *SAR) SAR_MODE() sarMode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return sarMode(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// SAR imaging mode
func (rcv *SAR) MutateSAR_MODE(n sarMode) bool {
	return rcv._tab.MutateInt8Slot(36, int8(n))
}

/// Operating RF band (e.g., X, C, L, S, P)
func (rcv *SAR) OPERATING_BAND() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Operating RF band (e.g., X, C, L, S, P)
/// Operating frequency (GHz)
func (rcv *SAR) OPERATING_FREQ() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Operating frequency (GHz)
func (rcv *SAR) MutateOPERATING_FREQ(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// Signal-to-noise ratio (dB)
func (rcv *SAR) SNR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Signal-to-noise ratio (dB)
func (rcv *SAR) MutateSNR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// Transmit polarization
func (rcv *SAR) TX_POLARIZATION() sarPolarization {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return sarPolarization(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Transmit polarization
func (rcv *SAR) MutateTX_POLARIZATION(n sarPolarization) bool {
	return rcv._tab.MutateInt8Slot(44, int8(n))
}

/// Receive polarization
func (rcv *SAR) RX_POLARIZATION() sarPolarization {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return sarPolarization(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Receive polarization
func (rcv *SAR) MutateRX_POLARIZATION(n sarPolarization) bool {
	return rcv._tab.MutateInt8Slot(46, int8(n))
}

/// Grazing angle (degrees)
func (rcv *SAR) GRAZE_ANGLE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Grazing angle (degrees)
func (rcv *SAR) MutateGRAZE_ANGLE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

/// Incidence angle (degrees)
func (rcv *SAR) INCIDENCE_ANGLE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Incidence angle (degrees)
func (rcv *SAR) MutateINCIDENCE_ANGLE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

/// Squint angle (degrees)
func (rcv *SAR) SQUINT_ANGLE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Squint angle (degrees)
func (rcv *SAR) MutateSQUINT_ANGLE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(52, n)
}

/// Pulse bandwidth (MHz)
func (rcv *SAR) PULSE_BANDWIDTH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Pulse bandwidth (MHz)
func (rcv *SAR) MutatePULSE_BANDWIDTH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(54, n)
}

/// Pulse duration (microseconds)
func (rcv *SAR) PULSE_DURATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Pulse duration (microseconds)
func (rcv *SAR) MutatePULSE_DURATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(56, n)
}

/// Continuous spot angle (degrees)
func (rcv *SAR) CONTINUOUS_SPOT_ANGLE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Continuous spot angle (degrees)
func (rcv *SAR) MutateCONTINUOUS_SPOT_ANGLE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(58, n)
}

/// Slant range to target (km)
func (rcv *SAR) SLANT_RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Slant range to target (km)
func (rcv *SAR) MutateSLANT_RANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(60, n)
}

/// Near range (km)
func (rcv *SAR) NEAR_RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Near range (km)
func (rcv *SAR) MutateNEAR_RANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(62, n)
}

/// Far range (km)
func (rcv *SAR) FAR_RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Far range (km)
func (rcv *SAR) MutateFAR_RANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(64, n)
}

/// Swath length (km)
func (rcv *SAR) SWATH_LENGTH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Swath length (km)
func (rcv *SAR) MutateSWATH_LENGTH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(66, n)
}

/// Image area GeoJSON
func (rcv *SAR) AGJSON() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Image area GeoJSON
/// Image area text description
func (rcv *SAR) ATEXT() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Image area text description
/// Area type
func (rcv *SAR) ATYPE() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Area type
/// Coordinate system
func (rcv *SAR) COORD_SYS() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Coordinate system
/// Range pixel spacing (meters)
func (rcv *SAR) SPACING_RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Range pixel spacing (meters)
func (rcv *SAR) MutateSPACING_RANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(76, n)
}

/// Azimuth pixel spacing (meters)
func (rcv *SAR) SPACING_AZIMUTH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Azimuth pixel spacing (meters)
func (rcv *SAR) MutateSPACING_AZIMUTH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(78, n)
}

/// Number of azimuth looks
func (rcv *SAR) LOOKS_AZIMUTH() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of azimuth looks
func (rcv *SAR) MutateLOOKS_AZIMUTH(n byte) bool {
	return rcv._tab.MutateByteSlot(80, n)
}

/// Number of range looks
func (rcv *SAR) LOOKS_RANGE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of range looks
func (rcv *SAR) MutateLOOKS_RANGE(n byte) bool {
	return rcv._tab.MutateByteSlot(82, n)
}

/// Range resolution (meters)
func (rcv *SAR) RESOLUTION_RANGE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Range resolution (meters)
func (rcv *SAR) MutateRESOLUTION_RANGE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(84, n)
}

/// Azimuth resolution (meters)
func (rcv *SAR) RESOLUTION_AZIMUTH() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Azimuth resolution (meters)
func (rcv *SAR) MutateRESOLUTION_AZIMUTH(n float64) bool {
	return rcv._tab.MutateFloat64Slot(86, n)
}

/// Observation direction (ASCENDING/DESCENDING)
func (rcv *SAR) OB_DIRECTION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Observation direction (ASCENDING/DESCENDING)
/// Target position X (km)
func (rcv *SAR) TARGETPOSX() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(90))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Target position X (km)
func (rcv *SAR) MutateTARGETPOSX(n float64) bool {
	return rcv._tab.MutateFloat64Slot(90, n)
}

/// Target position Y (km)
func (rcv *SAR) TARGETPOSY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(92))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Target position Y (km)
func (rcv *SAR) MutateTARGETPOSY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(92, n)
}

/// Target position Z (km)
func (rcv *SAR) TARGETPOSZ() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(94))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Target position Z (km)
func (rcv *SAR) MutateTARGETPOSZ(n float64) bool {
	return rcv._tab.MutateFloat64Slot(94, n)
}

/// Sensor altitude (km)
func (rcv *SAR) SENALT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(96))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor altitude (km)
func (rcv *SAR) MutateSENALT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(96, n)
}

/// Sensor velocity X (km/s)
func (rcv *SAR) SENVELX() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor velocity X (km/s)
func (rcv *SAR) MutateSENVELX(n float64) bool {
	return rcv._tab.MutateFloat64Slot(98, n)
}

/// Sensor velocity Y (km/s)
func (rcv *SAR) SENVELY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(100))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor velocity Y (km/s)
func (rcv *SAR) MutateSENVELY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(100, n)
}

/// Sensor velocity Z (km/s)
func (rcv *SAR) SENVELZ() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor velocity Z (km/s)
func (rcv *SAR) MutateSENVELZ(n float64) bool {
	return rcv._tab.MutateFloat64Slot(102, n)
}

/// Sensor latitude at start (degrees)
func (rcv *SAR) SENLAT_START() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor latitude at start (degrees)
func (rcv *SAR) MutateSENLAT_START(n float64) bool {
	return rcv._tab.MutateFloat64Slot(104, n)
}

/// Sensor longitude at start (degrees)
func (rcv *SAR) SENLON_START() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor longitude at start (degrees)
func (rcv *SAR) MutateSENLON_START(n float64) bool {
	return rcv._tab.MutateFloat64Slot(106, n)
}

/// Sensor latitude at end (degrees)
func (rcv *SAR) SENLAT_END() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor latitude at end (degrees)
func (rcv *SAR) MutateSENLAT_END(n float64) bool {
	return rcv._tab.MutateFloat64Slot(108, n)
}

/// Sensor longitude at end (degrees)
func (rcv *SAR) SENLON_END() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Sensor longitude at end (degrees)
func (rcv *SAR) MutateSENLON_END(n float64) bool {
	return rcv._tab.MutateFloat64Slot(110, n)
}

/// Transaction identifier
func (rcv *SAR) TRANSACTION_ID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Transaction identifier
/// Associated tags
func (rcv *SAR) TAGS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *SAR) TAGSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Associated tags
/// Source types
func (rcv *SAR) SRC_TYPS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *SAR) SRC_TYPSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Source types
/// Source identifiers
func (rcv *SAR) SRC_IDS(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *SAR) SRC_IDSLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Source identifiers
func SARStart(builder *flatbuffers.Builder) {
	builder.StartObject(58)
}
func SARAddID(builder *flatbuffers.Builder, ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ID), 0)
}
func SARAddSAT_NO(builder *flatbuffers.Builder, SAT_NO uint32) {
	builder.PrependUint32Slot(1, SAT_NO, 0)
}
func SARAddORIG_OBJECT_ID(builder *flatbuffers.Builder, ORIG_OBJECT_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(ORIG_OBJECT_ID), 0)
}
func SARAddON_ORBIT(builder *flatbuffers.Builder, ON_ORBIT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(ON_ORBIT), 0)
}
func SARAddID_SENSOR(builder *flatbuffers.Builder, ID_SENSOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(ID_SENSOR), 0)
}
func SARAddORIG_SENSOR_ID(builder *flatbuffers.Builder, ORIG_SENSOR_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(ORIG_SENSOR_ID), 0)
}
func SARAddEXTERNAL_ID(builder *flatbuffers.Builder, EXTERNAL_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(EXTERNAL_ID), 0)
}
func SARAddCOLLECTION_ID(builder *flatbuffers.Builder, COLLECTION_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(COLLECTION_ID), 0)
}
func SARAddDETECTION_ID(builder *flatbuffers.Builder, DETECTION_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(DETECTION_ID), 0)
}
func SARAddCOLLECTION_START(builder *flatbuffers.Builder, COLLECTION_START flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(COLLECTION_START), 0)
}
func SARAddCOLLECTION_END(builder *flatbuffers.Builder, COLLECTION_END flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(COLLECTION_END), 0)
}
func SARAddCENTER_TIME(builder *flatbuffers.Builder, CENTER_TIME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(CENTER_TIME), 0)
}
func SARAddDETECTION_START(builder *flatbuffers.Builder, DETECTION_START flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(DETECTION_START), 0)
}
func SARAddDETECTION_END(builder *flatbuffers.Builder, DETECTION_END flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(DETECTION_END), 0)
}
func SARAddDWELL_TIME(builder *flatbuffers.Builder, DWELL_TIME float64) {
	builder.PrependFloat64Slot(14, DWELL_TIME, 0.0)
}
func SARAddORBIT_STATE(builder *flatbuffers.Builder, ORBIT_STATE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(ORBIT_STATE), 0)
}
func SARAddSAR_MODE(builder *flatbuffers.Builder, SAR_MODE sarMode) {
	builder.PrependInt8Slot(16, int8(SAR_MODE), 0)
}
func SARAddOPERATING_BAND(builder *flatbuffers.Builder, OPERATING_BAND flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(OPERATING_BAND), 0)
}
func SARAddOPERATING_FREQ(builder *flatbuffers.Builder, OPERATING_FREQ float64) {
	builder.PrependFloat64Slot(18, OPERATING_FREQ, 0.0)
}
func SARAddSNR(builder *flatbuffers.Builder, SNR float64) {
	builder.PrependFloat64Slot(19, SNR, 0.0)
}
func SARAddTX_POLARIZATION(builder *flatbuffers.Builder, TX_POLARIZATION sarPolarization) {
	builder.PrependInt8Slot(20, int8(TX_POLARIZATION), 0)
}
func SARAddRX_POLARIZATION(builder *flatbuffers.Builder, RX_POLARIZATION sarPolarization) {
	builder.PrependInt8Slot(21, int8(RX_POLARIZATION), 0)
}
func SARAddGRAZE_ANGLE(builder *flatbuffers.Builder, GRAZE_ANGLE float64) {
	builder.PrependFloat64Slot(22, GRAZE_ANGLE, 0.0)
}
func SARAddINCIDENCE_ANGLE(builder *flatbuffers.Builder, INCIDENCE_ANGLE float64) {
	builder.PrependFloat64Slot(23, INCIDENCE_ANGLE, 0.0)
}
func SARAddSQUINT_ANGLE(builder *flatbuffers.Builder, SQUINT_ANGLE float64) {
	builder.PrependFloat64Slot(24, SQUINT_ANGLE, 0.0)
}
func SARAddPULSE_BANDWIDTH(builder *flatbuffers.Builder, PULSE_BANDWIDTH float64) {
	builder.PrependFloat64Slot(25, PULSE_BANDWIDTH, 0.0)
}
func SARAddPULSE_DURATION(builder *flatbuffers.Builder, PULSE_DURATION float64) {
	builder.PrependFloat64Slot(26, PULSE_DURATION, 0.0)
}
func SARAddCONTINUOUS_SPOT_ANGLE(builder *flatbuffers.Builder, CONTINUOUS_SPOT_ANGLE float64) {
	builder.PrependFloat64Slot(27, CONTINUOUS_SPOT_ANGLE, 0.0)
}
func SARAddSLANT_RANGE(builder *flatbuffers.Builder, SLANT_RANGE float64) {
	builder.PrependFloat64Slot(28, SLANT_RANGE, 0.0)
}
func SARAddNEAR_RANGE(builder *flatbuffers.Builder, NEAR_RANGE float64) {
	builder.PrependFloat64Slot(29, NEAR_RANGE, 0.0)
}
func SARAddFAR_RANGE(builder *flatbuffers.Builder, FAR_RANGE float64) {
	builder.PrependFloat64Slot(30, FAR_RANGE, 0.0)
}
func SARAddSWATH_LENGTH(builder *flatbuffers.Builder, SWATH_LENGTH float64) {
	builder.PrependFloat64Slot(31, SWATH_LENGTH, 0.0)
}
func SARAddAGJSON(builder *flatbuffers.Builder, AGJSON flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(32, flatbuffers.UOffsetT(AGJSON), 0)
}
func SARAddATEXT(builder *flatbuffers.Builder, ATEXT flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(33, flatbuffers.UOffsetT(ATEXT), 0)
}
func SARAddATYPE(builder *flatbuffers.Builder, ATYPE flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(34, flatbuffers.UOffsetT(ATYPE), 0)
}
func SARAddCOORD_SYS(builder *flatbuffers.Builder, COORD_SYS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(35, flatbuffers.UOffsetT(COORD_SYS), 0)
}
func SARAddSPACING_RANGE(builder *flatbuffers.Builder, SPACING_RANGE float64) {
	builder.PrependFloat64Slot(36, SPACING_RANGE, 0.0)
}
func SARAddSPACING_AZIMUTH(builder *flatbuffers.Builder, SPACING_AZIMUTH float64) {
	builder.PrependFloat64Slot(37, SPACING_AZIMUTH, 0.0)
}
func SARAddLOOKS_AZIMUTH(builder *flatbuffers.Builder, LOOKS_AZIMUTH byte) {
	builder.PrependByteSlot(38, LOOKS_AZIMUTH, 0)
}
func SARAddLOOKS_RANGE(builder *flatbuffers.Builder, LOOKS_RANGE byte) {
	builder.PrependByteSlot(39, LOOKS_RANGE, 0)
}
func SARAddRESOLUTION_RANGE(builder *flatbuffers.Builder, RESOLUTION_RANGE float64) {
	builder.PrependFloat64Slot(40, RESOLUTION_RANGE, 0.0)
}
func SARAddRESOLUTION_AZIMUTH(builder *flatbuffers.Builder, RESOLUTION_AZIMUTH float64) {
	builder.PrependFloat64Slot(41, RESOLUTION_AZIMUTH, 0.0)
}
func SARAddOB_DIRECTION(builder *flatbuffers.Builder, OB_DIRECTION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(42, flatbuffers.UOffsetT(OB_DIRECTION), 0)
}
func SARAddTARGETPOSX(builder *flatbuffers.Builder, TARGETPOSX float64) {
	builder.PrependFloat64Slot(43, TARGETPOSX, 0.0)
}
func SARAddTARGETPOSY(builder *flatbuffers.Builder, TARGETPOSY float64) {
	builder.PrependFloat64Slot(44, TARGETPOSY, 0.0)
}
func SARAddTARGETPOSZ(builder *flatbuffers.Builder, TARGETPOSZ float64) {
	builder.PrependFloat64Slot(45, TARGETPOSZ, 0.0)
}
func SARAddSENALT(builder *flatbuffers.Builder, SENALT float64) {
	builder.PrependFloat64Slot(46, SENALT, 0.0)
}
func SARAddSENVELX(builder *flatbuffers.Builder, SENVELX float64) {
	builder.PrependFloat64Slot(47, SENVELX, 0.0)
}
func SARAddSENVELY(builder *flatbuffers.Builder, SENVELY float64) {
	builder.PrependFloat64Slot(48, SENVELY, 0.0)
}
func SARAddSENVELZ(builder *flatbuffers.Builder, SENVELZ float64) {
	builder.PrependFloat64Slot(49, SENVELZ, 0.0)
}
func SARAddSENLAT_START(builder *flatbuffers.Builder, SENLAT_START float64) {
	builder.PrependFloat64Slot(50, SENLAT_START, 0.0)
}
func SARAddSENLON_START(builder *flatbuffers.Builder, SENLON_START float64) {
	builder.PrependFloat64Slot(51, SENLON_START, 0.0)
}
func SARAddSENLAT_END(builder *flatbuffers.Builder, SENLAT_END float64) {
	builder.PrependFloat64Slot(52, SENLAT_END, 0.0)
}
func SARAddSENLON_END(builder *flatbuffers.Builder, SENLON_END float64) {
	builder.PrependFloat64Slot(53, SENLON_END, 0.0)
}
func SARAddTRANSACTION_ID(builder *flatbuffers.Builder, TRANSACTION_ID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(54, flatbuffers.UOffsetT(TRANSACTION_ID), 0)
}
func SARAddTAGS(builder *flatbuffers.Builder, TAGS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(55, flatbuffers.UOffsetT(TAGS), 0)
}
func SARStartTAGSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SARAddSRC_TYPS(builder *flatbuffers.Builder, SRC_TYPS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(56, flatbuffers.UOffsetT(SRC_TYPS), 0)
}
func SARStartSRC_TYPSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SARAddSRC_IDS(builder *flatbuffers.Builder, SRC_IDS flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(57, flatbuffers.UOffsetT(SRC_IDS), 0)
}
func SARStartSRC_IDSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SAREnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
