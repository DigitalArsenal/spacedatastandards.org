// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package ION

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Ionospheric Observation Data Point
type ionoDataPoint struct {
	_tab flatbuffers.Table
}

func GetRootAsionoDataPoint(buf []byte, offset flatbuffers.UOffsetT) *ionoDataPoint {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ionoDataPoint{}
	x.Init(buf, n+offset)
	return x
}

func FinishionoDataPointBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsionoDataPoint(buf []byte, offset flatbuffers.UOffsetT) *ionoDataPoint {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ionoDataPoint{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedionoDataPointBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *ionoDataPoint) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ionoDataPoint) Table() flatbuffers.Table {
	return rcv._tab
}

/// Observation epoch (ISO 8601)
func (rcv *ionoDataPoint) EPOCH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Observation epoch (ISO 8601)
/// Ionospheric layer
func (rcv *ionoDataPoint) LAYER() ionoLayer {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return ionoLayer(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Ionospheric layer
func (rcv *ionoDataPoint) MutateLAYER(n ionoLayer) bool {
	return rcv._tab.MutateInt8Slot(6, int8(n))
}

/// Critical frequency in MHz
func (rcv *ionoDataPoint) CRITICAL_FREQ() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Critical frequency in MHz
func (rcv *ionoDataPoint) MutateCRITICAL_FREQ(n float64) bool {
	return rcv._tab.MutateFloat64Slot(8, n)
}

/// Virtual height in km
func (rcv *ionoDataPoint) VIRTUAL_HEIGHT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Virtual height in km
func (rcv *ionoDataPoint) MutateVIRTUAL_HEIGHT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

/// True height in km
func (rcv *ionoDataPoint) TRUE_HEIGHT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// True height in km
func (rcv *ionoDataPoint) MutateTRUE_HEIGHT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

/// Peak electron density in electrons/m^3
func (rcv *ionoDataPoint) PEAK_DENSITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Peak electron density in electrons/m^3
func (rcv *ionoDataPoint) MutatePEAK_DENSITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

/// Total electron content in TECU
func (rcv *ionoDataPoint) TEC() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Total electron content in TECU
func (rcv *ionoDataPoint) MutateTEC(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// TEC uncertainty in TECU
func (rcv *ionoDataPoint) TEC_UNCERTAINTY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// TEC uncertainty in TECU
func (rcv *ionoDataPoint) MutateTEC_UNCERTAINTY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

func ionoDataPointStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func ionoDataPointAddEPOCH(builder *flatbuffers.Builder, EPOCH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(EPOCH), 0)
}
func ionoDataPointAddLAYER(builder *flatbuffers.Builder, LAYER ionoLayer) {
	builder.PrependInt8Slot(1, int8(LAYER), 0)
}
func ionoDataPointAddCRITICAL_FREQ(builder *flatbuffers.Builder, CRITICAL_FREQ float64) {
	builder.PrependFloat64Slot(2, CRITICAL_FREQ, 0.0)
}
func ionoDataPointAddVIRTUAL_HEIGHT(builder *flatbuffers.Builder, VIRTUAL_HEIGHT float64) {
	builder.PrependFloat64Slot(3, VIRTUAL_HEIGHT, 0.0)
}
func ionoDataPointAddTRUE_HEIGHT(builder *flatbuffers.Builder, TRUE_HEIGHT float64) {
	builder.PrependFloat64Slot(4, TRUE_HEIGHT, 0.0)
}
func ionoDataPointAddPEAK_DENSITY(builder *flatbuffers.Builder, PEAK_DENSITY float64) {
	builder.PrependFloat64Slot(5, PEAK_DENSITY, 0.0)
}
func ionoDataPointAddTEC(builder *flatbuffers.Builder, TEC float64) {
	builder.PrependFloat64Slot(6, TEC, 0.0)
}
func ionoDataPointAddTEC_UNCERTAINTY(builder *flatbuffers.Builder, TEC_UNCERTAINTY float64) {
	builder.PrependFloat64Slot(7, TEC_UNCERTAINTY, 0.0)
}
func ionoDataPointEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
