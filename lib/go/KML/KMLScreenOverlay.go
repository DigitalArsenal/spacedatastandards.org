// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package KML

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Screen overlay
type KMLScreenOverlay struct {
	_tab flatbuffers.Table
}

func GetRootAsKMLScreenOverlay(buf []byte, offset flatbuffers.UOffsetT) *KMLScreenOverlay {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &KMLScreenOverlay{}
	x.Init(buf, n+offset)
	return x
}

func FinishKMLScreenOverlayBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsKMLScreenOverlay(buf []byte, offset flatbuffers.UOffsetT) *KMLScreenOverlay {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &KMLScreenOverlay{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedKMLScreenOverlayBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *KMLScreenOverlay) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *KMLScreenOverlay) Table() flatbuffers.Table {
	return rcv._tab
}

/// Name
func (rcv *KMLScreenOverlay) NAME() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Name
/// Description
func (rcv *KMLScreenOverlay) DESCRIPTION() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Description
/// Visibility
func (rcv *KMLScreenOverlay) VISIBILITY() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Visibility
func (rcv *KMLScreenOverlay) MutateVISIBILITY(n bool) bool {
	return rcv._tab.MutateBoolSlot(8, n)
}

/// Icon/image URL
func (rcv *KMLScreenOverlay) ICON_HREF() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Icon/image URL
/// Color
func (rcv *KMLScreenOverlay) COLOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Color
/// Draw order
func (rcv *KMLScreenOverlay) DRAW_ORDER() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Draw order
func (rcv *KMLScreenOverlay) MutateDRAW_ORDER(n int32) bool {
	return rcv._tab.MutateInt32Slot(14, n)
}

/// Overlay X position
func (rcv *KMLScreenOverlay) OVERLAY_XY_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Overlay X position
func (rcv *KMLScreenOverlay) MutateOVERLAY_XY_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// Overlay Y position
func (rcv *KMLScreenOverlay) OVERLAY_XY_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Overlay Y position
func (rcv *KMLScreenOverlay) MutateOVERLAY_XY_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

/// Overlay X units
func (rcv *KMLScreenOverlay) OVERLAY_XY_XUNITS() KMLUnits {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return KMLUnits(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Overlay X units
func (rcv *KMLScreenOverlay) MutateOVERLAY_XY_XUNITS(n KMLUnits) bool {
	return rcv._tab.MutateInt8Slot(20, int8(n))
}

/// Overlay Y units
func (rcv *KMLScreenOverlay) OVERLAY_XY_YUNITS() KMLUnits {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return KMLUnits(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Overlay Y units
func (rcv *KMLScreenOverlay) MutateOVERLAY_XY_YUNITS(n KMLUnits) bool {
	return rcv._tab.MutateInt8Slot(22, int8(n))
}

/// Screen X position
func (rcv *KMLScreenOverlay) SCREEN_XY_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Screen X position
func (rcv *KMLScreenOverlay) MutateSCREEN_XY_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// Screen Y position
func (rcv *KMLScreenOverlay) SCREEN_XY_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Screen Y position
func (rcv *KMLScreenOverlay) MutateSCREEN_XY_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// Screen X units
func (rcv *KMLScreenOverlay) SCREEN_XY_XUNITS() KMLUnits {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return KMLUnits(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Screen X units
func (rcv *KMLScreenOverlay) MutateSCREEN_XY_XUNITS(n KMLUnits) bool {
	return rcv._tab.MutateInt8Slot(28, int8(n))
}

/// Screen Y units
func (rcv *KMLScreenOverlay) SCREEN_XY_YUNITS() KMLUnits {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return KMLUnits(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Screen Y units
func (rcv *KMLScreenOverlay) MutateSCREEN_XY_YUNITS(n KMLUnits) bool {
	return rcv._tab.MutateInt8Slot(30, int8(n))
}

/// Rotation X
func (rcv *KMLScreenOverlay) ROTATION_XY_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Rotation X
func (rcv *KMLScreenOverlay) MutateROTATION_XY_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(32, n)
}

/// Rotation Y
func (rcv *KMLScreenOverlay) ROTATION_XY_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Rotation Y
func (rcv *KMLScreenOverlay) MutateROTATION_XY_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(34, n)
}

/// Rotation X units
func (rcv *KMLScreenOverlay) ROTATION_XY_XUNITS() KMLUnits {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return KMLUnits(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Rotation X units
func (rcv *KMLScreenOverlay) MutateROTATION_XY_XUNITS(n KMLUnits) bool {
	return rcv._tab.MutateInt8Slot(36, int8(n))
}

/// Rotation Y units
func (rcv *KMLScreenOverlay) ROTATION_XY_YUNITS() KMLUnits {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return KMLUnits(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Rotation Y units
func (rcv *KMLScreenOverlay) MutateROTATION_XY_YUNITS(n KMLUnits) bool {
	return rcv._tab.MutateInt8Slot(38, int8(n))
}

/// Size X
func (rcv *KMLScreenOverlay) SIZE_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Size X
func (rcv *KMLScreenOverlay) MutateSIZE_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// Size Y
func (rcv *KMLScreenOverlay) SIZE_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Size Y
func (rcv *KMLScreenOverlay) MutateSIZE_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// Size X units
func (rcv *KMLScreenOverlay) SIZE_XUNITS() KMLUnits {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return KMLUnits(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Size X units
func (rcv *KMLScreenOverlay) MutateSIZE_XUNITS(n KMLUnits) bool {
	return rcv._tab.MutateInt8Slot(44, int8(n))
}

/// Size Y units
func (rcv *KMLScreenOverlay) SIZE_YUNITS() KMLUnits {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return KMLUnits(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Size Y units
func (rcv *KMLScreenOverlay) MutateSIZE_YUNITS(n KMLUnits) bool {
	return rcv._tab.MutateInt8Slot(46, int8(n))
}

/// Rotation in degrees
func (rcv *KMLScreenOverlay) ROTATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Rotation in degrees
func (rcv *KMLScreenOverlay) MutateROTATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

func KMLScreenOverlayStart(builder *flatbuffers.Builder) {
	builder.StartObject(23)
}
func KMLScreenOverlayAddNAME(builder *flatbuffers.Builder, NAME flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(NAME), 0)
}
func KMLScreenOverlayAddDESCRIPTION(builder *flatbuffers.Builder, DESCRIPTION flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(DESCRIPTION), 0)
}
func KMLScreenOverlayAddVISIBILITY(builder *flatbuffers.Builder, VISIBILITY bool) {
	builder.PrependBoolSlot(2, VISIBILITY, false)
}
func KMLScreenOverlayAddICON_HREF(builder *flatbuffers.Builder, ICON_HREF flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(ICON_HREF), 0)
}
func KMLScreenOverlayAddCOLOR(builder *flatbuffers.Builder, COLOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(COLOR), 0)
}
func KMLScreenOverlayAddDRAW_ORDER(builder *flatbuffers.Builder, DRAW_ORDER int32) {
	builder.PrependInt32Slot(5, DRAW_ORDER, 0)
}
func KMLScreenOverlayAddOVERLAY_XY_X(builder *flatbuffers.Builder, OVERLAY_XY_X float64) {
	builder.PrependFloat64Slot(6, OVERLAY_XY_X, 0.0)
}
func KMLScreenOverlayAddOVERLAY_XY_Y(builder *flatbuffers.Builder, OVERLAY_XY_Y float64) {
	builder.PrependFloat64Slot(7, OVERLAY_XY_Y, 0.0)
}
func KMLScreenOverlayAddOVERLAY_XY_XUNITS(builder *flatbuffers.Builder, OVERLAY_XY_XUNITS KMLUnits) {
	builder.PrependInt8Slot(8, int8(OVERLAY_XY_XUNITS), 0)
}
func KMLScreenOverlayAddOVERLAY_XY_YUNITS(builder *flatbuffers.Builder, OVERLAY_XY_YUNITS KMLUnits) {
	builder.PrependInt8Slot(9, int8(OVERLAY_XY_YUNITS), 0)
}
func KMLScreenOverlayAddSCREEN_XY_X(builder *flatbuffers.Builder, SCREEN_XY_X float64) {
	builder.PrependFloat64Slot(10, SCREEN_XY_X, 0.0)
}
func KMLScreenOverlayAddSCREEN_XY_Y(builder *flatbuffers.Builder, SCREEN_XY_Y float64) {
	builder.PrependFloat64Slot(11, SCREEN_XY_Y, 0.0)
}
func KMLScreenOverlayAddSCREEN_XY_XUNITS(builder *flatbuffers.Builder, SCREEN_XY_XUNITS KMLUnits) {
	builder.PrependInt8Slot(12, int8(SCREEN_XY_XUNITS), 0)
}
func KMLScreenOverlayAddSCREEN_XY_YUNITS(builder *flatbuffers.Builder, SCREEN_XY_YUNITS KMLUnits) {
	builder.PrependInt8Slot(13, int8(SCREEN_XY_YUNITS), 0)
}
func KMLScreenOverlayAddROTATION_XY_X(builder *flatbuffers.Builder, ROTATION_XY_X float64) {
	builder.PrependFloat64Slot(14, ROTATION_XY_X, 0.0)
}
func KMLScreenOverlayAddROTATION_XY_Y(builder *flatbuffers.Builder, ROTATION_XY_Y float64) {
	builder.PrependFloat64Slot(15, ROTATION_XY_Y, 0.0)
}
func KMLScreenOverlayAddROTATION_XY_XUNITS(builder *flatbuffers.Builder, ROTATION_XY_XUNITS KMLUnits) {
	builder.PrependInt8Slot(16, int8(ROTATION_XY_XUNITS), 0)
}
func KMLScreenOverlayAddROTATION_XY_YUNITS(builder *flatbuffers.Builder, ROTATION_XY_YUNITS KMLUnits) {
	builder.PrependInt8Slot(17, int8(ROTATION_XY_YUNITS), 0)
}
func KMLScreenOverlayAddSIZE_X(builder *flatbuffers.Builder, SIZE_X float64) {
	builder.PrependFloat64Slot(18, SIZE_X, 0.0)
}
func KMLScreenOverlayAddSIZE_Y(builder *flatbuffers.Builder, SIZE_Y float64) {
	builder.PrependFloat64Slot(19, SIZE_Y, 0.0)
}
func KMLScreenOverlayAddSIZE_XUNITS(builder *flatbuffers.Builder, SIZE_XUNITS KMLUnits) {
	builder.PrependInt8Slot(20, int8(SIZE_XUNITS), 0)
}
func KMLScreenOverlayAddSIZE_YUNITS(builder *flatbuffers.Builder, SIZE_YUNITS KMLUnits) {
	builder.PrependInt8Slot(21, int8(SIZE_YUNITS), 0)
}
func KMLScreenOverlayAddROTATION(builder *flatbuffers.Builder, ROTATION float64) {
	builder.PrependFloat64Slot(22, ROTATION, 0.0)
}
func KMLScreenOverlayEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
