// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package MNF

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Manifold Element Set
type manifoldElset struct {
	_tab flatbuffers.Table
}

func GetRootAsmanifoldElset(buf []byte, offset flatbuffers.UOffsetT) *manifoldElset {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &manifoldElset{}
	x.Init(buf, n+offset)
	return x
}

func FinishmanifoldElsetBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsmanifoldElset(buf []byte, offset flatbuffers.UOffsetT) *manifoldElset {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &manifoldElset{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedmanifoldElsetBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *manifoldElset) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *manifoldElset) Table() flatbuffers.Table {
	return rcv._tab
}

/// Epoch of element set (ISO 8601)
func (rcv *manifoldElset) EPOCH() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Epoch of element set (ISO 8601)
/// Semi-major axis in km
func (rcv *manifoldElset) SEMI_MAJOR_AXIS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Semi-major axis in km
func (rcv *manifoldElset) MutateSEMI_MAJOR_AXIS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

/// Eccentricity
func (rcv *manifoldElset) ECCENTRICITY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Eccentricity
func (rcv *manifoldElset) MutateECCENTRICITY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(8, n)
}

/// Inclination in degrees
func (rcv *manifoldElset) INCLINATION() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Inclination in degrees
func (rcv *manifoldElset) MutateINCLINATION(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

/// Right ascension of ascending node in degrees
func (rcv *manifoldElset) RA_OF_ASC_NODE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Right ascension of ascending node in degrees
func (rcv *manifoldElset) MutateRA_OF_ASC_NODE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

/// Argument of pericenter in degrees
func (rcv *manifoldElset) ARG_OF_PERICENTER() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Argument of pericenter in degrees
func (rcv *manifoldElset) MutateARG_OF_PERICENTER(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

/// Mean anomaly in degrees
func (rcv *manifoldElset) MEAN_ANOMALY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Mean anomaly in degrees
func (rcv *manifoldElset) MutateMEAN_ANOMALY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// Applied delta-V in m/s
func (rcv *manifoldElset) DELTA_V() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Applied delta-V in m/s
func (rcv *manifoldElset) MutateDELTA_V(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

/// Applied delta-T in seconds
func (rcv *manifoldElset) DELTA_T() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Applied delta-T in seconds
func (rcv *manifoldElset) MutateDELTA_T(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

/// Delta-V direction X (unit vector)
func (rcv *manifoldElset) DV_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Delta-V direction X (unit vector)
func (rcv *manifoldElset) MutateDV_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

/// Delta-V direction Y (unit vector)
func (rcv *manifoldElset) DV_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Delta-V direction Y (unit vector)
func (rcv *manifoldElset) MutateDV_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// Delta-V direction Z (unit vector)
func (rcv *manifoldElset) DV_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Delta-V direction Z (unit vector)
func (rcv *manifoldElset) MutateDV_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// Probability weight (0.0-1.0)
func (rcv *manifoldElset) WEIGHT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Probability weight (0.0-1.0)
func (rcv *manifoldElset) MutateWEIGHT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

/// Apogee altitude in km
func (rcv *manifoldElset) APOGEE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Apogee altitude in km
func (rcv *manifoldElset) MutateAPOGEE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(30, n)
}

/// Perigee altitude in km
func (rcv *manifoldElset) PERIGEE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Perigee altitude in km
func (rcv *manifoldElset) MutatePERIGEE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(32, n)
}

/// Period in minutes
func (rcv *manifoldElset) PERIOD() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Period in minutes
func (rcv *manifoldElset) MutatePERIOD(n float64) bool {
	return rcv._tab.MutateFloat64Slot(34, n)
}

func manifoldElsetStart(builder *flatbuffers.Builder) {
	builder.StartObject(16)
}
func manifoldElsetAddEPOCH(builder *flatbuffers.Builder, EPOCH flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(EPOCH), 0)
}
func manifoldElsetAddSEMI_MAJOR_AXIS(builder *flatbuffers.Builder, SEMI_MAJOR_AXIS float64) {
	builder.PrependFloat64Slot(1, SEMI_MAJOR_AXIS, 0.0)
}
func manifoldElsetAddECCENTRICITY(builder *flatbuffers.Builder, ECCENTRICITY float64) {
	builder.PrependFloat64Slot(2, ECCENTRICITY, 0.0)
}
func manifoldElsetAddINCLINATION(builder *flatbuffers.Builder, INCLINATION float64) {
	builder.PrependFloat64Slot(3, INCLINATION, 0.0)
}
func manifoldElsetAddRA_OF_ASC_NODE(builder *flatbuffers.Builder, RA_OF_ASC_NODE float64) {
	builder.PrependFloat64Slot(4, RA_OF_ASC_NODE, 0.0)
}
func manifoldElsetAddARG_OF_PERICENTER(builder *flatbuffers.Builder, ARG_OF_PERICENTER float64) {
	builder.PrependFloat64Slot(5, ARG_OF_PERICENTER, 0.0)
}
func manifoldElsetAddMEAN_ANOMALY(builder *flatbuffers.Builder, MEAN_ANOMALY float64) {
	builder.PrependFloat64Slot(6, MEAN_ANOMALY, 0.0)
}
func manifoldElsetAddDELTA_V(builder *flatbuffers.Builder, DELTA_V float64) {
	builder.PrependFloat64Slot(7, DELTA_V, 0.0)
}
func manifoldElsetAddDELTA_T(builder *flatbuffers.Builder, DELTA_T float64) {
	builder.PrependFloat64Slot(8, DELTA_T, 0.0)
}
func manifoldElsetAddDV_X(builder *flatbuffers.Builder, DV_X float64) {
	builder.PrependFloat64Slot(9, DV_X, 0.0)
}
func manifoldElsetAddDV_Y(builder *flatbuffers.Builder, DV_Y float64) {
	builder.PrependFloat64Slot(10, DV_Y, 0.0)
}
func manifoldElsetAddDV_Z(builder *flatbuffers.Builder, DV_Z float64) {
	builder.PrependFloat64Slot(11, DV_Z, 0.0)
}
func manifoldElsetAddWEIGHT(builder *flatbuffers.Builder, WEIGHT float64) {
	builder.PrependFloat64Slot(12, WEIGHT, 0.0)
}
func manifoldElsetAddAPOGEE(builder *flatbuffers.Builder, APOGEE float64) {
	builder.PrependFloat64Slot(13, APOGEE, 0.0)
}
func manifoldElsetAddPERIGEE(builder *flatbuffers.Builder, PERIGEE float64) {
	builder.PrependFloat64Slot(14, PERIGEE, 0.0)
}
func manifoldElsetAddPERIOD(builder *flatbuffers.Builder, PERIOD float64) {
	builder.PrependFloat64Slot(15, PERIOD, 0.0)
}
func manifoldElsetEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
