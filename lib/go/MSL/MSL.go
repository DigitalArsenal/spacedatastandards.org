// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package MSL

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Guided Missiles
type MSL struct {
	_tab flatbuffers.Table
}

const MSLIdentifier = "$MSL"

func GetRootAsMSL(buf []byte, offset flatbuffers.UOffsetT) *MSL {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MSL{}
	x.Init(buf, n+offset)
	return x
}

func FinishMSLBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(MSLIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func MSLBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, MSLIdentifier)
}

func GetSizePrefixedRootAsMSL(buf []byte, offset flatbuffers.UOffsetT) *MSL {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &MSL{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedMSLBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(MSLIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedMSLBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, MSLIdentifier)
}

func (rcv *MSL) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MSL) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *MSL) POSITION_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutatePOSITION_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(4, n)
}

func (rcv *MSL) POSITION_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutatePOSITION_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

func (rcv *MSL) POSITION_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutatePOSITION_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(8, n)
}

func (rcv *MSL) VELOCITY_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateVELOCITY_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

func (rcv *MSL) VELOCITY_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateVELOCITY_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

func (rcv *MSL) VELOCITY_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateVELOCITY_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

func (rcv *MSL) ATTITUDE_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateATTITUDE_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

func (rcv *MSL) ATTITUDE_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateATTITUDE_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

func (rcv *MSL) ATTITUDE_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateATTITUDE_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

func (rcv *MSL) ATTITUDE_W() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateATTITUDE_W(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

func (rcv *MSL) OMEGA_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateOMEGA_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

func (rcv *MSL) OMEGA_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateOMEGA_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

func (rcv *MSL) OMEGA_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateOMEGA_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

func (rcv *MSL) MASS() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateMASS(n float64) bool {
	return rcv._tab.MutateFloat64Slot(30, n)
}

func (rcv *MSL) MASS_INITIAL() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateMASS_INITIAL(n float64) bool {
	return rcv._tab.MutateFloat64Slot(32, n)
}

func (rcv *MSL) TARGET_POSITION_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateTARGET_POSITION_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(34, n)
}

func (rcv *MSL) TARGET_POSITION_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateTARGET_POSITION_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(36, n)
}

func (rcv *MSL) TARGET_POSITION_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateTARGET_POSITION_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

func (rcv *MSL) TARGET_VELOCITY_X() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateTARGET_VELOCITY_X(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

func (rcv *MSL) TARGET_VELOCITY_Y() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateTARGET_VELOCITY_Y(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

func (rcv *MSL) TARGET_VELOCITY_Z() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateTARGET_VELOCITY_Z(n float64) bool {
	return rcv._tab.MutateFloat64Slot(44, n)
}

func (rcv *MSL) MISS_DISTANCE() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateMISS_DISTANCE(n float64) bool {
	return rcv._tab.MutateFloat64Slot(46, n)
}

func (rcv *MSL) SEEKER() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MSL) MOTOR() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MSL) GUIDANCE_CMD() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MSL) PHASE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MSL) MutatePHASE(n byte) bool {
	return rcv._tab.MutateByteSlot(54, n)
}

func (rcv *MSL) GUIDANCE_LAW() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MSL) MutateGUIDANCE_LAW(n byte) bool {
	return rcv._tab.MutateByteSlot(56, n)
}

func (rcv *MSL) TYPE() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MSL) MutateTYPE(n byte) bool {
	return rcv._tab.MutateByteSlot(58, n)
}

func (rcv *MSL) ARMED() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MSL) MutateARMED(n byte) bool {
	return rcv._tab.MutateByteSlot(60, n)
}

func (rcv *MSL) TIME_OF_FLIGHT() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateTIME_OF_FLIGHT(n float32) bool {
	return rcv._tab.MutateFloat32Slot(62, n)
}

func (rcv *MSL) MAX_G() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *MSL) MutateMAX_G(n float32) bool {
	return rcv._tab.MutateFloat32Slot(64, n)
}

func (rcv *MSL) RESERVED(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *MSL) RESERVEDLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *MSL) RESERVEDBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MSL) MutateRESERVED(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func MSLStart(builder *flatbuffers.Builder) {
	builder.StartObject(32)
}
func MSLAddPOSITION_X(builder *flatbuffers.Builder, POSITION_X float64) {
	builder.PrependFloat64Slot(0, POSITION_X, 0.0)
}
func MSLAddPOSITION_Y(builder *flatbuffers.Builder, POSITION_Y float64) {
	builder.PrependFloat64Slot(1, POSITION_Y, 0.0)
}
func MSLAddPOSITION_Z(builder *flatbuffers.Builder, POSITION_Z float64) {
	builder.PrependFloat64Slot(2, POSITION_Z, 0.0)
}
func MSLAddVELOCITY_X(builder *flatbuffers.Builder, VELOCITY_X float64) {
	builder.PrependFloat64Slot(3, VELOCITY_X, 0.0)
}
func MSLAddVELOCITY_Y(builder *flatbuffers.Builder, VELOCITY_Y float64) {
	builder.PrependFloat64Slot(4, VELOCITY_Y, 0.0)
}
func MSLAddVELOCITY_Z(builder *flatbuffers.Builder, VELOCITY_Z float64) {
	builder.PrependFloat64Slot(5, VELOCITY_Z, 0.0)
}
func MSLAddATTITUDE_X(builder *flatbuffers.Builder, ATTITUDE_X float64) {
	builder.PrependFloat64Slot(6, ATTITUDE_X, 0.0)
}
func MSLAddATTITUDE_Y(builder *flatbuffers.Builder, ATTITUDE_Y float64) {
	builder.PrependFloat64Slot(7, ATTITUDE_Y, 0.0)
}
func MSLAddATTITUDE_Z(builder *flatbuffers.Builder, ATTITUDE_Z float64) {
	builder.PrependFloat64Slot(8, ATTITUDE_Z, 0.0)
}
func MSLAddATTITUDE_W(builder *flatbuffers.Builder, ATTITUDE_W float64) {
	builder.PrependFloat64Slot(9, ATTITUDE_W, 0.0)
}
func MSLAddOMEGA_X(builder *flatbuffers.Builder, OMEGA_X float64) {
	builder.PrependFloat64Slot(10, OMEGA_X, 0.0)
}
func MSLAddOMEGA_Y(builder *flatbuffers.Builder, OMEGA_Y float64) {
	builder.PrependFloat64Slot(11, OMEGA_Y, 0.0)
}
func MSLAddOMEGA_Z(builder *flatbuffers.Builder, OMEGA_Z float64) {
	builder.PrependFloat64Slot(12, OMEGA_Z, 0.0)
}
func MSLAddMASS(builder *flatbuffers.Builder, MASS float64) {
	builder.PrependFloat64Slot(13, MASS, 0.0)
}
func MSLAddMASS_INITIAL(builder *flatbuffers.Builder, MASS_INITIAL float64) {
	builder.PrependFloat64Slot(14, MASS_INITIAL, 0.0)
}
func MSLAddTARGET_POSITION_X(builder *flatbuffers.Builder, TARGET_POSITION_X float64) {
	builder.PrependFloat64Slot(15, TARGET_POSITION_X, 0.0)
}
func MSLAddTARGET_POSITION_Y(builder *flatbuffers.Builder, TARGET_POSITION_Y float64) {
	builder.PrependFloat64Slot(16, TARGET_POSITION_Y, 0.0)
}
func MSLAddTARGET_POSITION_Z(builder *flatbuffers.Builder, TARGET_POSITION_Z float64) {
	builder.PrependFloat64Slot(17, TARGET_POSITION_Z, 0.0)
}
func MSLAddTARGET_VELOCITY_X(builder *flatbuffers.Builder, TARGET_VELOCITY_X float64) {
	builder.PrependFloat64Slot(18, TARGET_VELOCITY_X, 0.0)
}
func MSLAddTARGET_VELOCITY_Y(builder *flatbuffers.Builder, TARGET_VELOCITY_Y float64) {
	builder.PrependFloat64Slot(19, TARGET_VELOCITY_Y, 0.0)
}
func MSLAddTARGET_VELOCITY_Z(builder *flatbuffers.Builder, TARGET_VELOCITY_Z float64) {
	builder.PrependFloat64Slot(20, TARGET_VELOCITY_Z, 0.0)
}
func MSLAddMISS_DISTANCE(builder *flatbuffers.Builder, MISS_DISTANCE float64) {
	builder.PrependFloat64Slot(21, MISS_DISTANCE, 0.0)
}
func MSLAddSEEKER(builder *flatbuffers.Builder, SEEKER flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(22, flatbuffers.UOffsetT(SEEKER), 0)
}
func MSLAddMOTOR(builder *flatbuffers.Builder, MOTOR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(23, flatbuffers.UOffsetT(MOTOR), 0)
}
func MSLAddGUIDANCE_CMD(builder *flatbuffers.Builder, GUIDANCE_CMD flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(24, flatbuffers.UOffsetT(GUIDANCE_CMD), 0)
}
func MSLAddPHASE(builder *flatbuffers.Builder, PHASE byte) {
	builder.PrependByteSlot(25, PHASE, 0)
}
func MSLAddGUIDANCE_LAW(builder *flatbuffers.Builder, GUIDANCE_LAW byte) {
	builder.PrependByteSlot(26, GUIDANCE_LAW, 0)
}
func MSLAddTYPE(builder *flatbuffers.Builder, TYPE byte) {
	builder.PrependByteSlot(27, TYPE, 0)
}
func MSLAddARMED(builder *flatbuffers.Builder, ARMED byte) {
	builder.PrependByteSlot(28, ARMED, 0)
}
func MSLAddTIME_OF_FLIGHT(builder *flatbuffers.Builder, TIME_OF_FLIGHT float32) {
	builder.PrependFloat32Slot(29, TIME_OF_FLIGHT, 0.0)
}
func MSLAddMAX_G(builder *flatbuffers.Builder, MAX_G float32) {
	builder.PrependFloat32Slot(30, MAX_G, 0.0)
}
func MSLAddRESERVED(builder *flatbuffers.Builder, RESERVED flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(31, flatbuffers.UOffsetT(RESERVED), 0)
}
func MSLStartRESERVEDVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MSLEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
