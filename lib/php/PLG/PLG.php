<?php
// automatically generated by the FlatBuffers compiler, do not modify

use \Google\FlatBuffers\Struct;
use \Google\FlatBuffers\Table;
use \Google\FlatBuffers\ByteBuffer;
use \Google\FlatBuffers\FlatBufferBuilder;

/// Plugin Manifest - WASM plugin distribution
class PLG extends Table
{
    /**
     * @param ByteBuffer $bb
     * @return PLG
     */
    public static function getRootAsPLG(ByteBuffer $bb)
    {
        $obj = new PLG();
        return ($obj->init($bb->getInt($bb->getPosition()) + $bb->getPosition(), $bb));
    }

    public static function PLGIdentifier()
    {
        return "$PLG";
    }

    public static function PLGBufferHasIdentifier(ByteBuffer $buf)
    {
        return self::__has_identifier($buf, self::PLGIdentifier());
    }

    /**
     * @param int $_i offset
     * @param ByteBuffer $_bb
     * @return PLG
     **/
    public function init($_i, ByteBuffer $_bb)
    {
        $this->bb_pos = $_i;
        $this->bb = $_bb;
        return $this;
    }

    /// Unique identifier for the plugin
    public function getPLUGIN_ID()
    {
        $o = $this->__offset(4);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Human-readable plugin name
    public function getNAME()
    {
        $o = $this->__offset(6);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Plugin version (semver format)
    public function getVERSION()
    {
        $o = $this->__offset(8);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Detailed description of plugin functionality
    public function getDESCRIPTION()
    {
        $o = $this->__offset(10);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Type/category of the plugin
    /**
     * @return sbyte
     */
    public function getPLUGIN_TYPE()
    {
        $o = $this->__offset(12);
        return $o != 0 ? $this->bb->getSbyte($o + $this->bb_pos) : \pluginType::Sensor;
    }

    /// ABI version for compatibility checking
    /**
     * @return uint
     */
    public function getABI_VERSION()
    {
        $o = $this->__offset(14);
        return $o != 0 ? $this->bb->getUint($o + $this->bb_pos) : 1;
    }

    /// SHA256 hash of the decrypted WASM binary
    /**
     * @param int offset
     * @return byte
     */
    public function getWASM_HASH($j)
    {
        $o = $this->__offset(16);
        return $o != 0 ? $this->bb->getByte($this->__vector($o) + $j * 1) : 0;
    }

    /**
     * @return int
     */
    public function getWASM_HASHLength()
    {
        $o = $this->__offset(16);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return string
     */
    public function getWASM_HASHBytes()
    {
        return $this->__vector_as_bytes(16);
    }

    /// Size of WASM binary in bytes
    /**
     * @return ulong
     */
    public function getWASM_SIZE()
    {
        $o = $this->__offset(18);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : 0;
    }

    /// IPFS CID of the encrypted WASM binary
    public function getWASM_CID()
    {
        $o = $this->__offset(20);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Entry point functions exported by the plugin
    /**
     * @returnVectorOffset
     */
    public function getENTRY_FUNCTIONS($j)
    {
        $o = $this->__offset(22);
        $obj = new EntryFunction();
        return $o != 0 ? $obj->init($this->__indirect($this->__vector($o) + $j * 4), $this->bb) : null;
    }

    /**
     * @return int
     */
    public function getENTRY_FUNCTIONSLength()
    {
        $o = $this->__offset(22);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// FlatBuffer schemas required by this plugin
    /**
     * @param int offset
     * @return string
     */
    public function getREQUIRED_SCHEMAS($j)
    {
        $o = $this->__offset(24);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getREQUIRED_SCHEMASLength()
    {
        $o = $this->__offset(24);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Other plugins this depends on
    /**
     * @returnVectorOffset
     */
    public function getDEPENDENCIES($j)
    {
        $o = $this->__offset(26);
        $obj = new PluginDependency();
        return $o != 0 ? $obj->init($this->__indirect($this->__vector($o) + $j * 4), $this->bb) : null;
    }

    /**
     * @return int
     */
    public function getDEPENDENCIESLength()
    {
        $o = $this->__offset(26);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Capabilities provided by this plugin
    /**
     * @returnVectorOffset
     */
    public function getCAPABILITIES($j)
    {
        $o = $this->__offset(28);
        $obj = new PluginCapability();
        return $o != 0 ? $obj->init($this->__indirect($this->__vector($o) + $j * 4), $this->bb) : null;
    }

    /**
     * @return int
     */
    public function getCAPABILITIESLength()
    {
        $o = $this->__offset(28);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Peer ID of the plugin provider
    public function getPROVIDER_PEER_ID()
    {
        $o = $this->__offset(30);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// IPFS CID of provider's EPM (Entity Profile Message)
    public function getPROVIDER_EPM_CID()
    {
        $o = $this->__offset(32);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Whether the WASM binary is encrypted
    /**
     * @return bool
     */
    public function getENCRYPTED()
    {
        $o = $this->__offset(34);
        return $o != 0 ? $this->bb->getBool($o + $this->bb_pos) : true;
    }

    /// Minimum permissions required to run
    /**
     * @param int offset
     * @return string
     */
    public function getMIN_PERMISSIONS($j)
    {
        $o = $this->__offset(36);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getMIN_PERMISSIONSLength()
    {
        $o = $this->__offset(36);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Unix timestamp when plugin was created
    /**
     * @return ulong
     */
    public function getCREATED_AT()
    {
        $o = $this->__offset(38);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : 0;
    }

    /// Unix timestamp when plugin was last updated
    /**
     * @return ulong
     */
    public function getUPDATED_AT()
    {
        $o = $this->__offset(40);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : 0;
    }

    /// URL to plugin documentation
    public function getDOCUMENTATION_URL()
    {
        $o = $this->__offset(42);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// URL to plugin icon/logo
    public function getICON_URL()
    {
        $o = $this->__offset(44);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// License identifier (SPDX format)
    public function getLICENSE()
    {
        $o = $this->__offset(46);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Ed25519 signature from provider over manifest
    /**
     * @param int offset
     * @return byte
     */
    public function getSIGNATURE($j)
    {
        $o = $this->__offset(48);
        return $o != 0 ? $this->bb->getByte($this->__vector($o) + $j * 1) : 0;
    }

    /**
     * @return int
     */
    public function getSIGNATURELength()
    {
        $o = $this->__offset(48);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return string
     */
    public function getSIGNATUREBytes()
    {
        return $this->__vector_as_bytes(48);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return void
     */
    public static function startPLG(FlatBufferBuilder $builder)
    {
        $builder->StartObject(23);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return PLG
     */
    public static function createPLG(FlatBufferBuilder $builder, $PLUGIN_ID, $NAME, $VERSION, $DESCRIPTION, $PLUGIN_TYPE, $ABI_VERSION, $WASM_HASH, $WASM_SIZE, $WASM_CID, $ENTRY_FUNCTIONS, $REQUIRED_SCHEMAS, $DEPENDENCIES, $CAPABILITIES, $PROVIDER_PEER_ID, $PROVIDER_EPM_CID, $ENCRYPTED, $MIN_PERMISSIONS, $CREATED_AT, $UPDATED_AT, $DOCUMENTATION_URL, $ICON_URL, $LICENSE, $SIGNATURE)
    {
        $builder->startObject(23);
        self::addPLUGIN_ID($builder, $PLUGIN_ID);
        self::addNAME($builder, $NAME);
        self::addVERSION($builder, $VERSION);
        self::addDESCRIPTION($builder, $DESCRIPTION);
        self::addPLUGIN_TYPE($builder, $PLUGIN_TYPE);
        self::addABI_VERSION($builder, $ABI_VERSION);
        self::addWASM_HASH($builder, $WASM_HASH);
        self::addWASM_SIZE($builder, $WASM_SIZE);
        self::addWASM_CID($builder, $WASM_CID);
        self::addENTRY_FUNCTIONS($builder, $ENTRY_FUNCTIONS);
        self::addREQUIRED_SCHEMAS($builder, $REQUIRED_SCHEMAS);
        self::addDEPENDENCIES($builder, $DEPENDENCIES);
        self::addCAPABILITIES($builder, $CAPABILITIES);
        self::addPROVIDER_PEER_ID($builder, $PROVIDER_PEER_ID);
        self::addPROVIDER_EPM_CID($builder, $PROVIDER_EPM_CID);
        self::addENCRYPTED($builder, $ENCRYPTED);
        self::addMIN_PERMISSIONS($builder, $MIN_PERMISSIONS);
        self::addCREATED_AT($builder, $CREATED_AT);
        self::addUPDATED_AT($builder, $UPDATED_AT);
        self::addDOCUMENTATION_URL($builder, $DOCUMENTATION_URL);
        self::addICON_URL($builder, $ICON_URL);
        self::addLICENSE($builder, $LICENSE);
        self::addSIGNATURE($builder, $SIGNATURE);
        $o = $builder->endObject();
        $builder->required($o, 4);  // PLUGIN_ID
        $builder->required($o, 6);  // NAME
        $builder->required($o, 8);  // VERSION
        return $o;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addPLUGIN_ID(FlatBufferBuilder $builder, $PLUGIN_ID)
    {
        $builder->addOffsetX(0, $PLUGIN_ID, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addNAME(FlatBufferBuilder $builder, $NAME)
    {
        $builder->addOffsetX(1, $NAME, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addVERSION(FlatBufferBuilder $builder, $VERSION)
    {
        $builder->addOffsetX(2, $VERSION, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addDESCRIPTION(FlatBufferBuilder $builder, $DESCRIPTION)
    {
        $builder->addOffsetX(3, $DESCRIPTION, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param sbyte
     * @return void
     */
    public static function addPLUGIN_TYPE(FlatBufferBuilder $builder, $PLUGIN_TYPE)
    {
        $builder->addSbyteX(4, $PLUGIN_TYPE, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param uint
     * @return void
     */
    public static function addABI_VERSION(FlatBufferBuilder $builder, $ABI_VERSION)
    {
        $builder->addUintX(5, $ABI_VERSION, 1);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addWASM_HASH(FlatBufferBuilder $builder, $WASM_HASH)
    {
        $builder->addOffsetX(6, $WASM_HASH, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createWASM_HASHVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(1, count($data), 1);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putByte($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startWASM_HASHVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(1, $numElems, 1);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addWASM_SIZE(FlatBufferBuilder $builder, $WASM_SIZE)
    {
        $builder->addUlongX(7, $WASM_SIZE, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addWASM_CID(FlatBufferBuilder $builder, $WASM_CID)
    {
        $builder->addOffsetX(8, $WASM_CID, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addENTRY_FUNCTIONS(FlatBufferBuilder $builder, $ENTRY_FUNCTIONS)
    {
        $builder->addOffsetX(9, $ENTRY_FUNCTIONS, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createENTRY_FUNCTIONSVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startENTRY_FUNCTIONSVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addREQUIRED_SCHEMAS(FlatBufferBuilder $builder, $REQUIRED_SCHEMAS)
    {
        $builder->addOffsetX(10, $REQUIRED_SCHEMAS, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createREQUIRED_SCHEMASVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startREQUIRED_SCHEMASVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addDEPENDENCIES(FlatBufferBuilder $builder, $DEPENDENCIES)
    {
        $builder->addOffsetX(11, $DEPENDENCIES, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createDEPENDENCIESVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startDEPENDENCIESVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addCAPABILITIES(FlatBufferBuilder $builder, $CAPABILITIES)
    {
        $builder->addOffsetX(12, $CAPABILITIES, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createCAPABILITIESVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startCAPABILITIESVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addPROVIDER_PEER_ID(FlatBufferBuilder $builder, $PROVIDER_PEER_ID)
    {
        $builder->addOffsetX(13, $PROVIDER_PEER_ID, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addPROVIDER_EPM_CID(FlatBufferBuilder $builder, $PROVIDER_EPM_CID)
    {
        $builder->addOffsetX(14, $PROVIDER_EPM_CID, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param bool
     * @return void
     */
    public static function addENCRYPTED(FlatBufferBuilder $builder, $ENCRYPTED)
    {
        $builder->addBoolX(15, $ENCRYPTED, false);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addMIN_PERMISSIONS(FlatBufferBuilder $builder, $MIN_PERMISSIONS)
    {
        $builder->addOffsetX(16, $MIN_PERMISSIONS, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createMIN_PERMISSIONSVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startMIN_PERMISSIONSVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addCREATED_AT(FlatBufferBuilder $builder, $CREATED_AT)
    {
        $builder->addUlongX(17, $CREATED_AT, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addUPDATED_AT(FlatBufferBuilder $builder, $UPDATED_AT)
    {
        $builder->addUlongX(18, $UPDATED_AT, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addDOCUMENTATION_URL(FlatBufferBuilder $builder, $DOCUMENTATION_URL)
    {
        $builder->addOffsetX(19, $DOCUMENTATION_URL, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addICON_URL(FlatBufferBuilder $builder, $ICON_URL)
    {
        $builder->addOffsetX(20, $ICON_URL, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addLICENSE(FlatBufferBuilder $builder, $LICENSE)
    {
        $builder->addOffsetX(21, $LICENSE, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addSIGNATURE(FlatBufferBuilder $builder, $SIGNATURE)
    {
        $builder->addOffsetX(22, $SIGNATURE, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createSIGNATUREVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(1, count($data), 1);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putByte($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startSIGNATUREVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(1, $numElems, 1);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return int table offset
     */
    public static function endPLG(FlatBufferBuilder $builder)
    {
        $o = $builder->endObject();
        $builder->required($o, 4);  // PLUGIN_ID
        $builder->required($o, 6);  // NAME
        $builder->required($o, 8);  // VERSION
        return $o;
    }

    public static function finishPLGBuffer(FlatBufferBuilder $builder, $offset)
    {
        $builder->finish($offset, "$PLG");
    }
}
