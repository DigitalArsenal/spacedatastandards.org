<?php
// automatically generated by the FlatBuffers compiler, do not modify

use \Google\FlatBuffers\Struct;
use \Google\FlatBuffers\Table;
use \Google\FlatBuffers\ByteBuffer;
use \Google\FlatBuffers\FlatBufferBuilder;

/// Storefront Listing - Data marketplace listing
class STF extends Table
{
    /**
     * @param ByteBuffer $bb
     * @return STF
     */
    public static function getRootAsSTF(ByteBuffer $bb)
    {
        $obj = new STF();
        return ($obj->init($bb->getInt($bb->getPosition()) + $bb->getPosition(), $bb));
    }

    public static function STFIdentifier()
    {
        return "$STF";
    }

    public static function STFBufferHasIdentifier(ByteBuffer $buf)
    {
        return self::__has_identifier($buf, self::STFIdentifier());
    }

    /**
     * @param int $_i offset
     * @param ByteBuffer $_bb
     * @return STF
     **/
    public function init($_i, ByteBuffer $_bb)
    {
        $this->bb_pos = $_i;
        $this->bb = $_bb;
        return $this;
    }

    /// Unique identifier for the listing
    public function getLISTING_ID()
    {
        $o = $this->__offset(4);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Peer ID of the data provider
    public function getPROVIDER_PEER_ID()
    {
        $o = $this->__offset(6);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// IPFS CID of provider's EPM (Entity Profile Message)
    public function getPROVIDER_EPM_CID()
    {
        $o = $this->__offset(8);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Title of the data listing
    public function getTITLE()
    {
        $o = $this->__offset(10);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Detailed description of the data offering
    public function getDESCRIPTION()
    {
        $o = $this->__offset(12);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// SDS data types offered, e.g., ["OMM", "CDM", "TLE"]
    /**
     * @param int offset
     * @return string
     */
    public function getDATA_TYPES($j)
    {
        $o = $this->__offset(14);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getDATA_TYPESLength()
    {
        $o = $this->__offset(14);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Coverage information (spatial and temporal)
    public function getCOVERAGE()
    {
        $obj = new DataCoverage();
        $o = $this->__offset(16);
        return $o != 0 ? $obj->init($this->__indirect($o + $this->bb_pos), $this->bb) : 0;
    }

    /// IPFS CID of sample data
    public function getSAMPLE_CID()
    {
        $o = $this->__offset(18);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Type of access offered
    /**
     * @return sbyte
     */
    public function getACCESS_TYPE()
    {
        $o = $this->__offset(20);
        return $o != 0 ? $this->bb->getSbyte($o + $this->bb_pos) : \accessType::OneTime;
    }

    /// Whether encryption is required for data delivery
    /**
     * @return bool
     */
    public function getENCRYPTION_REQUIRED()
    {
        $o = $this->__offset(22);
        return $o != 0 ? $this->bb->getBool($o + $this->bb_pos) : false;
    }

    /// Available pricing tiers
    /**
     * @returnVectorOffset
     */
    public function getPRICING($j)
    {
        $o = $this->__offset(24);
        $obj = new PricingTier();
        return $o != 0 ? $obj->init($this->__indirect($this->__vector($o) + $j * 4), $this->bb) : null;
    }

    /**
     * @return int
     */
    public function getPRICINGLength()
    {
        $o = $this->__offset(24);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Payment methods accepted
    /**
     * @param int offset
     * @return sbyte
     */
    public function getACCEPTED_PAYMENTS($j)
    {
        $o = $this->__offset(26);
        return $o != 0 ? $this->bb->getSbyte($this->__vector($o) + $j * 1) : \paymentMethod::Crypto_ETH;
    }

    /**
     * @return int
     */
    public function getACCEPTED_PAYMENTSLength()
    {
        $o = $this->__offset(26);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Unix timestamp when listing was created
    /**
     * @return ulong
     */
    public function getCREATED_AT()
    {
        $o = $this->__offset(28);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : 0;
    }

    /// Unix timestamp when listing was last updated
    /**
     * @return ulong
     */
    public function getUPDATED_AT()
    {
        $o = $this->__offset(30);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : 0;
    }

    /// Whether the listing is currently active
    /**
     * @return bool
     */
    public function getACTIVE()
    {
        $o = $this->__offset(32);
        return $o != 0 ? $this->bb->getBool($o + $this->bb_pos) : false;
    }

    /// Ed25519 signature from provider
    /**
     * @param int offset
     * @return byte
     */
    public function getSIGNATURE($j)
    {
        $o = $this->__offset(34);
        return $o != 0 ? $this->bb->getByte($this->__vector($o) + $j * 1) : 0;
    }

    /**
     * @return int
     */
    public function getSIGNATURELength()
    {
        $o = $this->__offset(34);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return string
     */
    public function getSIGNATUREBytes()
    {
        return $this->__vector_as_bytes(34);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return void
     */
    public static function startSTF(FlatBufferBuilder $builder)
    {
        $builder->StartObject(16);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return STF
     */
    public static function createSTF(FlatBufferBuilder $builder, $LISTING_ID, $PROVIDER_PEER_ID, $PROVIDER_EPM_CID, $TITLE, $DESCRIPTION, $DATA_TYPES, $COVERAGE, $SAMPLE_CID, $ACCESS_TYPE, $ENCRYPTION_REQUIRED, $PRICING, $ACCEPTED_PAYMENTS, $CREATED_AT, $UPDATED_AT, $ACTIVE, $SIGNATURE)
    {
        $builder->startObject(16);
        self::addLISTING_ID($builder, $LISTING_ID);
        self::addPROVIDER_PEER_ID($builder, $PROVIDER_PEER_ID);
        self::addPROVIDER_EPM_CID($builder, $PROVIDER_EPM_CID);
        self::addTITLE($builder, $TITLE);
        self::addDESCRIPTION($builder, $DESCRIPTION);
        self::addDATA_TYPES($builder, $DATA_TYPES);
        self::addCOVERAGE($builder, $COVERAGE);
        self::addSAMPLE_CID($builder, $SAMPLE_CID);
        self::addACCESS_TYPE($builder, $ACCESS_TYPE);
        self::addENCRYPTION_REQUIRED($builder, $ENCRYPTION_REQUIRED);
        self::addPRICING($builder, $PRICING);
        self::addACCEPTED_PAYMENTS($builder, $ACCEPTED_PAYMENTS);
        self::addCREATED_AT($builder, $CREATED_AT);
        self::addUPDATED_AT($builder, $UPDATED_AT);
        self::addACTIVE($builder, $ACTIVE);
        self::addSIGNATURE($builder, $SIGNATURE);
        $o = $builder->endObject();
        $builder->required($o, 4);  // LISTING_ID
        $builder->required($o, 6);  // PROVIDER_PEER_ID
        $builder->required($o, 10);  // TITLE
        return $o;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addLISTING_ID(FlatBufferBuilder $builder, $LISTING_ID)
    {
        $builder->addOffsetX(0, $LISTING_ID, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addPROVIDER_PEER_ID(FlatBufferBuilder $builder, $PROVIDER_PEER_ID)
    {
        $builder->addOffsetX(1, $PROVIDER_PEER_ID, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addPROVIDER_EPM_CID(FlatBufferBuilder $builder, $PROVIDER_EPM_CID)
    {
        $builder->addOffsetX(2, $PROVIDER_EPM_CID, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addTITLE(FlatBufferBuilder $builder, $TITLE)
    {
        $builder->addOffsetX(3, $TITLE, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addDESCRIPTION(FlatBufferBuilder $builder, $DESCRIPTION)
    {
        $builder->addOffsetX(4, $DESCRIPTION, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addDATA_TYPES(FlatBufferBuilder $builder, $DATA_TYPES)
    {
        $builder->addOffsetX(5, $DATA_TYPES, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createDATA_TYPESVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startDATA_TYPESVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addCOVERAGE(FlatBufferBuilder $builder, $COVERAGE)
    {
        $builder->addOffsetX(6, $COVERAGE, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addSAMPLE_CID(FlatBufferBuilder $builder, $SAMPLE_CID)
    {
        $builder->addOffsetX(7, $SAMPLE_CID, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param sbyte
     * @return void
     */
    public static function addACCESS_TYPE(FlatBufferBuilder $builder, $ACCESS_TYPE)
    {
        $builder->addSbyteX(8, $ACCESS_TYPE, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param bool
     * @return void
     */
    public static function addENCRYPTION_REQUIRED(FlatBufferBuilder $builder, $ENCRYPTION_REQUIRED)
    {
        $builder->addBoolX(9, $ENCRYPTION_REQUIRED, false);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addPRICING(FlatBufferBuilder $builder, $PRICING)
    {
        $builder->addOffsetX(10, $PRICING, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createPRICINGVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startPRICINGVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addACCEPTED_PAYMENTS(FlatBufferBuilder $builder, $ACCEPTED_PAYMENTS)
    {
        $builder->addOffsetX(11, $ACCEPTED_PAYMENTS, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createACCEPTED_PAYMENTSVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(1, count($data), 1);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putSbyte($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startACCEPTED_PAYMENTSVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(1, $numElems, 1);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addCREATED_AT(FlatBufferBuilder $builder, $CREATED_AT)
    {
        $builder->addUlongX(12, $CREATED_AT, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addUPDATED_AT(FlatBufferBuilder $builder, $UPDATED_AT)
    {
        $builder->addUlongX(13, $UPDATED_AT, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param bool
     * @return void
     */
    public static function addACTIVE(FlatBufferBuilder $builder, $ACTIVE)
    {
        $builder->addBoolX(14, $ACTIVE, false);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addSIGNATURE(FlatBufferBuilder $builder, $SIGNATURE)
    {
        $builder->addOffsetX(15, $SIGNATURE, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createSIGNATUREVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(1, count($data), 1);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putByte($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startSIGNATUREVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(1, $numElems, 1);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return int table offset
     */
    public static function endSTF(FlatBufferBuilder $builder)
    {
        $o = $builder->endObject();
        $builder->required($o, 4);  // LISTING_ID
        $builder->required($o, 6);  // PROVIDER_PEER_ID
        $builder->required($o, 10);  // TITLE
        return $o;
    }

    public static function finishSTFBuffer(FlatBufferBuilder $builder, $offset)
    {
        $builder->finish($offset, "$STF");
    }
}
