# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# GPX Document
class GPX(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = GPX()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsGPX(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def GPXBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x47\x50\x58", size_prefixed=size_prefixed)

    # GPX
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # GPX schema version
    # GPX
    def VERSION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Creator software/organization
    # GPX
    def CREATOR(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # File name
    # GPX
    def NAME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # File description
    # GPX
    def DESCRIPTION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Person or organization who created the file
    # GPX
    def AUTHOR_NAME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Author email
    # GPX
    def AUTHOR_EMAIL(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Author link
    # GPX
    def AUTHOR_LINK(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from GPXLink import GPXLink
            obj = GPXLink()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Copyright holder
    # GPX
    def COPYRIGHT_AUTHOR(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Copyright year
    # GPX
    def COPYRIGHT_YEAR(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Copyright license URL
    # GPX
    def COPYRIGHT_LICENSE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Links to additional information
    # GPX
    def LINKS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from GPXLink import GPXLink
            obj = GPXLink()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # GPX
    def LINKSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # GPX
    def LINKSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return o == 0

    # Creation timestamp (ISO 8601)
    # GPX
    def TIME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Keywords
    # GPX
    def KEYWORDS(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Minimum latitude of bounding box
    # GPX
    def BOUNDS_MIN_LAT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Minimum longitude of bounding box
    # GPX
    def BOUNDS_MIN_LON(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Maximum latitude of bounding box
    # GPX
    def BOUNDS_MAX_LAT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Maximum longitude of bounding box
    # GPX
    def BOUNDS_MAX_LON(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Waypoints
    # GPX
    def WAYPOINTS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from GPXWaypoint import GPXWaypoint
            obj = GPXWaypoint()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # GPX
    def WAYPOINTSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # GPX
    def WAYPOINTSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        return o == 0

    # Routes
    # GPX
    def ROUTES(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from GPXRoute import GPXRoute
            obj = GPXRoute()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # GPX
    def ROUTESLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # GPX
    def ROUTESIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        return o == 0

    # Tracks
    # GPX
    def TRACKS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from GPXTrack import GPXTrack
            obj = GPXTrack()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # GPX
    def TRACKSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # GPX
    def TRACKSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        return o == 0

def GPXStart(builder):
    builder.StartObject(20)

def Start(builder):
    GPXStart(builder)

def GPXAddVERSION(builder, VERSION):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(VERSION), 0)

def AddVERSION(builder, VERSION):
    GPXAddVERSION(builder, VERSION)

def GPXAddCREATOR(builder, CREATOR):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(CREATOR), 0)

def AddCREATOR(builder, CREATOR):
    GPXAddCREATOR(builder, CREATOR)

def GPXAddNAME(builder, NAME):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(NAME), 0)

def AddNAME(builder, NAME):
    GPXAddNAME(builder, NAME)

def GPXAddDESCRIPTION(builder, DESCRIPTION):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(DESCRIPTION), 0)

def AddDESCRIPTION(builder, DESCRIPTION):
    GPXAddDESCRIPTION(builder, DESCRIPTION)

def GPXAddAUTHOR_NAME(builder, AUTHOR_NAME):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(AUTHOR_NAME), 0)

def AddAUTHOR_NAME(builder, AUTHOR_NAME):
    GPXAddAUTHOR_NAME(builder, AUTHOR_NAME)

def GPXAddAUTHOR_EMAIL(builder, AUTHOR_EMAIL):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(AUTHOR_EMAIL), 0)

def AddAUTHOR_EMAIL(builder, AUTHOR_EMAIL):
    GPXAddAUTHOR_EMAIL(builder, AUTHOR_EMAIL)

def GPXAddAUTHOR_LINK(builder, AUTHOR_LINK):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(AUTHOR_LINK), 0)

def AddAUTHOR_LINK(builder, AUTHOR_LINK):
    GPXAddAUTHOR_LINK(builder, AUTHOR_LINK)

def GPXAddCOPYRIGHT_AUTHOR(builder, COPYRIGHT_AUTHOR):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(COPYRIGHT_AUTHOR), 0)

def AddCOPYRIGHT_AUTHOR(builder, COPYRIGHT_AUTHOR):
    GPXAddCOPYRIGHT_AUTHOR(builder, COPYRIGHT_AUTHOR)

def GPXAddCOPYRIGHT_YEAR(builder, COPYRIGHT_YEAR):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(COPYRIGHT_YEAR), 0)

def AddCOPYRIGHT_YEAR(builder, COPYRIGHT_YEAR):
    GPXAddCOPYRIGHT_YEAR(builder, COPYRIGHT_YEAR)

def GPXAddCOPYRIGHT_LICENSE(builder, COPYRIGHT_LICENSE):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(COPYRIGHT_LICENSE), 0)

def AddCOPYRIGHT_LICENSE(builder, COPYRIGHT_LICENSE):
    GPXAddCOPYRIGHT_LICENSE(builder, COPYRIGHT_LICENSE)

def GPXAddLINKS(builder, LINKS):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(LINKS), 0)

def AddLINKS(builder, LINKS):
    GPXAddLINKS(builder, LINKS)

def GPXStartLINKSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartLINKSVector(builder, numElems):
    return GPXStartLINKSVector(builder, numElems)

def GPXAddTIME(builder, TIME):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(TIME), 0)

def AddTIME(builder, TIME):
    GPXAddTIME(builder, TIME)

def GPXAddKEYWORDS(builder, KEYWORDS):
    builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(KEYWORDS), 0)

def AddKEYWORDS(builder, KEYWORDS):
    GPXAddKEYWORDS(builder, KEYWORDS)

def GPXAddBOUNDS_MIN_LAT(builder, BOUNDS_MIN_LAT):
    builder.PrependFloat64Slot(13, BOUNDS_MIN_LAT, 0.0)

def AddBOUNDS_MIN_LAT(builder, BOUNDS_MIN_LAT):
    GPXAddBOUNDS_MIN_LAT(builder, BOUNDS_MIN_LAT)

def GPXAddBOUNDS_MIN_LON(builder, BOUNDS_MIN_LON):
    builder.PrependFloat64Slot(14, BOUNDS_MIN_LON, 0.0)

def AddBOUNDS_MIN_LON(builder, BOUNDS_MIN_LON):
    GPXAddBOUNDS_MIN_LON(builder, BOUNDS_MIN_LON)

def GPXAddBOUNDS_MAX_LAT(builder, BOUNDS_MAX_LAT):
    builder.PrependFloat64Slot(15, BOUNDS_MAX_LAT, 0.0)

def AddBOUNDS_MAX_LAT(builder, BOUNDS_MAX_LAT):
    GPXAddBOUNDS_MAX_LAT(builder, BOUNDS_MAX_LAT)

def GPXAddBOUNDS_MAX_LON(builder, BOUNDS_MAX_LON):
    builder.PrependFloat64Slot(16, BOUNDS_MAX_LON, 0.0)

def AddBOUNDS_MAX_LON(builder, BOUNDS_MAX_LON):
    GPXAddBOUNDS_MAX_LON(builder, BOUNDS_MAX_LON)

def GPXAddWAYPOINTS(builder, WAYPOINTS):
    builder.PrependUOffsetTRelativeSlot(17, flatbuffers.number_types.UOffsetTFlags.py_type(WAYPOINTS), 0)

def AddWAYPOINTS(builder, WAYPOINTS):
    GPXAddWAYPOINTS(builder, WAYPOINTS)

def GPXStartWAYPOINTSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartWAYPOINTSVector(builder, numElems):
    return GPXStartWAYPOINTSVector(builder, numElems)

def GPXAddROUTES(builder, ROUTES):
    builder.PrependUOffsetTRelativeSlot(18, flatbuffers.number_types.UOffsetTFlags.py_type(ROUTES), 0)

def AddROUTES(builder, ROUTES):
    GPXAddROUTES(builder, ROUTES)

def GPXStartROUTESVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartROUTESVector(builder, numElems):
    return GPXStartROUTESVector(builder, numElems)

def GPXAddTRACKS(builder, TRACKS):
    builder.PrependUOffsetTRelativeSlot(19, flatbuffers.number_types.UOffsetTFlags.py_type(TRACKS), 0)

def AddTRACKS(builder, TRACKS):
    GPXAddTRACKS(builder, TRACKS)

def GPXStartTRACKSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartTRACKSVector(builder, numElems):
    return GPXStartTRACKSVector(builder, numElems)

def GPXEnd(builder):
    return builder.EndObject()

def End(builder):
    return GPXEnd(builder)

import GPXLink
import GPXRoute
import GPXTrack
import GPXWaypoint
try:
    from typing import List, Optional
except:
    pass

class GPXT(object):

    # GPXT
    def __init__(self):
        self.VERSION = None  # type: str
        self.CREATOR = None  # type: str
        self.NAME = None  # type: str
        self.DESCRIPTION = None  # type: str
        self.AUTHOR_NAME = None  # type: str
        self.AUTHOR_EMAIL = None  # type: str
        self.AUTHOR_LINK = None  # type: Optional[GPXLink.GPXLinkT]
        self.COPYRIGHT_AUTHOR = None  # type: str
        self.COPYRIGHT_YEAR = None  # type: str
        self.COPYRIGHT_LICENSE = None  # type: str
        self.LINKS = None  # type: List[GPXLink.GPXLinkT]
        self.TIME = None  # type: str
        self.KEYWORDS = None  # type: str
        self.BOUNDS_MIN_LAT = 0.0  # type: float
        self.BOUNDS_MIN_LON = 0.0  # type: float
        self.BOUNDS_MAX_LAT = 0.0  # type: float
        self.BOUNDS_MAX_LON = 0.0  # type: float
        self.WAYPOINTS = None  # type: List[GPXWaypoint.GPXWaypointT]
        self.ROUTES = None  # type: List[GPXRoute.GPXRouteT]
        self.TRACKS = None  # type: List[GPXTrack.GPXTrackT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        GPX = GPX()
        GPX.Init(buf, pos)
        return cls.InitFromObj(GPX)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, GPX):
        x = GPXT()
        x._UnPack(GPX)
        return x

    # GPXT
    def _UnPack(self, GPX):
        if GPX is None:
            return
        self.VERSION = GPX.VERSION()
        self.CREATOR = GPX.CREATOR()
        self.NAME = GPX.NAME()
        self.DESCRIPTION = GPX.DESCRIPTION()
        self.AUTHOR_NAME = GPX.AUTHOR_NAME()
        self.AUTHOR_EMAIL = GPX.AUTHOR_EMAIL()
        if GPX.AUTHOR_LINK() is not None:
            self.AUTHOR_LINK = GPXLink.GPXLinkT.InitFromObj(GPX.AUTHOR_LINK())
        self.COPYRIGHT_AUTHOR = GPX.COPYRIGHT_AUTHOR()
        self.COPYRIGHT_YEAR = GPX.COPYRIGHT_YEAR()
        self.COPYRIGHT_LICENSE = GPX.COPYRIGHT_LICENSE()
        if not GPX.LINKSIsNone():
            self.LINKS = []
            for i in range(GPX.LINKSLength()):
                if GPX.LINKS(i) is None:
                    self.LINKS.append(None)
                else:
                    gPXLink_ = GPXLink.GPXLinkT.InitFromObj(GPX.LINKS(i))
                    self.LINKS.append(gPXLink_)
        self.TIME = GPX.TIME()
        self.KEYWORDS = GPX.KEYWORDS()
        self.BOUNDS_MIN_LAT = GPX.BOUNDS_MIN_LAT()
        self.BOUNDS_MIN_LON = GPX.BOUNDS_MIN_LON()
        self.BOUNDS_MAX_LAT = GPX.BOUNDS_MAX_LAT()
        self.BOUNDS_MAX_LON = GPX.BOUNDS_MAX_LON()
        if not GPX.WAYPOINTSIsNone():
            self.WAYPOINTS = []
            for i in range(GPX.WAYPOINTSLength()):
                if GPX.WAYPOINTS(i) is None:
                    self.WAYPOINTS.append(None)
                else:
                    gPXWaypoint_ = GPXWaypoint.GPXWaypointT.InitFromObj(GPX.WAYPOINTS(i))
                    self.WAYPOINTS.append(gPXWaypoint_)
        if not GPX.ROUTESIsNone():
            self.ROUTES = []
            for i in range(GPX.ROUTESLength()):
                if GPX.ROUTES(i) is None:
                    self.ROUTES.append(None)
                else:
                    gPXRoute_ = GPXRoute.GPXRouteT.InitFromObj(GPX.ROUTES(i))
                    self.ROUTES.append(gPXRoute_)
        if not GPX.TRACKSIsNone():
            self.TRACKS = []
            for i in range(GPX.TRACKSLength()):
                if GPX.TRACKS(i) is None:
                    self.TRACKS.append(None)
                else:
                    gPXTrack_ = GPXTrack.GPXTrackT.InitFromObj(GPX.TRACKS(i))
                    self.TRACKS.append(gPXTrack_)

    # GPXT
    def Pack(self, builder):
        if self.VERSION is not None:
            VERSION = builder.CreateString(self.VERSION)
        if self.CREATOR is not None:
            CREATOR = builder.CreateString(self.CREATOR)
        if self.NAME is not None:
            NAME = builder.CreateString(self.NAME)
        if self.DESCRIPTION is not None:
            DESCRIPTION = builder.CreateString(self.DESCRIPTION)
        if self.AUTHOR_NAME is not None:
            AUTHOR_NAME = builder.CreateString(self.AUTHOR_NAME)
        if self.AUTHOR_EMAIL is not None:
            AUTHOR_EMAIL = builder.CreateString(self.AUTHOR_EMAIL)
        if self.AUTHOR_LINK is not None:
            AUTHOR_LINK = self.AUTHOR_LINK.Pack(builder)
        if self.COPYRIGHT_AUTHOR is not None:
            COPYRIGHT_AUTHOR = builder.CreateString(self.COPYRIGHT_AUTHOR)
        if self.COPYRIGHT_YEAR is not None:
            COPYRIGHT_YEAR = builder.CreateString(self.COPYRIGHT_YEAR)
        if self.COPYRIGHT_LICENSE is not None:
            COPYRIGHT_LICENSE = builder.CreateString(self.COPYRIGHT_LICENSE)
        if self.LINKS is not None:
            LINKSlist = []
            for i in range(len(self.LINKS)):
                LINKSlist.append(self.LINKS[i].Pack(builder))
            GPXStartLINKSVector(builder, len(self.LINKS))
            for i in reversed(range(len(self.LINKS))):
                builder.PrependUOffsetTRelative(LINKSlist[i])
            LINKS = builder.EndVector()
        if self.TIME is not None:
            TIME = builder.CreateString(self.TIME)
        if self.KEYWORDS is not None:
            KEYWORDS = builder.CreateString(self.KEYWORDS)
        if self.WAYPOINTS is not None:
            WAYPOINTSlist = []
            for i in range(len(self.WAYPOINTS)):
                WAYPOINTSlist.append(self.WAYPOINTS[i].Pack(builder))
            GPXStartWAYPOINTSVector(builder, len(self.WAYPOINTS))
            for i in reversed(range(len(self.WAYPOINTS))):
                builder.PrependUOffsetTRelative(WAYPOINTSlist[i])
            WAYPOINTS = builder.EndVector()
        if self.ROUTES is not None:
            ROUTESlist = []
            for i in range(len(self.ROUTES)):
                ROUTESlist.append(self.ROUTES[i].Pack(builder))
            GPXStartROUTESVector(builder, len(self.ROUTES))
            for i in reversed(range(len(self.ROUTES))):
                builder.PrependUOffsetTRelative(ROUTESlist[i])
            ROUTES = builder.EndVector()
        if self.TRACKS is not None:
            TRACKSlist = []
            for i in range(len(self.TRACKS)):
                TRACKSlist.append(self.TRACKS[i].Pack(builder))
            GPXStartTRACKSVector(builder, len(self.TRACKS))
            for i in reversed(range(len(self.TRACKS))):
                builder.PrependUOffsetTRelative(TRACKSlist[i])
            TRACKS = builder.EndVector()
        GPXStart(builder)
        if self.VERSION is not None:
            GPXAddVERSION(builder, VERSION)
        if self.CREATOR is not None:
            GPXAddCREATOR(builder, CREATOR)
        if self.NAME is not None:
            GPXAddNAME(builder, NAME)
        if self.DESCRIPTION is not None:
            GPXAddDESCRIPTION(builder, DESCRIPTION)
        if self.AUTHOR_NAME is not None:
            GPXAddAUTHOR_NAME(builder, AUTHOR_NAME)
        if self.AUTHOR_EMAIL is not None:
            GPXAddAUTHOR_EMAIL(builder, AUTHOR_EMAIL)
        if self.AUTHOR_LINK is not None:
            GPXAddAUTHOR_LINK(builder, AUTHOR_LINK)
        if self.COPYRIGHT_AUTHOR is not None:
            GPXAddCOPYRIGHT_AUTHOR(builder, COPYRIGHT_AUTHOR)
        if self.COPYRIGHT_YEAR is not None:
            GPXAddCOPYRIGHT_YEAR(builder, COPYRIGHT_YEAR)
        if self.COPYRIGHT_LICENSE is not None:
            GPXAddCOPYRIGHT_LICENSE(builder, COPYRIGHT_LICENSE)
        if self.LINKS is not None:
            GPXAddLINKS(builder, LINKS)
        if self.TIME is not None:
            GPXAddTIME(builder, TIME)
        if self.KEYWORDS is not None:
            GPXAddKEYWORDS(builder, KEYWORDS)
        GPXAddBOUNDS_MIN_LAT(builder, self.BOUNDS_MIN_LAT)
        GPXAddBOUNDS_MIN_LON(builder, self.BOUNDS_MIN_LON)
        GPXAddBOUNDS_MAX_LAT(builder, self.BOUNDS_MAX_LAT)
        GPXAddBOUNDS_MAX_LON(builder, self.BOUNDS_MAX_LON)
        if self.WAYPOINTS is not None:
            GPXAddWAYPOINTS(builder, WAYPOINTS)
        if self.ROUTES is not None:
            GPXAddROUTES(builder, ROUTES)
        if self.TRACKS is not None:
            GPXAddTRACKS(builder, TRACKS)
        GPX = GPXEnd(builder)
        return GPX
