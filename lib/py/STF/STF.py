# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Storefront Listing - Data marketplace listing
class STF(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = STF()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSTF(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def STFBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x53\x54\x46", size_prefixed=size_prefixed)

    # STF
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Unique identifier for the listing
    # STF
    def LISTING_ID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Peer ID of the data provider
    # STF
    def PROVIDER_PEER_ID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # IPFS CID of provider's EPM (Entity Profile Message)
    # STF
    def PROVIDER_EPM_CID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Title of the data listing
    # STF
    def TITLE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Detailed description of the data offering
    # STF
    def DESCRIPTION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # SDS data types offered, e.g., ["OMM", "CDM", "TLE"]
    # STF
    def DATA_TYPES(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # STF
    def DATA_TYPESLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # STF
    def DATA_TYPESIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Coverage information (spatial and temporal)
    # STF
    def COVERAGE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from DataCoverage import DataCoverage
            obj = DataCoverage()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # IPFS CID of sample data
    # STF
    def SAMPLE_CID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Type of access offered
    # STF
    def ACCESS_TYPE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Whether encryption is required for data delivery
    # STF
    def ENCRYPTION_REQUIRED(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Available pricing tiers
    # STF
    def PRICING(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from PricingTier import PricingTier
            obj = PricingTier()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # STF
    def PRICINGLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # STF
    def PRICINGIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return o == 0

    # Payment methods accepted
    # STF
    def ACCEPTED_PAYMENTS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # STF
    def ACCEPTED_PAYMENTSAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int8Flags, o)
        return 0

    # STF
    def ACCEPTED_PAYMENTSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # STF
    def ACCEPTED_PAYMENTSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

    # Unix timestamp when listing was created
    # STF
    def CREATED_AT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # Unix timestamp when listing was last updated
    # STF
    def UPDATED_AT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # Whether the listing is currently active
    # STF
    def ACTIVE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Ed25519 signature from provider
    # STF
    def SIGNATURE(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # STF
    def SIGNATUREAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # STF
    def SIGNATURELength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # STF
    def SIGNATUREIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        return o == 0

def STFStart(builder):
    builder.StartObject(16)

def Start(builder):
    STFStart(builder)

def STFAddLISTING_ID(builder, LISTING_ID):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(LISTING_ID), 0)

def AddLISTING_ID(builder, LISTING_ID):
    STFAddLISTING_ID(builder, LISTING_ID)

def STFAddPROVIDER_PEER_ID(builder, PROVIDER_PEER_ID):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(PROVIDER_PEER_ID), 0)

def AddPROVIDER_PEER_ID(builder, PROVIDER_PEER_ID):
    STFAddPROVIDER_PEER_ID(builder, PROVIDER_PEER_ID)

def STFAddPROVIDER_EPM_CID(builder, PROVIDER_EPM_CID):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(PROVIDER_EPM_CID), 0)

def AddPROVIDER_EPM_CID(builder, PROVIDER_EPM_CID):
    STFAddPROVIDER_EPM_CID(builder, PROVIDER_EPM_CID)

def STFAddTITLE(builder, TITLE):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(TITLE), 0)

def AddTITLE(builder, TITLE):
    STFAddTITLE(builder, TITLE)

def STFAddDESCRIPTION(builder, DESCRIPTION):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(DESCRIPTION), 0)

def AddDESCRIPTION(builder, DESCRIPTION):
    STFAddDESCRIPTION(builder, DESCRIPTION)

def STFAddDATA_TYPES(builder, DATA_TYPES):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(DATA_TYPES), 0)

def AddDATA_TYPES(builder, DATA_TYPES):
    STFAddDATA_TYPES(builder, DATA_TYPES)

def STFStartDATA_TYPESVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartDATA_TYPESVector(builder, numElems):
    return STFStartDATA_TYPESVector(builder, numElems)

def STFAddCOVERAGE(builder, COVERAGE):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(COVERAGE), 0)

def AddCOVERAGE(builder, COVERAGE):
    STFAddCOVERAGE(builder, COVERAGE)

def STFAddSAMPLE_CID(builder, SAMPLE_CID):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(SAMPLE_CID), 0)

def AddSAMPLE_CID(builder, SAMPLE_CID):
    STFAddSAMPLE_CID(builder, SAMPLE_CID)

def STFAddACCESS_TYPE(builder, ACCESS_TYPE):
    builder.PrependInt8Slot(8, ACCESS_TYPE, 0)

def AddACCESS_TYPE(builder, ACCESS_TYPE):
    STFAddACCESS_TYPE(builder, ACCESS_TYPE)

def STFAddENCRYPTION_REQUIRED(builder, ENCRYPTION_REQUIRED):
    builder.PrependBoolSlot(9, ENCRYPTION_REQUIRED, 0)

def AddENCRYPTION_REQUIRED(builder, ENCRYPTION_REQUIRED):
    STFAddENCRYPTION_REQUIRED(builder, ENCRYPTION_REQUIRED)

def STFAddPRICING(builder, PRICING):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(PRICING), 0)

def AddPRICING(builder, PRICING):
    STFAddPRICING(builder, PRICING)

def STFStartPRICINGVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartPRICINGVector(builder, numElems):
    return STFStartPRICINGVector(builder, numElems)

def STFAddACCEPTED_PAYMENTS(builder, ACCEPTED_PAYMENTS):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(ACCEPTED_PAYMENTS), 0)

def AddACCEPTED_PAYMENTS(builder, ACCEPTED_PAYMENTS):
    STFAddACCEPTED_PAYMENTS(builder, ACCEPTED_PAYMENTS)

def STFStartACCEPTED_PAYMENTSVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartACCEPTED_PAYMENTSVector(builder, numElems):
    return STFStartACCEPTED_PAYMENTSVector(builder, numElems)

def STFAddCREATED_AT(builder, CREATED_AT):
    builder.PrependUint64Slot(12, CREATED_AT, 0)

def AddCREATED_AT(builder, CREATED_AT):
    STFAddCREATED_AT(builder, CREATED_AT)

def STFAddUPDATED_AT(builder, UPDATED_AT):
    builder.PrependUint64Slot(13, UPDATED_AT, 0)

def AddUPDATED_AT(builder, UPDATED_AT):
    STFAddUPDATED_AT(builder, UPDATED_AT)

def STFAddACTIVE(builder, ACTIVE):
    builder.PrependBoolSlot(14, ACTIVE, 0)

def AddACTIVE(builder, ACTIVE):
    STFAddACTIVE(builder, ACTIVE)

def STFAddSIGNATURE(builder, SIGNATURE):
    builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(SIGNATURE), 0)

def AddSIGNATURE(builder, SIGNATURE):
    STFAddSIGNATURE(builder, SIGNATURE)

def STFStartSIGNATUREVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartSIGNATUREVector(builder, numElems):
    return STFStartSIGNATUREVector(builder, numElems)

def STFEnd(builder):
    return builder.EndObject()

def End(builder):
    return STFEnd(builder)

import DataCoverage
import PricingTier
try:
    from typing import List, Optional
except:
    pass

class STFT(object):

    # STFT
    def __init__(self):
        self.LISTING_ID = None  # type: str
        self.PROVIDER_PEER_ID = None  # type: str
        self.PROVIDER_EPM_CID = None  # type: str
        self.TITLE = None  # type: str
        self.DESCRIPTION = None  # type: str
        self.DATA_TYPES = None  # type: List[str]
        self.COVERAGE = None  # type: Optional[DataCoverage.DataCoverageT]
        self.SAMPLE_CID = None  # type: str
        self.ACCESS_TYPE = 0  # type: int
        self.ENCRYPTION_REQUIRED = False  # type: bool
        self.PRICING = None  # type: List[PricingTier.PricingTierT]
        self.ACCEPTED_PAYMENTS = None  # type: List[int]
        self.CREATED_AT = 0  # type: int
        self.UPDATED_AT = 0  # type: int
        self.ACTIVE = False  # type: bool
        self.SIGNATURE = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        STF = STF()
        STF.Init(buf, pos)
        return cls.InitFromObj(STF)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, STF):
        x = STFT()
        x._UnPack(STF)
        return x

    # STFT
    def _UnPack(self, STF):
        if STF is None:
            return
        self.LISTING_ID = STF.LISTING_ID()
        self.PROVIDER_PEER_ID = STF.PROVIDER_PEER_ID()
        self.PROVIDER_EPM_CID = STF.PROVIDER_EPM_CID()
        self.TITLE = STF.TITLE()
        self.DESCRIPTION = STF.DESCRIPTION()
        if not STF.DATA_TYPESIsNone():
            self.DATA_TYPES = []
            for i in range(STF.DATA_TYPESLength()):
                self.DATA_TYPES.append(STF.DATA_TYPES(i))
        if STF.COVERAGE() is not None:
            self.COVERAGE = DataCoverage.DataCoverageT.InitFromObj(STF.COVERAGE())
        self.SAMPLE_CID = STF.SAMPLE_CID()
        self.ACCESS_TYPE = STF.ACCESS_TYPE()
        self.ENCRYPTION_REQUIRED = STF.ENCRYPTION_REQUIRED()
        if not STF.PRICINGIsNone():
            self.PRICING = []
            for i in range(STF.PRICINGLength()):
                if STF.PRICING(i) is None:
                    self.PRICING.append(None)
                else:
                    pricingTier_ = PricingTier.PricingTierT.InitFromObj(STF.PRICING(i))
                    self.PRICING.append(pricingTier_)
        if not STF.ACCEPTED_PAYMENTSIsNone():
            if np is None:
                self.ACCEPTED_PAYMENTS = []
                for i in range(STF.ACCEPTED_PAYMENTSLength()):
                    self.ACCEPTED_PAYMENTS.append(STF.ACCEPTED_PAYMENTS(i))
            else:
                self.ACCEPTED_PAYMENTS = STF.ACCEPTED_PAYMENTSAsNumpy()
        self.CREATED_AT = STF.CREATED_AT()
        self.UPDATED_AT = STF.UPDATED_AT()
        self.ACTIVE = STF.ACTIVE()
        if not STF.SIGNATUREIsNone():
            if np is None:
                self.SIGNATURE = []
                for i in range(STF.SIGNATURELength()):
                    self.SIGNATURE.append(STF.SIGNATURE(i))
            else:
                self.SIGNATURE = STF.SIGNATUREAsNumpy()

    # STFT
    def Pack(self, builder):
        if self.LISTING_ID is not None:
            LISTING_ID = builder.CreateString(self.LISTING_ID)
        if self.PROVIDER_PEER_ID is not None:
            PROVIDER_PEER_ID = builder.CreateString(self.PROVIDER_PEER_ID)
        if self.PROVIDER_EPM_CID is not None:
            PROVIDER_EPM_CID = builder.CreateString(self.PROVIDER_EPM_CID)
        if self.TITLE is not None:
            TITLE = builder.CreateString(self.TITLE)
        if self.DESCRIPTION is not None:
            DESCRIPTION = builder.CreateString(self.DESCRIPTION)
        if self.DATA_TYPES is not None:
            DATA_TYPESlist = []
            for i in range(len(self.DATA_TYPES)):
                DATA_TYPESlist.append(builder.CreateString(self.DATA_TYPES[i]))
            STFStartDATA_TYPESVector(builder, len(self.DATA_TYPES))
            for i in reversed(range(len(self.DATA_TYPES))):
                builder.PrependUOffsetTRelative(DATA_TYPESlist[i])
            DATA_TYPES = builder.EndVector()
        if self.COVERAGE is not None:
            COVERAGE = self.COVERAGE.Pack(builder)
        if self.SAMPLE_CID is not None:
            SAMPLE_CID = builder.CreateString(self.SAMPLE_CID)
        if self.PRICING is not None:
            PRICINGlist = []
            for i in range(len(self.PRICING)):
                PRICINGlist.append(self.PRICING[i].Pack(builder))
            STFStartPRICINGVector(builder, len(self.PRICING))
            for i in reversed(range(len(self.PRICING))):
                builder.PrependUOffsetTRelative(PRICINGlist[i])
            PRICING = builder.EndVector()
        if self.ACCEPTED_PAYMENTS is not None:
            if np is not None and type(self.ACCEPTED_PAYMENTS) is np.ndarray:
                ACCEPTED_PAYMENTS = builder.CreateNumpyVector(self.ACCEPTED_PAYMENTS)
            else:
                STFStartACCEPTED_PAYMENTSVector(builder, len(self.ACCEPTED_PAYMENTS))
                for i in reversed(range(len(self.ACCEPTED_PAYMENTS))):
                    builder.PrependByte(self.ACCEPTED_PAYMENTS[i])
                ACCEPTED_PAYMENTS = builder.EndVector()
        if self.SIGNATURE is not None:
            if np is not None and type(self.SIGNATURE) is np.ndarray:
                SIGNATURE = builder.CreateNumpyVector(self.SIGNATURE)
            else:
                STFStartSIGNATUREVector(builder, len(self.SIGNATURE))
                for i in reversed(range(len(self.SIGNATURE))):
                    builder.PrependUint8(self.SIGNATURE[i])
                SIGNATURE = builder.EndVector()
        STFStart(builder)
        if self.LISTING_ID is not None:
            STFAddLISTING_ID(builder, LISTING_ID)
        if self.PROVIDER_PEER_ID is not None:
            STFAddPROVIDER_PEER_ID(builder, PROVIDER_PEER_ID)
        if self.PROVIDER_EPM_CID is not None:
            STFAddPROVIDER_EPM_CID(builder, PROVIDER_EPM_CID)
        if self.TITLE is not None:
            STFAddTITLE(builder, TITLE)
        if self.DESCRIPTION is not None:
            STFAddDESCRIPTION(builder, DESCRIPTION)
        if self.DATA_TYPES is not None:
            STFAddDATA_TYPES(builder, DATA_TYPES)
        if self.COVERAGE is not None:
            STFAddCOVERAGE(builder, COVERAGE)
        if self.SAMPLE_CID is not None:
            STFAddSAMPLE_CID(builder, SAMPLE_CID)
        STFAddACCESS_TYPE(builder, self.ACCESS_TYPE)
        STFAddENCRYPTION_REQUIRED(builder, self.ENCRYPTION_REQUIRED)
        if self.PRICING is not None:
            STFAddPRICING(builder, PRICING)
        if self.ACCEPTED_PAYMENTS is not None:
            STFAddACCEPTED_PAYMENTS(builder, ACCEPTED_PAYMENTS)
        STFAddCREATED_AT(builder, self.CREATED_AT)
        STFAddUPDATED_AT(builder, self.UPDATED_AT)
        STFAddACTIVE(builder, self.ACTIVE)
        if self.SIGNATURE is not None:
            STFAddSIGNATURE(builder, SIGNATURE)
        STF = STFEnd(builder)
        return STF
