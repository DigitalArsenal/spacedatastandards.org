# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Armor and Protection
class ARM(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ARM()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsARM(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ARMBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x41\x52\x4D", size_prefixed=size_prefixed)

    # ARM
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ARM
    def THICKNESS(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # ARM
    def ANGLE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # ARM
    def MATERIAL(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # ARM
    def HARDNESS(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # ARM
    def QUALITY(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # ARM
    def ERA_TYPE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # ARM
    def ERA_EFFECTIVENESS(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # ARM
    def ERA_VS_KE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # ARM
    def RHA_EQUIVALENT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # ARM
    def NORMAL_X(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # ARM
    def NORMAL_Y(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # ARM
    def NORMAL_Z(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # ARM
    def RESERVED(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # ARM
    def RESERVEDAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # ARM
    def RESERVEDLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ARM
    def RESERVEDIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        return o == 0

def ARMStart(builder):
    builder.StartObject(13)

def Start(builder):
    ARMStart(builder)

def ARMAddTHICKNESS(builder, THICKNESS):
    builder.PrependFloat64Slot(0, THICKNESS, 0.0)

def AddTHICKNESS(builder, THICKNESS):
    ARMAddTHICKNESS(builder, THICKNESS)

def ARMAddANGLE(builder, ANGLE):
    builder.PrependFloat64Slot(1, ANGLE, 0.0)

def AddANGLE(builder, ANGLE):
    ARMAddANGLE(builder, ANGLE)

def ARMAddMATERIAL(builder, MATERIAL):
    builder.PrependUint8Slot(2, MATERIAL, 0)

def AddMATERIAL(builder, MATERIAL):
    ARMAddMATERIAL(builder, MATERIAL)

def ARMAddHARDNESS(builder, HARDNESS):
    builder.PrependUint8Slot(3, HARDNESS, 0)

def AddHARDNESS(builder, HARDNESS):
    ARMAddHARDNESS(builder, HARDNESS)

def ARMAddQUALITY(builder, QUALITY):
    builder.PrependUint8Slot(4, QUALITY, 0)

def AddQUALITY(builder, QUALITY):
    ARMAddQUALITY(builder, QUALITY)

def ARMAddERA_TYPE(builder, ERA_TYPE):
    builder.PrependUint8Slot(5, ERA_TYPE, 0)

def AddERA_TYPE(builder, ERA_TYPE):
    ARMAddERA_TYPE(builder, ERA_TYPE)

def ARMAddERA_EFFECTIVENESS(builder, ERA_EFFECTIVENESS):
    builder.PrependFloat32Slot(6, ERA_EFFECTIVENESS, 0.0)

def AddERA_EFFECTIVENESS(builder, ERA_EFFECTIVENESS):
    ARMAddERA_EFFECTIVENESS(builder, ERA_EFFECTIVENESS)

def ARMAddERA_VS_KE(builder, ERA_VS_KE):
    builder.PrependFloat32Slot(7, ERA_VS_KE, 0.0)

def AddERA_VS_KE(builder, ERA_VS_KE):
    ARMAddERA_VS_KE(builder, ERA_VS_KE)

def ARMAddRHA_EQUIVALENT(builder, RHA_EQUIVALENT):
    builder.PrependFloat32Slot(8, RHA_EQUIVALENT, 0.0)

def AddRHA_EQUIVALENT(builder, RHA_EQUIVALENT):
    ARMAddRHA_EQUIVALENT(builder, RHA_EQUIVALENT)

def ARMAddNORMAL_X(builder, NORMAL_X):
    builder.PrependFloat64Slot(9, NORMAL_X, 0.0)

def AddNORMAL_X(builder, NORMAL_X):
    ARMAddNORMAL_X(builder, NORMAL_X)

def ARMAddNORMAL_Y(builder, NORMAL_Y):
    builder.PrependFloat64Slot(10, NORMAL_Y, 0.0)

def AddNORMAL_Y(builder, NORMAL_Y):
    ARMAddNORMAL_Y(builder, NORMAL_Y)

def ARMAddNORMAL_Z(builder, NORMAL_Z):
    builder.PrependFloat64Slot(11, NORMAL_Z, 0.0)

def AddNORMAL_Z(builder, NORMAL_Z):
    ARMAddNORMAL_Z(builder, NORMAL_Z)

def ARMAddRESERVED(builder, RESERVED):
    builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(RESERVED), 0)

def AddRESERVED(builder, RESERVED):
    ARMAddRESERVED(builder, RESERVED)

def ARMStartRESERVEDVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartRESERVEDVector(builder, numElems):
    return ARMStartRESERVEDVector(builder, numElems)

def ARMEnd(builder):
    return builder.EndObject()

def End(builder):
    return ARMEnd(builder)

try:
    from typing import List
except:
    pass

class ARMT(object):

    # ARMT
    def __init__(self):
        self.THICKNESS = 0.0  # type: float
        self.ANGLE = 0.0  # type: float
        self.MATERIAL = 0  # type: int
        self.HARDNESS = 0  # type: int
        self.QUALITY = 0  # type: int
        self.ERA_TYPE = 0  # type: int
        self.ERA_EFFECTIVENESS = 0.0  # type: float
        self.ERA_VS_KE = 0.0  # type: float
        self.RHA_EQUIVALENT = 0.0  # type: float
        self.NORMAL_X = 0.0  # type: float
        self.NORMAL_Y = 0.0  # type: float
        self.NORMAL_Z = 0.0  # type: float
        self.RESERVED = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        ARM = ARM()
        ARM.Init(buf, pos)
        return cls.InitFromObj(ARM)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, ARM):
        x = ARMT()
        x._UnPack(ARM)
        return x

    # ARMT
    def _UnPack(self, ARM):
        if ARM is None:
            return
        self.THICKNESS = ARM.THICKNESS()
        self.ANGLE = ARM.ANGLE()
        self.MATERIAL = ARM.MATERIAL()
        self.HARDNESS = ARM.HARDNESS()
        self.QUALITY = ARM.QUALITY()
        self.ERA_TYPE = ARM.ERA_TYPE()
        self.ERA_EFFECTIVENESS = ARM.ERA_EFFECTIVENESS()
        self.ERA_VS_KE = ARM.ERA_VS_KE()
        self.RHA_EQUIVALENT = ARM.RHA_EQUIVALENT()
        self.NORMAL_X = ARM.NORMAL_X()
        self.NORMAL_Y = ARM.NORMAL_Y()
        self.NORMAL_Z = ARM.NORMAL_Z()
        if not ARM.RESERVEDIsNone():
            if np is None:
                self.RESERVED = []
                for i in range(ARM.RESERVEDLength()):
                    self.RESERVED.append(ARM.RESERVED(i))
            else:
                self.RESERVED = ARM.RESERVEDAsNumpy()

    # ARMT
    def Pack(self, builder):
        if self.RESERVED is not None:
            if np is not None and type(self.RESERVED) is np.ndarray:
                RESERVED = builder.CreateNumpyVector(self.RESERVED)
            else:
                ARMStartRESERVEDVector(builder, len(self.RESERVED))
                for i in reversed(range(len(self.RESERVED))):
                    builder.PrependUint8(self.RESERVED[i])
                RESERVED = builder.EndVector()
        ARMStart(builder)
        ARMAddTHICKNESS(builder, self.THICKNESS)
        ARMAddANGLE(builder, self.ANGLE)
        ARMAddMATERIAL(builder, self.MATERIAL)
        ARMAddHARDNESS(builder, self.HARDNESS)
        ARMAddQUALITY(builder, self.QUALITY)
        ARMAddERA_TYPE(builder, self.ERA_TYPE)
        ARMAddERA_EFFECTIVENESS(builder, self.ERA_EFFECTIVENESS)
        ARMAddERA_VS_KE(builder, self.ERA_VS_KE)
        ARMAddRHA_EQUIVALENT(builder, self.RHA_EQUIVALENT)
        ARMAddNORMAL_X(builder, self.NORMAL_X)
        ARMAddNORMAL_Y(builder, self.NORMAL_Y)
        ARMAddNORMAL_Z(builder, self.NORMAL_Z)
        if self.RESERVED is not None:
            ARMAddRESERVED(builder, RESERVED)
        ARM = ARMEnd(builder)
        return ARM
