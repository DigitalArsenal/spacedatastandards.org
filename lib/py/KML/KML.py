# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# KML Document
class KML(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = KML()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsKML(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def KMLBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x4B\x4D\x4C", size_prefixed=size_prefixed)

    # KML
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Document name
    # KML
    def NAME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Document description
    # KML
    def DESCRIPTION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Whether document is visible
    # KML
    def VISIBILITY(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Whether document is open in tree view
    # KML
    def OPEN(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Shared styles
    # KML
    def STYLES(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from KMLStyle import KMLStyle
            obj = KMLStyle()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # KML
    def STYLESLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # KML
    def STYLESIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Style maps
    # KML
    def STYLE_MAPS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from KMLStyleMap import KMLStyleMap
            obj = KMLStyleMap()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # KML
    def STYLE_MAPSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # KML
    def STYLE_MAPSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Top-level placemarks
    # KML
    def PLACEMARKS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from KMLPlacemark import KMLPlacemark
            obj = KMLPlacemark()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # KML
    def PLACEMARKSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # KML
    def PLACEMARKSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Top-level folders
    # KML
    def FOLDERS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from KMLFolder import KMLFolder
            obj = KMLFolder()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # KML
    def FOLDERSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # KML
    def FOLDERSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # Network links
    # KML
    def NETWORK_LINKS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from KMLNetworkLink import KMLNetworkLink
            obj = KMLNetworkLink()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # KML
    def NETWORK_LINKSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # KML
    def NETWORK_LINKSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

    # Ground overlays
    # KML
    def GROUND_OVERLAYS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from KMLGroundOverlay import KMLGroundOverlay
            obj = KMLGroundOverlay()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # KML
    def GROUND_OVERLAYSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # KML
    def GROUND_OVERLAYSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        return o == 0

def KMLStart(builder):
    builder.StartObject(10)

def Start(builder):
    KMLStart(builder)

def KMLAddNAME(builder, NAME):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(NAME), 0)

def AddNAME(builder, NAME):
    KMLAddNAME(builder, NAME)

def KMLAddDESCRIPTION(builder, DESCRIPTION):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(DESCRIPTION), 0)

def AddDESCRIPTION(builder, DESCRIPTION):
    KMLAddDESCRIPTION(builder, DESCRIPTION)

def KMLAddVISIBILITY(builder, VISIBILITY):
    builder.PrependBoolSlot(2, VISIBILITY, 0)

def AddVISIBILITY(builder, VISIBILITY):
    KMLAddVISIBILITY(builder, VISIBILITY)

def KMLAddOPEN(builder, OPEN):
    builder.PrependBoolSlot(3, OPEN, 0)

def AddOPEN(builder, OPEN):
    KMLAddOPEN(builder, OPEN)

def KMLAddSTYLES(builder, STYLES):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(STYLES), 0)

def AddSTYLES(builder, STYLES):
    KMLAddSTYLES(builder, STYLES)

def KMLStartSTYLESVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartSTYLESVector(builder, numElems):
    return KMLStartSTYLESVector(builder, numElems)

def KMLAddSTYLE_MAPS(builder, STYLE_MAPS):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(STYLE_MAPS), 0)

def AddSTYLE_MAPS(builder, STYLE_MAPS):
    KMLAddSTYLE_MAPS(builder, STYLE_MAPS)

def KMLStartSTYLE_MAPSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartSTYLE_MAPSVector(builder, numElems):
    return KMLStartSTYLE_MAPSVector(builder, numElems)

def KMLAddPLACEMARKS(builder, PLACEMARKS):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(PLACEMARKS), 0)

def AddPLACEMARKS(builder, PLACEMARKS):
    KMLAddPLACEMARKS(builder, PLACEMARKS)

def KMLStartPLACEMARKSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartPLACEMARKSVector(builder, numElems):
    return KMLStartPLACEMARKSVector(builder, numElems)

def KMLAddFOLDERS(builder, FOLDERS):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(FOLDERS), 0)

def AddFOLDERS(builder, FOLDERS):
    KMLAddFOLDERS(builder, FOLDERS)

def KMLStartFOLDERSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartFOLDERSVector(builder, numElems):
    return KMLStartFOLDERSVector(builder, numElems)

def KMLAddNETWORK_LINKS(builder, NETWORK_LINKS):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(NETWORK_LINKS), 0)

def AddNETWORK_LINKS(builder, NETWORK_LINKS):
    KMLAddNETWORK_LINKS(builder, NETWORK_LINKS)

def KMLStartNETWORK_LINKSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartNETWORK_LINKSVector(builder, numElems):
    return KMLStartNETWORK_LINKSVector(builder, numElems)

def KMLAddGROUND_OVERLAYS(builder, GROUND_OVERLAYS):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(GROUND_OVERLAYS), 0)

def AddGROUND_OVERLAYS(builder, GROUND_OVERLAYS):
    KMLAddGROUND_OVERLAYS(builder, GROUND_OVERLAYS)

def KMLStartGROUND_OVERLAYSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartGROUND_OVERLAYSVector(builder, numElems):
    return KMLStartGROUND_OVERLAYSVector(builder, numElems)

def KMLEnd(builder):
    return builder.EndObject()

def End(builder):
    return KMLEnd(builder)

import KMLFolder
import KMLGroundOverlay
import KMLNetworkLink
import KMLPlacemark
import KMLStyle
import KMLStyleMap
try:
    from typing import List
except:
    pass

class KMLT(object):

    # KMLT
    def __init__(self):
        self.NAME = None  # type: str
        self.DESCRIPTION = None  # type: str
        self.VISIBILITY = False  # type: bool
        self.OPEN = False  # type: bool
        self.STYLES = None  # type: List[KMLStyle.KMLStyleT]
        self.STYLE_MAPS = None  # type: List[KMLStyleMap.KMLStyleMapT]
        self.PLACEMARKS = None  # type: List[KMLPlacemark.KMLPlacemarkT]
        self.FOLDERS = None  # type: List[KMLFolder.KMLFolderT]
        self.NETWORK_LINKS = None  # type: List[KMLNetworkLink.KMLNetworkLinkT]
        self.GROUND_OVERLAYS = None  # type: List[KMLGroundOverlay.KMLGroundOverlayT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        KML = KML()
        KML.Init(buf, pos)
        return cls.InitFromObj(KML)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, KML):
        x = KMLT()
        x._UnPack(KML)
        return x

    # KMLT
    def _UnPack(self, KML):
        if KML is None:
            return
        self.NAME = KML.NAME()
        self.DESCRIPTION = KML.DESCRIPTION()
        self.VISIBILITY = KML.VISIBILITY()
        self.OPEN = KML.OPEN()
        if not KML.STYLESIsNone():
            self.STYLES = []
            for i in range(KML.STYLESLength()):
                if KML.STYLES(i) is None:
                    self.STYLES.append(None)
                else:
                    kMLStyle_ = KMLStyle.KMLStyleT.InitFromObj(KML.STYLES(i))
                    self.STYLES.append(kMLStyle_)
        if not KML.STYLE_MAPSIsNone():
            self.STYLE_MAPS = []
            for i in range(KML.STYLE_MAPSLength()):
                if KML.STYLE_MAPS(i) is None:
                    self.STYLE_MAPS.append(None)
                else:
                    kMLStyleMap_ = KMLStyleMap.KMLStyleMapT.InitFromObj(KML.STYLE_MAPS(i))
                    self.STYLE_MAPS.append(kMLStyleMap_)
        if not KML.PLACEMARKSIsNone():
            self.PLACEMARKS = []
            for i in range(KML.PLACEMARKSLength()):
                if KML.PLACEMARKS(i) is None:
                    self.PLACEMARKS.append(None)
                else:
                    kMLPlacemark_ = KMLPlacemark.KMLPlacemarkT.InitFromObj(KML.PLACEMARKS(i))
                    self.PLACEMARKS.append(kMLPlacemark_)
        if not KML.FOLDERSIsNone():
            self.FOLDERS = []
            for i in range(KML.FOLDERSLength()):
                if KML.FOLDERS(i) is None:
                    self.FOLDERS.append(None)
                else:
                    kMLFolder_ = KMLFolder.KMLFolderT.InitFromObj(KML.FOLDERS(i))
                    self.FOLDERS.append(kMLFolder_)
        if not KML.NETWORK_LINKSIsNone():
            self.NETWORK_LINKS = []
            for i in range(KML.NETWORK_LINKSLength()):
                if KML.NETWORK_LINKS(i) is None:
                    self.NETWORK_LINKS.append(None)
                else:
                    kMLNetworkLink_ = KMLNetworkLink.KMLNetworkLinkT.InitFromObj(KML.NETWORK_LINKS(i))
                    self.NETWORK_LINKS.append(kMLNetworkLink_)
        if not KML.GROUND_OVERLAYSIsNone():
            self.GROUND_OVERLAYS = []
            for i in range(KML.GROUND_OVERLAYSLength()):
                if KML.GROUND_OVERLAYS(i) is None:
                    self.GROUND_OVERLAYS.append(None)
                else:
                    kMLGroundOverlay_ = KMLGroundOverlay.KMLGroundOverlayT.InitFromObj(KML.GROUND_OVERLAYS(i))
                    self.GROUND_OVERLAYS.append(kMLGroundOverlay_)

    # KMLT
    def Pack(self, builder):
        if self.NAME is not None:
            NAME = builder.CreateString(self.NAME)
        if self.DESCRIPTION is not None:
            DESCRIPTION = builder.CreateString(self.DESCRIPTION)
        if self.STYLES is not None:
            STYLESlist = []
            for i in range(len(self.STYLES)):
                STYLESlist.append(self.STYLES[i].Pack(builder))
            KMLStartSTYLESVector(builder, len(self.STYLES))
            for i in reversed(range(len(self.STYLES))):
                builder.PrependUOffsetTRelative(STYLESlist[i])
            STYLES = builder.EndVector()
        if self.STYLE_MAPS is not None:
            STYLE_MAPSlist = []
            for i in range(len(self.STYLE_MAPS)):
                STYLE_MAPSlist.append(self.STYLE_MAPS[i].Pack(builder))
            KMLStartSTYLE_MAPSVector(builder, len(self.STYLE_MAPS))
            for i in reversed(range(len(self.STYLE_MAPS))):
                builder.PrependUOffsetTRelative(STYLE_MAPSlist[i])
            STYLE_MAPS = builder.EndVector()
        if self.PLACEMARKS is not None:
            PLACEMARKSlist = []
            for i in range(len(self.PLACEMARKS)):
                PLACEMARKSlist.append(self.PLACEMARKS[i].Pack(builder))
            KMLStartPLACEMARKSVector(builder, len(self.PLACEMARKS))
            for i in reversed(range(len(self.PLACEMARKS))):
                builder.PrependUOffsetTRelative(PLACEMARKSlist[i])
            PLACEMARKS = builder.EndVector()
        if self.FOLDERS is not None:
            FOLDERSlist = []
            for i in range(len(self.FOLDERS)):
                FOLDERSlist.append(self.FOLDERS[i].Pack(builder))
            KMLStartFOLDERSVector(builder, len(self.FOLDERS))
            for i in reversed(range(len(self.FOLDERS))):
                builder.PrependUOffsetTRelative(FOLDERSlist[i])
            FOLDERS = builder.EndVector()
        if self.NETWORK_LINKS is not None:
            NETWORK_LINKSlist = []
            for i in range(len(self.NETWORK_LINKS)):
                NETWORK_LINKSlist.append(self.NETWORK_LINKS[i].Pack(builder))
            KMLStartNETWORK_LINKSVector(builder, len(self.NETWORK_LINKS))
            for i in reversed(range(len(self.NETWORK_LINKS))):
                builder.PrependUOffsetTRelative(NETWORK_LINKSlist[i])
            NETWORK_LINKS = builder.EndVector()
        if self.GROUND_OVERLAYS is not None:
            GROUND_OVERLAYSlist = []
            for i in range(len(self.GROUND_OVERLAYS)):
                GROUND_OVERLAYSlist.append(self.GROUND_OVERLAYS[i].Pack(builder))
            KMLStartGROUND_OVERLAYSVector(builder, len(self.GROUND_OVERLAYS))
            for i in reversed(range(len(self.GROUND_OVERLAYS))):
                builder.PrependUOffsetTRelative(GROUND_OVERLAYSlist[i])
            GROUND_OVERLAYS = builder.EndVector()
        KMLStart(builder)
        if self.NAME is not None:
            KMLAddNAME(builder, NAME)
        if self.DESCRIPTION is not None:
            KMLAddDESCRIPTION(builder, DESCRIPTION)
        KMLAddVISIBILITY(builder, self.VISIBILITY)
        KMLAddOPEN(builder, self.OPEN)
        if self.STYLES is not None:
            KMLAddSTYLES(builder, STYLES)
        if self.STYLE_MAPS is not None:
            KMLAddSTYLE_MAPS(builder, STYLE_MAPS)
        if self.PLACEMARKS is not None:
            KMLAddPLACEMARKS(builder, PLACEMARKS)
        if self.FOLDERS is not None:
            KMLAddFOLDERS(builder, FOLDERS)
        if self.NETWORK_LINKS is not None:
            KMLAddNETWORK_LINKS(builder, NETWORK_LINKS)
        if self.GROUND_OVERLAYS is not None:
            KMLAddGROUND_OVERLAYS(builder, GROUND_OVERLAYS)
        KML = KMLEnd(builder)
        return KML
