# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Hypothesis Message
class HYP(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = HYP()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsHYP(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def HYPBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x48\x59\x50", size_prefixed=size_prefixed)

    # HYP
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Space Objects Involved
    # HYP
    def CAT_IDS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # HYP
    def CAT_IDSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # HYP
    def CAT_IDSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Space Objects Involved
    # HYP
    def SIT_IDS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # HYP
    def SIT_IDSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # HYP
    def SIT_IDSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Name of the hypothesis
    # HYP
    def NAME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Category of the hypothesis
    # HYP
    def CATEGORY(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Row indicators for the hypothesis matrix
    # HYP
    def ROW_INDICATORS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # HYP
    def ROW_INDICATORSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # HYP
    def ROW_INDICATORSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Column indicators for the hypothesis matrix
    # HYP
    def COL_INDICATORS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # HYP
    def COL_INDICATORSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # HYP
    def COL_INDICATORSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Matrix data as a boolean array in row major format; if overflow, adds additional rows
    # HYP
    def MATRIX(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.BoolFlags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # HYP
    def MATRIXAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.BoolFlags, o)
        return 0

    # HYP
    def MATRIXLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # HYP
    def MATRIXIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Scores for objects
    # HYP
    def SCORE(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from Score import Score
            obj = Score()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # HYP
    def SCORELength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # HYP
    def SCOREIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # Analysis methodology used to form the hypothesis
    # HYP
    def ANALYSIS_METHOD(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # HYP
    def EVENT_START_TIME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # HYP
    def EVENT_END_TIME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def HYPStart(builder): builder.StartObject(11)
def Start(builder):
    return HYPStart(builder)
def HYPAddCAT_IDS(builder, CAT_IDS): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(CAT_IDS), 0)
def AddCAT_IDS(builder, CAT_IDS):
    return HYPAddCAT_IDS(builder, CAT_IDS)
def HYPStartCAT_IDSVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartCAT_IDSVector(builder, numElems):
    return HYPStartCAT_IDSVector(builder, numElems)
def HYPAddSIT_IDS(builder, SIT_IDS): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(SIT_IDS), 0)
def AddSIT_IDS(builder, SIT_IDS):
    return HYPAddSIT_IDS(builder, SIT_IDS)
def HYPStartSIT_IDSVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartSIT_IDSVector(builder, numElems):
    return HYPStartSIT_IDSVector(builder, numElems)
def HYPAddNAME(builder, NAME): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(NAME), 0)
def AddNAME(builder, NAME):
    return HYPAddNAME(builder, NAME)
def HYPAddCATEGORY(builder, CATEGORY): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(CATEGORY), 0)
def AddCATEGORY(builder, CATEGORY):
    return HYPAddCATEGORY(builder, CATEGORY)
def HYPAddROW_INDICATORS(builder, ROW_INDICATORS): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(ROW_INDICATORS), 0)
def AddROW_INDICATORS(builder, ROW_INDICATORS):
    return HYPAddROW_INDICATORS(builder, ROW_INDICATORS)
def HYPStartROW_INDICATORSVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartROW_INDICATORSVector(builder, numElems):
    return HYPStartROW_INDICATORSVector(builder, numElems)
def HYPAddCOL_INDICATORS(builder, COL_INDICATORS): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(COL_INDICATORS), 0)
def AddCOL_INDICATORS(builder, COL_INDICATORS):
    return HYPAddCOL_INDICATORS(builder, COL_INDICATORS)
def HYPStartCOL_INDICATORSVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartCOL_INDICATORSVector(builder, numElems):
    return HYPStartCOL_INDICATORSVector(builder, numElems)
def HYPAddMATRIX(builder, MATRIX): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(MATRIX), 0)
def AddMATRIX(builder, MATRIX):
    return HYPAddMATRIX(builder, MATRIX)
def HYPStartMATRIXVector(builder, numElems): return builder.StartVector(1, numElems, 1)
def StartMATRIXVector(builder, numElems):
    return HYPStartMATRIXVector(builder, numElems)
def HYPAddSCORE(builder, SCORE): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(SCORE), 0)
def AddSCORE(builder, SCORE):
    return HYPAddSCORE(builder, SCORE)
def HYPStartSCOREVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartSCOREVector(builder, numElems):
    return HYPStartSCOREVector(builder, numElems)
def HYPAddANALYSIS_METHOD(builder, ANALYSIS_METHOD): builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(ANALYSIS_METHOD), 0)
def AddANALYSIS_METHOD(builder, ANALYSIS_METHOD):
    return HYPAddANALYSIS_METHOD(builder, ANALYSIS_METHOD)
def HYPAddEVENT_START_TIME(builder, EVENT_START_TIME): builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(EVENT_START_TIME), 0)
def AddEVENT_START_TIME(builder, EVENT_START_TIME):
    return HYPAddEVENT_START_TIME(builder, EVENT_START_TIME)
def HYPAddEVENT_END_TIME(builder, EVENT_END_TIME): builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(EVENT_END_TIME), 0)
def AddEVENT_END_TIME(builder, EVENT_END_TIME):
    return HYPAddEVENT_END_TIME(builder, EVENT_END_TIME)
def HYPEnd(builder): return builder.EndObject()
def End(builder):
    return HYPEnd(builder)
import Score
try:
    from typing import List
except:
    pass

class HYPT(object):

    # HYPT
    def __init__(self):
        self.CAT_IDS = None  # type: List[str]
        self.SIT_IDS = None  # type: List[str]
        self.NAME = None  # type: str
        self.CATEGORY = None  # type: str
        self.ROW_INDICATORS = None  # type: List[str]
        self.COL_INDICATORS = None  # type: List[str]
        self.MATRIX = None  # type: List[bool]
        self.SCORE = None  # type: List[Score.ScoreT]
        self.ANALYSIS_METHOD = None  # type: str
        self.EVENT_START_TIME = None  # type: str
        self.EVENT_END_TIME = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        HYP = HYP()
        HYP.Init(buf, pos)
        return cls.InitFromObj(HYP)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, HYP):
        x = HYPT()
        x._UnPack(HYP)
        return x

    # HYPT
    def _UnPack(self, HYP):
        if HYP is None:
            return
        if not HYP.CAT_IDSIsNone():
            self.CAT_IDS = []
            for i in range(HYP.CAT_IDSLength()):
                self.CAT_IDS.append(HYP.CAT_IDS(i))
        if not HYP.SIT_IDSIsNone():
            self.SIT_IDS = []
            for i in range(HYP.SIT_IDSLength()):
                self.SIT_IDS.append(HYP.SIT_IDS(i))
        self.NAME = HYP.NAME()
        self.CATEGORY = HYP.CATEGORY()
        if not HYP.ROW_INDICATORSIsNone():
            self.ROW_INDICATORS = []
            for i in range(HYP.ROW_INDICATORSLength()):
                self.ROW_INDICATORS.append(HYP.ROW_INDICATORS(i))
        if not HYP.COL_INDICATORSIsNone():
            self.COL_INDICATORS = []
            for i in range(HYP.COL_INDICATORSLength()):
                self.COL_INDICATORS.append(HYP.COL_INDICATORS(i))
        if not HYP.MATRIXIsNone():
            if np is None:
                self.MATRIX = []
                for i in range(HYP.MATRIXLength()):
                    self.MATRIX.append(HYP.MATRIX(i))
            else:
                self.MATRIX = HYP.MATRIXAsNumpy()
        if not HYP.SCOREIsNone():
            self.SCORE = []
            for i in range(HYP.SCORELength()):
                if HYP.SCORE(i) is None:
                    self.SCORE.append(None)
                else:
                    score_ = Score.ScoreT.InitFromObj(HYP.SCORE(i))
                    self.SCORE.append(score_)
        self.ANALYSIS_METHOD = HYP.ANALYSIS_METHOD()
        self.EVENT_START_TIME = HYP.EVENT_START_TIME()
        self.EVENT_END_TIME = HYP.EVENT_END_TIME()

    # HYPT
    def Pack(self, builder):
        if self.CAT_IDS is not None:
            CAT_IDSlist = []
            for i in range(len(self.CAT_IDS)):
                CAT_IDSlist.append(builder.CreateString(self.CAT_IDS[i]))
            HYPStartCAT_IDSVector(builder, len(self.CAT_IDS))
            for i in reversed(range(len(self.CAT_IDS))):
                builder.PrependUOffsetTRelative(CAT_IDSlist[i])
            CAT_IDS = builder.EndVector()
        if self.SIT_IDS is not None:
            SIT_IDSlist = []
            for i in range(len(self.SIT_IDS)):
                SIT_IDSlist.append(builder.CreateString(self.SIT_IDS[i]))
            HYPStartSIT_IDSVector(builder, len(self.SIT_IDS))
            for i in reversed(range(len(self.SIT_IDS))):
                builder.PrependUOffsetTRelative(SIT_IDSlist[i])
            SIT_IDS = builder.EndVector()
        if self.NAME is not None:
            NAME = builder.CreateString(self.NAME)
        if self.CATEGORY is not None:
            CATEGORY = builder.CreateString(self.CATEGORY)
        if self.ROW_INDICATORS is not None:
            ROW_INDICATORSlist = []
            for i in range(len(self.ROW_INDICATORS)):
                ROW_INDICATORSlist.append(builder.CreateString(self.ROW_INDICATORS[i]))
            HYPStartROW_INDICATORSVector(builder, len(self.ROW_INDICATORS))
            for i in reversed(range(len(self.ROW_INDICATORS))):
                builder.PrependUOffsetTRelative(ROW_INDICATORSlist[i])
            ROW_INDICATORS = builder.EndVector()
        if self.COL_INDICATORS is not None:
            COL_INDICATORSlist = []
            for i in range(len(self.COL_INDICATORS)):
                COL_INDICATORSlist.append(builder.CreateString(self.COL_INDICATORS[i]))
            HYPStartCOL_INDICATORSVector(builder, len(self.COL_INDICATORS))
            for i in reversed(range(len(self.COL_INDICATORS))):
                builder.PrependUOffsetTRelative(COL_INDICATORSlist[i])
            COL_INDICATORS = builder.EndVector()
        if self.MATRIX is not None:
            if np is not None and type(self.MATRIX) is np.ndarray:
                MATRIX = builder.CreateNumpyVector(self.MATRIX)
            else:
                HYPStartMATRIXVector(builder, len(self.MATRIX))
                for i in reversed(range(len(self.MATRIX))):
                    builder.PrependBool(self.MATRIX[i])
                MATRIX = builder.EndVector()
        if self.SCORE is not None:
            SCORElist = []
            for i in range(len(self.SCORE)):
                SCORElist.append(self.SCORE[i].Pack(builder))
            HYPStartSCOREVector(builder, len(self.SCORE))
            for i in reversed(range(len(self.SCORE))):
                builder.PrependUOffsetTRelative(SCORElist[i])
            SCORE = builder.EndVector()
        if self.ANALYSIS_METHOD is not None:
            ANALYSIS_METHOD = builder.CreateString(self.ANALYSIS_METHOD)
        if self.EVENT_START_TIME is not None:
            EVENT_START_TIME = builder.CreateString(self.EVENT_START_TIME)
        if self.EVENT_END_TIME is not None:
            EVENT_END_TIME = builder.CreateString(self.EVENT_END_TIME)
        HYPStart(builder)
        if self.CAT_IDS is not None:
            HYPAddCAT_IDS(builder, CAT_IDS)
        if self.SIT_IDS is not None:
            HYPAddSIT_IDS(builder, SIT_IDS)
        if self.NAME is not None:
            HYPAddNAME(builder, NAME)
        if self.CATEGORY is not None:
            HYPAddCATEGORY(builder, CATEGORY)
        if self.ROW_INDICATORS is not None:
            HYPAddROW_INDICATORS(builder, ROW_INDICATORS)
        if self.COL_INDICATORS is not None:
            HYPAddCOL_INDICATORS(builder, COL_INDICATORS)
        if self.MATRIX is not None:
            HYPAddMATRIX(builder, MATRIX)
        if self.SCORE is not None:
            HYPAddSCORE(builder, SCORE)
        if self.ANALYSIS_METHOD is not None:
            HYPAddANALYSIS_METHOD(builder, ANALYSIS_METHOD)
        if self.EVENT_START_TIME is not None:
            HYPAddEVENT_START_TIME(builder, EVENT_START_TIME)
        if self.EVENT_END_TIME is not None:
            HYPAddEVENT_END_TIME(builder, EVENT_END_TIME)
        HYP = HYPEnd(builder)
        return HYP
