# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Propagator configuration structure to describe propagation settings
class propagatorConfig(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = propagatorConfig()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAspropagatorConfig(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # propagatorConfig
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # propagatorConfig
    def PROPAGATOR_NAME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # propagatorConfig
    def PROPAGATOR_TYPE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # propagatorConfig
    def FORCE_MODELS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # propagatorConfig
    def FORCE_MODELSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # propagatorConfig
    def FORCE_MODELSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # propagatorConfig
    def EPOCH(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # propagatorConfig
    def TIME_STEP(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # propagatorConfig
    def ZONAL_HARMONIC_TERMS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # propagatorConfig
    def ZONAL_HARMONIC_TERMSAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int8Flags, o)
        return 0

    # propagatorConfig
    def ZONAL_HARMONIC_TERMSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # propagatorConfig
    def ZONAL_HARMONIC_TERMSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

def propagatorConfigStart(builder):
    builder.StartObject(6)

def Start(builder):
    propagatorConfigStart(builder)

def propagatorConfigAddPROPAGATOR_NAME(builder, PROPAGATOR_NAME):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(PROPAGATOR_NAME), 0)

def AddPROPAGATOR_NAME(builder, PROPAGATOR_NAME):
    propagatorConfigAddPROPAGATOR_NAME(builder, PROPAGATOR_NAME)

def propagatorConfigAddPROPAGATOR_TYPE(builder, PROPAGATOR_TYPE):
    builder.PrependInt8Slot(1, PROPAGATOR_TYPE, 0)

def AddPROPAGATOR_TYPE(builder, PROPAGATOR_TYPE):
    propagatorConfigAddPROPAGATOR_TYPE(builder, PROPAGATOR_TYPE)

def propagatorConfigAddFORCE_MODELS(builder, FORCE_MODELS):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(FORCE_MODELS), 0)

def AddFORCE_MODELS(builder, FORCE_MODELS):
    propagatorConfigAddFORCE_MODELS(builder, FORCE_MODELS)

def propagatorConfigStartFORCE_MODELSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartFORCE_MODELSVector(builder, numElems):
    return propagatorConfigStartFORCE_MODELSVector(builder, numElems)

def propagatorConfigAddEPOCH(builder, EPOCH):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(EPOCH), 0)

def AddEPOCH(builder, EPOCH):
    propagatorConfigAddEPOCH(builder, EPOCH)

def propagatorConfigAddTIME_STEP(builder, TIME_STEP):
    builder.PrependFloat64Slot(4, TIME_STEP, 0.0)

def AddTIME_STEP(builder, TIME_STEP):
    propagatorConfigAddTIME_STEP(builder, TIME_STEP)

def propagatorConfigAddZONAL_HARMONIC_TERMS(builder, ZONAL_HARMONIC_TERMS):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(ZONAL_HARMONIC_TERMS), 0)

def AddZONAL_HARMONIC_TERMS(builder, ZONAL_HARMONIC_TERMS):
    propagatorConfigAddZONAL_HARMONIC_TERMS(builder, ZONAL_HARMONIC_TERMS)

def propagatorConfigStartZONAL_HARMONIC_TERMSVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartZONAL_HARMONIC_TERMSVector(builder, numElems):
    return propagatorConfigStartZONAL_HARMONIC_TERMSVector(builder, numElems)

def propagatorConfigEnd(builder):
    return builder.EndObject()

def End(builder):
    return propagatorConfigEnd(builder)

try:
    from typing import List
except:
    pass

class propagatorConfigT(object):

    # propagatorConfigT
    def __init__(self):
        self.PROPAGATOR_NAME = None  # type: str
        self.PROPAGATOR_TYPE = 0  # type: int
        self.FORCE_MODELS = None  # type: List[str]
        self.EPOCH = None  # type: str
        self.TIME_STEP = 0.0  # type: float
        self.ZONAL_HARMONIC_TERMS = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        propagatorConfig = propagatorConfig()
        propagatorConfig.Init(buf, pos)
        return cls.InitFromObj(propagatorConfig)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, propagatorConfig):
        x = propagatorConfigT()
        x._UnPack(propagatorConfig)
        return x

    # propagatorConfigT
    def _UnPack(self, propagatorConfig):
        if propagatorConfig is None:
            return
        self.PROPAGATOR_NAME = propagatorConfig.PROPAGATOR_NAME()
        self.PROPAGATOR_TYPE = propagatorConfig.PROPAGATOR_TYPE()
        if not propagatorConfig.FORCE_MODELSIsNone():
            self.FORCE_MODELS = []
            for i in range(propagatorConfig.FORCE_MODELSLength()):
                self.FORCE_MODELS.append(propagatorConfig.FORCE_MODELS(i))
        self.EPOCH = propagatorConfig.EPOCH()
        self.TIME_STEP = propagatorConfig.TIME_STEP()
        if not propagatorConfig.ZONAL_HARMONIC_TERMSIsNone():
            if np is None:
                self.ZONAL_HARMONIC_TERMS = []
                for i in range(propagatorConfig.ZONAL_HARMONIC_TERMSLength()):
                    self.ZONAL_HARMONIC_TERMS.append(propagatorConfig.ZONAL_HARMONIC_TERMS(i))
            else:
                self.ZONAL_HARMONIC_TERMS = propagatorConfig.ZONAL_HARMONIC_TERMSAsNumpy()

    # propagatorConfigT
    def Pack(self, builder):
        if self.PROPAGATOR_NAME is not None:
            PROPAGATOR_NAME = builder.CreateString(self.PROPAGATOR_NAME)
        if self.FORCE_MODELS is not None:
            FORCE_MODELSlist = []
            for i in range(len(self.FORCE_MODELS)):
                FORCE_MODELSlist.append(builder.CreateString(self.FORCE_MODELS[i]))
            propagatorConfigStartFORCE_MODELSVector(builder, len(self.FORCE_MODELS))
            for i in reversed(range(len(self.FORCE_MODELS))):
                builder.PrependUOffsetTRelative(FORCE_MODELSlist[i])
            FORCE_MODELS = builder.EndVector()
        if self.EPOCH is not None:
            EPOCH = builder.CreateString(self.EPOCH)
        if self.ZONAL_HARMONIC_TERMS is not None:
            if np is not None and type(self.ZONAL_HARMONIC_TERMS) is np.ndarray:
                ZONAL_HARMONIC_TERMS = builder.CreateNumpyVector(self.ZONAL_HARMONIC_TERMS)
            else:
                propagatorConfigStartZONAL_HARMONIC_TERMSVector(builder, len(self.ZONAL_HARMONIC_TERMS))
                for i in reversed(range(len(self.ZONAL_HARMONIC_TERMS))):
                    builder.PrependByte(self.ZONAL_HARMONIC_TERMS[i])
                ZONAL_HARMONIC_TERMS = builder.EndVector()
        propagatorConfigStart(builder)
        if self.PROPAGATOR_NAME is not None:
            propagatorConfigAddPROPAGATOR_NAME(builder, PROPAGATOR_NAME)
        propagatorConfigAddPROPAGATOR_TYPE(builder, self.PROPAGATOR_TYPE)
        if self.FORCE_MODELS is not None:
            propagatorConfigAddFORCE_MODELS(builder, FORCE_MODELS)
        if self.EPOCH is not None:
            propagatorConfigAddEPOCH(builder, EPOCH)
        propagatorConfigAddTIME_STEP(builder, self.TIME_STEP)
        if self.ZONAL_HARMONIC_TERMS is not None:
            propagatorConfigAddZONAL_HARMONIC_TERMS(builder, ZONAL_HARMONIC_TERMS)
        propagatorConfig = propagatorConfigEnd(builder)
        return propagatorConfig
