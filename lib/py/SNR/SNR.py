# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Sensor Systems
class SNR(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SNR()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSNR(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def SNRBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x53\x4E\x52", size_prefixed=size_prefixed)

    # SNR
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SNR
    def TYPE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # SNR
    def MODE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # SNR
    def RESERVED1(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
        return 0

    # SNR
    def MAX_RANGE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def MIN_RANGE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def FOV_AZIMUTH(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def FOV_ELEVATION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def ANGULAR_RESOLUTION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def RANGE_RESOLUTION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def UPDATE_RATE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def DETECTION_THRESHOLD(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def AZIMUTH_SCAN_RATE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def ELEVATION_SCAN_RATE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def POWER(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def FREQUENCY(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # SNR
    def RESERVED(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # SNR
    def RESERVEDAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # SNR
    def RESERVEDLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SNR
    def RESERVEDIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        return o == 0

def SNRStart(builder):
    builder.StartObject(16)

def Start(builder):
    SNRStart(builder)

def SNRAddTYPE(builder, TYPE):
    builder.PrependUint8Slot(0, TYPE, 0)

def AddTYPE(builder, TYPE):
    SNRAddTYPE(builder, TYPE)

def SNRAddMODE(builder, MODE):
    builder.PrependUint8Slot(1, MODE, 0)

def AddMODE(builder, MODE):
    SNRAddMODE(builder, MODE)

def SNRAddRESERVED1(builder, RESERVED1):
    builder.PrependUint16Slot(2, RESERVED1, 0)

def AddRESERVED1(builder, RESERVED1):
    SNRAddRESERVED1(builder, RESERVED1)

def SNRAddMAX_RANGE(builder, MAX_RANGE):
    builder.PrependFloat64Slot(3, MAX_RANGE, 0.0)

def AddMAX_RANGE(builder, MAX_RANGE):
    SNRAddMAX_RANGE(builder, MAX_RANGE)

def SNRAddMIN_RANGE(builder, MIN_RANGE):
    builder.PrependFloat64Slot(4, MIN_RANGE, 0.0)

def AddMIN_RANGE(builder, MIN_RANGE):
    SNRAddMIN_RANGE(builder, MIN_RANGE)

def SNRAddFOV_AZIMUTH(builder, FOV_AZIMUTH):
    builder.PrependFloat32Slot(5, FOV_AZIMUTH, 0.0)

def AddFOV_AZIMUTH(builder, FOV_AZIMUTH):
    SNRAddFOV_AZIMUTH(builder, FOV_AZIMUTH)

def SNRAddFOV_ELEVATION(builder, FOV_ELEVATION):
    builder.PrependFloat32Slot(6, FOV_ELEVATION, 0.0)

def AddFOV_ELEVATION(builder, FOV_ELEVATION):
    SNRAddFOV_ELEVATION(builder, FOV_ELEVATION)

def SNRAddANGULAR_RESOLUTION(builder, ANGULAR_RESOLUTION):
    builder.PrependFloat32Slot(7, ANGULAR_RESOLUTION, 0.0)

def AddANGULAR_RESOLUTION(builder, ANGULAR_RESOLUTION):
    SNRAddANGULAR_RESOLUTION(builder, ANGULAR_RESOLUTION)

def SNRAddRANGE_RESOLUTION(builder, RANGE_RESOLUTION):
    builder.PrependFloat32Slot(8, RANGE_RESOLUTION, 0.0)

def AddRANGE_RESOLUTION(builder, RANGE_RESOLUTION):
    SNRAddRANGE_RESOLUTION(builder, RANGE_RESOLUTION)

def SNRAddUPDATE_RATE(builder, UPDATE_RATE):
    builder.PrependFloat32Slot(9, UPDATE_RATE, 0.0)

def AddUPDATE_RATE(builder, UPDATE_RATE):
    SNRAddUPDATE_RATE(builder, UPDATE_RATE)

def SNRAddDETECTION_THRESHOLD(builder, DETECTION_THRESHOLD):
    builder.PrependFloat32Slot(10, DETECTION_THRESHOLD, 0.0)

def AddDETECTION_THRESHOLD(builder, DETECTION_THRESHOLD):
    SNRAddDETECTION_THRESHOLD(builder, DETECTION_THRESHOLD)

def SNRAddAZIMUTH_SCAN_RATE(builder, AZIMUTH_SCAN_RATE):
    builder.PrependFloat32Slot(11, AZIMUTH_SCAN_RATE, 0.0)

def AddAZIMUTH_SCAN_RATE(builder, AZIMUTH_SCAN_RATE):
    SNRAddAZIMUTH_SCAN_RATE(builder, AZIMUTH_SCAN_RATE)

def SNRAddELEVATION_SCAN_RATE(builder, ELEVATION_SCAN_RATE):
    builder.PrependFloat32Slot(12, ELEVATION_SCAN_RATE, 0.0)

def AddELEVATION_SCAN_RATE(builder, ELEVATION_SCAN_RATE):
    SNRAddELEVATION_SCAN_RATE(builder, ELEVATION_SCAN_RATE)

def SNRAddPOWER(builder, POWER):
    builder.PrependFloat32Slot(13, POWER, 0.0)

def AddPOWER(builder, POWER):
    SNRAddPOWER(builder, POWER)

def SNRAddFREQUENCY(builder, FREQUENCY):
    builder.PrependFloat32Slot(14, FREQUENCY, 0.0)

def AddFREQUENCY(builder, FREQUENCY):
    SNRAddFREQUENCY(builder, FREQUENCY)

def SNRAddRESERVED(builder, RESERVED):
    builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(RESERVED), 0)

def AddRESERVED(builder, RESERVED):
    SNRAddRESERVED(builder, RESERVED)

def SNRStartRESERVEDVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartRESERVEDVector(builder, numElems):
    return SNRStartRESERVEDVector(builder, numElems)

def SNREnd(builder):
    return builder.EndObject()

def End(builder):
    return SNREnd(builder)

try:
    from typing import List
except:
    pass

class SNRT(object):

    # SNRT
    def __init__(self):
        self.TYPE = 0  # type: int
        self.MODE = 0  # type: int
        self.RESERVED1 = 0  # type: int
        self.MAX_RANGE = 0.0  # type: float
        self.MIN_RANGE = 0.0  # type: float
        self.FOV_AZIMUTH = 0.0  # type: float
        self.FOV_ELEVATION = 0.0  # type: float
        self.ANGULAR_RESOLUTION = 0.0  # type: float
        self.RANGE_RESOLUTION = 0.0  # type: float
        self.UPDATE_RATE = 0.0  # type: float
        self.DETECTION_THRESHOLD = 0.0  # type: float
        self.AZIMUTH_SCAN_RATE = 0.0  # type: float
        self.ELEVATION_SCAN_RATE = 0.0  # type: float
        self.POWER = 0.0  # type: float
        self.FREQUENCY = 0.0  # type: float
        self.RESERVED = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        SNR = SNR()
        SNR.Init(buf, pos)
        return cls.InitFromObj(SNR)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, SNR):
        x = SNRT()
        x._UnPack(SNR)
        return x

    # SNRT
    def _UnPack(self, SNR):
        if SNR is None:
            return
        self.TYPE = SNR.TYPE()
        self.MODE = SNR.MODE()
        self.RESERVED1 = SNR.RESERVED1()
        self.MAX_RANGE = SNR.MAX_RANGE()
        self.MIN_RANGE = SNR.MIN_RANGE()
        self.FOV_AZIMUTH = SNR.FOV_AZIMUTH()
        self.FOV_ELEVATION = SNR.FOV_ELEVATION()
        self.ANGULAR_RESOLUTION = SNR.ANGULAR_RESOLUTION()
        self.RANGE_RESOLUTION = SNR.RANGE_RESOLUTION()
        self.UPDATE_RATE = SNR.UPDATE_RATE()
        self.DETECTION_THRESHOLD = SNR.DETECTION_THRESHOLD()
        self.AZIMUTH_SCAN_RATE = SNR.AZIMUTH_SCAN_RATE()
        self.ELEVATION_SCAN_RATE = SNR.ELEVATION_SCAN_RATE()
        self.POWER = SNR.POWER()
        self.FREQUENCY = SNR.FREQUENCY()
        if not SNR.RESERVEDIsNone():
            if np is None:
                self.RESERVED = []
                for i in range(SNR.RESERVEDLength()):
                    self.RESERVED.append(SNR.RESERVED(i))
            else:
                self.RESERVED = SNR.RESERVEDAsNumpy()

    # SNRT
    def Pack(self, builder):
        if self.RESERVED is not None:
            if np is not None and type(self.RESERVED) is np.ndarray:
                RESERVED = builder.CreateNumpyVector(self.RESERVED)
            else:
                SNRStartRESERVEDVector(builder, len(self.RESERVED))
                for i in reversed(range(len(self.RESERVED))):
                    builder.PrependUint8(self.RESERVED[i])
                RESERVED = builder.EndVector()
        SNRStart(builder)
        SNRAddTYPE(builder, self.TYPE)
        SNRAddMODE(builder, self.MODE)
        SNRAddRESERVED1(builder, self.RESERVED1)
        SNRAddMAX_RANGE(builder, self.MAX_RANGE)
        SNRAddMIN_RANGE(builder, self.MIN_RANGE)
        SNRAddFOV_AZIMUTH(builder, self.FOV_AZIMUTH)
        SNRAddFOV_ELEVATION(builder, self.FOV_ELEVATION)
        SNRAddANGULAR_RESOLUTION(builder, self.ANGULAR_RESOLUTION)
        SNRAddRANGE_RESOLUTION(builder, self.RANGE_RESOLUTION)
        SNRAddUPDATE_RATE(builder, self.UPDATE_RATE)
        SNRAddDETECTION_THRESHOLD(builder, self.DETECTION_THRESHOLD)
        SNRAddAZIMUTH_SCAN_RATE(builder, self.AZIMUTH_SCAN_RATE)
        SNRAddELEVATION_SCAN_RATE(builder, self.ELEVATION_SCAN_RATE)
        SNRAddPOWER(builder, self.POWER)
        SNRAddFREQUENCY(builder, self.FREQUENCY)
        if self.RESERVED is not None:
            SNRAddRESERVED(builder, RESERVED)
        SNR = SNREnd(builder)
        return SNR
