# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Reentry Ground Impact Prediction
class reentryImpact(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = reentryImpact()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsreentryImpact(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def reentryImpactBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x52\x44\x4D", size_prefixed=size_prefixed)

    # reentryImpact
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Predicted impact epoch (ISO 8601)
    # reentryImpact
    def IMPACT_EPOCH(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Epoch uncertainty window in seconds
    # reentryImpact
    def EPOCH_UNCERTAINTY(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Impact latitude in degrees
    # reentryImpact
    def LATITUDE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Impact longitude in degrees
    # reentryImpact
    def LONGITUDE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Along-track uncertainty in km
    # reentryImpact
    def ALONG_TRACK_UNC(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cross-track uncertainty in km
    # reentryImpact
    def CROSS_TRACK_UNC(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Impact probability (0.0-1.0)
    # reentryImpact
    def IMPACT_PROBABILITY(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

def reentryImpactStart(builder):
    builder.StartObject(7)

def Start(builder):
    reentryImpactStart(builder)

def reentryImpactAddIMPACT_EPOCH(builder, IMPACT_EPOCH):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(IMPACT_EPOCH), 0)

def AddIMPACT_EPOCH(builder, IMPACT_EPOCH):
    reentryImpactAddIMPACT_EPOCH(builder, IMPACT_EPOCH)

def reentryImpactAddEPOCH_UNCERTAINTY(builder, EPOCH_UNCERTAINTY):
    builder.PrependFloat64Slot(1, EPOCH_UNCERTAINTY, 0.0)

def AddEPOCH_UNCERTAINTY(builder, EPOCH_UNCERTAINTY):
    reentryImpactAddEPOCH_UNCERTAINTY(builder, EPOCH_UNCERTAINTY)

def reentryImpactAddLATITUDE(builder, LATITUDE):
    builder.PrependFloat64Slot(2, LATITUDE, 0.0)

def AddLATITUDE(builder, LATITUDE):
    reentryImpactAddLATITUDE(builder, LATITUDE)

def reentryImpactAddLONGITUDE(builder, LONGITUDE):
    builder.PrependFloat64Slot(3, LONGITUDE, 0.0)

def AddLONGITUDE(builder, LONGITUDE):
    reentryImpactAddLONGITUDE(builder, LONGITUDE)

def reentryImpactAddALONG_TRACK_UNC(builder, ALONG_TRACK_UNC):
    builder.PrependFloat64Slot(4, ALONG_TRACK_UNC, 0.0)

def AddALONG_TRACK_UNC(builder, ALONG_TRACK_UNC):
    reentryImpactAddALONG_TRACK_UNC(builder, ALONG_TRACK_UNC)

def reentryImpactAddCROSS_TRACK_UNC(builder, CROSS_TRACK_UNC):
    builder.PrependFloat64Slot(5, CROSS_TRACK_UNC, 0.0)

def AddCROSS_TRACK_UNC(builder, CROSS_TRACK_UNC):
    reentryImpactAddCROSS_TRACK_UNC(builder, CROSS_TRACK_UNC)

def reentryImpactAddIMPACT_PROBABILITY(builder, IMPACT_PROBABILITY):
    builder.PrependFloat64Slot(6, IMPACT_PROBABILITY, 0.0)

def AddIMPACT_PROBABILITY(builder, IMPACT_PROBABILITY):
    reentryImpactAddIMPACT_PROBABILITY(builder, IMPACT_PROBABILITY)

def reentryImpactEnd(builder):
    return builder.EndObject()

def End(builder):
    return reentryImpactEnd(builder)


class reentryImpactT(object):

    # reentryImpactT
    def __init__(self):
        self.IMPACT_EPOCH = None  # type: str
        self.EPOCH_UNCERTAINTY = 0.0  # type: float
        self.LATITUDE = 0.0  # type: float
        self.LONGITUDE = 0.0  # type: float
        self.ALONG_TRACK_UNC = 0.0  # type: float
        self.CROSS_TRACK_UNC = 0.0  # type: float
        self.IMPACT_PROBABILITY = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        reentryImpact = reentryImpact()
        reentryImpact.Init(buf, pos)
        return cls.InitFromObj(reentryImpact)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, reentryImpact):
        x = reentryImpactT()
        x._UnPack(reentryImpact)
        return x

    # reentryImpactT
    def _UnPack(self, reentryImpact):
        if reentryImpact is None:
            return
        self.IMPACT_EPOCH = reentryImpact.IMPACT_EPOCH()
        self.EPOCH_UNCERTAINTY = reentryImpact.EPOCH_UNCERTAINTY()
        self.LATITUDE = reentryImpact.LATITUDE()
        self.LONGITUDE = reentryImpact.LONGITUDE()
        self.ALONG_TRACK_UNC = reentryImpact.ALONG_TRACK_UNC()
        self.CROSS_TRACK_UNC = reentryImpact.CROSS_TRACK_UNC()
        self.IMPACT_PROBABILITY = reentryImpact.IMPACT_PROBABILITY()

    # reentryImpactT
    def Pack(self, builder):
        if self.IMPACT_EPOCH is not None:
            IMPACT_EPOCH = builder.CreateString(self.IMPACT_EPOCH)
        reentryImpactStart(builder)
        if self.IMPACT_EPOCH is not None:
            reentryImpactAddIMPACT_EPOCH(builder, IMPACT_EPOCH)
        reentryImpactAddEPOCH_UNCERTAINTY(builder, self.EPOCH_UNCERTAINTY)
        reentryImpactAddLATITUDE(builder, self.LATITUDE)
        reentryImpactAddLONGITUDE(builder, self.LONGITUDE)
        reentryImpactAddALONG_TRACK_UNC(builder, self.ALONG_TRACK_UNC)
        reentryImpactAddCROSS_TRACK_UNC(builder, self.CROSS_TRACK_UNC)
        reentryImpactAddIMPACT_PROBABILITY(builder, self.IMPACT_PROBABILITY)
        reentryImpact = reentryImpactEnd(builder)
        return reentryImpact
