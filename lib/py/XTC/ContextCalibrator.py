# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Context-dependent calibrator selection
class ContextCalibrator(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ContextCalibrator()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsContextCalibrator(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ContextCalibratorBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x58\x54\x43", size_prefixed=size_prefixed)

    # ContextCalibrator
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Match criteria for selecting this calibrator
    # ContextCalibrator
    def MATCH_CRITERIA(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from MatchCriteria import MatchCriteria
            obj = MatchCriteria()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Polynomial calibrator (if used)
    # ContextCalibrator
    def POLYNOMIAL(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from PolynomialCalibrator import PolynomialCalibrator
            obj = PolynomialCalibrator()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Spline calibrator (if used)
    # ContextCalibrator
    def SPLINE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from SplineCalibrator import SplineCalibrator
            obj = SplineCalibrator()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Math operation calibrator (if used)
    # ContextCalibrator
    def MATH_OPERATION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from MathOperation import MathOperation
            obj = MathOperation()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def ContextCalibratorStart(builder):
    builder.StartObject(4)

def Start(builder):
    ContextCalibratorStart(builder)

def ContextCalibratorAddMATCH_CRITERIA(builder, MATCH_CRITERIA):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(MATCH_CRITERIA), 0)

def AddMATCH_CRITERIA(builder, MATCH_CRITERIA):
    ContextCalibratorAddMATCH_CRITERIA(builder, MATCH_CRITERIA)

def ContextCalibratorAddPOLYNOMIAL(builder, POLYNOMIAL):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(POLYNOMIAL), 0)

def AddPOLYNOMIAL(builder, POLYNOMIAL):
    ContextCalibratorAddPOLYNOMIAL(builder, POLYNOMIAL)

def ContextCalibratorAddSPLINE(builder, SPLINE):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(SPLINE), 0)

def AddSPLINE(builder, SPLINE):
    ContextCalibratorAddSPLINE(builder, SPLINE)

def ContextCalibratorAddMATH_OPERATION(builder, MATH_OPERATION):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(MATH_OPERATION), 0)

def AddMATH_OPERATION(builder, MATH_OPERATION):
    ContextCalibratorAddMATH_OPERATION(builder, MATH_OPERATION)

def ContextCalibratorEnd(builder):
    return builder.EndObject()

def End(builder):
    return ContextCalibratorEnd(builder)

import MatchCriteria
import MathOperation
import PolynomialCalibrator
import SplineCalibrator
try:
    from typing import Optional
except:
    pass

class ContextCalibratorT(object):

    # ContextCalibratorT
    def __init__(self):
        self.MATCH_CRITERIA = None  # type: Optional[MatchCriteria.MatchCriteriaT]
        self.POLYNOMIAL = None  # type: Optional[PolynomialCalibrator.PolynomialCalibratorT]
        self.SPLINE = None  # type: Optional[SplineCalibrator.SplineCalibratorT]
        self.MATH_OPERATION = None  # type: Optional[MathOperation.MathOperationT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        contextCalibrator = ContextCalibrator()
        contextCalibrator.Init(buf, pos)
        return cls.InitFromObj(contextCalibrator)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, contextCalibrator):
        x = ContextCalibratorT()
        x._UnPack(contextCalibrator)
        return x

    # ContextCalibratorT
    def _UnPack(self, contextCalibrator):
        if contextCalibrator is None:
            return
        if contextCalibrator.MATCH_CRITERIA() is not None:
            self.MATCH_CRITERIA = MatchCriteria.MatchCriteriaT.InitFromObj(contextCalibrator.MATCH_CRITERIA())
        if contextCalibrator.POLYNOMIAL() is not None:
            self.POLYNOMIAL = PolynomialCalibrator.PolynomialCalibratorT.InitFromObj(contextCalibrator.POLYNOMIAL())
        if contextCalibrator.SPLINE() is not None:
            self.SPLINE = SplineCalibrator.SplineCalibratorT.InitFromObj(contextCalibrator.SPLINE())
        if contextCalibrator.MATH_OPERATION() is not None:
            self.MATH_OPERATION = MathOperation.MathOperationT.InitFromObj(contextCalibrator.MATH_OPERATION())

    # ContextCalibratorT
    def Pack(self, builder):
        if self.MATCH_CRITERIA is not None:
            MATCH_CRITERIA = self.MATCH_CRITERIA.Pack(builder)
        if self.POLYNOMIAL is not None:
            POLYNOMIAL = self.POLYNOMIAL.Pack(builder)
        if self.SPLINE is not None:
            SPLINE = self.SPLINE.Pack(builder)
        if self.MATH_OPERATION is not None:
            MATH_OPERATION = self.MATH_OPERATION.Pack(builder)
        ContextCalibratorStart(builder)
        if self.MATCH_CRITERIA is not None:
            ContextCalibratorAddMATCH_CRITERIA(builder, MATCH_CRITERIA)
        if self.POLYNOMIAL is not None:
            ContextCalibratorAddPOLYNOMIAL(builder, POLYNOMIAL)
        if self.SPLINE is not None:
            ContextCalibratorAddSPLINE(builder, SPLINE)
        if self.MATH_OPERATION is not None:
            ContextCalibratorAddMATH_OPERATION(builder, MATH_OPERATION)
        contextCalibrator = ContextCalibratorEnd(builder)
        return contextCalibrator
