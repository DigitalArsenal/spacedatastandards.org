# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Custom algorithm definition
class CustomAlgorithm(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CustomAlgorithm()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsCustomAlgorithm(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def CustomAlgorithmBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x58\x54\x43", size_prefixed=size_prefixed)

    # CustomAlgorithm
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Algorithm name
    # CustomAlgorithm
    def NAME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Short description
    # CustomAlgorithm
    def SHORT_DESCRIPTION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Long description
    # CustomAlgorithm
    def LONG_DESCRIPTION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Programming language
    # CustomAlgorithm
    def LANGUAGE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Algorithm text/code
    # CustomAlgorithm
    def ALGORITHM_TEXT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # External algorithm reference
    # CustomAlgorithm
    def EXTERNAL_ALGORITHM_REF(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Input bindings
    # CustomAlgorithm
    def INPUTS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from AlgorithmInput import AlgorithmInput
            obj = AlgorithmInput()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # CustomAlgorithm
    def INPUTSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # CustomAlgorithm
    def INPUTSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Output bindings
    # CustomAlgorithm
    def OUTPUTS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from AlgorithmOutput import AlgorithmOutput
            obj = AlgorithmOutput()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # CustomAlgorithm
    def OUTPUTSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # CustomAlgorithm
    def OUTPUTSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # Trigger conditions
    # CustomAlgorithm
    def TRIGGERS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from AlgorithmTrigger import AlgorithmTrigger
            obj = AlgorithmTrigger()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # CustomAlgorithm
    def TRIGGERSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # CustomAlgorithm
    def TRIGGERSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

def CustomAlgorithmStart(builder):
    builder.StartObject(9)

def Start(builder):
    CustomAlgorithmStart(builder)

def CustomAlgorithmAddNAME(builder, NAME):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(NAME), 0)

def AddNAME(builder, NAME):
    CustomAlgorithmAddNAME(builder, NAME)

def CustomAlgorithmAddSHORT_DESCRIPTION(builder, SHORT_DESCRIPTION):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(SHORT_DESCRIPTION), 0)

def AddSHORT_DESCRIPTION(builder, SHORT_DESCRIPTION):
    CustomAlgorithmAddSHORT_DESCRIPTION(builder, SHORT_DESCRIPTION)

def CustomAlgorithmAddLONG_DESCRIPTION(builder, LONG_DESCRIPTION):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(LONG_DESCRIPTION), 0)

def AddLONG_DESCRIPTION(builder, LONG_DESCRIPTION):
    CustomAlgorithmAddLONG_DESCRIPTION(builder, LONG_DESCRIPTION)

def CustomAlgorithmAddLANGUAGE(builder, LANGUAGE):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(LANGUAGE), 0)

def AddLANGUAGE(builder, LANGUAGE):
    CustomAlgorithmAddLANGUAGE(builder, LANGUAGE)

def CustomAlgorithmAddALGORITHM_TEXT(builder, ALGORITHM_TEXT):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(ALGORITHM_TEXT), 0)

def AddALGORITHM_TEXT(builder, ALGORITHM_TEXT):
    CustomAlgorithmAddALGORITHM_TEXT(builder, ALGORITHM_TEXT)

def CustomAlgorithmAddEXTERNAL_ALGORITHM_REF(builder, EXTERNAL_ALGORITHM_REF):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(EXTERNAL_ALGORITHM_REF), 0)

def AddEXTERNAL_ALGORITHM_REF(builder, EXTERNAL_ALGORITHM_REF):
    CustomAlgorithmAddEXTERNAL_ALGORITHM_REF(builder, EXTERNAL_ALGORITHM_REF)

def CustomAlgorithmAddINPUTS(builder, INPUTS):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(INPUTS), 0)

def AddINPUTS(builder, INPUTS):
    CustomAlgorithmAddINPUTS(builder, INPUTS)

def CustomAlgorithmStartINPUTSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartINPUTSVector(builder, numElems):
    return CustomAlgorithmStartINPUTSVector(builder, numElems)

def CustomAlgorithmAddOUTPUTS(builder, OUTPUTS):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(OUTPUTS), 0)

def AddOUTPUTS(builder, OUTPUTS):
    CustomAlgorithmAddOUTPUTS(builder, OUTPUTS)

def CustomAlgorithmStartOUTPUTSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartOUTPUTSVector(builder, numElems):
    return CustomAlgorithmStartOUTPUTSVector(builder, numElems)

def CustomAlgorithmAddTRIGGERS(builder, TRIGGERS):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(TRIGGERS), 0)

def AddTRIGGERS(builder, TRIGGERS):
    CustomAlgorithmAddTRIGGERS(builder, TRIGGERS)

def CustomAlgorithmStartTRIGGERSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartTRIGGERSVector(builder, numElems):
    return CustomAlgorithmStartTRIGGERSVector(builder, numElems)

def CustomAlgorithmEnd(builder):
    return builder.EndObject()

def End(builder):
    return CustomAlgorithmEnd(builder)

import AlgorithmInput
import AlgorithmOutput
import AlgorithmTrigger
try:
    from typing import List
except:
    pass

class CustomAlgorithmT(object):

    # CustomAlgorithmT
    def __init__(self):
        self.NAME = None  # type: str
        self.SHORT_DESCRIPTION = None  # type: str
        self.LONG_DESCRIPTION = None  # type: str
        self.LANGUAGE = None  # type: str
        self.ALGORITHM_TEXT = None  # type: str
        self.EXTERNAL_ALGORITHM_REF = None  # type: str
        self.INPUTS = None  # type: List[AlgorithmInput.AlgorithmInputT]
        self.OUTPUTS = None  # type: List[AlgorithmOutput.AlgorithmOutputT]
        self.TRIGGERS = None  # type: List[AlgorithmTrigger.AlgorithmTriggerT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        customAlgorithm = CustomAlgorithm()
        customAlgorithm.Init(buf, pos)
        return cls.InitFromObj(customAlgorithm)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, customAlgorithm):
        x = CustomAlgorithmT()
        x._UnPack(customAlgorithm)
        return x

    # CustomAlgorithmT
    def _UnPack(self, customAlgorithm):
        if customAlgorithm is None:
            return
        self.NAME = customAlgorithm.NAME()
        self.SHORT_DESCRIPTION = customAlgorithm.SHORT_DESCRIPTION()
        self.LONG_DESCRIPTION = customAlgorithm.LONG_DESCRIPTION()
        self.LANGUAGE = customAlgorithm.LANGUAGE()
        self.ALGORITHM_TEXT = customAlgorithm.ALGORITHM_TEXT()
        self.EXTERNAL_ALGORITHM_REF = customAlgorithm.EXTERNAL_ALGORITHM_REF()
        if not customAlgorithm.INPUTSIsNone():
            self.INPUTS = []
            for i in range(customAlgorithm.INPUTSLength()):
                if customAlgorithm.INPUTS(i) is None:
                    self.INPUTS.append(None)
                else:
                    algorithmInput_ = AlgorithmInput.AlgorithmInputT.InitFromObj(customAlgorithm.INPUTS(i))
                    self.INPUTS.append(algorithmInput_)
        if not customAlgorithm.OUTPUTSIsNone():
            self.OUTPUTS = []
            for i in range(customAlgorithm.OUTPUTSLength()):
                if customAlgorithm.OUTPUTS(i) is None:
                    self.OUTPUTS.append(None)
                else:
                    algorithmOutput_ = AlgorithmOutput.AlgorithmOutputT.InitFromObj(customAlgorithm.OUTPUTS(i))
                    self.OUTPUTS.append(algorithmOutput_)
        if not customAlgorithm.TRIGGERSIsNone():
            self.TRIGGERS = []
            for i in range(customAlgorithm.TRIGGERSLength()):
                if customAlgorithm.TRIGGERS(i) is None:
                    self.TRIGGERS.append(None)
                else:
                    algorithmTrigger_ = AlgorithmTrigger.AlgorithmTriggerT.InitFromObj(customAlgorithm.TRIGGERS(i))
                    self.TRIGGERS.append(algorithmTrigger_)

    # CustomAlgorithmT
    def Pack(self, builder):
        if self.NAME is not None:
            NAME = builder.CreateString(self.NAME)
        if self.SHORT_DESCRIPTION is not None:
            SHORT_DESCRIPTION = builder.CreateString(self.SHORT_DESCRIPTION)
        if self.LONG_DESCRIPTION is not None:
            LONG_DESCRIPTION = builder.CreateString(self.LONG_DESCRIPTION)
        if self.LANGUAGE is not None:
            LANGUAGE = builder.CreateString(self.LANGUAGE)
        if self.ALGORITHM_TEXT is not None:
            ALGORITHM_TEXT = builder.CreateString(self.ALGORITHM_TEXT)
        if self.EXTERNAL_ALGORITHM_REF is not None:
            EXTERNAL_ALGORITHM_REF = builder.CreateString(self.EXTERNAL_ALGORITHM_REF)
        if self.INPUTS is not None:
            INPUTSlist = []
            for i in range(len(self.INPUTS)):
                INPUTSlist.append(self.INPUTS[i].Pack(builder))
            CustomAlgorithmStartINPUTSVector(builder, len(self.INPUTS))
            for i in reversed(range(len(self.INPUTS))):
                builder.PrependUOffsetTRelative(INPUTSlist[i])
            INPUTS = builder.EndVector()
        if self.OUTPUTS is not None:
            OUTPUTSlist = []
            for i in range(len(self.OUTPUTS)):
                OUTPUTSlist.append(self.OUTPUTS[i].Pack(builder))
            CustomAlgorithmStartOUTPUTSVector(builder, len(self.OUTPUTS))
            for i in reversed(range(len(self.OUTPUTS))):
                builder.PrependUOffsetTRelative(OUTPUTSlist[i])
            OUTPUTS = builder.EndVector()
        if self.TRIGGERS is not None:
            TRIGGERSlist = []
            for i in range(len(self.TRIGGERS)):
                TRIGGERSlist.append(self.TRIGGERS[i].Pack(builder))
            CustomAlgorithmStartTRIGGERSVector(builder, len(self.TRIGGERS))
            for i in reversed(range(len(self.TRIGGERS))):
                builder.PrependUOffsetTRelative(TRIGGERSlist[i])
            TRIGGERS = builder.EndVector()
        CustomAlgorithmStart(builder)
        if self.NAME is not None:
            CustomAlgorithmAddNAME(builder, NAME)
        if self.SHORT_DESCRIPTION is not None:
            CustomAlgorithmAddSHORT_DESCRIPTION(builder, SHORT_DESCRIPTION)
        if self.LONG_DESCRIPTION is not None:
            CustomAlgorithmAddLONG_DESCRIPTION(builder, LONG_DESCRIPTION)
        if self.LANGUAGE is not None:
            CustomAlgorithmAddLANGUAGE(builder, LANGUAGE)
        if self.ALGORITHM_TEXT is not None:
            CustomAlgorithmAddALGORITHM_TEXT(builder, ALGORITHM_TEXT)
        if self.EXTERNAL_ALGORITHM_REF is not None:
            CustomAlgorithmAddEXTERNAL_ALGORITHM_REF(builder, EXTERNAL_ALGORITHM_REF)
        if self.INPUTS is not None:
            CustomAlgorithmAddINPUTS(builder, INPUTS)
        if self.OUTPUTS is not None:
            CustomAlgorithmAddOUTPUTS(builder, OUTPUTS)
        if self.TRIGGERS is not None:
            CustomAlgorithmAddTRIGGERS(builder, TRIGGERS)
        customAlgorithm = CustomAlgorithmEnd(builder)
        return customAlgorithm
