# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Numeric alarm range
class AlarmRange(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AlarmRange()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAlarmRange(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def AlarmRangeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x58\x54\x43", size_prefixed=size_prefixed)

    # AlarmRange
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Minimum value (inclusive)
    # AlarmRange
    def MIN_INCLUSIVE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Maximum value (inclusive)
    # AlarmRange
    def MAX_INCLUSIVE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Minimum value (exclusive)
    # AlarmRange
    def MIN_EXCLUSIVE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Maximum value (exclusive)
    # AlarmRange
    def MAX_EXCLUSIVE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

def AlarmRangeStart(builder):
    builder.StartObject(4)

def Start(builder):
    AlarmRangeStart(builder)

def AlarmRangeAddMIN_INCLUSIVE(builder, MIN_INCLUSIVE):
    builder.PrependFloat64Slot(0, MIN_INCLUSIVE, 0.0)

def AddMIN_INCLUSIVE(builder, MIN_INCLUSIVE):
    AlarmRangeAddMIN_INCLUSIVE(builder, MIN_INCLUSIVE)

def AlarmRangeAddMAX_INCLUSIVE(builder, MAX_INCLUSIVE):
    builder.PrependFloat64Slot(1, MAX_INCLUSIVE, 0.0)

def AddMAX_INCLUSIVE(builder, MAX_INCLUSIVE):
    AlarmRangeAddMAX_INCLUSIVE(builder, MAX_INCLUSIVE)

def AlarmRangeAddMIN_EXCLUSIVE(builder, MIN_EXCLUSIVE):
    builder.PrependFloat64Slot(2, MIN_EXCLUSIVE, 0.0)

def AddMIN_EXCLUSIVE(builder, MIN_EXCLUSIVE):
    AlarmRangeAddMIN_EXCLUSIVE(builder, MIN_EXCLUSIVE)

def AlarmRangeAddMAX_EXCLUSIVE(builder, MAX_EXCLUSIVE):
    builder.PrependFloat64Slot(3, MAX_EXCLUSIVE, 0.0)

def AddMAX_EXCLUSIVE(builder, MAX_EXCLUSIVE):
    AlarmRangeAddMAX_EXCLUSIVE(builder, MAX_EXCLUSIVE)

def AlarmRangeEnd(builder):
    return builder.EndObject()

def End(builder):
    return AlarmRangeEnd(builder)


class AlarmRangeT(object):

    # AlarmRangeT
    def __init__(self):
        self.MIN_INCLUSIVE = 0.0  # type: float
        self.MAX_INCLUSIVE = 0.0  # type: float
        self.MIN_EXCLUSIVE = 0.0  # type: float
        self.MAX_EXCLUSIVE = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        alarmRange = AlarmRange()
        alarmRange.Init(buf, pos)
        return cls.InitFromObj(alarmRange)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, alarmRange):
        x = AlarmRangeT()
        x._UnPack(alarmRange)
        return x

    # AlarmRangeT
    def _UnPack(self, alarmRange):
        if alarmRange is None:
            return
        self.MIN_INCLUSIVE = alarmRange.MIN_INCLUSIVE()
        self.MAX_INCLUSIVE = alarmRange.MAX_INCLUSIVE()
        self.MIN_EXCLUSIVE = alarmRange.MIN_EXCLUSIVE()
        self.MAX_EXCLUSIVE = alarmRange.MAX_EXCLUSIVE()

    # AlarmRangeT
    def Pack(self, builder):
        AlarmRangeStart(builder)
        AlarmRangeAddMIN_INCLUSIVE(builder, self.MIN_INCLUSIVE)
        AlarmRangeAddMAX_INCLUSIVE(builder, self.MAX_INCLUSIVE)
        AlarmRangeAddMIN_EXCLUSIVE(builder, self.MIN_EXCLUSIVE)
        AlarmRangeAddMAX_EXCLUSIVE(builder, self.MAX_EXCLUSIVE)
        alarmRange = AlarmRangeEnd(builder)
        return alarmRange
