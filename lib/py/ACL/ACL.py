# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Access Control Grant - Permission to access purchased data
class ACL(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ACL()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsACL(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ACLBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x41\x43\x4C", size_prefixed=size_prefixed)

    # ACL
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Unique identifier for this grant
    # ACL
    def GRANT_ID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # ID of the listing this grant applies to
    # ACL
    def LISTING_ID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Peer ID of the buyer/grantee
    # ACL
    def BUYER_PEER_ID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Buyer's encryption public key for encrypted delivery
    # ACL
    def BUYER_ENCRYPTION_PUBKEY(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # ACL
    def BUYER_ENCRYPTION_PUBKEYAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # ACL
    def BUYER_ENCRYPTION_PUBKEYLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ACL
    def BUYER_ENCRYPTION_PUBKEYIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Type of access granted
    # ACL
    def ACCESS_TYPE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Name of the pricing tier purchased
    # ACL
    def TIER_NAME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Unix timestamp when access was granted
    # ACL
    def GRANTED_AT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # Unix timestamp when access expires (0 = never expires)
    # ACL
    def EXPIRES_AT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # Transaction hash or reference proving payment
    # ACL
    def PAYMENT_TX_HASH(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Payment method used
    # ACL
    def PAYMENT_METHOD(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Ed25519 signature from provider
    # ACL
    def PROVIDER_SIGNATURE(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # ACL
    def PROVIDER_SIGNATUREAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # ACL
    def PROVIDER_SIGNATURELength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ACL
    def PROVIDER_SIGNATUREIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return o == 0

def ACLStart(builder):
    builder.StartObject(11)

def Start(builder):
    ACLStart(builder)

def ACLAddGRANT_ID(builder, GRANT_ID):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(GRANT_ID), 0)

def AddGRANT_ID(builder, GRANT_ID):
    ACLAddGRANT_ID(builder, GRANT_ID)

def ACLAddLISTING_ID(builder, LISTING_ID):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(LISTING_ID), 0)

def AddLISTING_ID(builder, LISTING_ID):
    ACLAddLISTING_ID(builder, LISTING_ID)

def ACLAddBUYER_PEER_ID(builder, BUYER_PEER_ID):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(BUYER_PEER_ID), 0)

def AddBUYER_PEER_ID(builder, BUYER_PEER_ID):
    ACLAddBUYER_PEER_ID(builder, BUYER_PEER_ID)

def ACLAddBUYER_ENCRYPTION_PUBKEY(builder, BUYER_ENCRYPTION_PUBKEY):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(BUYER_ENCRYPTION_PUBKEY), 0)

def AddBUYER_ENCRYPTION_PUBKEY(builder, BUYER_ENCRYPTION_PUBKEY):
    ACLAddBUYER_ENCRYPTION_PUBKEY(builder, BUYER_ENCRYPTION_PUBKEY)

def ACLStartBUYER_ENCRYPTION_PUBKEYVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartBUYER_ENCRYPTION_PUBKEYVector(builder, numElems):
    return ACLStartBUYER_ENCRYPTION_PUBKEYVector(builder, numElems)

def ACLAddACCESS_TYPE(builder, ACCESS_TYPE):
    builder.PrependInt8Slot(4, ACCESS_TYPE, 0)

def AddACCESS_TYPE(builder, ACCESS_TYPE):
    ACLAddACCESS_TYPE(builder, ACCESS_TYPE)

def ACLAddTIER_NAME(builder, TIER_NAME):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(TIER_NAME), 0)

def AddTIER_NAME(builder, TIER_NAME):
    ACLAddTIER_NAME(builder, TIER_NAME)

def ACLAddGRANTED_AT(builder, GRANTED_AT):
    builder.PrependUint64Slot(6, GRANTED_AT, 0)

def AddGRANTED_AT(builder, GRANTED_AT):
    ACLAddGRANTED_AT(builder, GRANTED_AT)

def ACLAddEXPIRES_AT(builder, EXPIRES_AT):
    builder.PrependUint64Slot(7, EXPIRES_AT, 0)

def AddEXPIRES_AT(builder, EXPIRES_AT):
    ACLAddEXPIRES_AT(builder, EXPIRES_AT)

def ACLAddPAYMENT_TX_HASH(builder, PAYMENT_TX_HASH):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(PAYMENT_TX_HASH), 0)

def AddPAYMENT_TX_HASH(builder, PAYMENT_TX_HASH):
    ACLAddPAYMENT_TX_HASH(builder, PAYMENT_TX_HASH)

def ACLAddPAYMENT_METHOD(builder, PAYMENT_METHOD):
    builder.PrependInt8Slot(9, PAYMENT_METHOD, 0)

def AddPAYMENT_METHOD(builder, PAYMENT_METHOD):
    ACLAddPAYMENT_METHOD(builder, PAYMENT_METHOD)

def ACLAddPROVIDER_SIGNATURE(builder, PROVIDER_SIGNATURE):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(PROVIDER_SIGNATURE), 0)

def AddPROVIDER_SIGNATURE(builder, PROVIDER_SIGNATURE):
    ACLAddPROVIDER_SIGNATURE(builder, PROVIDER_SIGNATURE)

def ACLStartPROVIDER_SIGNATUREVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartPROVIDER_SIGNATUREVector(builder, numElems):
    return ACLStartPROVIDER_SIGNATUREVector(builder, numElems)

def ACLEnd(builder):
    return builder.EndObject()

def End(builder):
    return ACLEnd(builder)

try:
    from typing import List
except:
    pass

class ACLT(object):

    # ACLT
    def __init__(self):
        self.GRANT_ID = None  # type: str
        self.LISTING_ID = None  # type: str
        self.BUYER_PEER_ID = None  # type: str
        self.BUYER_ENCRYPTION_PUBKEY = None  # type: List[int]
        self.ACCESS_TYPE = 0  # type: int
        self.TIER_NAME = None  # type: str
        self.GRANTED_AT = 0  # type: int
        self.EXPIRES_AT = 0  # type: int
        self.PAYMENT_TX_HASH = None  # type: str
        self.PAYMENT_METHOD = 0  # type: int
        self.PROVIDER_SIGNATURE = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        ACL = ACL()
        ACL.Init(buf, pos)
        return cls.InitFromObj(ACL)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, ACL):
        x = ACLT()
        x._UnPack(ACL)
        return x

    # ACLT
    def _UnPack(self, ACL):
        if ACL is None:
            return
        self.GRANT_ID = ACL.GRANT_ID()
        self.LISTING_ID = ACL.LISTING_ID()
        self.BUYER_PEER_ID = ACL.BUYER_PEER_ID()
        if not ACL.BUYER_ENCRYPTION_PUBKEYIsNone():
            if np is None:
                self.BUYER_ENCRYPTION_PUBKEY = []
                for i in range(ACL.BUYER_ENCRYPTION_PUBKEYLength()):
                    self.BUYER_ENCRYPTION_PUBKEY.append(ACL.BUYER_ENCRYPTION_PUBKEY(i))
            else:
                self.BUYER_ENCRYPTION_PUBKEY = ACL.BUYER_ENCRYPTION_PUBKEYAsNumpy()
        self.ACCESS_TYPE = ACL.ACCESS_TYPE()
        self.TIER_NAME = ACL.TIER_NAME()
        self.GRANTED_AT = ACL.GRANTED_AT()
        self.EXPIRES_AT = ACL.EXPIRES_AT()
        self.PAYMENT_TX_HASH = ACL.PAYMENT_TX_HASH()
        self.PAYMENT_METHOD = ACL.PAYMENT_METHOD()
        if not ACL.PROVIDER_SIGNATUREIsNone():
            if np is None:
                self.PROVIDER_SIGNATURE = []
                for i in range(ACL.PROVIDER_SIGNATURELength()):
                    self.PROVIDER_SIGNATURE.append(ACL.PROVIDER_SIGNATURE(i))
            else:
                self.PROVIDER_SIGNATURE = ACL.PROVIDER_SIGNATUREAsNumpy()

    # ACLT
    def Pack(self, builder):
        if self.GRANT_ID is not None:
            GRANT_ID = builder.CreateString(self.GRANT_ID)
        if self.LISTING_ID is not None:
            LISTING_ID = builder.CreateString(self.LISTING_ID)
        if self.BUYER_PEER_ID is not None:
            BUYER_PEER_ID = builder.CreateString(self.BUYER_PEER_ID)
        if self.BUYER_ENCRYPTION_PUBKEY is not None:
            if np is not None and type(self.BUYER_ENCRYPTION_PUBKEY) is np.ndarray:
                BUYER_ENCRYPTION_PUBKEY = builder.CreateNumpyVector(self.BUYER_ENCRYPTION_PUBKEY)
            else:
                ACLStartBUYER_ENCRYPTION_PUBKEYVector(builder, len(self.BUYER_ENCRYPTION_PUBKEY))
                for i in reversed(range(len(self.BUYER_ENCRYPTION_PUBKEY))):
                    builder.PrependUint8(self.BUYER_ENCRYPTION_PUBKEY[i])
                BUYER_ENCRYPTION_PUBKEY = builder.EndVector()
        if self.TIER_NAME is not None:
            TIER_NAME = builder.CreateString(self.TIER_NAME)
        if self.PAYMENT_TX_HASH is not None:
            PAYMENT_TX_HASH = builder.CreateString(self.PAYMENT_TX_HASH)
        if self.PROVIDER_SIGNATURE is not None:
            if np is not None and type(self.PROVIDER_SIGNATURE) is np.ndarray:
                PROVIDER_SIGNATURE = builder.CreateNumpyVector(self.PROVIDER_SIGNATURE)
            else:
                ACLStartPROVIDER_SIGNATUREVector(builder, len(self.PROVIDER_SIGNATURE))
                for i in reversed(range(len(self.PROVIDER_SIGNATURE))):
                    builder.PrependUint8(self.PROVIDER_SIGNATURE[i])
                PROVIDER_SIGNATURE = builder.EndVector()
        ACLStart(builder)
        if self.GRANT_ID is not None:
            ACLAddGRANT_ID(builder, GRANT_ID)
        if self.LISTING_ID is not None:
            ACLAddLISTING_ID(builder, LISTING_ID)
        if self.BUYER_PEER_ID is not None:
            ACLAddBUYER_PEER_ID(builder, BUYER_PEER_ID)
        if self.BUYER_ENCRYPTION_PUBKEY is not None:
            ACLAddBUYER_ENCRYPTION_PUBKEY(builder, BUYER_ENCRYPTION_PUBKEY)
        ACLAddACCESS_TYPE(builder, self.ACCESS_TYPE)
        if self.TIER_NAME is not None:
            ACLAddTIER_NAME(builder, TIER_NAME)
        ACLAddGRANTED_AT(builder, self.GRANTED_AT)
        ACLAddEXPIRES_AT(builder, self.EXPIRES_AT)
        if self.PAYMENT_TX_HASH is not None:
            ACLAddPAYMENT_TX_HASH(builder, PAYMENT_TX_HASH)
        ACLAddPAYMENT_METHOD(builder, self.PAYMENT_METHOD)
        if self.PROVIDER_SIGNATURE is not None:
            ACLAddPROVIDER_SIGNATURE(builder, PROVIDER_SIGNATURE)
        ACL = ACLEnd(builder)
        return ACL
