# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# A single time-dynamic property (non-static value)
class CZMDynamicProperty(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CZMDynamicProperty()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsCZMDynamicProperty(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def CZMDynamicPropertyBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x43\x5A\x4D", size_prefixed=size_prefixed)

    # CZMDynamicProperty
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Dotted path name, e.g. "billboard.scale", "point.color"
    # CZMDynamicProperty
    def NAME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Sampled data (when property uses epoch + data array)
    # CZMDynamicProperty
    def SAMPLED(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from CZMDynSampled import CZMDynSampled
            obj = CZMDynSampled()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Interval-based values
    # CZMDynamicProperty
    def INTERVALS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from CZMDynInterval import CZMDynInterval
            obj = CZMDynInterval()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # CZMDynamicProperty
    def INTERVALSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # CZMDynamicProperty
    def INTERVALSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Reference to another entity's property
    # CZMDynamicProperty
    def REFERENCE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def CZMDynamicPropertyStart(builder):
    builder.StartObject(4)

def Start(builder):
    CZMDynamicPropertyStart(builder)

def CZMDynamicPropertyAddNAME(builder, NAME):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(NAME), 0)

def AddNAME(builder, NAME):
    CZMDynamicPropertyAddNAME(builder, NAME)

def CZMDynamicPropertyAddSAMPLED(builder, SAMPLED):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(SAMPLED), 0)

def AddSAMPLED(builder, SAMPLED):
    CZMDynamicPropertyAddSAMPLED(builder, SAMPLED)

def CZMDynamicPropertyAddINTERVALS(builder, INTERVALS):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(INTERVALS), 0)

def AddINTERVALS(builder, INTERVALS):
    CZMDynamicPropertyAddINTERVALS(builder, INTERVALS)

def CZMDynamicPropertyStartINTERVALSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartINTERVALSVector(builder, numElems):
    return CZMDynamicPropertyStartINTERVALSVector(builder, numElems)

def CZMDynamicPropertyAddREFERENCE(builder, REFERENCE):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(REFERENCE), 0)

def AddREFERENCE(builder, REFERENCE):
    CZMDynamicPropertyAddREFERENCE(builder, REFERENCE)

def CZMDynamicPropertyEnd(builder):
    return builder.EndObject()

def End(builder):
    return CZMDynamicPropertyEnd(builder)

import CZMDynInterval
import CZMDynSampled
try:
    from typing import List, Optional
except:
    pass

class CZMDynamicPropertyT(object):

    # CZMDynamicPropertyT
    def __init__(self):
        self.NAME = None  # type: str
        self.SAMPLED = None  # type: Optional[CZMDynSampled.CZMDynSampledT]
        self.INTERVALS = None  # type: List[CZMDynInterval.CZMDynIntervalT]
        self.REFERENCE = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        czmdynamicProperty = CZMDynamicProperty()
        czmdynamicProperty.Init(buf, pos)
        return cls.InitFromObj(czmdynamicProperty)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, czmdynamicProperty):
        x = CZMDynamicPropertyT()
        x._UnPack(czmdynamicProperty)
        return x

    # CZMDynamicPropertyT
    def _UnPack(self, czmdynamicProperty):
        if czmdynamicProperty is None:
            return
        self.NAME = czmdynamicProperty.NAME()
        if czmdynamicProperty.SAMPLED() is not None:
            self.SAMPLED = CZMDynSampled.CZMDynSampledT.InitFromObj(czmdynamicProperty.SAMPLED())
        if not czmdynamicProperty.INTERVALSIsNone():
            self.INTERVALS = []
            for i in range(czmdynamicProperty.INTERVALSLength()):
                if czmdynamicProperty.INTERVALS(i) is None:
                    self.INTERVALS.append(None)
                else:
                    cZMDynInterval_ = CZMDynInterval.CZMDynIntervalT.InitFromObj(czmdynamicProperty.INTERVALS(i))
                    self.INTERVALS.append(cZMDynInterval_)
        self.REFERENCE = czmdynamicProperty.REFERENCE()

    # CZMDynamicPropertyT
    def Pack(self, builder):
        if self.NAME is not None:
            NAME = builder.CreateString(self.NAME)
        if self.SAMPLED is not None:
            SAMPLED = self.SAMPLED.Pack(builder)
        if self.INTERVALS is not None:
            INTERVALSlist = []
            for i in range(len(self.INTERVALS)):
                INTERVALSlist.append(self.INTERVALS[i].Pack(builder))
            CZMDynamicPropertyStartINTERVALSVector(builder, len(self.INTERVALS))
            for i in reversed(range(len(self.INTERVALS))):
                builder.PrependUOffsetTRelative(INTERVALSlist[i])
            INTERVALS = builder.EndVector()
        if self.REFERENCE is not None:
            REFERENCE = builder.CreateString(self.REFERENCE)
        CZMDynamicPropertyStart(builder)
        if self.NAME is not None:
            CZMDynamicPropertyAddNAME(builder, NAME)
        if self.SAMPLED is not None:
            CZMDynamicPropertyAddSAMPLED(builder, SAMPLED)
        if self.INTERVALS is not None:
            CZMDynamicPropertyAddINTERVALS(builder, INTERVALS)
        if self.REFERENCE is not None:
            CZMDynamicPropertyAddREFERENCE(builder, REFERENCE)
        czmdynamicProperty = CZMDynamicPropertyEnd(builder)
        return czmdynamicProperty
