# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Publish Notification Message
class PNM(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = PNM()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsPNM(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def PNMBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x50\x4E\x4D", size_prefixed=size_prefixed)

    # PNM
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # IPFS Content Identifier (CID)
    # The hash of a file stored on the InterPlanetary File System (IPFS).
    # Refer to the section on IPFS integration for details.
    # PNM
    def IPFS_CID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Ethereum Digital Signature
    # Digital signature of the IPFS CID using Ethereum's signing mechanism.
    # Refer to the Ethereum Blockchain integration section for details.
    # PNM
    def ETH_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Bitcoin Digital Signature
    # Digital signature of the IPFS CID using Bitcoin's signing mechanism.
    # Refer to the Bitcoin Blockchain integration section for details.
    # PNM
    def BTC_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Litecoin Digital Signature
    # Digital signature of the IPFS CID using Litecoin's signing mechanism.
    # Refer to the Litecoin Blockchain integration section for details.
    # PNM
    def LTC_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Ripple Digital Signature
    # Digital signature of the IPFS CID using Ripple's signing mechanism.
    # Refer to the Ripple Blockchain integration section for details.
    # PNM
    def XRP_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Cardano Digital Signature
    # Digital signature of the IPFS CID using Cardano's signing mechanism.
    # Refer to the Cardano Blockchain integration section for details.
    # PNM
    def ADA_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Stellar Digital Signature
    # Digital signature of the IPFS CID using Stellar's signing mechanism.
    # Refer to the Stellar Blockchain integration section for details.
    # PNM
    def XLM_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Dogecoin Digital Signature
    # Digital signature of the IPFS CID using Dogecoin's signing mechanism.
    # Refer to the Dogecoin Blockchain integration section for details.
    # PNM
    def DOGE_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Monero Digital Signature
    # Digital signature of the IPFS CID using Monero's signing mechanism.
    # Refer to the Monero Blockchain integration section for details.
    # PNM
    def XMR_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Polkadot Digital Signature
    # Digital signature of the IPFS CID using Polkadot's signing mechanism.
    # Refer to the Polkadot Blockchain integration section for details.
    # PNM
    def DOT_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Filecoin Digital Signature
    # Digital signature of the IPFS CID using Filecoin's signing mechanism.
    # Refer to the Filecoin Blockchain integration section for details.
    # PNM
    def FIL_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Tezos Digital Signature
    # Digital signature of the IPFS CID using Tezos's signing mechanism.
    # Refer to the Tezos Blockchain integration section for details.
    # PNM
    def XTZ_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Cosmos Digital Signature
    # Digital signature of the IPFS CID using Cosmos's signing mechanism.
    # Refer to the Cosmos Blockchain integration section for details.
    # PNM
    def ATOM_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Tron Digital Signature
    # Digital signature of the IPFS CID using Tron's signing mechanism.
    # Refer to the Tron Blockchain integration section for details.
    # PNM
    def TRX_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Binance Coin Digital Signature
    # Digital signature of the IPFS CID using Binance Coin's signing mechanism.
    # Refer to the Binance Coin Blockchain integration section for details.
    # PNM
    def BNB_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Avalanche Digital Signature
    # Digital signature of the IPFS CID using Avalanche's signing mechanism.
    # Refer to the Avalanche Blockchain integration section for details.
    # PNM
    def AVAX_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Solana Digital Signature
    # Digital signature of the IPFS CID using Solana's signing mechanism.
    # Refer to the Solana Blockchain integration section for details.
    # PNM
    def SOL_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def PNMStart(builder): builder.StartObject(17)
def Start(builder):
    return PNMStart(builder)
def PNMAddIPFS_CID(builder, IPFS_CID): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(IPFS_CID), 0)
def AddIPFS_CID(builder, IPFS_CID):
    return PNMAddIPFS_CID(builder, IPFS_CID)
def PNMAddETH_DIGITAL_SIGNATURE(builder, ETH_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(ETH_DIGITAL_SIGNATURE), 0)
def AddETH_DIGITAL_SIGNATURE(builder, ETH_DIGITAL_SIGNATURE):
    return PNMAddETH_DIGITAL_SIGNATURE(builder, ETH_DIGITAL_SIGNATURE)
def PNMAddBTC_DIGITAL_SIGNATURE(builder, BTC_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(BTC_DIGITAL_SIGNATURE), 0)
def AddBTC_DIGITAL_SIGNATURE(builder, BTC_DIGITAL_SIGNATURE):
    return PNMAddBTC_DIGITAL_SIGNATURE(builder, BTC_DIGITAL_SIGNATURE)
def PNMAddLTC_DIGITAL_SIGNATURE(builder, LTC_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(LTC_DIGITAL_SIGNATURE), 0)
def AddLTC_DIGITAL_SIGNATURE(builder, LTC_DIGITAL_SIGNATURE):
    return PNMAddLTC_DIGITAL_SIGNATURE(builder, LTC_DIGITAL_SIGNATURE)
def PNMAddXRP_DIGITAL_SIGNATURE(builder, XRP_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(XRP_DIGITAL_SIGNATURE), 0)
def AddXRP_DIGITAL_SIGNATURE(builder, XRP_DIGITAL_SIGNATURE):
    return PNMAddXRP_DIGITAL_SIGNATURE(builder, XRP_DIGITAL_SIGNATURE)
def PNMAddADA_DIGITAL_SIGNATURE(builder, ADA_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(ADA_DIGITAL_SIGNATURE), 0)
def AddADA_DIGITAL_SIGNATURE(builder, ADA_DIGITAL_SIGNATURE):
    return PNMAddADA_DIGITAL_SIGNATURE(builder, ADA_DIGITAL_SIGNATURE)
def PNMAddXLM_DIGITAL_SIGNATURE(builder, XLM_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(XLM_DIGITAL_SIGNATURE), 0)
def AddXLM_DIGITAL_SIGNATURE(builder, XLM_DIGITAL_SIGNATURE):
    return PNMAddXLM_DIGITAL_SIGNATURE(builder, XLM_DIGITAL_SIGNATURE)
def PNMAddDOGE_DIGITAL_SIGNATURE(builder, DOGE_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(DOGE_DIGITAL_SIGNATURE), 0)
def AddDOGE_DIGITAL_SIGNATURE(builder, DOGE_DIGITAL_SIGNATURE):
    return PNMAddDOGE_DIGITAL_SIGNATURE(builder, DOGE_DIGITAL_SIGNATURE)
def PNMAddXMR_DIGITAL_SIGNATURE(builder, XMR_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(XMR_DIGITAL_SIGNATURE), 0)
def AddXMR_DIGITAL_SIGNATURE(builder, XMR_DIGITAL_SIGNATURE):
    return PNMAddXMR_DIGITAL_SIGNATURE(builder, XMR_DIGITAL_SIGNATURE)
def PNMAddDOT_DIGITAL_SIGNATURE(builder, DOT_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(DOT_DIGITAL_SIGNATURE), 0)
def AddDOT_DIGITAL_SIGNATURE(builder, DOT_DIGITAL_SIGNATURE):
    return PNMAddDOT_DIGITAL_SIGNATURE(builder, DOT_DIGITAL_SIGNATURE)
def PNMAddFIL_DIGITAL_SIGNATURE(builder, FIL_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(FIL_DIGITAL_SIGNATURE), 0)
def AddFIL_DIGITAL_SIGNATURE(builder, FIL_DIGITAL_SIGNATURE):
    return PNMAddFIL_DIGITAL_SIGNATURE(builder, FIL_DIGITAL_SIGNATURE)
def PNMAddXTZ_DIGITAL_SIGNATURE(builder, XTZ_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(XTZ_DIGITAL_SIGNATURE), 0)
def AddXTZ_DIGITAL_SIGNATURE(builder, XTZ_DIGITAL_SIGNATURE):
    return PNMAddXTZ_DIGITAL_SIGNATURE(builder, XTZ_DIGITAL_SIGNATURE)
def PNMAddATOM_DIGITAL_SIGNATURE(builder, ATOM_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(ATOM_DIGITAL_SIGNATURE), 0)
def AddATOM_DIGITAL_SIGNATURE(builder, ATOM_DIGITAL_SIGNATURE):
    return PNMAddATOM_DIGITAL_SIGNATURE(builder, ATOM_DIGITAL_SIGNATURE)
def PNMAddTRX_DIGITAL_SIGNATURE(builder, TRX_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(13, flatbuffers.number_types.UOffsetTFlags.py_type(TRX_DIGITAL_SIGNATURE), 0)
def AddTRX_DIGITAL_SIGNATURE(builder, TRX_DIGITAL_SIGNATURE):
    return PNMAddTRX_DIGITAL_SIGNATURE(builder, TRX_DIGITAL_SIGNATURE)
def PNMAddBNB_DIGITAL_SIGNATURE(builder, BNB_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(BNB_DIGITAL_SIGNATURE), 0)
def AddBNB_DIGITAL_SIGNATURE(builder, BNB_DIGITAL_SIGNATURE):
    return PNMAddBNB_DIGITAL_SIGNATURE(builder, BNB_DIGITAL_SIGNATURE)
def PNMAddAVAX_DIGITAL_SIGNATURE(builder, AVAX_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(AVAX_DIGITAL_SIGNATURE), 0)
def AddAVAX_DIGITAL_SIGNATURE(builder, AVAX_DIGITAL_SIGNATURE):
    return PNMAddAVAX_DIGITAL_SIGNATURE(builder, AVAX_DIGITAL_SIGNATURE)
def PNMAddSOL_DIGITAL_SIGNATURE(builder, SOL_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(16, flatbuffers.number_types.UOffsetTFlags.py_type(SOL_DIGITAL_SIGNATURE), 0)
def AddSOL_DIGITAL_SIGNATURE(builder, SOL_DIGITAL_SIGNATURE):
    return PNMAddSOL_DIGITAL_SIGNATURE(builder, SOL_DIGITAL_SIGNATURE)
def PNMEnd(builder): return builder.EndObject()
def End(builder):
    return PNMEnd(builder)

class PNMT(object):

    # PNMT
    def __init__(self):
        self.IPFS_CID = None  # type: str
        self.ETH_DIGITAL_SIGNATURE = None  # type: str
        self.BTC_DIGITAL_SIGNATURE = None  # type: str
        self.LTC_DIGITAL_SIGNATURE = None  # type: str
        self.XRP_DIGITAL_SIGNATURE = None  # type: str
        self.ADA_DIGITAL_SIGNATURE = None  # type: str
        self.XLM_DIGITAL_SIGNATURE = None  # type: str
        self.DOGE_DIGITAL_SIGNATURE = None  # type: str
        self.XMR_DIGITAL_SIGNATURE = None  # type: str
        self.DOT_DIGITAL_SIGNATURE = None  # type: str
        self.FIL_DIGITAL_SIGNATURE = None  # type: str
        self.XTZ_DIGITAL_SIGNATURE = None  # type: str
        self.ATOM_DIGITAL_SIGNATURE = None  # type: str
        self.TRX_DIGITAL_SIGNATURE = None  # type: str
        self.BNB_DIGITAL_SIGNATURE = None  # type: str
        self.AVAX_DIGITAL_SIGNATURE = None  # type: str
        self.SOL_DIGITAL_SIGNATURE = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        PNM = PNM()
        PNM.Init(buf, pos)
        return cls.InitFromObj(PNM)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, PNM):
        x = PNMT()
        x._UnPack(PNM)
        return x

    # PNMT
    def _UnPack(self, PNM):
        if PNM is None:
            return
        self.IPFS_CID = PNM.IPFS_CID()
        self.ETH_DIGITAL_SIGNATURE = PNM.ETH_DIGITAL_SIGNATURE()
        self.BTC_DIGITAL_SIGNATURE = PNM.BTC_DIGITAL_SIGNATURE()
        self.LTC_DIGITAL_SIGNATURE = PNM.LTC_DIGITAL_SIGNATURE()
        self.XRP_DIGITAL_SIGNATURE = PNM.XRP_DIGITAL_SIGNATURE()
        self.ADA_DIGITAL_SIGNATURE = PNM.ADA_DIGITAL_SIGNATURE()
        self.XLM_DIGITAL_SIGNATURE = PNM.XLM_DIGITAL_SIGNATURE()
        self.DOGE_DIGITAL_SIGNATURE = PNM.DOGE_DIGITAL_SIGNATURE()
        self.XMR_DIGITAL_SIGNATURE = PNM.XMR_DIGITAL_SIGNATURE()
        self.DOT_DIGITAL_SIGNATURE = PNM.DOT_DIGITAL_SIGNATURE()
        self.FIL_DIGITAL_SIGNATURE = PNM.FIL_DIGITAL_SIGNATURE()
        self.XTZ_DIGITAL_SIGNATURE = PNM.XTZ_DIGITAL_SIGNATURE()
        self.ATOM_DIGITAL_SIGNATURE = PNM.ATOM_DIGITAL_SIGNATURE()
        self.TRX_DIGITAL_SIGNATURE = PNM.TRX_DIGITAL_SIGNATURE()
        self.BNB_DIGITAL_SIGNATURE = PNM.BNB_DIGITAL_SIGNATURE()
        self.AVAX_DIGITAL_SIGNATURE = PNM.AVAX_DIGITAL_SIGNATURE()
        self.SOL_DIGITAL_SIGNATURE = PNM.SOL_DIGITAL_SIGNATURE()

    # PNMT
    def Pack(self, builder):
        if self.IPFS_CID is not None:
            IPFS_CID = builder.CreateString(self.IPFS_CID)
        if self.ETH_DIGITAL_SIGNATURE is not None:
            ETH_DIGITAL_SIGNATURE = builder.CreateString(self.ETH_DIGITAL_SIGNATURE)
        if self.BTC_DIGITAL_SIGNATURE is not None:
            BTC_DIGITAL_SIGNATURE = builder.CreateString(self.BTC_DIGITAL_SIGNATURE)
        if self.LTC_DIGITAL_SIGNATURE is not None:
            LTC_DIGITAL_SIGNATURE = builder.CreateString(self.LTC_DIGITAL_SIGNATURE)
        if self.XRP_DIGITAL_SIGNATURE is not None:
            XRP_DIGITAL_SIGNATURE = builder.CreateString(self.XRP_DIGITAL_SIGNATURE)
        if self.ADA_DIGITAL_SIGNATURE is not None:
            ADA_DIGITAL_SIGNATURE = builder.CreateString(self.ADA_DIGITAL_SIGNATURE)
        if self.XLM_DIGITAL_SIGNATURE is not None:
            XLM_DIGITAL_SIGNATURE = builder.CreateString(self.XLM_DIGITAL_SIGNATURE)
        if self.DOGE_DIGITAL_SIGNATURE is not None:
            DOGE_DIGITAL_SIGNATURE = builder.CreateString(self.DOGE_DIGITAL_SIGNATURE)
        if self.XMR_DIGITAL_SIGNATURE is not None:
            XMR_DIGITAL_SIGNATURE = builder.CreateString(self.XMR_DIGITAL_SIGNATURE)
        if self.DOT_DIGITAL_SIGNATURE is not None:
            DOT_DIGITAL_SIGNATURE = builder.CreateString(self.DOT_DIGITAL_SIGNATURE)
        if self.FIL_DIGITAL_SIGNATURE is not None:
            FIL_DIGITAL_SIGNATURE = builder.CreateString(self.FIL_DIGITAL_SIGNATURE)
        if self.XTZ_DIGITAL_SIGNATURE is not None:
            XTZ_DIGITAL_SIGNATURE = builder.CreateString(self.XTZ_DIGITAL_SIGNATURE)
        if self.ATOM_DIGITAL_SIGNATURE is not None:
            ATOM_DIGITAL_SIGNATURE = builder.CreateString(self.ATOM_DIGITAL_SIGNATURE)
        if self.TRX_DIGITAL_SIGNATURE is not None:
            TRX_DIGITAL_SIGNATURE = builder.CreateString(self.TRX_DIGITAL_SIGNATURE)
        if self.BNB_DIGITAL_SIGNATURE is not None:
            BNB_DIGITAL_SIGNATURE = builder.CreateString(self.BNB_DIGITAL_SIGNATURE)
        if self.AVAX_DIGITAL_SIGNATURE is not None:
            AVAX_DIGITAL_SIGNATURE = builder.CreateString(self.AVAX_DIGITAL_SIGNATURE)
        if self.SOL_DIGITAL_SIGNATURE is not None:
            SOL_DIGITAL_SIGNATURE = builder.CreateString(self.SOL_DIGITAL_SIGNATURE)
        PNMStart(builder)
        if self.IPFS_CID is not None:
            PNMAddIPFS_CID(builder, IPFS_CID)
        if self.ETH_DIGITAL_SIGNATURE is not None:
            PNMAddETH_DIGITAL_SIGNATURE(builder, ETH_DIGITAL_SIGNATURE)
        if self.BTC_DIGITAL_SIGNATURE is not None:
            PNMAddBTC_DIGITAL_SIGNATURE(builder, BTC_DIGITAL_SIGNATURE)
        if self.LTC_DIGITAL_SIGNATURE is not None:
            PNMAddLTC_DIGITAL_SIGNATURE(builder, LTC_DIGITAL_SIGNATURE)
        if self.XRP_DIGITAL_SIGNATURE is not None:
            PNMAddXRP_DIGITAL_SIGNATURE(builder, XRP_DIGITAL_SIGNATURE)
        if self.ADA_DIGITAL_SIGNATURE is not None:
            PNMAddADA_DIGITAL_SIGNATURE(builder, ADA_DIGITAL_SIGNATURE)
        if self.XLM_DIGITAL_SIGNATURE is not None:
            PNMAddXLM_DIGITAL_SIGNATURE(builder, XLM_DIGITAL_SIGNATURE)
        if self.DOGE_DIGITAL_SIGNATURE is not None:
            PNMAddDOGE_DIGITAL_SIGNATURE(builder, DOGE_DIGITAL_SIGNATURE)
        if self.XMR_DIGITAL_SIGNATURE is not None:
            PNMAddXMR_DIGITAL_SIGNATURE(builder, XMR_DIGITAL_SIGNATURE)
        if self.DOT_DIGITAL_SIGNATURE is not None:
            PNMAddDOT_DIGITAL_SIGNATURE(builder, DOT_DIGITAL_SIGNATURE)
        if self.FIL_DIGITAL_SIGNATURE is not None:
            PNMAddFIL_DIGITAL_SIGNATURE(builder, FIL_DIGITAL_SIGNATURE)
        if self.XTZ_DIGITAL_SIGNATURE is not None:
            PNMAddXTZ_DIGITAL_SIGNATURE(builder, XTZ_DIGITAL_SIGNATURE)
        if self.ATOM_DIGITAL_SIGNATURE is not None:
            PNMAddATOM_DIGITAL_SIGNATURE(builder, ATOM_DIGITAL_SIGNATURE)
        if self.TRX_DIGITAL_SIGNATURE is not None:
            PNMAddTRX_DIGITAL_SIGNATURE(builder, TRX_DIGITAL_SIGNATURE)
        if self.BNB_DIGITAL_SIGNATURE is not None:
            PNMAddBNB_DIGITAL_SIGNATURE(builder, BNB_DIGITAL_SIGNATURE)
        if self.AVAX_DIGITAL_SIGNATURE is not None:
            PNMAddAVAX_DIGITAL_SIGNATURE(builder, AVAX_DIGITAL_SIGNATURE)
        if self.SOL_DIGITAL_SIGNATURE is not None:
            PNMAddSOL_DIGITAL_SIGNATURE(builder, SOL_DIGITAL_SIGNATURE)
        PNM = PNMEnd(builder)
        return PNM
