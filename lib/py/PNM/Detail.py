# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Details of Published Message
class Detail(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Detail()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDetail(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def DetailBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x50\x4E\x4D", size_prefixed=size_prefixed)

    # Detail
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Multiformat Address
    # https://multiformats.io/multiaddr/
    # A universal address format for representing multiple network protocols. Examples include:
    # - /ip4/192.168.1.1/tcp/80 for an IPv4 address with TCP protocol
    # - /ip6zone/x/ip6/::1 for an IPv6 address with a zone
    # - /dns4/example.com for a domain name resolvable only to IPv4 addresses
    # - /ipfs/bafybeiccfclkdtucu6y4yc5cpr6y3yuinr67svmii46v5cfcrkp47ihehy/README.txt -IPFS address w/CID and path to `README.txt`.
    # Detail
    def MULTIFORMAT_ADDRESS(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Concatenated Content Identifier (CID)
    # This field is a unique ID for distributed systems (CID).
    # The CID provides a unique identifier within distributed systems, as detailed at https://github.com/multiformats/cid. 
    # Detail
    def CID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # File ID
    # This field is the file ID / Name
    # Detail
    def FID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Ethereum Digital Signature
    # Digital signature of the CID using Ethereum's signing mechanism.
    # Refer to the Ethereum Blockchain integration section for details.
    # Detail
    def ETH_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Bitcoin Digital Signature
    # Digital signature of the CID using Bitcoin's signing mechanism.
    # Refer to the Bitcoin Blockchain integration section for details.
    # Detail
    def BTC_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Litecoin Digital Signature
    # Digital signature of the CID using Litecoin's signing mechanism.
    # Refer to the Litecoin Blockchain integration section for details.
    # Detail
    def LTC_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Ripple Digital Signature
    # Digital signature of the CID using Ripple's signing mechanism.
    # Refer to the Ripple Blockchain integration section for details.
    # Detail
    def XRP_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Cardano Digital Signature
    # Digital signature of the CID using Cardano's signing mechanism.
    # Refer to the Cardano Blockchain integration section for details.
    # Detail
    def ADA_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Stellar Digital Signature
    # Digital signature of the CID using Stellar's signing mechanism.
    # Refer to the Stellar Blockchain integration section for details.
    # Detail
    def XLM_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Dogecoin Digital Signature
    # Digital signature of the CID using Dogecoin's signing mechanism.
    # Refer to the Dogecoin Blockchain integration section for details.
    # Detail
    def DOGE_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Monero Digital Signature
    # Digital signature of the CID using Monero's signing mechanism.
    # Refer to the Monero Blockchain integration section for details.
    # Detail
    def XMR_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Polkadot Digital Signature
    # Digital signature of the CID using Polkadot's signing mechanism.
    # Refer to the Polkadot Blockchain integration section for details.
    # Detail
    def DOT_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Filecoin Digital Signature
    # Digital signature of the CID using Filecoin's signing mechanism.
    # Refer to the Filecoin Blockchain integration section for details.
    # Detail
    def FIL_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Tezos Digital Signature
    # Digital signature of the CID using Tezos's signing mechanism.
    # Refer to the Tezos Blockchain integration section for details.
    # Detail
    def XTZ_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Cosmos Digital Signature
    # Digital signature of the CID using Cosmos's signing mechanism.
    # Refer to the Cosmos Blockchain integration section for details.
    # Detail
    def ATOM_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Tron Digital Signature
    # Digital signature of the CID using Tron's signing mechanism.
    # Refer to the Tron Blockchain integration section for details.
    # Detail
    def TRX_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Binance Coin Digital Signature
    # Digital signature of the CID using Binance Coin's signing mechanism.
    # Refer to the Binance Coin Blockchain integration section for details.
    # Detail
    def BNB_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Avalanche Digital Signature
    # Digital signature of the CID using Avalanche's signing mechanism.
    # Refer to the Avalanche Blockchain integration section for details.
    # Detail
    def AVAX_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Solana Digital Signature
    # Digital signature of the CID using Solana's signing mechanism.
    # Refer to the Solana Blockchain integration section for details.
    # Detail
    def SOL_DIGITAL_SIGNATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def DetailStart(builder): builder.StartObject(19)
def Start(builder):
    return DetailStart(builder)
def DetailAddMULTIFORMAT_ADDRESS(builder, MULTIFORMAT_ADDRESS): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(MULTIFORMAT_ADDRESS), 0)
def AddMULTIFORMAT_ADDRESS(builder, MULTIFORMAT_ADDRESS):
    return DetailAddMULTIFORMAT_ADDRESS(builder, MULTIFORMAT_ADDRESS)
def DetailAddCID(builder, CID): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(CID), 0)
def AddCID(builder, CID):
    return DetailAddCID(builder, CID)
def DetailAddFID(builder, FID): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(FID), 0)
def AddFID(builder, FID):
    return DetailAddFID(builder, FID)
def DetailAddETH_DIGITAL_SIGNATURE(builder, ETH_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(ETH_DIGITAL_SIGNATURE), 0)
def AddETH_DIGITAL_SIGNATURE(builder, ETH_DIGITAL_SIGNATURE):
    return DetailAddETH_DIGITAL_SIGNATURE(builder, ETH_DIGITAL_SIGNATURE)
def DetailAddBTC_DIGITAL_SIGNATURE(builder, BTC_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(BTC_DIGITAL_SIGNATURE), 0)
def AddBTC_DIGITAL_SIGNATURE(builder, BTC_DIGITAL_SIGNATURE):
    return DetailAddBTC_DIGITAL_SIGNATURE(builder, BTC_DIGITAL_SIGNATURE)
def DetailAddLTC_DIGITAL_SIGNATURE(builder, LTC_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(LTC_DIGITAL_SIGNATURE), 0)
def AddLTC_DIGITAL_SIGNATURE(builder, LTC_DIGITAL_SIGNATURE):
    return DetailAddLTC_DIGITAL_SIGNATURE(builder, LTC_DIGITAL_SIGNATURE)
def DetailAddXRP_DIGITAL_SIGNATURE(builder, XRP_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(XRP_DIGITAL_SIGNATURE), 0)
def AddXRP_DIGITAL_SIGNATURE(builder, XRP_DIGITAL_SIGNATURE):
    return DetailAddXRP_DIGITAL_SIGNATURE(builder, XRP_DIGITAL_SIGNATURE)
def DetailAddADA_DIGITAL_SIGNATURE(builder, ADA_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(ADA_DIGITAL_SIGNATURE), 0)
def AddADA_DIGITAL_SIGNATURE(builder, ADA_DIGITAL_SIGNATURE):
    return DetailAddADA_DIGITAL_SIGNATURE(builder, ADA_DIGITAL_SIGNATURE)
def DetailAddXLM_DIGITAL_SIGNATURE(builder, XLM_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(XLM_DIGITAL_SIGNATURE), 0)
def AddXLM_DIGITAL_SIGNATURE(builder, XLM_DIGITAL_SIGNATURE):
    return DetailAddXLM_DIGITAL_SIGNATURE(builder, XLM_DIGITAL_SIGNATURE)
def DetailAddDOGE_DIGITAL_SIGNATURE(builder, DOGE_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(DOGE_DIGITAL_SIGNATURE), 0)
def AddDOGE_DIGITAL_SIGNATURE(builder, DOGE_DIGITAL_SIGNATURE):
    return DetailAddDOGE_DIGITAL_SIGNATURE(builder, DOGE_DIGITAL_SIGNATURE)
def DetailAddXMR_DIGITAL_SIGNATURE(builder, XMR_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(XMR_DIGITAL_SIGNATURE), 0)
def AddXMR_DIGITAL_SIGNATURE(builder, XMR_DIGITAL_SIGNATURE):
    return DetailAddXMR_DIGITAL_SIGNATURE(builder, XMR_DIGITAL_SIGNATURE)
def DetailAddDOT_DIGITAL_SIGNATURE(builder, DOT_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(DOT_DIGITAL_SIGNATURE), 0)
def AddDOT_DIGITAL_SIGNATURE(builder, DOT_DIGITAL_SIGNATURE):
    return DetailAddDOT_DIGITAL_SIGNATURE(builder, DOT_DIGITAL_SIGNATURE)
def DetailAddFIL_DIGITAL_SIGNATURE(builder, FIL_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(FIL_DIGITAL_SIGNATURE), 0)
def AddFIL_DIGITAL_SIGNATURE(builder, FIL_DIGITAL_SIGNATURE):
    return DetailAddFIL_DIGITAL_SIGNATURE(builder, FIL_DIGITAL_SIGNATURE)
def DetailAddXTZ_DIGITAL_SIGNATURE(builder, XTZ_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(13, flatbuffers.number_types.UOffsetTFlags.py_type(XTZ_DIGITAL_SIGNATURE), 0)
def AddXTZ_DIGITAL_SIGNATURE(builder, XTZ_DIGITAL_SIGNATURE):
    return DetailAddXTZ_DIGITAL_SIGNATURE(builder, XTZ_DIGITAL_SIGNATURE)
def DetailAddATOM_DIGITAL_SIGNATURE(builder, ATOM_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(ATOM_DIGITAL_SIGNATURE), 0)
def AddATOM_DIGITAL_SIGNATURE(builder, ATOM_DIGITAL_SIGNATURE):
    return DetailAddATOM_DIGITAL_SIGNATURE(builder, ATOM_DIGITAL_SIGNATURE)
def DetailAddTRX_DIGITAL_SIGNATURE(builder, TRX_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(TRX_DIGITAL_SIGNATURE), 0)
def AddTRX_DIGITAL_SIGNATURE(builder, TRX_DIGITAL_SIGNATURE):
    return DetailAddTRX_DIGITAL_SIGNATURE(builder, TRX_DIGITAL_SIGNATURE)
def DetailAddBNB_DIGITAL_SIGNATURE(builder, BNB_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(16, flatbuffers.number_types.UOffsetTFlags.py_type(BNB_DIGITAL_SIGNATURE), 0)
def AddBNB_DIGITAL_SIGNATURE(builder, BNB_DIGITAL_SIGNATURE):
    return DetailAddBNB_DIGITAL_SIGNATURE(builder, BNB_DIGITAL_SIGNATURE)
def DetailAddAVAX_DIGITAL_SIGNATURE(builder, AVAX_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(17, flatbuffers.number_types.UOffsetTFlags.py_type(AVAX_DIGITAL_SIGNATURE), 0)
def AddAVAX_DIGITAL_SIGNATURE(builder, AVAX_DIGITAL_SIGNATURE):
    return DetailAddAVAX_DIGITAL_SIGNATURE(builder, AVAX_DIGITAL_SIGNATURE)
def DetailAddSOL_DIGITAL_SIGNATURE(builder, SOL_DIGITAL_SIGNATURE): builder.PrependUOffsetTRelativeSlot(18, flatbuffers.number_types.UOffsetTFlags.py_type(SOL_DIGITAL_SIGNATURE), 0)
def AddSOL_DIGITAL_SIGNATURE(builder, SOL_DIGITAL_SIGNATURE):
    return DetailAddSOL_DIGITAL_SIGNATURE(builder, SOL_DIGITAL_SIGNATURE)
def DetailEnd(builder): return builder.EndObject()
def End(builder):
    return DetailEnd(builder)

class DetailT(object):

    # DetailT
    def __init__(self):
        self.MULTIFORMAT_ADDRESS = None  # type: str
        self.CID = None  # type: str
        self.FID = None  # type: str
        self.ETH_DIGITAL_SIGNATURE = None  # type: str
        self.BTC_DIGITAL_SIGNATURE = None  # type: str
        self.LTC_DIGITAL_SIGNATURE = None  # type: str
        self.XRP_DIGITAL_SIGNATURE = None  # type: str
        self.ADA_DIGITAL_SIGNATURE = None  # type: str
        self.XLM_DIGITAL_SIGNATURE = None  # type: str
        self.DOGE_DIGITAL_SIGNATURE = None  # type: str
        self.XMR_DIGITAL_SIGNATURE = None  # type: str
        self.DOT_DIGITAL_SIGNATURE = None  # type: str
        self.FIL_DIGITAL_SIGNATURE = None  # type: str
        self.XTZ_DIGITAL_SIGNATURE = None  # type: str
        self.ATOM_DIGITAL_SIGNATURE = None  # type: str
        self.TRX_DIGITAL_SIGNATURE = None  # type: str
        self.BNB_DIGITAL_SIGNATURE = None  # type: str
        self.AVAX_DIGITAL_SIGNATURE = None  # type: str
        self.SOL_DIGITAL_SIGNATURE = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        detail = Detail()
        detail.Init(buf, pos)
        return cls.InitFromObj(detail)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, detail):
        x = DetailT()
        x._UnPack(detail)
        return x

    # DetailT
    def _UnPack(self, detail):
        if detail is None:
            return
        self.MULTIFORMAT_ADDRESS = detail.MULTIFORMAT_ADDRESS()
        self.CID = detail.CID()
        self.FID = detail.FID()
        self.ETH_DIGITAL_SIGNATURE = detail.ETH_DIGITAL_SIGNATURE()
        self.BTC_DIGITAL_SIGNATURE = detail.BTC_DIGITAL_SIGNATURE()
        self.LTC_DIGITAL_SIGNATURE = detail.LTC_DIGITAL_SIGNATURE()
        self.XRP_DIGITAL_SIGNATURE = detail.XRP_DIGITAL_SIGNATURE()
        self.ADA_DIGITAL_SIGNATURE = detail.ADA_DIGITAL_SIGNATURE()
        self.XLM_DIGITAL_SIGNATURE = detail.XLM_DIGITAL_SIGNATURE()
        self.DOGE_DIGITAL_SIGNATURE = detail.DOGE_DIGITAL_SIGNATURE()
        self.XMR_DIGITAL_SIGNATURE = detail.XMR_DIGITAL_SIGNATURE()
        self.DOT_DIGITAL_SIGNATURE = detail.DOT_DIGITAL_SIGNATURE()
        self.FIL_DIGITAL_SIGNATURE = detail.FIL_DIGITAL_SIGNATURE()
        self.XTZ_DIGITAL_SIGNATURE = detail.XTZ_DIGITAL_SIGNATURE()
        self.ATOM_DIGITAL_SIGNATURE = detail.ATOM_DIGITAL_SIGNATURE()
        self.TRX_DIGITAL_SIGNATURE = detail.TRX_DIGITAL_SIGNATURE()
        self.BNB_DIGITAL_SIGNATURE = detail.BNB_DIGITAL_SIGNATURE()
        self.AVAX_DIGITAL_SIGNATURE = detail.AVAX_DIGITAL_SIGNATURE()
        self.SOL_DIGITAL_SIGNATURE = detail.SOL_DIGITAL_SIGNATURE()

    # DetailT
    def Pack(self, builder):
        if self.MULTIFORMAT_ADDRESS is not None:
            MULTIFORMAT_ADDRESS = builder.CreateString(self.MULTIFORMAT_ADDRESS)
        if self.CID is not None:
            CID = builder.CreateString(self.CID)
        if self.FID is not None:
            FID = builder.CreateString(self.FID)
        if self.ETH_DIGITAL_SIGNATURE is not None:
            ETH_DIGITAL_SIGNATURE = builder.CreateString(self.ETH_DIGITAL_SIGNATURE)
        if self.BTC_DIGITAL_SIGNATURE is not None:
            BTC_DIGITAL_SIGNATURE = builder.CreateString(self.BTC_DIGITAL_SIGNATURE)
        if self.LTC_DIGITAL_SIGNATURE is not None:
            LTC_DIGITAL_SIGNATURE = builder.CreateString(self.LTC_DIGITAL_SIGNATURE)
        if self.XRP_DIGITAL_SIGNATURE is not None:
            XRP_DIGITAL_SIGNATURE = builder.CreateString(self.XRP_DIGITAL_SIGNATURE)
        if self.ADA_DIGITAL_SIGNATURE is not None:
            ADA_DIGITAL_SIGNATURE = builder.CreateString(self.ADA_DIGITAL_SIGNATURE)
        if self.XLM_DIGITAL_SIGNATURE is not None:
            XLM_DIGITAL_SIGNATURE = builder.CreateString(self.XLM_DIGITAL_SIGNATURE)
        if self.DOGE_DIGITAL_SIGNATURE is not None:
            DOGE_DIGITAL_SIGNATURE = builder.CreateString(self.DOGE_DIGITAL_SIGNATURE)
        if self.XMR_DIGITAL_SIGNATURE is not None:
            XMR_DIGITAL_SIGNATURE = builder.CreateString(self.XMR_DIGITAL_SIGNATURE)
        if self.DOT_DIGITAL_SIGNATURE is not None:
            DOT_DIGITAL_SIGNATURE = builder.CreateString(self.DOT_DIGITAL_SIGNATURE)
        if self.FIL_DIGITAL_SIGNATURE is not None:
            FIL_DIGITAL_SIGNATURE = builder.CreateString(self.FIL_DIGITAL_SIGNATURE)
        if self.XTZ_DIGITAL_SIGNATURE is not None:
            XTZ_DIGITAL_SIGNATURE = builder.CreateString(self.XTZ_DIGITAL_SIGNATURE)
        if self.ATOM_DIGITAL_SIGNATURE is not None:
            ATOM_DIGITAL_SIGNATURE = builder.CreateString(self.ATOM_DIGITAL_SIGNATURE)
        if self.TRX_DIGITAL_SIGNATURE is not None:
            TRX_DIGITAL_SIGNATURE = builder.CreateString(self.TRX_DIGITAL_SIGNATURE)
        if self.BNB_DIGITAL_SIGNATURE is not None:
            BNB_DIGITAL_SIGNATURE = builder.CreateString(self.BNB_DIGITAL_SIGNATURE)
        if self.AVAX_DIGITAL_SIGNATURE is not None:
            AVAX_DIGITAL_SIGNATURE = builder.CreateString(self.AVAX_DIGITAL_SIGNATURE)
        if self.SOL_DIGITAL_SIGNATURE is not None:
            SOL_DIGITAL_SIGNATURE = builder.CreateString(self.SOL_DIGITAL_SIGNATURE)
        DetailStart(builder)
        if self.MULTIFORMAT_ADDRESS is not None:
            DetailAddMULTIFORMAT_ADDRESS(builder, MULTIFORMAT_ADDRESS)
        if self.CID is not None:
            DetailAddCID(builder, CID)
        if self.FID is not None:
            DetailAddFID(builder, FID)
        if self.ETH_DIGITAL_SIGNATURE is not None:
            DetailAddETH_DIGITAL_SIGNATURE(builder, ETH_DIGITAL_SIGNATURE)
        if self.BTC_DIGITAL_SIGNATURE is not None:
            DetailAddBTC_DIGITAL_SIGNATURE(builder, BTC_DIGITAL_SIGNATURE)
        if self.LTC_DIGITAL_SIGNATURE is not None:
            DetailAddLTC_DIGITAL_SIGNATURE(builder, LTC_DIGITAL_SIGNATURE)
        if self.XRP_DIGITAL_SIGNATURE is not None:
            DetailAddXRP_DIGITAL_SIGNATURE(builder, XRP_DIGITAL_SIGNATURE)
        if self.ADA_DIGITAL_SIGNATURE is not None:
            DetailAddADA_DIGITAL_SIGNATURE(builder, ADA_DIGITAL_SIGNATURE)
        if self.XLM_DIGITAL_SIGNATURE is not None:
            DetailAddXLM_DIGITAL_SIGNATURE(builder, XLM_DIGITAL_SIGNATURE)
        if self.DOGE_DIGITAL_SIGNATURE is not None:
            DetailAddDOGE_DIGITAL_SIGNATURE(builder, DOGE_DIGITAL_SIGNATURE)
        if self.XMR_DIGITAL_SIGNATURE is not None:
            DetailAddXMR_DIGITAL_SIGNATURE(builder, XMR_DIGITAL_SIGNATURE)
        if self.DOT_DIGITAL_SIGNATURE is not None:
            DetailAddDOT_DIGITAL_SIGNATURE(builder, DOT_DIGITAL_SIGNATURE)
        if self.FIL_DIGITAL_SIGNATURE is not None:
            DetailAddFIL_DIGITAL_SIGNATURE(builder, FIL_DIGITAL_SIGNATURE)
        if self.XTZ_DIGITAL_SIGNATURE is not None:
            DetailAddXTZ_DIGITAL_SIGNATURE(builder, XTZ_DIGITAL_SIGNATURE)
        if self.ATOM_DIGITAL_SIGNATURE is not None:
            DetailAddATOM_DIGITAL_SIGNATURE(builder, ATOM_DIGITAL_SIGNATURE)
        if self.TRX_DIGITAL_SIGNATURE is not None:
            DetailAddTRX_DIGITAL_SIGNATURE(builder, TRX_DIGITAL_SIGNATURE)
        if self.BNB_DIGITAL_SIGNATURE is not None:
            DetailAddBNB_DIGITAL_SIGNATURE(builder, BNB_DIGITAL_SIGNATURE)
        if self.AVAX_DIGITAL_SIGNATURE is not None:
            DetailAddAVAX_DIGITAL_SIGNATURE(builder, AVAX_DIGITAL_SIGNATURE)
        if self.SOL_DIGITAL_SIGNATURE is not None:
            DetailAddSOL_DIGITAL_SIGNATURE(builder, SOL_DIGITAL_SIGNATURE)
        detail = DetailEnd(builder)
        return detail
