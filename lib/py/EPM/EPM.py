# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Represents an entity with common fields and specific attributes for Person or Organization
class EPM(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = EPM()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsEPM(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def EPMBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x45\x50\x4D", size_prefixed=size_prefixed)

    # EPM
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Common name of the entity (person or organization)
    # EPM
    def NAME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Alternate names for the entity
    # EPM
    def ALTERNATE_NAMES(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # EPM
    def ALTERNATE_NAMESLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # EPM
    def ALTERNATE_NAMESIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Email address of the entity
    # EPM
    def EMAIL(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Telephone number of the entity
    # EPM
    def TELEPHONE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Cryptographic keys associated with the entity
    # EPM
    def KEYS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from CryptoKey import CryptoKey
            obj = CryptoKey()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # EPM
    def KEYSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # EPM
    def KEYSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Multiformat addresses associated with the entity
    # EPM
    def MULTIFORMAT_ADDRESS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # EPM
    def MULTIFORMAT_ADDRESSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # EPM
    def MULTIFORMAT_ADDRESSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # EPM
    def AttributesType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # Specific attributes for the entity, either Person or Organization
    # EPM
    def ATTRIBUTES(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def EPMStart(builder): builder.StartObject(8)
def Start(builder):
    return EPMStart(builder)
def EPMAddNAME(builder, NAME): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(NAME), 0)
def AddNAME(builder, NAME):
    return EPMAddNAME(builder, NAME)
def EPMAddALTERNATE_NAMES(builder, ALTERNATE_NAMES): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(ALTERNATE_NAMES), 0)
def AddALTERNATE_NAMES(builder, ALTERNATE_NAMES):
    return EPMAddALTERNATE_NAMES(builder, ALTERNATE_NAMES)
def EPMStartALTERNATE_NAMESVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartALTERNATE_NAMESVector(builder, numElems):
    return EPMStartALTERNATE_NAMESVector(builder, numElems)
def EPMAddEMAIL(builder, EMAIL): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(EMAIL), 0)
def AddEMAIL(builder, EMAIL):
    return EPMAddEMAIL(builder, EMAIL)
def EPMAddTELEPHONE(builder, TELEPHONE): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(TELEPHONE), 0)
def AddTELEPHONE(builder, TELEPHONE):
    return EPMAddTELEPHONE(builder, TELEPHONE)
def EPMAddKEYS(builder, KEYS): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(KEYS), 0)
def AddKEYS(builder, KEYS):
    return EPMAddKEYS(builder, KEYS)
def EPMStartKEYSVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartKEYSVector(builder, numElems):
    return EPMStartKEYSVector(builder, numElems)
def EPMAddMULTIFORMAT_ADDRESS(builder, MULTIFORMAT_ADDRESS): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(MULTIFORMAT_ADDRESS), 0)
def AddMULTIFORMAT_ADDRESS(builder, MULTIFORMAT_ADDRESS):
    return EPMAddMULTIFORMAT_ADDRESS(builder, MULTIFORMAT_ADDRESS)
def EPMStartMULTIFORMAT_ADDRESSVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartMULTIFORMAT_ADDRESSVector(builder, numElems):
    return EPMStartMULTIFORMAT_ADDRESSVector(builder, numElems)
def EPMAddAttributesType(builder, attributesType): builder.PrependUint8Slot(6, attributesType, 0)
def AddAttributesType(builder, attributesType):
    return EPMAddAttributesType(builder, attributesType)
def EPMAddATTRIBUTES(builder, ATTRIBUTES): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(ATTRIBUTES), 0)
def AddATTRIBUTES(builder, ATTRIBUTES):
    return EPMAddATTRIBUTES(builder, ATTRIBUTES)
def EPMEnd(builder): return builder.EndObject()
def End(builder):
    return EPMEnd(builder)
import CryptoKey
import OrganizationAttributes
import PersonAttributes
import SpecificAttributes
try:
    from typing import List, Union
except:
    pass

class EPMT(object):

    # EPMT
    def __init__(self):
        self.NAME = None  # type: str
        self.ALTERNATE_NAMES = None  # type: List[str]
        self.EMAIL = None  # type: str
        self.TELEPHONE = None  # type: str
        self.KEYS = None  # type: List[CryptoKey.CryptoKeyT]
        self.MULTIFORMAT_ADDRESS = None  # type: List[str]
        self.attributesType = 0  # type: int
        self.ATTRIBUTES = None  # type: Union[None, PersonAttributes.PersonAttributesT, OrganizationAttributes.OrganizationAttributesT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        EPM = EPM()
        EPM.Init(buf, pos)
        return cls.InitFromObj(EPM)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, EPM):
        x = EPMT()
        x._UnPack(EPM)
        return x

    # EPMT
    def _UnPack(self, EPM):
        if EPM is None:
            return
        self.NAME = EPM.NAME()
        if not EPM.ALTERNATE_NAMESIsNone():
            self.ALTERNATE_NAMES = []
            for i in range(EPM.ALTERNATE_NAMESLength()):
                self.ALTERNATE_NAMES.append(EPM.ALTERNATE_NAMES(i))
        self.EMAIL = EPM.EMAIL()
        self.TELEPHONE = EPM.TELEPHONE()
        if not EPM.KEYSIsNone():
            self.KEYS = []
            for i in range(EPM.KEYSLength()):
                if EPM.KEYS(i) is None:
                    self.KEYS.append(None)
                else:
                    cryptoKey_ = CryptoKey.CryptoKeyT.InitFromObj(EPM.KEYS(i))
                    self.KEYS.append(cryptoKey_)
        if not EPM.MULTIFORMAT_ADDRESSIsNone():
            self.MULTIFORMAT_ADDRESS = []
            for i in range(EPM.MULTIFORMAT_ADDRESSLength()):
                self.MULTIFORMAT_ADDRESS.append(EPM.MULTIFORMAT_ADDRESS(i))
        self.attributesType = EPM.AttributesType()
        self.ATTRIBUTES = SpecificAttributes.SpecificAttributesCreator(self.ATTRIBUTESType, EPM.ATTRIBUTES())

    # EPMT
    def Pack(self, builder):
        if self.NAME is not None:
            NAME = builder.CreateString(self.NAME)
        if self.ALTERNATE_NAMES is not None:
            ALTERNATE_NAMESlist = []
            for i in range(len(self.ALTERNATE_NAMES)):
                ALTERNATE_NAMESlist.append(builder.CreateString(self.ALTERNATE_NAMES[i]))
            EPMStartALTERNATE_NAMESVector(builder, len(self.ALTERNATE_NAMES))
            for i in reversed(range(len(self.ALTERNATE_NAMES))):
                builder.PrependUOffsetTRelative(ALTERNATE_NAMESlist[i])
            ALTERNATE_NAMES = builder.EndVector()
        if self.EMAIL is not None:
            EMAIL = builder.CreateString(self.EMAIL)
        if self.TELEPHONE is not None:
            TELEPHONE = builder.CreateString(self.TELEPHONE)
        if self.KEYS is not None:
            KEYSlist = []
            for i in range(len(self.KEYS)):
                KEYSlist.append(self.KEYS[i].Pack(builder))
            EPMStartKEYSVector(builder, len(self.KEYS))
            for i in reversed(range(len(self.KEYS))):
                builder.PrependUOffsetTRelative(KEYSlist[i])
            KEYS = builder.EndVector()
        if self.MULTIFORMAT_ADDRESS is not None:
            MULTIFORMAT_ADDRESSlist = []
            for i in range(len(self.MULTIFORMAT_ADDRESS)):
                MULTIFORMAT_ADDRESSlist.append(builder.CreateString(self.MULTIFORMAT_ADDRESS[i]))
            EPMStartMULTIFORMAT_ADDRESSVector(builder, len(self.MULTIFORMAT_ADDRESS))
            for i in reversed(range(len(self.MULTIFORMAT_ADDRESS))):
                builder.PrependUOffsetTRelative(MULTIFORMAT_ADDRESSlist[i])
            MULTIFORMAT_ADDRESS = builder.EndVector()
        if self.ATTRIBUTES is not None:
            ATTRIBUTES = self.ATTRIBUTES.Pack(builder)
        EPMStart(builder)
        if self.NAME is not None:
            EPMAddNAME(builder, NAME)
        if self.ALTERNATE_NAMES is not None:
            EPMAddALTERNATE_NAMES(builder, ALTERNATE_NAMES)
        if self.EMAIL is not None:
            EPMAddEMAIL(builder, EMAIL)
        if self.TELEPHONE is not None:
            EPMAddTELEPHONE(builder, TELEPHONE)
        if self.KEYS is not None:
            EPMAddKEYS(builder, KEYS)
        if self.MULTIFORMAT_ADDRESS is not None:
            EPMAddMULTIFORMAT_ADDRESS(builder, MULTIFORMAT_ADDRESS)
        EPMAddAttributesType(builder, self.attributesType)
        if self.ATTRIBUTES is not None:
            EPMAddATTRIBUTES(builder, ATTRIBUTES)
        EPM = EPMEnd(builder)
        return EPM
