# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Integrated Device Message
class IDM(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = IDM()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsIDM(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def IDMBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x49\x44\x4D", size_prefixed=size_prefixed)

    # IDM
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Unique identifier for the EMT
    # IDM
    def ID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Name of the EMT
    # IDM
    def NAME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Mode of the data (real, simulated, synthetic)
    # IDM
    def DATA_MODE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Uplink frequency range
    # IDM
    def UPLINK(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from FrequencyRange import FrequencyRange
            obj = FrequencyRange()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Downlink frequency range
    # IDM
    def DOWNLINK(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from FrequencyRange import FrequencyRange
            obj = FrequencyRange()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Beacon frequency range
    # IDM
    def BEACON(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from FrequencyRange import FrequencyRange
            obj = FrequencyRange()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Bands associated with the EMT
    # IDM
    def BAND(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from Band import Band
            obj = Band()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # IDM
    def BANDLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # IDM
    def BANDIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Type of polarization used
    # IDM
    def POLARIZATION_TYPE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Simple polarization configuration
    # IDM
    def SIMPLE_POLARIZATION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Stokes parameters for polarization characterization
    # IDM
    def STOKES_PARAMETERS(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from StokesParameters import StokesParameters
            obj = StokesParameters()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Power required in Watts
    # IDM
    def POWER_REQUIRED(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Type of power (eg. AC or DC)
    # IDM
    def POWER_TYPE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Indicates if the EMT can transmit
    # IDM
    def TRANSMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Indicates if the EMT can receive
    # IDM
    def RECEIVE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Type of the sensor
    # IDM
    def SENSOR_TYPE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Source of the data
    # IDM
    def SOURCE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Timestamp of the last observation
    # IDM
    def LAST_OB_TIME(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Lower left elevation limit
    # IDM
    def LOWER_LEFT_ELEVATION_LIMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Upper left azimuth limit
    # IDM
    def UPPER_LEFT_AZIMUTH_LIMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Lower right elevation limit
    # IDM
    def LOWER_RIGHT_ELEVATION_LIMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Lower left azimuth limit
    # IDM
    def LOWER_LEFT_AZIMUTH_LIMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(44))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Upper right elevation limit
    # IDM
    def UPPER_RIGHT_ELEVATION_LIMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(46))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Upper right azimuth limit
    # IDM
    def UPPER_RIGHT_AZIMUTH_LIMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(48))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Lower right azimuth limit
    # IDM
    def LOWER_RIGHT_AZIMUTH_LIMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(50))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Upper left elevation limit
    # IDM
    def UPPER_LEFT_ELEVATION_LIMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(52))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Right geostationary belt limit
    # IDM
    def RIGHT_GEO_BELT_LIMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(54))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Left geostationary belt limit
    # IDM
    def LEFT_GEO_BELT_LIMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(56))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Magnitude limit of the sensor
    # IDM
    def MAGNITUDE_LIMIT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(58))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Indicates if the site is taskable
    # IDM
    def TASKABLE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(60))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def IDMStart(builder):
    builder.StartObject(29)

def Start(builder):
    IDMStart(builder)

def IDMAddID(builder, ID):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(ID), 0)

def AddID(builder, ID):
    IDMAddID(builder, ID)

def IDMAddNAME(builder, NAME):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(NAME), 0)

def AddNAME(builder, NAME):
    IDMAddNAME(builder, NAME)

def IDMAddDATA_MODE(builder, DATA_MODE):
    builder.PrependInt8Slot(2, DATA_MODE, 0)

def AddDATA_MODE(builder, DATA_MODE):
    IDMAddDATA_MODE(builder, DATA_MODE)

def IDMAddUPLINK(builder, UPLINK):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(UPLINK), 0)

def AddUPLINK(builder, UPLINK):
    IDMAddUPLINK(builder, UPLINK)

def IDMAddDOWNLINK(builder, DOWNLINK):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(DOWNLINK), 0)

def AddDOWNLINK(builder, DOWNLINK):
    IDMAddDOWNLINK(builder, DOWNLINK)

def IDMAddBEACON(builder, BEACON):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(BEACON), 0)

def AddBEACON(builder, BEACON):
    IDMAddBEACON(builder, BEACON)

def IDMAddBAND(builder, BAND):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(BAND), 0)

def AddBAND(builder, BAND):
    IDMAddBAND(builder, BAND)

def IDMStartBANDVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartBANDVector(builder, numElems):
    return IDMStartBANDVector(builder, numElems)

def IDMAddPOLARIZATION_TYPE(builder, POLARIZATION_TYPE):
    builder.PrependInt8Slot(7, POLARIZATION_TYPE, 0)

def AddPOLARIZATION_TYPE(builder, POLARIZATION_TYPE):
    IDMAddPOLARIZATION_TYPE(builder, POLARIZATION_TYPE)

def IDMAddSIMPLE_POLARIZATION(builder, SIMPLE_POLARIZATION):
    builder.PrependInt8Slot(8, SIMPLE_POLARIZATION, 0)

def AddSIMPLE_POLARIZATION(builder, SIMPLE_POLARIZATION):
    IDMAddSIMPLE_POLARIZATION(builder, SIMPLE_POLARIZATION)

def IDMAddSTOKES_PARAMETERS(builder, STOKES_PARAMETERS):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(STOKES_PARAMETERS), 0)

def AddSTOKES_PARAMETERS(builder, STOKES_PARAMETERS):
    IDMAddSTOKES_PARAMETERS(builder, STOKES_PARAMETERS)

def IDMAddPOWER_REQUIRED(builder, POWER_REQUIRED):
    builder.PrependFloat64Slot(10, POWER_REQUIRED, 0.0)

def AddPOWER_REQUIRED(builder, POWER_REQUIRED):
    IDMAddPOWER_REQUIRED(builder, POWER_REQUIRED)

def IDMAddPOWER_TYPE(builder, POWER_TYPE):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(POWER_TYPE), 0)

def AddPOWER_TYPE(builder, POWER_TYPE):
    IDMAddPOWER_TYPE(builder, POWER_TYPE)

def IDMAddTRANSMIT(builder, TRANSMIT):
    builder.PrependBoolSlot(12, TRANSMIT, 0)

def AddTRANSMIT(builder, TRANSMIT):
    IDMAddTRANSMIT(builder, TRANSMIT)

def IDMAddRECEIVE(builder, RECEIVE):
    builder.PrependBoolSlot(13, RECEIVE, 0)

def AddRECEIVE(builder, RECEIVE):
    IDMAddRECEIVE(builder, RECEIVE)

def IDMAddSENSOR_TYPE(builder, SENSOR_TYPE):
    builder.PrependInt8Slot(14, SENSOR_TYPE, 0)

def AddSENSOR_TYPE(builder, SENSOR_TYPE):
    IDMAddSENSOR_TYPE(builder, SENSOR_TYPE)

def IDMAddSOURCE(builder, SOURCE):
    builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(SOURCE), 0)

def AddSOURCE(builder, SOURCE):
    IDMAddSOURCE(builder, SOURCE)

def IDMAddLAST_OB_TIME(builder, LAST_OB_TIME):
    builder.PrependUOffsetTRelativeSlot(16, flatbuffers.number_types.UOffsetTFlags.py_type(LAST_OB_TIME), 0)

def AddLAST_OB_TIME(builder, LAST_OB_TIME):
    IDMAddLAST_OB_TIME(builder, LAST_OB_TIME)

def IDMAddLOWER_LEFT_ELEVATION_LIMIT(builder, LOWER_LEFT_ELEVATION_LIMIT):
    builder.PrependFloat64Slot(17, LOWER_LEFT_ELEVATION_LIMIT, 0.0)

def AddLOWER_LEFT_ELEVATION_LIMIT(builder, LOWER_LEFT_ELEVATION_LIMIT):
    IDMAddLOWER_LEFT_ELEVATION_LIMIT(builder, LOWER_LEFT_ELEVATION_LIMIT)

def IDMAddUPPER_LEFT_AZIMUTH_LIMIT(builder, UPPER_LEFT_AZIMUTH_LIMIT):
    builder.PrependFloat64Slot(18, UPPER_LEFT_AZIMUTH_LIMIT, 0.0)

def AddUPPER_LEFT_AZIMUTH_LIMIT(builder, UPPER_LEFT_AZIMUTH_LIMIT):
    IDMAddUPPER_LEFT_AZIMUTH_LIMIT(builder, UPPER_LEFT_AZIMUTH_LIMIT)

def IDMAddLOWER_RIGHT_ELEVATION_LIMIT(builder, LOWER_RIGHT_ELEVATION_LIMIT):
    builder.PrependFloat64Slot(19, LOWER_RIGHT_ELEVATION_LIMIT, 0.0)

def AddLOWER_RIGHT_ELEVATION_LIMIT(builder, LOWER_RIGHT_ELEVATION_LIMIT):
    IDMAddLOWER_RIGHT_ELEVATION_LIMIT(builder, LOWER_RIGHT_ELEVATION_LIMIT)

def IDMAddLOWER_LEFT_AZIMUTH_LIMIT(builder, LOWER_LEFT_AZIMUTH_LIMIT):
    builder.PrependFloat64Slot(20, LOWER_LEFT_AZIMUTH_LIMIT, 0.0)

def AddLOWER_LEFT_AZIMUTH_LIMIT(builder, LOWER_LEFT_AZIMUTH_LIMIT):
    IDMAddLOWER_LEFT_AZIMUTH_LIMIT(builder, LOWER_LEFT_AZIMUTH_LIMIT)

def IDMAddUPPER_RIGHT_ELEVATION_LIMIT(builder, UPPER_RIGHT_ELEVATION_LIMIT):
    builder.PrependFloat64Slot(21, UPPER_RIGHT_ELEVATION_LIMIT, 0.0)

def AddUPPER_RIGHT_ELEVATION_LIMIT(builder, UPPER_RIGHT_ELEVATION_LIMIT):
    IDMAddUPPER_RIGHT_ELEVATION_LIMIT(builder, UPPER_RIGHT_ELEVATION_LIMIT)

def IDMAddUPPER_RIGHT_AZIMUTH_LIMIT(builder, UPPER_RIGHT_AZIMUTH_LIMIT):
    builder.PrependFloat64Slot(22, UPPER_RIGHT_AZIMUTH_LIMIT, 0.0)

def AddUPPER_RIGHT_AZIMUTH_LIMIT(builder, UPPER_RIGHT_AZIMUTH_LIMIT):
    IDMAddUPPER_RIGHT_AZIMUTH_LIMIT(builder, UPPER_RIGHT_AZIMUTH_LIMIT)

def IDMAddLOWER_RIGHT_AZIMUTH_LIMIT(builder, LOWER_RIGHT_AZIMUTH_LIMIT):
    builder.PrependFloat64Slot(23, LOWER_RIGHT_AZIMUTH_LIMIT, 0.0)

def AddLOWER_RIGHT_AZIMUTH_LIMIT(builder, LOWER_RIGHT_AZIMUTH_LIMIT):
    IDMAddLOWER_RIGHT_AZIMUTH_LIMIT(builder, LOWER_RIGHT_AZIMUTH_LIMIT)

def IDMAddUPPER_LEFT_ELEVATION_LIMIT(builder, UPPER_LEFT_ELEVATION_LIMIT):
    builder.PrependFloat64Slot(24, UPPER_LEFT_ELEVATION_LIMIT, 0.0)

def AddUPPER_LEFT_ELEVATION_LIMIT(builder, UPPER_LEFT_ELEVATION_LIMIT):
    IDMAddUPPER_LEFT_ELEVATION_LIMIT(builder, UPPER_LEFT_ELEVATION_LIMIT)

def IDMAddRIGHT_GEO_BELT_LIMIT(builder, RIGHT_GEO_BELT_LIMIT):
    builder.PrependFloat64Slot(25, RIGHT_GEO_BELT_LIMIT, 0.0)

def AddRIGHT_GEO_BELT_LIMIT(builder, RIGHT_GEO_BELT_LIMIT):
    IDMAddRIGHT_GEO_BELT_LIMIT(builder, RIGHT_GEO_BELT_LIMIT)

def IDMAddLEFT_GEO_BELT_LIMIT(builder, LEFT_GEO_BELT_LIMIT):
    builder.PrependFloat64Slot(26, LEFT_GEO_BELT_LIMIT, 0.0)

def AddLEFT_GEO_BELT_LIMIT(builder, LEFT_GEO_BELT_LIMIT):
    IDMAddLEFT_GEO_BELT_LIMIT(builder, LEFT_GEO_BELT_LIMIT)

def IDMAddMAGNITUDE_LIMIT(builder, MAGNITUDE_LIMIT):
    builder.PrependFloat64Slot(27, MAGNITUDE_LIMIT, 0.0)

def AddMAGNITUDE_LIMIT(builder, MAGNITUDE_LIMIT):
    IDMAddMAGNITUDE_LIMIT(builder, MAGNITUDE_LIMIT)

def IDMAddTASKABLE(builder, TASKABLE):
    builder.PrependBoolSlot(28, TASKABLE, 0)

def AddTASKABLE(builder, TASKABLE):
    IDMAddTASKABLE(builder, TASKABLE)

def IDMEnd(builder):
    return builder.EndObject()

def End(builder):
    return IDMEnd(builder)

import Band
import FrequencyRange
import StokesParameters
try:
    from typing import List, Optional
except:
    pass

class IDMT(object):

    # IDMT
    def __init__(self):
        self.ID = None  # type: str
        self.NAME = None  # type: str
        self.DATA_MODE = 0  # type: int
        self.UPLINK = None  # type: Optional[FrequencyRange.FrequencyRangeT]
        self.DOWNLINK = None  # type: Optional[FrequencyRange.FrequencyRangeT]
        self.BEACON = None  # type: Optional[FrequencyRange.FrequencyRangeT]
        self.BAND = None  # type: List[Band.BandT]
        self.POLARIZATION_TYPE = 0  # type: int
        self.SIMPLE_POLARIZATION = 0  # type: int
        self.STOKES_PARAMETERS = None  # type: Optional[StokesParameters.StokesParametersT]
        self.POWER_REQUIRED = 0.0  # type: float
        self.POWER_TYPE = None  # type: str
        self.TRANSMIT = False  # type: bool
        self.RECEIVE = False  # type: bool
        self.SENSOR_TYPE = 0  # type: int
        self.SOURCE = None  # type: str
        self.LAST_OB_TIME = None  # type: str
        self.LOWER_LEFT_ELEVATION_LIMIT = 0.0  # type: float
        self.UPPER_LEFT_AZIMUTH_LIMIT = 0.0  # type: float
        self.LOWER_RIGHT_ELEVATION_LIMIT = 0.0  # type: float
        self.LOWER_LEFT_AZIMUTH_LIMIT = 0.0  # type: float
        self.UPPER_RIGHT_ELEVATION_LIMIT = 0.0  # type: float
        self.UPPER_RIGHT_AZIMUTH_LIMIT = 0.0  # type: float
        self.LOWER_RIGHT_AZIMUTH_LIMIT = 0.0  # type: float
        self.UPPER_LEFT_ELEVATION_LIMIT = 0.0  # type: float
        self.RIGHT_GEO_BELT_LIMIT = 0.0  # type: float
        self.LEFT_GEO_BELT_LIMIT = 0.0  # type: float
        self.MAGNITUDE_LIMIT = 0.0  # type: float
        self.TASKABLE = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        IDM = IDM()
        IDM.Init(buf, pos)
        return cls.InitFromObj(IDM)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, IDM):
        x = IDMT()
        x._UnPack(IDM)
        return x

    # IDMT
    def _UnPack(self, IDM):
        if IDM is None:
            return
        self.ID = IDM.ID()
        self.NAME = IDM.NAME()
        self.DATA_MODE = IDM.DATA_MODE()
        if IDM.UPLINK() is not None:
            self.UPLINK = FrequencyRange.FrequencyRangeT.InitFromObj(IDM.UPLINK())
        if IDM.DOWNLINK() is not None:
            self.DOWNLINK = FrequencyRange.FrequencyRangeT.InitFromObj(IDM.DOWNLINK())
        if IDM.BEACON() is not None:
            self.BEACON = FrequencyRange.FrequencyRangeT.InitFromObj(IDM.BEACON())
        if not IDM.BANDIsNone():
            self.BAND = []
            for i in range(IDM.BANDLength()):
                if IDM.BAND(i) is None:
                    self.BAND.append(None)
                else:
                    band_ = Band.BandT.InitFromObj(IDM.BAND(i))
                    self.BAND.append(band_)
        self.POLARIZATION_TYPE = IDM.POLARIZATION_TYPE()
        self.SIMPLE_POLARIZATION = IDM.SIMPLE_POLARIZATION()
        if IDM.STOKES_PARAMETERS() is not None:
            self.STOKES_PARAMETERS = StokesParameters.StokesParametersT.InitFromObj(IDM.STOKES_PARAMETERS())
        self.POWER_REQUIRED = IDM.POWER_REQUIRED()
        self.POWER_TYPE = IDM.POWER_TYPE()
        self.TRANSMIT = IDM.TRANSMIT()
        self.RECEIVE = IDM.RECEIVE()
        self.SENSOR_TYPE = IDM.SENSOR_TYPE()
        self.SOURCE = IDM.SOURCE()
        self.LAST_OB_TIME = IDM.LAST_OB_TIME()
        self.LOWER_LEFT_ELEVATION_LIMIT = IDM.LOWER_LEFT_ELEVATION_LIMIT()
        self.UPPER_LEFT_AZIMUTH_LIMIT = IDM.UPPER_LEFT_AZIMUTH_LIMIT()
        self.LOWER_RIGHT_ELEVATION_LIMIT = IDM.LOWER_RIGHT_ELEVATION_LIMIT()
        self.LOWER_LEFT_AZIMUTH_LIMIT = IDM.LOWER_LEFT_AZIMUTH_LIMIT()
        self.UPPER_RIGHT_ELEVATION_LIMIT = IDM.UPPER_RIGHT_ELEVATION_LIMIT()
        self.UPPER_RIGHT_AZIMUTH_LIMIT = IDM.UPPER_RIGHT_AZIMUTH_LIMIT()
        self.LOWER_RIGHT_AZIMUTH_LIMIT = IDM.LOWER_RIGHT_AZIMUTH_LIMIT()
        self.UPPER_LEFT_ELEVATION_LIMIT = IDM.UPPER_LEFT_ELEVATION_LIMIT()
        self.RIGHT_GEO_BELT_LIMIT = IDM.RIGHT_GEO_BELT_LIMIT()
        self.LEFT_GEO_BELT_LIMIT = IDM.LEFT_GEO_BELT_LIMIT()
        self.MAGNITUDE_LIMIT = IDM.MAGNITUDE_LIMIT()
        self.TASKABLE = IDM.TASKABLE()

    # IDMT
    def Pack(self, builder):
        if self.ID is not None:
            ID = builder.CreateString(self.ID)
        if self.NAME is not None:
            NAME = builder.CreateString(self.NAME)
        if self.UPLINK is not None:
            UPLINK = self.UPLINK.Pack(builder)
        if self.DOWNLINK is not None:
            DOWNLINK = self.DOWNLINK.Pack(builder)
        if self.BEACON is not None:
            BEACON = self.BEACON.Pack(builder)
        if self.BAND is not None:
            BANDlist = []
            for i in range(len(self.BAND)):
                BANDlist.append(self.BAND[i].Pack(builder))
            IDMStartBANDVector(builder, len(self.BAND))
            for i in reversed(range(len(self.BAND))):
                builder.PrependUOffsetTRelative(BANDlist[i])
            BAND = builder.EndVector()
        if self.STOKES_PARAMETERS is not None:
            STOKES_PARAMETERS = self.STOKES_PARAMETERS.Pack(builder)
        if self.POWER_TYPE is not None:
            POWER_TYPE = builder.CreateString(self.POWER_TYPE)
        if self.SOURCE is not None:
            SOURCE = builder.CreateString(self.SOURCE)
        if self.LAST_OB_TIME is not None:
            LAST_OB_TIME = builder.CreateString(self.LAST_OB_TIME)
        IDMStart(builder)
        if self.ID is not None:
            IDMAddID(builder, ID)
        if self.NAME is not None:
            IDMAddNAME(builder, NAME)
        IDMAddDATA_MODE(builder, self.DATA_MODE)
        if self.UPLINK is not None:
            IDMAddUPLINK(builder, UPLINK)
        if self.DOWNLINK is not None:
            IDMAddDOWNLINK(builder, DOWNLINK)
        if self.BEACON is not None:
            IDMAddBEACON(builder, BEACON)
        if self.BAND is not None:
            IDMAddBAND(builder, BAND)
        IDMAddPOLARIZATION_TYPE(builder, self.POLARIZATION_TYPE)
        IDMAddSIMPLE_POLARIZATION(builder, self.SIMPLE_POLARIZATION)
        if self.STOKES_PARAMETERS is not None:
            IDMAddSTOKES_PARAMETERS(builder, STOKES_PARAMETERS)
        IDMAddPOWER_REQUIRED(builder, self.POWER_REQUIRED)
        if self.POWER_TYPE is not None:
            IDMAddPOWER_TYPE(builder, POWER_TYPE)
        IDMAddTRANSMIT(builder, self.TRANSMIT)
        IDMAddRECEIVE(builder, self.RECEIVE)
        IDMAddSENSOR_TYPE(builder, self.SENSOR_TYPE)
        if self.SOURCE is not None:
            IDMAddSOURCE(builder, SOURCE)
        if self.LAST_OB_TIME is not None:
            IDMAddLAST_OB_TIME(builder, LAST_OB_TIME)
        IDMAddLOWER_LEFT_ELEVATION_LIMIT(builder, self.LOWER_LEFT_ELEVATION_LIMIT)
        IDMAddUPPER_LEFT_AZIMUTH_LIMIT(builder, self.UPPER_LEFT_AZIMUTH_LIMIT)
        IDMAddLOWER_RIGHT_ELEVATION_LIMIT(builder, self.LOWER_RIGHT_ELEVATION_LIMIT)
        IDMAddLOWER_LEFT_AZIMUTH_LIMIT(builder, self.LOWER_LEFT_AZIMUTH_LIMIT)
        IDMAddUPPER_RIGHT_ELEVATION_LIMIT(builder, self.UPPER_RIGHT_ELEVATION_LIMIT)
        IDMAddUPPER_RIGHT_AZIMUTH_LIMIT(builder, self.UPPER_RIGHT_AZIMUTH_LIMIT)
        IDMAddLOWER_RIGHT_AZIMUTH_LIMIT(builder, self.LOWER_RIGHT_AZIMUTH_LIMIT)
        IDMAddUPPER_LEFT_ELEVATION_LIMIT(builder, self.UPPER_LEFT_ELEVATION_LIMIT)
        IDMAddRIGHT_GEO_BELT_LIMIT(builder, self.RIGHT_GEO_BELT_LIMIT)
        IDMAddLEFT_GEO_BELT_LIMIT(builder, self.LEFT_GEO_BELT_LIMIT)
        IDMAddMAGNITUDE_LIMIT(builder, self.MAGNITUDE_LIMIT)
        IDMAddTASKABLE(builder, self.TASKABLE)
        IDM = IDMEnd(builder)
        return IDM
