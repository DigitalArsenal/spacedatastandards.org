# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Encryption Header containing all parameters needed for decryption
class ENC(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ENC()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsENC(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ENCBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x45\x4E\x43", size_prefixed=size_prefixed)

    # ENC
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Schema version for forward compatibility
    # ENC
    def VERSION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 1

    # Key exchange algorithm used
    # ENC
    def KEY_EXCHANGE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Symmetric encryption algorithm used
    # ENC
    def SYMMETRIC(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Key derivation function used
    # ENC
    def KEY_DERIVATION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Ephemeral public key for ECDH key agreement (32-65 bytes depending on algorithm)
    # ENC
    def EPHEMERAL_PUBLIC_KEY(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # ENC
    def EPHEMERAL_PUBLIC_KEYAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # ENC
    def EPHEMERAL_PUBLIC_KEYLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ENC
    def EPHEMERAL_PUBLIC_KEYIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
    # ENC
    def NONCE_START(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # ENC
    def NONCE_STARTAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # ENC
    def NONCE_STARTLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ENC
    def NONCE_STARTIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Optional identifier for the recipient's public key (up to 32 bytes)
    # ENC
    def RECIPIENT_KEY_ID(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # ENC
    def RECIPIENT_KEY_IDAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # ENC
    def RECIPIENT_KEY_IDLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ENC
    def RECIPIENT_KEY_IDIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Optional domain separation context string
    # ENC
    def CONTEXT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Optional SHA-256 hash of the FlatBuffers schema (32 bytes)
    # ENC
    def SCHEMA_HASH(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # ENC
    def SCHEMA_HASHAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # ENC
    def SCHEMA_HASHLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ENC
    def SCHEMA_HASHIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

    # Optional root type name from the schema
    # ENC
    def ROOT_TYPE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Optional Unix timestamp (milliseconds) when encryption was performed
    # ENC
    def TIMESTAMP(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

def ENCStart(builder):
    builder.StartObject(11)

def Start(builder):
    ENCStart(builder)

def ENCAddVERSION(builder, VERSION):
    builder.PrependUint8Slot(0, VERSION, 1)

def AddVERSION(builder, VERSION):
    ENCAddVERSION(builder, VERSION)

def ENCAddKEY_EXCHANGE(builder, KEY_EXCHANGE):
    builder.PrependInt8Slot(1, KEY_EXCHANGE, 0)

def AddKEY_EXCHANGE(builder, KEY_EXCHANGE):
    ENCAddKEY_EXCHANGE(builder, KEY_EXCHANGE)

def ENCAddSYMMETRIC(builder, SYMMETRIC):
    builder.PrependInt8Slot(2, SYMMETRIC, 0)

def AddSYMMETRIC(builder, SYMMETRIC):
    ENCAddSYMMETRIC(builder, SYMMETRIC)

def ENCAddKEY_DERIVATION(builder, KEY_DERIVATION):
    builder.PrependInt8Slot(3, KEY_DERIVATION, 0)

def AddKEY_DERIVATION(builder, KEY_DERIVATION):
    ENCAddKEY_DERIVATION(builder, KEY_DERIVATION)

def ENCAddEPHEMERAL_PUBLIC_KEY(builder, EPHEMERAL_PUBLIC_KEY):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(EPHEMERAL_PUBLIC_KEY), 0)

def AddEPHEMERAL_PUBLIC_KEY(builder, EPHEMERAL_PUBLIC_KEY):
    ENCAddEPHEMERAL_PUBLIC_KEY(builder, EPHEMERAL_PUBLIC_KEY)

def ENCStartEPHEMERAL_PUBLIC_KEYVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartEPHEMERAL_PUBLIC_KEYVector(builder, numElems):
    return ENCStartEPHEMERAL_PUBLIC_KEYVector(builder, numElems)

def ENCAddNONCE_START(builder, NONCE_START):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(NONCE_START), 0)

def AddNONCE_START(builder, NONCE_START):
    ENCAddNONCE_START(builder, NONCE_START)

def ENCStartNONCE_STARTVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartNONCE_STARTVector(builder, numElems):
    return ENCStartNONCE_STARTVector(builder, numElems)

def ENCAddRECIPIENT_KEY_ID(builder, RECIPIENT_KEY_ID):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(RECIPIENT_KEY_ID), 0)

def AddRECIPIENT_KEY_ID(builder, RECIPIENT_KEY_ID):
    ENCAddRECIPIENT_KEY_ID(builder, RECIPIENT_KEY_ID)

def ENCStartRECIPIENT_KEY_IDVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartRECIPIENT_KEY_IDVector(builder, numElems):
    return ENCStartRECIPIENT_KEY_IDVector(builder, numElems)

def ENCAddCONTEXT(builder, CONTEXT):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(CONTEXT), 0)

def AddCONTEXT(builder, CONTEXT):
    ENCAddCONTEXT(builder, CONTEXT)

def ENCAddSCHEMA_HASH(builder, SCHEMA_HASH):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(SCHEMA_HASH), 0)

def AddSCHEMA_HASH(builder, SCHEMA_HASH):
    ENCAddSCHEMA_HASH(builder, SCHEMA_HASH)

def ENCStartSCHEMA_HASHVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartSCHEMA_HASHVector(builder, numElems):
    return ENCStartSCHEMA_HASHVector(builder, numElems)

def ENCAddROOT_TYPE(builder, ROOT_TYPE):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(ROOT_TYPE), 0)

def AddROOT_TYPE(builder, ROOT_TYPE):
    ENCAddROOT_TYPE(builder, ROOT_TYPE)

def ENCAddTIMESTAMP(builder, TIMESTAMP):
    builder.PrependUint64Slot(10, TIMESTAMP, 0)

def AddTIMESTAMP(builder, TIMESTAMP):
    ENCAddTIMESTAMP(builder, TIMESTAMP)

def ENCEnd(builder):
    return builder.EndObject()

def End(builder):
    return ENCEnd(builder)

try:
    from typing import List
except:
    pass

class ENCT(object):

    # ENCT
    def __init__(self):
        self.VERSION = 1  # type: int
        self.KEY_EXCHANGE = 0  # type: int
        self.SYMMETRIC = 0  # type: int
        self.KEY_DERIVATION = 0  # type: int
        self.EPHEMERAL_PUBLIC_KEY = None  # type: List[int]
        self.NONCE_START = None  # type: List[int]
        self.RECIPIENT_KEY_ID = None  # type: List[int]
        self.CONTEXT = None  # type: str
        self.SCHEMA_HASH = None  # type: List[int]
        self.ROOT_TYPE = None  # type: str
        self.TIMESTAMP = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        ENC = ENC()
        ENC.Init(buf, pos)
        return cls.InitFromObj(ENC)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, ENC):
        x = ENCT()
        x._UnPack(ENC)
        return x

    # ENCT
    def _UnPack(self, ENC):
        if ENC is None:
            return
        self.VERSION = ENC.VERSION()
        self.KEY_EXCHANGE = ENC.KEY_EXCHANGE()
        self.SYMMETRIC = ENC.SYMMETRIC()
        self.KEY_DERIVATION = ENC.KEY_DERIVATION()
        if not ENC.EPHEMERAL_PUBLIC_KEYIsNone():
            if np is None:
                self.EPHEMERAL_PUBLIC_KEY = []
                for i in range(ENC.EPHEMERAL_PUBLIC_KEYLength()):
                    self.EPHEMERAL_PUBLIC_KEY.append(ENC.EPHEMERAL_PUBLIC_KEY(i))
            else:
                self.EPHEMERAL_PUBLIC_KEY = ENC.EPHEMERAL_PUBLIC_KEYAsNumpy()
        if not ENC.NONCE_STARTIsNone():
            if np is None:
                self.NONCE_START = []
                for i in range(ENC.NONCE_STARTLength()):
                    self.NONCE_START.append(ENC.NONCE_START(i))
            else:
                self.NONCE_START = ENC.NONCE_STARTAsNumpy()
        if not ENC.RECIPIENT_KEY_IDIsNone():
            if np is None:
                self.RECIPIENT_KEY_ID = []
                for i in range(ENC.RECIPIENT_KEY_IDLength()):
                    self.RECIPIENT_KEY_ID.append(ENC.RECIPIENT_KEY_ID(i))
            else:
                self.RECIPIENT_KEY_ID = ENC.RECIPIENT_KEY_IDAsNumpy()
        self.CONTEXT = ENC.CONTEXT()
        if not ENC.SCHEMA_HASHIsNone():
            if np is None:
                self.SCHEMA_HASH = []
                for i in range(ENC.SCHEMA_HASHLength()):
                    self.SCHEMA_HASH.append(ENC.SCHEMA_HASH(i))
            else:
                self.SCHEMA_HASH = ENC.SCHEMA_HASHAsNumpy()
        self.ROOT_TYPE = ENC.ROOT_TYPE()
        self.TIMESTAMP = ENC.TIMESTAMP()

    # ENCT
    def Pack(self, builder):
        if self.EPHEMERAL_PUBLIC_KEY is not None:
            if np is not None and type(self.EPHEMERAL_PUBLIC_KEY) is np.ndarray:
                EPHEMERAL_PUBLIC_KEY = builder.CreateNumpyVector(self.EPHEMERAL_PUBLIC_KEY)
            else:
                ENCStartEPHEMERAL_PUBLIC_KEYVector(builder, len(self.EPHEMERAL_PUBLIC_KEY))
                for i in reversed(range(len(self.EPHEMERAL_PUBLIC_KEY))):
                    builder.PrependUint8(self.EPHEMERAL_PUBLIC_KEY[i])
                EPHEMERAL_PUBLIC_KEY = builder.EndVector()
        if self.NONCE_START is not None:
            if np is not None and type(self.NONCE_START) is np.ndarray:
                NONCE_START = builder.CreateNumpyVector(self.NONCE_START)
            else:
                ENCStartNONCE_STARTVector(builder, len(self.NONCE_START))
                for i in reversed(range(len(self.NONCE_START))):
                    builder.PrependUint8(self.NONCE_START[i])
                NONCE_START = builder.EndVector()
        if self.RECIPIENT_KEY_ID is not None:
            if np is not None and type(self.RECIPIENT_KEY_ID) is np.ndarray:
                RECIPIENT_KEY_ID = builder.CreateNumpyVector(self.RECIPIENT_KEY_ID)
            else:
                ENCStartRECIPIENT_KEY_IDVector(builder, len(self.RECIPIENT_KEY_ID))
                for i in reversed(range(len(self.RECIPIENT_KEY_ID))):
                    builder.PrependUint8(self.RECIPIENT_KEY_ID[i])
                RECIPIENT_KEY_ID = builder.EndVector()
        if self.CONTEXT is not None:
            CONTEXT = builder.CreateString(self.CONTEXT)
        if self.SCHEMA_HASH is not None:
            if np is not None and type(self.SCHEMA_HASH) is np.ndarray:
                SCHEMA_HASH = builder.CreateNumpyVector(self.SCHEMA_HASH)
            else:
                ENCStartSCHEMA_HASHVector(builder, len(self.SCHEMA_HASH))
                for i in reversed(range(len(self.SCHEMA_HASH))):
                    builder.PrependUint8(self.SCHEMA_HASH[i])
                SCHEMA_HASH = builder.EndVector()
        if self.ROOT_TYPE is not None:
            ROOT_TYPE = builder.CreateString(self.ROOT_TYPE)
        ENCStart(builder)
        ENCAddVERSION(builder, self.VERSION)
        ENCAddKEY_EXCHANGE(builder, self.KEY_EXCHANGE)
        ENCAddSYMMETRIC(builder, self.SYMMETRIC)
        ENCAddKEY_DERIVATION(builder, self.KEY_DERIVATION)
        if self.EPHEMERAL_PUBLIC_KEY is not None:
            ENCAddEPHEMERAL_PUBLIC_KEY(builder, EPHEMERAL_PUBLIC_KEY)
        if self.NONCE_START is not None:
            ENCAddNONCE_START(builder, NONCE_START)
        if self.RECIPIENT_KEY_ID is not None:
            ENCAddRECIPIENT_KEY_ID(builder, RECIPIENT_KEY_ID)
        if self.CONTEXT is not None:
            ENCAddCONTEXT(builder, CONTEXT)
        if self.SCHEMA_HASH is not None:
            ENCAddSCHEMA_HASH(builder, SCHEMA_HASH)
        if self.ROOT_TYPE is not None:
            ENCAddROOT_TYPE(builder, ROOT_TYPE)
        ENCAddTIMESTAMP(builder, self.TIMESTAMP)
        ENC = ENCEnd(builder)
        return ENC
