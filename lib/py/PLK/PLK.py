# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Plugin License Key - Issued license for plugin access
# Uses ECIES: both parties derive symmetric key via X25519 ECDH
# Key derivation: X25519(private, peer_public) → HKDF-SHA256 → AES-256-GCM
class PLK(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = PLK()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsPLK(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def PLKBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x50\x4C\x4B", size_prefixed=size_prefixed)

    # PLK
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Unique license key identifier
    # PLK
    def LICENSE_ID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Plugin ID this license is for
    # PLK
    def PLUGIN_ID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Plugin version or version range (semver)
    # PLK
    def PLUGIN_VERSION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Licensee organization name
    # PLK
    def LICENSEE_ORG(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Licensee contact email
    # PLK
    def LICENSEE_EMAIL(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Licensee's SDN Peer ID
    # PLK
    def LICENSEE_PEER_ID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Licensee's X25519 public key (32 bytes)
    # PLK
    def LICENSEE_PUBKEY(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # PLK
    def LICENSEE_PUBKEYAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # PLK
    def LICENSEE_PUBKEYLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # PLK
    def LICENSEE_PUBKEYIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Issuer's X25519 public key (32 bytes)
    # Used with licensee's private key to derive shared secret via ECDH
    # PLK
    def ISSUER_PUBKEY(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # PLK
    def ISSUER_PUBKEYAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # PLK
    def ISSUER_PUBKEYLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # PLK
    def ISSUER_PUBKEYIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # Domain restrictions (empty = any domain allowed)
    # PLK
    def ALLOWED_DOMAINS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # PLK
    def ALLOWED_DOMAINSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # PLK
    def ALLOWED_DOMAINSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

    # TLD restrictions (e.g., ".gov", ".mil", ".edu")
    # PLK
    def ALLOWED_TLDS(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # PLK
    def ALLOWED_TLDSLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # PLK
    def ALLOWED_TLDSIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        return o == 0

    # Type of license
    # PLK
    def LICENSE_TYPE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Maximum concurrent activations (0 = unlimited)
    # PLK
    def MAX_ACTIVATIONS(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # Unix timestamp when license was issued
    # PLK
    def ISSUED_AT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # Unix timestamp when license becomes valid
    # PLK
    def VALID_FROM(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # Unix timestamp when license expires (0 = never expires)
    # PLK
    def EXPIRES_AT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # Peer ID of the license issuer (OrbPro)
    # PLK
    def ISSUER_PEER_ID(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Ed25519 signature from issuer over all fields (except SIGNATURE)
    # PLK
    def SIGNATURE(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # PLK
    def SIGNATUREAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # PLK
    def SIGNATURELength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # PLK
    def SIGNATUREIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        return o == 0

def PLKStart(builder):
    builder.StartObject(17)

def Start(builder):
    PLKStart(builder)

def PLKAddLICENSE_ID(builder, LICENSE_ID):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(LICENSE_ID), 0)

def AddLICENSE_ID(builder, LICENSE_ID):
    PLKAddLICENSE_ID(builder, LICENSE_ID)

def PLKAddPLUGIN_ID(builder, PLUGIN_ID):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(PLUGIN_ID), 0)

def AddPLUGIN_ID(builder, PLUGIN_ID):
    PLKAddPLUGIN_ID(builder, PLUGIN_ID)

def PLKAddPLUGIN_VERSION(builder, PLUGIN_VERSION):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(PLUGIN_VERSION), 0)

def AddPLUGIN_VERSION(builder, PLUGIN_VERSION):
    PLKAddPLUGIN_VERSION(builder, PLUGIN_VERSION)

def PLKAddLICENSEE_ORG(builder, LICENSEE_ORG):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(LICENSEE_ORG), 0)

def AddLICENSEE_ORG(builder, LICENSEE_ORG):
    PLKAddLICENSEE_ORG(builder, LICENSEE_ORG)

def PLKAddLICENSEE_EMAIL(builder, LICENSEE_EMAIL):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(LICENSEE_EMAIL), 0)

def AddLICENSEE_EMAIL(builder, LICENSEE_EMAIL):
    PLKAddLICENSEE_EMAIL(builder, LICENSEE_EMAIL)

def PLKAddLICENSEE_PEER_ID(builder, LICENSEE_PEER_ID):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(LICENSEE_PEER_ID), 0)

def AddLICENSEE_PEER_ID(builder, LICENSEE_PEER_ID):
    PLKAddLICENSEE_PEER_ID(builder, LICENSEE_PEER_ID)

def PLKAddLICENSEE_PUBKEY(builder, LICENSEE_PUBKEY):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(LICENSEE_PUBKEY), 0)

def AddLICENSEE_PUBKEY(builder, LICENSEE_PUBKEY):
    PLKAddLICENSEE_PUBKEY(builder, LICENSEE_PUBKEY)

def PLKStartLICENSEE_PUBKEYVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartLICENSEE_PUBKEYVector(builder, numElems):
    return PLKStartLICENSEE_PUBKEYVector(builder, numElems)

def PLKAddISSUER_PUBKEY(builder, ISSUER_PUBKEY):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(ISSUER_PUBKEY), 0)

def AddISSUER_PUBKEY(builder, ISSUER_PUBKEY):
    PLKAddISSUER_PUBKEY(builder, ISSUER_PUBKEY)

def PLKStartISSUER_PUBKEYVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartISSUER_PUBKEYVector(builder, numElems):
    return PLKStartISSUER_PUBKEYVector(builder, numElems)

def PLKAddALLOWED_DOMAINS(builder, ALLOWED_DOMAINS):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(ALLOWED_DOMAINS), 0)

def AddALLOWED_DOMAINS(builder, ALLOWED_DOMAINS):
    PLKAddALLOWED_DOMAINS(builder, ALLOWED_DOMAINS)

def PLKStartALLOWED_DOMAINSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartALLOWED_DOMAINSVector(builder, numElems):
    return PLKStartALLOWED_DOMAINSVector(builder, numElems)

def PLKAddALLOWED_TLDS(builder, ALLOWED_TLDS):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(ALLOWED_TLDS), 0)

def AddALLOWED_TLDS(builder, ALLOWED_TLDS):
    PLKAddALLOWED_TLDS(builder, ALLOWED_TLDS)

def PLKStartALLOWED_TLDSVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartALLOWED_TLDSVector(builder, numElems):
    return PLKStartALLOWED_TLDSVector(builder, numElems)

def PLKAddLICENSE_TYPE(builder, LICENSE_TYPE):
    builder.PrependInt8Slot(10, LICENSE_TYPE, 0)

def AddLICENSE_TYPE(builder, LICENSE_TYPE):
    PLKAddLICENSE_TYPE(builder, LICENSE_TYPE)

def PLKAddMAX_ACTIVATIONS(builder, MAX_ACTIVATIONS):
    builder.PrependUint32Slot(11, MAX_ACTIVATIONS, 0)

def AddMAX_ACTIVATIONS(builder, MAX_ACTIVATIONS):
    PLKAddMAX_ACTIVATIONS(builder, MAX_ACTIVATIONS)

def PLKAddISSUED_AT(builder, ISSUED_AT):
    builder.PrependUint64Slot(12, ISSUED_AT, 0)

def AddISSUED_AT(builder, ISSUED_AT):
    PLKAddISSUED_AT(builder, ISSUED_AT)

def PLKAddVALID_FROM(builder, VALID_FROM):
    builder.PrependUint64Slot(13, VALID_FROM, 0)

def AddVALID_FROM(builder, VALID_FROM):
    PLKAddVALID_FROM(builder, VALID_FROM)

def PLKAddEXPIRES_AT(builder, EXPIRES_AT):
    builder.PrependUint64Slot(14, EXPIRES_AT, 0)

def AddEXPIRES_AT(builder, EXPIRES_AT):
    PLKAddEXPIRES_AT(builder, EXPIRES_AT)

def PLKAddISSUER_PEER_ID(builder, ISSUER_PEER_ID):
    builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(ISSUER_PEER_ID), 0)

def AddISSUER_PEER_ID(builder, ISSUER_PEER_ID):
    PLKAddISSUER_PEER_ID(builder, ISSUER_PEER_ID)

def PLKAddSIGNATURE(builder, SIGNATURE):
    builder.PrependUOffsetTRelativeSlot(16, flatbuffers.number_types.UOffsetTFlags.py_type(SIGNATURE), 0)

def AddSIGNATURE(builder, SIGNATURE):
    PLKAddSIGNATURE(builder, SIGNATURE)

def PLKStartSIGNATUREVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartSIGNATUREVector(builder, numElems):
    return PLKStartSIGNATUREVector(builder, numElems)

def PLKEnd(builder):
    return builder.EndObject()

def End(builder):
    return PLKEnd(builder)

try:
    from typing import List
except:
    pass

class PLKT(object):

    # PLKT
    def __init__(self):
        self.LICENSE_ID = None  # type: str
        self.PLUGIN_ID = None  # type: str
        self.PLUGIN_VERSION = None  # type: str
        self.LICENSEE_ORG = None  # type: str
        self.LICENSEE_EMAIL = None  # type: str
        self.LICENSEE_PEER_ID = None  # type: str
        self.LICENSEE_PUBKEY = None  # type: List[int]
        self.ISSUER_PUBKEY = None  # type: List[int]
        self.ALLOWED_DOMAINS = None  # type: List[str]
        self.ALLOWED_TLDS = None  # type: List[str]
        self.LICENSE_TYPE = 0  # type: int
        self.MAX_ACTIVATIONS = 0  # type: int
        self.ISSUED_AT = 0  # type: int
        self.VALID_FROM = 0  # type: int
        self.EXPIRES_AT = 0  # type: int
        self.ISSUER_PEER_ID = None  # type: str
        self.SIGNATURE = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        PLK = PLK()
        PLK.Init(buf, pos)
        return cls.InitFromObj(PLK)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, PLK):
        x = PLKT()
        x._UnPack(PLK)
        return x

    # PLKT
    def _UnPack(self, PLK):
        if PLK is None:
            return
        self.LICENSE_ID = PLK.LICENSE_ID()
        self.PLUGIN_ID = PLK.PLUGIN_ID()
        self.PLUGIN_VERSION = PLK.PLUGIN_VERSION()
        self.LICENSEE_ORG = PLK.LICENSEE_ORG()
        self.LICENSEE_EMAIL = PLK.LICENSEE_EMAIL()
        self.LICENSEE_PEER_ID = PLK.LICENSEE_PEER_ID()
        if not PLK.LICENSEE_PUBKEYIsNone():
            if np is None:
                self.LICENSEE_PUBKEY = []
                for i in range(PLK.LICENSEE_PUBKEYLength()):
                    self.LICENSEE_PUBKEY.append(PLK.LICENSEE_PUBKEY(i))
            else:
                self.LICENSEE_PUBKEY = PLK.LICENSEE_PUBKEYAsNumpy()
        if not PLK.ISSUER_PUBKEYIsNone():
            if np is None:
                self.ISSUER_PUBKEY = []
                for i in range(PLK.ISSUER_PUBKEYLength()):
                    self.ISSUER_PUBKEY.append(PLK.ISSUER_PUBKEY(i))
            else:
                self.ISSUER_PUBKEY = PLK.ISSUER_PUBKEYAsNumpy()
        if not PLK.ALLOWED_DOMAINSIsNone():
            self.ALLOWED_DOMAINS = []
            for i in range(PLK.ALLOWED_DOMAINSLength()):
                self.ALLOWED_DOMAINS.append(PLK.ALLOWED_DOMAINS(i))
        if not PLK.ALLOWED_TLDSIsNone():
            self.ALLOWED_TLDS = []
            for i in range(PLK.ALLOWED_TLDSLength()):
                self.ALLOWED_TLDS.append(PLK.ALLOWED_TLDS(i))
        self.LICENSE_TYPE = PLK.LICENSE_TYPE()
        self.MAX_ACTIVATIONS = PLK.MAX_ACTIVATIONS()
        self.ISSUED_AT = PLK.ISSUED_AT()
        self.VALID_FROM = PLK.VALID_FROM()
        self.EXPIRES_AT = PLK.EXPIRES_AT()
        self.ISSUER_PEER_ID = PLK.ISSUER_PEER_ID()
        if not PLK.SIGNATUREIsNone():
            if np is None:
                self.SIGNATURE = []
                for i in range(PLK.SIGNATURELength()):
                    self.SIGNATURE.append(PLK.SIGNATURE(i))
            else:
                self.SIGNATURE = PLK.SIGNATUREAsNumpy()

    # PLKT
    def Pack(self, builder):
        if self.LICENSE_ID is not None:
            LICENSE_ID = builder.CreateString(self.LICENSE_ID)
        if self.PLUGIN_ID is not None:
            PLUGIN_ID = builder.CreateString(self.PLUGIN_ID)
        if self.PLUGIN_VERSION is not None:
            PLUGIN_VERSION = builder.CreateString(self.PLUGIN_VERSION)
        if self.LICENSEE_ORG is not None:
            LICENSEE_ORG = builder.CreateString(self.LICENSEE_ORG)
        if self.LICENSEE_EMAIL is not None:
            LICENSEE_EMAIL = builder.CreateString(self.LICENSEE_EMAIL)
        if self.LICENSEE_PEER_ID is not None:
            LICENSEE_PEER_ID = builder.CreateString(self.LICENSEE_PEER_ID)
        if self.LICENSEE_PUBKEY is not None:
            if np is not None and type(self.LICENSEE_PUBKEY) is np.ndarray:
                LICENSEE_PUBKEY = builder.CreateNumpyVector(self.LICENSEE_PUBKEY)
            else:
                PLKStartLICENSEE_PUBKEYVector(builder, len(self.LICENSEE_PUBKEY))
                for i in reversed(range(len(self.LICENSEE_PUBKEY))):
                    builder.PrependUint8(self.LICENSEE_PUBKEY[i])
                LICENSEE_PUBKEY = builder.EndVector()
        if self.ISSUER_PUBKEY is not None:
            if np is not None and type(self.ISSUER_PUBKEY) is np.ndarray:
                ISSUER_PUBKEY = builder.CreateNumpyVector(self.ISSUER_PUBKEY)
            else:
                PLKStartISSUER_PUBKEYVector(builder, len(self.ISSUER_PUBKEY))
                for i in reversed(range(len(self.ISSUER_PUBKEY))):
                    builder.PrependUint8(self.ISSUER_PUBKEY[i])
                ISSUER_PUBKEY = builder.EndVector()
        if self.ALLOWED_DOMAINS is not None:
            ALLOWED_DOMAINSlist = []
            for i in range(len(self.ALLOWED_DOMAINS)):
                ALLOWED_DOMAINSlist.append(builder.CreateString(self.ALLOWED_DOMAINS[i]))
            PLKStartALLOWED_DOMAINSVector(builder, len(self.ALLOWED_DOMAINS))
            for i in reversed(range(len(self.ALLOWED_DOMAINS))):
                builder.PrependUOffsetTRelative(ALLOWED_DOMAINSlist[i])
            ALLOWED_DOMAINS = builder.EndVector()
        if self.ALLOWED_TLDS is not None:
            ALLOWED_TLDSlist = []
            for i in range(len(self.ALLOWED_TLDS)):
                ALLOWED_TLDSlist.append(builder.CreateString(self.ALLOWED_TLDS[i]))
            PLKStartALLOWED_TLDSVector(builder, len(self.ALLOWED_TLDS))
            for i in reversed(range(len(self.ALLOWED_TLDS))):
                builder.PrependUOffsetTRelative(ALLOWED_TLDSlist[i])
            ALLOWED_TLDS = builder.EndVector()
        if self.ISSUER_PEER_ID is not None:
            ISSUER_PEER_ID = builder.CreateString(self.ISSUER_PEER_ID)
        if self.SIGNATURE is not None:
            if np is not None and type(self.SIGNATURE) is np.ndarray:
                SIGNATURE = builder.CreateNumpyVector(self.SIGNATURE)
            else:
                PLKStartSIGNATUREVector(builder, len(self.SIGNATURE))
                for i in reversed(range(len(self.SIGNATURE))):
                    builder.PrependUint8(self.SIGNATURE[i])
                SIGNATURE = builder.EndVector()
        PLKStart(builder)
        if self.LICENSE_ID is not None:
            PLKAddLICENSE_ID(builder, LICENSE_ID)
        if self.PLUGIN_ID is not None:
            PLKAddPLUGIN_ID(builder, PLUGIN_ID)
        if self.PLUGIN_VERSION is not None:
            PLKAddPLUGIN_VERSION(builder, PLUGIN_VERSION)
        if self.LICENSEE_ORG is not None:
            PLKAddLICENSEE_ORG(builder, LICENSEE_ORG)
        if self.LICENSEE_EMAIL is not None:
            PLKAddLICENSEE_EMAIL(builder, LICENSEE_EMAIL)
        if self.LICENSEE_PEER_ID is not None:
            PLKAddLICENSEE_PEER_ID(builder, LICENSEE_PEER_ID)
        if self.LICENSEE_PUBKEY is not None:
            PLKAddLICENSEE_PUBKEY(builder, LICENSEE_PUBKEY)
        if self.ISSUER_PUBKEY is not None:
            PLKAddISSUER_PUBKEY(builder, ISSUER_PUBKEY)
        if self.ALLOWED_DOMAINS is not None:
            PLKAddALLOWED_DOMAINS(builder, ALLOWED_DOMAINS)
        if self.ALLOWED_TLDS is not None:
            PLKAddALLOWED_TLDS(builder, ALLOWED_TLDS)
        PLKAddLICENSE_TYPE(builder, self.LICENSE_TYPE)
        PLKAddMAX_ACTIVATIONS(builder, self.MAX_ACTIVATIONS)
        PLKAddISSUED_AT(builder, self.ISSUED_AT)
        PLKAddVALID_FROM(builder, self.VALID_FROM)
        PLKAddEXPIRES_AT(builder, self.EXPIRES_AT)
        if self.ISSUER_PEER_ID is not None:
            PLKAddISSUER_PEER_ID(builder, ISSUER_PEER_ID)
        if self.SIGNATURE is not None:
            PLKAddSIGNATURE(builder, SIGNATURE)
        PLK = PLKEnd(builder)
        return PLK
