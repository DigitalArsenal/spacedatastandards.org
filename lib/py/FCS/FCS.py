# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Fire Control Systems
class FCS(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = FCS()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFCS(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def FCSBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x24\x46\x43\x53", size_prefixed=size_prefixed)

    # FCS
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # FCS
    def MODE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # FCS
    def LEAD_METHOD(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # FCS
    def RANGEFINDER_TYPE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # FCS
    def AMMO_SELECTED(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # FCS
    def TARGET(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # FCS
    def SOLUTION(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # FCS
    def LAST_RANGE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # FCS
    def RANGE_RATE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # FCS
    def ROUNDS_REMAINING(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
        return 0

    # FCS
    def TEMPERATURE(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # FCS
    def RESERVED(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # FCS
    def RESERVEDAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # FCS
    def RESERVEDLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # FCS
    def RESERVEDIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return o == 0

def FCSStart(builder):
    builder.StartObject(11)

def Start(builder):
    FCSStart(builder)

def FCSAddMODE(builder, MODE):
    builder.PrependUint8Slot(0, MODE, 0)

def AddMODE(builder, MODE):
    FCSAddMODE(builder, MODE)

def FCSAddLEAD_METHOD(builder, LEAD_METHOD):
    builder.PrependUint8Slot(1, LEAD_METHOD, 0)

def AddLEAD_METHOD(builder, LEAD_METHOD):
    FCSAddLEAD_METHOD(builder, LEAD_METHOD)

def FCSAddRANGEFINDER_TYPE(builder, RANGEFINDER_TYPE):
    builder.PrependUint8Slot(2, RANGEFINDER_TYPE, 0)

def AddRANGEFINDER_TYPE(builder, RANGEFINDER_TYPE):
    FCSAddRANGEFINDER_TYPE(builder, RANGEFINDER_TYPE)

def FCSAddAMMO_SELECTED(builder, AMMO_SELECTED):
    builder.PrependUint8Slot(3, AMMO_SELECTED, 0)

def AddAMMO_SELECTED(builder, AMMO_SELECTED):
    FCSAddAMMO_SELECTED(builder, AMMO_SELECTED)

def FCSAddTARGET(builder, TARGET):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(TARGET), 0)

def AddTARGET(builder, TARGET):
    FCSAddTARGET(builder, TARGET)

def FCSAddSOLUTION(builder, SOLUTION):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(SOLUTION), 0)

def AddSOLUTION(builder, SOLUTION):
    FCSAddSOLUTION(builder, SOLUTION)

def FCSAddLAST_RANGE(builder, LAST_RANGE):
    builder.PrependFloat64Slot(6, LAST_RANGE, 0.0)

def AddLAST_RANGE(builder, LAST_RANGE):
    FCSAddLAST_RANGE(builder, LAST_RANGE)

def FCSAddRANGE_RATE(builder, RANGE_RATE):
    builder.PrependFloat64Slot(7, RANGE_RATE, 0.0)

def AddRANGE_RATE(builder, RANGE_RATE):
    FCSAddRANGE_RATE(builder, RANGE_RATE)

def FCSAddROUNDS_REMAINING(builder, ROUNDS_REMAINING):
    builder.PrependUint16Slot(8, ROUNDS_REMAINING, 0)

def AddROUNDS_REMAINING(builder, ROUNDS_REMAINING):
    FCSAddROUNDS_REMAINING(builder, ROUNDS_REMAINING)

def FCSAddTEMPERATURE(builder, TEMPERATURE):
    builder.PrependFloat32Slot(9, TEMPERATURE, 0.0)

def AddTEMPERATURE(builder, TEMPERATURE):
    FCSAddTEMPERATURE(builder, TEMPERATURE)

def FCSAddRESERVED(builder, RESERVED):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(RESERVED), 0)

def AddRESERVED(builder, RESERVED):
    FCSAddRESERVED(builder, RESERVED)

def FCSStartRESERVEDVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def StartRESERVEDVector(builder, numElems):
    return FCSStartRESERVEDVector(builder, numElems)

def FCSEnd(builder):
    return builder.EndObject()

def End(builder):
    return FCSEnd(builder)

try:
    from typing import List
except:
    pass

class FCST(object):

    # FCST
    def __init__(self):
        self.MODE = 0  # type: int
        self.LEAD_METHOD = 0  # type: int
        self.RANGEFINDER_TYPE = 0  # type: int
        self.AMMO_SELECTED = 0  # type: int
        self.TARGET = None  # type: str
        self.SOLUTION = None  # type: str
        self.LAST_RANGE = 0.0  # type: float
        self.RANGE_RATE = 0.0  # type: float
        self.ROUNDS_REMAINING = 0  # type: int
        self.TEMPERATURE = 0.0  # type: float
        self.RESERVED = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        FCS = FCS()
        FCS.Init(buf, pos)
        return cls.InitFromObj(FCS)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, FCS):
        x = FCST()
        x._UnPack(FCS)
        return x

    # FCST
    def _UnPack(self, FCS):
        if FCS is None:
            return
        self.MODE = FCS.MODE()
        self.LEAD_METHOD = FCS.LEAD_METHOD()
        self.RANGEFINDER_TYPE = FCS.RANGEFINDER_TYPE()
        self.AMMO_SELECTED = FCS.AMMO_SELECTED()
        self.TARGET = FCS.TARGET()
        self.SOLUTION = FCS.SOLUTION()
        self.LAST_RANGE = FCS.LAST_RANGE()
        self.RANGE_RATE = FCS.RANGE_RATE()
        self.ROUNDS_REMAINING = FCS.ROUNDS_REMAINING()
        self.TEMPERATURE = FCS.TEMPERATURE()
        if not FCS.RESERVEDIsNone():
            if np is None:
                self.RESERVED = []
                for i in range(FCS.RESERVEDLength()):
                    self.RESERVED.append(FCS.RESERVED(i))
            else:
                self.RESERVED = FCS.RESERVEDAsNumpy()

    # FCST
    def Pack(self, builder):
        if self.TARGET is not None:
            TARGET = builder.CreateString(self.TARGET)
        if self.SOLUTION is not None:
            SOLUTION = builder.CreateString(self.SOLUTION)
        if self.RESERVED is not None:
            if np is not None and type(self.RESERVED) is np.ndarray:
                RESERVED = builder.CreateNumpyVector(self.RESERVED)
            else:
                FCSStartRESERVEDVector(builder, len(self.RESERVED))
                for i in reversed(range(len(self.RESERVED))):
                    builder.PrependUint8(self.RESERVED[i])
                RESERVED = builder.EndVector()
        FCSStart(builder)
        FCSAddMODE(builder, self.MODE)
        FCSAddLEAD_METHOD(builder, self.LEAD_METHOD)
        FCSAddRANGEFINDER_TYPE(builder, self.RANGEFINDER_TYPE)
        FCSAddAMMO_SELECTED(builder, self.AMMO_SELECTED)
        if self.TARGET is not None:
            FCSAddTARGET(builder, TARGET)
        if self.SOLUTION is not None:
            FCSAddSOLUTION(builder, SOLUTION)
        FCSAddLAST_RANGE(builder, self.LAST_RANGE)
        FCSAddRANGE_RATE(builder, self.RANGE_RATE)
        FCSAddROUNDS_REMAINING(builder, self.ROUNDS_REMAINING)
        FCSAddTEMPERATURE(builder, self.TEMPERATURE)
        if self.RESERVED is not None:
            FCSAddRESERVED(builder, RESERVED)
        FCS = FCSEnd(builder)
        return FCS
