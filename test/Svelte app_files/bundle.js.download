
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.head.appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function to_number(value) {
        return value === '' ? undefined : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        if (value != null || input.value) {
            input.value = value;
        }
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined' ? window : global);

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if ($$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.20.1' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    let _onload = [];
    const onLoad = (f) => _onload.indexOf(f) === -1 ? _onload.push(f) : null;
    globalThis.onload = (...args) => {
        _onload.map(f => f.apply(globalThis, args));
    };

    var background = "<h2>\n  Background\n</h2>\n<p>\n  The\n  <a href='https://public.ccsds.org/default.aspx'>\n    Consultative Committee for Space Data Systems (CCSDS)\n  </a>\n  '...is a multi-national forum for the development of communications and\n  data systems standards for spaceflight'.\n</p>\n<p>\n  Founded in 1982, CCSDS has been publishing\n  <a href='https://public.ccsds.org/Publications/BlueBooks.aspx'>\n    Recommended Standards (called 'Blue Books')\n  </a>\n  to help standardize space messaging formats.\n</p>\n<p>\n  In 2010, CCSDS published an\n  <a href='https://public.ccsds.org/Pubs/505x0b1.pdf'>\n    XML SPECIFICATION FOR NAVIGATION DATA MESSAGES\n  </a>\n  to aid developers in creating web services based on CCSDS standards, using\n  <a href='https://en.wikipedia.org/wiki/XML'>eXtensible Markup Language</a>\n  as the\n  <a href='https://en.wikipedia.org/wiki/Serialization'>\n    serialization format\n  </a>\n  , which is a format that allows transferring data between computers.\n</p>\n<p>\n  To transfer messages networks, the data is converted in a text-based\n  format using tags which look like\n  <a href='https://developer.mozilla.org/en-US/docs/Web/HTML'>\n    HyperText Markup Language (HTML)\n  </a>\n  , the basic format of the world wide web.\n</p>\n<p>\n  However, XML is\n  <a href='https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats'>\n    not the only way\n  </a>\n  to transmit messages between computers. Most modern systems use other\n  formats that consume less bandwidth, less memory, and require less\n  computational resources to use inside applications. Some do not even\n  require a conversion step and can write the messages directly into memory!\n  Here are some examples:\n</p>\n<div>\n  <ul>\n    <li>\n      <a href='https://tools.ietf.org/html/rfc8259' rel='nofollow'>\n        JavaScript Object Notation (JSON)\n      </a>\n    </li>\n    <li>\n      <a href='https://tools.ietf.org/html/rfc4180' rel='nofollow'>\n        Comma Seperated Values (CSV)\n      </a>\n    </li>\n    <li>\n      <a href='http://bsonspec.org/spec.html' rel='nofollow'>\n        Binary JSON (BSON)\n      </a>\n    </li>\n    <li>\n      <a href='https://google.github.io/flatbuffers/' rel='nofollow'>\n        Google Flatbuffers\n      </a>\n    </li>\n    <li>\n      <a href='https://avro.apache.org/docs/current/' rel='nofollow'>\n        Apache Avro\n      </a>\n    </li>\n  </ul>\n</div>\n<p>\n  The goal of this site is to add additional formatting options for CCSDS\n  messages, as well as aid developers by generating code for use in\n  applications. \n</p>\n<p>\n  For more information contact me at\n  <a href='mailto:tj@digitalarsenal.io'>tj@digitalarsenal.io</a>\n  , or\n  <a href='https://github.com/DigitalArsenal/spacedatastandards.org/issues'>\n    open an issue\n  </a>\n  on this repository.\n</p>";

    /* src/components/Main/Main.svelte generated by Svelte v3.20.1 */
    const file = "src/components/Main/Main.svelte";

    function add_css() {
    	var style = element("style");
    	style.id = "svelte-1749ifc-style";
    	style.textContent = "#backgroundContainer.svelte-1749ifc.svelte-1749ifc{height:calc(100vh - var(--header-height));padding-bottom:100px;overflow-y:scroll}#backgroundContainer.svelte-1749ifc div.svelte-1749ifc{font-family:-apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial,\n      sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\";padding:10px;font-weight:500;font-size:16px;max-width:1024px;margin:auto}#backgroundContainer h2{border-bottom-color:rgb(234, 236, 239);border-bottom-style:solid;border-bottom-width:0.993304px;box-sizing:border-box;padding-bottom:5px;font-weight:200;font-size:calc((1.7rem + 0.5 * ((100vw - 50rem) / 120)));margin:5px}h1.svelte-1749ifc.svelte-1749ifc{margin:auto;font-size:calc((2rem + 0.5 * ((100vw - 50rem) / 120)));width:fit-content;padding:10px;font-weight:300}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFpbi5zdmVsdGUiLCJzb3VyY2VzIjpbIk1haW4uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGltcG9ydCBiYWNrZ3JvdW5kIGZyb20gXCIuL2JhY2tncm91bmQuaHRtbC50eHRcIjtcblxuICBleHBvcnQgbGV0IGxvYWRlZDtcbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgbG9hZGVkID0gdHJ1ZTtcbiAgfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAjYmFja2dyb3VuZENvbnRhaW5lciB7XG4gICAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gdmFyKC0taGVhZGVyLWhlaWdodCkpO1xuICAgICAgLyogU3RhdHVzIGJhciBoZWlnaHQgb24gaU9TIDEwICovXG4gICAgcGFkZGluZy1ib3R0b206IDEwMHB4O1xuICAgIC8qIFN0YXR1cyBiYXIgaGVpZ2h0IG9uIGlPUyAxMS4wIFxuICAgIHBhZGRpbmctYm90dG9tOiBjb25zdGFudChzYWZlLWFyZWEtaW5zZXQtdG9wKTtcbiAgICAvKiBTdGF0dXMgYmFyIGhlaWdodCBvbiBpT1MgMTErIFxuICAgIHBhZGRpbmctYm90dG9tOiBlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCk7Ki9cbiAgICBvdmVyZmxvdy15OiBzY3JvbGw7XG4gIH1cbiAgI2JhY2tncm91bmRDb250YWluZXIgZGl2IHtcbiAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcIlNlZ29lIFVJXCIsIEhlbHZldGljYSwgQXJpYWwsXG4gICAgICBzYW5zLXNlcmlmLCBcIkFwcGxlIENvbG9yIEVtb2ppXCIsIFwiU2Vnb2UgVUkgRW1vamlcIjtcbiAgICBwYWRkaW5nOiAxMHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIG1heC13aWR0aDogMTAyNHB4O1xuICAgIG1hcmdpbjogYXV0bztcbiAgfVxuICA6Z2xvYmFsKCNiYWNrZ3JvdW5kQ29udGFpbmVyIGgyKSB7XG4gICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogcmdiKDIzNCwgMjM2LCAyMzkpO1xuICAgIGJvcmRlci1ib3R0b20tc3R5bGU6IHNvbGlkO1xuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDAuOTkzMzA0cHg7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBwYWRkaW5nLWJvdHRvbTogNXB4O1xuICAgIGZvbnQtd2VpZ2h0OiAyMDA7XG4gICAgZm9udC1zaXplOiBjYWxjKCgxLjdyZW0gKyAwLjUgKiAoKDEwMHZ3IC0gNTByZW0pIC8gMTIwKSkpO1xuICAgIG1hcmdpbjo1cHg7XG4gIH1cbiAgaDEge1xuICAgIG1hcmdpbjogYXV0bztcbiAgICBmb250LXNpemU6IGNhbGMoKDJyZW0gKyAwLjUgKiAoKDEwMHZ3IC0gNTByZW0pIC8gMTIwKSkpO1xuICAgIHdpZHRoOiBmaXQtY29udGVudDtcbiAgICBwYWRkaW5nOiAxMHB4O1xuICAgIGZvbnQtd2VpZ2h0OiAzMDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXYgaWQ9XCJiYWNrZ3JvdW5kQ29udGFpbmVyXCI+XG5cbiAgPGgxPlNwYWNlIERhdGEgU3RhbmRhcmRzPC9oMT5cbiAgPGRpdj5cbiAgICB7QGh0bWwgYmFja2dyb3VuZH1cbiAgPC9kaXY+XG48L2Rpdj5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFXRSxvQkFBb0IsOEJBQUMsQ0FBQyxBQUNwQixNQUFNLENBQUUsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksZUFBZSxDQUFDLENBQUMsQ0FFMUMsY0FBYyxDQUFFLEtBQUssQ0FLckIsVUFBVSxDQUFFLE1BQU0sQUFDcEIsQ0FBQyxBQUNELG1DQUFvQixDQUFDLEdBQUcsZUFBQyxDQUFDLEFBQ3hCLFdBQVcsQ0FBRSxhQUFhLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQUssQ0FBQztNQUMzRSxVQUFVLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLGdCQUFnQixDQUNuRCxPQUFPLENBQUUsSUFBSSxDQUNiLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsU0FBUyxDQUFFLE1BQU0sQ0FDakIsTUFBTSxDQUFFLElBQUksQUFDZCxDQUFDLEFBQ08sdUJBQXVCLEFBQUUsQ0FBQyxBQUNoQyxtQkFBbUIsQ0FBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUN2QyxtQkFBbUIsQ0FBRSxLQUFLLENBQzFCLG1CQUFtQixDQUFFLFVBQVUsQ0FDL0IsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsY0FBYyxDQUFFLEdBQUcsQ0FDbkIsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsU0FBUyxDQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDekQsT0FBTyxHQUFHLEFBQ1osQ0FBQyxBQUNELEVBQUUsOEJBQUMsQ0FBQyxBQUNGLE1BQU0sQ0FBRSxJQUFJLENBQ1osU0FBUyxDQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDdkQsS0FBSyxDQUFFLFdBQVcsQ0FDbEIsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsR0FBRyxBQUNsQixDQUFDIn0= */";
    	append_dev(document.head, style);
    }

    function create_fragment(ctx) {
    	let div1;
    	let h1;
    	let t1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Space Data Standards";
    			t1 = space();
    			div0 = element("div");
    			attr_dev(h1, "class", "svelte-1749ifc");
    			add_location(h1, file, 51, 2, 1304);
    			attr_dev(div0, "class", "svelte-1749ifc");
    			add_location(div0, file, 52, 2, 1336);
    			attr_dev(div1, "id", "backgroundContainer");
    			attr_dev(div1, "class", "svelte-1749ifc");
    			add_location(div1, file, 49, 0, 1270);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h1);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			div0.innerHTML = background;
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { loaded } = $$props;

    	onMount(() => {
    		$$invalidate(0, loaded = true);
    	});

    	const writable_props = ["loaded"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Main> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Main", $$slots, []);

    	$$self.$set = $$props => {
    		if ("loaded" in $$props) $$invalidate(0, loaded = $$props.loaded);
    	};

    	$$self.$capture_state = () => ({ onMount, background, loaded });

    	$$self.$inject_state = $$props => {
    		if ("loaded" in $$props) $$invalidate(0, loaded = $$props.loaded);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loaded];
    }

    class Main extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		if (!document.getElementById("svelte-1749ifc-style")) add_css();
    		init(this, options, instance, create_fragment, safe_not_equal, { loaded: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Main",
    			options,
    			id: create_fragment.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*loaded*/ ctx[0] === undefined && !("loaded" in props)) {
    			console.warn("<Main> was created without expected prop 'loaded'");
    		}
    	}

    	get loaded() {
    		throw new Error("<Main>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaded(value) {
    		throw new Error("<Main>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    var root = "schemas";
    var files = [
    	{
    		filename: "/000x00000.fbs",
    		title: "PRE-PROPOSAL MESSAGES",
    		type: "Pre-Proposal: Non-CCSDS",
    		color: "#EEEEE"
    	},
    	{
    		filename: "/502x0b2c1.fbs",
    		title: "ORBIT DATA MESSAGES",
    		type: "Blue: Recommended Standards",
    		color: "#0066FF"
    	}
    ];
    var manifestFile = {
    	root: root,
    	files: files
    };

    let setItem = (key, value) => localStorage.setItem(key, JSON.stringify(value));
    let getItem = (key) => JSON.parse(localStorage.getItem(key));

    let _IDLDocument = getItem("IDLDocument");
    let _IDLEditorContents = getItem(_IDLDocument);
    let _TestEditorContents = getItem("TestEditorContents");

    let manifest = writable(manifestFile);
    let IDLDocument = writable(_IDLDocument || "");
    let IDLEditorContents = writable(_IDLEditorContents);
    let CodeEditorDocuments = writable({});
    let CodeEditorActiveDocument = writable("");
    let CodeEditorContents = writable("");
    let CodeEditorLanguage = writable([]);
    let TestEditorDocument = writable("Test.js");
    let TestEditorContents = writable(_TestEditorContents);
    let saveEventTime = writable(new Date());

    IDLDocument.subscribe((d) => {
      _IDLDocument = d;
      setItem("IDLDocument", d);
    });

    IDLEditorContents.subscribe((d) => {
      setItem(_IDLDocument, d);
    });

    TestEditorContents.subscribe((d) => {
      setItem("TestEditorContents", d);
    });

    // 'path' module extracted from Node.js v8.11.1 (only the posix part)

    function assertPath(path) {
      if (typeof path !== 'string') {
        throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
      }
    }

    // Resolves . and .. elements in a path with directory names
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = '';
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code = path.charCodeAt(i);
        else if (code === 47 /*/*/)
          break;
        else
          code = 47 /*/*/;
        if (code === 47 /*/*/) {
          if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf('/');
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = '';
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = '';
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += '/..';
              else
                res = '..';
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += '/' + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 /*.*/ && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }

    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }

    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = '';
        var resolvedAbsolute = false;
        var cwd;

        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd === undefined)
              cwd = process.cwd();
            path = cwd;
          }

          assertPath(path);

          // Skip empty entries
          if (path.length === 0) {
            continue;
          }

          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
        }

        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)

        // Normalize the path
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return '/' + resolvedPath;
          else
            return '/';
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return '.';
        }
      },

      normalize: function normalize(path) {
        assertPath(path);

        if (path.length === 0) return '.';

        var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

        // Normalize the path
        path = normalizeStringPosix(path, !isAbsolute);

        if (path.length === 0 && !isAbsolute) path = '.';
        if (path.length > 0 && trailingSeparator) path += '/';

        if (isAbsolute) return '/' + path;
        return path;
      },

      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
      },

      join: function join() {
        if (arguments.length === 0)
          return '.';
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === undefined)
              joined = arg;
            else
              joined += '/' + arg;
          }
        }
        if (joined === undefined)
          return '.';
        return posix.normalize(joined);
      },

      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);

        if (from === to) return '';

        from = posix.resolve(from);
        to = posix.resolve(to);

        if (from === to) return '';

        // Trim any leading backslashes
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47 /*/*/)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;

        // Trim any leading backslashes
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47 /*/*/)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;

        // Compare paths to find the longest common path from root
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47 /*/*/) {
                // We get here if `from` is the exact base path for `to`.
                // For example: from='/foo/bar'; to='/foo/bar/baz'
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                // We get here if `from` is the root
                // For example: from='/'; to='/foo'
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
                // We get here if `to` is the exact base path for `from`.
                // For example: from='/foo/bar/baz'; to='/foo/bar'
                lastCommonSep = i;
              } else if (i === 0) {
                // We get here if `to` is the root.
                // For example: from='/foo'; to='/'
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47 /*/*/)
            lastCommonSep = i;
        }

        var out = '';
        // Generate the relative path based on the path difference between `to`
        // and `from`
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
            if (out.length === 0)
              out += '..';
            else
              out += '/..';
          }
        }

        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47 /*/*/)
            ++toStart;
          return to.slice(toStart);
        }
      },

      _makeLong: function _makeLong(path) {
        return path;
      },

      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0) return '.';
        var code = path.charCodeAt(0);
        var hasRoot = code === 47 /*/*/;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code = path.charCodeAt(i);
          if (code === 47 /*/*/) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
            // We saw the first non-path separator
            matchedSlash = false;
          }
        }

        if (end === -1) return hasRoot ? '/' : '.';
        if (hasRoot && end === 1) return '//';
        return path.slice(0, end);
      },

      basename: function basename(path, ext) {
        if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
        assertPath(path);

        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;

        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path) return '';
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47 /*/*/) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
              if (firstNonSlashEnd === -1) {
                // We saw the first non-path separator, remember this index in case
                // we need it if the extension ends up not matching
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                // Try to match the explicit extension
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    // We matched the extension, so mark this as the end of our path
                    // component
                    end = i;
                  }
                } else {
                  // Extension does not match, so our result is the entire path
                  // component
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }

          if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
          return path.slice(start, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47 /*/*/) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
              // We saw the first non-path separator, mark this as the end of our
              // path component
              matchedSlash = false;
              end = i + 1;
            }
          }

          if (end === -1) return '';
          return path.slice(start, end);
        }
      },

      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47 /*/*/) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
          if (end === -1) {
            // We saw the first non-path separator, mark this as the end of our
            // extension
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46 /*.*/) {
              // If this is our first dot, mark it as the start of our extension
              if (startDot === -1)
                startDot = i;
              else if (preDotState !== 1)
                preDotState = 1;
          } else if (startDot !== -1) {
            // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
          }
        }

        if (startDot === -1 || end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return '';
        }
        return path.slice(startDot, end);
      },

      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== 'object') {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format('/', pathObject);
      },

      parse: function parse(path) {
        assertPath(path);

        var ret = { root: '', dir: '', base: '', ext: '', name: '' };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47 /*/*/;
        var start;
        if (isAbsolute) {
          ret.root = '/';
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;

        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;

        // Get non-dir info
        for (; i >= start; --i) {
          code = path.charCodeAt(i);
          if (code === 47 /*/*/) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
          if (end === -1) {
            // We saw the first non-path separator, mark this as the end of our
            // extension
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46 /*.*/) {
              // If this is our first dot, mark it as the start of our extension
              if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
            // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
          }
        }

        if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }

        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

        return ret;
      },

      sep: '/',
      delimiter: ':',
      win32: null,
      posix: null
    };

    posix.posix = posix;

    var pathBrowserify = posix;

    /* src/components/Select/Select.svelte generated by Svelte v3.20.1 */
    const file$1 = "src/components/Select/Select.svelte";

    function add_css$1() {
    	var style = element("style");
    	style.id = "svelte-fkquly-style";
    	style.textContent = "container.svelte-fkquly.svelte-fkquly{display:flex;flex-wrap:wrap;justify-content:center;grid-gap:20px;padding:20px}:root{--border-radius:2em 17em}.docButton.svelte-fkquly.svelte-fkquly{position:relative;color:#eee;font-size:var(--font-size-btn);font-weight:300;min-width:200px;padding:8px;margin:5px;text-align:center;display:flex;justify-content:center;align-items:center;border:1.5px #6c9ec4 outset;border-bottom-left-radius:var(--border-radius);border-bottom-right-radius:var(--border-radius);border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);background:var(--button-gradient);text-shadow:1px 1px #666;cursor:pointer}.docButton.svelte-fkquly .text.svelte-fkquly{z-index:2}.docButton.svelte-fkquly.svelte-fkquly::before{position:absolute;content:\"\";top:0;right:0;bottom:0;left:0;z-index:1;transition:opacity 0.2s linear;opacity:0;background-image:linear-gradient(\n      to right,\n      var(--celestrak-blue) 0%,\n      #3dabff 50%,\n      var(--celestrak-blue) 100%\n    )}.docButton.svelte-fkquly.svelte-fkquly:hover::before{opacity:1}h2.svelte-fkquly.svelte-fkquly{font-size:calc(2rem + 0.5 * ((100vw - 50rem) / 120));text-align:center;color:#000;font-weight:200;font-family:var(--font-family)}h2.svelte-fkquly.svelte-fkquly{font-size:calc(2rem + 0.5 * ((100vw - 50rem) / 120))}#footer.svelte-fkquly.svelte-fkquly{display:flex;align-content:center;justify-content:center;padding:5px;position:fixed;bottom:0px;width:100vw}#footer.svelte-fkquly button.svelte-fkquly{background:var(--celestrak-blue);border:0px;color:white;padding:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0LnN2ZWx0ZSIsInNvdXJjZXMiOlsiU2VsZWN0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBpbXBvcnQge1xuICAgIElETERvY3VtZW50LFxuICAgIG1hbmlmZXN0LFxuICAgIElETEVkaXRvckNvbnRlbnRzXG4gIH0gZnJvbSBcIi4uLy4uL3N0b3Jlcy9GaWxlcy5qc1wiO1xuICBpbXBvcnQgcGF0aCBmcm9tIFwicGF0aC1icm93c2VyaWZ5XCI7XG4gIGV4cG9ydCBsZXQgbG9hZGVkO1xuICBleHBvcnQgbGV0IGFyZ3M7XG4gIGV4cG9ydCBsZXQgdG9nZ2xlTWVudTtcblxuICBsZXQgbG9hZEZpbGUgPSBtRmlsZSA9PiB7XG4gICAgaWYgKCEkSURMRWRpdG9yQ29udGVudHMgfHwgY29uZmlybShcIlJlcGxhY2UgQ3VycmVudCBJREwgQ29udGVudHM/XCIpKSB7XG4gICAgICBmZXRjaChwYXRoLmpvaW4oJG1hbmlmZXN0LnJvb3QsIG1GaWxlKSlcbiAgICAgICAgLnRoZW4oYXN5bmMgZGF0YSA9PiB7XG4gICAgICAgICAgJElETERvY3VtZW50ID0gbUZpbGU7XG4gICAgICAgICAgJElETEVkaXRvckNvbnRlbnRzID0gXCJcIjtcbiAgICAgICAgICAkSURMRWRpdG9yQ29udGVudHMgPSBhd2FpdCBkYXRhLnRleHQoKTtcbiAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgYWxlcnQoYEZldGNoIEZhaWxlZCBXaXRoIEVycm9yOiAke2V9YCk7XG4gICAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjbGVhckxvY2FsRGF0YSA9ICgpID0+IHtcbiAgICBpZiAoY29uZmlybShcImNsZWFyIGRhdGFcIikpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpO1xuICAgICAgJElETERvY3VtZW50ID0gXCJcIjtcbiAgICAgICRJRExFZGl0b3JDb250ZW50cyA9IFwiXCI7XG4gICAgfVxuICB9O1xuICBvbk1vdW50KCgpID0+IHtcbiAgICBsb2FkZWQgPSB0cnVlO1xuICB9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIGNvbnRhaW5lciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZ3JpZC1nYXA6IDIwcHg7XG4gICAgcGFkZGluZzogMjBweDtcbiAgfVxuICA6cm9vdCB7XG4gICAgLS1ib3JkZXItcmFkaXVzOiAyZW0gMTdlbTtcbiAgfVxuICAuZG9jQnV0dG9uIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgY29sb3I6ICNlZWU7XG4gICAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUtYnRuKTtcbiAgICBmb250LXdlaWdodDogMzAwO1xuICAgIG1pbi13aWR0aDogMjAwcHg7XG4gICAgcGFkZGluZzogOHB4O1xuICAgIG1hcmdpbjogNXB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm9yZGVyOiAxLjVweCAjNmM5ZWM0IG91dHNldDtcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzKTtcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cyk7XG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cyk7XG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMpO1xuXG4gICAgYmFja2dyb3VuZDogdmFyKC0tYnV0dG9uLWdyYWRpZW50KTtcbiAgICB0ZXh0LXNoYWRvdzogMXB4IDFweCAjNjY2O1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgfVxuICAuZG9jQnV0dG9uIC50ZXh0IHtcbiAgICB6LWluZGV4OiAyO1xuICB9XG4gIC5kb2NCdXR0b246OmJlZm9yZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGNvbnRlbnQ6IFwiXCI7XG4gICAgdG9wOiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJvdHRvbTogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHotaW5kZXg6IDE7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGxpbmVhcjtcbiAgICBvcGFjaXR5OiAwO1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudChcbiAgICAgIHRvIHJpZ2h0LFxuICAgICAgdmFyKC0tY2VsZXN0cmFrLWJsdWUpIDAlLFxuICAgICAgIzNkYWJmZiA1MCUsXG4gICAgICB2YXIoLS1jZWxlc3RyYWstYmx1ZSkgMTAwJVxuICAgICk7XG4gIH1cbiAgLmRvY0J1dHRvbjpob3Zlcjo6YmVmb3JlIHtcbiAgICBvcGFjaXR5OiAxO1xuICB9XG4gIGgxLFxuICBoMiB7XG4gICAgZm9udC1zaXplOiBjYWxjKDJyZW0gKyAwLjUgKiAoKDEwMHZ3IC0gNTByZW0pIC8gMTIwKSk7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGNvbG9yOiAjMDAwO1xuICAgIGZvbnQtd2VpZ2h0OiAyMDA7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtZmFtaWx5KTtcbiAgfVxuICBoMiB7XG4gICAgZm9udC1zaXplOiBjYWxjKDJyZW0gKyAwLjUgKiAoKDEwMHZ3IC0gNTByZW0pIC8gMTIwKSk7XG4gIH1cbiAgaDEgYSB7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgIGNvbG9yOiB2YXIoLS1jZWxlc3RyYWstYmx1ZSk7XG4gICAgYm9yZGVyLWJvdHRvbTogMC41cHggdmFyKC0tY2VsZXN0cmFrLWJsdWUpIHNvbGlkO1xuICB9XG4gICNmb290ZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIHBhZGRpbmc6IDVweDtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgYm90dG9tOiAwcHg7XG4gICAgd2lkdGg6IDEwMHZ3O1xuICB9XG4gICNmb290ZXIgYnV0dG9uIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jZWxlc3RyYWstYmx1ZSk7XG4gICAgYm9yZGVyOiAwcHg7XG4gICAgY29sb3I6IHdoaXRlO1xuICAgIHBhZGRpbmc6IDEwcHg7XG4gIH1cbjwvc3R5bGU+XG5cbjxoMj5DTElDSyBUTyBMT0FEPC9oMj5cbjxoMj5cbiAgPGFcbiAgICBzdHlsZT1cInRleHQtZGVjb3JhdGlvbjpub25lXCJcbiAgICBocmVmPVwiaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2ZsYXRidWZmZXJzL21kX19zY2hlbWFzLmh0bWxcIlxuICAgIHRhcmdldD1cIl9uZXdcIj5cbiAgICBJTlRFUkZBQ0UgREVGSU5JVElPTiBMQU5HVUFHRSAoSURMKSBGSUxFXG4gIDwvYT5cbjwvaDI+XG48Y29udGFpbmVyPlxuICB7I2VhY2ggJG1hbmlmZXN0LmZpbGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICByZXR1cm4gYS5maWxlbmFtZSA+IGIuZmlsZW5hbWUgPyAtMSA6IDE7XG4gIH0pIGFzIG1maWxlfVxuICAgIDxkaXYgY2xhc3M9XCJkb2NCdXR0b25cIj5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJ0ZXh0XCJcbiAgICAgICAgb246Y2xpY2s9e2UgPT4ge1xuICAgICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgIGxvYWRGaWxlKG1maWxlLmZpbGVuYW1lKTtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcvaWRsJztcbiAgICAgICAgICB0b2dnbGVNZW51KGZhbHNlKTtcbiAgICAgICAgfX0+XG4gICAgICAgIHttZmlsZS50aXRsZX1cbiAgICAgICAgPGJyIC8+XG4gICAgICAgIHttZmlsZS5maWxlbmFtZS5tYXRjaCgvXFx3ezEsfS8pfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIHsvZWFjaH1cbjwvY29udGFpbmVyPlxuPGRpdiBpZD1cImZvb3RlclwiPlxuICA8YnV0dG9uXG4gICAgb246Y2xpY2s9eygpID0+IHtcbiAgICAgIGNsZWFyTG9jYWxEYXRhKCk7XG4gICAgfX0+XG4gICAgQ2xpY2sgdG8gQ2xlYXIgTG9jYWwgRGF0YVxuICA8L2J1dHRvbj5cbjwvZGl2PlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXdDRSxTQUFTLDRCQUFDLENBQUMsQUFDVCxPQUFPLENBQUUsSUFBSSxDQUNiLFNBQVMsQ0FBRSxJQUFJLENBQ2YsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsUUFBUSxDQUFFLElBQUksQ0FDZCxPQUFPLENBQUUsSUFBSSxBQUNmLENBQUMsQUFDRCxLQUFLLEFBQUMsQ0FBQyxBQUNMLGVBQWUsQ0FBRSxRQUFRLEFBQzNCLENBQUMsQUFDRCxVQUFVLDRCQUFDLENBQUMsQUFDVixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLFNBQVMsQ0FBRSxJQUFJLGVBQWUsQ0FBQyxDQUMvQixXQUFXLENBQUUsR0FBRyxDQUNoQixTQUFTLENBQUUsS0FBSyxDQUNoQixPQUFPLENBQUUsR0FBRyxDQUNaLE1BQU0sQ0FBRSxHQUFHLENBQ1gsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsT0FBTyxDQUFFLElBQUksQ0FDYixlQUFlLENBQUUsTUFBTSxDQUN2QixXQUFXLENBQUUsTUFBTSxDQUNuQixNQUFNLENBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQzVCLHlCQUF5QixDQUFFLElBQUksZUFBZSxDQUFDLENBQy9DLDBCQUEwQixDQUFFLElBQUksZUFBZSxDQUFDLENBQ2hELHNCQUFzQixDQUFFLElBQUksZUFBZSxDQUFDLENBQzVDLHVCQUF1QixDQUFFLElBQUksZUFBZSxDQUFDLENBRTdDLFVBQVUsQ0FBRSxJQUFJLGlCQUFpQixDQUFDLENBQ2xDLFdBQVcsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FDekIsTUFBTSxDQUFFLE9BQU8sQUFDakIsQ0FBQyxBQUNELHdCQUFVLENBQUMsS0FBSyxjQUFDLENBQUMsQUFDaEIsT0FBTyxDQUFFLENBQUMsQUFDWixDQUFDLEFBQ0Qsc0NBQVUsUUFBUSxBQUFDLENBQUMsQUFDbEIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLEVBQUUsQ0FDWCxHQUFHLENBQUUsQ0FBQyxDQUNOLEtBQUssQ0FBRSxDQUFDLENBQ1IsTUFBTSxDQUFFLENBQUMsQ0FDVCxJQUFJLENBQUUsQ0FBQyxDQUNQLE9BQU8sQ0FBRSxDQUFDLENBQ1YsVUFBVSxDQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUMvQixPQUFPLENBQUUsQ0FBQyxDQUNWLGdCQUFnQixDQUFFO01BQ2hCLEVBQUUsQ0FBQyxLQUFLLENBQUM7TUFDVCxJQUFJLGdCQUFnQixDQUFDLENBQUMsRUFBRSxDQUFDO01BQ3pCLE9BQU8sQ0FBQyxHQUFHLENBQUM7TUFDWixJQUFJLGdCQUFnQixDQUFDLENBQUMsSUFBSTtLQUMzQixBQUNILENBQUMsQUFDRCxzQ0FBVSxNQUFNLFFBQVEsQUFBQyxDQUFDLEFBQ3hCLE9BQU8sQ0FBRSxDQUFDLEFBQ1osQ0FBQyxBQUVELEVBQUUsNEJBQUMsQ0FBQyxBQUNGLFNBQVMsQ0FBRSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FDckQsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxXQUFXLENBQUUsR0FBRyxDQUNoQixXQUFXLENBQUUsSUFBSSxhQUFhLENBQUMsQUFDakMsQ0FBQyxBQUNELEVBQUUsNEJBQUMsQ0FBQyxBQUNGLFNBQVMsQ0FBRSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQUFDdkQsQ0FBQyxBQU1ELE9BQU8sNEJBQUMsQ0FBQyxBQUNQLE9BQU8sQ0FBRSxJQUFJLENBQ2IsYUFBYSxDQUFFLE1BQU0sQ0FDckIsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsT0FBTyxDQUFFLEdBQUcsQ0FDWixRQUFRLENBQUUsS0FBSyxDQUNmLE1BQU0sQ0FBRSxHQUFHLENBQ1gsS0FBSyxDQUFFLEtBQUssQUFDZCxDQUFDLEFBQ0QscUJBQU8sQ0FBQyxNQUFNLGNBQUMsQ0FBQyxBQUNkLFVBQVUsQ0FBRSxJQUFJLGdCQUFnQixDQUFDLENBQ2pDLE1BQU0sQ0FBRSxHQUFHLENBQ1gsS0FBSyxDQUFFLEtBQUssQ0FDWixPQUFPLENBQUUsSUFBSSxBQUNmLENBQUMifQ== */";
    	append_dev(document.head, style);
    }

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (139:2) {#each $manifest.files.sort((a, b) => {     return a.filename > b.filename ? -1 : 1;   }) as mfile}
    function create_each_block(ctx) {
    	let div1;
    	let div0;
    	let t0_value = /*mfile*/ ctx[10].title + "";
    	let t0;
    	let t1;
    	let br;
    	let t2;
    	let t3_value = /*mfile*/ ctx[10].filename.match(/\w{1,}/) + "";
    	let t3;
    	let t4;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[8](/*mfile*/ ctx[10], ...args);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = space();
    			attr_dev(br, "class", "svelte-fkquly");
    			add_location(br, file$1, 151, 8, 3374);
    			attr_dev(div0, "class", "text svelte-fkquly");
    			add_location(div0, file$1, 142, 6, 3149);
    			attr_dev(div1, "class", "docButton svelte-fkquly");
    			add_location(div1, file$1, 141, 4, 3119);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, br);
    			append_dev(div0, t2);
    			append_dev(div0, t3);
    			append_dev(div1, t4);
    			if (remount) dispose();
    			dispose = listen_dev(div0, "click", click_handler, false, false, false);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$manifest*/ 4 && t0_value !== (t0_value = /*mfile*/ ctx[10].title + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$manifest*/ 4 && t3_value !== (t3_value = /*mfile*/ ctx[10].filename.match(/\w{1,}/) + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(139:2) {#each $manifest.files.sort((a, b) => {     return a.filename > b.filename ? -1 : 1;   }) as mfile}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let h20;
    	let t1;
    	let h21;
    	let a;
    	let t3;
    	let container;
    	let t4;
    	let div;
    	let button;
    	let dispose;
    	let each_value = /*$manifest*/ ctx[2].files.sort(func);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h20 = element("h2");
    			h20.textContent = "CLICK TO LOAD";
    			t1 = space();
    			h21 = element("h2");
    			a = element("a");
    			a.textContent = "INTERFACE DEFINITION LANGUAGE (IDL) FILE";
    			t3 = space();
    			container = element("container");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Click to Clear Local Data";
    			attr_dev(h20, "class", "svelte-fkquly");
    			add_location(h20, file$1, 128, 0, 2793);
    			set_style(a, "text-decoration", "none");
    			attr_dev(a, "href", "https://google.github.io/flatbuffers/md__schemas.html");
    			attr_dev(a, "target", "_new");
    			attr_dev(a, "class", "svelte-fkquly");
    			add_location(a, file$1, 130, 2, 2823);
    			attr_dev(h21, "class", "svelte-fkquly");
    			add_location(h21, file$1, 129, 0, 2816);
    			attr_dev(container, "class", "svelte-fkquly");
    			add_location(container, file$1, 137, 0, 3001);
    			attr_dev(button, "class", "svelte-fkquly");
    			add_location(button, file$1, 158, 2, 3489);
    			attr_dev(div, "id", "footer");
    			attr_dev(div, "class", "svelte-fkquly");
    			add_location(div, file$1, 157, 0, 3469);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h21, anchor);
    			append_dev(h21, a);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, container, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(container, null);
    			}

    			insert_dev(target, t4, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			if (remount) dispose();
    			dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[9], false, false, false);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*loaded, loadFile, $manifest, window, toggleMenu*/ 15) {
    				each_value = /*$manifest*/ ctx[2].files.sort(func);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(container, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(container);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = (a, b) => {
    	return a.filename > b.filename ? -1 : 1;
    };

    function instance$1($$self, $$props, $$invalidate) {
    	let $IDLEditorContents;
    	let $manifest;
    	let $IDLDocument;
    	validate_store(IDLEditorContents, "IDLEditorContents");
    	component_subscribe($$self, IDLEditorContents, $$value => $$invalidate(6, $IDLEditorContents = $$value));
    	validate_store(manifest, "manifest");
    	component_subscribe($$self, manifest, $$value => $$invalidate(2, $manifest = $$value));
    	validate_store(IDLDocument, "IDLDocument");
    	component_subscribe($$self, IDLDocument, $$value => $$invalidate(7, $IDLDocument = $$value));
    	let { loaded } = $$props;
    	let { args } = $$props;
    	let { toggleMenu } = $$props;

    	let loadFile = mFile => {
    		if (!$IDLEditorContents || confirm("Replace Current IDL Contents?")) {
    			fetch(pathBrowserify.join($manifest.root, mFile)).then(async data => {
    				set_store_value(IDLDocument, $IDLDocument = mFile);
    				set_store_value(IDLEditorContents, $IDLEditorContents = "");
    				set_store_value(IDLEditorContents, $IDLEditorContents = await data.text());
    				$$invalidate(0, loaded = true);
    			}).catch(e => {
    				alert(`Fetch Failed With Error: ${e}`);
    				$$invalidate(0, loaded = true);
    			});
    		}
    	};

    	const clearLocalData = () => {
    		if (confirm("clear data")) {
    			localStorage.clear();
    			set_store_value(IDLDocument, $IDLDocument = "");
    			set_store_value(IDLEditorContents, $IDLEditorContents = "");
    		}
    	};

    	onMount(() => {
    		$$invalidate(0, loaded = true);
    	});

    	const writable_props = ["loaded", "args", "toggleMenu"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Select> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Select", $$slots, []);

    	const click_handler = (mfile, e) => {
    		$$invalidate(0, loaded = false);
    		loadFile(mfile.filename);
    		window.location.hash = "/idl";
    		toggleMenu(false);
    	};

    	const click_handler_1 = () => {
    		clearLocalData();
    	};

    	$$self.$set = $$props => {
    		if ("loaded" in $$props) $$invalidate(0, loaded = $$props.loaded);
    		if ("args" in $$props) $$invalidate(5, args = $$props.args);
    		if ("toggleMenu" in $$props) $$invalidate(1, toggleMenu = $$props.toggleMenu);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		IDLDocument,
    		manifest,
    		IDLEditorContents,
    		path: pathBrowserify,
    		loaded,
    		args,
    		toggleMenu,
    		loadFile,
    		clearLocalData,
    		$IDLEditorContents,
    		$manifest,
    		$IDLDocument
    	});

    	$$self.$inject_state = $$props => {
    		if ("loaded" in $$props) $$invalidate(0, loaded = $$props.loaded);
    		if ("args" in $$props) $$invalidate(5, args = $$props.args);
    		if ("toggleMenu" in $$props) $$invalidate(1, toggleMenu = $$props.toggleMenu);
    		if ("loadFile" in $$props) $$invalidate(3, loadFile = $$props.loadFile);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		loaded,
    		toggleMenu,
    		$manifest,
    		loadFile,
    		clearLocalData,
    		args,
    		$IDLEditorContents,
    		$IDLDocument,
    		click_handler,
    		click_handler_1
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		if (!document.getElementById("svelte-fkquly-style")) add_css$1();
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { loaded: 0, args: 5, toggleMenu: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*loaded*/ ctx[0] === undefined && !("loaded" in props)) {
    			console.warn("<Select> was created without expected prop 'loaded'");
    		}

    		if (/*args*/ ctx[5] === undefined && !("args" in props)) {
    			console.warn("<Select> was created without expected prop 'args'");
    		}

    		if (/*toggleMenu*/ ctx[1] === undefined && !("toggleMenu" in props)) {
    			console.warn("<Select> was created without expected prop 'toggleMenu'");
    		}
    	}

    	get loaded() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaded(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get args() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set args(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleMenu() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggleMenu(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var tokenProvider = {
      tokenizer: {
        root: [
          [
            /\b(root_type|table|struct|union|enum|namespace|id|deprecated|required|original_order|force_align|bit_flags|nested_flatbuffer|key|attribute|include|file_identifier|file_extension)\b/,
            "keyword.control.flatbuffers"
          ],
          [
            /(\.)?\s*\b(bool|byte|ubyte|short|ushort|int|uint|float|long|ulong|double|string)\b/,
            "storage.type.flatbuffers"
          ],
          [
            /\b(?=>(namespace|attribute|include|enum|union|struct|table|root_type) )\w{1,}\b/,
            "keyword.name.flatbuffers"
          ],
          [
            /^\s*\/\/[^\/].{1,}/,
            "keyword.comments.flatbuffers"
          ],
          [
            /^\s*\/\/\/.*/,
            "keyword.local.comment.flatbuffers"
          ]
        ]
      }
    };

    /* src/components/MonacoEditor/MonacoEditor.svelte generated by Svelte v3.20.1 */

    const { document: document_1 } = globals;
    const file$2 = "src/components/MonacoEditor/MonacoEditor.svelte";

    function create_fragment$2(ctx) {
    	let script;
    	let t1;
    	let div;

    	const block = {
    		c: function create() {
    			script = element("script");
    			script.textContent = "import monaco from \"https://digitalarsenal.io/lib/monacoeditor.js\";\r\n    createEditor();";
    			t1 = space();
    			div = element("div");
    			attr_dev(script, "type", "module");
    			add_location(script, file$2, 102, 2, 2852);
    			attr_dev(div, "id", "monacoeditor");
    			attr_dev(div, "style", /*_style*/ ctx[3]);
    			attr_dev(div, "class", /*_class*/ ctx[2]);
    			add_location(div, file$2, 107, 0, 2999);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document_1.head, script);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			detach_dev(script);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $editorContents;
    	let $documentName;
    	let { loaded = undefined } = $$props;
    	let { args } = $$props;
    	let editor;
    	let { documentName, editorContents, _class, _style, language = "javascript", theme = "vs", readOnly = false } = args;
    	validate_store(documentName, "documentName");
    	component_subscribe($$self, documentName, value => $$invalidate(8, $documentName = value));
    	validate_store(editorContents, "editorContents");
    	component_subscribe($$self, editorContents, value => $$invalidate(7, $editorContents = value));

    	const setEditorLanguage = n => {
    		if (!n) return;
    		let language;

    		if (globalThis.monaco) {
    			let extension = n.split(".").pop();
    			let languages = monaco.languages.getLanguages();

    			for (let x = 0; x < languages.length; x++) {
    				let _language = languages[x];

    				if (_language.extensions && _language.extensions.indexOf("." + extension) > -1) {
    					language = _language.id;
    					break;
    				}
    			}

    			if (editor && globalThis.monaco && editor.getModel()) {
    				monaco.editor.setModelLanguage(editor.getModel(), language);
    				editor.updateOptions({ readOnly });
    			}
    		}
    	};

    	documentName.subscribe(setEditorLanguage);

    	editorContents.subscribe(e => {
    		if (editor && editor.getValue() !== e) {
    			editor.setValue(e);
    		}

    		$$invalidate(4, loaded = true);
    	});

    	const setC = () => {
    		if (editor && $editorContents !== editor.getValue()) {
    			set_store_value(editorContents, $editorContents = editor.getValue());
    		}

    		$$invalidate(4, loaded = true);
    	};

    	globalThis.createEditor = () => {
    		if (!editor && globalThis.monaco) {
    			monaco.languages.setMonarchTokensProvider("flatbuffers", tokenProvider);

    			monaco.editor.defineTheme("flatbuffers", {
    				base: "vs",
    				inherit: false,
    				rules: [
    					{
    						token: "keyword.control.flatbuffers",
    						foreground: "9100ff"
    					},
    					{
    						token: "storage.type.flatbuffers",
    						foreground: "2f45eb"
    					},
    					{
    						token: "keyword.name.flatbuffers",
    						foreground: "00d44a"
    					},
    					{
    						token: "keyword.comments.flatbuffers",
    						foreground: "00aa00"
    					},
    					{
    						token: "keyword.local.comment.flatbuffers",
    						foreground: "3300cc"
    					}
    				]
    			});

    			monaco.languages.register({ id: "flatbuffers", extensions: [".fbs"] });

    			editor = monaco.editor.create(document.getElementById("monacoeditor"), {
    				value: $editorContents,
    				language,
    				theme,
    				automaticLayout: true
    			});

    			globalThis.editor = editor;
    			editor.onDidChangeModelContent(setC);
    			window.editor = editor;
    			setEditorLanguage($documentName);
    		}

    		$$invalidate(4, loaded = true);
    	};

    	onMount(function () {
    		createEditor();
    		setEditorLanguage($documentName);
    	});

    	onDestroy(() => editor ? editor.dispose() : null);
    	const writable_props = ["loaded", "args"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MonacoEditor> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("MonacoEditor", $$slots, []);

    	$$self.$set = $$props => {
    		if ("loaded" in $$props) $$invalidate(4, loaded = $$props.loaded);
    		if ("args" in $$props) $$invalidate(5, args = $$props.args);
    	};

    	$$self.$capture_state = () => ({
    		onLoad,
    		onMount,
    		onDestroy,
    		IDLDocument,
    		tokenProvider,
    		loaded,
    		args,
    		editor,
    		documentName,
    		editorContents,
    		_class,
    		_style,
    		language,
    		theme,
    		readOnly,
    		setEditorLanguage,
    		setC,
    		$editorContents,
    		$documentName
    	});

    	$$self.$inject_state = $$props => {
    		if ("loaded" in $$props) $$invalidate(4, loaded = $$props.loaded);
    		if ("args" in $$props) $$invalidate(5, args = $$props.args);
    		if ("editor" in $$props) editor = $$props.editor;
    		if ("documentName" in $$props) $$invalidate(0, documentName = $$props.documentName);
    		if ("editorContents" in $$props) $$invalidate(1, editorContents = $$props.editorContents);
    		if ("_class" in $$props) $$invalidate(2, _class = $$props._class);
    		if ("_style" in $$props) $$invalidate(3, _style = $$props._style);
    		if ("language" in $$props) language = $$props.language;
    		if ("theme" in $$props) theme = $$props.theme;
    		if ("readOnly" in $$props) readOnly = $$props.readOnly;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [documentName, editorContents, _class, _style, loaded, args];
    }

    class MonacoEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { loaded: 4, args: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MonacoEditor",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*args*/ ctx[5] === undefined && !("args" in props)) {
    			console.warn("<MonacoEditor> was created without expected prop 'args'");
    		}
    	}

    	get loaded() {
    		throw new Error("<MonacoEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaded(value) {
    		throw new Error("<MonacoEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get args() {
    		throw new Error("<MonacoEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set args(value) {
    		throw new Error("<MonacoEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    let languages = [
      ["--cpp", "C++ header", "h", "include"],
      ["--java", "Java", "java", "java"],
      ["--kotlin", "Kotlin", "kt", "java"],
      ["--csharp", "C#", "cs", "net"],
      ["--go", "Go", "go", "go"],
      ["--python", "Python", "py", "python", "text/x-script.python"],
      ["--js", "JavaScript", "js", "js", "text/javascript"],
      ["--js", "JSON Schema", "json", "json"],
      ["--ts", "TypeScript", "ts", "js", "text/javascript"],
      ["--php", " PHP", "php", "php"],
      /*["--grpc", " RPC stub code for GRPC", ''],*/
      ["--dart", " Dart"],
      ["--lua", " Lua"],
      ["--lobster", " Lobster"],
      /*["--rust, -r ", " Rust"],*/
      ["--swift", " Swift"]

    ];

    const mobilecheck = function () {
      var check = false;
      (function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)) || navigator.userAgent.toLowerCase().indexOf('firefox') > -1) check = true; })(navigator.userAgent || navigator.vendor || window.opera);
      return check;
    };

    const nhC = navigator.hardwareConcurrency;
    const wMax = nhC ? nhC - 1 : 2;
    const workers = new Array(wMax);
    const activeWorkers = [];

    var workerLoader = (workerPath, inputObject, callback) => {

      if (mobilecheck()) { //cannot load external worker
        import(workerPath).then((m) => {
          m.convert({ data: inputObject })
            .then(callback)
            .catch((e) => {
              result = e;
            });
        });
      } else {
        let nW = () => new Worker(workerPath, { type: "module" });
        let wIndex = Math.min(activeWorkers.length, wMax - 1);
        activeWorkers[wIndex] = workers[wIndex] = workers[wIndex] || nW();
        activeWorkers[wIndex].postMessage(inputObject);
        activeWorkers[wIndex].onmessage = (a) => {
          callback(a.data);
          activeWorkers.splice(activeWorkers.indexOf(activeWorkers[wIndex]));
        };
      }
    };

    var demangler = (propertyArray = [], text) => {
      propertyArray.forEach(canonicalname => {
        let mangledname = canonicalname.replace(/_/g, "").toUpperCase();
        let mRegExp = new RegExp(mangledname, "g");
        text = text.replace(mRegExp, canonicalname);
      });

      return text;
    };

    /* src/components/Code/Code.svelte generated by Svelte v3.20.1 */

    const { Object: Object_1 } = globals;
    const file$3 = "src/components/Code/Code.svelte";

    function add_css$2() {
    	var style = element("style");
    	style.id = "svelte-i4yx4a-style";
    	style.textContent = "select.svelte-i4yx4a.svelte-i4yx4a{font-size:12px;padding:2px;user-select:none;outline:none}#topMenu.svelte-i4yx4a.svelte-i4yx4a{display:grid;grid-template-columns:minmax(50px, 100px) minmax(50px, 200px) minmax(20px, 100px)\r\n      auto;grid-gap:15px;padding:5px;height:40px}.dlBtn.svelte-i4yx4a.svelte-i4yx4a{display:flex;align-self:center;justify-content:flex-end;height:100%}.dlBtn.svelte-i4yx4a a.svelte-i4yx4a{text-decoration:none;color:white;background-color:var(--celestrak-blue);padding:5px;font-weight:300;font-size:var(--font-size-sm);display:flex;justify-content:center;align-items:center}.editorCode{height:calc(99.99vh - var(--header-height) - 40px)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29kZS5zdmVsdGUiLCJzb3VyY2VzIjpbIkNvZGUuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcbiAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcclxuICBpbXBvcnQge1xyXG4gICAgSURMRG9jdW1lbnQsXHJcbiAgICBJRExFZGl0b3JDb250ZW50cyxcclxuICAgIENvZGVFZGl0b3JEb2N1bWVudHMsXHJcbiAgICBDb2RlRWRpdG9yQWN0aXZlRG9jdW1lbnQsXHJcbiAgICBDb2RlRWRpdG9yQ29udGVudHMsXHJcbiAgICBDb2RlRWRpdG9yTGFuZ3VhZ2VcclxuICB9IGZyb20gXCIuLi8uLi9zdG9yZXMvRmlsZXNcIjtcclxuICBpbXBvcnQgeyBsYW5ndWFnZXMgfSBmcm9tIFwiLi9sYW5ndWFnZXMuanNcIjtcclxuICBpbXBvcnQgRWRpdG9yIGZyb20gXCIuLi9Nb25hY29FZGl0b3IvTW9uYWNvRWRpdG9yLnN2ZWx0ZVwiO1xyXG4gIGltcG9ydCB3b3JrZXJMb2FkZXIgZnJvbSBcIi4uLy4uL2xpYi93b3JrZXJMb2FkZXIuanNcIjtcclxuICBpbXBvcnQgZGVtYW5nbGVyIGZyb20gXCIuLi8uLi9saWIvZGVtYW5nbGVyLmpzXCI7XHJcbiAgZXhwb3J0IGxldCBsb2FkZWQgPSB1bmRlZmluZWQ7XHJcbiAgZXhwb3J0IGxldCB0b2dnbGVNZW51ID0gdW5kZWZpbmVkO1xyXG5cclxuICBleHBvcnQgbGV0IGFyZ3M7XHJcbiAgYXJncy5fY2xhc3MgPSBcImVkaXRvckNvZGVcIjtcclxuXHJcbiAgY29uc3Qgc2NoZW1hU29ydCA9IChhLCBiKSA9PiB7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH0gZWxzZSBpZiAoYS5pbmRleE9mKFwic2NoZW1hLmpzb25cIikgPiAtMSkge1xyXG4gICAgICByZXR1cm4gMTtcclxuICAgIH0gZWxzZSBpZiAoYi5pbmRleE9mKFwic2NoZW1hLmpzb25cIikgPiAtMSkge1xyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gYSA8IGIgPyAxIDogLTE7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgJDoge1xyXG4gICAgbGV0IF9lZGl0b3JDb250ZW50cyA9ICRDb2RlRWRpdG9yRG9jdW1lbnRzWyRDb2RlRWRpdG9yQWN0aXZlRG9jdW1lbnRdO1xyXG4gICAgbGV0IF9zRmlsZSA9IE9iamVjdC5rZXlzKCRDb2RlRWRpdG9yRG9jdW1lbnRzKS5maWx0ZXIoXHJcbiAgICAgIGYgPT4gZi5pbmRleE9mKFwic2NoZW1hLmpzb25cIikgPiAtMVxyXG4gICAgKVswXTtcclxuICAgIGlmIChfc0ZpbGUpIHtcclxuICAgICAgbGV0IF9zY2hlbWEgPSBKU09OLnBhcnNlKCRDb2RlRWRpdG9yRG9jdW1lbnRzW19zRmlsZV0pO1xyXG4gICAgICBsZXQgX2tleXMgPSBbXTtcclxuICAgICAgT2JqZWN0LmVudHJpZXMoX3NjaGVtYS5kZWZpbml0aW9ucykuZm9yRWFjaChwcCA9PiB7XHJcbiAgICAgICAgaWYgKHBwWzFdLmhhc093blByb3BlcnR5KFwicHJvcGVydGllc1wiKSkge1xyXG4gICAgICAgICAgX2tleXMgPSBfa2V5cy5jb25jYXQoT2JqZWN0LmtleXMocHBbMV0ucHJvcGVydGllcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgICRDb2RlRWRpdG9yQ29udGVudHMgPSBkZW1hbmdsZXIoX2tleXMsIF9lZGl0b3JDb250ZW50cyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IHdvcmtlclBhdGggPSBcIi93b3JrZXJzL3dvcmtlci5qc1wiO1xyXG4gICRDb2RlRWRpdG9yTGFuZ3VhZ2UgPSAkQ29kZUVkaXRvckxhbmd1YWdlLmxlbmd0aFxyXG4gICAgPyAkQ29kZUVkaXRvckxhbmd1YWdlXHJcbiAgICA6IGxhbmd1YWdlc1swXTtcclxuXHJcbiAgY29uc3QgY2FsbGJhY2sgPSBkYXRhID0+IHtcclxuICAgIGlmIChkYXRhLmVycm9yKSB7XHJcbiAgICAgIGFsZXJ0KGRhdGEuZXJyb3IpO1xyXG4gICAgICBsb2FkZWQgPSB0cnVlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAkQ29kZUVkaXRvckRvY3VtZW50cyA9IGRhdGEuZmlsZXM7XHJcbiAgICAkQ29kZUVkaXRvckFjdGl2ZURvY3VtZW50ID0gT2JqZWN0LmtleXMoZGF0YS5maWxlcykuc29ydChzY2hlbWFTb3J0KVswXTtcclxuICAgIGxvYWRlZCA9IGRhdGEubG9hZGVkO1xyXG4gIH07XHJcblxyXG4gIGxldCBjcmVhdGVDb2RlID0gKCkgPT4ge1xyXG4gICAgaWYgKCEkSURMRG9jdW1lbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgJENvZGVFZGl0b3JDb250ZW50cyA9IFwiXCI7XHJcbiAgICBsZXQgaW5wdXRPYmplY3QgPSB7XHJcbiAgICAgIGN1cnJlbnRMYW5ndWFnZTogJENvZGVFZGl0b3JMYW5ndWFnZSxcclxuICAgICAgSURMRG9jdW1lbnQ6ICRJRExEb2N1bWVudCxcclxuICAgICAgSURMRWRpdG9yQ29udGVudHM6ICRJRExFZGl0b3JDb250ZW50cyxcclxuICAgICAgbG9hZGVkLFxyXG4gICAgICBmbGFnczogW1wiLS1lczYtanMtZXhwb3J0XCIsIFwiLS1nZW4tb25lZmlsZVwiXVxyXG4gICAgfTtcclxuICAgIHdvcmtlckxvYWRlcih3b3JrZXJQYXRoLCBpbnB1dE9iamVjdCwgY2FsbGJhY2spO1xyXG4gIH07XHJcbiAgSURMRG9jdW1lbnQuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgIGNyZWF0ZUNvZGUoKTtcclxuICAgIGlmIChmYWxzZSkgdG9nZ2xlTWVudSgpO1xyXG4gIH0pO1xyXG4gIGNvbnN0IGRvd25sb2FkRmlsZSA9ICgpID0+IHtcclxuICAgIGRvd25sb2FkKCRDb2RlRWRpdG9yQ29udGVudHMsICRDb2RlRWRpdG9yQWN0aXZlRG9jdW1lbnQsIFwidGV4dC9wbGFpblwiKTtcclxuICB9O1xyXG4gIG9uTW91bnQoKCkgPT4ge1xyXG4gICAgaWYgKCEkSURMRG9jdW1lbnQpIHtcclxuICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBcIi9zZWxlY3RcIjtcclxuICAgIH1cclxuICAgIGxvYWRlZCA9ICRJRExEb2N1bWVudCA/IGZhbHNlIDogdHJ1ZTtcclxuICB9KTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcbiAgc2VsZWN0IHtcclxuICAgIC8qYm9yZGVyLXJhZGl1czogMTBweDsqL1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgcGFkZGluZzogMnB4O1xyXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICBvdXRsaW5lOiBub25lO1xyXG4gIH1cclxuICAjdG9wTWVudSB7XHJcbiAgICBkaXNwbGF5OiBncmlkO1xyXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOlxyXG4gICAgICBtaW5tYXgoNTBweCwgMTAwcHgpIG1pbm1heCg1MHB4LCAyMDBweCkgbWlubWF4KDIwcHgsIDEwMHB4KVxyXG4gICAgICBhdXRvO1xyXG4gICAgZ3JpZC1nYXA6IDE1cHg7XHJcbiAgICBwYWRkaW5nOiA1cHg7XHJcbiAgICBoZWlnaHQ6IDQwcHg7XHJcbiAgfVxyXG4gIC5kbEJ0biB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgYWxpZ24tc2VsZjogY2VudGVyO1xyXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcclxuICAgIGhlaWdodDogMTAwJTtcclxuICB9XHJcbiAgLmRsQnRuIGEge1xyXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY2VsZXN0cmFrLWJsdWUpO1xyXG4gICAgcGFkZGluZzogNXB4O1xyXG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcclxuICAgIGZvbnQtc2l6ZTogdmFyKC0tZm9udC1zaXplLXNtKTtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgfVxyXG4gIDpnbG9iYWwoLmVkaXRvckNvZGUpIHtcclxuICAgIGhlaWdodDogY2FsYyg5OS45OXZoIC0gdmFyKC0taGVhZGVyLWhlaWdodCkgLSA0MHB4KTtcclxuICB9XHJcbjwvc3R5bGU+XHJcblxyXG48ZGl2IGlkPVwidG9wTWVudVwiPlxyXG4gIDxzZWxlY3QgYmluZDp2YWx1ZT17JENvZGVFZGl0b3JMYW5ndWFnZX0gb246Y2hhbmdlPXsoKSA9PiBjcmVhdGVDb2RlKCl9PlxyXG4gICAgeyNlYWNoIGxhbmd1YWdlcyBhcyBsYW5ndWFnZX1cclxuICAgICAgPG9wdGlvbiB2YWx1ZT17bGFuZ3VhZ2V9IHNlbGVjdGVkPXtsYW5ndWFnZSA9PT0gJENvZGVFZGl0b3JMYW5ndWFnZX0+XHJcbiAgICAgICAge2xhbmd1YWdlWzFdfVxyXG4gICAgICA8L29wdGlvbj5cclxuICAgIHsvZWFjaH1cclxuICA8L3NlbGVjdD5cclxuICB7I2lmIE9iamVjdC5rZXlzKCRDb2RlRWRpdG9yRG9jdW1lbnRzKS5sZW5ndGggPiAwfVxyXG4gICAgPHNlbGVjdCBiaW5kOnZhbHVlPXskQ29kZUVkaXRvckFjdGl2ZURvY3VtZW50fT5cclxuICAgICAgeyNlYWNoIE9iamVjdC5rZXlzKCRDb2RlRWRpdG9yRG9jdW1lbnRzKS5zb3J0KHNjaGVtYVNvcnQpIGFzIGRvY3VtZW50fVxyXG4gICAgICAgIDxvcHRpb25cclxuICAgICAgICAgIHZhbHVlPXtkb2N1bWVudH1cclxuICAgICAgICAgIHNlbGVjdGVkPXtkb2N1bWVudCA9PT0gJENvZGVFZGl0b3JBY3RpdmVEb2N1bWVudH0+XHJcbiAgICAgICAgICB7ZG9jdW1lbnR9XHJcbiAgICAgICAgPC9vcHRpb24+XHJcbiAgICAgIHsvZWFjaH1cclxuICAgIDwvc2VsZWN0PlxyXG4gICAgPGRpdlxyXG4gICAgICBjbGFzcz1cImRsQnRuXCJcclxuICAgICAgc3R5bGU9XCJqdXN0aWZ5LWNvbnRlbnQ6IGxlZnQ7XCJcclxuICAgICAgb246Y2xpY2s9eygpID0+IGRvd25sb2FkRmlsZSgpfT5cclxuICAgICAgPGEgaHJlZj1cImphdmFzY3JpcHQ6XCI+RG93bmxvYWQ8L2E+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJkbEJ0blwiPlxyXG4gICAgICB7I2lmICRDb2RlRWRpdG9yTGFuZ3VhZ2VbMF19XHJcbiAgICAgICAgPGFcclxuICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXHJcbiAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9mbGF0YnVmZmVycy90cmVlL21hc3Rlci97JENvZGVFZGl0b3JMYW5ndWFnZVszXX1cIj5cclxuICAgICAgICAgIEZCIExJQiAoeyRDb2RlRWRpdG9yTGFuZ3VhZ2VbMF0ucmVwbGFjZSgnLS0nLCAnJykudG9VcHBlckNhc2UoKX0pXHJcbiAgICAgICAgPC9hPlxyXG4gICAgICB7L2lmfVxyXG4gICAgPC9kaXY+XHJcbiAgey9pZn1cclxuPC9kaXY+XHJcbjxFZGl0b3Ige2FyZ3N9IC8+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE4RkUsTUFBTSw0QkFBQyxDQUFDLEFBRU4sU0FBUyxDQUFFLElBQUksQ0FDZixPQUFPLENBQUUsR0FBRyxDQUNaLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLE9BQU8sQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQUNELFFBQVEsNEJBQUMsQ0FBQyxBQUNSLE9BQU8sQ0FBRSxJQUFJLENBQ2IscUJBQXFCLENBQ25CLE9BQU8sSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQztNQUMzRCxJQUFJLENBQ04sUUFBUSxDQUFFLElBQUksQ0FDZCxPQUFPLENBQUUsR0FBRyxDQUNaLE1BQU0sQ0FBRSxJQUFJLEFBQ2QsQ0FBQyxBQUNELE1BQU0sNEJBQUMsQ0FBQyxBQUNOLE9BQU8sQ0FBRSxJQUFJLENBQ2IsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsZUFBZSxDQUFFLFFBQVEsQ0FDekIsTUFBTSxDQUFFLElBQUksQUFDZCxDQUFDLEFBQ0Qsb0JBQU0sQ0FBQyxDQUFDLGNBQUMsQ0FBQyxBQUNSLGVBQWUsQ0FBRSxJQUFJLENBQ3JCLEtBQUssQ0FBRSxLQUFLLENBQ1osZ0JBQWdCLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxDQUN2QyxPQUFPLENBQUUsR0FBRyxDQUNaLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLFNBQVMsQ0FBRSxJQUFJLGNBQWMsQ0FBQyxDQUM5QixPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFdBQVcsQ0FBRSxNQUFNLEFBQ3JCLENBQUMsQUFDTyxXQUFXLEFBQUUsQ0FBQyxBQUNwQixNQUFNLENBQUUsS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxBQUNyRCxDQUFDIn0= */";
    	append_dev(document.head, style);
    }

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    // (135:4) {#each languages as language}
    function create_each_block_1(ctx) {
    	let option;
    	let t0_value = /*language*/ ctx[20][1] + "";
    	let t0;
    	let t1;
    	let option_value_value;
    	let option_selected_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t0 = text(t0_value);
    			t1 = space();
    			option.__value = option_value_value = /*language*/ ctx[20];
    			option.value = option.__value;
    			option.selected = option_selected_value = /*language*/ ctx[20] === /*$CodeEditorLanguage*/ ctx[3];
    			add_location(option, file$3, 135, 6, 3557);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t0);
    			append_dev(option, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$CodeEditorLanguage*/ 8 && option_selected_value !== (option_selected_value = /*language*/ ctx[20] === /*$CodeEditorLanguage*/ ctx[3])) {
    				prop_dev(option, "selected", option_selected_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(135:4) {#each languages as language}",
    		ctx
    	});

    	return block;
    }

    // (141:2) {#if Object.keys($CodeEditorDocuments).length > 0}
    function create_if_block(ctx) {
    	let select;
    	let t0;
    	let div0;
    	let a;
    	let t2;
    	let div1;
    	let dispose;
    	let each_value = Object.keys(/*$CodeEditorDocuments*/ ctx[1]).sort(/*schemaSort*/ ctx[4]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	let if_block = /*$CodeEditorLanguage*/ ctx[3][0] && create_if_block_1(ctx);

    	const block = {
    		c: function create() {
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			div0 = element("div");
    			a = element("a");
    			a.textContent = "Download";
    			t2 = space();
    			div1 = element("div");
    			if (if_block) if_block.c();
    			attr_dev(select, "class", "svelte-i4yx4a");
    			if (/*$CodeEditorActiveDocument*/ ctx[2] === void 0) add_render_callback(() => /*select_change_handler_1*/ ctx[15].call(select));
    			add_location(select, file$3, 141, 4, 3752);
    			attr_dev(a, "href", "javascript:");
    			attr_dev(a, "class", "svelte-i4yx4a");
    			add_location(a, file$3, 154, 6, 4172);
    			attr_dev(div0, "class", "dlBtn svelte-i4yx4a");
    			set_style(div0, "justify-content", "left");
    			add_location(div0, file$3, 150, 4, 4061);
    			attr_dev(div1, "class", "dlBtn svelte-i4yx4a");
    			add_location(div1, file$3, 156, 4, 4224);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, select, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*$CodeEditorActiveDocument*/ ctx[2]);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, a);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			if (if_block) if_block.m(div1, null);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(select, "change", /*select_change_handler_1*/ ctx[15]),
    				listen_dev(div0, "click", /*click_handler*/ ctx[16], false, false, false)
    			];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, $CodeEditorDocuments, schemaSort, $CodeEditorActiveDocument*/ 22) {
    				each_value = Object.keys(/*$CodeEditorDocuments*/ ctx[1]).sort(/*schemaSort*/ ctx[4]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*$CodeEditorActiveDocument*/ 4) {
    				select_option(select, /*$CodeEditorActiveDocument*/ ctx[2]);
    			}

    			if (/*$CodeEditorLanguage*/ ctx[3][0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1(ctx);
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(141:2) {#if Object.keys($CodeEditorDocuments).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (143:6) {#each Object.keys($CodeEditorDocuments).sort(schemaSort) as document}
    function create_each_block$1(ctx) {
    	let option;
    	let t0_value = /*document*/ ctx[17] + "";
    	let t0;
    	let t1;
    	let option_value_value;
    	let option_selected_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t0 = text(t0_value);
    			t1 = space();
    			option.__value = option_value_value = /*document*/ ctx[17];
    			option.value = option.__value;
    			option.selected = option_selected_value = /*document*/ ctx[17] === /*$CodeEditorActiveDocument*/ ctx[2];
    			add_location(option, file$3, 143, 8, 3887);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t0);
    			append_dev(option, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$CodeEditorDocuments*/ 2 && t0_value !== (t0_value = /*document*/ ctx[17] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$CodeEditorDocuments*/ 2 && option_value_value !== (option_value_value = /*document*/ ctx[17])) {
    				prop_dev(option, "__value", option_value_value);
    			}

    			option.value = option.__value;

    			if (dirty & /*$CodeEditorDocuments, $CodeEditorActiveDocument*/ 6 && option_selected_value !== (option_selected_value = /*document*/ ctx[17] === /*$CodeEditorActiveDocument*/ ctx[2])) {
    				prop_dev(option, "selected", option_selected_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(143:6) {#each Object.keys($CodeEditorDocuments).sort(schemaSort) as document}",
    		ctx
    	});

    	return block;
    }

    // (158:6) {#if $CodeEditorLanguage[0]}
    function create_if_block_1(ctx) {
    	let a;
    	let t0;
    	let t1_value = /*$CodeEditorLanguage*/ ctx[3][0].replace("--", "").toUpperCase() + "";
    	let t1;
    	let t2;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t0 = text("FB LIB (");
    			t1 = text(t1_value);
    			t2 = text(")");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "href", a_href_value = "https://github.com/google/flatbuffers/tree/master/" + /*$CodeEditorLanguage*/ ctx[3][3]);
    			attr_dev(a, "class", "svelte-i4yx4a");
    			add_location(a, file$3, 158, 8, 4289);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t0);
    			append_dev(a, t1);
    			append_dev(a, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$CodeEditorLanguage*/ 8 && t1_value !== (t1_value = /*$CodeEditorLanguage*/ ctx[3][0].replace("--", "").toUpperCase() + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*$CodeEditorLanguage*/ 8 && a_href_value !== (a_href_value = "https://github.com/google/flatbuffers/tree/master/" + /*$CodeEditorLanguage*/ ctx[3][3])) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(158:6) {#if $CodeEditorLanguage[0]}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let div;
    	let select;
    	let t0;
    	let show_if = Object.keys(/*$CodeEditorDocuments*/ ctx[1]).length > 0;
    	let t1;
    	let current;
    	let dispose;
    	let each_value_1 = languages;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let if_block = show_if && create_if_block(ctx);

    	const editor = new MonacoEditor({
    			props: { args: /*args*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(editor.$$.fragment);
    			attr_dev(select, "class", "svelte-i4yx4a");
    			if (/*$CodeEditorLanguage*/ ctx[3] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[13].call(select));
    			add_location(select, file$3, 133, 2, 3442);
    			attr_dev(div, "id", "topMenu");
    			attr_dev(div, "class", "svelte-i4yx4a");
    			add_location(div, file$3, 132, 0, 3420);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			append_dev(div, select);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*$CodeEditorLanguage*/ ctx[3]);
    			append_dev(div, t0);
    			if (if_block) if_block.m(div, null);
    			insert_dev(target, t1, anchor);
    			mount_component(editor, target, anchor);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(select, "change", /*select_change_handler*/ ctx[13]),
    				listen_dev(select, "change", /*change_handler*/ ctx[14], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*languages, $CodeEditorLanguage*/ 8) {
    				each_value_1 = languages;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty & /*$CodeEditorLanguage*/ 8) {
    				select_option(select, /*$CodeEditorLanguage*/ ctx[3]);
    			}

    			if (dirty & /*$CodeEditorDocuments*/ 2) show_if = Object.keys(/*$CodeEditorDocuments*/ ctx[1]).length > 0;

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const editor_changes = {};
    			if (dirty & /*args*/ 1) editor_changes.args = /*args*/ ctx[0];
    			editor.$set(editor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t1);
    			destroy_component(editor, detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const workerPath = "/workers/worker.js";

    function instance$3($$self, $$props, $$invalidate) {
    	let $CodeEditorDocuments;
    	let $CodeEditorActiveDocument;
    	let $CodeEditorContents;
    	let $CodeEditorLanguage;
    	let $IDLDocument;
    	let $IDLEditorContents;
    	validate_store(CodeEditorDocuments, "CodeEditorDocuments");
    	component_subscribe($$self, CodeEditorDocuments, $$value => $$invalidate(1, $CodeEditorDocuments = $$value));
    	validate_store(CodeEditorActiveDocument, "CodeEditorActiveDocument");
    	component_subscribe($$self, CodeEditorActiveDocument, $$value => $$invalidate(2, $CodeEditorActiveDocument = $$value));
    	validate_store(CodeEditorContents, "CodeEditorContents");
    	component_subscribe($$self, CodeEditorContents, $$value => $$invalidate(9, $CodeEditorContents = $$value));
    	validate_store(CodeEditorLanguage, "CodeEditorLanguage");
    	component_subscribe($$self, CodeEditorLanguage, $$value => $$invalidate(3, $CodeEditorLanguage = $$value));
    	validate_store(IDLDocument, "IDLDocument");
    	component_subscribe($$self, IDLDocument, $$value => $$invalidate(10, $IDLDocument = $$value));
    	validate_store(IDLEditorContents, "IDLEditorContents");
    	component_subscribe($$self, IDLEditorContents, $$value => $$invalidate(11, $IDLEditorContents = $$value));
    	let { loaded = undefined } = $$props;
    	let { toggleMenu = undefined } = $$props;
    	let { args } = $$props;
    	args._class = "editorCode";

    	const schemaSort = (a, b) => {
    		if (a === b) {
    			return 0;
    		} else if (a.indexOf("schema.json") > -1) {
    			return 1;
    		} else if (b.indexOf("schema.json") > -1) {
    			return -1;
    		} else {
    			return a < b ? 1 : -1;
    		}
    	};

    	set_store_value(CodeEditorLanguage, $CodeEditorLanguage = $CodeEditorLanguage.length
    	? $CodeEditorLanguage
    	: languages[0]);

    	const callback = data => {
    		if (data.error) {
    			alert(data.error);
    			$$invalidate(7, loaded = true);
    			return;
    		}

    		set_store_value(CodeEditorDocuments, $CodeEditorDocuments = data.files);
    		set_store_value(CodeEditorActiveDocument, $CodeEditorActiveDocument = Object.keys(data.files).sort(schemaSort)[0]);
    		$$invalidate(7, loaded = data.loaded);
    	};

    	let createCode = () => {
    		if (!$IDLDocument) {
    			return;
    		}

    		set_store_value(CodeEditorContents, $CodeEditorContents = "");

    		let inputObject = {
    			currentLanguage: $CodeEditorLanguage,
    			IDLDocument: $IDLDocument,
    			IDLEditorContents: $IDLEditorContents,
    			loaded,
    			flags: ["--es6-js-export", "--gen-onefile"]
    		};

    		workerLoader(workerPath, inputObject, callback);
    	};

    	IDLDocument.subscribe(() => {
    		createCode();
    	});

    	const downloadFile = () => {
    		download($CodeEditorContents, $CodeEditorActiveDocument, "text/plain");
    	};

    	onMount(() => {
    		if (!$IDLDocument) {
    			window.location.hash = "/select";
    		}

    		$$invalidate(7, loaded = $IDLDocument ? false : true);
    	});

    	const writable_props = ["loaded", "toggleMenu", "args"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Code> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Code", $$slots, []);

    	function select_change_handler() {
    		$CodeEditorLanguage = select_value(this);
    		CodeEditorLanguage.set($CodeEditorLanguage);
    	}

    	const change_handler = () => createCode();

    	function select_change_handler_1() {
    		$CodeEditorActiveDocument = select_value(this);
    		CodeEditorActiveDocument.set($CodeEditorActiveDocument);
    		$$invalidate(4, schemaSort);
    	}

    	const click_handler = () => downloadFile();

    	$$self.$set = $$props => {
    		if ("loaded" in $$props) $$invalidate(7, loaded = $$props.loaded);
    		if ("toggleMenu" in $$props) $$invalidate(8, toggleMenu = $$props.toggleMenu);
    		if ("args" in $$props) $$invalidate(0, args = $$props.args);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		IDLDocument,
    		IDLEditorContents,
    		CodeEditorDocuments,
    		CodeEditorActiveDocument,
    		CodeEditorContents,
    		CodeEditorLanguage,
    		languages,
    		Editor: MonacoEditor,
    		workerLoader,
    		demangler,
    		loaded,
    		toggleMenu,
    		args,
    		schemaSort,
    		workerPath,
    		callback,
    		createCode,
    		downloadFile,
    		$CodeEditorDocuments,
    		$CodeEditorActiveDocument,
    		$CodeEditorContents,
    		$CodeEditorLanguage,
    		$IDLDocument,
    		$IDLEditorContents
    	});

    	$$self.$inject_state = $$props => {
    		if ("loaded" in $$props) $$invalidate(7, loaded = $$props.loaded);
    		if ("toggleMenu" in $$props) $$invalidate(8, toggleMenu = $$props.toggleMenu);
    		if ("args" in $$props) $$invalidate(0, args = $$props.args);
    		if ("createCode" in $$props) $$invalidate(5, createCode = $$props.createCode);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$CodeEditorDocuments, $CodeEditorActiveDocument*/ 6) {
    			 {
    				let _editorContents = $CodeEditorDocuments[$CodeEditorActiveDocument];
    				let _sFile = Object.keys($CodeEditorDocuments).filter(f => f.indexOf("schema.json") > -1)[0];

    				if (_sFile) {
    					let _schema = JSON.parse($CodeEditorDocuments[_sFile]);
    					let _keys = [];

    					Object.entries(_schema.definitions).forEach(pp => {
    						if (pp[1].hasOwnProperty("properties")) {
    							_keys = _keys.concat(Object.keys(pp[1].properties));
    						}
    					});

    					set_store_value(CodeEditorContents, $CodeEditorContents = demangler(_keys, _editorContents));
    				}
    			}
    		}
    	};

    	return [
    		args,
    		$CodeEditorDocuments,
    		$CodeEditorActiveDocument,
    		$CodeEditorLanguage,
    		schemaSort,
    		createCode,
    		downloadFile,
    		loaded,
    		toggleMenu,
    		$CodeEditorContents,
    		$IDLDocument,
    		$IDLEditorContents,
    		callback,
    		select_change_handler,
    		change_handler,
    		select_change_handler_1,
    		click_handler
    	];
    }

    class Code extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		if (!document.getElementById("svelte-i4yx4a-style")) add_css$2();
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { loaded: 7, toggleMenu: 8, args: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Code",
    			options,
    			id: create_fragment$3.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*args*/ ctx[0] === undefined && !("args" in props)) {
    			console.warn("<Code> was created without expected prop 'args'");
    		}
    	}

    	get loaded() {
    		throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaded(value) {
    		throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleMenu() {
    		throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggleMenu(value) {
    		throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get args() {
    		throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set args(value) {
    		throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var bignumber$1 = createCommonjsModule(function (module) {
    (function (globalObject) {

    /*
     *      bignumber.js v9.0.0
     *      A JavaScript library for arbitrary-precision arithmetic.
     *      https://github.com/MikeMcl/bignumber.js
     *      Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>
     *      MIT Licensed.
     *
     *      BigNumber.prototype methods     |  BigNumber methods
     *                                      |
     *      absoluteValue            abs    |  clone
     *      comparedTo                      |  config               set
     *      decimalPlaces            dp     |      DECIMAL_PLACES
     *      dividedBy                div    |      ROUNDING_MODE
     *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
     *      exponentiatedBy          pow    |      RANGE
     *      integerValue                    |      CRYPTO
     *      isEqualTo                eq     |      MODULO_MODE
     *      isFinite                        |      POW_PRECISION
     *      isGreaterThan            gt     |      FORMAT
     *      isGreaterThanOrEqualTo   gte    |      ALPHABET
     *      isInteger                       |  isBigNumber
     *      isLessThan               lt     |  maximum              max
     *      isLessThanOrEqualTo      lte    |  minimum              min
     *      isNaN                           |  random
     *      isNegative                      |  sum
     *      isPositive                      |
     *      isZero                          |
     *      minus                           |
     *      modulo                   mod    |
     *      multipliedBy             times  |
     *      negated                         |
     *      plus                            |
     *      precision                sd     |
     *      shiftedBy                       |
     *      squareRoot               sqrt   |
     *      toExponential                   |
     *      toFixed                         |
     *      toFormat                        |
     *      toFraction                      |
     *      toJSON                          |
     *      toNumber                        |
     *      toPrecision                     |
     *      toString                        |
     *      valueOf                         |
     *
     */


      var BigNumber,
        isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
        mathceil = Math.ceil,
        mathfloor = Math.floor,

        bignumberError = '[BigNumber Error] ',
        tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

        BASE = 1e14,
        LOG_BASE = 14,
        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
        SQRT_BASE = 1e7,

        // EDITABLE
        // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
        // the arguments to toExponential, toFixed, toFormat, and toPrecision.
        MAX = 1E9;                                   // 0 to MAX_INT32


      /*
       * Create and return a BigNumber constructor.
       */
      function clone(configObject) {
        var div, convertBase, parseNumeric,
          P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
          ONE = new BigNumber(1),


          //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


          // The default values below must be integers within the inclusive ranges stated.
          // The values can also be changed at run-time using BigNumber.set.

          // The maximum number of decimal places for operations involving division.
          DECIMAL_PLACES = 20,                     // 0 to MAX

          // The rounding mode used when rounding to the above decimal places, and when using
          // toExponential, toFixed, toFormat and toPrecision, and round (default value).
          // UP         0 Away from zero.
          // DOWN       1 Towards zero.
          // CEIL       2 Towards +Infinity.
          // FLOOR      3 Towards -Infinity.
          // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
          // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
          // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
          // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
          // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
          ROUNDING_MODE = 4,                       // 0 to 8

          // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

          // The exponent value at and beneath which toString returns exponential notation.
          // Number type: -7
          TO_EXP_NEG = -7,                         // 0 to -MAX

          // The exponent value at and above which toString returns exponential notation.
          // Number type: 21
          TO_EXP_POS = 21,                         // 0 to MAX

          // RANGE : [MIN_EXP, MAX_EXP]

          // The minimum exponent value, beneath which underflow to zero occurs.
          // Number type: -324  (5e-324)
          MIN_EXP = -1e7,                          // -1 to -MAX

          // The maximum exponent value, above which overflow to Infinity occurs.
          // Number type:  308  (1.7976931348623157e+308)
          // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
          MAX_EXP = 1e7,                           // 1 to MAX

          // Whether to use cryptographically-secure random number generation, if available.
          CRYPTO = false,                          // true or false

          // The modulo mode used when calculating the modulus: a mod n.
          // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
          // The remainder (r) is calculated as: r = a - n * q.
          //
          // UP        0 The remainder is positive if the dividend is negative, else is negative.
          // DOWN      1 The remainder has the same sign as the dividend.
          //             This modulo mode is commonly known as 'truncated division' and is
          //             equivalent to (a % n) in JavaScript.
          // FLOOR     3 The remainder has the same sign as the divisor (Python %).
          // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
          // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
          //             The remainder is always positive.
          //
          // The truncated division, floored division, Euclidian division and IEEE 754 remainder
          // modes are commonly used for the modulus operation.
          // Although the other rounding modes can also be used, they may not give useful results.
          MODULO_MODE = 1,                         // 0 to 9

          // The maximum number of significant digits of the result of the exponentiatedBy operation.
          // If POW_PRECISION is 0, there will be unlimited significant digits.
          POW_PRECISION = 0,                    // 0 to MAX

          // The format specification used by the BigNumber.prototype.toFormat method.
          FORMAT = {
            prefix: '',
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ',',
            decimalSeparator: '.',
            fractionGroupSize: 0,
            fractionGroupSeparator: '\xA0',      // non-breaking space
            suffix: ''
          },

          // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
          // '-', '.', whitespace, or repeated character.
          // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
          ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


        //------------------------------------------------------------------------------------------


        // CONSTRUCTOR


        /*
         * The BigNumber constructor and exported function.
         * Create and return a new instance of a BigNumber object.
         *
         * v {number|string|BigNumber} A numeric value.
         * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
         */
        function BigNumber(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str,
            x = this;

          // Enable constructor call without `new`.
          if (!(x instanceof BigNumber)) return new BigNumber(v, b);

          if (b == null) {

            if (v && v._isBigNumber === true) {
              x.s = v.s;

              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }

              return;
            }

            if ((isNum = typeof v == 'number') && v * 0 == 0) {

              // Use `1 / n` to handle minus zero also.
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;

              // Fast path for integers, where n < 2147483648 (2**31).
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++);

                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }

                return;
              }

              str = String(v);
            } else {

              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }

            // Decimal point?
            if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

            // Exponential form?
            if ((i = str.search(/e/i)) > 0) {

              // Determine exponent.
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {

              // Integer.
              e = str.length;
            }

          } else {

            // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
            intCheck(b, 2, ALPHABET.length, 'Base');

            // Allow exponential notation to be used with base 10 argument, while
            // also rounding to DECIMAL_PLACES as with other bases.
            if (b == 10) {
              x = new BigNumber(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }

            str = String(v);

            if (isNum = typeof v == 'number') {

              // Avoid potential interpretation of Infinity and NaN as base 44+ values.
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

              // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
              if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
                throw Error
                 (tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }

            alphabet = ALPHABET.slice(0, b);
            e = i = 0;

            // Check that str is a valid base b number.
            // Don't use RegExp, so alphabet can contain special characters.
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == '.') {

                  // If '.' is not the first character and it has not be found before.
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {

                  // Allow e.g. hexadecimal 'FF' as well as 'ff'.
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                      str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }

                return parseNumeric(x, String(v), isNum, b);
              }
            }

            // Prevent later check for length on converted number.
            isNum = false;
            str = convertBase(str, b, 10, x.s);

            // Decimal point?
            if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
            else e = str.length;
          }

          // Determine leading zeros.
          for (i = 0; str.charCodeAt(i) === 48; i++);

          // Determine trailing zeros.
          for (len = str.length; str.charCodeAt(--len) === 48;);

          if (str = str.slice(i, ++len)) {
            len -= i;

            // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
            if (isNum && BigNumber.DEBUG &&
              len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                throw Error
                 (tooManyDigits + (x.s * v));
            }

             // Overflow?
            if ((e = e - i - 1) > MAX_EXP) {

              // Infinity.
              x.c = x.e = null;

            // Underflow?
            } else if (e < MIN_EXP) {

              // Zero.
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];

              // Transform base

              // e is the base 10 exponent.
              // i is where to slice str to get the first element of the coefficient array.
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;  // i < 1

              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));

                for (len -= LOG_BASE; i < len;) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }

                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }

              for (; i--; str += '0');
              x.c.push(+str);
            }
          } else {

            // Zero.
            x.c = [x.e = 0];
          }
        }


        // CONSTRUCTOR PROPERTIES


        BigNumber.clone = clone;

        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;


        /*
         * Configure infrequently-changing library-wide settings.
         *
         * Accept an object with the following optional properties (if the value of a property is
         * a number, it must be an integer within the inclusive range stated):
         *
         *   DECIMAL_PLACES   {number}           0 to MAX
         *   ROUNDING_MODE    {number}           0 to 8
         *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
         *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
         *   CRYPTO           {boolean}          true or false
         *   MODULO_MODE      {number}           0 to 9
         *   POW_PRECISION       {number}           0 to MAX
         *   ALPHABET         {string}           A string of two or more unique characters which does
         *                                       not contain '.'.
         *   FORMAT           {object}           An object with some of the following properties:
         *     prefix                 {string}
         *     groupSize              {number}
         *     secondaryGroupSize     {number}
         *     groupSeparator         {string}
         *     decimalSeparator       {string}
         *     fractionGroupSize      {number}
         *     fractionGroupSeparator {string}
         *     suffix                 {string}
         *
         * (The values assigned to the above FORMAT object properties are not checked for validity.)
         *
         * E.g.
         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
         *
         * Ignore properties/parameters set to null or undefined, except for ALPHABET.
         *
         * Return an object with the properties current values.
         */
        BigNumber.config = BigNumber.set = function (obj) {
          var p, v;

          if (obj != null) {

            if (typeof obj == 'object') {

              // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
              // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
              if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }

              // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
              // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
              if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }

              // EXPONENTIAL_AT {number|number[]}
              // Integer, -MAX to MAX inclusive or
              // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
              // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
              if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }

              // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
              // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
              // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
              if (obj.hasOwnProperty(p = 'RANGE')) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error
                     (bignumberError + p + ' cannot be zero: ' + v);
                  }
                }
              }

              // CRYPTO {boolean} true or false.
              // '[BigNumber Error] CRYPTO not true or false: {v}'
              // '[BigNumber Error] crypto unavailable'
              if (obj.hasOwnProperty(p = 'CRYPTO')) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != 'undefined' && crypto &&
                     (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error
                       (bignumberError + 'crypto unavailable');
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error
                   (bignumberError + p + ' not true or false: ' + v);
                }
              }

              // MODULO_MODE {number} Integer, 0 to 9 inclusive.
              // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
              if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }

              // POW_PRECISION {number} Integer, 0 to MAX inclusive.
              // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
              if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }

              // FORMAT {object}
              // '[BigNumber Error] FORMAT not an object: {v}'
              if (obj.hasOwnProperty(p = 'FORMAT')) {
                v = obj[p];
                if (typeof v == 'object') FORMAT = v;
                else throw Error
                 (bignumberError + p + ' not an object: ' + v);
              }

              // ALPHABET {string}
              // '[BigNumber Error] ALPHABET invalid: {v}'
              if (obj.hasOwnProperty(p = 'ALPHABET')) {
                v = obj[p];

                // Disallow if only one character,
                // or if it contains '+', '-', '.', whitespace, or a repeated character.
                if (typeof v == 'string' && !/^.$|[+-.\s]|(.).*\1/.test(v)) {
                  ALPHABET = v;
                } else {
                  throw Error
                   (bignumberError + p + ' invalid: ' + v);
                }
              }

            } else {

              // '[BigNumber Error] Object expected: {v}'
              throw Error
               (bignumberError + 'Object expected: ' + obj);
            }
          }

          return {
            DECIMAL_PLACES: DECIMAL_PLACES,
            ROUNDING_MODE: ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO: CRYPTO,
            MODULO_MODE: MODULO_MODE,
            POW_PRECISION: POW_PRECISION,
            FORMAT: FORMAT,
            ALPHABET: ALPHABET
          };
        };


        /*
         * Return true if v is a BigNumber instance, otherwise return false.
         *
         * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
         *
         * v {any}
         *
         * '[BigNumber Error] Invalid BigNumber: {v}'
         */
        BigNumber.isBigNumber = function (v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber.DEBUG) return true;

          var i, n,
            c = v.c,
            e = v.e,
            s = v.s;

          out: if ({}.toString.call(c) == '[object Array]') {

            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

              // If the first element is zero, the BigNumber value must be zero.
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }

              // Calculate number of digits that c[0] should have, based on the exponent.
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;

              // Calculate number of digits of c[0].
              //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
              if (String(c[0]).length == i) {

                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }

                // Last element cannot be zero, unless it is the only element.
                if (n !== 0) return true;
              }
            }

          // Infinity/NaN
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }

          throw Error
            (bignumberError + 'Invalid BigNumber: ' + v);
        };


        /*
         * Return a new BigNumber whose value is the maximum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.maximum = BigNumber.max = function () {
          return maxOrMin(arguments, P.lt);
        };


        /*
         * Return a new BigNumber whose value is the minimum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.minimum = BigNumber.min = function () {
          return maxOrMin(arguments, P.gt);
        };


        /*
         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
         * zeros are produced).
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
         * '[BigNumber Error] crypto unavailable'
         */
        BigNumber.random = (function () {
          var pow2_53 = 0x20000000000000;

          // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
          // Check if Math.random() produces more than 32 bits of randomness.
          // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
          // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
          var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
           ? function () { return mathfloor(Math.random() * pow2_53); }
           : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
             (Math.random() * 0x800000 | 0); };

          return function (dp) {
            var a, b, e, k, v,
              i = 0,
              c = [],
              rand = new BigNumber(ONE);

            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);

            k = mathceil(dp / LOG_BASE);

            if (CRYPTO) {

              // Browsers supporting crypto.getRandomValues.
              if (crypto.getRandomValues) {

                a = crypto.getRandomValues(new Uint32Array(k *= 2));

                for (; i < k;) {

                  // 53 bits:
                  // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                  // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                  // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                  //                                     11111 11111111 11111111
                  // 0x20000 is 2^21.
                  v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                  // Rejection sampling:
                  // 0 <= v < 9007199254740992
                  // Probability that v >= 9e15, is
                  // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {

                    // 0 <= v <= 8999999999999999
                    // 0 <= (v % 1e14) <= 99999999999999
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;

              // Node.js supporting crypto.randomBytes.
              } else if (crypto.randomBytes) {

                // buffer
                a = crypto.randomBytes(k *= 7);

                for (; i < k;) {

                  // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                  // 0x100000000 is 2^32, 0x1000000 is 2^24
                  // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                  // 0 <= v < 9007199254740992
                  v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                     (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                     (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {

                    // 0 <= (v % 1e14) <= 99999999999999
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error
                 (bignumberError + 'crypto unavailable');
              }
            }

            // Use Math.random.
            if (!CRYPTO) {

              for (; i < k;) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }

            k = c[--i];
            dp %= LOG_BASE;

            // Convert trailing digits to zeros according to dp.
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }

            // Remove trailing elements which are zero.
            for (; c[i] === 0; c.pop(), i--);

            // Zero?
            if (i < 0) {
              c = [e = 0];
            } else {

              // Remove leading elements which are zero and adjust exponent accordingly.
              for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

              // Count the digits of the first element of c to determine leading zeros, and...
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

              // adjust the exponent accordingly.
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }

            rand.e = e;
            rand.c = c;
            return rand;
          };
        })();


        /*
         * Return a BigNumber whose value is the sum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.sum = function () {
          var i = 1,
            args = arguments,
            sum = new BigNumber(args[0]);
          for (; i < args.length;) sum = sum.plus(args[i++]);
          return sum;
        };


        // PRIVATE FUNCTIONS


        // Called by BigNumber and BigNumber.prototype.toString.
        convertBase = (function () {
          var decimal = '0123456789';

          /*
           * Convert string of baseIn to an array of numbers of baseOut.
           * Eg. toBaseOut('255', 10, 16) returns [15, 15].
           * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
           */
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j,
              arr = [0],
              arrL,
              i = 0,
              len = str.length;

            for (; i < len;) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

              arr[0] += alphabet.indexOf(str.charAt(i++));

              for (j = 0; j < arr.length; j++) {

                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }

            return arr.reverse();
          }

          // Convert a numeric string of baseIn to a numeric string of baseOut.
          // If the caller is toString, we are converting from base 10 to baseOut.
          // If the caller is BigNumber, we are converting from baseIn to base 10.
          return function (str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y,
              i = str.indexOf('.'),
              dp = DECIMAL_PLACES,
              rm = ROUNDING_MODE;

            // Non-integer.
            if (i >= 0) {
              k = POW_PRECISION;

              // Unlimited precision.
              POW_PRECISION = 0;
              str = str.replace('.', '');
              y = new BigNumber(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;

              // Convert str as if an integer, then restore the fraction part by dividing the
              // result by its base raised to a power.

              y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
               10, baseOut, decimal);
              y.e = y.c.length;
            }

            // Convert the number as integer.

            xc = toBaseOut(str, baseIn, baseOut, callerIsToString
             ? (alphabet = ALPHABET, decimal)
             : (alphabet = decimal, ALPHABET));

            // xc now represents str as an integer and converted to baseOut. e is the exponent.
            e = k = xc.length;

            // Remove trailing zeros.
            for (; xc[--k] == 0; xc.pop());

            // Zero?
            if (!xc[0]) return alphabet.charAt(0);

            // Does str represent an integer? If so, no need for the division.
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;

              // The sign is needed for correct rounding.
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }

            // xc now represents str converted to baseOut.

            // THe index of the rounding digit.
            d = e + dp + 1;

            // The rounding digit: the digit to the right of the digit that may be rounded up.
            i = xc[d];

            // Look at the rounding digits and mode to determine whether to round up.

            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;

            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
                  : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                   rm == (x.s < 0 ? 8 : 7));

            // If the index of the rounding digit is not greater than zero, or xc represents
            // zero, then the result of the base conversion is zero or, if rounding up, a value
            // such as 0.00001.
            if (d < 1 || !xc[0]) {

              // 1^-dp or 0
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {

              // Truncate xc to the required number of decimal places.
              xc.length = d;

              // Round up?
              if (r) {

                // Rounding up may mean the previous digit has to be rounded up and so on.
                for (--baseOut; ++xc[--d] > baseOut;) {
                  xc[d] = 0;

                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }

              // Determine trailing zeros.
              for (k = xc.length; !xc[--k];);

              // E.g. [4, 11, 15] becomes 4bf.
              for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

              // Add leading zeros, decimal point and trailing zeros as required.
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }

            // The caller will add the sign.
            return str;
          };
        })();


        // Perform division in the specified base. Called by div and convertBase.
        div = (function () {

          // Assume non-zero x and k.
          function multiply(x, k, base) {
            var m, temp, xlo, xhi,
              carry = 0,
              i = x.length,
              klo = k % SQRT_BASE,
              khi = k / SQRT_BASE | 0;

            for (x = x.slice(); i--;) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }

            if (carry) x = [carry].concat(x);

            return x;
          }

          function compare(a, b, aL, bL) {
            var i, cmp;

            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {

              for (i = cmp = 0; i < aL; i++) {

                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }

            return cmp;
          }

          function subtract(a, b, aL, base) {
            var i = 0;

            // Subtract b from a.
            for (; aL--;) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }

            // Remove leading zeros.
            for (; !a[0] && a.length > 1; a.splice(0, 1));
          }

          // x: dividend, y: divisor.
          return function (x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
              yL, yz,
              s = x.s == y.s ? 1 : -1,
              xc = x.c,
              yc = y.c;

            // Either NaN, Infinity or 0?
            if (!xc || !xc[0] || !yc || !yc[0]) {

              return new BigNumber(

               // Return NaN if either NaN, or both Infinity or 0.
               !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xc && xc[0] == 0 || !yc ? s * 0 : s / 0
             );
            }

            q = new BigNumber(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;

            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }

            // Result exponent may be one less then the current value of e.
            // The coefficients of the BigNumbers from convertBase may have trailing zeros.
            for (i = 0; yc[i] == (xc[i] || 0); i++);

            if (yc[i] > (xc[i] || 0)) e--;

            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;

              // Normalise xc and yc so highest order digit of yc is >= base / 2.

              n = mathfloor(base / (yc[0] + 1));

              // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
              // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }

              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;

              // Add zeros to make remainder as long as divisor.
              for (; remL < yL; rem[remL++] = 0);
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              // Not necessary, but to prevent trial digit n > base, when using base 3.
              // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

              do {
                n = 0;

                // Compare divisor and remainder.
                cmp = compare(yc, rem, yL, remL);

                // If divisor < remainder.
                if (cmp < 0) {

                  // Calculate trial digit, n.

                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

                  // n is how many times the divisor goes into the current remainder.
                  n = mathfloor(rem0 / yc0);

                  //  Algorithm:
                  //  product = divisor multiplied by trial digit (n).
                  //  Compare product and remainder.
                  //  If product is greater than remainder:
                  //    Subtract divisor from product, decrement trial digit.
                  //  Subtract product from remainder.
                  //  If product was less than remainder at the last compare:
                  //    Compare new remainder and divisor.
                  //    If remainder is greater than divisor:
                  //      Subtract divisor from remainder, increment trial digit.

                  if (n > 1) {

                    // n may be > base only when base is 3.
                    if (n >= base) n = base - 1;

                    // product = divisor * trial digit.
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;

                    // Compare product and remainder.
                    // If product > remainder then trial digit n too high.
                    // n is 1 too high about 5% of the time, and is not known to have
                    // ever been more than 1 too high.
                    while (compare(prod, rem, prodL, remL) == 1) {
                      n--;

                      // Subtract divisor from product.
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {

                    // n is 0 or 1, cmp is -1.
                    // If n is 0, there is no need to compare yc and rem again below,
                    // so change cmp to 1 to avoid it.
                    // If n is 1, leave cmp as -1, so yc and rem are compared again.
                    if (n == 0) {

                      // divisor < remainder, so n must be at least 1.
                      cmp = n = 1;
                    }

                    // product = divisor
                    prod = yc.slice();
                    prodL = prod.length;
                  }

                  if (prodL < remL) prod = [0].concat(prod);

                  // Subtract product from remainder.
                  subtract(rem, prod, remL, base);
                  remL = rem.length;

                   // If product was < remainder.
                  if (cmp == -1) {

                    // Compare divisor and new remainder.
                    // If divisor < new remainder, subtract divisor from remainder.
                    // Trial digit n too low.
                    // n is 1 too low about 5% of the time, and very rarely 2 too low.
                    while (compare(yc, rem, yL, remL) < 1) {
                      n++;

                      // Subtract divisor from remainder.
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                } // else cmp === 1 and n will be 0

                // Add the next digit, n, to the result array.
                qc[i++] = n;

                // Update the remainder.
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);

              more = rem[0] != null;

              // Leading zero?
              if (!qc[0]) qc.splice(0, 1);
            }

            if (base == BASE) {

              // To calculate q.e, first get the number of digits of qc[0].
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

            // Caller is convertBase.
            } else {
              q.e = e;
              q.r = +more;
            }

            return q;
          };
        })();


        /*
         * Return a string representing the value of BigNumber n in fixed-point or exponential
         * notation rounded to the specified decimal places or significant digits.
         *
         * n: a BigNumber.
         * i: the index of the last digit required (i.e. the digit that may be rounded up).
         * rm: the rounding mode.
         * id: 1 (toExponential) or 2 (toPrecision).
         */
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;

          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);

          if (!n.c) return n.toString();

          c0 = n.c[0];
          ne = n.e;

          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
             ? toExponential(str, ne)
             : toFixedPoint(str, ne, '0');
          } else {
            n = round(new BigNumber(n), i, rm);

            // n.e may have changed if the value was rounded up.
            e = n.e;

            str = coeffToString(n.c);
            len = str.length;

            // toPrecision returns exponential notation if the number of significant digits
            // specified is less than the number of digits necessary to represent the integer
            // part of the value in fixed-point notation.

            // Exponential notation.
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

              // Append zeros?
              for (; len < i; str += '0', len++);
              str = toExponential(str, e);

            // Fixed-point notation.
            } else {
              i -= ne;
              str = toFixedPoint(str, e, '0');

              // Append zeros?
              if (e + 1 > len) {
                if (--i > 0) for (str += '.'; i--; str += '0');
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += '.';
                  for (; i--; str += '0');
                }
              }
            }
          }

          return n.s < 0 && c0 ? '-' + str : str;
        }


        // Handle BigNumber.max and BigNumber.min.
        function maxOrMin(args, method) {
          var n,
            i = 1,
            m = new BigNumber(args[0]);

          for (; i < args.length; i++) {
            n = new BigNumber(args[i]);

            // If any number is NaN, return NaN.
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }

          return m;
        }


        /*
         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
         * Called by minus, plus and times.
         */
        function normalise(n, c, e) {
          var i = 1,
            j = c.length;

           // Remove trailing zeros.
          for (; !c[--j]; c.pop());

          // Calculate the base 10 exponent. First get the number of digits of c[0].
          for (j = c[0]; j >= 10; j /= 10, i++);

          // Overflow?
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

            // Infinity.
            n.c = n.e = null;

          // Underflow?
          } else if (e < MIN_EXP) {

            // Zero.
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }

          return n;
        }


        // Handle values that fail the validity test in BigNumber.
        parseNumeric = (function () {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
            dotAfter = /^([^.]+)\.$/,
            dotBefore = /^\.([^.]+)$/,
            isInfinityOrNaN = /^-?(Infinity|NaN)$/,
            whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

          return function (x, str, isNum, b) {
            var base,
              s = isNum ? str : str.replace(whitespaceOrPlus, '');

            // No exception on Infinity or NaN.
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {

                // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                s = s.replace(basePrefix, function (m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });

                if (b) {
                  base = b;

                  // E.g. '1.' to '1', '.1' to '0.1'
                  s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
                }

                if (str != s) return new BigNumber(s, base);
              }

              // '[BigNumber Error] Not a number: {n}'
              // '[BigNumber Error] Not a base {b} number: {n}'
              if (BigNumber.DEBUG) {
                throw Error
                  (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
              }

              // NaN
              x.s = null;
            }

            x.c = x.e = null;
          }
        })();


        /*
         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
         * If r is truthy, it is known that there are more digits after the rounding digit.
         */
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd,
            xc = x.c,
            pows10 = POWS_TEN;

          // if x is not Infinity or NaN...
          if (xc) {

            // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
            // n is a base 1e14 number, the value of the element of array x.c containing rd.
            // ni is the index of n within x.c.
            // d is the number of digits of n.
            // i is the index of rd within n including leading zeros.
            // j is the actual index of rd within n (if < 0, rd is a leading zero).
            out: {

              // Get the number of digits of the first element of xc.
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
              i = sd - d;

              // If the rounding digit is in the first element of xc...
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];

                // Get the rounding digit at index j of n.
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);

                if (ni >= xc.length) {

                  if (r) {

                    // Needed by sqrt.
                    for (; xc.length <= ni; xc.push(0));
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];

                  // Get the number of digits of n.
                  for (d = 1; k >= 10; k /= 10, d++);

                  // Get the index of rd within n.
                  i %= LOG_BASE;

                  // Get the index of rd within n, adjusted for leading zeros.
                  // The number of leading zeros of n is given by LOG_BASE - d.
                  j = i - LOG_BASE + d;

                  // Get the rounding digit at index j of n.
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }

              r = r || sd < 0 ||

              // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
               xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

              r = rm < 4
               ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
               : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

                // Check whether the digit to the left of the rounding digit is odd.
                ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
                 rm == (x.s < 0 ? 8 : 7));

              if (sd < 1 || !xc[0]) {
                xc.length = 0;

                if (r) {

                  // Convert sd to decimal places.
                  sd -= x.e + 1;

                  // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {

                  // Zero.
                  xc[0] = x.e = 0;
                }

                return x;
              }

              // Remove excess digits.
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];

                // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                // j > 0 means i > number of leading zeros of n.
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }

              // Round up?
              if (r) {

                for (; ;) {

                  // If the digit to be rounded up is in the first element of xc...
                  if (ni == 0) {

                    // i will be the length of xc[0] before k is added.
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++);

                    // if i != k the length has increased.
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }

                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }

              // Remove trailing zeros.
              for (i = xc.length; xc[--i] === 0; xc.pop());
            }

            // Overflow? Infinity.
            if (x.e > MAX_EXP) {
              x.c = x.e = null;

            // Underflow? Zero.
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }

          return x;
        }


        function valueOf(n) {
          var str,
            e = n.e;

          if (e === null) return n.toString();

          str = coeffToString(n.c);

          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
            ? toExponential(str, e)
            : toFixedPoint(str, e, '0');

          return n.s < 0 ? '-' + str : str;
        }


        // PROTOTYPE/INSTANCE METHODS


        /*
         * Return a new BigNumber whose value is the absolute value of this BigNumber.
         */
        P.absoluteValue = P.abs = function () {
          var x = new BigNumber(this);
          if (x.s < 0) x.s = 1;
          return x;
        };


        /*
         * Return
         *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
         *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
         *   0 if they have the same value,
         *   or null if the value of either is NaN.
         */
        P.comparedTo = function (y, b) {
          return compare(this, new BigNumber(y, b));
        };


        /*
         * If dp is undefined or null or true or false, return the number of decimal places of the
         * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
         *
         * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
         * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
         * ROUNDING_MODE if rm is omitted.
         *
         * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
         */
        P.decimalPlaces = P.dp = function (dp, rm) {
          var c, n, v,
            x = this;

          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);

            return round(new BigNumber(x), dp + x.e + 1, rm);
          }

          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

          // Subtract the number of trailing zeros of the last number.
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
          if (n < 0) n = 0;

          return n;
        };


        /*
         *  n / 0 = I
         *  n / N = N
         *  n / I = 0
         *  0 / n = 0
         *  0 / 0 = N
         *  0 / N = N
         *  0 / I = 0
         *  N / n = N
         *  N / 0 = N
         *  N / N = N
         *  N / I = N
         *  I / n = I
         *  I / 0 = I
         *  I / N = N
         *  I / I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.dividedBy = P.div = function (y, b) {
          return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };


        /*
         * Return a new BigNumber whose value is the integer part of dividing the value of this
         * BigNumber by the value of BigNumber(y, b).
         */
        P.dividedToIntegerBy = P.idiv = function (y, b) {
          return div(this, new BigNumber(y, b), 0, 1);
        };


        /*
         * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
         *
         * If m is present, return the result modulo m.
         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
         * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
         *
         * The modular power operation works efficiently when x, n, and m are integers, otherwise it
         * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
         *
         * n {number|string|BigNumber} The exponent. An integer.
         * [m] {number|string|BigNumber} The modulus.
         *
         * '[BigNumber Error] Exponent not an integer: {n}'
         */
        P.exponentiatedBy = P.pow = function (n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
            x = this;

          n = new BigNumber(n);

          // Allow NaN and Infinity, but not other non-integers.
          if (n.c && !n.isInteger()) {
            throw Error
              (bignumberError + 'Exponent not an integer: ' + valueOf(n));
          }

          if (m != null) m = new BigNumber(m);

          // Exponent of MAX_SAFE_INTEGER is 15.
          nIsBig = n.e > 14;

          // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

            // The sign of the result of pow when x is negative depends on the evenness of n.
            // If +n overflows to Infinity, the evenness of n would be not be known.
            y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }

          nIsNeg = n.s < 0;

          if (m) {

            // x % m returns NaN if abs(m) is zero, or m is NaN.
            if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

            isModExp = !nIsNeg && x.isInteger() && m.isInteger();

            if (isModExp) x = x.mod(m);

          // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
          // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
            // [1, 240000000]
            ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
            // [80000000000000]  [99999750000000]
            : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

            // If x is negative and n is odd, k = -0, else k = 0.
            k = x.s < 0 && isOdd(n) ? -0 : 0;

            // If x >= 1, k = Infinity.
            if (x.e > -1) k = 1 / k;

            // If n is negative return 0, else return Infinity.
            return new BigNumber(nIsNeg ? 1 / k : k);

          } else if (POW_PRECISION) {

            // Truncating each coefficient array to a length of k after each multiplication
            // equates to truncating significant digits to POW_PRECISION + [28, 41],
            // i.e. there will be a minimum of 28 guard digits retained.
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }

          if (nIsBig) {
            half = new BigNumber(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }

          y = new BigNumber(ONE);

          // Performs 54 loop iterations for n of 9007199254740991.
          for (; ;) {

            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;

              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
              }
            }

            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);

              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }

            x = x.times(x);

            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
            }
          }

          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);

          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
         * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
         */
        P.integerValue = function (rm) {
          var n = new BigNumber(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };


        /*
         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
         * otherwise return false.
         */
        P.isEqualTo = P.eq = function (y, b) {
          return compare(this, new BigNumber(y, b)) === 0;
        };


        /*
         * Return true if the value of this BigNumber is a finite number, otherwise return false.
         */
        P.isFinite = function () {
          return !!this.c;
        };


        /*
         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * otherwise return false.
         */
        P.isGreaterThan = P.gt = function (y, b) {
          return compare(this, new BigNumber(y, b)) > 0;
        };


        /*
         * Return true if the value of this BigNumber is greater than or equal to the value of
         * BigNumber(y, b), otherwise return false.
         */
        P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
          return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

        };


        /*
         * Return true if the value of this BigNumber is an integer, otherwise return false.
         */
        P.isInteger = function () {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };


        /*
         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
         * otherwise return false.
         */
        P.isLessThan = P.lt = function (y, b) {
          return compare(this, new BigNumber(y, b)) < 0;
        };


        /*
         * Return true if the value of this BigNumber is less than or equal to the value of
         * BigNumber(y, b), otherwise return false.
         */
        P.isLessThanOrEqualTo = P.lte = function (y, b) {
          return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
        };


        /*
         * Return true if the value of this BigNumber is NaN, otherwise return false.
         */
        P.isNaN = function () {
          return !this.s;
        };


        /*
         * Return true if the value of this BigNumber is negative, otherwise return false.
         */
        P.isNegative = function () {
          return this.s < 0;
        };


        /*
         * Return true if the value of this BigNumber is positive, otherwise return false.
         */
        P.isPositive = function () {
          return this.s > 0;
        };


        /*
         * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
         */
        P.isZero = function () {
          return !!this.c && this.c[0] == 0;
        };


        /*
         *  n - 0 = n
         *  n - N = N
         *  n - I = -I
         *  0 - n = -n
         *  0 - 0 = 0
         *  0 - N = N
         *  0 - I = -I
         *  N - n = N
         *  N - 0 = N
         *  N - N = N
         *  N - I = N
         *  I - n = I
         *  I - 0 = I
         *  I - N = N
         *  I - I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
         * BigNumber(y, b).
         */
        P.minus = function (y, b) {
          var i, j, t, xLTy,
            x = this,
            a = x.s;

          y = new BigNumber(y, b);
          b = y.s;

          // Either NaN?
          if (!a || !b) return new BigNumber(NaN);

          // Signs differ?
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }

          var xe = x.e / LOG_BASE,
            ye = y.e / LOG_BASE,
            xc = x.c,
            yc = y.c;

          if (!xe || !ye) {

            // Either Infinity?
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

            // Either zero?
            if (!xc[0] || !yc[0]) {

              // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
              return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

               // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
               ROUNDING_MODE == 3 ? -0 : 0);
            }
          }

          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();

          // Determine which is the bigger number.
          if (a = xe - ye) {

            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }

            t.reverse();

            // Prepend zeros to equalise exponents.
            for (b = a; b--; t.push(0));
            t.reverse();
          } else {

            // Exponents equal. Check digit by digit.
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

            for (a = b = 0; b < j; b++) {

              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }

          // x < y? Point xc to the array of the bigger number.
          if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

          b = (j = yc.length) - (i = xc.length);

          // Append zeros to xc if shorter.
          // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
          if (b > 0) for (; b--; xc[i++] = 0);
          b = BASE - 1;

          // Subtract yc from xc.
          for (; j > a;) {

            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b);
              --xc[i];
              xc[j] += BASE;
            }

            xc[j] -= yc[j];
          }

          // Remove leading zeros and adjust exponent accordingly.
          for (; xc[0] == 0; xc.splice(0, 1), --ye);

          // Zero?
          if (!xc[0]) {

            // Following IEEE 754 (2008) 6.3,
            // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }

          // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
          // for finite x and y.
          return normalise(y, xc, ye);
        };


        /*
         *   n % 0 =  N
         *   n % N =  N
         *   n % I =  n
         *   0 % n =  0
         *  -0 % n = -0
         *   0 % 0 =  N
         *   0 % N =  N
         *   0 % I =  0
         *   N % n =  N
         *   N % 0 =  N
         *   N % N =  N
         *   N % I =  N
         *   I % n =  N
         *   I % 0 =  N
         *   I % N =  N
         *   I % I =  N
         *
         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
         */
        P.modulo = P.mod = function (y, b) {
          var q, s,
            x = this;

          y = new BigNumber(y, b);

          // Return NaN if x is Infinity or NaN, or y is NaN or zero.
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber(NaN);

          // Return x if y is Infinity or x is zero.
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber(x);
          }

          if (MODULO_MODE == 9) {

            // Euclidian division: q = sign(y) * floor(x / abs(y))
            // r = x - qy    where  0 <= r < abs(y)
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }

          y = x.minus(q.times(y));

          // To match JavaScript %, ensure sign of zero is sign of dividend.
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

          return y;
        };


        /*
         *  n * 0 = 0
         *  n * N = N
         *  n * I = I
         *  0 * n = 0
         *  0 * 0 = 0
         *  0 * N = N
         *  0 * I = N
         *  N * n = N
         *  N * 0 = N
         *  N * N = N
         *  N * I = N
         *  I * n = I
         *  I * 0 = N
         *  I * N = N
         *  I * I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
         * of BigNumber(y, b).
         */
        P.multipliedBy = P.times = function (y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
            base, sqrtBase,
            x = this,
            xc = x.c,
            yc = (y = new BigNumber(y, b)).c;

          // Either NaN, Infinity or 0?
          if (!xc || !yc || !xc[0] || !yc[0]) {

            // Return NaN if either is NaN, or one is 0 and the other is Infinity.
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;

              // Return Infinity if either is Infinity.
              if (!xc || !yc) {
                y.c = y.e = null;

              // Return 0 if either is 0.
              } else {
                y.c = [0];
                y.e = 0;
              }
            }

            return y;
          }

          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;

          // Ensure xc points to longer array and xcL to its length.
          if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

          // Initialise the result array with zeros.
          for (i = xcL + ycL, zc = []; i--; zc.push(0));

          base = BASE;
          sqrtBase = SQRT_BASE;

          for (i = ycL; --i >= 0;) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;

            for (k = xcL, j = i + k; j > i;) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }

            zc[j] = c;
          }

          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }

          return normalise(y, zc, e);
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber negated,
         * i.e. multiplied by -1.
         */
        P.negated = function () {
          var x = new BigNumber(this);
          x.s = -x.s || null;
          return x;
        };


        /*
         *  n + 0 = n
         *  n + N = N
         *  n + I = I
         *  0 + n = n
         *  0 + 0 = 0
         *  0 + N = N
         *  0 + I = I
         *  N + n = N
         *  N + 0 = N
         *  N + N = N
         *  N + I = N
         *  I + n = I
         *  I + 0 = I
         *  I + N = N
         *  I + I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
         * BigNumber(y, b).
         */
        P.plus = function (y, b) {
          var t,
            x = this,
            a = x.s;

          y = new BigNumber(y, b);
          b = y.s;

          // Either NaN?
          if (!a || !b) return new BigNumber(NaN);

          // Signs differ?
           if (a != b) {
            y.s = -b;
            return x.minus(y);
          }

          var xe = x.e / LOG_BASE,
            ye = y.e / LOG_BASE,
            xc = x.c,
            yc = y.c;

          if (!xe || !ye) {

            // Return Infinity if either Infinity.
            if (!xc || !yc) return new BigNumber(a / 0);

            // Either zero?
            // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
          }

          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();

          // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }

            t.reverse();
            for (; a--; t.push(0));
            t.reverse();
          }

          a = xc.length;
          b = yc.length;

          // Point xc to the longer array, and b to the shorter length.
          if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

          // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
          for (a = 0; b;) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }

          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }

          // No need to check for zero, as +x + +y != 0 && -x + -y != 0
          // ye = MAX_EXP + 1 possible
          return normalise(y, xc, ye);
        };


        /*
         * If sd is undefined or null or true or false, return the number of significant digits of
         * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
         * If sd is true include integer-part trailing zeros in the count.
         *
         * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
         * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
         * ROUNDING_MODE if rm is omitted.
         *
         * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
         *                     boolean: whether to count integer-part trailing zeros: true or false.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
         */
        P.precision = P.sd = function (sd, rm) {
          var c, n, v,
            x = this;

          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);

            return round(new BigNumber(x), sd, rm);
          }

          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;

          if (v = c[v]) {

            // Subtract the number of trailing zeros of the last element.
            for (; v % 10 == 0; v /= 10, n--);

            // Add the number of digits of the first element.
            for (v = c[0]; v >= 10; v /= 10, n++);
          }

          if (sd && x.e + 1 > n) n = x.e + 1;

          return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
         *
         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
         */
        P.shiftedBy = function (k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times('1e' + k);
        };


        /*
         *  sqrt(-n) =  N
         *  sqrt(N) =  N
         *  sqrt(-I) =  N
         *  sqrt(I) =  I
         *  sqrt(0) =  0
         *  sqrt(-0) = -0
         *
         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.squareRoot = P.sqrt = function () {
          var m, n, r, rep, t,
            x = this,
            c = x.c,
            s = x.s,
            e = x.e,
            dp = DECIMAL_PLACES + 4,
            half = new BigNumber('0.5');

          // Negative/NaN/Infinity/zero?
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }

          // Initial estimate.
          s = Math.sqrt(+valueOf(x));

          // Math.sqrt underflow/overflow?
          // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += '0';
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

            if (s == 1 / 0) {
              n = '1e' + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf('e') + 1) + e;
            }

            r = new BigNumber(n);
          } else {
            r = new BigNumber(s + '');
          }

          // Check for zero.
          // r could be zero if MIN_EXP is changed after the this value was created.
          // This would cause a division by zero (x/t) and hence Infinity below, which would cause
          // coeffToString to throw.
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;

            // Newton-Raphson iteration.
            for (; ;) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));

              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

                // The exponent of r may here be one less than the final result exponent,
                // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                // are indexed correctly.
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);

                // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                // iteration.
                if (n == '9999' || !rep && n == '4999') {

                  // On the first iteration only, check to see if rounding up gives the
                  // exact result as the nines may infinitely repeat.
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);

                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }

                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {

                  // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                  // result. If not, then there are further digits and m will be truthy.
                  if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                    // Truncate to the first rounding digit.
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }

                  break;
                }
              }
            }
          }

          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };


        /*
         * Return a string representing the value of this BigNumber in exponential notation and
         * rounded using ROUNDING_MODE to dp fixed decimal places.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
         */
        P.toExponential = function (dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounding
         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
         * but e.g. (-0.00001).toFixed(0) is '-0'.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
         */
        P.toFixed = function (dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounded
         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
         * of the format or FORMAT object (see BigNumber.set).
         *
         * The formatting object may contain some or all of the properties shown below.
         *
         * FORMAT = {
         *   prefix: '',
         *   groupSize: 3,
         *   secondaryGroupSize: 0,
         *   groupSeparator: ',',
         *   decimalSeparator: '.',
         *   fractionGroupSize: 0,
         *   fractionGroupSeparator: '\xA0',      // non-breaking space
         *   suffix: ''
         * };
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         * [format] {object} Formatting options. See FORMAT pbject above.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
         * '[BigNumber Error] Argument not an object: {format}'
         */
        P.toFormat = function (dp, rm, format) {
          var str,
            x = this;

          if (format == null) {
            if (dp != null && rm && typeof rm == 'object') {
              format = rm;
              rm = null;
            } else if (dp && typeof dp == 'object') {
              format = dp;
              dp = rm = null;
            } else {
              format = FORMAT;
            }
          } else if (typeof format != 'object') {
            throw Error
              (bignumberError + 'Argument not an object: ' + format);
          }

          str = x.toFixed(dp, rm);

          if (x.c) {
            var i,
              arr = str.split('.'),
              g1 = +format.groupSize,
              g2 = +format.secondaryGroupSize,
              groupSeparator = format.groupSeparator || '',
              intPart = arr[0],
              fractionPart = arr[1],
              isNeg = x.s < 0,
              intDigits = isNeg ? intPart.slice(1) : intPart,
              len = intDigits.length;

            if (g2) i = g1, g1 = g2, g2 = i, len -= i;

            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = '-' + intPart;
            }

            str = fractionPart
             ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
              ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
               '$&' + (format.fractionGroupSeparator || ''))
              : fractionPart)
             : intPart;
          }

          return (format.prefix || '') + str + (format.suffix || '');
        };


        /*
         * Return an array of two BigNumbers representing the value of this BigNumber as a simple
         * fraction with an integer numerator and an integer denominator.
         * The denominator will be a positive non-zero value less than or equal to the specified
         * maximum denominator. If a maximum denominator is not specified, the denominator will be
         * the lowest value necessary to represent the number exactly.
         *
         * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
         *
         * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
         */
        P.toFraction = function (md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
            x = this,
            xc = x.c;

          if (md != null) {
            n = new BigNumber(md);

            // Throw if md is less than one or is not an integer, unless it is Infinity.
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error
                (bignumberError + 'Argument ' +
                  (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
            }
          }

          if (!xc) return new BigNumber(x);

          d = new BigNumber(ONE);
          n1 = d0 = new BigNumber(ONE);
          d1 = n0 = new BigNumber(ONE);
          s = coeffToString(xc);

          // Determine initial denominator.
          // d is a power of 10 and the minimum max denominator that specifies the value exactly.
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber(s);

          // n0 = d1 = 0
          n0.c[0] = 0;

          for (; ;)  {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }

          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;

          // Determine which fraction is closer to x, n0/d0 or n1/d1
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
              div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

          MAX_EXP = exp;

          return r;
        };


        /*
         * Return the value of this BigNumber converted to a number primitive.
         */
        P.toNumber = function () {
          return +valueOf(this);
        };


        /*
         * Return a string representing the value of this BigNumber rounded to sd significant digits
         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
         * necessary to represent the integer part of the value in fixed-point notation, then use
         * exponential notation.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
         */
        P.toPrecision = function (sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };


        /*
         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
         * TO_EXP_NEG, return exponential notation.
         *
         * [b] {number} Integer, 2 to ALPHABET.length inclusive.
         *
         * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
         */
        P.toString = function (b) {
          var str,
            n = this,
            s = n.s,
            e = n.e;

          // Infinity or NaN?
          if (e === null) {
            if (s) {
              str = 'Infinity';
              if (s < 0) str = '-' + str;
            } else {
              str = 'NaN';
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS
               ? toExponential(coeffToString(n.c), e)
               : toFixedPoint(coeffToString(n.c), e, '0');
            } else if (b === 10) {
              n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, '0');
            } else {
              intCheck(b, 2, ALPHABET.length, 'Base');
              str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
            }

            if (s < 0 && n.c[0]) str = '-' + str;
          }

          return str;
        };


        /*
         * Return as toString, but do not accept a base argument, and include the minus sign for
         * negative zero.
         */
        P.valueOf = P.toJSON = function () {
          return valueOf(this);
        };


        P._isBigNumber = true;

        if (configObject != null) BigNumber.set(configObject);

        return BigNumber;
      }


      // PRIVATE HELPER FUNCTIONS

      // These functions don't need access to variables,
      // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }


      // Return a coefficient array as a string of base 10 digits.
      function coeffToString(a) {
        var s, z,
          i = 1,
          j = a.length,
          r = a[0] + '';

        for (; i < j;) {
          s = a[i++] + '';
          z = LOG_BASE - s.length;
          for (; z--; s = '0' + s);
          r += s;
        }

        // Determine trailing zeros.
        for (j = r.length; r.charCodeAt(--j) === 48;);

        return r.slice(0, j + 1 || 1);
      }


      // Compare the value of BigNumbers x and y.
      function compare(x, y) {
        var a, b,
          xc = x.c,
          yc = y.c,
          i = x.s,
          j = y.s,
          k = x.e,
          l = y.e;

        // Either NaN?
        if (!i || !j) return null;

        a = xc && !xc[0];
        b = yc && !yc[0];

        // Either zero?
        if (a || b) return a ? b ? 0 : -j : i;

        // Signs differ?
        if (i != j) return i;

        a = i < 0;
        b = k == l;

        // Either Infinity?
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

        // Compare exponents.
        if (!b) return k > l ^ a ? 1 : -1;

        j = (k = xc.length) < (l = yc.length) ? k : l;

        // Compare digit by digit.
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }


      /*
       * Check that n is a primitive number, an integer, and in range, otherwise throw.
       */
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error
           (bignumberError + (name || 'Argument') + (typeof n == 'number'
             ? n < min || n > max ? ' out of range: ' : ' not an integer: '
             : ' not a primitive number: ') + String(n));
        }
      }


      // Assumes finite n.
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }


      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
         (e < 0 ? 'e' : 'e+') + e;
      }


      function toFixedPoint(str, e, z) {
        var len, zs;

        // Negative exponent?
        if (e < 0) {

          // Prepend zeros.
          for (zs = z + '.'; ++e; zs += z);
          str = zs + str;

        // Positive exponent
        } else {
          len = str.length;

          // Append zeros.
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z);
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + '.' + str.slice(e);
          }
        }

        return str;
      }


      // EXPORT


      BigNumber = clone();
      BigNumber['default'] = BigNumber.BigNumber = BigNumber;

      // AMD.
      if ( module.exports) {
        module.exports = BigNumber;

      // Browser.
      } else {
        if (!globalObject) {
          globalObject = typeof self != 'undefined' && self ? self : window;
        }

        globalObject.BigNumber = BigNumber;
      }
    })(commonjsGlobal);
    });

    const decimalAssumed = (value) => bignumber("." + value) || 0;

    const whatCentury = (digits) => {
      digits = parseInt(digits);
      return digits || digits === 0 ? (digits < 50 ? "20" : "19") + digits.toString().padStart(2, 0) : null;
    };

    const tle_map = {
      1: {
        NORAD_CAT_ID: [3, 7],
        CLASSIFICATION_TYPE: [8],
        OBJECT_ID: [10, 17],
        EPOCH: [19, 32],
        MEAN_MOTION_DOT: [34, 43],
        MEAN_MOTION_DDOT: [45, 52],
        BSTAR: [54, 61],
        EPHEMERIS_TYPE: [63],
        ELEMENT_SET_NO: [65, 68],
        CHECKSUM: [69],
      },
      2: {
        NORAD_CAT_ID: [3, 7],
        INCLINATION: [9, 16],
        RA_OF_ASC_NODE: [18, 25],
        ECCENTRICITY: [27, 33],
        ARG_OF_PERICENTER: [35, 42],
        MEAN_ANOMALY: [44, 51],
        MEAN_MOTION: [53, 63],
        REV_AT_EPOCH: [64, 68],
        CHECKSUM: [69],
      },
    };

    const tle_transform = {
      BSTAR: (value) => {
        let sign = value.slice(0, 1) === "-" ? -1 : 1;
        let num = value.slice(1, 6);
        let exp = value.slice(6);
        let fpf = 1e32;
        let r = sign * parseInt(num) * Math.pow(10, parseInt(exp));
        return (r * fpf) / (fpf * parseInt("10" + new Array(num.length).join("0")));
      },
      CLASSIFICATION_TYPE: (value) => value,
      OBJECT_ID: (value) => {
        let year = whatCentury(parseInt(value.slice(0, 2)));

        return `${year ? year : "0000"}-${value.slice(2)}`.trim();
      },
      ECCENTRICITY: decimalAssumed,
      MEAN_MOTION_DDOT: (value) => {
        let sign = value.slice(0, 1) === "-" ? -1 : 1;
        return sign * decimalAssumed(value.slice(1));
      },
      EPOCH: (value) => {
        value = value.trim();
        let tA = [whatCentury(value.slice(0, 2)), 0, parseFloat(value.substr(2)), 0, 24, 0, 60, 0, 60, 0, 1000];
        tA.forEach((v, i) => {
          if (i % 2 && i !== 1) {
            tA[i] = Math.floor(tA[i - 1]);
          } else if (i > 2) {
            tA[i] = tA[i] * (tA[i - 2] - tA[i - 1]);
          }
        });
        return new Date(
          Date.UTC.apply(
            0,
            tA.filter((v, i) => {
              return i % 2 || i == 0 || i == tA.length - 1;
            })
          )
        );
      },
    };

    //https://celestrak.com/NORAD/documentation/spacetrk.pdf
    window.bignumber = bignumber$1;


    class lineReader {
      constructor(reader) {
        this.reader = reader;
        this.processLine = (line) => line;

        this.readLines = async () => {
          async function* rr() {
            const utf8Decoder = new TextDecoder("utf-8");
            let leRegex = /[\r\n]{1,2}/gm;

            let { value, done } = await reader.read();
            value = value ? utf8Decoder.decode(value) : "";

            let startIndex = 0;

            for (; ;) {
              let remline = leRegex.exec(value);
              //only progress if there are more lines
              if (!remline) {
                if (done) break;
                //loop through each successive line
                let remainder = value.substr(startIndex);
                ({ value, done } = await reader.read());
                //add more if available
                value = remainder + (value ? utf8Decoder.decode(value) : "");
                startIndex = leRegex.lastIndex = 0;
              } else {
                yield value.substring(startIndex, remline.index);
              }
              startIndex = leRegex.lastIndex;
            }

            if (startIndex < value.length) {
              yield value.substr(startIndex);
            }
          }
          for await (let line of rr(this.reader)) {
            this.processLine(line);
          }
          return new Date();
        };
      }
    }

    class tle extends lineReader {
      constructor(reader) {
        super(reader);
        this.lines = [];
        this._line = [];
        this.processLine = (line) => {
          this._line.push(line);
          let l0 = this._line[0].length;
          let l1 = this._line.length;
          if ((l0 === 24 && l1 === 3) || (l0 >= 68 && l1 === 2)) {
            this.processTLE(this._line);
            this._line = [];
          }
        };
        this.processTLE = (tle) => {
          this.lines.push(tle);
        };
        this.format = {
          RAW: (tle) => tle,
          OMM: (tle) => {
            if (!tle) return;
            let OBJECT_NAME;
            let _OMM = {};
            if (tle.length === 3) {
              OBJECT_NAME = tle[0].trim();
              tle = tle.slice(1, 3);
            }
            tle.forEach((_line, i) => {
              let tt = tle_map[i + 1];
              for (let prop in tt) {
                let tp = tt[prop];
                let _tp = [];
                _tp = tp.length === 2 ? [tp[0] - 1, tp[1]] : [tp[0] - 1, tp[0]];
                let value = _line.substring(_tp[0], _tp[1]);
                _OMM[prop] = (tle_transform[prop] || bignumber$1)(value);
              }
            });
            if (OBJECT_NAME) _OMM.OBJECT_NAME = OBJECT_NAME;
            return _OMM;
          },
        };
      }
    }

    const satcat = class tle extends lineReader {
      constructor(reader) {
        super(reader);
        this.lines = [];
        this.processLine = (line) => {
          this.lines.push(line);
        };

        this.format = {
          RAW: (line) => line,
          SATCAT: (line) => {
            if (line) return;
            let OBJECT_NAME;
            let _OMM = {};
            if (tle.length === 3) {
              OBJECT_NAME = tle[0].trim();
              tle = tle.slice(1, 3);
            }
            tle.forEach((_line, i) => {
              let tt = tle_map[i + 1];
              for (let prop in tt) {
                let tp = tt[prop];
                let _tp = [];
                _tp = tp.length === 2 ? [tp[0] - 1, tp[1]] : [tp[0] - 1, tp[0]];
                let value = _line.substring(_tp[0], _tp[1]);
                _OMM[prop] = (tle_transform[prop] || bignumber$1)(value);
              }
            });
            if (OBJECT_NAME) _OMM.OBJECT_NAME = OBJECT_NAME;
            return _OMM;
          },
        };
      }
    };
    const vcm = null;

    /// @file
    /// @addtogroup flatbuffers_javascript_api
    /// @{
    /// @cond FLATBUFFERS_INTERNAL

    /**
     * @fileoverview
     *
     * Need to suppress 'global this' error so the Node.js export line doesn't cause
     * closure compile to error out.
     * @suppress {globalThis}
     */

    /**
     * @const
     * @namespace
     */
    var flatbuffers = {};

    /**
     * @type {number}
     * @const
     */
    flatbuffers.SIZEOF_SHORT = 2;

    /**
     * @type {number}
     * @const
     */
    flatbuffers.SIZEOF_INT = 4;

    /**
     * @type {number}
     * @const
     */
    flatbuffers.FILE_IDENTIFIER_LENGTH = 4;

    /**
     * @type {number}
     * @const
     */
    flatbuffers.SIZE_PREFIX_LENGTH = 4;

    /**
     * @param {number} low
     * @param {number} high
     * @returns {flatbuffers.Long}
     */
    flatbuffers.createLong = function (low, high) {
      return flatbuffers.Long.create(low, high);
    };

    /**
     * @enum {number}
     */
    flatbuffers.Encoding = {
      UTF8_BYTES: 1,
      UTF16_STRING: 2
    };

    /**
     * @type {Int32Array}
     * @const
     */
    flatbuffers.int32 = new Int32Array(2);

    /**
     * @type {Float32Array}
     * @const
     */
    flatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);

    /**
     * @type {Float64Array}
     * @const
     */
    flatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);

    /**
     * @type {boolean}
     * @const
     */
    flatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

    ////////////////////////////////////////////////////////////////////////////////

    /**
     * @constructor
     * @param {number} low
     * @param {number} high
     */
    flatbuffers.Long = function (low, high) {
      /**
       * @type {number}
       * @const
       */
      this.low = low | 0;

      /**
       * @type {number}
       * @const
       */
      this.high = high | 0;
    };

    /**
     * @param {number} low
     * @param {number} high
     * @returns {!flatbuffers.Long}
     */
    flatbuffers.Long.create = function (low, high) {
      // Special-case zero to avoid GC overhead for default values
      return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);
    };

    /**
     * @returns {number}
     */
    flatbuffers.Long.prototype.toFloat64 = function () {
      return (this.low >>> 0) + this.high * 0x100000000;
    };

    /**
     * @param {flatbuffers.Long} other
     * @returns {boolean}
     */
    flatbuffers.Long.prototype.equals = function (other) {
      return this.low == other.low && this.high == other.high;
    };

    /**
     * @type {!flatbuffers.Long}
     * @const
     */
    flatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);

    /// @endcond
    ////////////////////////////////////////////////////////////////////////////////
    /**
     * Create a FlatBufferBuilder.
     *
     * @constructor
     * @param {number=} opt_initial_size
     */
    flatbuffers.Builder = function (opt_initial_size) {
      if (!opt_initial_size) {
        var initial_size = 1024;
      } else {
        var initial_size = opt_initial_size;
      }

      /**
       * @type {flatbuffers.ByteBuffer}
       * @private
       */
      this.bb = flatbuffers.ByteBuffer.allocate(initial_size);

      /**
       * Remaining space in the ByteBuffer.
       *
       * @type {number}
       * @private
       */
      this.space = initial_size;

      /**
       * Minimum alignment encountered so far.
       *
       * @type {number}
       * @private
       */
      this.minalign = 1;

      /**
       * The vtable for the current table.
       *
       * @type {Array.<number>}
       * @private
       */
      this.vtable = null;

      /**
       * The amount of fields we're actually using.
       *
       * @type {number}
       * @private
       */
      this.vtable_in_use = 0;

      /**
       * Whether we are currently serializing a table.
       *
       * @type {boolean}
       * @private
       */
      this.isNested = false;

      /**
       * Starting offset of the current struct/table.
       *
       * @type {number}
       * @private
       */
      this.object_start = 0;

      /**
       * List of offsets of all vtables.
       *
       * @type {Array.<number>}
       * @private
       */
      this.vtables = [];

      /**
       * For the current vector being built.
       *
       * @type {number}
       * @private
       */
      this.vector_num_elems = 0;

      /**
       * False omits default values from the serialized data
       *
       * @type {boolean}
       * @private
       */
      this.force_defaults = false;
    };

    flatbuffers.Builder.prototype.clear = function () {
      this.bb.clear();
      this.space = this.bb.capacity();
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
    };

    /**
     * In order to save space, fields that are set to their default value
     * don't get serialized into the buffer. Forcing defaults provides a
     * way to manually disable this optimization.
     *
     * @param {boolean} forceDefaults true always serializes default values
     */
    flatbuffers.Builder.prototype.forceDefaults = function (forceDefaults) {
      this.force_defaults = forceDefaults;
    };

    /**
     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
     * called finish(). The actual data starts at the ByteBuffer's current position,
     * not necessarily at 0.
     *
     * @returns {flatbuffers.ByteBuffer}
     */
    flatbuffers.Builder.prototype.dataBuffer = function () {
      return this.bb;
    };

    /**
     * Get the bytes representing the FlatBuffer. Only call this after you've
     * called finish().
     *
     * @returns {!Uint8Array}
     */
    flatbuffers.Builder.prototype.asUint8Array = function () {
      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    };

    /// @cond FLATBUFFERS_INTERNAL
    /**
     * Prepare to write an element of `size` after `additional_bytes` have been
     * written, e.g. if you write a string, you need to align such the int length
     * field is aligned to 4 bytes, and the string data follows it directly. If all
     * you need to do is alignment, `additional_bytes` will be 0.
     *
     * @param {number} size This is the of the new element to write
     * @param {number} additional_bytes The padding size
     */
    flatbuffers.Builder.prototype.prep = function (size, additional_bytes) {
      // Track the biggest thing we've ever aligned to.
      if (size > this.minalign) {
        this.minalign = size;
      }

      // Find the amount of alignment needed such that `size` is properly
      // aligned after `additional_bytes`
      var align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);

      // Reallocate the buffer if needed.
      while (this.space < align_size + size + additional_bytes) {
        var old_buf_size = this.bb.capacity();
        this.bb = flatbuffers.Builder.growByteBuffer(this.bb);
        this.space += this.bb.capacity() - old_buf_size;
      }

      this.pad(align_size);
    };

    /**
     * @param {number} byte_size
     */
    flatbuffers.Builder.prototype.pad = function (byte_size) {
      for (var i = 0; i < byte_size; i++) {
        this.bb.writeInt8(--this.space, 0);
      }
    };

    /**
     * @param {number} value
     */
    flatbuffers.Builder.prototype.writeInt8 = function (value) {
      this.bb.writeInt8(this.space -= 1, value);
    };

    /**
     * @param {number} value
     */
    flatbuffers.Builder.prototype.writeInt16 = function (value) {
      this.bb.writeInt16(this.space -= 2, value);
    };

    /**
     * @param {number} value
     */
    flatbuffers.Builder.prototype.writeInt32 = function (value) {
      this.bb.writeInt32(this.space -= 4, value);
    };

    /**
     * @param {flatbuffers.Long} value
     */
    flatbuffers.Builder.prototype.writeInt64 = function (value) {
      this.bb.writeInt64(this.space -= 8, value);
    };

    /**
     * @param {number} value
     */
    flatbuffers.Builder.prototype.writeFloat32 = function (value) {
      this.bb.writeFloat32(this.space -= 4, value);
    };

    /**
     * @param {number} value
     */
    flatbuffers.Builder.prototype.writeFloat64 = function (value) {
      this.bb.writeFloat64(this.space -= 8, value);
    };
    /// @endcond

    /**
     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param {number} value The `int8` to add the the buffer.
     */
    flatbuffers.Builder.prototype.addInt8 = function (value) {
      this.prep(1, 0);
      this.writeInt8(value);
    };

    /**
     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param {number} value The `int16` to add the the buffer.
     */
    flatbuffers.Builder.prototype.addInt16 = function (value) {
      this.prep(2, 0);
      this.writeInt16(value);
    };

    /**
     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param {number} value The `int32` to add the the buffer.
     */
    flatbuffers.Builder.prototype.addInt32 = function (value) {
      this.prep(4, 0);
      this.writeInt32(value);
    };

    /**
     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param {flatbuffers.Long} value The `int64` to add the the buffer.
     */
    flatbuffers.Builder.prototype.addInt64 = function (value) {
      this.prep(8, 0);
      this.writeInt64(value);
    };

    /**
     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param {number} value The `float32` to add the the buffer.
     */
    flatbuffers.Builder.prototype.addFloat32 = function (value) {
      this.prep(4, 0);
      this.writeFloat32(value);
    };

    /**
     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param {number} value The `float64` to add the the buffer.
     */
    flatbuffers.Builder.prototype.addFloat64 = function (value) {
      this.prep(8, 0);
      this.writeFloat64(value);
    };

    /// @cond FLATBUFFERS_INTERNAL
    /**
     * @param {number} voffset
     * @param {number} value
     * @param {number} defaultValue
     */
    flatbuffers.Builder.prototype.addFieldInt8 = function (voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt8(value);
        this.slot(voffset);
      }
    };

    /**
     * @param {number} voffset
     * @param {number} value
     * @param {number} defaultValue
     */
    flatbuffers.Builder.prototype.addFieldInt16 = function (voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt16(value);
        this.slot(voffset);
      }
    };

    /**
     * @param {number} voffset
     * @param {number} value
     * @param {number} defaultValue
     */
    flatbuffers.Builder.prototype.addFieldInt32 = function (voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt32(value);
        this.slot(voffset);
      }
    };

    /**
     * @param {number} voffset
     * @param {flatbuffers.Long} value
     * @param {flatbuffers.Long} defaultValue
     */
    flatbuffers.Builder.prototype.addFieldInt64 = function (voffset, value, defaultValue) {
      if (this.force_defaults || !value.equals(defaultValue)) {
        this.addInt64(value);
        this.slot(voffset);
      }
    };

    /**
     * @param {number} voffset
     * @param {number} value
     * @param {number} defaultValue
     */
    flatbuffers.Builder.prototype.addFieldFloat32 = function (voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat32(value);
        this.slot(voffset);
      }
    };

    /**
     * @param {number} voffset
     * @param {number} value
     * @param {number} defaultValue
     */
    flatbuffers.Builder.prototype.addFieldFloat64 = function (voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat64(value);
        this.slot(voffset);
      }
    };

    /**
     * @param {number} voffset
     * @param {flatbuffers.Offset} value
     * @param {flatbuffers.Offset} defaultValue
     */
    flatbuffers.Builder.prototype.addFieldOffset = function (voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addOffset(value);
        this.slot(voffset);
      }
    };

    /**
     * Structs are stored inline, so nothing additional is being added. `d` is always 0.
     *
     * @param {number} voffset
     * @param {flatbuffers.Offset} value
     * @param {flatbuffers.Offset} defaultValue
     */
    flatbuffers.Builder.prototype.addFieldStruct = function (voffset, value, defaultValue) {
      if (value != defaultValue) {
        this.nested(value);
        this.slot(voffset);
      }
    };

    /**
     * Structures are always stored inline, they need to be created right
     * where they're used.  You'll get this assertion failure if you
     * created it elsewhere.
     *
     * @param {flatbuffers.Offset} obj The offset of the created object
     */
    flatbuffers.Builder.prototype.nested = function (obj) {
      if (obj != this.offset()) {
        throw new Error('FlatBuffers: struct must be serialized inline.');
      }
    };

    /**
     * Should not be creating any other object, string or vector
     * while an object is being constructed
     */
    flatbuffers.Builder.prototype.notNested = function () {
      if (this.isNested) {
        throw new Error('FlatBuffers: object serialization must not be nested.');
      }
    };

    /**
     * Set the current vtable at `voffset` to the current location in the buffer.
     *
     * @param {number} voffset
     */
    flatbuffers.Builder.prototype.slot = function (voffset) {
      this.vtable[voffset] = this.offset();
    };

    /**
     * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.
     */
    flatbuffers.Builder.prototype.offset = function () {
      return this.bb.capacity() - this.space;
    };

    /**
     * Doubles the size of the backing ByteBuffer and copies the old data towards
     * the end of the new buffer (since we build the buffer backwards).
     *
     * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data
     * @returns {!flatbuffers.ByteBuffer} A new byte buffer with the old data copied
     * to it. The data is located at the end of the buffer.
     *
     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
     * it a uint8Array we need to suppress the type check:
     * @suppress {checkTypes}
     */
    flatbuffers.Builder.growByteBuffer = function (bb) {
      var old_buf_size = bb.capacity();

      // Ensure we don't grow beyond what fits in an int.
      if (old_buf_size & 0xC0000000) {
        throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
      }

      var new_buf_size = old_buf_size << 1;
      var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);
      nbb.setPosition(new_buf_size - old_buf_size);
      nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
      return nbb;
    };
    /// @endcond

    /**
     * Adds on offset, relative to where it will be written.
     *
     * @param {flatbuffers.Offset} offset The offset to add.
     */
    flatbuffers.Builder.prototype.addOffset = function (offset) {
      this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.
      this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);
    };

    /// @cond FLATBUFFERS_INTERNAL
    /**
     * Start encoding a new object in the buffer.  Users will not usually need to
     * call this directly. The FlatBuffers compiler will generate helper methods
     * that call this method internally.
     *
     * @param {number} numfields
     */
    flatbuffers.Builder.prototype.startObject = function (numfields) {
      this.notNested();
      if (this.vtable == null) {
        this.vtable = [];
      }
      this.vtable_in_use = numfields;
      for (var i = 0; i < numfields; i++) {
        this.vtable[i] = 0; // This will push additional elements as needed
      }
      this.isNested = true;
      this.object_start = this.offset();
    };

    /**
     * Finish off writing the object that is under construction.
     *
     * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`
     */
    flatbuffers.Builder.prototype.endObject = function () {
      if (this.vtable == null || !this.isNested) {
        throw new Error('FlatBuffers: endObject called without startObject');
      }

      this.addInt32(0);
      var vtableloc = this.offset();

      // Trim trailing zeroes.
      var i = this.vtable_in_use - 1;
      for (; i >= 0 && this.vtable[i] == 0; i--) { }
      var trimmed_size = i + 1;

      // Write out the current vtable.
      for (; i >= 0; i--) {
        // Offset relative to the start of the table.
        this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
      }

      var standard_fields = 2; // The fields below:
      this.addInt16(vtableloc - this.object_start);
      var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;
      this.addInt16(len);

      // Search for an existing vtable that matches the current one.
      var existing_vtable = 0;
      var vt1 = this.space;
      outer_loop:
      for (i = 0; i < this.vtables.length; i++) {
        var vt2 = this.bb.capacity() - this.vtables[i];
        if (len == this.bb.readInt16(vt2)) {
          for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {
            if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
              continue outer_loop;
            }
          }
          existing_vtable = this.vtables[i];
          break;
        }
      }

      if (existing_vtable) {
        // Found a match:
        // Remove the current vtable.
        this.space = this.bb.capacity() - vtableloc;

        // Point table to existing vtable.
        this.bb.writeInt32(this.space, existing_vtable - vtableloc);
      } else {
        // No match:
        // Add the location of the current vtable to the list of vtables.
        this.vtables.push(this.offset());

        // Point table to current vtable.
        this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
      }

      this.isNested = false;
      return vtableloc;
    };
    /// @endcond

    /**
     * Finalize a buffer, poiting to the given `root_table`.
     *
     * @param {flatbuffers.Offset} root_table
     * @param {string=} opt_file_identifier
     * @param {boolean=} opt_size_prefix
     */
    flatbuffers.Builder.prototype.finish = function (root_table, opt_file_identifier, opt_size_prefix) {
      var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;
      if (opt_file_identifier) {
        var file_identifier = opt_file_identifier;
        this.prep(this.minalign, flatbuffers.SIZEOF_INT +
          flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);
        if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
          throw new Error('FlatBuffers: file identifier must be length ' +
            flatbuffers.FILE_IDENTIFIER_LENGTH);
        }
        for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
          this.writeInt8(file_identifier.charCodeAt(i));
        }
      }
      this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);
      this.addOffset(root_table);
      if (size_prefix) {
        this.addInt32(this.bb.capacity() - this.space);
      }
      this.bb.setPosition(this.space);
    };

    /**
     * Finalize a size prefixed buffer, pointing to the given `root_table`.
     *
     * @param {flatbuffers.Offset} root_table
     * @param {string=} opt_file_identifier
     */
    flatbuffers.Builder.prototype.finishSizePrefixed = function (root_table, opt_file_identifier) {
      this.finish(root_table, opt_file_identifier, true);
    };

    /// @cond FLATBUFFERS_INTERNAL
    /**
     * This checks a required field has been set in a given table that has
     * just been constructed.
     *
     * @param {flatbuffers.Offset} table
     * @param {number} field
     */
    flatbuffers.Builder.prototype.requiredField = function (table, field) {
      var table_start = this.bb.capacity() - table;
      var vtable_start = table_start - this.bb.readInt32(table_start);
      var ok = this.bb.readInt16(vtable_start + field) != 0;

      // If this fails, the caller will show what field needs to be set.
      if (!ok) {
        throw new Error('FlatBuffers: field ' + field + ' must be set');
      }
    };

    /**
     * Start a new array/vector of objects.  Users usually will not call
     * this directly. The FlatBuffers compiler will create a start/end
     * method for vector types in generated code.
     *
     * @param {number} elem_size The size of each element in the array
     * @param {number} num_elems The number of elements in the array
     * @param {number} alignment The alignment of the array
     */
    flatbuffers.Builder.prototype.startVector = function (elem_size, num_elems, alignment) {
      this.notNested();
      this.vector_num_elems = num_elems;
      this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);
      this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.
    };

    /**
     * Finish off the creation of an array and all its elements. The array must be
     * created with `startVector`.
     *
     * @returns {flatbuffers.Offset} The offset at which the newly created array
     * starts.
     */
    flatbuffers.Builder.prototype.endVector = function () {
      this.writeInt32(this.vector_num_elems);
      return this.offset();
    };
    /// @endcond

    /**
     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
     * instead of a string, it is assumed to contain valid UTF-8 encoded data.
     *
     * @param {string|Uint8Array} s The string to encode
     * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts
     */
    flatbuffers.Builder.prototype.createString = function (s) {
      if (s instanceof Uint8Array) {
        var utf8 = s;
      } else {
        var utf8 = [];
        var i = 0;

        while (i < s.length) {
          var codePoint;

          // Decode UTF-16
          var a = s.charCodeAt(i++);
          if (a < 0xD800 || a >= 0xDC00) {
            codePoint = a;
          } else {
            var b = s.charCodeAt(i++);
            codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);
          }

          // Encode UTF-8
          if (codePoint < 0x80) {
            utf8.push(codePoint);
          } else {
            if (codePoint < 0x800) {
              utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);
            } else {
              if (codePoint < 0x10000) {
                utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);
              } else {
                utf8.push(
                  ((codePoint >> 18) & 0x07) | 0xF0,
                  ((codePoint >> 12) & 0x3F) | 0x80);
              }
              utf8.push(((codePoint >> 6) & 0x3F) | 0x80);
            }
            utf8.push((codePoint & 0x3F) | 0x80);
          }
        }
      }

      this.addInt8(0);
      this.startVector(1, utf8.length, 1);
      this.bb.setPosition(this.space -= utf8.length);
      for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
        bytes[offset++] = utf8[i];
      }
      return this.endVector();
    };

    /**
     * A helper function to avoid generated code depending on this file directly.
     *
     * @param {number} low
     * @param {number} high
     * @returns {!flatbuffers.Long}
     */
    flatbuffers.Builder.prototype.createLong = function (low, high) {
      return flatbuffers.Long.create(low, high);
    };

    /**
     * A helper function to pack an object
     * 
     * @returns offset of obj
     */
    flatbuffers.Builder.prototype.createObjectOffset = function (obj) {
      if (obj === null) {
        return 0
      }

      if (typeof obj === 'string') {
        return this.createString(obj);
      } else {
        return obj.pack(this);
      }
    };

    /**
     * A helper function to pack a list of object
     * 
     * @returns list of offsets of each non null object
     */
    flatbuffers.Builder.prototype.createObjectOffsetList = function (list) {
      let ret = [];

      for (let i = 0; i < list.length; ++i) {
        let val = list[i];

        if (val !== null) {
          ret.push(this.createObjectOffset(val));
        } else {
          throw new Error(
            'FlatBuffers: Argument for createObjectOffsetList cannot contain null.');
        }
      }

      return ret;
    };

    flatbuffers.Builder.prototype.createStructOffsetList = function (list, startFunc) {
      startFunc(this, list.length);
      this.createObjectOffsetList(list);
      return this.endVector();
    };

    ////////////////////////////////////////////////////////////////////////////////
    /// @cond FLATBUFFERS_INTERNAL
    /**
     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).
     *
     * @constructor
     * @param {Uint8Array} bytes
     */
    flatbuffers.ByteBuffer = function (bytes) {
      /**
       * @type {Uint8Array}
       * @private
       */
      this.bytes_ = bytes;

      /**
       * @type {number}
       * @private
       */
      this.position_ = 0;
    };

    /**
     * Create and allocate a new ByteBuffer with a given size.
     *
     * @param {number} byte_size
     * @returns {!flatbuffers.ByteBuffer}
     */
    flatbuffers.ByteBuffer.allocate = function (byte_size) {
      return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
    };

    flatbuffers.ByteBuffer.prototype.clear = function () {
      this.position_ = 0;
    };

    /**
     * Get the underlying `Uint8Array`.
     *
     * @returns {Uint8Array}
     */
    flatbuffers.ByteBuffer.prototype.bytes = function () {
      return this.bytes_;
    };

    /**
     * Get the buffer's position.
     *
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.position = function () {
      return this.position_;
    };

    /**
     * Set the buffer's position.
     *
     * @param {number} position
     */
    flatbuffers.ByteBuffer.prototype.setPosition = function (position) {
      this.position_ = position;
    };

    /**
     * Get the buffer's capacity.
     *
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.capacity = function () {
      return this.bytes_.length;
    };

    /**
     * @param {number} offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.readInt8 = function (offset) {
      return this.readUint8(offset) << 24 >> 24;
    };

    /**
     * @param {number} offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.readUint8 = function (offset) {
      return this.bytes_[offset];
    };

    /**
     * @param {number} offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.readInt16 = function (offset) {
      return this.readUint16(offset) << 16 >> 16;
    };

    /**
     * @param {number} offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.readUint16 = function (offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    };

    /**
     * @param {number} offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.readInt32 = function (offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    };

    /**
     * @param {number} offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.readUint32 = function (offset) {
      return this.readInt32(offset) >>> 0;
    };

    /**
     * @param {number} offset
     * @returns {!flatbuffers.Long}
     */
    flatbuffers.ByteBuffer.prototype.readInt64 = function (offset) {
      return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));
    };

    /**
     * @param {number} offset
     * @returns {!flatbuffers.Long}
     */
    flatbuffers.ByteBuffer.prototype.readUint64 = function (offset) {
      return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));
    };

    /**
     * @param {number} offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.readFloat32 = function (offset) {
      flatbuffers.int32[0] = this.readInt32(offset);
      return flatbuffers.float32[0];
    };

    /**
     * @param {number} offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.readFloat64 = function (offset) {
      flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);
      flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
      return flatbuffers.float64[0];
    };

    /**
     * @param {number} offset
     * @param {number|boolean} value
     */
    flatbuffers.ByteBuffer.prototype.writeInt8 = function (offset, value) {
      this.bytes_[offset] = /** @type {number} */(value);
    };

    /**
     * @param {number} offset
     * @param {number} value
     */
    flatbuffers.ByteBuffer.prototype.writeUint8 = function (offset, value) {
      this.bytes_[offset] = value;
    };

    /**
     * @param {number} offset
     * @param {number} value
     */
    flatbuffers.ByteBuffer.prototype.writeInt16 = function (offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    };

    /**
     * @param {number} offset
     * @param {number} value
     */
    flatbuffers.ByteBuffer.prototype.writeUint16 = function (offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    };

    /**
     * @param {number} offset
     * @param {number} value
     */
    flatbuffers.ByteBuffer.prototype.writeInt32 = function (offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    };

    /**
     * @param {number} offset
     * @param {number} value
     */
    flatbuffers.ByteBuffer.prototype.writeUint32 = function (offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    };

    /**
     * @param {number} offset
     * @param {flatbuffers.Long} value
     */
    flatbuffers.ByteBuffer.prototype.writeInt64 = function (offset, value) {
      this.writeInt32(offset, value.low);
      this.writeInt32(offset + 4, value.high);
    };

    /**
     * @param {number} offset
     * @param {flatbuffers.Long} value
     */
    flatbuffers.ByteBuffer.prototype.writeUint64 = function (offset, value) {
      this.writeUint32(offset, value.low);
      this.writeUint32(offset + 4, value.high);
    };

    /**
     * @param {number} offset
     * @param {number} value
     */
    flatbuffers.ByteBuffer.prototype.writeFloat32 = function (offset, value) {
      flatbuffers.float32[0] = value;
      this.writeInt32(offset, flatbuffers.int32[0]);
    };

    /**
     * @param {number} offset
     * @param {number} value
     */
    flatbuffers.ByteBuffer.prototype.writeFloat64 = function (offset, value) {
      flatbuffers.float64[0] = value;
      this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);
      this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);
    };

    /**
     * Return the file identifier.   Behavior is undefined for FlatBuffers whose
     * schema does not include a file_identifier (likely points at padding or the
     * start of a the root vtable).
     * @returns {string}
     */
    flatbuffers.ByteBuffer.prototype.getBufferIdentifier = function () {
      if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +
        flatbuffers.FILE_IDENTIFIER_LENGTH) {
        throw new Error(
          'FlatBuffers: ByteBuffer is too short to contain an identifier.');
      }
      var result = "";
      for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
        result += String.fromCharCode(
          this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));
      }
      return result;
    };

    /**
     * Look up a field in the vtable, return an offset into the object, or 0 if the
     * field is not present.
     *
     * @param {number} bb_pos
     * @param {number} vtable_offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.__offset = function (bb_pos, vtable_offset) {
      var vtable = bb_pos - this.readInt32(bb_pos);
      return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    };

    /**
     * Initialize any Table-derived type to point to the union at the given offset.
     *
     * @param {flatbuffers.Table} t
     * @param {number} offset
     * @returns {flatbuffers.Table}
     */
    flatbuffers.ByteBuffer.prototype.__union = function (t, offset) {
      t.bb_pos = offset + this.readInt32(offset);
      t.bb = this;
      return t;
    };

    /**
     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
     * This allocates a new string and converts to wide chars upon each access.
     *
     * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as
     * the "optionalEncoding" argument. This is useful for avoiding conversion to
     * and from UTF-16 when the data will just be packaged back up in another
     * FlatBuffer later on.
     *
     * @param {number} offset
     * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING
     * @returns {string|!Uint8Array}
     */
    flatbuffers.ByteBuffer.prototype.__string = function (offset, opt_encoding) {
      offset += this.readInt32(offset);

      var length = this.readInt32(offset);
      var result = '';
      var i = 0;

      offset += flatbuffers.SIZEOF_INT;

      if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {
        return this.bytes_.subarray(offset, offset + length);
      }

      while (i < length) {
        var codePoint;

        // Decode UTF-8
        var a = this.readUint8(offset + i++);
        if (a < 0xC0) {
          codePoint = a;
        } else {
          var b = this.readUint8(offset + i++);
          if (a < 0xE0) {
            codePoint =
              ((a & 0x1F) << 6) |
              (b & 0x3F);
          } else {
            var c = this.readUint8(offset + i++);
            if (a < 0xF0) {
              codePoint =
                ((a & 0x0F) << 12) |
                ((b & 0x3F) << 6) |
                (c & 0x3F);
            } else {
              var d = this.readUint8(offset + i++);
              codePoint =
                ((a & 0x07) << 18) |
                ((b & 0x3F) << 12) |
                ((c & 0x3F) << 6) |
                (d & 0x3F);
            }
          }
        }

        // Encode UTF-16
        if (codePoint < 0x10000) {
          result += String.fromCharCode(codePoint);
        } else {
          codePoint -= 0x10000;
          result += String.fromCharCode(
            (codePoint >> 10) + 0xD800,
            (codePoint & ((1 << 10) - 1)) + 0xDC00);
        }
      }

      return result;
    };

    /**
     * Handle unions that can contain string as its member, if a Table-derived type then initialize it, 
     * if a string then return a new one
     * 
     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this 
     * makes the behaviour of __union_with_string different compared to __union
     *
     * @param {flatbuffers.Table|string} o
     * @param {number} offset
     * @returns {flatbuffers.Table|string}
     */
    flatbuffers.ByteBuffer.prototype.__union_with_string = function (o, offset) {
      if (typeof o === 'string') {
        return this.__string(offset);
      }
      return this.__union(o, offset);
    };

    /**
     * Retrieve the relative offset stored at "offset"
     * @param {number} offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.__indirect = function (offset) {
      return offset + this.readInt32(offset);
    };

    /**
     * Get the start of data of a vector whose offset is stored at "offset" in this object.
     *
     * @param {number} offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.__vector = function (offset) {
      return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length
    };

    /**
     * Get the length of a vector whose offset is stored at "offset" in this object.
     *
     * @param {number} offset
     * @returns {number}
     */
    flatbuffers.ByteBuffer.prototype.__vector_len = function (offset) {
      return this.readInt32(offset + this.readInt32(offset));
    };

    /**
     * @param {string} ident
     * @returns {boolean}
     */
    flatbuffers.ByteBuffer.prototype.__has_identifier = function (ident) {
      if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
        throw new Error('FlatBuffers: file identifier must be length ' +
          flatbuffers.FILE_IDENTIFIER_LENGTH);
      }
      for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
        if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {
          return false;
        }
      }
      return true;
    };

    /**
     * A helper function to avoid generated code depending on this file directly.
     *
     * @param {number} low
     * @param {number} high
     * @returns {!flatbuffers.Long}
     */
    flatbuffers.ByteBuffer.prototype.createLong = function (low, high) {
      return flatbuffers.Long.create(low, high);
    };

    /**
     * A helper function for generating list for obj api
     * @param listAccessor function that accepts an index and return data at that index
     * @param {number} listLength
     * @returns {any[]}
     */
    flatbuffers.ByteBuffer.prototype.createScalarList = function (listAccessor, listLength) {
      let ret = [];
      for (let i = 0; i < listLength; ++i) {
        if (listAccessor(i) !== null) {
          ret.push(listAccessor(i));
        }
      }

      return ret;
    };

    /**
     * This function is here only to get around typescript type system
     */
    flatbuffers.ByteBuffer.prototype.createStringList = function (listAccessor, listLength) {
      return this.createScalarList(listAccessor, listLength);
    };

    /**
     * A helper function for generating list for obj api
     * @param listAccessor function that accepts an index and return data at that index
     * @param listLength {number} listLength
     * @param res any[] result list
     */
    flatbuffers.ByteBuffer.prototype.createObjList = function (listAccessor, listLength) {
      let ret = [];
      for (let i = 0; i < listLength; ++i) {
        let val = listAccessor(i);
        if (val !== null) {
          ret.push(val.unpack());
        }
      }

      return ret;
    };

    /// @endcond
    /// @}

    var download$1 = createCommonjsModule(function (module, exports) {
    //download.js v4.2, by dandavis; 2008-2016. [MIT] see http://danml.com/download.html for tests/usage
    // v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime
    // v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs
    // v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.
    // v4 adds AMD/UMD, commonJS, and plain browser support
    // v4.1 adds url download capability via solo URL argument (same domain/CORS only)
    // v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors
    // https://github.com/rndme/download

    (function (root, factory) {
    	{
    		// Node. Does not work with strict CommonJS, but
    		// only CommonJS-like environments that support module.exports,
    		// like Node.
    		module.exports = factory();
    	}
    }(commonjsGlobal, function () {

    	return function download(data, strFileName, strMimeType) {

    		var self = window, // this script is only for browsers anyway...
    			defaultMime = "application/octet-stream", // this default mime also triggers iframe downloads
    			mimeType = strMimeType || defaultMime,
    			payload = data,
    			url = !strFileName && !strMimeType && payload,
    			anchor = document.createElement("a"),
    			toString = function(a){return String(a);},
    			myBlob = (self.Blob || self.MozBlob || self.WebKitBlob || toString),
    			fileName = strFileName || "download",
    			blob,
    			reader;
    			myBlob= myBlob.call ? myBlob.bind(self) : Blob ;
    	  
    		if(String(this)==="true"){ //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback
    			payload=[payload, mimeType];
    			mimeType=payload[0];
    			payload=payload[1];
    		}


    		if(url && url.length< 2048){ // if no filename and no mime, assume a url was passed as the only argument
    			fileName = url.split("/").pop().split("?")[0];
    			anchor.href = url; // assign href prop to temp anchor
    		  	if(anchor.href.indexOf(url) !== -1){ // if the browser determines that it's a potentially valid url path:
            		var ajax=new XMLHttpRequest();
            		ajax.open( "GET", url, true);
            		ajax.responseType = 'blob';
            		ajax.onload= function(e){ 
    				  download(e.target.response, fileName, defaultMime);
    				};
            		setTimeout(function(){ ajax.send();}, 0); // allows setting custom ajax headers using the return:
    			    return ajax;
    			} // end if valid url?
    		} // end if url?


    		//go ahead and download dataURLs right away
    		if(/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(payload)){
    		
    			if(payload.length > (1024*1024*1.999) && myBlob !== toString ){
    				payload=dataUrlToBlob(payload);
    				mimeType=payload.type || defaultMime;
    			}else {			
    				return navigator.msSaveBlob ?  // IE10 can't do a[download], only Blobs:
    					navigator.msSaveBlob(dataUrlToBlob(payload), fileName) :
    					saver(payload) ; // everyone else can save dataURLs un-processed
    			}
    			
    		}else {//not data url, is it a string with special needs?
    			if(/([\x80-\xff])/.test(payload)){			  
    				var i=0, tempUiArr= new Uint8Array(payload.length), mx=tempUiArr.length;
    				for(i;i<mx;++i) tempUiArr[i]= payload.charCodeAt(i);
    			 	payload=new myBlob([tempUiArr], {type: mimeType});
    			}		  
    		}
    		blob = payload instanceof myBlob ?
    			payload :
    			new myBlob([payload], {type: mimeType}) ;


    		function dataUrlToBlob(strUrl) {
    			var parts= strUrl.split(/[:;,]/),
    			type= parts[1],
    			decoder= parts[2] == "base64" ? atob : decodeURIComponent,
    			binData= decoder( parts.pop() ),
    			mx= binData.length,
    			i= 0,
    			uiArr= new Uint8Array(mx);

    			for(i;i<mx;++i) uiArr[i]= binData.charCodeAt(i);

    			return new myBlob([uiArr], {type: type});
    		 }

    		function saver(url, winMode){

    			if ('download' in anchor) { //html5 A[download]
    				anchor.href = url;
    				anchor.setAttribute("download", fileName);
    				anchor.className = "download-js-link";
    				anchor.innerHTML = "downloading...";
    				anchor.style.display = "none";
    				document.body.appendChild(anchor);
    				setTimeout(function() {
    					anchor.click();
    					document.body.removeChild(anchor);
    					if(winMode===true){setTimeout(function(){ self.URL.revokeObjectURL(anchor.href);}, 250 );}
    				}, 66);
    				return true;
    			}

    			// handle non-a[download] safari as best we can:
    			if(/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
    				if(/^data:/.test(url))	url="data:"+url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
    				if(!window.open(url)){ // popup blocked, offer direct download:
    					if(confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")){ location.href=url; }
    				}
    				return true;
    			}

    			//do iframe dataURL download (old ch+FF):
    			var f = document.createElement("iframe");
    			document.body.appendChild(f);

    			if(!winMode && /^data:/.test(url)){ // force a mime that will download:
    				url="data:"+url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
    			}
    			f.src=url;
    			setTimeout(function(){ document.body.removeChild(f); }, 333);

    		}//end saver




    		if (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL)
    			return navigator.msSaveBlob(blob, fileName);
    		}

    		if(self.URL){ // simple fast and modern way using Blob and URL:
    			saver(self.URL.createObjectURL(blob), true);
    		}else {
    			// handle non-Blob()+non-URL browsers:
    			if(typeof blob === "string" || blob.constructor===toString ){
    				try{
    					return saver( "data:" +  mimeType   + ";base64,"  +  self.btoa(blob)  );
    				}catch(y){
    					return saver( "data:" +  mimeType   + "," + encodeURIComponent(blob)  );
    				}
    			}

    			// Blob but not URL support:
    			reader=new FileReader();
    			reader.onload=function(e){
    				saver(this.result);
    			};
    			reader.readAsDataURL(blob);
    		}
    		return true;
    	}; /* end download() */
    }));
    });

    /* src/components/Examples/OMM.svelte generated by Svelte v3.20.1 */

    const { Object: Object_1$1, document: document_1$1 } = globals;
    const file$4 = "src/components/Examples/OMM.svelte";

    function add_css$3() {
    	var style = element("style");
    	style.id = "svelte-1sy1xwz-style";
    	style.textContent = "select.svelte-1sy1xwz.svelte-1sy1xwz{font-size:12px;padding:2px;user-select:none;outline:none}#topMenu.svelte-1sy1xwz.svelte-1sy1xwz{display:grid;grid-template-columns:1fr 1fr;grid-gap:5px;padding:5px}#topMenu.svelte-1sy1xwz>div.svelte-1sy1xwz{display:grid;grid-gap:5px;font-size:var(--font-size-sm);padding:2px;grid-template-columns:minmax(100px, 200px) minmax(35px, 55px)}#right.svelte-1sy1xwz.svelte-1sy1xwz{justify-content:right}#code-top-container.svelte-1sy1xwz.svelte-1sy1xwz{box-sizing:border-box;width:100%;padding:5px;display:grid;grid-template-rows:40px auto 50px;grid-gap:5px}#controls.svelte-1sy1xwz.svelte-1sy1xwz{display:grid;grid-template-columns:auto auto;grid-gap:30px}#page.svelte-1sy1xwz.svelte-1sy1xwz{display:grid;grid-template-columns:1fr 3fr 1fr;grid-gap:10px;font-size:var(--font-size-sm)}#controls.svelte-1sy1xwz #page div.svelte-1sy1xwz{cursor:pointer;display:flex;border:1px #eee solid;align-items:center;justify-content:center;padding:5px}#slider.svelte-1sy1xwz.svelte-1sy1xwz{display:flex;justify-content:center;align-content:center}#slider.svelte-1sy1xwz input.svelte-1sy1xwz{height:1;width:100%}.button.svelte-1sy1xwz.svelte-1sy1xwz{display:flex;align-items:center;justify-content:center;background:var(--celestrak-blue);color:white;height:100%;cursor:pointer}.button.svelte-1sy1xwz.svelte-1sy1xwz:hover{background:#2164bd}div[contenteditable=\"true\"].svelte-1sy1xwz.svelte-1sy1xwz{padding:1px;width:50px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT01NLnN2ZWx0ZSIsInNvdXJjZXMiOlsiT01NLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxyXG4gIGltcG9ydCB7IG9uTW91bnQsIG9uRGVzdHJveSB9IGZyb20gXCJzdmVsdGVcIjtcclxuICBpbXBvcnQgeyB0bGUsIHNhdGNhdCwgdmNtIH0gZnJvbSBcIi4uLy4uLy4uL3BhcnNlcnMvbGVnYWN5Lm1qc1wiO1xyXG4gIGltcG9ydCB7XHJcbiAgICBDb2RlRWRpdG9yRG9jdW1lbnRzLFxyXG4gICAgSURMRWRpdG9yQ29udGVudHMsXHJcbiAgICBJRExEb2N1bWVudFxyXG4gIH0gZnJvbSBcIi4uLy4uL3N0b3Jlcy9GaWxlc1wiO1xyXG4gIGltcG9ydCB3b3JrZXJMb2FkZXIgZnJvbSBcIi4uLy4uL2xpYi93b3JrZXJMb2FkZXIuanNcIjtcclxuICBpbXBvcnQgeyBmbGF0YnVmZmVycyB9IGZyb20gXCIuL2ZsYXRidWZmZXJzLmpzXCI7XHJcbiAgaW1wb3J0IGJpZ251bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XHJcbiAgaW1wb3J0IGRvd25sb2FkIGZyb20gXCJkb3dubG9hZGpzXCI7XHJcblxyXG4gIGNvbnN0IHdvcmtlclBhdGggPSBcIi93b3JrZXJzL3dvcmtlci5qc1wiO1xyXG5cclxuICBleHBvcnQgbGV0IGxvYWRlZDtcclxuICBleHBvcnQgbGV0IGFyZ3M7XHJcbiAgZXhwb3J0IGxldCB0b2dnbGVNZW51O1xyXG5cclxuICBjb25zdCBkb3dubG9hZHMgPSBbXCIuL3Rlc3QvdHdvbGluZS50eHRcIiwgXCIuL3Rlc3QvdGhyZWVsaW5lLnR4dFwiXTtcclxuICBsZXQgY3VycmVudERvd25sb2FkID0gZG93bmxvYWRzWzBdO1xyXG5cclxuICBsZXQgX3dvcmtlcjtcclxuICBsZXQgdGxlcztcclxuICBsZXQgcmF3O1xyXG4gIGxldCBzY2hlbWE7XHJcbiAgbGV0IEZsYXRCdWZmZXIgPSB7fTtcclxuICBsZXQgc3RhcnRMaW5lID0gMDtcclxuICBsZXQgdG90YWwgPSAwO1xyXG4gICQ6IGN1cnJlbnQgPSBNYXRoLm1pbihNYXRoLm1heChjdXJyZW50LCAxKSwgdG90YWwpIHx8IDA7XHJcbiAgbGV0IGN1cnJlbnRWZXJzaW9uID0gXCJSQVdcIjtcclxuICBsZXQgZmlsdGVyZWQgPSBbXTtcclxuICBsZXQgZmlsdGVyID0gXCJcIjtcclxuICBsZXQgdG9maXhlZCA9IG4gPT4ge1xyXG4gICAgaWYgKCFpc05hTihuKSAmJiAodHlwZW9mIG4gPT09IFwibnVtYmVyXCIgfHwgbiBpbnN0YW5jZW9mIGJpZ251bWJlcikpIHtcclxuICAgICAgbGV0IHBsYWNlID0gbiAlIDEgPyAxNSA6IDA7XHJcbiAgICAgIG4gPSBuLnRvRml4ZWQocGxhY2UpO1xyXG4gICAgICBuID0gcGxhY2UgPyBuLnJlcGxhY2UoLzArJC8sIFwiXCIpIDogbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4gPSBuIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbjtcclxuICB9O1xyXG5cclxuICBsZXQgdmVyc2lvbkV4dGVuc2lvbnMgPSB7XHJcbiAgICBSQVc6IFwidHh0XCIsXHJcbiAgICBcIk9NTSAoS0VZIC8gVkFMVUUpXCI6IFwidHh0XCIsXHJcbiAgICBcIk9NTSAoSlNPTilcIjogXCJqc29uXCIsXHJcbiAgICBcIk9NTSAoRkxBVEJVRkZFUilcIjogXCJmYnNcIlxyXG4gIH07XHJcblxyXG4gIGxldCB2ZXJzaW9ucyA9IHtcclxuICAgIFJBVzogdiA9PiAodiA/IHYuam9pbihcIlxcblwiKSA6IFwiXCIpLFxyXG4gICAgXCJPTU0gKEtFWSAvIFZBTFVFKVwiOiB2ID0+IHtcclxuICAgICAgaWYgKCF2KSByZXR1cm47XHJcbiAgICAgIHYgPSB0bGVzLmZvcm1hdC5PTU0odik7XHJcbiAgICAgIGxldCBfdiA9IHt9O1xyXG4gICAgICBsZXQga2V5cyA9IFJlZmxlY3Qub3duS2V5cyhzY2hlbWEuZGVmaW5pdGlvbnMuT01NLnByb3BlcnRpZXMpO1xyXG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICBsZXQga2V5ID0ga2V5c1trXTtcclxuICAgICAgICBfdltrZXldID0gdltrZXldIHx8IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IF9tYXggPVxyXG4gICAgICAgIFJlZmxlY3Qub3duS2V5cyhfdikucmVkdWNlKChwLCBjKSA9PiAocC5sZW5ndGggPiBjLmxlbmd0aCA/IHAgOiBjKSlcclxuICAgICAgICAgIC5sZW5ndGggKyAxO1xyXG4gICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmVudHJpZXMoX3YpXHJcbiAgICAgICAgLm1hcChrdiA9PiB7XHJcbiAgICAgICAgICBsZXQgX3YgPVxyXG4gICAgICAgICAgICBrdlsxXSBpbnN0YW5jZW9mIERhdGVcclxuICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KGt2WzFdKVxyXG4gICAgICAgICAgICAgIDogdG9maXhlZChrdlsxXSkgfHwgXCJudWxsXCI7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGAke2t2WzBdLnBhZEVuZChfbWF4KX0gPSAke192LnRvU3RyaW5nKCkucmVwbGFjZSgvXCIvZywgXCJcIil9YDtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5qb2luKFwiXFxuXCIpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIFwiT01NIChKU09OKVwiOiB2ID0+IHtcclxuICAgICAgaWYgKCF2KSByZXR1cm47XHJcbiAgICAgIHYgPSB0bGVzLmZvcm1hdC5PTU0odik7XHJcbiAgICAgIGxldCBfdiA9IHt9O1xyXG4gICAgICBsZXQga2V5cyA9IFJlZmxlY3Qub3duS2V5cyhzY2hlbWEuZGVmaW5pdGlvbnMuT01NLnByb3BlcnRpZXMpO1xyXG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICBsZXQga2V5ID0ga2V5c1trXTtcclxuICAgICAgICBfdltrZXldID0gdG9maXhlZCh2W2tleV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShfdiwgbnVsbCwgNCkucmVwbGFjZShcclxuICAgICAgICAvXCIoW1xcLStcXHNdP1swLTldK1xcLnswLDF9WzAtOV0qKVwiL2csXHJcbiAgICAgICAgXCIkMVwiXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gICAgXCJPTU0gKEZMQVRCVUZGRVIpXCI6IHYgPT4ge1xyXG4gICAgICBpZiAoIXYpIHJldHVybjtcclxuICAgICAgdiA9IHRsZXMuZm9ybWF0Lk9NTSh2KTtcclxuICAgICAgbGV0IHsgT01NIH0gPSBGbGF0QnVmZmVyO1xyXG4gICAgICBsZXQgYnVpbGRlciA9IG5ldyBmbGF0YnVmZmVycy5CdWlsZGVyKDApO1xyXG4gICAgICBsZXQgc2hpbSA9IE9iamVjdC5rZXlzKHNjaGVtYS5kZWZpbml0aW9ucy5PTU0ucHJvcGVydGllcyk7XHJcbiAgICAgIGxldCBpbnRlcm1lZGlhdGUgPSB7fTtcclxuICAgICAgc2hpbS5mb3JFYWNoKGNhbm9uaWNhbG5hbWUgPT4ge1xyXG4gICAgICAgIGxldCBtYW5nbGVkbmFtZSA9IGNhbm9uaWNhbG5hbWUucmVwbGFjZSgvXy9nLCBcIlwiKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gT01NKSB7XHJcbiAgICAgICAgICBpZiAocHJvcC5pbmRleE9mKG1hbmdsZWRuYW1lKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIGlmICh2W2Nhbm9uaWNhbG5hbWVdIHx8IHZbY2Fub25pY2FsbmFtZV0gPT09IDApIHtcclxuICAgICAgICAgICAgICBsZXQgc2NoZW1hVmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgc2NoZW1hLmRlZmluaXRpb25zLk9NTS5wcm9wZXJ0aWVzW2Nhbm9uaWNhbG5hbWVdO1xyXG4gICAgICAgICAgICAgIGludGVybWVkaWF0ZVtwcm9wXSA9IHsgY2Fub25pY2FsbmFtZSwgbWFuZ2xlZG5hbWUgfTtcclxuICAgICAgICAgICAgICBsZXQgX3ZhbHVlID0gdltjYW5vbmljYWxuYW1lXTtcclxuICAgICAgICAgICAgICBzd2l0Y2ggKHNjaGVtYVZhbHVlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgICAgICAgICAgICAgIF92YWx1ZSA9IGJ1aWxkZXIuY3JlYXRlU3RyaW5nKF92YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVbcHJvcF0udmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT01NLnN0YXJ0T01NKGJ1aWxkZXIpO1xyXG5cclxuICAgICAgZm9yIChsZXQgcHJvcCBpbiBpbnRlcm1lZGlhdGUpIHtcclxuICAgICAgICBPTU1bcHJvcF0oYnVpbGRlciwgaW50ZXJtZWRpYXRlW3Byb3BdLnZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIEJ1aWx0T01NID0gT01NLmVuZE9NTShidWlsZGVyKTtcclxuXHJcbiAgICAgIGJ1aWxkZXIuZmluaXNoKEJ1aWx0T01NKTtcclxuXHJcbiAgICAgIHZhciBidWYgPSBidWlsZGVyLmRhdGFCdWZmZXIoKTtcclxuICAgICAgbGV0IHVpbnQ4ID0gYnVpbGRlci5hc1VpbnQ4QXJyYXkoKTtcclxuICAgICAgdmFyIGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpO1xyXG4gICAgICB2YXIgYjY0ZW5jb2RlZCA9IGJ0b2EoXHJcbiAgICAgICAgdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZXIuZGVjb2RlKHVpbnQ4KSkpXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiB1aW50ODtcclxuICAgIH1cclxuICAgIC8qIFwiT01NIChYTUwpXCI6IHYgPT4ge30qL1xyXG4gIH07XHJcblxyXG4gICQ6IHtcclxuICAgIGlmICh0bGVzICYmIGN1cnJlbnRWZXJzaW9uICYmICFpc05hTihjdXJyZW50KSkge1xyXG4gICAgICBzZXRSYXdUZXh0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAkOiBmaWx0ZXJlZCA9XHJcbiAgICB0bGVzICYmIHRsZXMubGluZXMgJiYgZmlsdGVyLmxlbmd0aFxyXG4gICAgICA/IHRsZXMubGluZXMuZmlsdGVyKHYgPT4gSlNPTi5zdHJpbmdpZnkodikuaW5kZXhPZihmaWx0ZXIpID4gLTEpXHJcbiAgICAgIDogW107XHJcbiAgY29uc3Qgc2V0UmF3VGV4dCA9IGMgPT5cclxuICAgIHRsZXMgJiYgc2NoZW1hXHJcbiAgICAgID8gKHJhdyA9IHZlcnNpb25zW2N1cnJlbnRWZXJzaW9uXSh0bGVzLmxpbmVzW2MgfHwgY3VycmVudF0pKVxyXG4gICAgICA6IG51bGw7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbnZlcnRPYmplY3RzKCkge1xyXG4gICAgbGV0IGlucHV0T2JqZWN0ID0ge1xyXG4gICAgICBjdXJyZW50TGFuZ3VhZ2U6IFtcclxuICAgICAgICBcIi0tanNcIixcclxuICAgICAgICBcIkdlbmVyYXRlIEphdmFTY3JpcHQgY29kZVwiLFxyXG4gICAgICAgIFwianNcIixcclxuICAgICAgICBcImpzXCIsXHJcbiAgICAgICAgXCJ0ZXh0L2phdmFzY3JpcHRcIlxyXG4gICAgICBdLFxyXG4gICAgICBJRExEb2N1bWVudDogXCJKU1RFU1RcIixcclxuICAgICAgSURMRWRpdG9yQ29udGVudHM6ICRJRExFZGl0b3JDb250ZW50cyxcclxuICAgICAgbG9hZGVkXHJcbiAgICB9O1xyXG4gICAgd29ya2VyTG9hZGVyKHdvcmtlclBhdGgsIGlucHV0T2JqZWN0LCBmdW5jdGlvbihkKSB7XHJcbiAgICAgIGxldCBmaWxlID0gT2JqZWN0LmtleXMoZC5maWxlcykuZmlsdGVyKFxyXG4gICAgICAgIGYgPT4gZi5zbGljZShmLmxhc3RJbmRleE9mKFwiLlwiKSkgPT09IFwiLmpzXCJcclxuICAgICAgKTtcclxuICAgICAgbGV0IHNmaWxlID0gT2JqZWN0LmtleXMoZC5maWxlcykuZmlsdGVyKFxyXG4gICAgICAgIGYgPT4gZi5pbmRleE9mKFwic2NoZW1hLmpzb25cIikgPiAtMVxyXG4gICAgICApO1xyXG4gICAgICBuZXcgRnVuY3Rpb24oZC5maWxlc1tmaWxlXSkuYmluZChGbGF0QnVmZmVyKSgpO1xyXG4gICAgICBzY2hlbWEgPSBKU09OLnBhcnNlKGQuZmlsZXNbc2ZpbGVdKTtcclxuICAgICAgc2V0UmF3VGV4dCgpO1xyXG4gICAgICBsb2FkZWQgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGFzeW5jIGZ1bmN0aW9uIGdldERhdGEoKSB7XHJcbiAgICBsb2FkZWQgPSBmYWxzZTtcclxuICAgIHJhdyA9IFwiXCI7XHJcbiAgICBsZXQgaSA9IGRvd25sb2Fkcy5pbmRleE9mKGN1cnJlbnREb3dubG9hZCk7XHJcbiAgICBsZXQgc3RhcnQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goY3VycmVudERvd25sb2FkKTtcclxuICAgIGxldCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xyXG4gICAgdGxlcyA9IG5ldyB0bGUocmVhZGVyKTtcclxuICAgIGxldCBzdG9wID0gYXdhaXQgdGxlcy5yZWFkTGluZXMoKTtcclxuXHJcbiAgICBzZXRSYXdUZXh0KCk7XHJcbiAgICB0b3RhbCA9IHRsZXMubGluZXMubGVuZ3RoIC0gMTtcclxuICAgIGlmICgkSURMRWRpdG9yQ29udGVudHMgJiYgIXNjaGVtYSkge1xyXG4gICAgICBjb252ZXJ0T2JqZWN0cygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbG9hZGVkID0gdHJ1ZTtcclxuICAgICAgc2V0UmF3VGV4dCgpO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCBkb3dubG9hZERhdGEgPSAoKSA9PiB7XHJcbiAgICBpZiAocmF3KSB7XHJcbiAgICAgIGRvd25sb2FkKFxyXG4gICAgICAgIHJhdyxcclxuICAgICAgICBgdGVzdF9vbW0uJHt2ZXJzaW9uRXh0ZW5zaW9uc1tjdXJyZW50VmVyc2lvbl0gfHwgXCJ0eHRcIn1gLFxyXG4gICAgICAgIFwidGV4dC9wbGFpblwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBsZXQgc2l6ZUV2ZW50cyA9IFtcInJlc2l6ZVwiLCBcIm9yaWVudGF0aW9uY2hhbmdlXCJdO1xyXG4gIGxldCBzaXplU2V0ID0gKCkgPT5cclxuICAgIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcclxuICAgICAgXCJjb2RlLXRvcC1jb250YWluZXJcIlxyXG4gICAgKS5zdHlsZS5oZWlnaHQgPSBgY2FsYygke3dpbmRvdy5pbm5lckhlaWdodH1weCAtIHZhcigtLWhlYWRlci1oZWlnaHQpKWApO1xyXG4gIG9uTW91bnQoYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCEkSURMRG9jdW1lbnQpIHtcclxuICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBcIi9zZWxlY3RcIjtcclxuICAgIH1cclxuICAgIHNpemVTZXQoKTtcclxuICAgIHNpemVFdmVudHMuZm9yRWFjaChlID0+IHtcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZSwgc2l6ZVNldCk7XHJcbiAgICB9KTtcclxuICAgIGxvYWRlZCA9IHRydWU7XHJcbiAgfSk7XHJcbiAgb25EZXN0cm95KCgpID0+IHtcclxuICAgIHNpemVFdmVudHMuZm9yRWFjaChlID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgc2l6ZVNldCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcbiAgc2VsZWN0IHtcclxuICAgIC8qYm9yZGVyLXJhZGl1czogMTBweDsqL1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgcGFkZGluZzogMnB4O1xyXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICBvdXRsaW5lOiBub25lO1xyXG4gIH1cclxuICAjdG9wTWVudSB7XHJcbiAgICBkaXNwbGF5OiBncmlkO1xyXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMWZyO1xyXG4gICAgZ3JpZC1nYXA6IDVweDtcclxuICAgIHBhZGRpbmc6IDVweDtcclxuICB9XHJcblxyXG4gICN0b3BNZW51ID4gZGl2IHtcclxuICAgIGRpc3BsYXk6IGdyaWQ7XHJcbiAgICBncmlkLWdhcDogNXB4O1xyXG4gICAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUtc20pO1xyXG4gICAgcGFkZGluZzogMnB4O1xyXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBtaW5tYXgoMTAwcHgsIDIwMHB4KSBtaW5tYXgoMzVweCwgNTVweCk7XHJcbiAgfVxyXG4gICNyaWdodCB7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHJpZ2h0O1xyXG4gIH1cclxuICAjY29kZS10b3AtY29udGFpbmVyIHtcclxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIHBhZGRpbmc6IDVweDtcclxuICAgIGRpc3BsYXk6IGdyaWQ7XHJcbiAgICBncmlkLXRlbXBsYXRlLXJvd3M6IDQwcHggYXV0byA1MHB4O1xyXG4gICAgZ3JpZC1nYXA6IDVweDtcclxuICB9XHJcblxyXG4gICNjb250cm9scyB7XHJcbiAgICBkaXNwbGF5OiBncmlkO1xyXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBhdXRvIGF1dG87XHJcbiAgICBncmlkLWdhcDogMzBweDtcclxuICB9XHJcbiAgI3BhZ2Uge1xyXG4gICAgZGlzcGxheTogZ3JpZDtcclxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDNmciAxZnI7XHJcbiAgICBncmlkLWdhcDogMTBweDtcclxuICAgIGZvbnQtc2l6ZTogdmFyKC0tZm9udC1zaXplLXNtKTtcclxuICB9XHJcbiAgI2NvbnRyb2xzICNwYWdlIGRpdiB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgYm9yZGVyOiAxcHggI2VlZSBzb2xpZDtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgIHBhZGRpbmc6IDVweDtcclxuICB9XHJcbiAgI3NsaWRlciB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XHJcbiAgfVxyXG4gICNzbGlkZXIgaW5wdXQge1xyXG4gICAgaGVpZ2h0OiAxO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgfVxyXG5cclxuICAuYnV0dG9uIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jZWxlc3RyYWstYmx1ZSk7XHJcbiAgICAvKmJvcmRlci1yYWRpdXM6IDVweDsqL1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gIH1cclxuICAuYnV0dG9uOmhvdmVyIHtcclxuICAgIGJhY2tncm91bmQ6ICMyMTY0YmQ7XHJcbiAgfVxyXG4gIGRpdltjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcclxuICAgIHBhZGRpbmc6IDFweDtcclxuICAgIHdpZHRoOiA1MHB4O1xyXG4gIH1cclxuPC9zdHlsZT5cclxuXHJcbjxkaXYgaWQ9XCJjb2RlLXRvcC1jb250YWluZXJcIj5cclxuICA8ZGl2IGlkPVwidG9wTWVudVwiPlxyXG4gICAgPGRpdj5cclxuICAgICAgPHNlbGVjdCBiaW5kOnZhbHVlPXtjdXJyZW50RG93bmxvYWR9PlxyXG4gICAgICAgIHsjZWFjaCBkb3dubG9hZHMgYXMgZG93bmxvYWR9XHJcbiAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtkb3dubG9hZH0gc2VsZWN0ZWQ9e2Rvd25sb2FkID09PSBjdXJyZW50RG93bmxvYWR9PlxyXG4gICAgICAgICAgICB7ZG93bmxvYWR9XHJcbiAgICAgICAgICA8L29wdGlvbj5cclxuICAgICAgICB7L2VhY2h9XHJcbiAgICAgIDwvc2VsZWN0PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uXCIgb246Y2xpY2s9eygpID0+IGdldERhdGEoKX0+R0VUPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgaWQ9XCJyaWdodFwiPlxyXG4gICAgICA8c2VsZWN0IGJpbmQ6dmFsdWU9e2N1cnJlbnRWZXJzaW9ufSBvbjpjaGFuZ2U9eygpID0+IHNldFJhd1RleHQoKX0+XHJcbiAgICAgICAgeyNlYWNoIE9iamVjdC5lbnRyaWVzKHZlcnNpb25zKSBhcyBba2V5LCB2YWx1ZV19XHJcbiAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtrZXl9IHNlbGVjdGVkPXtrZXkgPT09IGN1cnJlbnRWZXJzaW9ufT57a2V5fTwvb3B0aW9uPlxyXG4gICAgICAgIHsvZWFjaH1cclxuICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJidXR0b25cIiBvbjpjbGljaz17KCkgPT4gZG93bmxvYWREYXRhKCl9PkQvTDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbiAgPHRleHRhcmVhIGJpbmQ6dmFsdWU9e3Jhd30gLz5cclxuICA8ZGl2IGlkPVwiY29udHJvbHNcIj5cclxuICAgIDxkaXYgaWQ9XCJwYWdlXCI+XHJcbiAgICAgIDxkaXZcclxuICAgICAgICBjbGFzcz1cImFycm93XCJcclxuICAgICAgICBvbjpjbGljaz17KCkgPT4ge1xyXG4gICAgICAgICAgY3VycmVudCA9IE1hdGgubWF4KDAsIGN1cnJlbnQgLSAxKTtcclxuICAgICAgICB9fT5cclxuICAgICAgICDil4FcclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXY+XHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXHJcbiAgICAgICAgICBiaW5kOnRleHRDb250ZW50PXtjdXJyZW50fVxyXG4gICAgICAgICAgaW5wdXRtb2RlPVwidGV4dFwiIC8+XHJcbiAgICAgICAgL3t0b3RhbH1cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXZcclxuICAgICAgICBjbGFzcz1cImFycm93XCJcclxuICAgICAgICBvbjpjbGljaz17KCkgPT4ge1xyXG4gICAgICAgICAgY3VycmVudCA9IE1hdGgubWluKHRvdGFsLCBjdXJyZW50ICsgMSk7XHJcbiAgICAgICAgfX0+XHJcbiAgICAgICAg4pa3XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGlkPVwic2xpZGVyXCI+XHJcbiAgICAgIDxpbnB1dFxyXG4gICAgICAgIHR5cGU9XCJyYW5nZVwiXHJcbiAgICAgICAgbWluPVwiMVwiXHJcbiAgICAgICAgbWF4PXt0b3RhbH1cclxuICAgICAgICBiaW5kOnZhbHVlPXtjdXJyZW50fVxyXG4gICAgICAgIGNsYXNzPVwic2xpZGVyXCJcclxuICAgICAgICBpZD1cIm15UmFuZ2VcIiAvPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbjwvZGl2PlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBeU9FLE1BQU0sOEJBQUMsQ0FBQyxBQUVOLFNBQVMsQ0FBRSxJQUFJLENBQ2YsT0FBTyxDQUFFLEdBQUcsQ0FDWixXQUFXLENBQUUsSUFBSSxDQUNqQixPQUFPLENBQUUsSUFBSSxBQUNmLENBQUMsQUFDRCxRQUFRLDhCQUFDLENBQUMsQUFDUixPQUFPLENBQUUsSUFBSSxDQUNiLHFCQUFxQixDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQzlCLFFBQVEsQ0FBRSxHQUFHLENBQ2IsT0FBTyxDQUFFLEdBQUcsQUFDZCxDQUFDLEFBRUQsdUJBQVEsQ0FBRyxHQUFHLGVBQUMsQ0FBQyxBQUNkLE9BQU8sQ0FBRSxJQUFJLENBQ2IsUUFBUSxDQUFFLEdBQUcsQ0FDYixTQUFTLENBQUUsSUFBSSxjQUFjLENBQUMsQ0FDOUIsT0FBTyxDQUFFLEdBQUcsQ0FDWixxQkFBcUIsQ0FBRSxPQUFPLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEFBQ2hFLENBQUMsQUFDRCxNQUFNLDhCQUFDLENBQUMsQUFDTixlQUFlLENBQUUsS0FBSyxBQUN4QixDQUFDLEFBQ0QsbUJBQW1CLDhCQUFDLENBQUMsQUFDbkIsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsS0FBSyxDQUFFLElBQUksQ0FDWCxPQUFPLENBQUUsR0FBRyxDQUNaLE9BQU8sQ0FBRSxJQUFJLENBQ2Isa0JBQWtCLENBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQ2xDLFFBQVEsQ0FBRSxHQUFHLEFBQ2YsQ0FBQyxBQUVELFNBQVMsOEJBQUMsQ0FBQyxBQUNULE9BQU8sQ0FBRSxJQUFJLENBQ2IscUJBQXFCLENBQUUsSUFBSSxDQUFDLElBQUksQ0FDaEMsUUFBUSxDQUFFLElBQUksQUFDaEIsQ0FBQyxBQUNELEtBQUssOEJBQUMsQ0FBQyxBQUNMLE9BQU8sQ0FBRSxJQUFJLENBQ2IscUJBQXFCLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQ2xDLFFBQVEsQ0FBRSxJQUFJLENBQ2QsU0FBUyxDQUFFLElBQUksY0FBYyxDQUFDLEFBQ2hDLENBQUMsQUFDRCx3QkFBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLGVBQUMsQ0FBQyxBQUNuQixNQUFNLENBQUUsT0FBTyxDQUNmLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUN0QixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxDQUN2QixPQUFPLENBQUUsR0FBRyxBQUNkLENBQUMsQUFDRCxPQUFPLDhCQUFDLENBQUMsQUFDUCxPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLGFBQWEsQ0FBRSxNQUFNLEFBQ3ZCLENBQUMsQUFDRCxzQkFBTyxDQUFDLEtBQUssZUFBQyxDQUFDLEFBQ2IsTUFBTSxDQUFFLENBQUMsQ0FDVCxLQUFLLENBQUUsSUFBSSxBQUNiLENBQUMsQUFFRCxPQUFPLDhCQUFDLENBQUMsQUFDUCxPQUFPLENBQUUsSUFBSSxDQUNiLFdBQVcsQ0FBRSxNQUFNLENBQ25CLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFVBQVUsQ0FBRSxJQUFJLGdCQUFnQixDQUFDLENBRWpDLEtBQUssQ0FBRSxLQUFLLENBQ1osTUFBTSxDQUFFLElBQUksQ0FDWixNQUFNLENBQUUsT0FBTyxBQUNqQixDQUFDLEFBQ0QscUNBQU8sTUFBTSxBQUFDLENBQUMsQUFDYixVQUFVLENBQUUsT0FBTyxBQUNyQixDQUFDLEFBQ0QsR0FBRyxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsOEJBQUMsQ0FBQyxBQUMzQixPQUFPLENBQUUsR0FBRyxDQUNaLEtBQUssQ0FBRSxJQUFJLEFBQ2IsQ0FBQyJ9 */";
    	append_dev(document_1$1.head, style);
    }

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[37] = list[i][0];
    	child_ctx[38] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[41] = list[i];
    	return child_ctx;
    }

    // (319:8) {#each downloads as download}
    function create_each_block_1$1(ctx) {
    	let option;
    	let t0_value = /*download*/ ctx[41] + "";
    	let t0;
    	let t1;
    	let option_value_value;
    	let option_selected_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t0 = text(t0_value);
    			t1 = space();
    			option.__value = option_value_value = /*download*/ ctx[41];
    			option.value = option.__value;
    			option.selected = option_selected_value = /*download*/ ctx[41] === /*currentDownload*/ ctx[0];
    			add_location(option, file$4, 319, 10, 8261);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t0);
    			append_dev(option, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*currentDownload*/ 1 && option_selected_value !== (option_selected_value = /*download*/ ctx[41] === /*currentDownload*/ ctx[0])) {
    				prop_dev(option, "selected", option_selected_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(319:8) {#each downloads as download}",
    		ctx
    	});

    	return block;
    }

    // (329:8) {#each Object.entries(versions) as [key, value]}
    function create_each_block$2(ctx) {
    	let option;
    	let t_value = /*key*/ ctx[37] + "";
    	let t;
    	let option_value_value;
    	let option_selected_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*key*/ ctx[37];
    			option.value = option.__value;
    			option.selected = option_selected_value = /*key*/ ctx[37] === /*currentVersion*/ ctx[3];
    			add_location(option, file$4, 329, 10, 8648);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*currentVersion*/ 8 && option_selected_value !== (option_selected_value = /*key*/ ctx[37] === /*currentVersion*/ ctx[3])) {
    				prop_dev(option, "selected", option_selected_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(329:8) {#each Object.entries(versions) as [key, value]}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let div12;
    	let div4;
    	let div1;
    	let select0;
    	let t0;
    	let div0;
    	let t2;
    	let div3;
    	let select1;
    	let t3;
    	let div2;
    	let t5;
    	let textarea;
    	let t6;
    	let div11;
    	let div9;
    	let div5;
    	let t8;
    	let div7;
    	let div6;
    	let t9;
    	let t10;
    	let t11;
    	let div8;
    	let t13;
    	let div10;
    	let input;
    	let dispose;
    	let each_value_1 = /*downloads*/ ctx[5];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	let each_value = Object.entries(/*versions*/ ctx[6]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div12 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			select0 = element("select");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t0 = space();
    			div0 = element("div");
    			div0.textContent = "GET";
    			t2 = space();
    			div3 = element("div");
    			select1 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "D/L";
    			t5 = space();
    			textarea = element("textarea");
    			t6 = space();
    			div11 = element("div");
    			div9 = element("div");
    			div5 = element("div");
    			div5.textContent = "";
    			t8 = space();
    			div7 = element("div");
    			div6 = element("div");
    			t9 = text("\r\n        /");
    			t10 = text(/*total*/ ctx[2]);
    			t11 = space();
    			div8 = element("div");
    			div8.textContent = "";
    			t13 = space();
    			div10 = element("div");
    			input = element("input");
    			attr_dev(select0, "class", "svelte-1sy1xwz");
    			if (/*currentDownload*/ ctx[0] === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[27].call(select0));
    			add_location(select0, file$4, 317, 6, 8173);
    			attr_dev(div0, "class", "button svelte-1sy1xwz");
    			add_location(div0, file$4, 324, 6, 8413);
    			attr_dev(div1, "class", "svelte-1sy1xwz");
    			add_location(div1, file$4, 316, 4, 8160);
    			attr_dev(select1, "class", "svelte-1sy1xwz");
    			if (/*currentVersion*/ ctx[3] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[29].call(select1));
    			add_location(select1, file$4, 327, 6, 8511);
    			attr_dev(div2, "class", "button svelte-1sy1xwz");
    			add_location(div2, file$4, 332, 6, 8758);
    			attr_dev(div3, "id", "right");
    			attr_dev(div3, "class", "svelte-1sy1xwz");
    			add_location(div3, file$4, 326, 4, 8487);
    			attr_dev(div4, "id", "topMenu");
    			attr_dev(div4, "class", "svelte-1sy1xwz");
    			add_location(div4, file$4, 315, 2, 8136);
    			add_location(textarea, file$4, 335, 2, 8845);
    			attr_dev(div5, "class", "arrow svelte-1sy1xwz");
    			add_location(div5, file$4, 338, 6, 8926);
    			attr_dev(div6, "contenteditable", "true");
    			attr_dev(div6, "inputmode", "text");
    			attr_dev(div6, "class", "svelte-1sy1xwz");
    			if (/*current*/ ctx[4] === void 0) add_render_callback(() => /*div6_input_handler*/ ctx[34].call(div6));
    			add_location(div6, file$4, 346, 8, 9088);
    			attr_dev(div7, "class", "svelte-1sy1xwz");
    			add_location(div7, file$4, 345, 6, 9073);
    			attr_dev(div8, "class", "arrow svelte-1sy1xwz");
    			add_location(div8, file$4, 352, 6, 9235);
    			attr_dev(div9, "id", "page");
    			attr_dev(div9, "class", "svelte-1sy1xwz");
    			add_location(div9, file$4, 337, 4, 8903);
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", "1");
    			attr_dev(input, "max", /*total*/ ctx[2]);
    			attr_dev(input, "class", "slider svelte-1sy1xwz");
    			attr_dev(input, "id", "myRange");
    			add_location(input, file$4, 361, 6, 9421);
    			attr_dev(div10, "id", "slider");
    			attr_dev(div10, "class", "svelte-1sy1xwz");
    			add_location(div10, file$4, 360, 4, 9396);
    			attr_dev(div11, "id", "controls");
    			attr_dev(div11, "class", "svelte-1sy1xwz");
    			add_location(div11, file$4, 336, 2, 8878);
    			attr_dev(div12, "id", "code-top-container");
    			attr_dev(div12, "class", "svelte-1sy1xwz");
    			add_location(div12, file$4, 314, 0, 8103);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div12, anchor);
    			append_dev(div12, div4);
    			append_dev(div4, div1);
    			append_dev(div1, select0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select0, null);
    			}

    			select_option(select0, /*currentDownload*/ ctx[0]);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			append_dev(div3, select1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			select_option(select1, /*currentVersion*/ ctx[3]);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div12, t5);
    			append_dev(div12, textarea);
    			set_input_value(textarea, /*raw*/ ctx[1]);
    			append_dev(div12, t6);
    			append_dev(div12, div11);
    			append_dev(div11, div9);
    			append_dev(div9, div5);
    			append_dev(div9, t8);
    			append_dev(div9, div7);
    			append_dev(div7, div6);

    			if (/*current*/ ctx[4] !== void 0) {
    				div6.textContent = /*current*/ ctx[4];
    			}

    			append_dev(div7, t9);
    			append_dev(div7, t10);
    			append_dev(div9, t11);
    			append_dev(div9, div8);
    			append_dev(div11, t13);
    			append_dev(div11, div10);
    			append_dev(div10, input);
    			set_input_value(input, /*current*/ ctx[4]);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(select0, "change", /*select0_change_handler*/ ctx[27]),
    				listen_dev(div0, "click", /*click_handler*/ ctx[28], false, false, false),
    				listen_dev(select1, "change", /*select1_change_handler*/ ctx[29]),
    				listen_dev(select1, "change", /*change_handler*/ ctx[30], false, false, false),
    				listen_dev(div2, "click", /*click_handler_1*/ ctx[31], false, false, false),
    				listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[32]),
    				listen_dev(div5, "click", /*click_handler_2*/ ctx[33], false, false, false),
    				listen_dev(div6, "input", /*div6_input_handler*/ ctx[34]),
    				listen_dev(div8, "click", /*click_handler_3*/ ctx[35], false, false, false),
    				listen_dev(input, "change", /*input_change_input_handler*/ ctx[36]),
    				listen_dev(input, "input", /*input_change_input_handler*/ ctx[36])
    			];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*downloads, currentDownload*/ 33) {
    				each_value_1 = /*downloads*/ ctx[5];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty[0] & /*currentDownload*/ 1) {
    				select_option(select0, /*currentDownload*/ ctx[0]);
    			}

    			if (dirty[0] & /*versions, currentVersion*/ 72) {
    				each_value = Object.entries(/*versions*/ ctx[6]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*currentVersion*/ 8) {
    				select_option(select1, /*currentVersion*/ ctx[3]);
    			}

    			if (dirty[0] & /*raw*/ 2) {
    				set_input_value(textarea, /*raw*/ ctx[1]);
    			}

    			if (dirty[0] & /*current*/ 16 && /*current*/ ctx[4] !== div6.textContent) {
    				div6.textContent = /*current*/ ctx[4];
    			}

    			if (dirty[0] & /*total*/ 4) set_data_dev(t10, /*total*/ ctx[2]);

    			if (dirty[0] & /*total*/ 4) {
    				attr_dev(input, "max", /*total*/ ctx[2]);
    			}

    			if (dirty[0] & /*current*/ 16) {
    				set_input_value(input, /*current*/ ctx[4]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div12);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const workerPath$1 = "/workers/worker.js";

    function instance$4($$self, $$props, $$invalidate) {
    	let $IDLEditorContents;
    	let $IDLDocument;
    	validate_store(IDLEditorContents, "IDLEditorContents");
    	component_subscribe($$self, IDLEditorContents, $$value => $$invalidate(16, $IDLEditorContents = $$value));
    	validate_store(IDLDocument, "IDLDocument");
    	component_subscribe($$self, IDLDocument, $$value => $$invalidate(17, $IDLDocument = $$value));
    	let { loaded } = $$props;
    	let { args } = $$props;
    	let { toggleMenu } = $$props;
    	const downloads = ["./test/twoline.txt", "./test/threeline.txt"];
    	let currentDownload = downloads[0];
    	let _worker;
    	let tles;
    	let raw;
    	let schema;
    	let FlatBuffer = {};
    	let startLine = 0;
    	let total = 0;
    	let currentVersion = "RAW";
    	let filtered = [];
    	let filter = "";

    	let tofixed = n => {
    		if (!isNaN(n) && (typeof n === "number" || n instanceof bignumber$1)) {
    			let place = n % 1 ? 15 : 0;
    			n = n.toFixed(place);
    			n = place ? n.replace(/0+$/, "") : n;
    		} else {
    			n = n || null;
    		}

    		return n;
    	};

    	let versionExtensions = {
    		RAW: "txt",
    		"OMM (KEY / VALUE)": "txt",
    		"OMM (JSON)": "json",
    		"OMM (FLATBUFFER)": "fbs"
    	};

    	let versions = {
    		RAW: v => v ? v.join("\n") : "",
    		"OMM (KEY / VALUE)": v => {
    			if (!v) return;
    			v = tles.format.OMM(v);
    			let _v = {};
    			let keys = Reflect.ownKeys(schema.definitions.OMM.properties);

    			for (let k = 0; k < keys.length; k++) {
    				let key = keys[k];
    				_v[key] = v[key] || null;
    			}

    			let _max = Reflect.ownKeys(_v).reduce((p, c) => p.length > c.length ? p : c).length + 1;

    			let result = Object.entries(_v).map(kv => {
    				let _v = kv[1] instanceof Date
    				? JSON.stringify(kv[1])
    				: tofixed(kv[1]) || "null";

    				return `${kv[0].padEnd(_max)} = ${_v.toString().replace(/"/g, "")}`;
    			}).join("\n");

    			return result;
    		},
    		"OMM (JSON)": v => {
    			if (!v) return;
    			v = tles.format.OMM(v);
    			let _v = {};
    			let keys = Reflect.ownKeys(schema.definitions.OMM.properties);

    			for (let k = 0; k < keys.length; k++) {
    				let key = keys[k];
    				_v[key] = tofixed(v[key]);
    			}

    			return JSON.stringify(_v, null, 4).replace(/"([\-+\s]?[0-9]+\.{0,1}[0-9]*)"/g, "$1");
    		},
    		"OMM (FLATBUFFER)": v => {
    			if (!v) return;
    			v = tles.format.OMM(v);
    			let { OMM } = FlatBuffer;
    			let builder = new flatbuffers.Builder(0);
    			let shim = Object.keys(schema.definitions.OMM.properties);
    			let intermediate = {};

    			shim.forEach(canonicalname => {
    				let mangledname = canonicalname.replace(/_/g, "").toUpperCase();

    				for (let prop in OMM) {
    					if (prop.indexOf(mangledname) > -1) {
    						if (v[canonicalname] || v[canonicalname] === 0) {
    							let schemaValue = schema.definitions.OMM.properties[canonicalname];
    							intermediate[prop] = { canonicalname, mangledname };
    							let _value = v[canonicalname];

    							switch (schemaValue.type) {
    								case "number":
    									break;
    								case "string":
    									_value = builder.createString(_value);
    									break;
    							}

    							intermediate[prop].value = _value;
    						}
    					}
    				}
    			});

    			OMM.startOMM(builder);

    			for (let prop in intermediate) {
    				OMM[prop](builder, intermediate[prop].value);
    			}

    			var BuiltOMM = OMM.endOMM(builder);
    			builder.finish(BuiltOMM);
    			var buf = builder.dataBuffer();
    			let uint8 = builder.asUint8Array();
    			var decoder = new TextDecoder("utf8");
    			var b64encoded = btoa(unescape(encodeURIComponent(decoder.decode(uint8))));
    			return uint8;
    		}
    	}; /* "OMM (XML)": v => {}*/

    	const setRawText = c => tles && schema
    	? $$invalidate(1, raw = versions[currentVersion](tles.lines[c || current]))
    	: null;

    	function convertObjects() {
    		let inputObject = {
    			currentLanguage: ["--js", "Generate JavaScript code", "js", "js", "text/javascript"],
    			IDLDocument: "JSTEST",
    			IDLEditorContents: $IDLEditorContents,
    			loaded
    		};

    		workerLoader(workerPath$1, inputObject, function (d) {
    			let file = Object.keys(d.files).filter(f => f.slice(f.lastIndexOf(".")) === ".js");
    			let sfile = Object.keys(d.files).filter(f => f.indexOf("schema.json") > -1);
    			new Function(d.files[file]).bind(FlatBuffer)();
    			schema = JSON.parse(d.files[sfile]);
    			setRawText();
    			$$invalidate(10, loaded = true);
    		});
    	}

    	async function getData() {
    		$$invalidate(10, loaded = false);
    		$$invalidate(1, raw = "");
    		let response = await fetch(currentDownload);
    		let reader = response.body.getReader();
    		$$invalidate(13, tles = new tle(reader));
    		let stop = await tles.readLines();
    		setRawText();
    		$$invalidate(2, total = tles.lines.length - 1);

    		if ($IDLEditorContents && !schema) {
    			convertObjects();
    		} else {
    			$$invalidate(10, loaded = true);
    			setRawText();
    		}
    	}

    	const downloadData = () => {
    		if (raw) {
    			download$1(raw, `test_omm.${versionExtensions[currentVersion] || "txt"}`, "text/plain");
    		}
    	};

    	let sizeEvents = ["resize", "orientationchange"];
    	let sizeSet = () => document.getElementById("code-top-container").style.height = `calc(${window.innerHeight}px - var(--header-height))`;

    	onMount(async () => {
    		if (!$IDLDocument) {
    			window.location.hash = "/select";
    		}

    		sizeSet();

    		sizeEvents.forEach(e => {
    			window.addEventListener(e, sizeSet);
    		});

    		$$invalidate(10, loaded = true);
    	});

    	onDestroy(() => {
    		sizeEvents.forEach(e => {
    			window.removeEventListener(e, sizeSet);
    		});
    	});

    	const writable_props = ["loaded", "args", "toggleMenu"];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OMM> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("OMM", $$slots, []);

    	function select0_change_handler() {
    		currentDownload = select_value(this);
    		$$invalidate(0, currentDownload);
    		$$invalidate(5, downloads);
    	}

    	const click_handler = () => getData();

    	function select1_change_handler() {
    		currentVersion = select_value(this);
    		$$invalidate(3, currentVersion);
    		$$invalidate(6, versions);
    	}

    	const change_handler = () => setRawText();
    	const click_handler_1 = () => downloadData();

    	function textarea_input_handler() {
    		raw = this.value;
    		$$invalidate(1, raw);
    	}

    	const click_handler_2 = () => {
    		$$invalidate(4, current = Math.max(0, current - 1));
    	};

    	function div6_input_handler() {
    		current = this.textContent;
    		($$invalidate(4, current), $$invalidate(2, total));
    	}

    	const click_handler_3 = () => {
    		$$invalidate(4, current = Math.min(total, current + 1));
    	};

    	function input_change_input_handler() {
    		current = to_number(this.value);
    		($$invalidate(4, current), $$invalidate(2, total));
    	}

    	$$self.$set = $$props => {
    		if ("loaded" in $$props) $$invalidate(10, loaded = $$props.loaded);
    		if ("args" in $$props) $$invalidate(11, args = $$props.args);
    		if ("toggleMenu" in $$props) $$invalidate(12, toggleMenu = $$props.toggleMenu);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		tle,
    		satcat,
    		vcm,
    		CodeEditorDocuments,
    		IDLEditorContents,
    		IDLDocument,
    		workerLoader,
    		flatbuffers,
    		bignumber: bignumber$1,
    		download: download$1,
    		workerPath: workerPath$1,
    		loaded,
    		args,
    		toggleMenu,
    		downloads,
    		currentDownload,
    		_worker,
    		tles,
    		raw,
    		schema,
    		FlatBuffer,
    		startLine,
    		total,
    		currentVersion,
    		filtered,
    		filter,
    		tofixed,
    		versionExtensions,
    		versions,
    		setRawText,
    		convertObjects,
    		getData,
    		downloadData,
    		sizeEvents,
    		sizeSet,
    		current,
    		$IDLEditorContents,
    		$IDLDocument
    	});

    	$$self.$inject_state = $$props => {
    		if ("loaded" in $$props) $$invalidate(10, loaded = $$props.loaded);
    		if ("args" in $$props) $$invalidate(11, args = $$props.args);
    		if ("toggleMenu" in $$props) $$invalidate(12, toggleMenu = $$props.toggleMenu);
    		if ("currentDownload" in $$props) $$invalidate(0, currentDownload = $$props.currentDownload);
    		if ("_worker" in $$props) _worker = $$props._worker;
    		if ("tles" in $$props) $$invalidate(13, tles = $$props.tles);
    		if ("raw" in $$props) $$invalidate(1, raw = $$props.raw);
    		if ("schema" in $$props) schema = $$props.schema;
    		if ("FlatBuffer" in $$props) FlatBuffer = $$props.FlatBuffer;
    		if ("startLine" in $$props) startLine = $$props.startLine;
    		if ("total" in $$props) $$invalidate(2, total = $$props.total);
    		if ("currentVersion" in $$props) $$invalidate(3, currentVersion = $$props.currentVersion);
    		if ("filtered" in $$props) filtered = $$props.filtered;
    		if ("filter" in $$props) $$invalidate(21, filter = $$props.filter);
    		if ("tofixed" in $$props) tofixed = $$props.tofixed;
    		if ("versionExtensions" in $$props) versionExtensions = $$props.versionExtensions;
    		if ("versions" in $$props) $$invalidate(6, versions = $$props.versions);
    		if ("sizeEvents" in $$props) sizeEvents = $$props.sizeEvents;
    		if ("sizeSet" in $$props) sizeSet = $$props.sizeSet;
    		if ("current" in $$props) $$invalidate(4, current = $$props.current);
    	};

    	let current;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*current, total*/ 20) {
    			 $$invalidate(4, current = Math.min(Math.max(current, 1), total) || 0);
    		}

    		if ($$self.$$.dirty[0] & /*tles, currentVersion, current*/ 8216) {
    			 {
    				if (tles && currentVersion && !isNaN(current)) {
    					setRawText();
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*tles*/ 8192) {
    			 filtered = tles && tles.lines && filter.length
    			? tles.lines.filter(v => JSON.stringify(v).indexOf(filter) > -1)
    			: [];
    		}
    	};

    	return [
    		currentDownload,
    		raw,
    		total,
    		currentVersion,
    		current,
    		downloads,
    		versions,
    		setRawText,
    		getData,
    		downloadData,
    		loaded,
    		args,
    		toggleMenu,
    		tles,
    		schema,
    		filtered,
    		$IDLEditorContents,
    		$IDLDocument,
    		_worker,
    		FlatBuffer,
    		startLine,
    		filter,
    		tofixed,
    		versionExtensions,
    		convertObjects,
    		sizeEvents,
    		sizeSet,
    		select0_change_handler,
    		click_handler,
    		select1_change_handler,
    		change_handler,
    		click_handler_1,
    		textarea_input_handler,
    		click_handler_2,
    		div6_input_handler,
    		click_handler_3,
    		input_change_input_handler
    	];
    }

    class OMM extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		if (!document_1$1.getElementById("svelte-1sy1xwz-style")) add_css$3();
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { loaded: 10, args: 11, toggleMenu: 12 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OMM",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*loaded*/ ctx[10] === undefined && !("loaded" in props)) {
    			console.warn("<OMM> was created without expected prop 'loaded'");
    		}

    		if (/*args*/ ctx[11] === undefined && !("args" in props)) {
    			console.warn("<OMM> was created without expected prop 'args'");
    		}

    		if (/*toggleMenu*/ ctx[12] === undefined && !("toggleMenu" in props)) {
    			console.warn("<OMM> was created without expected prop 'toggleMenu'");
    		}
    	}

    	get loaded() {
    		throw new Error("<OMM>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaded(value) {
    		throw new Error("<OMM>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get args() {
    		throw new Error("<OMM>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set args(value) {
    		throw new Error("<OMM>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleMenu() {
    		throw new Error("<OMM>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggleMenu(value) {
    		throw new Error("<OMM>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Examples/Examples.svelte generated by Svelte v3.20.1 */

    function create_fragment$5(ctx) {
    	let updating_loaded;
    	let updating_args;
    	let updating_toggleMenu;
    	let switch_instance_anchor;
    	let current;

    	function switch_instance_loaded_binding(value) {
    		/*switch_instance_loaded_binding*/ ctx[6].call(null, value);
    	}

    	function switch_instance_args_binding(value) {
    		/*switch_instance_args_binding*/ ctx[7].call(null, value);
    	}

    	function switch_instance_toggleMenu_binding(value) {
    		/*switch_instance_toggleMenu_binding*/ ctx[8].call(null, value);
    	}

    	var switch_value = /*activeComponent*/ ctx[3];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		if (/*loaded*/ ctx[0] !== void 0) {
    			switch_instance_props.loaded = /*loaded*/ ctx[0];
    		}

    		if (/*args*/ ctx[1] !== void 0) {
    			switch_instance_props.args = /*args*/ ctx[1];
    		}

    		if (/*toggleMenu*/ ctx[2] !== void 0) {
    			switch_instance_props.toggleMenu = /*toggleMenu*/ ctx[2];
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, "loaded", switch_instance_loaded_binding));
    		binding_callbacks.push(() => bind(switch_instance, "args", switch_instance_args_binding));
    		binding_callbacks.push(() => bind(switch_instance, "toggleMenu", switch_instance_toggleMenu_binding));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};

    			if (!updating_loaded && dirty & /*loaded*/ 1) {
    				updating_loaded = true;
    				switch_instance_changes.loaded = /*loaded*/ ctx[0];
    				add_flush_callback(() => updating_loaded = false);
    			}

    			if (!updating_args && dirty & /*args*/ 2) {
    				updating_args = true;
    				switch_instance_changes.args = /*args*/ ctx[1];
    				add_flush_callback(() => updating_args = false);
    			}

    			if (!updating_toggleMenu && dirty & /*toggleMenu*/ 4) {
    				updating_toggleMenu = true;
    				switch_instance_changes.toggleMenu = /*toggleMenu*/ ctx[2];
    				add_flush_callback(() => updating_toggleMenu = false);
    			}

    			if (switch_value !== (switch_value = /*activeComponent*/ ctx[3])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, "loaded", switch_instance_loaded_binding));
    					binding_callbacks.push(() => bind(switch_instance, "args", switch_instance_args_binding));
    					binding_callbacks.push(() => bind(switch_instance, "toggleMenu", switch_instance_toggleMenu_binding));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $IDLEditorContents;
    	validate_store(IDLEditorContents, "IDLEditorContents");
    	component_subscribe($$self, IDLEditorContents, $$value => $$invalidate(4, $IDLEditorContents = $$value));
    	let { loaded } = $$props;
    	let { args } = $$props;
    	let { toggleMenu } = $$props;
    	let examples = { OMM };
    	let activeComponent = OMM;

    	onMount(() => {
    		alert($IDLEditorContents);
    	}); /* if ($IDLEditorContents) {
        
    let root_type = $IDLEditorContents.match(
       /(?<=root_type\s{1,})([^;]{1,})/g
     );

     if (root_type && examples[root_type[0]]) {
       activeComponent = examples[root_type[0]];
     } else {
       alert(`No Example For Type ${root_type}`);
       window.location.hash = "/idl";
     }
        }*/

    	const writable_props = ["loaded", "args", "toggleMenu"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Examples> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Examples", $$slots, []);

    	function switch_instance_loaded_binding(value) {
    		loaded = value;
    		$$invalidate(0, loaded);
    	}

    	function switch_instance_args_binding(value) {
    		args = value;
    		$$invalidate(1, args);
    	}

    	function switch_instance_toggleMenu_binding(value) {
    		toggleMenu = value;
    		$$invalidate(2, toggleMenu);
    	}

    	$$self.$set = $$props => {
    		if ("loaded" in $$props) $$invalidate(0, loaded = $$props.loaded);
    		if ("args" in $$props) $$invalidate(1, args = $$props.args);
    		if ("toggleMenu" in $$props) $$invalidate(2, toggleMenu = $$props.toggleMenu);
    	};

    	$$self.$capture_state = () => ({
    		OMM,
    		onMount,
    		onDestroy,
    		CodeEditorDocuments,
    		IDLEditorContents,
    		IDLDocument,
    		loaded,
    		args,
    		toggleMenu,
    		examples,
    		activeComponent,
    		$IDLEditorContents
    	});

    	$$self.$inject_state = $$props => {
    		if ("loaded" in $$props) $$invalidate(0, loaded = $$props.loaded);
    		if ("args" in $$props) $$invalidate(1, args = $$props.args);
    		if ("toggleMenu" in $$props) $$invalidate(2, toggleMenu = $$props.toggleMenu);
    		if ("examples" in $$props) examples = $$props.examples;
    		if ("activeComponent" in $$props) $$invalidate(3, activeComponent = $$props.activeComponent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		loaded,
    		args,
    		toggleMenu,
    		activeComponent,
    		$IDLEditorContents,
    		examples,
    		switch_instance_loaded_binding,
    		switch_instance_args_binding,
    		switch_instance_toggleMenu_binding
    	];
    }

    class Examples extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { loaded: 0, args: 1, toggleMenu: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Examples",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*loaded*/ ctx[0] === undefined && !("loaded" in props)) {
    			console.warn("<Examples> was created without expected prop 'loaded'");
    		}

    		if (/*args*/ ctx[1] === undefined && !("args" in props)) {
    			console.warn("<Examples> was created without expected prop 'args'");
    		}

    		if (/*toggleMenu*/ ctx[2] === undefined && !("toggleMenu" in props)) {
    			console.warn("<Examples> was created without expected prop 'toggleMenu'");
    		}
    	}

    	get loaded() {
    		throw new Error("<Examples>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaded(value) {
    		throw new Error("<Examples>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get args() {
    		throw new Error("<Examples>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set args(value) {
    		throw new Error("<Examples>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleMenu() {
    		throw new Error("<Examples>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggleMenu(value) {
    		throw new Error("<Examples>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var fb = "/// @file\n/// @addtogroup flatbuffers_javascript_api\n/// @{\n/// @cond FLATBUFFERS_INTERNAL\n\n/**\n * @fileoverview\n *\n * Need to suppress 'global this' error so the Node.js export line doesn't cause\n * closure compile to error out.\n * @suppress {globalThis}\n */\n\n/**\n * @const\n * @namespace\n */\nvar flatbuffers = {};\n\n/**\n * @typedef {number}\n */\nflatbuffers.Offset;\n\n/**\n * @typedef {{\n *   bb: flatbuffers.ByteBuffer,\n *   bb_pos: number\n * }}\n */\nflatbuffers.Table;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_SHORT = 2;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_INT = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.FILE_IDENTIFIER_LENGTH = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZE_PREFIX_LENGTH = 4;\n\n/**\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\nflatbuffers.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n/**\n * @enum {number}\n */\nflatbuffers.Encoding = {\n  UTF8_BYTES: 1,\n  UTF16_STRING: 2\n};\n\n/**\n * @type {Int32Array}\n * @const\n */\nflatbuffers.int32 = new Int32Array(2);\n\n/**\n * @type {Float32Array}\n * @const\n */\nflatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);\n\n/**\n * @type {Float64Array}\n * @const\n */\nflatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);\n\n/**\n * @type {boolean}\n * @const\n */\nflatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @constructor\n * @param {number} low\n * @param {number} high\n */\nflatbuffers.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @const\n   */\n  this.low = low | 0;\n\n  /**\n   * @type {number}\n   * @const\n   */\n  this.high = high | 0;\n};\n\n/**\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Long.create = function(low, high) {\n  // Special-case zero to avoid GC overhead for default values\n  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);\n};\n\n/**\n * @returns {number}\n */\nflatbuffers.Long.prototype.toFloat64 = function() {\n  return (this.low >>> 0) + this.high * 0x100000000;\n};\n\n/**\n * @param {flatbuffers.Long} other\n * @returns {boolean}\n */\nflatbuffers.Long.prototype.equals = function(other) {\n  return this.low == other.low && this.high == other.high;\n};\n\n/**\n * @type {!flatbuffers.Long}\n * @const\n */\nflatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);\n\n/// @endcond\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a FlatBufferBuilder.\n *\n * @constructor\n * @param {number=} opt_initial_size\n */\nflatbuffers.Builder = function(opt_initial_size) {\n  if (!opt_initial_size) {\n    var initial_size = 1024;\n  } else {\n    var initial_size = opt_initial_size;\n  }\n\n  /**\n   * @type {flatbuffers.ByteBuffer}\n   * @private\n   */\n  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);\n\n  /**\n   * Remaining space in the ByteBuffer.\n   *\n   * @type {number}\n   * @private\n   */\n  this.space = initial_size;\n\n  /**\n   * Minimum alignment encountered so far.\n   *\n   * @type {number}\n   * @private\n   */\n  this.minalign = 1;\n\n  /**\n   * The vtable for the current table.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtable = null;\n\n  /**\n   * The amount of fields we're actually using.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vtable_in_use = 0;\n\n  /**\n   * Whether we are currently serializing a table.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.isNested = false;\n\n  /**\n   * Starting offset of the current struct/table.\n   *\n   * @type {number}\n   * @private\n   */\n  this.object_start = 0;\n\n  /**\n   * List of offsets of all vtables.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtables = [];\n\n  /**\n   * For the current vector being built.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vector_num_elems = 0;\n\n  /**\n   * False omits default values from the serialized data\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.force_defaults = false;\n};\n\nflatbuffers.Builder.prototype.clear = function() {\n  this.bb.clear();\n  this.space = this.bb.capacity();\n  this.minalign = 1;\n  this.vtable = null;\n  this.vtable_in_use = 0;\n  this.isNested = false;\n  this.object_start = 0;\n  this.vtables = [];\n  this.vector_num_elems = 0;\n  this.force_defaults = false;\n};\n\n/**\n * In order to save space, fields that are set to their default value\n * don't get serialized into the buffer. Forcing defaults provides a\n * way to manually disable this optimization.\n *\n * @param {boolean} forceDefaults true always serializes default values\n */\nflatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {\n  this.force_defaults = forceDefaults;\n};\n\n/**\n * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n * called finish(). The actual data starts at the ByteBuffer's current position,\n * not necessarily at 0.\n *\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.Builder.prototype.dataBuffer = function() {\n  return this.bb;\n};\n\n/**\n * Get the bytes representing the FlatBuffer. Only call this after you've\n * called finish().\n *\n * @returns {!Uint8Array}\n */\nflatbuffers.Builder.prototype.asUint8Array = function() {\n  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Prepare to write an element of `size` after `additional_bytes` have been\n * written, e.g. if you write a string, you need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * you need to do is alignment, `additional_bytes` will be 0.\n *\n * @param {number} size This is the of the new element to write\n * @param {number} additional_bytes The padding size\n */\nflatbuffers.Builder.prototype.prep = function(size, additional_bytes) {\n  // Track the biggest thing we've ever aligned to.\n  if (size > this.minalign) {\n    this.minalign = size;\n  }\n\n  // Find the amount of alignment needed such that `size` is properly\n  // aligned after `additional_bytes`\n  var align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n\n  // Reallocate the buffer if needed.\n  while (this.space < align_size + size + additional_bytes) {\n    var old_buf_size = this.bb.capacity();\n    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);\n    this.space += this.bb.capacity() - old_buf_size;\n  }\n\n  this.pad(align_size);\n};\n\n/**\n * @param {number} byte_size\n */\nflatbuffers.Builder.prototype.pad = function(byte_size) {\n  for (var i = 0; i < byte_size; i++) {\n    this.bb.writeInt8(--this.space, 0);\n  }\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt8 = function(value) {\n  this.bb.writeInt8(this.space -= 1, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt16 = function(value) {\n  this.bb.writeInt16(this.space -= 2, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt32 = function(value) {\n  this.bb.writeInt32(this.space -= 4, value);\n};\n\n/**\n * @param {flatbuffers.Long} value\n */\nflatbuffers.Builder.prototype.writeInt64 = function(value) {\n  this.bb.writeInt64(this.space -= 8, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat32 = function(value) {\n  this.bb.writeFloat32(this.space -= 4, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat64 = function(value) {\n  this.bb.writeFloat64(this.space -= 8, value);\n};\n/// @endcond\n\n/**\n * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int8` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt8 = function(value) {\n  this.prep(1, 0);\n  this.writeInt8(value);\n};\n\n/**\n * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int16` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt16 = function(value) {\n  this.prep(2, 0);\n  this.writeInt16(value);\n};\n\n/**\n * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt32 = function(value) {\n  this.prep(4, 0);\n  this.writeInt32(value);\n};\n\n/**\n * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {flatbuffers.Long} value The `int64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt64 = function(value) {\n  this.prep(8, 0);\n  this.writeInt64(value);\n};\n\n/**\n * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat32 = function(value) {\n  this.prep(4, 0);\n  this.writeFloat32(value);\n};\n\n/**\n * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat64 = function(value) {\n  this.prep(8, 0);\n  this.writeFloat64(value);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt8(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt16(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Long} value\n * @param {flatbuffers.Long} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || !value.equals(defaultValue)) {\n    this.addInt64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addOffset(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n *\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {\n  if (value != defaultValue) {\n    this.nested(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structures are always stored inline, they need to be created right\n * where they're used.  You'll get this assertion failure if you\n * created it elsewhere.\n *\n * @param {flatbuffers.Offset} obj The offset of the created object\n */\nflatbuffers.Builder.prototype.nested = function(obj) {\n  if (obj != this.offset()) {\n    throw new Error('FlatBuffers: struct must be serialized inline.');\n  }\n};\n\n/**\n * Should not be creating any other object, string or vector\n * while an object is being constructed\n */\nflatbuffers.Builder.prototype.notNested = function() {\n  if (this.isNested) {\n    throw new Error('FlatBuffers: object serialization must not be nested.');\n  }\n};\n\n/**\n * Set the current vtable at `voffset` to the current location in the buffer.\n *\n * @param {number} voffset\n */\nflatbuffers.Builder.prototype.slot = function(voffset) {\n  this.vtable[voffset] = this.offset();\n};\n\n/**\n * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\n */\nflatbuffers.Builder.prototype.offset = function() {\n  return this.bb.capacity() - this.space;\n};\n\n/**\n * Doubles the size of the backing ByteBuffer and copies the old data towards\n * the end of the new buffer (since we build the buffer backwards).\n *\n * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\n * @returns {!flatbuffers.ByteBuffer} A new byte buffer with the old data copied\n * to it. The data is located at the end of the buffer.\n *\n * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n * it a uint8Array we need to suppress the type check:\n * @suppress {checkTypes}\n */\nflatbuffers.Builder.growByteBuffer = function(bb) {\n  var old_buf_size = bb.capacity();\n\n  // Ensure we don't grow beyond what fits in an int.\n  if (old_buf_size & 0xC0000000) {\n    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n  }\n\n  var new_buf_size = old_buf_size << 1;\n  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);\n  nbb.setPosition(new_buf_size - old_buf_size);\n  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n  return nbb;\n};\n/// @endcond\n\n/**\n * Adds on offset, relative to where it will be written.\n *\n * @param {flatbuffers.Offset} offset The offset to add.\n */\nflatbuffers.Builder.prototype.addOffset = function(offset) {\n  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.\n  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Start encoding a new object in the buffer.  Users will not usually need to\n * call this directly. The FlatBuffers compiler will generate helper methods\n * that call this method internally.\n *\n * @param {number} numfields\n */\nflatbuffers.Builder.prototype.startObject = function(numfields) {\n  this.notNested();\n  if (this.vtable == null) {\n    this.vtable = [];\n  }\n  this.vtable_in_use = numfields;\n  for (var i = 0; i < numfields; i++) {\n    this.vtable[i] = 0; // This will push additional elements as needed\n  }\n  this.isNested = true;\n  this.object_start = this.offset();\n};\n\n/**\n * Finish off writing the object that is under construction.\n *\n * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\n */\nflatbuffers.Builder.prototype.endObject = function() {\n  if (this.vtable == null || !this.isNested) {\n    throw new Error('FlatBuffers: endObject called without startObject');\n  }\n\n  this.addInt32(0);\n  var vtableloc = this.offset();\n\n  // Trim trailing zeroes.\n  var i = this.vtable_in_use - 1;\n  for (; i >= 0 && this.vtable[i] == 0; i--) {}\n  var trimmed_size = i + 1;\n\n  // Write out the current vtable.\n  for (; i >= 0; i--) {\n    // Offset relative to the start of the table.\n    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n  }\n\n  var standard_fields = 2; // The fields below:\n  this.addInt16(vtableloc - this.object_start);\n  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;\n  this.addInt16(len);\n\n  // Search for an existing vtable that matches the current one.\n  var existing_vtable = 0;\n  var vt1 = this.space;\nouter_loop:\n  for (i = 0; i < this.vtables.length; i++) {\n    var vt2 = this.bb.capacity() - this.vtables[i];\n    if (len == this.bb.readInt16(vt2)) {\n      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {\n        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n          continue outer_loop;\n        }\n      }\n      existing_vtable = this.vtables[i];\n      break;\n    }\n  }\n\n  if (existing_vtable) {\n    // Found a match:\n    // Remove the current vtable.\n    this.space = this.bb.capacity() - vtableloc;\n\n    // Point table to existing vtable.\n    this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n  } else {\n    // No match:\n    // Add the location of the current vtable to the list of vtables.\n    this.vtables.push(this.offset());\n\n    // Point table to current vtable.\n    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n  }\n\n  this.isNested = false;\n  return vtableloc;\n};\n/// @endcond\n\n/**\n * Finalize a buffer, poiting to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n * @param {boolean=} opt_size_prefix\n */\nflatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {\n  var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;\n  if (opt_file_identifier) {\n    var file_identifier = opt_file_identifier;\n    this.prep(this.minalign, flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);\n    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' +\n        flatbuffers.FILE_IDENTIFIER_LENGTH);\n    }\n    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n      this.writeInt8(file_identifier.charCodeAt(i));\n    }\n  }\n  this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);\n  this.addOffset(root_table);\n  if (size_prefix) {\n    this.addInt32(this.bb.capacity() - this.space);\n  }\n  this.bb.setPosition(this.space);\n};\n\n/**\n * Finalize a size prefixed buffer, pointing to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n */\nflatbuffers.Builder.prototype.finishSizePrefixed = function (root_table, opt_file_identifier) {\n  this.finish(root_table, opt_file_identifier, true);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * This checks a required field has been set in a given table that has\n * just been constructed.\n *\n * @param {flatbuffers.Offset} table\n * @param {number} field\n */\nflatbuffers.Builder.prototype.requiredField = function(table, field) {\n  var table_start = this.bb.capacity() - table;\n  var vtable_start = table_start - this.bb.readInt32(table_start);\n  var ok = this.bb.readInt16(vtable_start + field) != 0;\n\n  // If this fails, the caller will show what field needs to be set.\n  if (!ok) {\n    throw new Error('FlatBuffers: field ' + field + ' must be set');\n  }\n};\n\n/**\n * Start a new array/vector of objects.  Users usually will not call\n * this directly. The FlatBuffers compiler will create a start/end\n * method for vector types in generated code.\n *\n * @param {number} elem_size The size of each element in the array\n * @param {number} num_elems The number of elements in the array\n * @param {number} alignment The alignment of the array\n */\nflatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {\n  this.notNested();\n  this.vector_num_elems = num_elems;\n  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);\n  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n};\n\n/**\n * Finish off the creation of an array and all its elements. The array must be\n * created with `startVector`.\n *\n * @returns {flatbuffers.Offset} The offset at which the newly created array\n * starts.\n */\nflatbuffers.Builder.prototype.endVector = function() {\n  this.writeInt32(this.vector_num_elems);\n  return this.offset();\n};\n/// @endcond\n\n/**\n * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n *\n * @param {string|Uint8Array} s The string to encode\n * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n */\nflatbuffers.Builder.prototype.createString = function(s) {\n  if (s instanceof Uint8Array) {\n    var utf8 = s;\n  } else {\n    var utf8 = [];\n    var i = 0;\n\n    while (i < s.length) {\n      var codePoint;\n\n      // Decode UTF-16\n      var a = s.charCodeAt(i++);\n      if (a < 0xD800 || a >= 0xDC00) {\n        codePoint = a;\n      } else {\n        var b = s.charCodeAt(i++);\n        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);\n      }\n\n      // Encode UTF-8\n      if (codePoint < 0x80) {\n        utf8.push(codePoint);\n      } else {\n        if (codePoint < 0x800) {\n          utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);\n        } else {\n          if (codePoint < 0x10000) {\n            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);\n          } else {\n            utf8.push(\n              ((codePoint >> 18) & 0x07) | 0xF0,\n              ((codePoint >> 12) & 0x3F) | 0x80);\n          }\n          utf8.push(((codePoint >> 6) & 0x3F) | 0x80);\n        }\n        utf8.push((codePoint & 0x3F) | 0x80);\n      }\n    }\n  }\n\n  this.addInt8(0);\n  this.startVector(1, utf8.length, 1);\n  this.bb.setPosition(this.space -= utf8.length);\n  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n    bytes[offset++] = utf8[i];\n  }\n  return this.endVector();\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Builder.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n/**\n * A helper function to pack an object\n * \n * @returns offset of obj\n */\nflatbuffers.Builder.prototype.createObjectOffset = function(obj) {\n  if(obj === null) {\n    return 0\n  }\n\n  if(typeof obj === 'string') {\n    return this.createString(obj);\n  } else {\n    return obj.pack(this);\n  }\n}\n\n/**\n * A helper function to pack a list of object\n * \n * @returns list of offsets of each non null object\n */\nflatbuffers.Builder.prototype.createObjectOffsetList = function(list) {\n  let ret = [];\n\n  for(let i = 0; i < list.length; ++i) {\n    let val = list[i];\n\n    if(val !== null) {\n      ret.push(this.createObjectOffset(val));\n    } else {\n      throw new Error(\n        'FlatBuffers: Argument for createObjectOffsetList cannot contain null.'); \n    }\n  }\n  \n  return ret;\n};\n\nflatbuffers.Builder.prototype.createStructOffsetList = function(list, startFunc) {\n  startFunc(this, list.length);\n  this.createObjectOffsetList(list);\n  return this.endVector();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).\n *\n * @constructor\n * @param {Uint8Array} bytes\n */\nflatbuffers.ByteBuffer = function(bytes) {\n  /**\n   * @type {Uint8Array}\n   * @private\n   */\n  this.bytes_ = bytes;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * Create and allocate a new ByteBuffer with a given size.\n *\n * @param {number} byte_size\n * @returns {!flatbuffers.ByteBuffer}\n */\nflatbuffers.ByteBuffer.allocate = function(byte_size) {\n  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));\n};\n\nflatbuffers.ByteBuffer.prototype.clear = function() {\n  this.position_ = 0;\n};\n\n/**\n * Get the underlying `Uint8Array`.\n *\n * @returns {Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.bytes = function() {\n  return this.bytes_;\n};\n\n/**\n * Get the buffer's position.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.position = function() {\n  return this.position_;\n};\n\n/**\n * Set the buffer's position.\n *\n * @param {number} position\n */\nflatbuffers.ByteBuffer.prototype.setPosition = function(position) {\n  this.position_ = position;\n};\n\n/**\n * Get the buffer's capacity.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.capacity = function() {\n  return this.bytes_.length;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {\n  return this.readUint8(offset) << 24 >> 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {\n  return this.bytes_[offset];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {\n  return this.readUint16(offset) << 16 >> 16;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {\n  return this.readInt32(offset) >>> 0;\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {\n  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {\n  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {\n  flatbuffers.int32[0] = this.readInt32(offset);\n  return flatbuffers.float32[0];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n  return flatbuffers.float64[0];\n};\n\n/**\n * @param {number} offset\n * @param {number|boolean} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {\n  this.bytes_[offset] = /** @type {number} */(value);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {\n  this.bytes_[offset] = value;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {\n  this.writeInt32(offset, value.low);\n  this.writeInt32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {\n    this.writeUint32(offset, value.low);\n    this.writeUint32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {\n  flatbuffers.float32[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[0]);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {\n  flatbuffers.float64[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);\n  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);\n};\n\n/**\n * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n * schema does not include a file_identifier (likely points at padding or the\n * start of a the root vtable).\n * @returns {string}\n */\nflatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {\n  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error(\n        'FlatBuffers: ByteBuffer is too short to contain an identifier.');\n  }\n  var result = \"\";\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    result += String.fromCharCode(\n        this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));\n  }\n  return result;\n};\n\n/**\n * Look up a field in the vtable, return an offset into the object, or 0 if the\n * field is not present.\n *\n * @param {number} bb_pos\n * @param {number} vtable_offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {\n  var vtable = bb_pos - this.readInt32(bb_pos);\n  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n};\n\n/**\n * Initialize any Table-derived type to point to the union at the given offset.\n *\n * @param {flatbuffers.Table} t\n * @param {number} offset\n * @returns {flatbuffers.Table}\n */\nflatbuffers.ByteBuffer.prototype.__union = function(t, offset) {\n  t.bb_pos = offset + this.readInt32(offset);\n  t.bb = this;\n  return t;\n};\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n *\n * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\n * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n * and from UTF-16 when the data will just be packaged back up in another\n * FlatBuffer later on.\n *\n * @param {number} offset\n * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING\n * @returns {string|!Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {\n  offset += this.readInt32(offset);\n\n  var length = this.readInt32(offset);\n  var result = '';\n  var i = 0;\n\n  offset += flatbuffers.SIZEOF_INT;\n\n  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {\n    return this.bytes_.subarray(offset, offset + length);\n  }\n\n  while (i < length) {\n    var codePoint;\n\n    // Decode UTF-8\n    var a = this.readUint8(offset + i++);\n    if (a < 0xC0) {\n      codePoint = a;\n    } else {\n      var b = this.readUint8(offset + i++);\n      if (a < 0xE0) {\n        codePoint =\n          ((a & 0x1F) << 6) |\n          (b & 0x3F);\n      } else {\n        var c = this.readUint8(offset + i++);\n        if (a < 0xF0) {\n          codePoint =\n            ((a & 0x0F) << 12) |\n            ((b & 0x3F) << 6) |\n            (c & 0x3F);\n        } else {\n          var d = this.readUint8(offset + i++);\n          codePoint =\n            ((a & 0x07) << 18) |\n            ((b & 0x3F) << 12) |\n            ((c & 0x3F) << 6) |\n            (d & 0x3F);\n        }\n      }\n    }\n\n    // Encode UTF-16\n    if (codePoint < 0x10000) {\n      result += String.fromCharCode(codePoint);\n    } else {\n      codePoint -= 0x10000;\n      result += String.fromCharCode(\n        (codePoint >> 10) + 0xD800,\n        (codePoint & ((1 << 10) - 1)) + 0xDC00);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Handle unions that can contain string as its member, if a Table-derived type then initialize it, \n * if a string then return a new one\n * \n * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this \n * makes the behaviour of __union_with_string different compared to __union\n *\n * @param {flatbuffers.Table|string} o\n * @param {number} offset\n * @returns {flatbuffers.Table|string}\n */\nflatbuffers.ByteBuffer.prototype.__union_with_string = function(o, offset) {\n  if(typeof o === 'string') {\n    return this.__string(offset);\n  } \n  return this.__union(o, offset);\n};\n\n/**\n * Retrieve the relative offset stored at \"offset\"\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__indirect = function(offset) {\n  return offset + this.readInt32(offset);\n};\n\n/**\n * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector = function(offset) {\n  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length\n};\n\n/**\n * Get the length of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {\n  return this.readInt32(offset + this.readInt32(offset));\n};\n\n/**\n * @param {string} ident\n * @returns {boolean}\n */\nflatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {\n  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: file identifier must be length ' +\n                    flatbuffers.FILE_IDENTIFIER_LENGTH);\n  }\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n/**\n * A helper function for generating list for obj api\n * @param listAccessor function that accepts an index and return data at that index\n * @param {number} listLength\n * @returns {any[]}\n */\nflatbuffers.ByteBuffer.prototype.createScalarList = function(listAccessor, listLength) {\n  let ret = [];\n  for(let i = 0; i < listLength; ++i) {\n    if(listAccessor(i) !== null) {\n      ret.push(listAccessor(i));\n    }\n  }\n\n  return ret;\n};\n\n/**\n * This function is here only to get around typescript type system\n */\nflatbuffers.ByteBuffer.prototype.createStringList = function(listAccessor, listLength) {\n  return this.createScalarList(listAccessor, listLength);\n};\n\n/**\n * A helper function for generating list for obj api\n * @param listAccessor function that accepts an index and return data at that index\n * @param listLength {number} listLength\n * @param res any[] result list\n */\nflatbuffers.ByteBuffer.prototype.createObjList = function(listAccessor, listLength) {\n  let ret = [];\n  for(let i = 0; i < listLength; ++i) {\n    let val = listAccessor(i);\n    if(val !== null) {\n      ret.push(val.unpack());\n    }\n  }\n  \n  return ret;\n};\n\n// Exports for Node.js and RequireJS\nthis.flatbuffers = flatbuffers;\n\n/// @endcond\n/// @}\n";

    var ws = "let _done = () => { globalThis.postMessage('done'); };\nconsole.log = function (...args) {\n  args.map((msg, m) => {\n    if (typeof msg === \"object\") {\n      args[m] = (JSON && JSON.stringify ? JSON.stringify(msg) : msg);\n    } else if (typeof msg === \"function\") {\n      args[m] = (msg.toString());\n    }\n  });\n  globalThis.postMessage(args);\n};";

    /* src/components/Test/Test.svelte generated by Svelte v3.20.1 */

    const { Object: Object_1$2, document: document_1$2 } = globals;
    const file$5 = "src/components/Test/Test.svelte";

    function add_css$4() {
    	var style = element("style");
    	style.id = "svelte-1sv0ypf-style";
    	style.textContent = ":root{--console-height:250px}#test-top-container.svelte-1sv0ypf.svelte-1sv0ypf{position:absolute;width:100%;height:100%;display:flex;flex-direction:column}.editor2{height:100%}#editor-container.svelte-1sv0ypf.svelte-1sv0ypf{box-sizing:border-box;height:50%}#editor-container.svelte-1sv0ypf.svelte-1sv0ypf,#console.svelte-1sv0ypf.svelte-1sv0ypf{flex:1 1 auto}#console.svelte-1sv0ypf.svelte-1sv0ypf{padding:5px;padding-bottom:50px;font-size:12px;font-weight:400;font-family:monospace;overflow-y:scroll;overflow-x:none;user-select:none;word-wrap:break-word;font:12px/1.2 sans-serif;color:#333;height:var(--console-height)}#top-menu.svelte-1sv0ypf.svelte-1sv0ypf{font-size:var(--font-size-sm);padding:2px;display:flex;align-items:center;justify-content:space-between;grid-gap:10px}#top-menu.svelte-1sv0ypf div.svelte-1sv0ypf{font-weight:300;color:#eee;height:100%;border:0.5px #eee inset;cursor:pointer;display:flex;justify-content:center;align-items:center;border-radius:2px;padding:8px;background:linear-gradient(\r\n      to right,\r\n      #8f0222 0%,\r\n      #a90329 44%,\r\n      #830220 100%\r\n    )}#top-menu.svelte-1sv0ypf div.svelte-1sv0ypf:hover{background:linear-gradient(\r\n      to right,\r\n      #8f0222 0%,\r\n      #c90230 44%,\r\n      #6d0019 100%\r\n    )}#top-menu.svelte-1sv0ypf div#reloadEditor.svelte-1sv0ypf,#top-menu.svelte-1sv0ypf div#run.svelte-1sv0ypf{max-width:200px;right:0px;background:var(--button-gradient)}#top-menu.svelte-1sv0ypf div#reloadEditor.svelte-1sv0ypf:hover,#top-menu.svelte-1sv0ypf div#run.svelte-1sv0ypf:hover{max-width:200px;right:0px;background:linear-gradient(\r\n      to right,\r\n      var(--celestrak-blue) 0%,\r\n      #007fe0 50%,\r\n      var(--celestrak-blue) 100%\r\n    )}#hr.svelte-1sv0ypf.svelte-1sv0ypf{z-index:1;cursor:ns-resize;height:20px;background:#888;box-shadow:-1px 2px 2px -1px black}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGVzdC5zdmVsdGUiLCJzb3VyY2VzIjpbIlRlc3Quc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcbiAgaW1wb3J0IHsgb25Nb3VudCwgb25EZXN0cm95IH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG4gIGltcG9ydCBFZGl0b3IgZnJvbSBcIi4uL01vbmFjb0VkaXRvci9Nb25hY29FZGl0b3Iuc3ZlbHRlXCI7XHJcbiAgaW1wb3J0IHtcclxuICAgIElETERvY3VtZW50LFxyXG4gICAgSURMRWRpdG9yQ29udGVudHMsXHJcbiAgICBUZXN0RWRpdG9yRG9jdW1lbnQsXHJcbiAgICBUZXN0RWRpdG9yQ29udGVudHMsXHJcbiAgICBzYXZlRXZlbnRUaW1lXHJcbiAgfSBmcm9tIFwiLi4vLi4vc3RvcmVzL0ZpbGVzLmpzXCI7XHJcbiAgaW1wb3J0IGZiIGZyb20gXCIuLi8uLi8uLi9saWIvZmxhdGJ1ZmZlcnMuanNcIjtcclxuICBpbXBvcnQgd3MgZnJvbSBcIi4uLy4uL2xpYi93b3JrZXJTaGltLmpzXCI7XHJcbiAgaW1wb3J0IHdvcmtlckxvYWRlciBmcm9tIFwiLi4vLi4vbGliL3dvcmtlckxvYWRlci5qc1wiO1xyXG4gIGltcG9ydCBkZW1hbmdsZXIgZnJvbSBcIi4uLy4uL2xpYi9kZW1hbmdsZXIuanNcIjtcclxuXHJcbiAgZXhwb3J0IGxldCBsb2FkZWQ7XHJcbiAgZXhwb3J0IGxldCBhcmdzO1xyXG5cclxuICBjb25zdCB3b3JrZXJQYXRoID0gXCIvd29ya2Vycy93b3JrZXIuanNcIjtcclxuICBsZXQgY2FyYXQgPSBgPmA7XHJcbiAgbGV0IF9sb2dPdXRwdXQgPSBgJHtjYXJhdH1cXG5gO1xyXG4gIGxldCBzdGFydExpbmUgPSAwO1xyXG4gIGxldCBfd29ya2VyO1xyXG4gIGxldCBfcnVubmluZztcclxuICBsZXQgZHJhZ2dpbmc7XHJcbiAgbGV0IGRyYWdFbCA9IFtdO1xyXG5cclxuICBsZXQgbW91c2V1cEV2ZW50ID0gKCkgPT4ge1xyXG4gICAgZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHNjcm9sbERvd24oKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG1vdXNldXBFdmVudCk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUV2ZW50KTtcclxuICB9O1xyXG4gIGxldCBtb3VzZU1vdmVFdmVudCA9IGUgPT4ge1xyXG4gICAgZSA9IGUgJiYgZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuICAgIGlmIChlKSB7XHJcbiAgICAgIGRyYWdFbFszXS5zdHlsZS5oZWlnaHQgPSBkcmFnZ2luZ1xyXG4gICAgICAgID8gYCR7TWF0aC5tYXgoXHJcbiAgICAgICAgICAgIDEwLFxyXG4gICAgICAgICAgICB3aW5kb3cuaW5uZXJIZWlnaHQgLVxyXG4gICAgICAgICAgICAgIGUuY2xpZW50WSAtXHJcbiAgICAgICAgICAgICAgMiAqXHJcbiAgICAgICAgICAgICAgICBwYXJzZUludChcclxuICAgICAgICAgICAgICAgICAgZ2xvYmFsVGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIC5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaHJcIikpXHJcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodC5yZXBsYWNlKFwicHhcIiwgXCJcIilcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICl9cHhgXHJcbiAgICAgICAgOiBkcmFnRWxbM10uc3R5bGUuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZHJhZ0VsWzJdLnN0eWxlLmhlaWdodCA9IGAke3dpbmRvdy5pbm5lckhlaWdodCAtXHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZGVyXCIpWzBdLmNsaWVudEhlaWdodCAtXHJcbiAgICAgIGRyYWdFbFsxXS5jbGllbnRIZWlnaHQgLVxyXG4gICAgICBkcmFnRWxbM10uY2xpZW50SGVpZ2h0fXB4YDtcclxuICB9O1xyXG4gICQ6IHtcclxuICAgIGlmICgkc2F2ZUV2ZW50VGltZSkge1xyXG4gICAgICBydW5UZXN0U2NyaXB0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBzY3JvbGxEb3duID0gKCkgPT5cclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBsZXQgdGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnNvbGVcIik7XHJcbiAgICAgIGlmICh0YSkge1xyXG4gICAgICAgIHRhLnNjcm9sbFRvcCA9IHRhLnNjcm9sbEhlaWdodDtcclxuICAgICAgfVxyXG4gICAgfSwgMTApO1xyXG4gIGxldCBfZXhlYyA9IGNvZGUgPT4ge1xyXG4gICAgaWYgKF93b3JrZXIpIF93b3JrZXIudGVybWluYXRlKCk7XHJcbiAgICBsZXQgX3ByZWFtYmxlID0gYCR7d3N9JHtjb2RlfWA7XHJcbiAgICBzdGFydExpbmUgPSBfcHJlYW1ibGUubWF0Y2goL1xcbi9nKS5sZW5ndGg7XHJcbiAgICBfd29ya2VyID0gbmV3IFdvcmtlcihcclxuICAgICAgd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoXHJcbiAgICAgICAgbmV3IEJsb2IoW2Ake19wcmVhbWJsZX0keyRUZXN0RWRpdG9yQ29udGVudHN9YF0sIHtcclxuICAgICAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcclxuICAgICAgICB9KVxyXG4gICAgICApXHJcbiAgICApO1xyXG4gICAgX2xvZ091dHB1dCA9IFwiXCI7XHJcbiAgICBfd29ya2VyLm9ubWVzc2FnZSA9IGUgPT4ge1xyXG4gICAgICBpZiAoZS5kYXRhID09PSBcImRvbmVcIikgX3dvcmtlci50ZXJtaW5hdGUoKTtcclxuXHJcbiAgICAgIGlmIChlLmRhdGEuZ2xvYmFsKSB7XHJcbiAgICAgICAgZ2xvYmFsVGhpc1tlLmRhdGEuZ2xvYmFsTmFtZV0gPSBlLmRhdGEuZ2xvYmFsO1xyXG4gICAgICB9IGVsc2UgX2xvZ091dHB1dCArPSBgJHtjYXJhdH0gJHtlLmRhdGEuam9pbihcIlwiKX0gIFxcbmA7XHJcbiAgICAgIHNjcm9sbERvd24oKTtcclxuICAgIH07XHJcbiAgICBfd29ya2VyLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgX2xvZ091dHB1dCArPSBgJHtlcnIubWVzc2FnZX0gIGF0IGxpbmUgJHtlcnIubGluZW5vIC0gc3RhcnRMaW5lfWA7XHJcbiAgICAgIF93b3JrZXIudGVybWluYXRlKCk7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHJ1blRlc3RTY3JpcHQoKSB7XHJcbiAgICBpZiAoX3J1bm5pbmcpIHJldHVybjtcclxuICAgIF9ydW5uaW5nID0gdHJ1ZTtcclxuICAgIGlmICgkSURMRWRpdG9yQ29udGVudHMpIHtcclxuICAgICAgX2xvZ091dHB1dCA9IGAke2NhcmF0fSBMT0FESU5HIC4uLmA7XHJcbiAgICAgIGxldCBpbnB1dE9iamVjdCA9IHtcclxuICAgICAgICBjdXJyZW50TGFuZ3VhZ2U6IFtcclxuICAgICAgICAgIFwiLS1qc1wiLFxyXG4gICAgICAgICAgXCJHZW5lcmF0ZSBKYXZhU2NyaXB0IGNvZGVcIixcclxuICAgICAgICAgIFwianNcIixcclxuICAgICAgICAgIFwianNcIixcclxuICAgICAgICAgIFwidGV4dC9qYXZhc2NyaXB0XCJcclxuICAgICAgICBdLFxyXG4gICAgICAgIElETERvY3VtZW50OiBcIkpTVEVTVFwiLFxyXG4gICAgICAgIElETEVkaXRvckNvbnRlbnRzOiAkSURMRWRpdG9yQ29udGVudHMsXHJcbiAgICAgICAgbG9hZGVkXHJcbiAgICAgIH07XHJcbiAgICAgIHdvcmtlckxvYWRlcih3b3JrZXJQYXRoLCBpbnB1dE9iamVjdCwgZnVuY3Rpb24oZCkge1xyXG4gICAgICAgIF9ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGZpbGUgPSBPYmplY3Qua2V5cyhkLmZpbGVzKS5maWx0ZXIoXHJcbiAgICAgICAgICBmID0+IGYuc2xpY2UoZi5sYXN0SW5kZXhPZihcIi5cIikpID09PSBcIi5qc1wiXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsZXQgc2NoZW1hRmlsZSA9IE9iamVjdC5rZXlzKGQuZmlsZXMpLmZpbHRlcihcclxuICAgICAgICAgIGYgPT4gZi5pbmRleE9mKFwic2NoZW1hLmpzb25cIikgPiAtMVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmIChkLmZpbGVzW2ZpbGVdICYmIGQuZmlsZXNbc2NoZW1hRmlsZV0pIHtcclxuICAgICAgICAgIGxldCBfa2V5cyA9IE9iamVjdC5rZXlzKFxyXG4gICAgICAgICAgICBKU09OLnBhcnNlKGQuZmlsZXNbc2NoZW1hRmlsZV0pLmRlZmluaXRpb25zLk9NTS5wcm9wZXJ0aWVzXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgZC5maWxlc1tmaWxlXSA9IGRlbWFuZ2xlcihfa2V5cywgZC5maWxlc1tmaWxlXSk7XHJcbiAgICAgICAgICBfZXhlYyhgJHtmYn0ke2QuZmlsZXNbZmlsZV19OyBPTU0uc2NoZW1hID0gJHtkLmZpbGVzW3NjaGVtYUZpbGVdfTtgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWxlcnQoSlNPTi5zdHJpbmdpZnkoZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IHJlc2V0VGVzdFNjcmlwdCA9ICgpID0+IHtcclxuICAgIGZldGNoKFwiLi90ZXN0L3Rlc3QuanNcIilcclxuICAgICAgLnRoZW4oYXN5bmMgZCA9PiB7XHJcbiAgICAgICAgJFRlc3RFZGl0b3JDb250ZW50cyA9IGF3YWl0IGQudGV4dCgpO1xyXG4gICAgICAgIGxvYWRlZCA9IHRydWU7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICBhbGVydChgTG9hZGluZyBmaWxlIGVycm9yOiAke2V9YCk7XHJcbiAgICAgICAgbG9hZGVkID0gdHJ1ZTtcclxuICAgICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgYXJncyA9IHtcclxuICAgIGRvY3VtZW50TmFtZTogVGVzdEVkaXRvckRvY3VtZW50LFxyXG4gICAgX2NsYXNzOiBcImVkaXRvcjJcIixcclxuICAgIGxhbmd1YWdlOiBcImphdmFzY3JpcHRcIixcclxuICAgIGVkaXRvckNvbnRlbnRzOiBUZXN0RWRpdG9yQ29udGVudHMsXHJcbiAgICB0aGVtZTogXCJ2cy1kYXJrXCJcclxuICB9O1xyXG5cclxuICBvbk1vdW50KCgpID0+IHtcclxuICAgIGlmICghJElETERvY3VtZW50KSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gXCIvc2VsZWN0XCI7XHJcbiAgICB9XHJcbiAgICBkcmFnRWwgPSBbXHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGVzdC10b3AtY29udGFpbmVyXCIpLFxyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRvcC1tZW51XCIpLFxyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImVkaXRvci1jb250YWluZXJcIiksXHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29uc29sZVwiKVxyXG4gICAgXTtcclxuICAgIGxvYWRlZCA9IGZhbHNlO1xyXG4gICAgaWYgKCEkVGVzdEVkaXRvckNvbnRlbnRzKSB7XHJcbiAgICAgIHJlc2V0VGVzdFNjcmlwdCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbG9hZGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIG1vdXNlTW92ZUV2ZW50KCk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBtb3VzZU1vdmVFdmVudCk7XHJcbiAgfSk7XHJcbiAgb25EZXN0cm95KCgpID0+IHtcclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG1vdXNlTW92ZUV2ZW50KTtcclxuICB9KTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcbiAgOnJvb3Qge1xyXG4gICAgLS1jb25zb2xlLWhlaWdodDogMjUwcHg7XHJcbiAgfVxyXG4gICN0ZXN0LXRvcC1jb250YWluZXIge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICB9XHJcblxyXG4gIDpnbG9iYWwoLmVkaXRvcjIpIHtcclxuICAgIGhlaWdodDogMTAwJTtcclxuICB9XHJcbiAgI2VkaXRvci1jb250YWluZXIge1xyXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgIGhlaWdodDogNTAlO1xyXG4gIH1cclxuICAjZWRpdG9yLWNvbnRhaW5lcixcclxuICAjY29uc29sZSB7XHJcbiAgICBmbGV4OiAxIDEgYXV0bztcclxuICB9XHJcbiAgI2NvbnNvbGUge1xyXG4gICAgcGFkZGluZzogNXB4O1xyXG4gICAgcGFkZGluZy1ib3R0b206IDUwcHg7XHJcbiAgICBmb250LXNpemU6IDEycHg7XHJcbiAgICBmb250LXdlaWdodDogNDAwO1xyXG4gICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcclxuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcclxuICAgIG92ZXJmbG93LXg6IG5vbmU7XHJcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcclxuICAgIHdvcmQtd3JhcDogYnJlYWstd29yZDtcclxuICAgIGZvbnQ6IDEycHgvMS4yIHNhbnMtc2VyaWY7XHJcbiAgICBjb2xvcjogIzMzMztcclxuICAgIGhlaWdodDogdmFyKC0tY29uc29sZS1oZWlnaHQpO1xyXG4gIH1cclxuICAjdG9wLW1lbnUge1xyXG4gICAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUtc20pO1xyXG4gICAgcGFkZGluZzogMnB4O1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcbiAgICBncmlkLWdhcDogMTBweDtcclxuICB9XHJcbiAgI3RvcC1tZW51IGRpdiB7XHJcbiAgICBmb250LXdlaWdodDogMzAwO1xyXG4gICAgY29sb3I6ICNlZWU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICBib3JkZXI6IDAuNXB4ICNlZWUgaW5zZXQ7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xyXG4gICAgcGFkZGluZzogOHB4O1xyXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxyXG4gICAgICB0byByaWdodCxcclxuICAgICAgIzhmMDIyMiAwJSxcclxuICAgICAgI2E5MDMyOSA0NCUsXHJcbiAgICAgICM4MzAyMjAgMTAwJVxyXG4gICAgKTtcclxuICB9XHJcbiAgI3RvcC1tZW51IGRpdjpob3ZlciB7XHJcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXHJcbiAgICAgIHRvIHJpZ2h0LFxyXG4gICAgICAjOGYwMjIyIDAlLFxyXG4gICAgICAjYzkwMjMwIDQ0JSxcclxuICAgICAgIzZkMDAxOSAxMDAlXHJcbiAgICApO1xyXG4gIH1cclxuICAjdG9wLW1lbnUgZGl2I3JlbG9hZEVkaXRvcixcclxuICAjdG9wLW1lbnUgZGl2I3J1biB7XHJcbiAgICBtYXgtd2lkdGg6IDIwMHB4O1xyXG4gICAgcmlnaHQ6IDBweDtcclxuICAgIGJhY2tncm91bmQ6IHZhcigtLWJ1dHRvbi1ncmFkaWVudCk7XHJcbiAgfVxyXG4gICN0b3AtbWVudSBkaXYjcmVsb2FkRWRpdG9yOmhvdmVyLFxyXG4gICN0b3AtbWVudSBkaXYjcnVuOmhvdmVyIHtcclxuICAgIG1heC13aWR0aDogMjAwcHg7XHJcbiAgICByaWdodDogMHB4O1xyXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxyXG4gICAgICB0byByaWdodCxcclxuICAgICAgdmFyKC0tY2VsZXN0cmFrLWJsdWUpIDAlLFxyXG4gICAgICAjMDA3ZmUwIDUwJSxcclxuICAgICAgdmFyKC0tY2VsZXN0cmFrLWJsdWUpIDEwMCVcclxuICAgICk7XHJcbiAgfVxyXG4gICNociB7XHJcbiAgICB6LWluZGV4OiAxO1xyXG4gICAgY3Vyc29yOiBucy1yZXNpemU7XHJcbiAgICBoZWlnaHQ6IDIwcHg7XHJcbiAgICBiYWNrZ3JvdW5kOiAjODg4O1xyXG4gICAgYm94LXNoYWRvdzogLTFweCAycHggMnB4IC0xcHggYmxhY2s7XHJcbiAgfVxyXG48L3N0eWxlPlxyXG5cclxuPGRpdiBpZD1cInRlc3QtdG9wLWNvbnRhaW5lclwiPlxyXG4gIDxkaXYgaWQ9XCJ0b3AtbWVudVwiPlxyXG4gICAgPGRpdiBpZD1cInJ1blwiIG9uOmNsaWNrPXsoKSA9PiBydW5UZXN0U2NyaXB0KCl9PlJVTiBDT0RFPC9kaXY+XHJcbiAgICA8ZGl2IHN0eWxlPVwiZm9udC1zaXplOi43cmVtXCI+Tk9URTogVGhpcyB0b29sIG9ubHkgd29ya3MgaW4gQ2hyb21lLjwvZGl2PlxyXG4gICAgPGRpdlxyXG4gICAgICBpZD1cInJlbG9hZEVkaXRvclwiXHJcbiAgICAgIG9uOmNsaWNrPXsoKSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbmZpcm0oJ1Jlc2V0IFRlc3QgRWRpdG9yPycpKSB7XHJcbiAgICAgICAgICByZXNldFRlc3RTY3JpcHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH19PlxyXG4gICAgICBSRUxPQUQgU0NSSVBUXHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuICA8ZGl2IGlkPVwiZWRpdG9yLWNvbnRhaW5lclwiPlxyXG4gICAgPEVkaXRvciB7YXJnc30gLz5cclxuICA8L2Rpdj5cclxuICA8ZGl2XHJcbiAgICBpZD1cImhyXCJcclxuICAgIG9uOm1vdXNlZG93bj17KCkgPT4ge1xyXG4gICAgICBkcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgIFtbJ21vdXNldXAnLCBtb3VzZXVwRXZlbnRdLCBbJ21vdXNlbW92ZScsIG1vdXNlTW92ZUV2ZW50XV0uZm9yRWFjaChlZSA9PiB7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lci5hcHBseShkb2N1bWVudCwgZWUpO1xyXG4gICAgICB9KTtcclxuICAgIH19XHJcbiAgICBvbjp0b3VjaHN0YXJ0PXsoKSA9PiB7XHJcbiAgICAgIGRyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgW1sndG91Y2hjYW5jZWwnLCBtb3VzZXVwRXZlbnRdLCBbJ3RvdWNoZW5kJywgbW91c2V1cEV2ZW50XSwgWyd0b3VjaG1vdmUnLCBtb3VzZU1vdmVFdmVudF1dLmZvckVhY2goXHJcbiAgICAgICAgZWUgPT4ge1xyXG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lci5hcHBseShkb2N1bWVudCwgZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICAgIH19PlxyXG4gICAgJm5ic3A7XHJcbiAgPC9kaXY+XHJcbiAgPHRleHRhcmVhIHJlYWRvbmx5IGlkPVwiY29uc29sZVwiIGJpbmQ6dmFsdWU9e19sb2dPdXRwdXR9IC8+XHJcbjwvZGl2PlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUxFLEtBQUssQUFBQyxDQUFDLEFBQ0wsZ0JBQWdCLENBQUUsS0FBSyxBQUN6QixDQUFDLEFBQ0QsbUJBQW1CLDhCQUFDLENBQUMsQUFDbkIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLE1BQU0sQUFDeEIsQ0FBQyxBQUVPLFFBQVEsQUFBRSxDQUFDLEFBQ2pCLE1BQU0sQ0FBRSxJQUFJLEFBQ2QsQ0FBQyxBQUNELGlCQUFpQiw4QkFBQyxDQUFDLEFBQ2pCLFVBQVUsQ0FBRSxVQUFVLENBQ3RCLE1BQU0sQ0FBRSxHQUFHLEFBQ2IsQ0FBQyxBQUNELCtDQUFpQixDQUNqQixRQUFRLDhCQUFDLENBQUMsQUFDUixJQUFJLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEFBQ2hCLENBQUMsQUFDRCxRQUFRLDhCQUFDLENBQUMsQUFDUixPQUFPLENBQUUsR0FBRyxDQUNaLGNBQWMsQ0FBRSxJQUFJLENBQ3BCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsV0FBVyxDQUFFLFNBQVMsQ0FDdEIsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsVUFBVSxDQUFFLElBQUksQ0FDaEIsV0FBVyxDQUFFLElBQUksQ0FDakIsU0FBUyxDQUFFLFVBQVUsQ0FDckIsSUFBSSxDQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUN6QixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLGdCQUFnQixDQUFDLEFBQy9CLENBQUMsQUFDRCxTQUFTLDhCQUFDLENBQUMsQUFDVCxTQUFTLENBQUUsSUFBSSxjQUFjLENBQUMsQ0FDOUIsT0FBTyxDQUFFLEdBQUcsQ0FDWixPQUFPLENBQUUsSUFBSSxDQUNiLFdBQVcsQ0FBRSxNQUFNLENBQ25CLGVBQWUsQ0FBRSxhQUFhLENBQzlCLFFBQVEsQ0FBRSxJQUFJLEFBQ2hCLENBQUMsQUFDRCx3QkFBUyxDQUFDLEdBQUcsZUFBQyxDQUFDLEFBQ2IsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLE1BQU0sQ0FBRSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FDeEIsTUFBTSxDQUFFLE9BQU8sQ0FDZixPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFdBQVcsQ0FBRSxNQUFNLENBQ25CLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE9BQU8sQ0FBRSxHQUFHLENBQ1osVUFBVSxDQUFFO01BQ1YsRUFBRSxDQUFDLEtBQUssQ0FBQztNQUNULE9BQU8sQ0FBQyxFQUFFLENBQUM7TUFDWCxPQUFPLENBQUMsR0FBRyxDQUFDO01BQ1osT0FBTyxDQUFDLElBQUk7S0FDYixBQUNILENBQUMsQUFDRCx3QkFBUyxDQUFDLGtCQUFHLE1BQU0sQUFBQyxDQUFDLEFBQ25CLFVBQVUsQ0FBRTtNQUNWLEVBQUUsQ0FBQyxLQUFLLENBQUM7TUFDVCxPQUFPLENBQUMsRUFBRSxDQUFDO01BQ1gsT0FBTyxDQUFDLEdBQUcsQ0FBQztNQUNaLE9BQU8sQ0FBQyxJQUFJO0tBQ2IsQUFDSCxDQUFDLEFBQ0Qsd0JBQVMsQ0FBQyxHQUFHLDRCQUFhLENBQzFCLHdCQUFTLENBQUMsR0FBRyxJQUFJLGVBQUMsQ0FBQyxBQUNqQixTQUFTLENBQUUsS0FBSyxDQUNoQixLQUFLLENBQUUsR0FBRyxDQUNWLFVBQVUsQ0FBRSxJQUFJLGlCQUFpQixDQUFDLEFBQ3BDLENBQUMsQUFDRCx3QkFBUyxDQUFDLEdBQUcsNEJBQWEsTUFBTSxDQUNoQyx3QkFBUyxDQUFDLEdBQUcsbUJBQUksTUFBTSxBQUFDLENBQUMsQUFDdkIsU0FBUyxDQUFFLEtBQUssQ0FDaEIsS0FBSyxDQUFFLEdBQUcsQ0FDVixVQUFVLENBQUU7TUFDVixFQUFFLENBQUMsS0FBSyxDQUFDO01BQ1QsSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQztNQUN6QixPQUFPLENBQUMsR0FBRyxDQUFDO01BQ1osSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLElBQUk7S0FDM0IsQUFDSCxDQUFDLEFBQ0QsR0FBRyw4QkFBQyxDQUFDLEFBQ0gsT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsU0FBUyxDQUNqQixNQUFNLENBQUUsSUFBSSxDQUNaLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFVBQVUsQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxBQUNyQyxDQUFDIn0= */";
    	append_dev(document_1$2.head, style);
    }

    function create_fragment$6(ctx) {
    	let div6;
    	let div3;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div4;
    	let t6;
    	let div5;
    	let t8;
    	let textarea;
    	let current;
    	let dispose;

    	const editor = new MonacoEditor({
    			props: { args: /*args*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "RUN CODE";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "NOTE: This tool only works in Chrome.";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "RELOAD SCRIPT";
    			t5 = space();
    			div4 = element("div");
    			create_component(editor.$$.fragment);
    			t6 = space();
    			div5 = element("div");
    			div5.textContent = "";
    			t8 = space();
    			textarea = element("textarea");
    			attr_dev(div0, "id", "run");
    			attr_dev(div0, "class", "svelte-1sv0ypf");
    			add_location(div0, file$5, 275, 4, 6903);
    			set_style(div1, "font-size", ".7rem");
    			attr_dev(div1, "class", "svelte-1sv0ypf");
    			add_location(div1, file$5, 276, 4, 6970);
    			attr_dev(div2, "id", "reloadEditor");
    			attr_dev(div2, "class", "svelte-1sv0ypf");
    			add_location(div2, file$5, 277, 4, 7048);
    			attr_dev(div3, "id", "top-menu");
    			attr_dev(div3, "class", "svelte-1sv0ypf");
    			add_location(div3, file$5, 274, 2, 6878);
    			attr_dev(div4, "id", "editor-container");
    			attr_dev(div4, "class", "svelte-1sv0ypf");
    			add_location(div4, file$5, 287, 2, 7247);
    			attr_dev(div5, "id", "hr");
    			attr_dev(div5, "class", "svelte-1sv0ypf");
    			add_location(div5, file$5, 290, 2, 7311);
    			textarea.readOnly = true;
    			attr_dev(textarea, "id", "console");
    			attr_dev(textarea, "class", "svelte-1sv0ypf");
    			add_location(textarea, file$5, 308, 2, 7826);
    			attr_dev(div6, "id", "test-top-container");
    			attr_dev(div6, "class", "svelte-1sv0ypf");
    			add_location(div6, file$5, 273, 0, 6845);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div3);
    			append_dev(div3, div0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div6, t5);
    			append_dev(div6, div4);
    			mount_component(editor, div4, null);
    			append_dev(div6, t6);
    			append_dev(div6, div5);
    			append_dev(div6, t8);
    			append_dev(div6, textarea);
    			set_input_value(textarea, /*_logOutput*/ ctx[1]);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(div0, "click", /*click_handler*/ ctx[19], false, false, false),
    				listen_dev(div2, "click", /*click_handler_1*/ ctx[20], false, false, false),
    				listen_dev(div5, "mousedown", /*mousedown_handler*/ ctx[21], false, false, false),
    				listen_dev(div5, "touchstart", /*touchstart_handler*/ ctx[22], { passive: true }, false, false),
    				listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[23])
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			const editor_changes = {};
    			if (dirty & /*args*/ 1) editor_changes.args = /*args*/ ctx[0];
    			editor.$set(editor_changes);

    			if (dirty & /*_logOutput*/ 2) {
    				set_input_value(textarea, /*_logOutput*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(editor);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const workerPath$2 = "/workers/worker.js";

    function instance$6($$self, $$props, $$invalidate) {
    	let $saveEventTime;
    	let $TestEditorContents;
    	let $IDLEditorContents;
    	let $IDLDocument;
    	validate_store(saveEventTime, "saveEventTime");
    	component_subscribe($$self, saveEventTime, $$value => $$invalidate(12, $saveEventTime = $$value));
    	validate_store(TestEditorContents, "TestEditorContents");
    	component_subscribe($$self, TestEditorContents, $$value => $$invalidate(13, $TestEditorContents = $$value));
    	validate_store(IDLEditorContents, "IDLEditorContents");
    	component_subscribe($$self, IDLEditorContents, $$value => $$invalidate(14, $IDLEditorContents = $$value));
    	validate_store(IDLDocument, "IDLDocument");
    	component_subscribe($$self, IDLDocument, $$value => $$invalidate(15, $IDLDocument = $$value));
    	let { loaded } = $$props;
    	let { args } = $$props;
    	let carat = `>`;
    	let _logOutput = `${carat}\n`;
    	let startLine = 0;
    	let _worker;
    	let _running;
    	let dragging;
    	let dragEl = [];

    	let mouseupEvent = () => {
    		$$invalidate(2, dragging = false);
    		scrollDown();
    		document.removeEventListener("mouseup", mouseupEvent);
    		document.removeEventListener("mousemove", mouseMoveEvent);
    	};

    	let mouseMoveEvent = e => {
    		e = e && e.touches ? e.touches[0] : e;

    		if (e) {
    			dragEl[3].style.height = dragging
    			? `${Math.max(10, window.innerHeight - e.clientY - 2 * parseInt(globalThis.getComputedStyle(document.getElementById("hr")).height.replace("px", "")))}px`
    			: dragEl[3].style.height;
    		}

    		dragEl[2].style.height = `${window.innerHeight - document.getElementsByTagName("header")[0].clientHeight - dragEl[1].clientHeight - dragEl[3].clientHeight}px`;
    	};

    	const scrollDown = () => setTimeout(
    		() => {
    			let ta = document.getElementById("console");

    			if (ta) {
    				ta.scrollTop = ta.scrollHeight;
    			}
    		},
    		10
    	);

    	let _exec = code => {
    		if (_worker) _worker.terminate();
    		let _preamble = `${ws}${code}`;
    		startLine = _preamble.match(/\n/g).length;
    		_worker = new Worker(window.URL.createObjectURL(new Blob([`${_preamble}${$TestEditorContents}`], { type: "text/javascript" })));
    		$$invalidate(1, _logOutput = "");

    		_worker.onmessage = e => {
    			if (e.data === "done") _worker.terminate();

    			if (e.data.global) {
    				globalThis[e.data.globalName] = e.data.global;
    			} else $$invalidate(1, _logOutput += `${carat} ${e.data.join("")}  \n`);

    			scrollDown();
    		};

    		_worker.onerror = function (err) {
    			$$invalidate(1, _logOutput += `${err.message}  at line ${err.lineno - startLine}`);
    			_worker.terminate();
    		};
    	};

    	function runTestScript() {
    		if (_running) return;
    		_running = true;

    		if ($IDLEditorContents) {
    			$$invalidate(1, _logOutput = `${carat} LOADING ...`);

    			let inputObject = {
    				currentLanguage: ["--js", "Generate JavaScript code", "js", "js", "text/javascript"],
    				IDLDocument: "JSTEST",
    				IDLEditorContents: $IDLEditorContents,
    				loaded
    			};

    			workerLoader(workerPath$2, inputObject, function (d) {
    				_running = false;
    				let file = Object.keys(d.files).filter(f => f.slice(f.lastIndexOf(".")) === ".js");
    				let schemaFile = Object.keys(d.files).filter(f => f.indexOf("schema.json") > -1);

    				if (d.files[file] && d.files[schemaFile]) {
    					let _keys = Object.keys(JSON.parse(d.files[schemaFile]).definitions.OMM.properties);
    					d.files[file] = demangler(_keys, d.files[file]);
    					_exec(`${fb}${d.files[file]}; OMM.schema = ${d.files[schemaFile]};`);
    				} else {
    					alert(JSON.stringify(d));
    				}
    			});
    		}
    	}

    	const resetTestScript = () => {
    		fetch("./test/test.js").then(async d => {
    			set_store_value(TestEditorContents, $TestEditorContents = await d.text());
    			$$invalidate(7, loaded = true);
    		}).catch(e => {
    			alert(`Loading file error: ${e}`);
    			$$invalidate(7, loaded = true);
    		});
    	};

    	args = {
    		documentName: TestEditorDocument,
    		_class: "editor2",
    		language: "javascript",
    		editorContents: TestEditorContents,
    		theme: "vs-dark"
    	};

    	onMount(() => {
    		if (!$IDLDocument) {
    			window.location.hash = "/select";
    		}

    		dragEl = [
    			document.getElementById("test-top-container"),
    			document.getElementById("top-menu"),
    			document.getElementById("editor-container"),
    			document.getElementById("console")
    		];

    		$$invalidate(7, loaded = false);

    		if (!$TestEditorContents) {
    			resetTestScript();
    		} else {
    			$$invalidate(7, loaded = true);
    		}

    		mouseMoveEvent();
    		window.addEventListener("resize", mouseMoveEvent);
    	});

    	onDestroy(() => {
    		window.removeEventListener("resize", mouseMoveEvent);
    	});

    	const writable_props = ["loaded", "args"];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Test> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Test", $$slots, []);
    	const click_handler = () => runTestScript();

    	const click_handler_1 = () => {
    		if (confirm("Reset Test Editor?")) {
    			resetTestScript();
    		}
    	};

    	const mousedown_handler = () => {
    		$$invalidate(2, dragging = true);

    		[["mouseup", mouseupEvent], ["mousemove", mouseMoveEvent]].forEach(ee => {
    			document.addEventListener.apply(document, ee);
    		});
    	};

    	const touchstart_handler = () => {
    		$$invalidate(2, dragging = true);

    		[
    			["touchcancel", mouseupEvent],
    			["touchend", mouseupEvent],
    			["touchmove", mouseMoveEvent]
    		].forEach(ee => {
    			document.addEventListener.apply(document, ee);
    		});
    	};

    	function textarea_input_handler() {
    		_logOutput = this.value;
    		$$invalidate(1, _logOutput);
    	}

    	$$self.$set = $$props => {
    		if ("loaded" in $$props) $$invalidate(7, loaded = $$props.loaded);
    		if ("args" in $$props) $$invalidate(0, args = $$props.args);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		Editor: MonacoEditor,
    		IDLDocument,
    		IDLEditorContents,
    		TestEditorDocument,
    		TestEditorContents,
    		saveEventTime,
    		fb,
    		ws,
    		workerLoader,
    		demangler,
    		loaded,
    		args,
    		workerPath: workerPath$2,
    		carat,
    		_logOutput,
    		startLine,
    		_worker,
    		_running,
    		dragging,
    		dragEl,
    		mouseupEvent,
    		mouseMoveEvent,
    		scrollDown,
    		_exec,
    		runTestScript,
    		resetTestScript,
    		$saveEventTime,
    		$TestEditorContents,
    		$IDLEditorContents,
    		$IDLDocument
    	});

    	$$self.$inject_state = $$props => {
    		if ("loaded" in $$props) $$invalidate(7, loaded = $$props.loaded);
    		if ("args" in $$props) $$invalidate(0, args = $$props.args);
    		if ("carat" in $$props) carat = $$props.carat;
    		if ("_logOutput" in $$props) $$invalidate(1, _logOutput = $$props._logOutput);
    		if ("startLine" in $$props) startLine = $$props.startLine;
    		if ("_worker" in $$props) _worker = $$props._worker;
    		if ("_running" in $$props) _running = $$props._running;
    		if ("dragging" in $$props) $$invalidate(2, dragging = $$props.dragging);
    		if ("dragEl" in $$props) dragEl = $$props.dragEl;
    		if ("mouseupEvent" in $$props) $$invalidate(3, mouseupEvent = $$props.mouseupEvent);
    		if ("mouseMoveEvent" in $$props) $$invalidate(4, mouseMoveEvent = $$props.mouseMoveEvent);
    		if ("_exec" in $$props) _exec = $$props._exec;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$saveEventTime*/ 4096) {
    			 {
    				if ($saveEventTime) {
    					runTestScript();
    				}
    			}
    		}
    	};

    	return [
    		args,
    		_logOutput,
    		dragging,
    		mouseupEvent,
    		mouseMoveEvent,
    		runTestScript,
    		resetTestScript,
    		loaded,
    		startLine,
    		_worker,
    		_running,
    		dragEl,
    		$saveEventTime,
    		$TestEditorContents,
    		$IDLEditorContents,
    		$IDLDocument,
    		carat,
    		scrollDown,
    		_exec,
    		click_handler,
    		click_handler_1,
    		mousedown_handler,
    		touchstart_handler,
    		textarea_input_handler
    	];
    }

    class Test extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		if (!document_1$2.getElementById("svelte-1sv0ypf-style")) add_css$4();
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { loaded: 7, args: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Test",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*loaded*/ ctx[7] === undefined && !("loaded" in props)) {
    			console.warn("<Test> was created without expected prop 'loaded'");
    		}

    		if (/*args*/ ctx[0] === undefined && !("args" in props)) {
    			console.warn("<Test> was created without expected prop 'args'");
    		}
    	}

    	get loaded() {
    		throw new Error("<Test>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaded(value) {
    		throw new Error("<Test>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get args() {
    		throw new Error("<Test>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set args(value) {
    		throw new Error("<Test>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Loader.svelte generated by Svelte v3.20.1 */

    const file$6 = "src/Loader.svelte";

    function add_css$5() {
    	var style = element("style");
    	style.id = "svelte-1f89n5p-style";
    	style.textContent = "#loaderBox.svelte-1f89n5p{position:fixed;width:100vw;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100;background:#ffffffaa}h1.svelte-1f89n5p{color:var(--celestrak-blue)}svg.svelte-1f89n5p{animation:2s linear infinite svelte-1f89n5p-svg-animation;max-width:100px;height:20vw;width:20vw}@keyframes svelte-1f89n5p-svg-animation{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}circle.svelte-1f89n5p{animation:1.4s ease-in-out infinite both svelte-1f89n5p-circle-animation;display:block;fill:transparent;stroke:var(--celestrak-blue);stroke-linecap:round;stroke-dasharray:283;stroke-dashoffset:280;stroke-width:10px;transform-origin:50% 50%}@keyframes svelte-1f89n5p-circle-animation{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGVyLnN2ZWx0ZSIsInNvdXJjZXMiOlsiTG9hZGVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c3R5bGU+XG4gICNsb2FkZXJCb3gge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB3aWR0aDogMTAwdnc7XG4gICAgaGVpZ2h0OiAxMDB2aDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICB6LWluZGV4OiAxMDA7XG4gICAgYmFja2dyb3VuZDogI2ZmZmZmZmFhO1xuICB9XG4gIGgxIHtcbiAgICBjb2xvcjogdmFyKC0tY2VsZXN0cmFrLWJsdWUpO1xuICB9XG4gIHN2ZyB7XG4gICAgYW5pbWF0aW9uOiAycyBsaW5lYXIgaW5maW5pdGUgc3ZnLWFuaW1hdGlvbjtcbiAgICBtYXgtd2lkdGg6IDEwMHB4O1xuICAgIGhlaWdodDogMjB2dztcbiAgICB3aWR0aDogMjB2dztcbiAgfVxuXG4gIEBrZXlmcmFtZXMgc3ZnLWFuaW1hdGlvbiB7XG4gICAgMCUge1xuICAgICAgdHJhbnNmb3JtOiByb3RhdGVaKDBkZWcpO1xuICAgIH1cbiAgICAxMDAlIHtcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlWigzNjBkZWcpO1xuICAgIH1cbiAgfVxuXG4gIGNpcmNsZSB7XG4gICAgYW5pbWF0aW9uOiAxLjRzIGVhc2UtaW4tb3V0IGluZmluaXRlIGJvdGggY2lyY2xlLWFuaW1hdGlvbjtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBmaWxsOiB0cmFuc3BhcmVudDtcbiAgICBzdHJva2U6IHZhcigtLWNlbGVzdHJhay1ibHVlKTtcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XG4gICAgc3Ryb2tlLWRhc2hhcnJheTogMjgzO1xuICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAyODA7XG4gICAgc3Ryb2tlLXdpZHRoOiAxMHB4O1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XG4gIH1cblxuICBAa2V5ZnJhbWVzIGNpcmNsZS1hbmltYXRpb24ge1xuICAgIDAlLFxuICAgIDI1JSB7XG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogMjgwO1xuICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMCk7XG4gICAgfVxuXG4gICAgNTAlLFxuICAgIDc1JSB7XG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogNzU7XG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XG4gICAgfVxuXG4gICAgMTAwJSB7XG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogMjgwO1xuICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgICB9XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXYgaWQ9XCJsb2FkZXJCb3hcIj5cbiAgPHN2ZyB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI0NVwiIC8+XG4gIDwvc3ZnPlxuICA8aDE+TE9BRElORzwvaDE+XG48L2Rpdj5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDRSxVQUFVLGVBQUMsQ0FBQyxBQUNWLFFBQVEsQ0FBRSxLQUFLLENBQ2YsS0FBSyxDQUFFLEtBQUssQ0FDWixNQUFNLENBQUUsS0FBSyxDQUNiLE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLE1BQU0sQ0FDdEIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsT0FBTyxDQUFFLEdBQUcsQ0FDWixVQUFVLENBQUUsU0FBUyxBQUN2QixDQUFDLEFBQ0QsRUFBRSxlQUFDLENBQUMsQUFDRixLQUFLLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxBQUM5QixDQUFDLEFBQ0QsR0FBRyxlQUFDLENBQUMsQUFDSCxTQUFTLENBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsNEJBQWEsQ0FDM0MsU0FBUyxDQUFFLEtBQUssQ0FDaEIsTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsSUFBSSxBQUNiLENBQUMsQUFFRCxXQUFXLDRCQUFjLENBQUMsQUFDeEIsRUFBRSxBQUFDLENBQUMsQUFDRixTQUFTLENBQUUsUUFBUSxJQUFJLENBQUMsQUFDMUIsQ0FBQyxBQUNELElBQUksQUFBQyxDQUFDLEFBQ0osU0FBUyxDQUFFLFFBQVEsTUFBTSxDQUFDLEFBQzVCLENBQUMsQUFDSCxDQUFDLEFBRUQsTUFBTSxlQUFDLENBQUMsQUFDTixTQUFTLENBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLCtCQUFnQixDQUMxRCxPQUFPLENBQUUsS0FBSyxDQUNkLElBQUksQ0FBRSxXQUFXLENBQ2pCLE1BQU0sQ0FBRSxJQUFJLGdCQUFnQixDQUFDLENBQzdCLGNBQWMsQ0FBRSxLQUFLLENBQ3JCLGdCQUFnQixDQUFFLEdBQUcsQ0FDckIsaUJBQWlCLENBQUUsR0FBRyxDQUN0QixZQUFZLENBQUUsSUFBSSxDQUNsQixnQkFBZ0IsQ0FBRSxHQUFHLENBQUMsR0FBRyxBQUMzQixDQUFDLEFBRUQsV0FBVywrQkFBaUIsQ0FBQyxBQUMzQixFQUFFLENBQ0YsR0FBRyxBQUFDLENBQUMsQUFDSCxpQkFBaUIsQ0FBRSxHQUFHLENBQ3RCLFNBQVMsQ0FBRSxPQUFPLENBQUMsQ0FBQyxBQUN0QixDQUFDLEFBRUQsR0FBRyxDQUNILEdBQUcsQUFBQyxDQUFDLEFBQ0gsaUJBQWlCLENBQUUsRUFBRSxDQUNyQixTQUFTLENBQUUsT0FBTyxLQUFLLENBQUMsQUFDMUIsQ0FBQyxBQUVELElBQUksQUFBQyxDQUFDLEFBQ0osaUJBQWlCLENBQUUsR0FBRyxDQUN0QixTQUFTLENBQUUsT0FBTyxNQUFNLENBQUMsQUFDM0IsQ0FBQyxBQUNILENBQUMifQ== */";
    	append_dev(document.head, style);
    }

    function create_fragment$7(ctx) {
    	let div;
    	let svg;
    	let circle;
    	let t0;
    	let h1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = "LOADING";
    			attr_dev(circle, "cx", "50");
    			attr_dev(circle, "cy", "50");
    			attr_dev(circle, "r", "45");
    			attr_dev(circle, "class", "svelte-1f89n5p");
    			add_location(circle, file$6, 65, 4, 1208);
    			attr_dev(svg, "viewBox", "0 0 100 100");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "class", "svelte-1f89n5p");
    			add_location(svg, file$6, 64, 2, 1141);
    			attr_dev(h1, "class", "svelte-1f89n5p");
    			add_location(h1, file$6, 67, 2, 1253);
    			attr_dev(div, "id", "loaderBox");
    			attr_dev(div, "class", "svelte-1f89n5p");
    			add_location(div, file$6, 63, 0, 1118);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, circle);
    			append_dev(div, t0);
    			append_dev(div, h1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Loader> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Loader", $$slots, []);
    	return [];
    }

    class Loader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		if (!document.getElementById("svelte-1f89n5p-style")) add_css$5();
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loader",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    function convert (str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    function Navaid(base, on404) {
    	var rgx,
    		routes = [],
    		$ = {};

    	var fmt = ($.format = function(uri) {
    		if (!uri) return uri;
    		uri = "/" + uri.replace(/^\/|\/$/g, "");
    		return rgx.test(uri) && uri.replace(rgx, "/");
    	});

    	base = "/" + (base || "").replace(/^\/|\/$/g, "");
    	rgx = base == "/" ? /^\/+/ : new RegExp("^\\" + base + "(?=\\/|$)\\/?", "i");

    	$.route = function(uri, replace) {
    		if (uri[0] == "/" && !rgx.test(uri)) uri = base + uri;
    		history[(replace ? "replace" : "push") + "State"](uri, null, uri);
    	};

    	$.on = function(pat, fn) {
    		(pat = convert(pat)).fn = fn;
    		routes.push(pat);
    		return $;
    	};

    	$.run = function(uri) {
    		var i = 0,
    			params = {},
    			arr,
    			obj;
    		if ((uri = fmt(uri || location.href.replace(location.origin, "")))) {
    			//uri = uri.match(/[^\?#]*/)[0];
    			for (; i < routes.length; i++) {
    				uri = uri.indexOf("?") > -1 ? uri.replace(location.search, "") : uri;
    				if ((arr = (obj = routes[i]).pattern.exec(uri))) {
    					for (i = 0; i < obj.keys.length; ) {
    						params[obj.keys[i]] = arr[++i] || null;
    					}
    					obj.fn(params); // todo loop?
    					return $;
    				}
    			}
    			if (on404) on404(uri);
    		}
    		return $;
    	};

    	$.listen = function(u) {
    		wrap("push");
    		wrap("replace");

    		function run(e) {
    			$.run();
    		}

    		function click(e) {
    			var x = e.target.closest("a"),
    				y = x && x.getAttribute("href");
    			if (
    				e.ctrlKey ||
    				e.metaKey ||
    				e.altKey ||
    				e.shiftKey ||
    				e.button ||
    				e.defaultPrevented
    			)
    				return;
    			if (!y || x.target || x.host !== location.host) return;
    			if (y[0] != "/" || rgx.test(y)) {
    				e.preventDefault();
    				$.route(y);
    			}
    		}

    		addEventListener("popstate", run);
    		addEventListener("replacestate", run);
    		addEventListener("pushstate", run);
    		addEventListener("click", click);
    		addEventListener("hashChange", run);
    		$.unlisten = function() {
    			removeEventListener("popstate", run);
    			removeEventListener("replacestate", run);
    			removeEventListener("pushstate", run);
    			removeEventListener("click", click);
    			removeEventListener("hashChange", run);
    		};

    		return $.run(u);
    	};

    	return $;
    }

    function wrap(type, fn) {
    	if (history[type]) return;
    	history[type] = type;
    	fn = history[(type += "State")];
    	history[type] = function(uri) {
    		var ev = new Event(type.toLowerCase());
    		ev.uri = uri;
    		fn.apply(this, arguments);
    		return dispatchEvent(ev);
    	};
    }

    let routeparams = writable({});

    /* src/App.svelte generated by Svelte v3.20.1 */

    const { document: document_1$3 } = globals;

    const file$7 = "src/App.svelte";

    function add_css$6() {
    	var style = element("style");
    	style.id = "svelte-f415ab-style";
    	style.textContent = ":root{--font-size-sm:calc((0.85rem + 0.5 * ((100vw - 50rem) / 120)));--font-size-btn:calc((1.5rem + 0.5 * ((100vw - 50rem) / 120)));--font-size-header:calc((1rem + 0.5 * ((100vw - 80rem) / 120)));--celestrak-blue:#1e5cad;--font-family:-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto,\r\n      Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif;--header-height:50px;--container-position:0px;--menu-width:30vw;--header-gradient:linear-gradient(\r\n      to bottom,\r\n      var(--celestrak-blue) 20%,\r\n      #2963af 50%,\r\n      var(--celestrak-blue) 80%\r\n    );--button-gradient:linear-gradient(\r\n      to right,\r\n      var(--celestrak-blue) 0%,\r\n      #2b66b3 50%,\r\n      var(--celestrak-blue) 100%\r\n    )}.editor1{height:calc(99.99vh - var(--header-height))}html, body{position:relative;width:100%;height:100%;overflow:hidden;position:fixed}body{padding-bottom:20px;background:#164583;color:#333;margin:0;box-sizing:border-box;font-family:var(--font-family)}div{box-sizing:border-box;user-select:none}main.svelte-f415ab.svelte-f415ab{margin:0 auto;display:grid;grid-template-columns:100vw}header.svelte-f415ab.svelte-f415ab{background:var(--header-gradient);color:white;padding:2px;box-sizing:border-box;margin-bottom:1px;display:flex;align-items:center;justify-content:center}container.svelte-f415ab.svelte-f415ab{display:grid;grid-template-rows:var(--header-height) auto;height:100vh;width:100vw;box-sizing:border-box;overflow:hidden;position:relative;left:var(--container-position);transition:all 0.1s;background:white;box-shadow:-5px 2px 6px 7px #00000044}@media(min-width: 640px){main.svelte-f415ab.svelte-f415ab{max-width:none;z-index:1;background:white}}#mainContainer.svelte-f415ab.svelte-f415ab{width:100%}#links.svelte-f415ab.svelte-f415ab{box-sizing:border-box;display:grid;grid-gap:4px;grid-template-columns:auto;font-size:var(--font-size-header);padding-right:10px}#links.svelte-f415ab a.svelte-f415ab,header.svelte-f415ab a.svelte-f415ab,menu.svelte-f415ab a.svelte-f415ab{color:#fff;font-weight:300;text-decoration:none;cursor:pointer;border:0.5px #ccc solid;padding:5px}#menuButton.svelte-f415ab.svelte-f415ab{color:#eee;padding-left:10px;display:flex;cursor:pointer;font-size:30px;position:absolute;justify-content:center;align-items:center;left:0px}menu.svelte-f415ab a.svelte-f415ab{border:none;width:100%;height:100%;display:flex;justify-content:center;align-items:center}menu.svelte-f415ab.svelte-f415ab{position:fixed;left:-100%;padding:0px;width:var(--menu-width);height:100vh;background:#164583;margin:0px}menu.navActive.svelte-f415ab.svelte-f415ab{left:0px}menu.svelte-f415ab div.svelte-f415ab{height:var(--header-height);border-bottom:1px #aaa solid;width:100%;display:flex;justify-content:center;align-items:center;cursor:pointer;color:#eee;background:#164583}menu.svelte-f415ab div.svelte-f415ab:hover{background:#1a529b}#links.svelte-f415ab.svelte-f415ab{position:absolute;right:0px}#links.svelte-f415ab a.svelte-f415ab:hover{background:#eee;color:#333}#mainHeader.svelte-f415ab span.svelte-f415ab{font-size:var(--font-size-header);display:flex}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXBwLnN2ZWx0ZSIsInNvdXJjZXMiOlsiQXBwLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxyXG4gIGltcG9ydCB7IG9uTW91bnQsIG9uRGVzdHJveSB9IGZyb20gXCJzdmVsdGVcIjtcclxuICBpbXBvcnQgeyBvbkxvYWQgfSBmcm9tIFwiLi9saWIvZ2xvYmFsLmpzXCI7XHJcbiAgaW1wb3J0IE1haW4gZnJvbSBcIi4vY29tcG9uZW50cy9NYWluL01haW4uc3ZlbHRlXCI7XHJcbiAgaW1wb3J0IFNlbGVjdCBmcm9tIFwiLi9jb21wb25lbnRzL1NlbGVjdC9TZWxlY3Quc3ZlbHRlXCI7XHJcbiAgaW1wb3J0IEVkaXRvciBmcm9tIFwiLi9jb21wb25lbnRzL01vbmFjb0VkaXRvci9Nb25hY29FZGl0b3Iuc3ZlbHRlXCI7XHJcbiAgaW1wb3J0IENvZGUgZnJvbSBcIi4vY29tcG9uZW50cy9Db2RlL0NvZGUuc3ZlbHRlXCI7XHJcbiAgaW1wb3J0IEV4YW1wbGVzIGZyb20gXCIuL2NvbXBvbmVudHMvRXhhbXBsZXMvRXhhbXBsZXMuc3ZlbHRlXCI7XHJcblxyXG4gIGltcG9ydCBUZXN0IGZyb20gXCIuL2NvbXBvbmVudHMvVGVzdC9UZXN0LnN2ZWx0ZVwiO1xyXG4gIGltcG9ydCBkb3dubG9hZCBmcm9tIFwiZG93bmxvYWRqc1wiO1xyXG4gIGltcG9ydCBMb2FkZXIgZnJvbSBcIi4vTG9hZGVyLnN2ZWx0ZVwiO1xyXG4gIGltcG9ydCBOYXZhaWQgZnJvbSBcIm5hdmFpZFwiO1xyXG4gIGltcG9ydCB7IHJvdXRlcGFyYW1zIH0gZnJvbSBcIi4vc3RvcmVzL1JvdXRlXCI7XHJcbiAgd2luZG93LmRvd25sb2FkID0gZG93bmxvYWQ7XHJcbiAgaW1wb3J0IHtcclxuICAgIG1hbmlmZXN0LFxyXG4gICAgSURMRG9jdW1lbnQsXHJcbiAgICBJRExFZGl0b3JDb250ZW50cyxcclxuICAgIENvZGVFZGl0b3JBY3RpdmVEb2N1bWVudCxcclxuICAgIENvZGVFZGl0b3JDb250ZW50cyxcclxuICAgIENvZGVFZGl0b3JMYW5ndWFnZSxcclxuICAgIFRlc3RFZGl0b3JEb2N1bWVudCxcclxuICAgIFRlc3RFZGl0b3JDb250ZW50cyxcclxuICAgIHNhdmVFdmVudFRpbWVcclxuICB9IGZyb20gXCIuL3N0b3Jlcy9GaWxlcy5qc1wiO1xyXG5cclxuICBsZXQgbWVudU9wZW4gPSBmYWxzZTtcclxuICBsZXQgbG9hZGVkID0gZmFsc2U7XHJcbiAgbGV0IGVkaXRvciA9IG51bGw7XHJcblxyXG4gIGxldCBhcmdzID0ge307XHJcbiAgY29uc3QgZ2l0aHViVVJMID0gXCJodHRwczovL2dpdGh1Yi5jb20vRGlnaXRhbEFyc2VuYWwvc3BhY2VkYXRhc3RhbmRhcmRzLm9yZ1wiO1xyXG4gICQ6IGxpbmsgPSBgaHR0cHM6Ly9wdWJsaWMuY2NzZHMub3JnL1B1YnMvJHsoJElETERvY3VtZW50IHx8IFwiXCIpLm1hdGNoKFxyXG4gICAgL1xcd3sxLH0vXHJcbiAgKX0ucGRmYDtcclxuXHJcbiAgY29uc3Qgc2V0Um91dGUgPSAoX3BhcmFtcywgX2NvbXBvbmVudCkgPT4ge1xyXG4gICAgJHJvdXRlcGFyYW1zID0gX3BhcmFtcztcclxuICAgIGFjdGl2ZUNvbXBvbmVudCA9IF9jb21wb25lbnQ7XHJcbiAgfTtcclxuICAkOiBsaW5rTmFtZSA9ICgkSURMRG9jdW1lbnQgfHwgXCJcIikubWF0Y2goL1xcd3sxLH0vKTtcclxuXHJcbiAgbGV0IGFjdGl2ZUNvbXBvbmVudCA9IEVkaXRvcjtcclxuXHJcbiAgbGV0IGRlZmF1bHRQYXRoID0gcGFyYW1zID0+IHtcclxuICAgIHNldFJvdXRlKHBhcmFtcywgTWFpbik7XHJcbiAgfTtcclxuXHJcbiAgbGV0IHJvdXRlciA9IG5ldyBOYXZhaWQoXCIvXCIsIGRlZmF1bHRQYXRoKTtcclxuXHJcbiAgcm91dGVyLm9uKFwiL1wiLCBkZWZhdWx0UGF0aCk7XHJcbiAgcm91dGVyLm9uKFwiLyMvXCIsIGRlZmF1bHRQYXRoKTtcclxuICByb3V0ZXIub24oXCIvIy9zZWxlY3RcIiwgcGFyYW1zID0+IHtcclxuICAgIGFyZ3MgPSB7fTtcclxuICAgIHNldFJvdXRlKHBhcmFtcywgU2VsZWN0KTtcclxuICB9KTtcclxuICByb3V0ZXIub24oXCIvIy9pZGxcIiwgcGFyYW1zID0+IHtcclxuICAgIGFyZ3MgPSB7XHJcbiAgICAgIGRvY3VtZW50TmFtZTogSURMRG9jdW1lbnQsXHJcbiAgICAgIGVkaXRvckNvbnRlbnRzOiBJRExFZGl0b3JDb250ZW50cyxcclxuICAgICAgbGFuZ3VhZ2U6IFwiZmxhdGJ1ZmZlcnNcIixcclxuICAgICAgdGhlbWU6IFwiZmxhdGJ1ZmZlcnNcIixcclxuICAgICAgX2NsYXNzOiBcImVkaXRvcjFcIlxyXG4gICAgfTtcclxuICAgIHNldFJvdXRlKHBhcmFtcywgRWRpdG9yKTtcclxuICB9KTtcclxuXHJcbiAgcm91dGVyLm9uKFwiLyMvY29kZVwiLCBwYXJhbXMgPT4ge1xyXG4gICAgYXJncyA9IHtcclxuICAgICAgZG9jdW1lbnROYW1lOiBDb2RlRWRpdG9yQWN0aXZlRG9jdW1lbnQsXHJcbiAgICAgIGVkaXRvckNvbnRlbnRzOiBDb2RlRWRpdG9yQ29udGVudHMsXHJcbiAgICAgIGxhbmd1YWdlOiBcIlwiLFxyXG4gICAgICB0aGVtZTogXCJcIixcclxuICAgICAgX2NsYXNzOiBcImVkaXRvcjFcIixcclxuICAgICAgcmVhZE9ubHk6IHRydWVcclxuICAgIH07XHJcbiAgICBzZXRSb3V0ZShwYXJhbXMsIENvZGUpO1xyXG4gIH0pO1xyXG4gIHJvdXRlci5vbihcIi8jL2V4YW1wbGVzXCIsIHBhcmFtcyA9PiB7XHJcbiAgICBhcmdzID0ge1xyXG4gICAgICBkb2N1bWVudE5hbWU6IFwiXCIsXHJcbiAgICAgIGVkaXRvckNvbnRlbnRzOiBcIlwiLFxyXG4gICAgICBsYW5ndWFnZTogXCJcIixcclxuICAgICAgdGhlbWU6IFwiXCIsXHJcbiAgICAgIF9jbGFzczogXCJlZGl0b3IxXCIsXHJcbiAgICAgIHJlYWRPbmx5OiB0cnVlXHJcbiAgICB9O1xyXG4gICAgc2V0Um91dGUocGFyYW1zLCBFeGFtcGxlcyk7XHJcbiAgfSk7XHJcbiAgcm91dGVyLm9uKFwiLyMvdGVzdFwiLCBwYXJhbXMgPT4ge1xyXG4gICAgYXJncyA9IHtcclxuICAgICAgZG9jdW1lbnROYW1lOiBUZXN0RWRpdG9yRG9jdW1lbnQsXHJcbiAgICAgIGVkaXRvckNvbnRlbnRzOiBUZXN0RWRpdG9yQ29udGVudHMsXHJcbiAgICAgIGxhbmd1YWdlOiBcIlwiLFxyXG4gICAgICB0aGVtZTogXCJcIixcclxuICAgICAgX2NsYXNzOiBcImVkaXRvcjFcIixcclxuICAgICAgcmVhZE9ubHk6IHRydWVcclxuICAgIH07XHJcbiAgICBzZXRSb3V0ZShwYXJhbXMsIFRlc3QpO1xyXG4gIH0pO1xyXG5cclxuICByb3V0ZXIubGlzdGVuKCk7XHJcblxyXG4gIGNvbnN0IHRvZ2dsZU1lbnUgPSB2YWx1ZSA9PiB7XHJcbiAgICBtZW51T3BlbiA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6ICFtZW51T3BlbjtcclxuICAgIGxldCBwb3NWYWwgPSBtZW51T3BlbiA/IFwiMzB2d1wiIDogXCIwdndcIjtcclxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tY29udGFpbmVyLXBvc2l0aW9uXCIsIHBvc1ZhbCk7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlRG93bmxvYWQoKSB7XHJcbiAgICBsZXQgZEwgPSBbXTtcclxuICAgIGlmIChhY3RpdmVDb21wb25lbnQgPT09IEVkaXRvcikge1xyXG4gICAgICBkTCA9IFskSURMRWRpdG9yQ29udGVudHMsICRJRExEb2N1bWVudF07XHJcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZUNvbXBvbmVudCA9PT0gQ29kZSkge1xyXG4gICAgICBkTCA9IFskQ29kZUVkaXRvckNvbnRlbnRzLCAkQ29kZUVkaXRvckFjdGl2ZURvY3VtZW50XTtcclxuICAgIH0gZWxzZSBpZiAoYWN0aXZlQ29tcG9uZW50ID09PSBUZXN0KSB7XHJcbiAgICAgIGRMID0gWyRUZXN0RWRpdG9yQ29udGVudHMsICRUZXN0RWRpdG9yRG9jdW1lbnRdO1xyXG4gICAgfVxyXG4gICAgZG93bmxvYWQoZExbMF0sIGRMWzFdLCBcInRleHQvcGxhaW5cIik7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzRXZlbnQgPSBldmVudCA9PiB7XHJcbiAgICBpZiAoZXZlbnQud2hpY2ggPT0gODMgJiYgZXZlbnQuY3RybEtleSkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAkc2F2ZUV2ZW50VGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgb25Nb3VudCgoKSA9PiB7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgc0V2ZW50KTtcclxuICB9KTtcclxuICBvbkRlc3Ryb3koKCkgPT4ge1xyXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHNFdmVudCk7XHJcbiAgfSk7XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG4gIDpnbG9iYWwoOnJvb3QpIHtcclxuICAgIC0tZm9udC1zaXplLXNtOiBjYWxjKCgwLjg1cmVtICsgMC41ICogKCgxMDB2dyAtIDUwcmVtKSAvIDEyMCkpKTtcclxuICAgIC0tZm9udC1zaXplLWJ0bjogY2FsYygoMS41cmVtICsgMC41ICogKCgxMDB2dyAtIDUwcmVtKSAvIDEyMCkpKTtcclxuICAgIC0tZm9udC1zaXplLWhlYWRlcjogY2FsYygoMXJlbSArIDAuNSAqICgoMTAwdncgLSA4MHJlbSkgLyAxMjApKSk7XHJcbiAgICAtLWNlbGVzdHJhay1ibHVlOiAjMWU1Y2FkO1xyXG4gICAgLS1mb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcIlNlZ29lIFVJXCIsIFJvYm90byxcclxuICAgICAgT3h5Z2VuLVNhbnMsIFVidW50dSwgQ2FudGFyZWxsLCBcIkhlbHZldGljYSBOZXVlXCIsIHNhbnMtc2VyaWY7XHJcbiAgICAtLWhlYWRlci1oZWlnaHQ6IDUwcHg7XHJcbiAgICAtLWNvbnRhaW5lci1wb3NpdGlvbjogMHB4O1xyXG4gICAgLS1tZW51LXdpZHRoOiAzMHZ3O1xyXG4gICAgLS1oZWFkZXItZ3JhZGllbnQ6IGxpbmVhci1ncmFkaWVudChcclxuICAgICAgdG8gYm90dG9tLFxyXG4gICAgICB2YXIoLS1jZWxlc3RyYWstYmx1ZSkgMjAlLFxyXG4gICAgICAjMjk2M2FmIDUwJSxcclxuICAgICAgdmFyKC0tY2VsZXN0cmFrLWJsdWUpIDgwJVxyXG4gICAgKTtcclxuICAgIC0tYnV0dG9uLWdyYWRpZW50OiBsaW5lYXItZ3JhZGllbnQoXHJcbiAgICAgIHRvIHJpZ2h0LFxyXG4gICAgICB2YXIoLS1jZWxlc3RyYWstYmx1ZSkgMCUsXHJcbiAgICAgICMyYjY2YjMgNTAlLFxyXG4gICAgICB2YXIoLS1jZWxlc3RyYWstYmx1ZSkgMTAwJVxyXG4gICAgKTtcclxuICB9XHJcbiAgOmdsb2JhbCguZWRpdG9yMSkge1xyXG4gICAgaGVpZ2h0OiBjYWxjKDk5Ljk5dmggLSB2YXIoLS1oZWFkZXItaGVpZ2h0KSk7XHJcbiAgfVxyXG4gIDpnbG9iYWwoaHRtbCwgYm9keSkge1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgcG9zaXRpb246IGZpeGVkO1xyXG4gIH1cclxuXHJcbiAgOmdsb2JhbChib2R5KSB7XHJcbiAgICAvKm92ZXJmbG93OiBoaWRkZW47Ki9cclxuXHJcbiAgICBwYWRkaW5nLWJvdHRvbTogMjBweDtcclxuICAgIGJhY2tncm91bmQ6ICMxNjQ1ODM7XHJcbiAgICBjb2xvcjogIzMzMztcclxuICAgIG1hcmdpbjogMDtcclxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1mYW1pbHkpO1xyXG4gIH1cclxuICA6Z2xvYmFsKGRpdikge1xyXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgIHVzZXItc2VsZWN0OiBub25lO1xyXG4gIH1cclxuXHJcbiAgbWFpbiB7XHJcbiAgICBtYXJnaW46IDAgYXV0bztcclxuICAgIGRpc3BsYXk6IGdyaWQ7XHJcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDEwMHZ3O1xyXG4gIH1cclxuXHJcbiAgaGVhZGVyIHtcclxuICAgIGJhY2tncm91bmQ6IHZhcigtLWhlYWRlci1ncmFkaWVudCk7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbiAgICBwYWRkaW5nOiAycHg7XHJcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMXB4O1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICB9XHJcblxyXG4gIGNvbnRhaW5lciB7XHJcbiAgICBkaXNwbGF5OiBncmlkO1xyXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiB2YXIoLS1oZWFkZXItaGVpZ2h0KSBhdXRvO1xyXG4gICAgaGVpZ2h0OiAxMDB2aDtcclxuICAgIHdpZHRoOiAxMDB2dztcclxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgbGVmdDogdmFyKC0tY29udGFpbmVyLXBvc2l0aW9uKTtcclxuICAgIHRyYW5zaXRpb246IGFsbCAwLjFzO1xyXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XHJcbiAgICBib3gtc2hhZG93OiAtNXB4IDJweCA2cHggN3B4ICMwMDAwMDA0NDtcclxuICB9XHJcbiAgQG1lZGlhIChtaW4td2lkdGg6IDY0MHB4KSB7XHJcbiAgICBtYWluIHtcclxuICAgICAgbWF4LXdpZHRoOiBub25lO1xyXG4gICAgICB6LWluZGV4OiAxO1xyXG4gICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gICNtYWluQ29udGFpbmVyIHtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gIH1cclxuICAjbGlua3Mge1xyXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgIGRpc3BsYXk6IGdyaWQ7XHJcbiAgICBncmlkLWdhcDogNHB4O1xyXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBhdXRvO1xyXG4gICAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUtaGVhZGVyKTtcclxuICAgIHBhZGRpbmctcmlnaHQ6IDEwcHg7XHJcbiAgfVxyXG4gICNsaW5rcyBhLFxyXG4gIGhlYWRlciBhLFxyXG4gIG1lbnUgYSB7XHJcbiAgICBjb2xvcjogI2ZmZjtcclxuICAgIGZvbnQtd2VpZ2h0OiAzMDA7XHJcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBib3JkZXI6IDAuNXB4ICNjY2Mgc29saWQ7XHJcbiAgICBwYWRkaW5nOiA1cHg7XHJcbiAgfVxyXG5cclxuICAjbWVudUJ1dHRvbiB7XHJcbiAgICBjb2xvcjogI2VlZTtcclxuICAgIHBhZGRpbmctbGVmdDogMTBweDtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBmb250LXNpemU6IDMwcHg7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICBsZWZ0OiAwcHg7XHJcbiAgfVxyXG5cclxuICBtZW51IGEge1xyXG4gICAgYm9yZGVyOiBub25lO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gIH1cclxuICBtZW51IHtcclxuICAgIHBvc2l0aW9uOiBmaXhlZDtcclxuICAgIGxlZnQ6IC0xMDAlO1xyXG4gICAgcGFkZGluZzogMHB4O1xyXG4gICAgd2lkdGg6IHZhcigtLW1lbnUtd2lkdGgpO1xyXG4gICAgaGVpZ2h0OiAxMDB2aDtcclxuICAgIGJhY2tncm91bmQ6ICMxNjQ1ODM7XHJcblxyXG4gICAgbWFyZ2luOiAwcHg7XHJcbiAgfVxyXG4gIG1lbnUubmF2QWN0aXZlIHtcclxuICAgIGxlZnQ6IDBweDtcclxuICB9XHJcbiAgbWVudSBkaXYge1xyXG4gICAgaGVpZ2h0OiB2YXIoLS1oZWFkZXItaGVpZ2h0KTtcclxuICAgIGJvcmRlci1ib3R0b206IDFweCAjYWFhIHNvbGlkO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgY29sb3I6ICNlZWU7XHJcbiAgICBiYWNrZ3JvdW5kOiAjMTY0NTgzO1xyXG4gIH1cclxuICBtZW51IGRpdjpob3ZlciB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjMWE1MjliO1xyXG4gIH1cclxuICAjbGlua3Mge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgcmlnaHQ6IDBweDtcclxuICB9XHJcbiAgI2xpbmtzIGE6aG92ZXIsXHJcbiAgI2xpbmtzIGEuYWN0aXZlIHtcclxuICAgIGJhY2tncm91bmQ6ICNlZWU7XHJcbiAgICBjb2xvcjogIzMzMztcclxuICB9XHJcblxyXG4gICNtYWluSGVhZGVyIHNwYW4ge1xyXG4gICAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUtaGVhZGVyKTtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgfVxyXG48L3N0eWxlPlxyXG5cclxuPHN2ZWx0ZTpoZWFkPlxyXG4gIDxsaW5rXHJcbiAgICByZWw9XCJwcmVmZXRjaFwiXHJcbiAgICBocmVmPVwiL3dvcmtlcnMvd29ya2VyLmpzXCJcclxuICAgIGFzPVwid29ya2VyXCJcclxuICAgIHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiAvPlxyXG4gIDxsaW5rXHJcbiAgICByZWw9XCJwcmVmZXRjaFwiXHJcbiAgICBocmVmPVwiaHR0cHM6Ly9kaWdpdGFsYXJzZW5hbC5pby9saWIvZmxhdGJ1ZmZlcnMuanNcIlxyXG4gICAgYXM9XCJ3b3JrZXJcIlxyXG4gICAgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIC8+XHJcbiAgPG1ldGFcclxuICAgIG5hbWU9XCJ2aWV3cG9ydFwiXHJcbiAgICBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCwgbWF4aW11bS1zY2FsZT0xLjAsXHJcbiAgICB1c2VyLXNjYWxhYmxlPW5vLCB2aWV3cG9ydC1maXQ9Y29udGFpblwiIC8+XHJcblxyXG48L3N2ZWx0ZTpoZWFkPlxyXG48c3ZlbHRlOm9wdGlvbnMgYWNjZXNzb3JzPXt0cnVlfSAvPlxyXG48bWVudSBjbGFzczpuYXZBY3RpdmU9e21lbnVPcGVufT5cclxuICA8ZGl2PlxyXG4gICAgPGFcclxuICAgICAgaHJlZj1cIiMvXCJcclxuICAgICAgY2xhc3M6YWN0aXZlPXthY3RpdmVDb21wb25lbnQgPT09IE1haW59XHJcbiAgICAgIG9uOmNsaWNrPXsoKSA9PiB0b2dnbGVNZW51KCl9PlxyXG4gICAgICBIT01FXHJcbiAgICA8L2E+XHJcbiAgPC9kaXY+XHJcbiAgPGRpdj5cclxuICAgIDxhXHJcbiAgICAgIGhyZWY9XCIjL3NlbGVjdFwiXHJcbiAgICAgIGNsYXNzOmFjdGl2ZT17YWN0aXZlQ29tcG9uZW50ID09PSBNYWlufVxyXG4gICAgICBvbjpjbGljaz17KCkgPT4gdG9nZ2xlTWVudSgpfT5cclxuICAgICAgU0VMRUNUXHJcbiAgICA8L2E+XHJcbiAgPC9kaXY+XHJcbiAgPGRpdj5cclxuICAgIDxhXHJcbiAgICAgIGhyZWY9XCIjL2lkbFwiXHJcbiAgICAgIGNsYXNzOmFjdGl2ZT17YWN0aXZlQ29tcG9uZW50ID09PSBFZGl0b3J9XHJcbiAgICAgIG9uOmNsaWNrPXsoKSA9PiB0b2dnbGVNZW51KCl9PlxyXG4gICAgICBJRExcclxuICAgIDwvYT5cclxuICA8L2Rpdj5cclxuICA8ZGl2PlxyXG4gICAgPGFcclxuICAgICAgaHJlZj1cIiMvY29kZVwiXHJcbiAgICAgIGNsYXNzOmFjdGl2ZT17YWN0aXZlQ29tcG9uZW50ID09PSBDb2RlfVxyXG4gICAgICBvbjpjbGljaz17KCkgPT4gdG9nZ2xlTWVudSgpfT5cclxuICAgICAgQ09ERVxyXG4gICAgPC9hPlxyXG4gIDwvZGl2PlxyXG4gIDxkaXY+XHJcbiAgICA8YVxyXG4gICAgICBocmVmPVwiIy9leGFtcGxlc1wiXHJcbiAgICAgIGNsYXNzOmFjdGl2ZT17YWN0aXZlQ29tcG9uZW50ID09PSBFeGFtcGxlc31cclxuICAgICAgb246Y2xpY2s9eygpID0+IHRvZ2dsZU1lbnUoKX0+XHJcbiAgICAgIEVYQU1QTEVTXHJcbiAgICA8L2E+XHJcbiAgPC9kaXY+XHJcbiAgPGRpdj5cclxuICAgIDxhXHJcbiAgICAgIGhyZWY9XCIjL3Rlc3RcIlxyXG4gICAgICBjbGFzczphY3RpdmU9e2FjdGl2ZUNvbXBvbmVudCA9PT0gVGVzdH1cclxuICAgICAgb246Y2xpY2s9eygpID0+IHRvZ2dsZU1lbnUoKX0+XHJcbiAgICAgIFRFU1RcclxuICAgIDwvYT5cclxuICA8L2Rpdj5cclxuICA8ZGl2PlxyXG4gICAgPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj17Z2l0aHViVVJMfSBjbGFzczphY3RpdmU9e2FjdGl2ZUNvbXBvbmVudCA9PT0gTWFpbn0+XHJcbiAgICAgIEdJVEhVQlxyXG4gICAgPC9hPlxyXG4gIDwvZGl2PlxyXG48L21lbnU+XHJcbjxjb250YWluZXI+XHJcbiAgPGhlYWRlcj5cclxuICAgIDxkaXYgaWQ9XCJtZW51QnV0dG9uXCIgb246Y2xpY2s9eygpID0+IHRvZ2dsZU1lbnUoKX0+XHJcbiAgICAgIDxzcGFuPuKYsDwvc3Bhbj5cclxuICAgIDwvZGl2PlxyXG4gICAgPGRpdiBpZD1cIm1haW5IZWFkZXJcIj5cclxuICAgICAgPHNwYW4+XHJcbiAgICAgICAgPGEgc3R5bGU9XCJib3JkZXI6bm9uZVwiIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9e2dpdGh1YlVSTH0+XHJcbiAgICAgICAgICBTUEFDRURBVEFTVEFOREFSRFMuT1JHXHJcbiAgICAgICAgPC9hPlxyXG4gICAgICA8L3NwYW4+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgaWQ9XCJsaW5rc1wiPlxyXG4gICAgICB7I2lmICRJRExEb2N1bWVudH1cclxuICAgICAgICA8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPXtsaW5rfSBvbjpjbGljaz17KCkgPT4gdG9nZ2xlTWVudSgpfT5cclxuICAgICAgICAgIHtsaW5rTmFtZX1cclxuICAgICAgICA8L2E+XHJcbiAgICAgICAgPCEtLTxhIGhyZWY9XCJqYXZhc2NyaXB0OlwiIG9uOmNsaWNrPXsoKSA9PiBjcmVhdGVEb3dubG9hZCgpfT5TQVZFPC9hPi0tPlxyXG4gICAgICB7OmVsc2V9XHJcbiAgICAgICAgPGEgaHJlZj1cIiMvc2VsZWN0XCI+U0VMRUNULi4uPC9hPlxyXG4gICAgICB7L2lmfVxyXG4gICAgPC9kaXY+XHJcbiAgPC9oZWFkZXI+XHJcbiAgPG1haW4+XHJcbiAgICB7I2lmICFsb2FkZWR9XHJcbiAgICAgIDxMb2FkZXIgLz5cclxuICAgIHsvaWZ9XHJcblxyXG4gICAgPGRpdiBpZD1cIm1haW5Db250YWluZXJcIj5cclxuICAgICAgPHN2ZWx0ZTpjb21wb25lbnRcclxuICAgICAgICB0aGlzPXthY3RpdmVDb21wb25lbnR9XHJcbiAgICAgICAgYmluZDpsb2FkZWRcclxuICAgICAgICB7YXJnc31cclxuICAgICAgICB7dG9nZ2xlTWVudX0gLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICA8L21haW4+XHJcbjwvY29udGFpbmVyPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMElVLEtBQUssQUFBRSxDQUFDLEFBQ2QsY0FBYyxDQUFFLCtDQUErQyxDQUMvRCxlQUFlLENBQUUsOENBQThDLENBQy9ELGtCQUFrQixDQUFFLDRDQUE0QyxDQUNoRSxnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLGFBQWEsQ0FBRTtrRUFDK0MsQ0FDOUQsZUFBZSxDQUFFLElBQUksQ0FDckIsb0JBQW9CLENBQUUsR0FBRyxDQUN6QixZQUFZLENBQUUsSUFBSSxDQUNsQixpQkFBaUIsQ0FBRTs7Ozs7S0FLbEIsQ0FDRCxpQkFBaUIsQ0FBRTs7Ozs7S0FLbEIsQUFDSCxDQUFDLEFBQ08sUUFBUSxBQUFFLENBQUMsQUFDakIsTUFBTSxDQUFFLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxDQUFDLEFBQzlDLENBQUMsQUFDTyxVQUFVLEFBQUUsQ0FBQyxBQUNuQixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osUUFBUSxDQUFFLE1BQU0sQ0FDaEIsUUFBUSxDQUFFLEtBQUssQUFDakIsQ0FBQyxBQUVPLElBQUksQUFBRSxDQUFDLEFBR2IsY0FBYyxDQUFFLElBQUksQ0FDcEIsVUFBVSxDQUFFLE9BQU8sQ0FDbkIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsQ0FBQyxDQUNULFVBQVUsQ0FBRSxVQUFVLENBQ3RCLFdBQVcsQ0FBRSxJQUFJLGFBQWEsQ0FBQyxBQUNqQyxDQUFDLEFBQ08sR0FBRyxBQUFFLENBQUMsQUFDWixVQUFVLENBQUUsVUFBVSxDQUN0QixXQUFXLENBQUUsSUFBSSxBQUNuQixDQUFDLEFBRUQsSUFBSSw0QkFBQyxDQUFDLEFBQ0osTUFBTSxDQUFFLENBQUMsQ0FBQyxJQUFJLENBQ2QsT0FBTyxDQUFFLElBQUksQ0FDYixxQkFBcUIsQ0FBRSxLQUFLLEFBQzlCLENBQUMsQUFFRCxNQUFNLDRCQUFDLENBQUMsQUFDTixVQUFVLENBQUUsSUFBSSxpQkFBaUIsQ0FBQyxDQUNsQyxLQUFLLENBQUUsS0FBSyxDQUNaLE9BQU8sQ0FBRSxHQUFHLENBQ1osVUFBVSxDQUFFLFVBQVUsQ0FDdEIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxBQUN6QixDQUFDLEFBRUQsU0FBUyw0QkFBQyxDQUFDLEFBQ1QsT0FBTyxDQUFFLElBQUksQ0FDYixrQkFBa0IsQ0FBRSxJQUFJLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FDN0MsTUFBTSxDQUFFLEtBQUssQ0FDYixLQUFLLENBQUUsS0FBSyxDQUNaLFVBQVUsQ0FBRSxVQUFVLENBQ3RCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxJQUFJLG9CQUFvQixDQUFDLENBQy9CLFVBQVUsQ0FBRSxHQUFHLENBQUMsSUFBSSxDQUNwQixVQUFVLENBQUUsS0FBSyxDQUNqQixVQUFVLENBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFNBQVMsQUFDeEMsQ0FBQyxBQUNELE1BQU0sQUFBQyxZQUFZLEtBQUssQ0FBQyxBQUFDLENBQUMsQUFDekIsSUFBSSw0QkFBQyxDQUFDLEFBQ0osU0FBUyxDQUFFLElBQUksQ0FDZixPQUFPLENBQUUsQ0FBQyxDQUNWLFVBQVUsQ0FBRSxLQUFLLEFBQ25CLENBQUMsQUFDSCxDQUFDLEFBRUQsY0FBYyw0QkFBQyxDQUFDLEFBQ2QsS0FBSyxDQUFFLElBQUksQUFDYixDQUFDLEFBQ0QsTUFBTSw0QkFBQyxDQUFDLEFBQ04sVUFBVSxDQUFFLFVBQVUsQ0FDdEIsT0FBTyxDQUFFLElBQUksQ0FDYixRQUFRLENBQUUsR0FBRyxDQUNiLHFCQUFxQixDQUFFLElBQUksQ0FDM0IsU0FBUyxDQUFFLElBQUksa0JBQWtCLENBQUMsQ0FDbEMsYUFBYSxDQUFFLElBQUksQUFDckIsQ0FBQyxBQUNELG9CQUFNLENBQUMsZUFBQyxDQUNSLG9CQUFNLENBQUMsZUFBQyxDQUNSLGtCQUFJLENBQUMsQ0FBQyxjQUFDLENBQUMsQUFDTixLQUFLLENBQUUsSUFBSSxDQUNYLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLGVBQWUsQ0FBRSxJQUFJLENBQ3JCLE1BQU0sQ0FBRSxPQUFPLENBQ2YsTUFBTSxDQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUN4QixPQUFPLENBQUUsR0FBRyxBQUNkLENBQUMsQUFFRCxXQUFXLDRCQUFDLENBQUMsQUFDWCxLQUFLLENBQUUsSUFBSSxDQUNYLFlBQVksQ0FBRSxJQUFJLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLE9BQU8sQ0FDZixTQUFTLENBQUUsSUFBSSxDQUNmLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFdBQVcsQ0FBRSxNQUFNLENBQ25CLElBQUksQ0FBRSxHQUFHLEFBQ1gsQ0FBQyxBQUVELGtCQUFJLENBQUMsQ0FBQyxjQUFDLENBQUMsQUFDTixNQUFNLENBQUUsSUFBSSxDQUNaLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFdBQVcsQ0FBRSxNQUFNLEFBQ3JCLENBQUMsQUFDRCxJQUFJLDRCQUFDLENBQUMsQUFDSixRQUFRLENBQUUsS0FBSyxDQUNmLElBQUksQ0FBRSxLQUFLLENBQ1gsT0FBTyxDQUFFLEdBQUcsQ0FDWixLQUFLLENBQUUsSUFBSSxZQUFZLENBQUMsQ0FDeEIsTUFBTSxDQUFFLEtBQUssQ0FDYixVQUFVLENBQUUsT0FBTyxDQUVuQixNQUFNLENBQUUsR0FBRyxBQUNiLENBQUMsQUFDRCxJQUFJLFVBQVUsNEJBQUMsQ0FBQyxBQUNkLElBQUksQ0FBRSxHQUFHLEFBQ1gsQ0FBQyxBQUNELGtCQUFJLENBQUMsR0FBRyxjQUFDLENBQUMsQUFDUixNQUFNLENBQUUsSUFBSSxlQUFlLENBQUMsQ0FDNUIsYUFBYSxDQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUM3QixLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxJQUFJLENBQ2IsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsTUFBTSxDQUFFLE9BQU8sQ0FDZixLQUFLLENBQUUsSUFBSSxDQUNYLFVBQVUsQ0FBRSxPQUFPLEFBQ3JCLENBQUMsQUFDRCxrQkFBSSxDQUFDLGlCQUFHLE1BQU0sQUFBQyxDQUFDLEFBQ2QsVUFBVSxDQUFFLE9BQU8sQUFDckIsQ0FBQyxBQUNELE1BQU0sNEJBQUMsQ0FBQyxBQUNOLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxHQUFHLEFBQ1osQ0FBQyxBQUNELG9CQUFNLENBQUMsZUFBQyxNQUFNLEFBQ0UsQ0FBQyxBQUNmLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLEtBQUssQ0FBRSxJQUFJLEFBQ2IsQ0FBQyxBQUVELHlCQUFXLENBQUMsSUFBSSxjQUFDLENBQUMsQUFDaEIsU0FBUyxDQUFFLElBQUksa0JBQWtCLENBQUMsQ0FDbEMsT0FBTyxDQUFFLElBQUksQUFDZixDQUFDIn0= */";
    	append_dev(document_1$3.head, style);
    }

    // (402:6) {:else}
    function create_else_block(ctx) {
    	let a;

    	const block = {
    		c: function create() {
    			a = element("a");
    			a.textContent = "SELECT...";
    			attr_dev(a, "href", "#/select");
    			attr_dev(a, "class", "svelte-f415ab");
    			add_location(a, file$7, 402, 8, 9457);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(402:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (397:6) {#if $IDLDocument}
    function create_if_block_1$1(ctx) {
    	let a;
    	let t;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text(/*linkName*/ ctx[6]);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "href", /*link*/ ctx[4]);
    			attr_dev(a, "class", "svelte-f415ab");
    			add_location(a, file$7, 397, 8, 9254);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    			if (remount) dispose();
    			dispose = listen_dev(a, "click", /*click_handler_7*/ ctx[28], false, false, false);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*linkName*/ 64) set_data_dev(t, /*linkName*/ ctx[6]);

    			if (dirty & /*link*/ 16) {
    				attr_dev(a, "href", /*link*/ ctx[4]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(397:6) {#if $IDLDocument}",
    		ctx
    	});

    	return block;
    }

    // (408:4) {#if !loaded}
    function create_if_block$1(ctx) {
    	let current;
    	const loader = new Loader({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(408:4) {#if !loaded}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let link0;
    	let link1;
    	let meta;
    	let t0;
    	let menu;
    	let div0;
    	let a0;
    	let t2;
    	let div1;
    	let a1;
    	let t4;
    	let div2;
    	let a2;
    	let t6;
    	let div3;
    	let a3;
    	let t8;
    	let div4;
    	let a4;
    	let t10;
    	let div5;
    	let a5;
    	let t12;
    	let div6;
    	let a6;
    	let t13;
    	let t14;
    	let container;
    	let header;
    	let div7;
    	let span0;
    	let t16;
    	let div8;
    	let span1;
    	let a7;
    	let t17;
    	let t18;
    	let div9;
    	let t19;
    	let main;
    	let t20;
    	let div10;
    	let updating_loaded;
    	let current;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*$IDLDocument*/ ctx[5]) return create_if_block_1$1;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = !/*loaded*/ ctx[1] && create_if_block$1(ctx);

    	function switch_instance_loaded_binding(value) {
    		/*switch_instance_loaded_binding*/ ctx[29].call(null, value);
    	}

    	var switch_value = /*activeComponent*/ ctx[3];

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			args: /*args*/ ctx[2],
    			toggleMenu: /*toggleMenu*/ ctx[7]
    		};

    		if (/*loaded*/ ctx[1] !== void 0) {
    			switch_instance_props.loaded = /*loaded*/ ctx[1];
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, "loaded", switch_instance_loaded_binding));
    	}

    	const block = {
    		c: function create() {
    			link0 = element("link");
    			link1 = element("link");
    			meta = element("meta");
    			t0 = space();
    			menu = element("menu");
    			div0 = element("div");
    			a0 = element("a");
    			a0.textContent = "HOME";
    			t2 = space();
    			div1 = element("div");
    			a1 = element("a");
    			a1.textContent = "SELECT";
    			t4 = space();
    			div2 = element("div");
    			a2 = element("a");
    			a2.textContent = "IDL";
    			t6 = space();
    			div3 = element("div");
    			a3 = element("a");
    			a3.textContent = "CODE";
    			t8 = space();
    			div4 = element("div");
    			a4 = element("a");
    			a4.textContent = "EXAMPLES";
    			t10 = space();
    			div5 = element("div");
    			a5 = element("a");
    			a5.textContent = "TEST";
    			t12 = space();
    			div6 = element("div");
    			a6 = element("a");
    			t13 = text("GITHUB");
    			t14 = space();
    			container = element("container");
    			header = element("header");
    			div7 = element("div");
    			span0 = element("span");
    			span0.textContent = "";
    			t16 = space();
    			div8 = element("div");
    			span1 = element("span");
    			a7 = element("a");
    			t17 = text("SPACEDATASTANDARDS.ORG");
    			t18 = space();
    			div9 = element("div");
    			if_block0.c();
    			t19 = space();
    			main = element("main");
    			if (if_block1) if_block1.c();
    			t20 = space();
    			div10 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(link0, "rel", "prefetch");
    			attr_dev(link0, "href", "/workers/worker.js");
    			attr_dev(link0, "as", "worker");
    			attr_dev(link0, "type", "text/javascript");
    			add_location(link0, file$7, 311, 2, 7344);
    			attr_dev(link1, "rel", "prefetch");
    			attr_dev(link1, "href", "https://digitalarsenal.io/lib/flatbuffers.js");
    			attr_dev(link1, "as", "worker");
    			attr_dev(link1, "type", "text/javascript");
    			add_location(link1, file$7, 316, 2, 7452);
    			attr_dev(meta, "name", "viewport");
    			attr_dev(meta, "content", "width=device-width, initial-scale=1.0, maximum-scale=1.0,\r\n    user-scalable=no, viewport-fit=contain");
    			add_location(meta, file$7, 321, 2, 7586);
    			attr_dev(a0, "href", "#/");
    			attr_dev(a0, "class", "svelte-f415ab");
    			toggle_class(a0, "active", /*activeComponent*/ ctx[3] === Main);
    			add_location(a0, file$7, 330, 4, 7837);
    			attr_dev(div0, "class", "svelte-f415ab");
    			add_location(div0, file$7, 329, 2, 7826);
    			attr_dev(a1, "href", "#/select");
    			attr_dev(a1, "class", "svelte-f415ab");
    			toggle_class(a1, "active", /*activeComponent*/ ctx[3] === Main);
    			add_location(a1, file$7, 338, 4, 7988);
    			attr_dev(div1, "class", "svelte-f415ab");
    			add_location(div1, file$7, 337, 2, 7977);
    			attr_dev(a2, "href", "#/idl");
    			attr_dev(a2, "class", "svelte-f415ab");
    			toggle_class(a2, "active", /*activeComponent*/ ctx[3] === MonacoEditor);
    			add_location(a2, file$7, 346, 4, 8147);
    			attr_dev(div2, "class", "svelte-f415ab");
    			add_location(div2, file$7, 345, 2, 8136);
    			attr_dev(a3, "href", "#/code");
    			attr_dev(a3, "class", "svelte-f415ab");
    			toggle_class(a3, "active", /*activeComponent*/ ctx[3] === Code);
    			add_location(a3, file$7, 354, 4, 8302);
    			attr_dev(div3, "class", "svelte-f415ab");
    			add_location(div3, file$7, 353, 2, 8291);
    			attr_dev(a4, "href", "#/examples");
    			attr_dev(a4, "class", "svelte-f415ab");
    			toggle_class(a4, "active", /*activeComponent*/ ctx[3] === Examples);
    			add_location(a4, file$7, 362, 4, 8457);
    			attr_dev(div4, "class", "svelte-f415ab");
    			add_location(div4, file$7, 361, 2, 8446);
    			attr_dev(a5, "href", "#/test");
    			attr_dev(a5, "class", "svelte-f415ab");
    			toggle_class(a5, "active", /*activeComponent*/ ctx[3] === Test);
    			add_location(a5, file$7, 370, 4, 8624);
    			attr_dev(div5, "class", "svelte-f415ab");
    			add_location(div5, file$7, 369, 2, 8613);
    			attr_dev(a6, "target", "_blank");
    			attr_dev(a6, "href", githubURL);
    			attr_dev(a6, "class", "svelte-f415ab");
    			toggle_class(a6, "active", /*activeComponent*/ ctx[3] === Main);
    			add_location(a6, file$7, 378, 4, 8779);
    			attr_dev(div6, "class", "svelte-f415ab");
    			add_location(div6, file$7, 377, 2, 8768);
    			attr_dev(menu, "class", "svelte-f415ab");
    			toggle_class(menu, "navActive", /*menuOpen*/ ctx[0]);
    			add_location(menu, file$7, 328, 0, 7789);
    			add_location(span0, file$7, 386, 6, 8988);
    			attr_dev(div7, "id", "menuButton");
    			attr_dev(div7, "class", "svelte-f415ab");
    			add_location(div7, file$7, 385, 4, 8929);
    			set_style(a7, "border", "none");
    			attr_dev(a7, "target", "_blank");
    			attr_dev(a7, "href", githubURL);
    			attr_dev(a7, "class", "svelte-f415ab");
    			add_location(a7, file$7, 390, 8, 9065);
    			attr_dev(span1, "class", "svelte-f415ab");
    			add_location(span1, file$7, 389, 6, 9049);
    			attr_dev(div8, "id", "mainHeader");
    			attr_dev(div8, "class", "svelte-f415ab");
    			add_location(div8, file$7, 388, 4, 9020);
    			attr_dev(div9, "id", "links");
    			attr_dev(div9, "class", "svelte-f415ab");
    			add_location(div9, file$7, 395, 4, 9202);
    			attr_dev(header, "class", "svelte-f415ab");
    			add_location(header, file$7, 384, 2, 8915);
    			attr_dev(div10, "id", "mainContainer");
    			attr_dev(div10, "class", "svelte-f415ab");
    			add_location(div10, file$7, 411, 4, 9593);
    			attr_dev(main, "class", "svelte-f415ab");
    			add_location(main, file$7, 406, 2, 9531);
    			attr_dev(container, "class", "svelte-f415ab");
    			add_location(container, file$7, 383, 0, 8900);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			append_dev(document_1$3.head, link0);
    			append_dev(document_1$3.head, link1);
    			append_dev(document_1$3.head, meta);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, menu, anchor);
    			append_dev(menu, div0);
    			append_dev(div0, a0);
    			append_dev(menu, t2);
    			append_dev(menu, div1);
    			append_dev(div1, a1);
    			append_dev(menu, t4);
    			append_dev(menu, div2);
    			append_dev(div2, a2);
    			append_dev(menu, t6);
    			append_dev(menu, div3);
    			append_dev(div3, a3);
    			append_dev(menu, t8);
    			append_dev(menu, div4);
    			append_dev(div4, a4);
    			append_dev(menu, t10);
    			append_dev(menu, div5);
    			append_dev(div5, a5);
    			append_dev(menu, t12);
    			append_dev(menu, div6);
    			append_dev(div6, a6);
    			append_dev(a6, t13);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, container, anchor);
    			append_dev(container, header);
    			append_dev(header, div7);
    			append_dev(div7, span0);
    			append_dev(header, t16);
    			append_dev(header, div8);
    			append_dev(div8, span1);
    			append_dev(span1, a7);
    			append_dev(a7, t17);
    			append_dev(header, t18);
    			append_dev(header, div9);
    			if_block0.m(div9, null);
    			append_dev(container, t19);
    			append_dev(container, main);
    			if (if_block1) if_block1.m(main, null);
    			append_dev(main, t20);
    			append_dev(main, div10);

    			if (switch_instance) {
    				mount_component(switch_instance, div10, null);
    			}

    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(a0, "click", /*click_handler*/ ctx[21], false, false, false),
    				listen_dev(a1, "click", /*click_handler_1*/ ctx[22], false, false, false),
    				listen_dev(a2, "click", /*click_handler_2*/ ctx[23], false, false, false),
    				listen_dev(a3, "click", /*click_handler_3*/ ctx[24], false, false, false),
    				listen_dev(a4, "click", /*click_handler_4*/ ctx[25], false, false, false),
    				listen_dev(a5, "click", /*click_handler_5*/ ctx[26], false, false, false),
    				listen_dev(div7, "click", /*click_handler_6*/ ctx[27], false, false, false)
    			];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*activeComponent, Main*/ 8) {
    				toggle_class(a0, "active", /*activeComponent*/ ctx[3] === Main);
    			}

    			if (dirty & /*activeComponent, Main*/ 8) {
    				toggle_class(a1, "active", /*activeComponent*/ ctx[3] === Main);
    			}

    			if (dirty & /*activeComponent, Editor*/ 8) {
    				toggle_class(a2, "active", /*activeComponent*/ ctx[3] === MonacoEditor);
    			}

    			if (dirty & /*activeComponent, Code*/ 8) {
    				toggle_class(a3, "active", /*activeComponent*/ ctx[3] === Code);
    			}

    			if (dirty & /*activeComponent, Examples*/ 8) {
    				toggle_class(a4, "active", /*activeComponent*/ ctx[3] === Examples);
    			}

    			if (dirty & /*activeComponent, Test*/ 8) {
    				toggle_class(a5, "active", /*activeComponent*/ ctx[3] === Test);
    			}

    			if (dirty & /*activeComponent, Main*/ 8) {
    				toggle_class(a6, "active", /*activeComponent*/ ctx[3] === Main);
    			}

    			if (dirty & /*menuOpen*/ 1) {
    				toggle_class(menu, "navActive", /*menuOpen*/ ctx[0]);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div9, null);
    				}
    			}

    			if (!/*loaded*/ ctx[1]) {
    				if (!if_block1) {
    					if_block1 = create_if_block$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(main, t20);
    				} else {
    					transition_in(if_block1, 1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const switch_instance_changes = {};
    			if (dirty & /*args*/ 4) switch_instance_changes.args = /*args*/ ctx[2];

    			if (!updating_loaded && dirty & /*loaded*/ 2) {
    				updating_loaded = true;
    				switch_instance_changes.loaded = /*loaded*/ ctx[1];
    				add_flush_callback(() => updating_loaded = false);
    			}

    			if (switch_value !== (switch_value = /*activeComponent*/ ctx[3])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, "loaded", switch_instance_loaded_binding));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div10, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link0);
    			detach_dev(link1);
    			detach_dev(meta);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(menu);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(container);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    			if (switch_instance) destroy_component(switch_instance);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const githubURL = "https://github.com/DigitalArsenal/spacedatastandards.org";

    function instance$8($$self, $$props, $$invalidate) {
    	let $IDLDocument;
    	let $routeparams;
    	let $IDLEditorContents;
    	let $CodeEditorContents;
    	let $CodeEditorActiveDocument;
    	let $TestEditorContents;
    	let $TestEditorDocument;
    	let $saveEventTime;
    	validate_store(IDLDocument, "IDLDocument");
    	component_subscribe($$self, IDLDocument, $$value => $$invalidate(5, $IDLDocument = $$value));
    	validate_store(routeparams, "routeparams");
    	component_subscribe($$self, routeparams, $$value => $$invalidate(8, $routeparams = $$value));
    	validate_store(IDLEditorContents, "IDLEditorContents");
    	component_subscribe($$self, IDLEditorContents, $$value => $$invalidate(9, $IDLEditorContents = $$value));
    	validate_store(CodeEditorContents, "CodeEditorContents");
    	component_subscribe($$self, CodeEditorContents, $$value => $$invalidate(10, $CodeEditorContents = $$value));
    	validate_store(CodeEditorActiveDocument, "CodeEditorActiveDocument");
    	component_subscribe($$self, CodeEditorActiveDocument, $$value => $$invalidate(11, $CodeEditorActiveDocument = $$value));
    	validate_store(TestEditorContents, "TestEditorContents");
    	component_subscribe($$self, TestEditorContents, $$value => $$invalidate(12, $TestEditorContents = $$value));
    	validate_store(TestEditorDocument, "TestEditorDocument");
    	component_subscribe($$self, TestEditorDocument, $$value => $$invalidate(13, $TestEditorDocument = $$value));
    	validate_store(saveEventTime, "saveEventTime");
    	component_subscribe($$self, saveEventTime, $$value => $$invalidate(14, $saveEventTime = $$value));
    	window.download = download$1;
    	let menuOpen = false;
    	let loaded = false;
    	let editor = null;
    	let args = {};

    	const setRoute = (_params, _component) => {
    		set_store_value(routeparams, $routeparams = _params);
    		$$invalidate(3, activeComponent = _component);
    	};

    	let activeComponent = MonacoEditor;

    	let defaultPath = params => {
    		setRoute(params, Main);
    	};

    	let router = new Navaid("/", defaultPath);
    	router.on("/", defaultPath);
    	router.on("/#/", defaultPath);

    	router.on("/#/select", params => {
    		$$invalidate(2, args = {});
    		setRoute(params, Select);
    	});

    	router.on("/#/idl", params => {
    		$$invalidate(2, args = {
    			documentName: IDLDocument,
    			editorContents: IDLEditorContents,
    			language: "flatbuffers",
    			theme: "flatbuffers",
    			_class: "editor1"
    		});

    		setRoute(params, MonacoEditor);
    	});

    	router.on("/#/code", params => {
    		$$invalidate(2, args = {
    			documentName: CodeEditorActiveDocument,
    			editorContents: CodeEditorContents,
    			language: "",
    			theme: "",
    			_class: "editor1",
    			readOnly: true
    		});

    		setRoute(params, Code);
    	});

    	router.on("/#/examples", params => {
    		$$invalidate(2, args = {
    			documentName: "",
    			editorContents: "",
    			language: "",
    			theme: "",
    			_class: "editor1",
    			readOnly: true
    		});

    		setRoute(params, Examples);
    	});

    	router.on("/#/test", params => {
    		$$invalidate(2, args = {
    			documentName: TestEditorDocument,
    			editorContents: TestEditorContents,
    			language: "",
    			theme: "",
    			_class: "editor1",
    			readOnly: true
    		});

    		setRoute(params, Test);
    	});

    	router.listen();

    	const toggleMenu = value => {
    		$$invalidate(0, menuOpen = value !== undefined ? value : !menuOpen);
    		let posVal = menuOpen ? "30vw" : "0vw";
    		document.documentElement.style.setProperty("--container-position", posVal);
    	};

    	function createDownload() {
    		let dL = [];

    		if (activeComponent === MonacoEditor) {
    			dL = [$IDLEditorContents, $IDLDocument];
    		} else if (activeComponent === Code) {
    			dL = [$CodeEditorContents, $CodeEditorActiveDocument];
    		} else if (activeComponent === Test) {
    			dL = [$TestEditorContents, $TestEditorDocument];
    		}

    		download$1(dL[0], dL[1], "text/plain");
    	}

    	const sEvent = event => {
    		if (event.which == 83 && event.ctrlKey) {
    			event.preventDefault();
    			set_store_value(saveEventTime, $saveEventTime = new Date());
    		}
    	};

    	onMount(() => {
    		window.addEventListener("keydown", sEvent);
    	});

    	onDestroy(() => {
    		window.removeEventListener("keydown", sEvent);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("App", $$slots, []);
    	const click_handler = () => toggleMenu();
    	const click_handler_1 = () => toggleMenu();
    	const click_handler_2 = () => toggleMenu();
    	const click_handler_3 = () => toggleMenu();
    	const click_handler_4 = () => toggleMenu();
    	const click_handler_5 = () => toggleMenu();
    	const click_handler_6 = () => toggleMenu();
    	const click_handler_7 = () => toggleMenu();

    	function switch_instance_loaded_binding(value) {
    		loaded = value;
    		$$invalidate(1, loaded);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		onLoad,
    		Main,
    		Select,
    		Editor: MonacoEditor,
    		Code,
    		Examples,
    		Test,
    		download: download$1,
    		Loader,
    		Navaid,
    		routeparams,
    		manifest,
    		IDLDocument,
    		IDLEditorContents,
    		CodeEditorActiveDocument,
    		CodeEditorContents,
    		CodeEditorLanguage,
    		TestEditorDocument,
    		TestEditorContents,
    		saveEventTime,
    		menuOpen,
    		loaded,
    		editor,
    		args,
    		githubURL,
    		setRoute,
    		activeComponent,
    		defaultPath,
    		router,
    		toggleMenu,
    		createDownload,
    		sEvent,
    		link,
    		$IDLDocument,
    		$routeparams,
    		linkName,
    		$IDLEditorContents,
    		$CodeEditorContents,
    		$CodeEditorActiveDocument,
    		$TestEditorContents,
    		$TestEditorDocument,
    		$saveEventTime
    	});

    	$$self.$inject_state = $$props => {
    		if ("menuOpen" in $$props) $$invalidate(0, menuOpen = $$props.menuOpen);
    		if ("loaded" in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ("editor" in $$props) editor = $$props.editor;
    		if ("args" in $$props) $$invalidate(2, args = $$props.args);
    		if ("activeComponent" in $$props) $$invalidate(3, activeComponent = $$props.activeComponent);
    		if ("defaultPath" in $$props) defaultPath = $$props.defaultPath;
    		if ("router" in $$props) router = $$props.router;
    		if ("link" in $$props) $$invalidate(4, link = $$props.link);
    		if ("linkName" in $$props) $$invalidate(6, linkName = $$props.linkName);
    	};

    	let link;
    	let linkName;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$IDLDocument*/ 32) {
    			 $$invalidate(4, link = `https://public.ccsds.org/Pubs/${($IDLDocument || "").match(/\w{1,}/)}.pdf`);
    		}

    		if ($$self.$$.dirty & /*$IDLDocument*/ 32) {
    			 $$invalidate(6, linkName = ($IDLDocument || "").match(/\w{1,}/));
    		}
    	};

    	return [
    		menuOpen,
    		loaded,
    		args,
    		activeComponent,
    		link,
    		$IDLDocument,
    		linkName,
    		toggleMenu,
    		$routeparams,
    		$IDLEditorContents,
    		$CodeEditorContents,
    		$CodeEditorActiveDocument,
    		$TestEditorContents,
    		$TestEditorDocument,
    		$saveEventTime,
    		editor,
    		setRoute,
    		defaultPath,
    		router,
    		createDownload,
    		sEvent,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		switch_instance_loaded_binding
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		if (!document_1$3.getElementById("svelte-f415ab-style")) add_css$6();
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    const app = new App({
      target: document.body,
      props: {}
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
