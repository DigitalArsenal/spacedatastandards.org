<?php
// automatically generated by the FlatBuffers compiler, do not modify

use \Google\FlatBuffers\Struct;
use \Google\FlatBuffers\Table;
use \Google\FlatBuffers\ByteBuffer;
use \Google\FlatBuffers\FlatBufferBuilder;

/// /// These services provide for posting and querying Weather Data. Weather Data integrates dynamic data measured by Doppler/CG such as signal power and noise levels, to produce useful weather information.
class WeatherData_Full extends Table
{
    /**
     * @param ByteBuffer $bb
     * @return WeatherData_Full
     */
    public static function getRootAsWeatherData_Full(ByteBuffer $bb)
    {
        $obj = new WeatherData_Full();
        return ($obj->init($bb->getInt($bb->getPosition()) + $bb->getPosition(), $bb));
    }

    public static function WeatherData_FullIdentifier()
    {
        return "WEAT";
    }

    public static function WeatherData_FullBufferHasIdentifier(ByteBuffer $buf)
    {
        return self::__has_identifier($buf, self::WeatherData_FullIdentifier());
    }

    /**
     * @param int $_i offset
     * @param ByteBuffer $_bb
     * @return WeatherData_Full
     **/
    public function init($_i, ByteBuffer $_bb)
    {
        $this->bb_pos = $_i;
        $this->bb = $_bb;
        return $this;
    }

    /// Unique identifier of the record, auto-generated by the system.
    /// Example: /// Example: WEATHER-DATA-ID
    /// Constraints: Minimum length = 1, Maximum length = 36
    public function getId()
    {
        $o = $this->__offset(4);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Classification marking of the data in IC/CAPCO Portion-marked format.
    /// Example: /// Example: U
    /// Constraints: Minimum length = 1, Maximum length = 128
    public function getClassificationMarking()
    {
        $o = $this->__offset(6);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Unique identifier of the sensor making the weather measurement.
    /// Example: /// Example: 0129f577-e04c-441e-65ca-0a04a750bed9
    /// Constraints: Minimum length = 0, Maximum length = 36
    public function getIdSensor()
    {
        $o = $this->__offset(8);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Optional identifier provided by the record source. This may be an internal identifier and not necessarily a valid sensor ID.
    /// Example: /// Example: ORIGSENSOR-ID
    /// Constraints: Minimum length = 0, Maximum length = 64
    public function getOrigSensorId()
    {
        $o = $this->__offset(10);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Datetime of the weather observation in ISO 8601 UTC datetime format with microsecond precision.
    /// Example: /// Example: 2018-01-01T16:00:00.123456Z
    /// Constraints: No constraints specified.
    public function getObTime()
    {
        $o = $this->__offset(12);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Array of signal power(s) measured by the sensor, in decibels. Users should consult the data provider for information on the signal powers array structure.
    /// Example: /// Example: [116.5, 121.6]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getSigPwrs($j)
    {
        $o = $this->__offset(14);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getSigPwrsLength()
    {
        $o = $this->__offset(14);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Array of noise level(s) measured by radar, in decibels. Users should consult the data provider for information on the noise levels array structure.
    /// Example: /// Example: [58.2, 58.3]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getNoiseLvls($j)
    {
        $o = $this->__offset(16);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getNoiseLvlsLength()
    {
        $o = $this->__offset(16);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Array of width(s) of the distribution in Doppler velocity measured by radar, in meters/second. Spectral width depends on the particle size distribution, the wind shear across the radar beam, and turbulence. Users should consult the data provider for information on the spectral widths array structure.
    /// Example: /// Example: [0.3, 0.6]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getSpecWidths($j)
    {
        $o = $this->__offset(18);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getSpecWidthsLength()
    {
        $o = $this->__offset(18);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Array of average maximum number(s) of consecutive instances in which the same first guess velocity is used in radar data processing to estimate wind speed. Users should consult the data provider for information on the first guess averages array structure.
    /// Example: /// Example: [16, 1]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getFirstGuessAvgs($j)
    {
        $o = $this->__offset(20);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getFirstGuessAvgsLength()
    {
        $o = $this->__offset(20);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Quality control flag value, as defined by the data provider.
    /// Example: /// Example: 4
    /// Constraints: No constraints specified.
    /**
     * @return int
     */
    public function getQcValue()
    {
        $o = $this->__offset(22);
        return $o != 0 ? $this->bb->getInt($o + $this->bb_pos) : 0;
    }

    /// Datetime the system files were created.
    /// Example: /// Example: 2018-01-01T16:00:00.123456Z
    /// Constraints: No constraints specified.
    public function getFileCreation()
    {
        $o = $this->__offset(24);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Last altitude with recorded measurements in this record, in meters.
    /// Example: /// Example: 19505.1
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getTermAlt()
    {
        $o = $this->__offset(26);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Average transmitted power of the radar, in kilowatts.
    /// Example: /// Example: 20.23
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getAvgTxPwr()
    {
        $o = $this->__offset(28);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Average power of the reflected signal received by the radar, in Watts.
    /// Example: /// Example: 714.9
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getAvgRefPwr()
    {
        $o = $this->__offset(30);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Number of sectors within the radar coverage area, each containing a number of antennas.
    /// Example: /// Example: 20
    /// Constraints: No constraints specified.
    /**
     * @return int
     */
    public function getSectorNum()
    {
        $o = $this->__offset(32);
        return $o != 0 ? $this->bb->getInt($o + $this->bb_pos) : 0;
    }

    /// Number of antennas across all sectors within the radar coverage area.
    /// Example: /// Example: 640
    /// Constraints: No constraints specified.
    /**
     * @return int
     */
    public function getNumElements()
    {
        $o = $this->__offset(34);
        return $o != 0 ? $this->bb->getInt($o + $this->bb_pos) : 0;
    }

    /// Array of the number(s) of radar samples used in time domain averaging for radar data processing. Time domain averaging improves the quality of the measured signal by reducing random noise and enhancing the signal-to-noise ratio. Users should consult the data provider for information on the time domain sample numbers array structure.
    /// Example: /// Example: [32, 30]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getTdAvgSampleNums($j)
    {
        $o = $this->__offset(36);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getTdAvgSampleNumsLength()
    {
        $o = $this->__offset(36);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Checksum value for the data.
    /// Example: /// Example: 133
    /// Constraints: No constraints specified.
    /**
     * @return int
     */
    public function getChecksum()
    {
        $o = $this->__offset(38);
        return $o != 0 ? $this->bb->getInt($o + $this->bb_pos) : 0;
    }

    /// Array of the number(s) of measurements used in coherent integrations used for radar data processing. Users should consult the data provider for information on the coherent integrations array structure.
    /// Example: /// Example: [4, 3]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getCoIntegs($j)
    {
        $o = $this->__offset(40);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getCoIntegsLength()
    {
        $o = $this->__offset(40);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Array of the number(s) of spectral averages used in radar data processing. Users should consult the data provider for information on the spectral averages array structure.
    /// Example: /// Example: [4, 3]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getSpecAvgs($j)
    {
        $o = $this->__offset(42);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getSpecAvgsLength()
    {
        $o = $this->__offset(42);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Array of the elapsed time(s) from the beginning of one pulse to the beginning of the next pulse for a radar beam, in microseconds. Users should consult the data provider for information on the interpulse periods array structure.
    /// Example: /// Example: [1000.3, 1000.2]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getInterpulsePeriods($j)
    {
        $o = $this->__offset(44);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getInterpulsePeriodsLength()
    {
        $o = $this->__offset(44);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Array of full scale Nyquist Doppler velocities measured by radar, in meters per second. Nyquist velocity refers to the maximum velocity magnitude that the radar system can unambiguously detect. Doppler velocities with absolute values exceeding the Nyquist threshold suffer from aliasing at the time of collection. Users should consult the data provider for information on the doppler velocities array structure.
    /// Example: /// Example: [44.4, 467.3]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getDoppVels($j)
    {
        $o = $this->__offset(46);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getDoppVelsLength()
    {
        $o = $this->__offset(46);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Array of the number(s) of records in consensus for a radar beam. Users should consult the data provider for information on the consensus records array structure.
    /// Example: /// Example: [5, 2]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getConsRecs($j)
    {
        $o = $this->__offset(48);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getConsRecsLength()
    {
        $o = $this->__offset(48);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Array of signal to noise ratio(s) for a radar beam, in decibels. Users should consult the data provider for information on the signal to noise ratios array structure.
    /// Example: /// Example: [14.5, -16.2]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getSnrs($j)
    {
        $o = $this->__offset(50);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getSnrsLength()
    {
        $o = $this->__offset(50);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Signal strength of the electromagnetic energy received due to a lightning event, in kiloamps.
    /// Example: /// Example: 163.7
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getSigStrength()
    {
        $o = $this->__offset(52);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Semi-major axis of the 50% positional confidence ellipse, in kilometers.
    /// Example: /// Example: 3.4
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getSemiMajorAxis()
    {
        $o = $this->__offset(54);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Semi-minor axis of the 50% positional confidence ellipse, in kilometers.
    /// Example: /// Example: 0.3
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getSemiMinorAxis()
    {
        $o = $this->__offset(56);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Angle of orientation of the 50% positional confidence ellipse, in degrees clockwise from true north.
    /// Example: /// Example: 75.7
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getAngleOrientation()
    {
        $o = $this->__offset(58);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Number of sensors used in the lightning event location solution.
    /// Example: /// Example: 9
    /// Constraints: No constraints specified.
    /**
     * @return int
     */
    public function getLightEventNum()
    {
        $o = $this->__offset(60);
        return $o != 0 ? $this->bb->getInt($o + $this->bb_pos) : 0;
    }

    /// Array of sensor(s) that participated in the lightning event location determination.
    /// Example: /// Example: [11, 28, 190]
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getLightDetSensors($j)
    {
        $o = $this->__offset(62);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getLightDetSensorsLength()
    {
        $o = $this->__offset(62);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// The positional confidence of the calculated lightning event location using the chi-square statistical method.
    /// Example: /// Example: 0.1
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getPosConfidence()
    {
        $o = $this->__offset(64);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Array of UDL record types (SENSOR, WEATHERREPORT) that are related to this WeatherData record. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
    /// Example: /// Example: ['SENSOR', 'WEATHERREPORT']
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getSrcTyps($j)
    {
        $o = $this->__offset(66);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getSrcTypsLength()
    {
        $o = $this->__offset(66);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Array of UUID(s) of the UDL data record(s) that are related to this WeatherData record. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
    /// Example: /// Example: ['1b23ba93-0957-4654-b5ca-8c3703f3ec57', '32944ee4-0437-4d94-95ce-2f2823ffa001']
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getSrcIds($j)
    {
        $o = $this->__offset(68);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getSrcIdsLength()
    {
        $o = $this->__offset(68);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// The originating source network on which this record was created, auto-populated by the system.
    /// Example: /// Example: OPS1
    /// Constraints: Minimum length = 1, Maximum length = 32
    public function getOrigNetwork()
    {
        $o = $this->__offset(70);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Time the row was created in the database.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    public function getCreatedAt()
    {
        $o = $this->__offset(72);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Application user who created the row in the database.
    /// Example: /// Example: some.user
    /// Constraints: Minimum length = 1, Maximum length = 64
    public function getCreatedBy()
    {
        $o = $this->__offset(74);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Source of the data.
    /// Example: /// Example: Bluestaq
    /// Constraints: Minimum length = 1, Maximum length = 36
    public function getSource()
    {
        $o = $this->__offset(76);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
    /// Example: /// Example: THIRD_PARTY_DATASOURCE
    /// Constraints: Minimum length = 0, Maximum length = 64
    public function getOrigin()
    {
        $o = $this->__offset(78);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
    /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
    /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
    /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
    /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    /// Example: /// Example: TEST
    /// Constraints: Minimum length = 1, Maximum length = 32
    /**
     * @return sbyte
     */
    public function getDataMode()
    {
        $o = $this->__offset(80);
        return $o != 0 ? $this->bb->getSbyte($o + $this->bb_pos) : \WeatherData_Full_dataMode_Enum::REAL;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return void
     */
    public static function startWeatherData_Full(FlatBufferBuilder $builder)
    {
        $builder->StartObject(39);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return WeatherData_Full
     */
    public static function createWeatherData_Full(FlatBufferBuilder $builder, $id, $classificationMarking, $idSensor, $origSensorId, $obTime, $sigPwrs, $noiseLvls, $specWidths, $firstGuessAvgs, $qcValue, $fileCreation, $termAlt, $avgTxPwr, $avgRefPwr, $sectorNum, $numElements, $tdAvgSampleNums, $checksum, $coIntegs, $specAvgs, $interpulsePeriods, $doppVels, $consRecs, $snrs, $sigStrength, $semiMajorAxis, $semiMinorAxis, $angleOrientation, $lightEventNum, $lightDetSensors, $posConfidence, $srcTyps, $srcIds, $origNetwork, $createdAt, $createdBy, $source, $origin, $dataMode)
    {
        $builder->startObject(39);
        self::addId($builder, $id);
        self::addClassificationMarking($builder, $classificationMarking);
        self::addIdSensor($builder, $idSensor);
        self::addOrigSensorId($builder, $origSensorId);
        self::addObTime($builder, $obTime);
        self::addSigPwrs($builder, $sigPwrs);
        self::addNoiseLvls($builder, $noiseLvls);
        self::addSpecWidths($builder, $specWidths);
        self::addFirstGuessAvgs($builder, $firstGuessAvgs);
        self::addQcValue($builder, $qcValue);
        self::addFileCreation($builder, $fileCreation);
        self::addTermAlt($builder, $termAlt);
        self::addAvgTxPwr($builder, $avgTxPwr);
        self::addAvgRefPwr($builder, $avgRefPwr);
        self::addSectorNum($builder, $sectorNum);
        self::addNumElements($builder, $numElements);
        self::addTdAvgSampleNums($builder, $tdAvgSampleNums);
        self::addChecksum($builder, $checksum);
        self::addCoIntegs($builder, $coIntegs);
        self::addSpecAvgs($builder, $specAvgs);
        self::addInterpulsePeriods($builder, $interpulsePeriods);
        self::addDoppVels($builder, $doppVels);
        self::addConsRecs($builder, $consRecs);
        self::addSnrs($builder, $snrs);
        self::addSigStrength($builder, $sigStrength);
        self::addSemiMajorAxis($builder, $semiMajorAxis);
        self::addSemiMinorAxis($builder, $semiMinorAxis);
        self::addAngleOrientation($builder, $angleOrientation);
        self::addLightEventNum($builder, $lightEventNum);
        self::addLightDetSensors($builder, $lightDetSensors);
        self::addPosConfidence($builder, $posConfidence);
        self::addSrcTyps($builder, $srcTyps);
        self::addSrcIds($builder, $srcIds);
        self::addOrigNetwork($builder, $origNetwork);
        self::addCreatedAt($builder, $createdAt);
        self::addCreatedBy($builder, $createdBy);
        self::addSource($builder, $source);
        self::addOrigin($builder, $origin);
        self::addDataMode($builder, $dataMode);
        $o = $builder->endObject();
        return $o;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addId(FlatBufferBuilder $builder, $id)
    {
        $builder->addOffsetX(0, $id, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addClassificationMarking(FlatBufferBuilder $builder, $classificationMarking)
    {
        $builder->addOffsetX(1, $classificationMarking, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addIdSensor(FlatBufferBuilder $builder, $idSensor)
    {
        $builder->addOffsetX(2, $idSensor, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addOrigSensorId(FlatBufferBuilder $builder, $origSensorId)
    {
        $builder->addOffsetX(3, $origSensorId, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addObTime(FlatBufferBuilder $builder, $obTime)
    {
        $builder->addOffsetX(4, $obTime, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addSigPwrs(FlatBufferBuilder $builder, $sigPwrs)
    {
        $builder->addOffsetX(5, $sigPwrs, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createSigPwrsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startSigPwrsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addNoiseLvls(FlatBufferBuilder $builder, $noiseLvls)
    {
        $builder->addOffsetX(6, $noiseLvls, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createNoiseLvlsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startNoiseLvlsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addSpecWidths(FlatBufferBuilder $builder, $specWidths)
    {
        $builder->addOffsetX(7, $specWidths, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createSpecWidthsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startSpecWidthsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addFirstGuessAvgs(FlatBufferBuilder $builder, $firstGuessAvgs)
    {
        $builder->addOffsetX(8, $firstGuessAvgs, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createFirstGuessAvgsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startFirstGuessAvgsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int
     * @return void
     */
    public static function addQcValue(FlatBufferBuilder $builder, $qcValue)
    {
        $builder->addIntX(9, $qcValue, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addFileCreation(FlatBufferBuilder $builder, $fileCreation)
    {
        $builder->addOffsetX(10, $fileCreation, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addTermAlt(FlatBufferBuilder $builder, $termAlt)
    {
        $builder->addDoubleX(11, $termAlt, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addAvgTxPwr(FlatBufferBuilder $builder, $avgTxPwr)
    {
        $builder->addDoubleX(12, $avgTxPwr, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addAvgRefPwr(FlatBufferBuilder $builder, $avgRefPwr)
    {
        $builder->addDoubleX(13, $avgRefPwr, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int
     * @return void
     */
    public static function addSectorNum(FlatBufferBuilder $builder, $sectorNum)
    {
        $builder->addIntX(14, $sectorNum, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int
     * @return void
     */
    public static function addNumElements(FlatBufferBuilder $builder, $numElements)
    {
        $builder->addIntX(15, $numElements, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addTdAvgSampleNums(FlatBufferBuilder $builder, $tdAvgSampleNums)
    {
        $builder->addOffsetX(16, $tdAvgSampleNums, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createTdAvgSampleNumsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startTdAvgSampleNumsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int
     * @return void
     */
    public static function addChecksum(FlatBufferBuilder $builder, $checksum)
    {
        $builder->addIntX(17, $checksum, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addCoIntegs(FlatBufferBuilder $builder, $coIntegs)
    {
        $builder->addOffsetX(18, $coIntegs, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createCoIntegsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startCoIntegsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addSpecAvgs(FlatBufferBuilder $builder, $specAvgs)
    {
        $builder->addOffsetX(19, $specAvgs, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createSpecAvgsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startSpecAvgsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addInterpulsePeriods(FlatBufferBuilder $builder, $interpulsePeriods)
    {
        $builder->addOffsetX(20, $interpulsePeriods, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createInterpulsePeriodsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startInterpulsePeriodsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addDoppVels(FlatBufferBuilder $builder, $doppVels)
    {
        $builder->addOffsetX(21, $doppVels, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createDoppVelsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startDoppVelsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addConsRecs(FlatBufferBuilder $builder, $consRecs)
    {
        $builder->addOffsetX(22, $consRecs, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createConsRecsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startConsRecsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addSnrs(FlatBufferBuilder $builder, $snrs)
    {
        $builder->addOffsetX(23, $snrs, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createSnrsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startSnrsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addSigStrength(FlatBufferBuilder $builder, $sigStrength)
    {
        $builder->addDoubleX(24, $sigStrength, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addSemiMajorAxis(FlatBufferBuilder $builder, $semiMajorAxis)
    {
        $builder->addDoubleX(25, $semiMajorAxis, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addSemiMinorAxis(FlatBufferBuilder $builder, $semiMinorAxis)
    {
        $builder->addDoubleX(26, $semiMinorAxis, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addAngleOrientation(FlatBufferBuilder $builder, $angleOrientation)
    {
        $builder->addDoubleX(27, $angleOrientation, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int
     * @return void
     */
    public static function addLightEventNum(FlatBufferBuilder $builder, $lightEventNum)
    {
        $builder->addIntX(28, $lightEventNum, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addLightDetSensors(FlatBufferBuilder $builder, $lightDetSensors)
    {
        $builder->addOffsetX(29, $lightDetSensors, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createLightDetSensorsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startLightDetSensorsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addPosConfidence(FlatBufferBuilder $builder, $posConfidence)
    {
        $builder->addDoubleX(30, $posConfidence, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addSrcTyps(FlatBufferBuilder $builder, $srcTyps)
    {
        $builder->addOffsetX(31, $srcTyps, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createSrcTypsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startSrcTypsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addSrcIds(FlatBufferBuilder $builder, $srcIds)
    {
        $builder->addOffsetX(32, $srcIds, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createSrcIdsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startSrcIdsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addOrigNetwork(FlatBufferBuilder $builder, $origNetwork)
    {
        $builder->addOffsetX(33, $origNetwork, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addCreatedAt(FlatBufferBuilder $builder, $createdAt)
    {
        $builder->addOffsetX(34, $createdAt, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addCreatedBy(FlatBufferBuilder $builder, $createdBy)
    {
        $builder->addOffsetX(35, $createdBy, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addSource(FlatBufferBuilder $builder, $source)
    {
        $builder->addOffsetX(36, $source, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addOrigin(FlatBufferBuilder $builder, $origin)
    {
        $builder->addOffsetX(37, $origin, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param sbyte
     * @return void
     */
    public static function addDataMode(FlatBufferBuilder $builder, $dataMode)
    {
        $builder->addSbyteX(38, $dataMode, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return int table offset
     */
    public static function endWeatherData_Full(FlatBufferBuilder $builder)
    {
        $o = $builder->endObject();
        return $o;
    }

    public static function finishWeatherData_FullBuffer(FlatBufferBuilder $builder, $offset)
    {
        $builder->finish($offset, "WEAT");
    }
}
