<?php
// automatically generated by the FlatBuffers compiler, do not modify

use \Google\FlatBuffers\Struct;
use \Google\FlatBuffers\Table;
use \Google\FlatBuffers\ByteBuffer;
use \Google\FlatBuffers\FlatBufferBuilder;

/// /// A conditional nested segment to report multiple airspace control means within a particular airspace control means status.
class AirspaceControlMeans_Abridged extends Table
{
    /**
     * @param ByteBuffer $bb
     * @return AirspaceControlMeans_Abridged
     */
    public static function getRootAsAirspaceControlMeans_Abridged(ByteBuffer $bb)
    {
        $obj = new AirspaceControlMeans_Abridged();
        return ($obj->init($bb->getInt($bb->getPosition()) + $bb->getPosition(), $bb));
    }

    public static function AirspaceControlMeans_AbridgedIdentifier()
    {
        return "AIRS";
    }

    public static function AirspaceControlMeans_AbridgedBufferHasIdentifier(ByteBuffer $buf)
    {
        return self::__has_identifier($buf, self::AirspaceControlMeans_AbridgedIdentifier());
    }

    /**
     * @param int $_i offset
     * @param ByteBuffer $_bb
     * @return AirspaceControlMeans_Abridged
     **/
    public function init($_i, ByteBuffer $_bb)
    {
        $this->bb_pos = $_i;
        $this->bb = $_bb;
        return $this;
    }

    /// The code for the type of airspace control means.
    /// Example: /// Example: ACM:ADAREA
    /// Constraints: Minimum length = 0, Maximum length = 8
    public function getCmType()
    {
        $o = $this->__offset(4);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Airspace control means name or designator.
    /// Example: /// Example: DESIG:C34
    /// Constraints: Minimum length = 0, Maximum length = 32
    public function getCmId()
    {
        $o = $this->__offset(6);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Designates the geometric type that defines the airspace shape. One of CIRCLE, CORRIDOR, LINE, ORBIT, etc.
    /// Example: /// Example: POLYARC
    /// Constraints: Minimum length = 0, Maximum length = 8
    /**
     * @return sbyte
     */
    public function getCmShape()
    {
        $o = $this->__offset(8);
        return $o != 0 ? $this->bb->getSbyte($o + $this->bb_pos) : \AirspaceControlMeans_Abridged_cmShape_Enum::POLYARC;
    }

    /// Designates the means by which a defined airspace control means is to be used.
    /// Example: /// Example: USE:AIRCOR
    /// Constraints: Minimum length = 0, Maximum length = 8
    public function getUsage()
    {
        $o = $this->__offset(10);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Unique Link 16 identifier assigned to the airspace control means.
    /// Example: /// Example: F3356
    /// Constraints: Minimum length = 0, Maximum length = 8
    public function getLink16Id()
    {
        $o = $this->__offset(12);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// The altitude at or below which the vertical position of an aircraft is controlled by reference to true altitude.
    /// Example: /// Example: 18000FT
    /// Constraints: Minimum length = 0, Maximum length = 8
    public function getTransAltitude()
    {
        $o = $this->__offset(14);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated, if different from the top level ACO datum.
    /// Example: /// Example: NAR
    /// Constraints: Minimum length = 0, Maximum length = 8
    public function getGeoDatumAlt()
    {
        $o = $this->__offset(16);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
    /// Example: /// Example: 152345N0505657E
    /// Constraints: Minimum length = 0, Maximum length = 16
    public function getCoord0()
    {
        $o = $this->__offset(18);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
    /// Example: /// Example: 1523N05057E
    /// Constraints: Minimum length = 0, Maximum length = 16
    public function getCoord1()
    {
        $o = $this->__offset(20);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "beginning" radial bearing parameter.
    /// Example: /// Example: 330
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getBearing0()
    {
        $o = $this->__offset(22);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "ending" radial bearing parameter.
    /// Example: /// Example: 160
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getBearing1()
    {
        $o = $this->__offset(24);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "inner" radial magnitude arc limit. If provided, the field radMagUnit is required.
    /// Example: /// Example: 30.04
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getRadMag0()
    {
        $o = $this->__offset(26);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "outer" radial magnitude arc limit. If provided, the field radMagUnit is required.
    /// Example: /// Example: 50.12
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getRadMag1()
    {
        $o = $this->__offset(28);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Specifies the unit of length in which radial magnitudes are given. Use M for meters, KM for kilometers, or NM for nautical miles.
    /// Example: /// Example: NM
    /// Constraints: Minimum length = 0, Maximum length = 8
    public function getRadMagUnit()
    {
        $o = $this->__offset(30);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// A set of geospatial coordinates specified in DMS (Degrees, Minutes, Seconds) format which determine the vertices of a one or two dimensional geospatial shape. When shape is set to "POLYARC" or "POLYGON," this field is required as applied in the construction of the area boundary. If cmShape is set to "COORIDOR" or "GEOLINE," this field is required and can be interpreted as an ordered set of points along a path in space.
    /// Example: /// Example: ['203632N0594256E', '155000N0594815E', '155000N0591343E']
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getPolyCoord($j)
    {
        $o = $this->__offset(32);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getPolyCoordLength()
    {
        $o = $this->__offset(32);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Index of a segment in an airtrack, which is defined by an ordered set of points.
    /// Example: /// Example: 99
    /// Constraints: No constraints specified.
    /**
     * @return int
     */
    public function getTrackLeg()
    {
        $o = $this->__offset(34);
        return $o != 0 ? $this->bb->getInt($o + $this->bb_pos) : 0;
    }

    /// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the LEFT half-plane realtive to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the left of the track segment line. If provided, the field widthUnit is required.
    /// Example: /// Example: 5.2
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getWidthLeft()
    {
        $o = $this->__offset(36);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the RIGHT half-plane relative to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the right of the track segment line. If provided, the field widthUnit is required.
    /// Example: /// Example: 10.4
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getWidthRight()
    {
        $o = $this->__offset(38);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Used to describe the "side to side" distance of a target, object or area. If cmShape is set to "CORRIDOR" or "AORBIT", this field is required and is mapped to the width parameter. If provided, the field widthUnit is required.
    /// Example: /// Example: 15.6
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getWidth()
    {
        $o = $this->__offset(40);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Specifies the unit of length for which widths are given. Use M for meters, KM for kilometers, or NM for nautical miles.
    /// Example: /// Example: KM
    /// Constraints: Minimum length = 0, Maximum length = 8
    public function getWidthUnit()
    {
        $o = $this->__offset(42);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// An array of at least two alphanumeric symbols used to serially identify the corridor waypoints. If cmShape is set to "CORRIDOR," one of either corrWayPoints or polyCoord is required to specify the centerline of the corridor path.
    /// Example: /// Example: ['POB', 'RDU', 'IAD']
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getCorrWayPoints($j)
    {
        $o = $this->__offset(44);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getCorrWayPointsLength()
    {
        $o = $this->__offset(44);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Orbit alignment look-up code. Can be C=Center, L=Left, R=Right.
    /// Example: /// Example: C
    /// Constraints: Minimum length = 0, Maximum length = 1
    public function getOrbitAlignment()
    {
        $o = $this->__offset(46);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Description of the airspace vertical dimension.
    /// Example: /// Example: BRRA:GL-100AGL
    /// Constraints: Minimum length = 0, Maximum length = 16
    public function getEffVDim()
    {
        $o = $this->__offset(48);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// The timePeriod set describes the effective datetime for a given airspace control means.
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getAirspaceTimePeriod($j)
    {
        $o = $this->__offset(50);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getAirspaceTimePeriodLength()
    {
        $o = $this->__offset(50);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// The controlPoint set describes any reference/controlling/rendevous point for a given airspace control means.
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getAirspaceControlPoint($j)
    {
        $o = $this->__offset(52);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getAirspaceControlPointLength()
    {
        $o = $this->__offset(52);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// The commander responsible within a specified geographical area for the airspace control operation assigned to him.
    /// Example: /// Example: RHEIN MAIN CP
    /// Constraints: Minimum length = 0, Maximum length = 36
    public function getCtrlAuth()
    {
        $o = $this->__offset(54);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// The frequency for the airspace control authority. Can specify HZ, KHZ, MHZ, GHZ or a DESIG frequency designator code.
    /// Example: /// Example: ['125.25MHZ']
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getCtrlAuthFreqs($j)
    {
        $o = $this->__offset(56);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getCtrlAuthFreqsLength()
    {
        $o = $this->__offset(56);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Used to provide transit intstructions for the airspace control means.
    /// Example: /// Example: SITUATION
    /// Constraints: Minimum length = 0, Maximum length = 64
    public function getGenTextInd()
    {
        $o = $this->__offset(58);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// General informat detailing the transit instruction for the airspace control means.
    /// Example: /// Example: 1. CAPACITY: MDM TK, 50 VEHICLE CONVOY. 2. CHOKE POINTS: EXIT 5
    /// Constraints: Minimum length = 0, Maximum length = 128
    public function getFreeText()
    {
        $o = $this->__offset(60);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return void
     */
    public static function startAirspaceControlMeans_Abridged(FlatBufferBuilder $builder)
    {
        $builder->StartObject(29);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return AirspaceControlMeans_Abridged
     */
    public static function createAirspaceControlMeans_Abridged(FlatBufferBuilder $builder, $cmType, $cmId, $cmShape, $usage, $link16Id, $transAltitude, $geoDatumAlt, $coord0, $coord1, $bearing0, $bearing1, $radMag0, $radMag1, $radMagUnit, $polyCoord, $trackLeg, $widthLeft, $widthRight, $width, $widthUnit, $corrWayPoints, $orbitAlignment, $effVDim, $airspaceTimePeriod, $airspaceControlPoint, $ctrlAuth, $ctrlAuthFreqs, $genTextInd, $freeText)
    {
        $builder->startObject(29);
        self::addCmType($builder, $cmType);
        self::addCmId($builder, $cmId);
        self::addCmShape($builder, $cmShape);
        self::addUsage($builder, $usage);
        self::addLink16Id($builder, $link16Id);
        self::addTransAltitude($builder, $transAltitude);
        self::addGeoDatumAlt($builder, $geoDatumAlt);
        self::addCoord0($builder, $coord0);
        self::addCoord1($builder, $coord1);
        self::addBearing0($builder, $bearing0);
        self::addBearing1($builder, $bearing1);
        self::addRadMag0($builder, $radMag0);
        self::addRadMag1($builder, $radMag1);
        self::addRadMagUnit($builder, $radMagUnit);
        self::addPolyCoord($builder, $polyCoord);
        self::addTrackLeg($builder, $trackLeg);
        self::addWidthLeft($builder, $widthLeft);
        self::addWidthRight($builder, $widthRight);
        self::addWidth($builder, $width);
        self::addWidthUnit($builder, $widthUnit);
        self::addCorrWayPoints($builder, $corrWayPoints);
        self::addOrbitAlignment($builder, $orbitAlignment);
        self::addEffVDim($builder, $effVDim);
        self::addAirspaceTimePeriod($builder, $airspaceTimePeriod);
        self::addAirspaceControlPoint($builder, $airspaceControlPoint);
        self::addCtrlAuth($builder, $ctrlAuth);
        self::addCtrlAuthFreqs($builder, $ctrlAuthFreqs);
        self::addGenTextInd($builder, $genTextInd);
        self::addFreeText($builder, $freeText);
        $o = $builder->endObject();
        return $o;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addCmType(FlatBufferBuilder $builder, $cmType)
    {
        $builder->addOffsetX(0, $cmType, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addCmId(FlatBufferBuilder $builder, $cmId)
    {
        $builder->addOffsetX(1, $cmId, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param sbyte
     * @return void
     */
    public static function addCmShape(FlatBufferBuilder $builder, $cmShape)
    {
        $builder->addSbyteX(2, $cmShape, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addUsage(FlatBufferBuilder $builder, $usage)
    {
        $builder->addOffsetX(3, $usage, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addLink16Id(FlatBufferBuilder $builder, $link16Id)
    {
        $builder->addOffsetX(4, $link16Id, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addTransAltitude(FlatBufferBuilder $builder, $transAltitude)
    {
        $builder->addOffsetX(5, $transAltitude, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addGeoDatumAlt(FlatBufferBuilder $builder, $geoDatumAlt)
    {
        $builder->addOffsetX(6, $geoDatumAlt, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addCoord0(FlatBufferBuilder $builder, $coord0)
    {
        $builder->addOffsetX(7, $coord0, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addCoord1(FlatBufferBuilder $builder, $coord1)
    {
        $builder->addOffsetX(8, $coord1, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addBearing0(FlatBufferBuilder $builder, $bearing0)
    {
        $builder->addDoubleX(9, $bearing0, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addBearing1(FlatBufferBuilder $builder, $bearing1)
    {
        $builder->addDoubleX(10, $bearing1, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addRadMag0(FlatBufferBuilder $builder, $radMag0)
    {
        $builder->addDoubleX(11, $radMag0, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addRadMag1(FlatBufferBuilder $builder, $radMag1)
    {
        $builder->addDoubleX(12, $radMag1, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addRadMagUnit(FlatBufferBuilder $builder, $radMagUnit)
    {
        $builder->addOffsetX(13, $radMagUnit, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addPolyCoord(FlatBufferBuilder $builder, $polyCoord)
    {
        $builder->addOffsetX(14, $polyCoord, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createPolyCoordVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startPolyCoordVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int
     * @return void
     */
    public static function addTrackLeg(FlatBufferBuilder $builder, $trackLeg)
    {
        $builder->addIntX(15, $trackLeg, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addWidthLeft(FlatBufferBuilder $builder, $widthLeft)
    {
        $builder->addDoubleX(16, $widthLeft, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addWidthRight(FlatBufferBuilder $builder, $widthRight)
    {
        $builder->addDoubleX(17, $widthRight, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addWidth(FlatBufferBuilder $builder, $width)
    {
        $builder->addDoubleX(18, $width, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addWidthUnit(FlatBufferBuilder $builder, $widthUnit)
    {
        $builder->addOffsetX(19, $widthUnit, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addCorrWayPoints(FlatBufferBuilder $builder, $corrWayPoints)
    {
        $builder->addOffsetX(20, $corrWayPoints, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createCorrWayPointsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startCorrWayPointsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addOrbitAlignment(FlatBufferBuilder $builder, $orbitAlignment)
    {
        $builder->addOffsetX(21, $orbitAlignment, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addEffVDim(FlatBufferBuilder $builder, $effVDim)
    {
        $builder->addOffsetX(22, $effVDim, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addAirspaceTimePeriod(FlatBufferBuilder $builder, $airspaceTimePeriod)
    {
        $builder->addOffsetX(23, $airspaceTimePeriod, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createAirspaceTimePeriodVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startAirspaceTimePeriodVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addAirspaceControlPoint(FlatBufferBuilder $builder, $airspaceControlPoint)
    {
        $builder->addOffsetX(24, $airspaceControlPoint, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createAirspaceControlPointVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startAirspaceControlPointVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addCtrlAuth(FlatBufferBuilder $builder, $ctrlAuth)
    {
        $builder->addOffsetX(25, $ctrlAuth, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addCtrlAuthFreqs(FlatBufferBuilder $builder, $ctrlAuthFreqs)
    {
        $builder->addOffsetX(26, $ctrlAuthFreqs, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createCtrlAuthFreqsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startCtrlAuthFreqsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addGenTextInd(FlatBufferBuilder $builder, $genTextInd)
    {
        $builder->addOffsetX(27, $genTextInd, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addFreeText(FlatBufferBuilder $builder, $freeText)
    {
        $builder->addOffsetX(28, $freeText, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return int table offset
     */
    public static function endAirspaceControlMeans_Abridged(FlatBufferBuilder $builder)
    {
        $o = $builder->endObject();
        return $o;
    }

    public static function finishAirspaceControlMeans_AbridgedBuffer(FlatBufferBuilder $builder, $offset)
    {
        $builder->finish($offset, "AIRS");
    }
}
