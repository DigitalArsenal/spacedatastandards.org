<?php
// automatically generated by the FlatBuffers compiler, do not modify

use \Google\FlatBuffers\Struct;
use \Google\FlatBuffers\Table;
use \Google\FlatBuffers\ByteBuffer;
use \Google\FlatBuffers\FlatBufferBuilder;

/// /// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
class Sensorlimits_Full extends Table
{
    /**
     * @param ByteBuffer $bb
     * @return Sensorlimits_Full
     */
    public static function getRootAsSensorlimits_Full(ByteBuffer $bb)
    {
        $obj = new Sensorlimits_Full();
        return ($obj->init($bb->getInt($bb->getPosition()) + $bb->getPosition(), $bb));
    }

    public static function Sensorlimits_FullIdentifier()
    {
        return "SENS";
    }

    public static function Sensorlimits_FullBufferHasIdentifier(ByteBuffer $buf)
    {
        return self::__has_identifier($buf, self::Sensorlimits_FullIdentifier());
    }

    /**
     * @param int $_i offset
     * @param ByteBuffer $_bb
     * @return Sensorlimits_Full
     **/
    public function init($_i, ByteBuffer $_bb)
    {
        $this->bb_pos = $_i;
        $this->bb = $_bb;
        return $this;
    }

    /// Unique identifier of the record, auto-generated by the system.
    /// Example: /// Example: SENSORLIMITS-ID
    /// Constraints: Minimum length = 1, Maximum length = 36
    public function getIdSensorLimits()
    {
        $o = $this->__offset(4);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Classification marking of the data in IC/CAPCO Portion-marked format.
    /// Example: /// Example: U
    /// Constraints: Minimum length = 1, Maximum length = 128
    public function getClassificationMarking()
    {
        $o = $this->__offset(6);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// The originating source network on which this record was created, auto-populated by the system.
    /// Example: /// Example: ORIG
    /// Constraints: Minimum length = 1, Maximum length = 32
    public function getOrigNetwork()
    {
        $o = $this->__offset(8);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getUpperLeftAzimuthLimit()
    {
        $o = $this->__offset(10);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getUpperRightAzimuthLimit()
    {
        $o = $this->__offset(12);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getLowerRightAzimuthLimit()
    {
        $o = $this->__offset(14);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getLowerLeftAzimuthLimit()
    {
        $o = $this->__offset(16);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getLowerLeftElevationLimit()
    {
        $o = $this->__offset(18);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getUpperLeftElevationLimit()
    {
        $o = $this->__offset(20);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getLowerRightElevationLimit()
    {
        $o = $this->__offset(22);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    /**
     * @return double
     */
    public function getUpperRightElevationLimit()
    {
        $o = $this->__offset(24);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : 0.0;
    }

    /// Source of the data.
    /// Example: /// Example: Bluestaq
    /// Constraints: Minimum length = 1, Maximum length = 64
    public function getSource()
    {
        $o = $this->__offset(26);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
    /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
    /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
    /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
    /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    /// Example: /// Example: TEST
    /// Constraints: Minimum length = 1, Maximum length = 32
    /**
     * @return sbyte
     */
    public function getDataMode()
    {
        $o = $this->__offset(28);
        return $o != 0 ? $this->bb->getSbyte($o + $this->bb_pos) : \Sensorlimits_Full_dataMode_Enum::REAL;
    }

    /// Time the row was created in the database, auto-populated by the system.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    public function getCreatedAt()
    {
        $o = $this->__offset(30);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Application user who created the row in the database, auto-populated by the system.
    /// Example: /// Example: some.user
    /// Constraints: Minimum length = 1, Maximum length = 64
    public function getCreatedBy()
    {
        $o = $this->__offset(32);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Time the row was last updated in the database, auto-populated by the system.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    public function getUpdatedAt()
    {
        $o = $this->__offset(34);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Application user who updated the row in the database, auto-populated by the system.
    /// Example: /// Example: some.user
    /// Constraints: Minimum length = 0, Maximum length = 64
    public function getUpdatedBy()
    {
        $o = $this->__offset(36);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Unique identifier of the target sensor object.
    /// Example: /// Example: SENSORLIMITS-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    public function getIdSensor()
    {
        $o = $this->__offset(38);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return void
     */
    public static function startSensorlimits_Full(FlatBufferBuilder $builder)
    {
        $builder->StartObject(18);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return Sensorlimits_Full
     */
    public static function createSensorlimits_Full(FlatBufferBuilder $builder, $idSensorLimits, $classificationMarking, $origNetwork, $upperLeftAzimuthLimit, $upperRightAzimuthLimit, $lowerRightAzimuthLimit, $lowerLeftAzimuthLimit, $lowerLeftElevationLimit, $upperLeftElevationLimit, $lowerRightElevationLimit, $upperRightElevationLimit, $source, $dataMode, $createdAt, $createdBy, $updatedAt, $updatedBy, $idSensor)
    {
        $builder->startObject(18);
        self::addIdSensorLimits($builder, $idSensorLimits);
        self::addClassificationMarking($builder, $classificationMarking);
        self::addOrigNetwork($builder, $origNetwork);
        self::addUpperLeftAzimuthLimit($builder, $upperLeftAzimuthLimit);
        self::addUpperRightAzimuthLimit($builder, $upperRightAzimuthLimit);
        self::addLowerRightAzimuthLimit($builder, $lowerRightAzimuthLimit);
        self::addLowerLeftAzimuthLimit($builder, $lowerLeftAzimuthLimit);
        self::addLowerLeftElevationLimit($builder, $lowerLeftElevationLimit);
        self::addUpperLeftElevationLimit($builder, $upperLeftElevationLimit);
        self::addLowerRightElevationLimit($builder, $lowerRightElevationLimit);
        self::addUpperRightElevationLimit($builder, $upperRightElevationLimit);
        self::addSource($builder, $source);
        self::addDataMode($builder, $dataMode);
        self::addCreatedAt($builder, $createdAt);
        self::addCreatedBy($builder, $createdBy);
        self::addUpdatedAt($builder, $updatedAt);
        self::addUpdatedBy($builder, $updatedBy);
        self::addIdSensor($builder, $idSensor);
        $o = $builder->endObject();
        return $o;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addIdSensorLimits(FlatBufferBuilder $builder, $idSensorLimits)
    {
        $builder->addOffsetX(0, $idSensorLimits, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addClassificationMarking(FlatBufferBuilder $builder, $classificationMarking)
    {
        $builder->addOffsetX(1, $classificationMarking, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addOrigNetwork(FlatBufferBuilder $builder, $origNetwork)
    {
        $builder->addOffsetX(2, $origNetwork, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addUpperLeftAzimuthLimit(FlatBufferBuilder $builder, $upperLeftAzimuthLimit)
    {
        $builder->addDoubleX(3, $upperLeftAzimuthLimit, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addUpperRightAzimuthLimit(FlatBufferBuilder $builder, $upperRightAzimuthLimit)
    {
        $builder->addDoubleX(4, $upperRightAzimuthLimit, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addLowerRightAzimuthLimit(FlatBufferBuilder $builder, $lowerRightAzimuthLimit)
    {
        $builder->addDoubleX(5, $lowerRightAzimuthLimit, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addLowerLeftAzimuthLimit(FlatBufferBuilder $builder, $lowerLeftAzimuthLimit)
    {
        $builder->addDoubleX(6, $lowerLeftAzimuthLimit, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addLowerLeftElevationLimit(FlatBufferBuilder $builder, $lowerLeftElevationLimit)
    {
        $builder->addDoubleX(7, $lowerLeftElevationLimit, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addUpperLeftElevationLimit(FlatBufferBuilder $builder, $upperLeftElevationLimit)
    {
        $builder->addDoubleX(8, $upperLeftElevationLimit, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addLowerRightElevationLimit(FlatBufferBuilder $builder, $lowerRightElevationLimit)
    {
        $builder->addDoubleX(9, $lowerRightElevationLimit, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addUpperRightElevationLimit(FlatBufferBuilder $builder, $upperRightElevationLimit)
    {
        $builder->addDoubleX(10, $upperRightElevationLimit, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addSource(FlatBufferBuilder $builder, $source)
    {
        $builder->addOffsetX(11, $source, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param sbyte
     * @return void
     */
    public static function addDataMode(FlatBufferBuilder $builder, $dataMode)
    {
        $builder->addSbyteX(12, $dataMode, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addCreatedAt(FlatBufferBuilder $builder, $createdAt)
    {
        $builder->addOffsetX(13, $createdAt, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addCreatedBy(FlatBufferBuilder $builder, $createdBy)
    {
        $builder->addOffsetX(14, $createdBy, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addUpdatedAt(FlatBufferBuilder $builder, $updatedAt)
    {
        $builder->addOffsetX(15, $updatedAt, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addUpdatedBy(FlatBufferBuilder $builder, $updatedBy)
    {
        $builder->addOffsetX(16, $updatedBy, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addIdSensor(FlatBufferBuilder $builder, $idSensor)
    {
        $builder->addOffsetX(17, $idSensor, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return int table offset
     */
    public static function endSensorlimits_Full(FlatBufferBuilder $builder)
    {
        $o = $builder->endObject();
        return $o;
    }

    public static function finishSensorlimits_FullBuffer(FlatBufferBuilder $builder, $offset)
    {
        $builder->finish($offset, "SENS");
    }
}
