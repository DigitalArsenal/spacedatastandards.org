<?php
// automatically generated by the FlatBuffers compiler, do not modify

use \Google\FlatBuffers\Struct;
use \Google\FlatBuffers\Table;
use \Google\FlatBuffers\ByteBuffer;
use \Google\FlatBuffers\FlatBufferBuilder;

/// /// The timePeriod set describes the effective datetime for a given airspace control means.
class AirspaceTimePeriod_Ingest extends Table
{
    /**
     * @param ByteBuffer $bb
     * @return AirspaceTimePeriod_Ingest
     */
    public static function getRootAsAirspaceTimePeriod_Ingest(ByteBuffer $bb)
    {
        $obj = new AirspaceTimePeriod_Ingest();
        return ($obj->init($bb->getInt($bb->getPosition()) + $bb->getPosition(), $bb));
    }

    public static function AirspaceTimePeriod_IngestIdentifier()
    {
        return "AIRS";
    }

    public static function AirspaceTimePeriod_IngestBufferHasIdentifier(ByteBuffer $buf)
    {
        return self::__has_identifier($buf, self::AirspaceTimePeriod_IngestIdentifier());
    }

    /**
     * @param int $_i offset
     * @param ByteBuffer $_bb
     * @return AirspaceTimePeriod_Ingest
     **/
    public function init($_i, ByteBuffer $_bb)
    {
        $this->bb_pos = $_i;
        $this->bb = $_bb;
        return $this;
    }

    /// The airspace time code associated with the ACO. Can be DISCRETE, a fixed time block, or INTERVAL, a repeating time block.
    /// Example: /// Example: DISCRETE
    /// Constraints: Minimum length = 0, Maximum length = 8
    public function getTimeMode()
    {
        $o = $this->__offset(4);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// The start time designating that the airspace control order is active.
    /// Example: /// Example: 141325ZFEB2002
    /// Constraints: Minimum length = 0, Maximum length = 16
    public function getTimeStart()
    {
        $o = $this->__offset(6);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// The end time designating that the airspace control order is no longer active. Can contain datetime information or a stop time qualifier code, such as AFTER, NET, UFN, etc.
    /// Example: /// Example: 141325ZFEB2002
    /// Constraints: Minimum length = 0, Maximum length = 16
    public function getTimeEnd()
    {
        $o = $this->__offset(8);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /// Mandatory if timeMode is INTERVAL. Can be on of the interval frequency codes, such as BIWEEKLY, DAILY, YEARLY, etc.
    /// Example: /// Example: ['WEEKLY']
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getIntFreq($j)
    {
        $o = $this->__offset(10);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getIntFreqLength()
    {
        $o = $this->__offset(10);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// Mandatory if timeMode is INTERVAL. Can be a numerical multiplier on an interval frequency code, a stop time qualifier code such as AFTER, NET, UFN, etc, or a datetime like string.
    /// Example: /// Example: ['65WK']
    /// Constraints: No constraints specified.
    /**
     * @param int offset
     * @return string
     */
    public function getIntDur($j)
    {
        $o = $this->__offset(12);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : 0;
    }

    /**
     * @return int
     */
    public function getIntDurLength()
    {
        $o = $this->__offset(12);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return void
     */
    public static function startAirspaceTimePeriod_Ingest(FlatBufferBuilder $builder)
    {
        $builder->StartObject(5);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return AirspaceTimePeriod_Ingest
     */
    public static function createAirspaceTimePeriod_Ingest(FlatBufferBuilder $builder, $timeMode, $timeStart, $timeEnd, $intFreq, $intDur)
    {
        $builder->startObject(5);
        self::addTimeMode($builder, $timeMode);
        self::addTimeStart($builder, $timeStart);
        self::addTimeEnd($builder, $timeEnd);
        self::addIntFreq($builder, $intFreq);
        self::addIntDur($builder, $intDur);
        $o = $builder->endObject();
        return $o;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addTimeMode(FlatBufferBuilder $builder, $timeMode)
    {
        $builder->addOffsetX(0, $timeMode, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addTimeStart(FlatBufferBuilder $builder, $timeStart)
    {
        $builder->addOffsetX(1, $timeStart, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addTimeEnd(FlatBufferBuilder $builder, $timeEnd)
    {
        $builder->addOffsetX(2, $timeEnd, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addIntFreq(FlatBufferBuilder $builder, $intFreq)
    {
        $builder->addOffsetX(3, $intFreq, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createIntFreqVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startIntFreqVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addIntDur(FlatBufferBuilder $builder, $intDur)
    {
        $builder->addOffsetX(4, $intDur, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createIntDurVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startIntDurVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return int table offset
     */
    public static function endAirspaceTimePeriod_Ingest(FlatBufferBuilder $builder)
    {
        $o = $builder->endObject();
        return $o;
    }

    public static function finishAirspaceTimePeriod_IngestBuffer(FlatBufferBuilder $builder, $offset)
    {
        $builder->finish($offset, "AIRS");
    }
}
