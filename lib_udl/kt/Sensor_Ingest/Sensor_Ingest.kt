// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// Model representation of observation data for electro-optical based sensor phenomenologies.
 */
@Suppress("unused")
class Sensor_Ingest : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : Sensor_Ingest {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record, auto-generated by the system.
     * Example: /// Example: SENSOR-ID
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val idSensor : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idSensorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun idSensorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Unique name of this sensor.
     * Example: /// Example: SENSOR_NAME
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val sensorName : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sensorNameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun sensorNameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     * Example: /// Example: U
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val classificationMarking : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val classificationMarkingAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun classificationMarkingInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
     * Example: /// Example: 1234
     * Constraints: No constraints specified.
     */
    val sensorNumber : Int
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Optional short name for the sensor.
     * Example: /// Example: SNR-1
     * Constraints: Minimum length = 0, Maximum length = 5
     */
    val shortName : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val shortNameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun shortNameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Optional dissemination control required for accessing data (e.g observations) produced by this sensor. This is typically a proprietary data owner control for commercial sensors.
     * Example: /// Example: observations
     * Constraints: Minimum length = 0, Maximum length = 128
     */
    val dataControl : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val dataControlAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun dataControlInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Optional US Air Force identifier for the sensor/ASR site, typically for air surveillance radar (ASR) sensors.
     * Example: /// Example: AF-ID
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val afId : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val afIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun afIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * The sensor type at the site. Optional field, intended primarily for ASRs.
     * Example: /// Example: SENSOR_TYPE
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val asrType : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val asrTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun asrTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * Source of the data.
     * Example: /// Example: some.user
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val source : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun sourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     * Example: /// Example: THIRD_PARTY_DATASOURCE
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origin : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val originAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun originInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * The originating source network on which this record was created, auto-populated by the system.
     * Example: /// Example: ORIG
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val origNetwork : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origNetworkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun origNetworkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
     * Example: /// Example: TEST
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val dataMode : Byte
        get() {
            val o = __offset(26)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Time the row was created in the database, auto-populated by the system.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val createdAt : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdAtAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun createdAtInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    /**
     * Application user who created the row in the database, auto-populated by the system.
     * Example: /// Example: some.user
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val createdBy : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdByAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun createdByInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    /**
     * Optional flag indicating if the sensor is active.
     * Example: /// Example: True
     * Constraints: No constraints specified.
     */
    val active : Boolean
        get() {
            val o = __offset(32)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Collection of Sensorcharacteristics which define characteristics and capabilities of a sensor.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    fun sensorcharacteristics(j: Int) : String? {
        val o = __offset(34)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val sensorcharacteristicsLength : Int
        get() {
            val o = __offset(34); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Collection of SensorStats which contain statistics of a sensor.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    fun sensorStats(j: Int) : String? {
        val o = __offset(36)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val sensorStatsLength : Int
        get() {
            val o = __offset(36); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    fun sensorlimitsCollection(j: Int) : String? {
        val o = __offset(38)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val sensorlimitsCollectionLength : Int
        get() {
            val o = __offset(38); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * No description provided.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    val entity : String?
        get() {
            val o = __offset(40)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val entityAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(40, 1)
    fun entityInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 40, 1)
    /**
     * Unique identifier of the parent entity. idEntity is required for Put.
     * Example: /// Example: ENTITY-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idEntity : String?
        get() {
            val o = __offset(42)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idEntityAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(42, 1)
    fun idEntityInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 42, 1)
    /**
     * No description provided.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    val sensorObservationType : String?
        get() {
            val o = __offset(44)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sensorObservationTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(44, 1)
    fun sensorObservationTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 44, 1)
    /**
     * No description provided.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    val sensorType : String?
        get() {
            val o = __offset(46)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sensorTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(46, 1)
    fun sensorTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 46, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsSensor_Ingest(_bb: ByteBuffer): Sensor_Ingest = getRootAsSensor_Ingest(_bb, Sensor_Ingest())
        fun getRootAsSensor_Ingest(_bb: ByteBuffer, obj: Sensor_Ingest): Sensor_Ingest {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun Sensor_IngestBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "SENS")
        fun createSensor_Ingest(builder: FlatBufferBuilder, idSensorOffset: Int, sensorNameOffset: Int, classificationMarkingOffset: Int, sensorNumber: Int, shortNameOffset: Int, dataControlOffset: Int, afIdOffset: Int, asrTypeOffset: Int, sourceOffset: Int, originOffset: Int, origNetworkOffset: Int, dataMode: Byte, createdAtOffset: Int, createdByOffset: Int, active: Boolean, sensorcharacteristicsOffset: Int, sensorStatsOffset: Int, sensorlimitsCollectionOffset: Int, entityOffset: Int, idEntityOffset: Int, sensorObservationTypeOffset: Int, sensorTypeOffset: Int) : Int {
            builder.startTable(22)
            addSensorType(builder, sensorTypeOffset)
            addSensorObservationType(builder, sensorObservationTypeOffset)
            addIdEntity(builder, idEntityOffset)
            addEntity(builder, entityOffset)
            addSensorlimitsCollection(builder, sensorlimitsCollectionOffset)
            addSensorStats(builder, sensorStatsOffset)
            addSensorcharacteristics(builder, sensorcharacteristicsOffset)
            addCreatedBy(builder, createdByOffset)
            addCreatedAt(builder, createdAtOffset)
            addOrigNetwork(builder, origNetworkOffset)
            addOrigin(builder, originOffset)
            addSource(builder, sourceOffset)
            addAsrType(builder, asrTypeOffset)
            addAfId(builder, afIdOffset)
            addDataControl(builder, dataControlOffset)
            addShortName(builder, shortNameOffset)
            addSensorNumber(builder, sensorNumber)
            addClassificationMarking(builder, classificationMarkingOffset)
            addSensorName(builder, sensorNameOffset)
            addIdSensor(builder, idSensorOffset)
            addActive(builder, active)
            addDataMode(builder, dataMode)
            return endSensor_Ingest(builder)
        }
        fun startSensor_Ingest(builder: FlatBufferBuilder) = builder.startTable(22)
        fun addIdSensor(builder: FlatBufferBuilder, idSensor: Int) = builder.addOffset(0, idSensor, 0)
        fun addSensorName(builder: FlatBufferBuilder, sensorName: Int) = builder.addOffset(1, sensorName, 0)
        fun addClassificationMarking(builder: FlatBufferBuilder, classificationMarking: Int) = builder.addOffset(2, classificationMarking, 0)
        fun addSensorNumber(builder: FlatBufferBuilder, sensorNumber: Int) = builder.addInt(3, sensorNumber, 0)
        fun addShortName(builder: FlatBufferBuilder, shortName: Int) = builder.addOffset(4, shortName, 0)
        fun addDataControl(builder: FlatBufferBuilder, dataControl: Int) = builder.addOffset(5, dataControl, 0)
        fun addAfId(builder: FlatBufferBuilder, afId: Int) = builder.addOffset(6, afId, 0)
        fun addAsrType(builder: FlatBufferBuilder, asrType: Int) = builder.addOffset(7, asrType, 0)
        fun addSource(builder: FlatBufferBuilder, source: Int) = builder.addOffset(8, source, 0)
        fun addOrigin(builder: FlatBufferBuilder, origin: Int) = builder.addOffset(9, origin, 0)
        fun addOrigNetwork(builder: FlatBufferBuilder, origNetwork: Int) = builder.addOffset(10, origNetwork, 0)
        fun addDataMode(builder: FlatBufferBuilder, dataMode: Byte) = builder.addByte(11, dataMode, 0)
        fun addCreatedAt(builder: FlatBufferBuilder, createdAt: Int) = builder.addOffset(12, createdAt, 0)
        fun addCreatedBy(builder: FlatBufferBuilder, createdBy: Int) = builder.addOffset(13, createdBy, 0)
        fun addActive(builder: FlatBufferBuilder, active: Boolean) = builder.addBoolean(14, active, false)
        fun addSensorcharacteristics(builder: FlatBufferBuilder, sensorcharacteristics: Int) = builder.addOffset(15, sensorcharacteristics, 0)
        fun createSensorcharacteristicsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSensorcharacteristicsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSensorStats(builder: FlatBufferBuilder, sensorStats: Int) = builder.addOffset(16, sensorStats, 0)
        fun createSensorStatsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSensorStatsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSensorlimitsCollection(builder: FlatBufferBuilder, sensorlimitsCollection: Int) = builder.addOffset(17, sensorlimitsCollection, 0)
        fun createSensorlimitsCollectionVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSensorlimitsCollectionVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addEntity(builder: FlatBufferBuilder, entity: Int) = builder.addOffset(18, entity, 0)
        fun addIdEntity(builder: FlatBufferBuilder, idEntity: Int) = builder.addOffset(19, idEntity, 0)
        fun addSensorObservationType(builder: FlatBufferBuilder, sensorObservationType: Int) = builder.addOffset(20, sensorObservationType, 0)
        fun addSensorType(builder: FlatBufferBuilder, sensorType: Int) = builder.addOffset(21, sensorType, 0)
        fun endSensor_Ingest(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishSensorIngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "SENS")
        fun finishSizePrefixedSensor_IngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "SENS")
    }
}
