// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// The analytic imagery schema supports data plots and graphics of various types. The records contain general file information, allows for annotations to user-defined areas of interest on the graphics, and supports keyword searching.
 */
@Suppress("unused")
class AnalyticImagery_Abridged : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : AnalyticImagery_Abridged {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record, auto-generated by the system.
     * Example: /// Example: ANALYTIC-IMAGERY-ID
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val id : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun idInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     * Example: /// Example: U
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val classificationMarking : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val classificationMarkingAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun classificationMarkingInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * General type of content of this image (CONTOUR, DIAGRAM, HEATMAP, HISTOGRAM, PLOT, SCREENSHOT).
     * Example: /// Example: CONTOUR
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val content : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val contentAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun contentInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * The message time of this image record, in ISO8601 UTC format with millisecond precision.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val msgTime : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val msgTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun msgTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * The type of image associated with this record (GIF, JPG, PNG, TIF).
     * Example: /// Example: JPG
     * Constraints: Minimum length = 1, Maximum length = 16
     */
    val imageType : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val imageTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun imageTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * The image file name.
     * Example: /// Example: IMAGE-NAME
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val filename : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val filenameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun filenameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * The image file size, in bytes.  The maximum file size for this service is 40,000,000 bytes (40MB). Files exceeding the maximum size will be rejected.
     * Example: /// Example: 7654321
     * Constraints: No constraints specified.
     */
    val filesize : Long
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getLong(o + bb_pos) else 0L
        }
    /**
     * The image width (horizontal), in pixels.
     * Example: /// Example: 123
     * Constraints: No constraints specified.
     */
    val imgWidth : Int
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The image height (vertical), in pixels.
     * Example: /// Example: 123
     * Constraints: No constraints specified.
     */
    val imgHeight : Int
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Optional field indicating the units that apply to the x-axis of the attached image, when applicable.
     * Example: /// Example: pixels
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val xUnits : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val xUnitsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun xUnitsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * Optional field indicating the units that apply to the y-axis of the attached image, when applicable.
     * Example: /// Example: pixels
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val yUnits : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val yUnitsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun yUnitsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * Optional field indicating the units that apply to the z-axis of the attached image, when applicable.
     * Example: /// Example: pixels
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val zUnits : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val zUnitsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun zUnitsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * User-defined set ID of a sequence of images.  Used to associate related analytic image records.
     * Example: /// Example: IMAGE-IDS
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val imageSetId : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val imageSetIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun imageSetIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    /**
     * The number of images in an image set.
     * Example: /// Example: 123
     * Constraints: No constraints specified.
     */
    val imageSetLength : Int
        get() {
            val o = __offset(30)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The sequence number of an image within an image set.  If null, then it is assumed that the order of images in an imageSet is not relevant.
     * Example: /// Example: 123
     * Constraints: No constraints specified.
     */
    val sequenceId : Int
        get() {
            val o = __offset(32)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Description of the image content and utility.
     * Example: /// Example: Image description
     * Constraints: Minimum length = 1, Maximum length = 512
     */
    val description : String?
        get() {
            val o = __offset(34)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val descriptionAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(34, 1)
    fun descriptionInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 34, 1)
    /**
     * The start time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val dataStart : String?
        get() {
            val o = __offset(36)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val dataStartAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(36, 1)
    fun dataStartInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 36, 1)
    /**
     * The stop time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val dataStop : String?
        get() {
            val o = __offset(38)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val dataStopAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(38, 1)
    fun dataStopInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 38, 1)
    /**
     * Rectangular annotation limits, specified in pixels, as an array of arrays of the coordinates [ [UL1x, UL1y], [UR1x, UR1y], [LR1x, LR1y], [LL1x, LL1y] ], indicating the corners of a rectangle beginning with the Upper Left (UL) and moving clockwise. Allows the image provider to highlight one or more rectangular area(s) of interest. The array must contain Nx4 two-element arrays, where N is the number of rectangles of interest.  The associated annotation(s) should be included in the annText array.
     * Example: /// Example: [[1, 1], [1, 2], [1, 3], [1, 4]]
     * Constraints: No constraints specified.
     */
    fun annLims(j: Int) : String? {
        val o = __offset(40)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val annLimsLength : Int
        get() {
            val o = __offset(40); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Annotation text, a string array of annotation(s) corresponding to the rectangular areas specified in annLims.  This array contains the annotation text associated with the areas of interest indicated in annLims, in order.  This array should contain one annotation per four values of the area (annLims) array.
     * Example: /// Example: ['rec1', 'rec2']
     * Constraints: No constraints specified.
     */
    fun annText(j: Int) : String? {
        val o = __offset(42)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val annTextLength : Int
        get() {
            val o = __offset(42); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of searchable keywords for this analytic imagery record.
     * Example: /// Example: ['Key1', 'Key2']
     * Constraints: No constraints specified.
     */
    fun keywords(j: Int) : String? {
        val o = __offset(44)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val keywordsLength : Int
        get() {
            val o = __offset(44); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
     * Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
     * Constraints: No constraints specified.
     */
    val atext : String?
        get() {
            val o = __offset(46)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val atextAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(46, 1)
    fun atextInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 46, 1)
    /**
     * Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
     * Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
     * Constraints: No constraints specified.
     */
    val agjson : String?
        get() {
            val o = __offset(48)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val agjsonAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(48, 1)
    fun agjsonInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 48, 1)
    /**
     * Type of region as projected on the ground.
     * Example: /// Example: POLYGON
     * Constraints: Minimum length = 0, Maximum length = 128
     */
    val atype : String?
        get() {
            val o = __offset(50)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val atypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(50, 1)
    fun atypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 50, 1)
    /**
     * Number of dimensions of the geometry depicted by region.
     * Example: /// Example: 2
     * Constraints: No constraints specified.
     */
    val andims : Int
        get() {
            val o = __offset(52)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Geographical spatial_ref_sys for region.
     * Example: /// Example: 4326
     * Constraints: No constraints specified.
     */
    val asrid : Int
        get() {
            val o = __offset(54)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Assessed satellite ID (NORAD RSO object number).  The 'satId' and 'satIdConf' arrays must match in size.
     * Example: /// Example: [12004, 12005]
     * Constraints: No constraints specified.
     */
    fun satId(j: Int) : String? {
        val o = __offset(56)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val satIdLength : Int
        get() {
            val o = __offset(56); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Assessed satellite confidence corresponding to an assessment ID.  Values are between 0.0 and 1.0.  The 'satId' and 'satIdConf' arrays must match in size.
     * Example: /// Example: [0.98, 0.22]
     * Constraints: No constraints specified.
     */
    fun satIdConf(j: Int) : String? {
        val o = __offset(58)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val satIdConfLength : Int
        get() {
            val o = __offset(58); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this image. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
     * Example: /// Example: ['MTI', 'POI']
     * Constraints: No constraints specified.
     */
    fun srcTyps(j: Int) : String? {
        val o = __offset(60)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val srcTypsLength : Int
        get() {
            val o = __offset(60); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of UUIDs of the UDL data records that are related to this image. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
     * Example: /// Example: ['DOA_ID', 'DWELL_ID']
     * Constraints: No constraints specified.
     */
    fun srcIds(j: Int) : String? {
        val o = __offset(62)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val srcIdsLength : Int
        get() {
            val o = __offset(62); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
     * Example: /// Example: ['TAG1', 'TAG2']
     * Constraints: No constraints specified.
     */
    fun tags(j: Int) : String? {
        val o = __offset(64)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val tagsLength : Int
        get() {
            val o = __offset(64); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * MD5 checksum value of the file. The ingest/create operation will automatically generate the value.
     * Example: /// Example: 123
     * Constraints: Minimum length = 0, Maximum length = 256
     */
    val checksumValue : String?
        get() {
            val o = __offset(66)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val checksumValueAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(66, 1)
    fun checksumValueInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 66, 1)
    /**
     * Optional identifier to track a commercial or marketplace transaction executed to produce this data.
     * Example: /// Example: a7bdef1f-5a4f-4716-bee4-7a1e0ec7d35a
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val transactionId : String?
        get() {
            val o = __offset(68)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val transactionIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(68, 1)
    fun transactionIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 68, 1)
    /**
     * Time the row was created in the database, auto-populated by the system.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val createdAt : String?
        get() {
            val o = __offset(70)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdAtAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(70, 1)
    fun createdAtInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 70, 1)
    /**
     * Application user who created the row in the database, auto-populated by the system.
     * Example: /// Example: some.user
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val createdBy : String?
        get() {
            val o = __offset(72)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdByAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(72, 1)
    fun createdByInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 72, 1)
    /**
     * Source of the data.
     * Example: /// Example: Bluestaq
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val source : String?
        get() {
            val o = __offset(74)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(74, 1)
    fun sourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 74, 1)
    /**
     * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     * Example: /// Example: ORIGIN
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origin : String?
        get() {
            val o = __offset(76)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val originAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(76, 1)
    fun originInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 76, 1)
    /**
     * The originating source network on which this record was created, auto-populated by the system.
     * Example: /// Example: TST1
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val origNetwork : String?
        get() {
            val o = __offset(78)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origNetworkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(78, 1)
    fun origNetworkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 78, 1)
    /**
     * The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
     * Example: /// Example: AXE
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val sourceDl : String?
        get() {
            val o = __offset(80)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceDlAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(80, 1)
    fun sourceDlInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 80, 1)
    /**
     * Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
     * Example: /// Example: TEST
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val dataMode : Byte
        get() {
            val o = __offset(82)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsAnalyticImagery_Abridged(_bb: ByteBuffer): AnalyticImagery_Abridged = getRootAsAnalyticImagery_Abridged(_bb, AnalyticImagery_Abridged())
        fun getRootAsAnalyticImagery_Abridged(_bb: ByteBuffer, obj: AnalyticImagery_Abridged): AnalyticImagery_Abridged {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun AnalyticImagery_AbridgedBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "ANAL")
        fun createAnalyticImagery_Abridged(builder: FlatBufferBuilder, idOffset: Int, classificationMarkingOffset: Int, contentOffset: Int, msgTimeOffset: Int, imageTypeOffset: Int, filenameOffset: Int, filesize: Long, imgWidth: Int, imgHeight: Int, xUnitsOffset: Int, yUnitsOffset: Int, zUnitsOffset: Int, imageSetIdOffset: Int, imageSetLength: Int, sequenceId: Int, descriptionOffset: Int, dataStartOffset: Int, dataStopOffset: Int, annLimsOffset: Int, annTextOffset: Int, keywordsOffset: Int, atextOffset: Int, agjsonOffset: Int, atypeOffset: Int, andims: Int, asrid: Int, satIdOffset: Int, satIdConfOffset: Int, srcTypsOffset: Int, srcIdsOffset: Int, tagsOffset: Int, checksumValueOffset: Int, transactionIdOffset: Int, createdAtOffset: Int, createdByOffset: Int, sourceOffset: Int, originOffset: Int, origNetworkOffset: Int, sourceDlOffset: Int, dataMode: Byte) : Int {
            builder.startTable(40)
            addFilesize(builder, filesize)
            addSourceDL(builder, sourceDlOffset)
            addOrigNetwork(builder, origNetworkOffset)
            addOrigin(builder, originOffset)
            addSource(builder, sourceOffset)
            addCreatedBy(builder, createdByOffset)
            addCreatedAt(builder, createdAtOffset)
            addTransactionId(builder, transactionIdOffset)
            addChecksumValue(builder, checksumValueOffset)
            addTags(builder, tagsOffset)
            addSrcIds(builder, srcIdsOffset)
            addSrcTyps(builder, srcTypsOffset)
            addSatIdConf(builder, satIdConfOffset)
            addSatId(builder, satIdOffset)
            addAsrid(builder, asrid)
            addAndims(builder, andims)
            addAtype(builder, atypeOffset)
            addAgjson(builder, agjsonOffset)
            addAtext(builder, atextOffset)
            addKeywords(builder, keywordsOffset)
            addAnnText(builder, annTextOffset)
            addAnnLims(builder, annLimsOffset)
            addDataStop(builder, dataStopOffset)
            addDataStart(builder, dataStartOffset)
            addDescription(builder, descriptionOffset)
            addSequenceId(builder, sequenceId)
            addImageSetLength(builder, imageSetLength)
            addImageSetId(builder, imageSetIdOffset)
            addZUnits(builder, zUnitsOffset)
            addYUnits(builder, yUnitsOffset)
            addXUnits(builder, xUnitsOffset)
            addImgHeight(builder, imgHeight)
            addImgWidth(builder, imgWidth)
            addFilename(builder, filenameOffset)
            addImageType(builder, imageTypeOffset)
            addMsgTime(builder, msgTimeOffset)
            addContent(builder, contentOffset)
            addClassificationMarking(builder, classificationMarkingOffset)
            addId(builder, idOffset)
            addDataMode(builder, dataMode)
            return endAnalyticImagery_Abridged(builder)
        }
        fun startAnalyticImagery_Abridged(builder: FlatBufferBuilder) = builder.startTable(40)
        fun addId(builder: FlatBufferBuilder, id: Int) = builder.addOffset(0, id, 0)
        fun addClassificationMarking(builder: FlatBufferBuilder, classificationMarking: Int) = builder.addOffset(1, classificationMarking, 0)
        fun addContent(builder: FlatBufferBuilder, content: Int) = builder.addOffset(2, content, 0)
        fun addMsgTime(builder: FlatBufferBuilder, msgTime: Int) = builder.addOffset(3, msgTime, 0)
        fun addImageType(builder: FlatBufferBuilder, imageType: Int) = builder.addOffset(4, imageType, 0)
        fun addFilename(builder: FlatBufferBuilder, filename: Int) = builder.addOffset(5, filename, 0)
        fun addFilesize(builder: FlatBufferBuilder, filesize: Long) = builder.addLong(6, filesize, 0L)
        fun addImgWidth(builder: FlatBufferBuilder, imgWidth: Int) = builder.addInt(7, imgWidth, 0)
        fun addImgHeight(builder: FlatBufferBuilder, imgHeight: Int) = builder.addInt(8, imgHeight, 0)
        fun addXUnits(builder: FlatBufferBuilder, xUnits: Int) = builder.addOffset(9, xUnits, 0)
        fun addYUnits(builder: FlatBufferBuilder, yUnits: Int) = builder.addOffset(10, yUnits, 0)
        fun addZUnits(builder: FlatBufferBuilder, zUnits: Int) = builder.addOffset(11, zUnits, 0)
        fun addImageSetId(builder: FlatBufferBuilder, imageSetId: Int) = builder.addOffset(12, imageSetId, 0)
        fun addImageSetLength(builder: FlatBufferBuilder, imageSetLength: Int) = builder.addInt(13, imageSetLength, 0)
        fun addSequenceId(builder: FlatBufferBuilder, sequenceId: Int) = builder.addInt(14, sequenceId, 0)
        fun addDescription(builder: FlatBufferBuilder, description: Int) = builder.addOffset(15, description, 0)
        fun addDataStart(builder: FlatBufferBuilder, dataStart: Int) = builder.addOffset(16, dataStart, 0)
        fun addDataStop(builder: FlatBufferBuilder, dataStop: Int) = builder.addOffset(17, dataStop, 0)
        fun addAnnLims(builder: FlatBufferBuilder, annLims: Int) = builder.addOffset(18, annLims, 0)
        fun createAnnLimsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAnnLimsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addAnnText(builder: FlatBufferBuilder, annText: Int) = builder.addOffset(19, annText, 0)
        fun createAnnTextVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAnnTextVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addKeywords(builder: FlatBufferBuilder, keywords: Int) = builder.addOffset(20, keywords, 0)
        fun createKeywordsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startKeywordsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addAtext(builder: FlatBufferBuilder, atext: Int) = builder.addOffset(21, atext, 0)
        fun addAgjson(builder: FlatBufferBuilder, agjson: Int) = builder.addOffset(22, agjson, 0)
        fun addAtype(builder: FlatBufferBuilder, atype: Int) = builder.addOffset(23, atype, 0)
        fun addAndims(builder: FlatBufferBuilder, andims: Int) = builder.addInt(24, andims, 0)
        fun addAsrid(builder: FlatBufferBuilder, asrid: Int) = builder.addInt(25, asrid, 0)
        fun addSatId(builder: FlatBufferBuilder, satId: Int) = builder.addOffset(26, satId, 0)
        fun createSatIdVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSatIdVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSatIdConf(builder: FlatBufferBuilder, satIdConf: Int) = builder.addOffset(27, satIdConf, 0)
        fun createSatIdConfVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSatIdConfVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSrcTyps(builder: FlatBufferBuilder, srcTyps: Int) = builder.addOffset(28, srcTyps, 0)
        fun createSrcTypsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSrcTypsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSrcIds(builder: FlatBufferBuilder, srcIds: Int) = builder.addOffset(29, srcIds, 0)
        fun createSrcIdsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSrcIdsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addTags(builder: FlatBufferBuilder, tags: Int) = builder.addOffset(30, tags, 0)
        fun createTagsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTagsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addChecksumValue(builder: FlatBufferBuilder, checksumValue: Int) = builder.addOffset(31, checksumValue, 0)
        fun addTransactionId(builder: FlatBufferBuilder, transactionId: Int) = builder.addOffset(32, transactionId, 0)
        fun addCreatedAt(builder: FlatBufferBuilder, createdAt: Int) = builder.addOffset(33, createdAt, 0)
        fun addCreatedBy(builder: FlatBufferBuilder, createdBy: Int) = builder.addOffset(34, createdBy, 0)
        fun addSource(builder: FlatBufferBuilder, source: Int) = builder.addOffset(35, source, 0)
        fun addOrigin(builder: FlatBufferBuilder, origin: Int) = builder.addOffset(36, origin, 0)
        fun addOrigNetwork(builder: FlatBufferBuilder, origNetwork: Int) = builder.addOffset(37, origNetwork, 0)
        fun addSourceDL(builder: FlatBufferBuilder, sourceDl: Int) = builder.addOffset(38, sourceDl, 0)
        fun addDataMode(builder: FlatBufferBuilder, dataMode: Byte) = builder.addByte(39, dataMode, 0)
        fun endAnalyticImagery_Abridged(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishAnalyticImageryAbridgedBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "ANAL")
        fun finishSizePrefixedAnalyticImagery_AbridgedBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "ANAL")
    }
}
