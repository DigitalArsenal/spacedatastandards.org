// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// These services provide for posting and querying Weather Data. Weather Data integrates dynamic data measured by Doppler/CG such as signal power and noise levels, to produce useful weather information.
 */
@Suppress("unused")
class WeatherData_Full : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : WeatherData_Full {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record, auto-generated by the system.
     * Example: /// Example: WEATHER-DATA-ID
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val id : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun idInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     * Example: /// Example: U
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val classificationMarking : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val classificationMarkingAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun classificationMarkingInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Unique identifier of the sensor making the weather measurement.
     * Example: /// Example: 0129f577-e04c-441e-65ca-0a04a750bed9
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idSensor : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idSensorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun idSensorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Optional identifier provided by the record source. This may be an internal identifier and not necessarily a valid sensor ID.
     * Example: /// Example: ORIGSENSOR-ID
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origSensorId : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origSensorIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun origSensorIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Datetime of the weather observation in ISO 8601 UTC datetime format with microsecond precision.
     * Example: /// Example: 2018-01-01T16:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val obTime : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val obTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun obTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Array of signal power(s) measured by the sensor, in decibels. Users should consult the data provider for information on the signal powers array structure.
     * Example: /// Example: [116.5, 121.6]
     * Constraints: No constraints specified.
     */
    fun sigPwrs(j: Int) : String? {
        val o = __offset(14)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val sigPwrsLength : Int
        get() {
            val o = __offset(14); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of noise level(s) measured by radar, in decibels. Users should consult the data provider for information on the noise levels array structure.
     * Example: /// Example: [58.2, 58.3]
     * Constraints: No constraints specified.
     */
    fun noiseLvls(j: Int) : String? {
        val o = __offset(16)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val noiseLvlsLength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of width(s) of the distribution in Doppler velocity measured by radar, in meters/second. Spectral width depends on the particle size distribution, the wind shear across the radar beam, and turbulence. Users should consult the data provider for information on the spectral widths array structure.
     * Example: /// Example: [0.3, 0.6]
     * Constraints: No constraints specified.
     */
    fun specWidths(j: Int) : String? {
        val o = __offset(18)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val specWidthsLength : Int
        get() {
            val o = __offset(18); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of average maximum number(s) of consecutive instances in which the same first guess velocity is used in radar data processing to estimate wind speed. Users should consult the data provider for information on the first guess averages array structure.
     * Example: /// Example: [16, 1]
     * Constraints: No constraints specified.
     */
    fun firstGuessAvgs(j: Int) : String? {
        val o = __offset(20)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val firstGuessAvgsLength : Int
        get() {
            val o = __offset(20); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Quality control flag value, as defined by the data provider.
     * Example: /// Example: 4
     * Constraints: No constraints specified.
     */
    val qcValue : Int
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Datetime the system files were created.
     * Example: /// Example: 2018-01-01T16:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val fileCreation : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val fileCreationAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun fileCreationInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * Last altitude with recorded measurements in this record, in meters.
     * Example: /// Example: 19505.1
     * Constraints: No constraints specified.
     */
    val termAlt : Double
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Average transmitted power of the radar, in kilowatts.
     * Example: /// Example: 20.23
     * Constraints: No constraints specified.
     */
    val avgTxPwr : Double
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Average power of the reflected signal received by the radar, in Watts.
     * Example: /// Example: 714.9
     * Constraints: No constraints specified.
     */
    val avgRefPwr : Double
        get() {
            val o = __offset(30)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Number of sectors within the radar coverage area, each containing a number of antennas.
     * Example: /// Example: 20
     * Constraints: No constraints specified.
     */
    val sectorNum : Int
        get() {
            val o = __offset(32)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Number of antennas across all sectors within the radar coverage area.
     * Example: /// Example: 640
     * Constraints: No constraints specified.
     */
    val numElements : Int
        get() {
            val o = __offset(34)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Array of the number(s) of radar samples used in time domain averaging for radar data processing. Time domain averaging improves the quality of the measured signal by reducing random noise and enhancing the signal-to-noise ratio. Users should consult the data provider for information on the time domain sample numbers array structure.
     * Example: /// Example: [32, 30]
     * Constraints: No constraints specified.
     */
    fun tdAvgSampleNums(j: Int) : String? {
        val o = __offset(36)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val tdAvgSampleNumsLength : Int
        get() {
            val o = __offset(36); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Checksum value for the data.
     * Example: /// Example: 133
     * Constraints: No constraints specified.
     */
    val checksum : Int
        get() {
            val o = __offset(38)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Array of the number(s) of measurements used in coherent integrations used for radar data processing. Users should consult the data provider for information on the coherent integrations array structure.
     * Example: /// Example: [4, 3]
     * Constraints: No constraints specified.
     */
    fun coIntegs(j: Int) : String? {
        val o = __offset(40)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val coIntegsLength : Int
        get() {
            val o = __offset(40); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the number(s) of spectral averages used in radar data processing. Users should consult the data provider for information on the spectral averages array structure.
     * Example: /// Example: [4, 3]
     * Constraints: No constraints specified.
     */
    fun specAvgs(j: Int) : String? {
        val o = __offset(42)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val specAvgsLength : Int
        get() {
            val o = __offset(42); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the elapsed time(s) from the beginning of one pulse to the beginning of the next pulse for a radar beam, in microseconds. Users should consult the data provider for information on the interpulse periods array structure.
     * Example: /// Example: [1000.3, 1000.2]
     * Constraints: No constraints specified.
     */
    fun interpulsePeriods(j: Int) : String? {
        val o = __offset(44)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val interpulsePeriodsLength : Int
        get() {
            val o = __offset(44); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of full scale Nyquist Doppler velocities measured by radar, in meters per second. Nyquist velocity refers to the maximum velocity magnitude that the radar system can unambiguously detect. Doppler velocities with absolute values exceeding the Nyquist threshold suffer from aliasing at the time of collection. Users should consult the data provider for information on the doppler velocities array structure.
     * Example: /// Example: [44.4, 467.3]
     * Constraints: No constraints specified.
     */
    fun doppVels(j: Int) : String? {
        val o = __offset(46)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val doppVelsLength : Int
        get() {
            val o = __offset(46); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the number(s) of records in consensus for a radar beam. Users should consult the data provider for information on the consensus records array structure.
     * Example: /// Example: [5, 2]
     * Constraints: No constraints specified.
     */
    fun consRecs(j: Int) : String? {
        val o = __offset(48)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val consRecsLength : Int
        get() {
            val o = __offset(48); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of signal to noise ratio(s) for a radar beam, in decibels. Users should consult the data provider for information on the signal to noise ratios array structure.
     * Example: /// Example: [14.5, -16.2]
     * Constraints: No constraints specified.
     */
    fun snrs(j: Int) : String? {
        val o = __offset(50)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val snrsLength : Int
        get() {
            val o = __offset(50); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Signal strength of the electromagnetic energy received due to a lightning event, in kiloamps.
     * Example: /// Example: 163.7
     * Constraints: No constraints specified.
     */
    val sigStrength : Double
        get() {
            val o = __offset(52)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Semi-major axis of the 50% positional confidence ellipse, in kilometers.
     * Example: /// Example: 3.4
     * Constraints: No constraints specified.
     */
    val semiMajorAxis : Double
        get() {
            val o = __offset(54)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Semi-minor axis of the 50% positional confidence ellipse, in kilometers.
     * Example: /// Example: 0.3
     * Constraints: No constraints specified.
     */
    val semiMinorAxis : Double
        get() {
            val o = __offset(56)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Angle of orientation of the 50% positional confidence ellipse, in degrees clockwise from true north.
     * Example: /// Example: 75.7
     * Constraints: No constraints specified.
     */
    val angleOrientation : Double
        get() {
            val o = __offset(58)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Number of sensors used in the lightning event location solution.
     * Example: /// Example: 9
     * Constraints: No constraints specified.
     */
    val lightEventNum : Int
        get() {
            val o = __offset(60)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Array of sensor(s) that participated in the lightning event location determination.
     * Example: /// Example: [11, 28, 190]
     * Constraints: No constraints specified.
     */
    fun lightDetSensors(j: Int) : String? {
        val o = __offset(62)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val lightDetSensorsLength : Int
        get() {
            val o = __offset(62); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The positional confidence of the calculated lightning event location using the chi-square statistical method.
     * Example: /// Example: 0.1
     * Constraints: No constraints specified.
     */
    val posConfidence : Double
        get() {
            val o = __offset(64)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Array of UDL record types (SENSOR, WEATHERREPORT) that are related to this WeatherData record. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
     * Example: /// Example: ['SENSOR', 'WEATHERREPORT']
     * Constraints: No constraints specified.
     */
    fun srcTyps(j: Int) : String? {
        val o = __offset(66)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val srcTypsLength : Int
        get() {
            val o = __offset(66); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of UUID(s) of the UDL data record(s) that are related to this WeatherData record. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
     * Example: /// Example: ['1b23ba93-0957-4654-b5ca-8c3703f3ec57', '32944ee4-0437-4d94-95ce-2f2823ffa001']
     * Constraints: No constraints specified.
     */
    fun srcIds(j: Int) : String? {
        val o = __offset(68)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val srcIdsLength : Int
        get() {
            val o = __offset(68); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The originating source network on which this record was created, auto-populated by the system.
     * Example: /// Example: OPS1
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val origNetwork : String?
        get() {
            val o = __offset(70)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origNetworkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(70, 1)
    fun origNetworkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 70, 1)
    /**
     * Time the row was created in the database.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val createdAt : String?
        get() {
            val o = __offset(72)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdAtAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(72, 1)
    fun createdAtInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 72, 1)
    /**
     * Application user who created the row in the database.
     * Example: /// Example: some.user
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val createdBy : String?
        get() {
            val o = __offset(74)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdByAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(74, 1)
    fun createdByInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 74, 1)
    /**
     * Source of the data.
     * Example: /// Example: Bluestaq
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val source : String?
        get() {
            val o = __offset(76)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(76, 1)
    fun sourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 76, 1)
    /**
     * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     * Example: /// Example: THIRD_PARTY_DATASOURCE
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origin : String?
        get() {
            val o = __offset(78)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val originAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(78, 1)
    fun originInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 78, 1)
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
     * Example: /// Example: TEST
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val dataMode : Byte
        get() {
            val o = __offset(80)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsWeatherData_Full(_bb: ByteBuffer): WeatherData_Full = getRootAsWeatherData_Full(_bb, WeatherData_Full())
        fun getRootAsWeatherData_Full(_bb: ByteBuffer, obj: WeatherData_Full): WeatherData_Full {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun WeatherData_FullBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "WEAT")
        fun createWeatherData_Full(builder: FlatBufferBuilder, idOffset: Int, classificationMarkingOffset: Int, idSensorOffset: Int, origSensorIdOffset: Int, obTimeOffset: Int, sigPwrsOffset: Int, noiseLvlsOffset: Int, specWidthsOffset: Int, firstGuessAvgsOffset: Int, qcValue: Int, fileCreationOffset: Int, termAlt: Double, avgTxPwr: Double, avgRefPwr: Double, sectorNum: Int, numElements: Int, tdAvgSampleNumsOffset: Int, checksum: Int, coIntegsOffset: Int, specAvgsOffset: Int, interpulsePeriodsOffset: Int, doppVelsOffset: Int, consRecsOffset: Int, snrsOffset: Int, sigStrength: Double, semiMajorAxis: Double, semiMinorAxis: Double, angleOrientation: Double, lightEventNum: Int, lightDetSensorsOffset: Int, posConfidence: Double, srcTypsOffset: Int, srcIdsOffset: Int, origNetworkOffset: Int, createdAtOffset: Int, createdByOffset: Int, sourceOffset: Int, originOffset: Int, dataMode: Byte) : Int {
            builder.startTable(39)
            addPosConfidence(builder, posConfidence)
            addAngleOrientation(builder, angleOrientation)
            addSemiMinorAxis(builder, semiMinorAxis)
            addSemiMajorAxis(builder, semiMajorAxis)
            addSigStrength(builder, sigStrength)
            addAvgRefPwr(builder, avgRefPwr)
            addAvgTxPwr(builder, avgTxPwr)
            addTermAlt(builder, termAlt)
            addOrigin(builder, originOffset)
            addSource(builder, sourceOffset)
            addCreatedBy(builder, createdByOffset)
            addCreatedAt(builder, createdAtOffset)
            addOrigNetwork(builder, origNetworkOffset)
            addSrcIds(builder, srcIdsOffset)
            addSrcTyps(builder, srcTypsOffset)
            addLightDetSensors(builder, lightDetSensorsOffset)
            addLightEventNum(builder, lightEventNum)
            addSnrs(builder, snrsOffset)
            addConsRecs(builder, consRecsOffset)
            addDoppVels(builder, doppVelsOffset)
            addInterpulsePeriods(builder, interpulsePeriodsOffset)
            addSpecAvgs(builder, specAvgsOffset)
            addCoIntegs(builder, coIntegsOffset)
            addChecksum(builder, checksum)
            addTdAvgSampleNums(builder, tdAvgSampleNumsOffset)
            addNumElements(builder, numElements)
            addSectorNum(builder, sectorNum)
            addFileCreation(builder, fileCreationOffset)
            addQcValue(builder, qcValue)
            addFirstGuessAvgs(builder, firstGuessAvgsOffset)
            addSpecWidths(builder, specWidthsOffset)
            addNoiseLvls(builder, noiseLvlsOffset)
            addSigPwrs(builder, sigPwrsOffset)
            addObTime(builder, obTimeOffset)
            addOrigSensorId(builder, origSensorIdOffset)
            addIdSensor(builder, idSensorOffset)
            addClassificationMarking(builder, classificationMarkingOffset)
            addId(builder, idOffset)
            addDataMode(builder, dataMode)
            return endWeatherData_Full(builder)
        }
        fun startWeatherData_Full(builder: FlatBufferBuilder) = builder.startTable(39)
        fun addId(builder: FlatBufferBuilder, id: Int) = builder.addOffset(0, id, 0)
        fun addClassificationMarking(builder: FlatBufferBuilder, classificationMarking: Int) = builder.addOffset(1, classificationMarking, 0)
        fun addIdSensor(builder: FlatBufferBuilder, idSensor: Int) = builder.addOffset(2, idSensor, 0)
        fun addOrigSensorId(builder: FlatBufferBuilder, origSensorId: Int) = builder.addOffset(3, origSensorId, 0)
        fun addObTime(builder: FlatBufferBuilder, obTime: Int) = builder.addOffset(4, obTime, 0)
        fun addSigPwrs(builder: FlatBufferBuilder, sigPwrs: Int) = builder.addOffset(5, sigPwrs, 0)
        fun createSigPwrsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSigPwrsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addNoiseLvls(builder: FlatBufferBuilder, noiseLvls: Int) = builder.addOffset(6, noiseLvls, 0)
        fun createNoiseLvlsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startNoiseLvlsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSpecWidths(builder: FlatBufferBuilder, specWidths: Int) = builder.addOffset(7, specWidths, 0)
        fun createSpecWidthsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSpecWidthsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addFirstGuessAvgs(builder: FlatBufferBuilder, firstGuessAvgs: Int) = builder.addOffset(8, firstGuessAvgs, 0)
        fun createFirstGuessAvgsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startFirstGuessAvgsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addQcValue(builder: FlatBufferBuilder, qcValue: Int) = builder.addInt(9, qcValue, 0)
        fun addFileCreation(builder: FlatBufferBuilder, fileCreation: Int) = builder.addOffset(10, fileCreation, 0)
        fun addTermAlt(builder: FlatBufferBuilder, termAlt: Double) = builder.addDouble(11, termAlt, 0.0)
        fun addAvgTxPwr(builder: FlatBufferBuilder, avgTxPwr: Double) = builder.addDouble(12, avgTxPwr, 0.0)
        fun addAvgRefPwr(builder: FlatBufferBuilder, avgRefPwr: Double) = builder.addDouble(13, avgRefPwr, 0.0)
        fun addSectorNum(builder: FlatBufferBuilder, sectorNum: Int) = builder.addInt(14, sectorNum, 0)
        fun addNumElements(builder: FlatBufferBuilder, numElements: Int) = builder.addInt(15, numElements, 0)
        fun addTdAvgSampleNums(builder: FlatBufferBuilder, tdAvgSampleNums: Int) = builder.addOffset(16, tdAvgSampleNums, 0)
        fun createTdAvgSampleNumsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTdAvgSampleNumsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addChecksum(builder: FlatBufferBuilder, checksum: Int) = builder.addInt(17, checksum, 0)
        fun addCoIntegs(builder: FlatBufferBuilder, coIntegs: Int) = builder.addOffset(18, coIntegs, 0)
        fun createCoIntegsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startCoIntegsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSpecAvgs(builder: FlatBufferBuilder, specAvgs: Int) = builder.addOffset(19, specAvgs, 0)
        fun createSpecAvgsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSpecAvgsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addInterpulsePeriods(builder: FlatBufferBuilder, interpulsePeriods: Int) = builder.addOffset(20, interpulsePeriods, 0)
        fun createInterpulsePeriodsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startInterpulsePeriodsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addDoppVels(builder: FlatBufferBuilder, doppVels: Int) = builder.addOffset(21, doppVels, 0)
        fun createDoppVelsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startDoppVelsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addConsRecs(builder: FlatBufferBuilder, consRecs: Int) = builder.addOffset(22, consRecs, 0)
        fun createConsRecsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startConsRecsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSnrs(builder: FlatBufferBuilder, snrs: Int) = builder.addOffset(23, snrs, 0)
        fun createSnrsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSnrsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSigStrength(builder: FlatBufferBuilder, sigStrength: Double) = builder.addDouble(24, sigStrength, 0.0)
        fun addSemiMajorAxis(builder: FlatBufferBuilder, semiMajorAxis: Double) = builder.addDouble(25, semiMajorAxis, 0.0)
        fun addSemiMinorAxis(builder: FlatBufferBuilder, semiMinorAxis: Double) = builder.addDouble(26, semiMinorAxis, 0.0)
        fun addAngleOrientation(builder: FlatBufferBuilder, angleOrientation: Double) = builder.addDouble(27, angleOrientation, 0.0)
        fun addLightEventNum(builder: FlatBufferBuilder, lightEventNum: Int) = builder.addInt(28, lightEventNum, 0)
        fun addLightDetSensors(builder: FlatBufferBuilder, lightDetSensors: Int) = builder.addOffset(29, lightDetSensors, 0)
        fun createLightDetSensorsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startLightDetSensorsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addPosConfidence(builder: FlatBufferBuilder, posConfidence: Double) = builder.addDouble(30, posConfidence, 0.0)
        fun addSrcTyps(builder: FlatBufferBuilder, srcTyps: Int) = builder.addOffset(31, srcTyps, 0)
        fun createSrcTypsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSrcTypsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSrcIds(builder: FlatBufferBuilder, srcIds: Int) = builder.addOffset(32, srcIds, 0)
        fun createSrcIdsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSrcIdsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addOrigNetwork(builder: FlatBufferBuilder, origNetwork: Int) = builder.addOffset(33, origNetwork, 0)
        fun addCreatedAt(builder: FlatBufferBuilder, createdAt: Int) = builder.addOffset(34, createdAt, 0)
        fun addCreatedBy(builder: FlatBufferBuilder, createdBy: Int) = builder.addOffset(35, createdBy, 0)
        fun addSource(builder: FlatBufferBuilder, source: Int) = builder.addOffset(36, source, 0)
        fun addOrigin(builder: FlatBufferBuilder, origin: Int) = builder.addOffset(37, origin, 0)
        fun addDataMode(builder: FlatBufferBuilder, dataMode: Byte) = builder.addByte(38, dataMode, 0)
        fun endWeatherData_Full(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishWeatherDataFullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "WEAT")
        fun finishSizePrefixedWeatherData_FullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "WEAT")
    }
}
