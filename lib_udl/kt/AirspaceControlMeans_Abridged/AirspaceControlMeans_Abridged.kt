// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// A conditional nested segment to report multiple airspace control means within a particular airspace control means status.
 */
@Suppress("unused")
class AirspaceControlMeans_Abridged : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : AirspaceControlMeans_Abridged {
        __init(_i, _bb)
        return this
    }
    /**
     * The code for the type of airspace control means.
     * Example: /// Example: ACM:ADAREA
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val cmType : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val cmTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun cmTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Airspace control means name or designator.
     * Example: /// Example: DESIG:C34
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val cmId : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val cmIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun cmIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Designates the geometric type that defines the airspace shape. One of CIRCLE, CORRIDOR, LINE, ORBIT, etc.
     * Example: /// Example: POLYARC
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val cmShape : Byte
        get() {
            val o = __offset(8)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Designates the means by which a defined airspace control means is to be used.
     * Example: /// Example: USE:AIRCOR
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val usage : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val usageAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun usageInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Unique Link 16 identifier assigned to the airspace control means.
     * Example: /// Example: F3356
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val link16Id : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val link16IdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun link16IdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * The altitude at or below which the vertical position of an aircraft is controlled by reference to true altitude.
     * Example: /// Example: 18000FT
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val transAltitude : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val transAltitudeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun transAltitudeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated, if different from the top level ACO datum.
     * Example: /// Example: NAR
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val geoDatumAlt : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val geoDatumAltAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun geoDatumAltInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
     * Example: /// Example: 152345N0505657E
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val coord0 : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val coord0AsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun coord0InByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
     * Example: /// Example: 1523N05057E
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val coord1 : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val coord1AsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun coord1InByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "beginning" radial bearing parameter.
     * Example: /// Example: 330
     * Constraints: No constraints specified.
     */
    val bearing0 : Double
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "ending" radial bearing parameter.
     * Example: /// Example: 160
     * Constraints: No constraints specified.
     */
    val bearing1 : Double
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "inner" radial magnitude arc limit. If provided, the field radMagUnit is required.
     * Example: /// Example: 30.04
     * Constraints: No constraints specified.
     */
    val radMag0 : Double
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "outer" radial magnitude arc limit. If provided, the field radMagUnit is required.
     * Example: /// Example: 50.12
     * Constraints: No constraints specified.
     */
    val radMag1 : Double
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Specifies the unit of length in which radial magnitudes are given. Use M for meters, KM for kilometers, or NM for nautical miles.
     * Example: /// Example: NM
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val radMagUnit : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val radMagUnitAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun radMagUnitInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    /**
     * A set of geospatial coordinates specified in DMS (Degrees, Minutes, Seconds) format which determine the vertices of a one or two dimensional geospatial shape. When shape is set to "POLYARC" or "POLYGON," this field is required as applied in the construction of the area boundary. If cmShape is set to "COORIDOR" or "GEOLINE," this field is required and can be interpreted as an ordered set of points along a path in space.
     * Example: /// Example: ['203632N0594256E', '155000N0594815E', '155000N0591343E']
     * Constraints: No constraints specified.
     */
    fun polyCoord(j: Int) : String? {
        val o = __offset(32)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val polyCoordLength : Int
        get() {
            val o = __offset(32); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Index of a segment in an airtrack, which is defined by an ordered set of points.
     * Example: /// Example: 99
     * Constraints: No constraints specified.
     */
    val trackLeg : Int
        get() {
            val o = __offset(34)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the LEFT half-plane realtive to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the left of the track segment line. If provided, the field widthUnit is required.
     * Example: /// Example: 5.2
     * Constraints: No constraints specified.
     */
    val widthLeft : Double
        get() {
            val o = __offset(36)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the RIGHT half-plane relative to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the right of the track segment line. If provided, the field widthUnit is required.
     * Example: /// Example: 10.4
     * Constraints: No constraints specified.
     */
    val widthRight : Double
        get() {
            val o = __offset(38)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Used to describe the "side to side" distance of a target, object or area. If cmShape is set to "CORRIDOR" or "AORBIT", this field is required and is mapped to the width parameter. If provided, the field widthUnit is required.
     * Example: /// Example: 15.6
     * Constraints: No constraints specified.
     */
    val width : Double
        get() {
            val o = __offset(40)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Specifies the unit of length for which widths are given. Use M for meters, KM for kilometers, or NM for nautical miles.
     * Example: /// Example: KM
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val widthUnit : String?
        get() {
            val o = __offset(42)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val widthUnitAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(42, 1)
    fun widthUnitInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 42, 1)
    /**
     * An array of at least two alphanumeric symbols used to serially identify the corridor waypoints. If cmShape is set to "CORRIDOR," one of either corrWayPoints or polyCoord is required to specify the centerline of the corridor path.
     * Example: /// Example: ['POB', 'RDU', 'IAD']
     * Constraints: No constraints specified.
     */
    fun corrWayPoints(j: Int) : String? {
        val o = __offset(44)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val corrWayPointsLength : Int
        get() {
            val o = __offset(44); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Orbit alignment look-up code. Can be C=Center, L=Left, R=Right.
     * Example: /// Example: C
     * Constraints: Minimum length = 0, Maximum length = 1
     */
    val orbitAlignment : String?
        get() {
            val o = __offset(46)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val orbitAlignmentAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(46, 1)
    fun orbitAlignmentInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 46, 1)
    /**
     * Description of the airspace vertical dimension.
     * Example: /// Example: BRRA:GL-100AGL
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val effVdim : String?
        get() {
            val o = __offset(48)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val effVdimAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(48, 1)
    fun effVdimInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 48, 1)
    /**
     * The timePeriod set describes the effective datetime for a given airspace control means.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    fun airspaceTimePeriod(j: Int) : String? {
        val o = __offset(50)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val airspaceTimePeriodLength : Int
        get() {
            val o = __offset(50); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The controlPoint set describes any reference/controlling/rendevous point for a given airspace control means.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    fun airspaceControlPoint(j: Int) : String? {
        val o = __offset(52)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val airspaceControlPointLength : Int
        get() {
            val o = __offset(52); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The commander responsible within a specified geographical area for the airspace control operation assigned to him.
     * Example: /// Example: RHEIN MAIN CP
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val ctrlAuth : String?
        get() {
            val o = __offset(54)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ctrlAuthAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(54, 1)
    fun ctrlAuthInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 54, 1)
    /**
     * The frequency for the airspace control authority. Can specify HZ, KHZ, MHZ, GHZ or a DESIG frequency designator code.
     * Example: /// Example: ['125.25MHZ']
     * Constraints: No constraints specified.
     */
    fun ctrlAuthFreqs(j: Int) : String? {
        val o = __offset(56)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val ctrlAuthFreqsLength : Int
        get() {
            val o = __offset(56); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Used to provide transit intstructions for the airspace control means.
     * Example: /// Example: SITUATION
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val genTextInd : String?
        get() {
            val o = __offset(58)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val genTextIndAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(58, 1)
    fun genTextIndInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 58, 1)
    /**
     * General informat detailing the transit instruction for the airspace control means.
     * Example: /// Example: 1. CAPACITY: MDM TK, 50 VEHICLE CONVOY. 2. CHOKE POINTS: EXIT 5
     * Constraints: Minimum length = 0, Maximum length = 128
     */
    val freeText : String?
        get() {
            val o = __offset(60)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val freeTextAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(60, 1)
    fun freeTextInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 60, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsAirspaceControlMeans_Abridged(_bb: ByteBuffer): AirspaceControlMeans_Abridged = getRootAsAirspaceControlMeans_Abridged(_bb, AirspaceControlMeans_Abridged())
        fun getRootAsAirspaceControlMeans_Abridged(_bb: ByteBuffer, obj: AirspaceControlMeans_Abridged): AirspaceControlMeans_Abridged {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun AirspaceControlMeans_AbridgedBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "AIRS")
        fun createAirspaceControlMeans_Abridged(builder: FlatBufferBuilder, cmTypeOffset: Int, cmIdOffset: Int, cmShape: Byte, usageOffset: Int, link16IdOffset: Int, transAltitudeOffset: Int, geoDatumAltOffset: Int, coord0Offset: Int, coord1Offset: Int, bearing0: Double, bearing1: Double, radMag0: Double, radMag1: Double, radMagUnitOffset: Int, polyCoordOffset: Int, trackLeg: Int, widthLeft: Double, widthRight: Double, width: Double, widthUnitOffset: Int, corrWayPointsOffset: Int, orbitAlignmentOffset: Int, effVdimOffset: Int, airspaceTimePeriodOffset: Int, airspaceControlPointOffset: Int, ctrlAuthOffset: Int, ctrlAuthFreqsOffset: Int, genTextIndOffset: Int, freeTextOffset: Int) : Int {
            builder.startTable(29)
            addWidth(builder, width)
            addWidthRight(builder, widthRight)
            addWidthLeft(builder, widthLeft)
            addRadMag1(builder, radMag1)
            addRadMag0(builder, radMag0)
            addBearing1(builder, bearing1)
            addBearing0(builder, bearing0)
            addFreeText(builder, freeTextOffset)
            addGenTextInd(builder, genTextIndOffset)
            addCtrlAuthFreqs(builder, ctrlAuthFreqsOffset)
            addCtrlAuth(builder, ctrlAuthOffset)
            addAirspaceControlPoint(builder, airspaceControlPointOffset)
            addAirspaceTimePeriod(builder, airspaceTimePeriodOffset)
            addEffVDim(builder, effVdimOffset)
            addOrbitAlignment(builder, orbitAlignmentOffset)
            addCorrWayPoints(builder, corrWayPointsOffset)
            addWidthUnit(builder, widthUnitOffset)
            addTrackLeg(builder, trackLeg)
            addPolyCoord(builder, polyCoordOffset)
            addRadMagUnit(builder, radMagUnitOffset)
            addCoord1(builder, coord1Offset)
            addCoord0(builder, coord0Offset)
            addGeoDatumAlt(builder, geoDatumAltOffset)
            addTransAltitude(builder, transAltitudeOffset)
            addLink16Id(builder, link16IdOffset)
            addUsage(builder, usageOffset)
            addCmId(builder, cmIdOffset)
            addCmType(builder, cmTypeOffset)
            addCmShape(builder, cmShape)
            return endAirspaceControlMeans_Abridged(builder)
        }
        fun startAirspaceControlMeans_Abridged(builder: FlatBufferBuilder) = builder.startTable(29)
        fun addCmType(builder: FlatBufferBuilder, cmType: Int) = builder.addOffset(0, cmType, 0)
        fun addCmId(builder: FlatBufferBuilder, cmId: Int) = builder.addOffset(1, cmId, 0)
        fun addCmShape(builder: FlatBufferBuilder, cmShape: Byte) = builder.addByte(2, cmShape, 0)
        fun addUsage(builder: FlatBufferBuilder, usage: Int) = builder.addOffset(3, usage, 0)
        fun addLink16Id(builder: FlatBufferBuilder, link16Id: Int) = builder.addOffset(4, link16Id, 0)
        fun addTransAltitude(builder: FlatBufferBuilder, transAltitude: Int) = builder.addOffset(5, transAltitude, 0)
        fun addGeoDatumAlt(builder: FlatBufferBuilder, geoDatumAlt: Int) = builder.addOffset(6, geoDatumAlt, 0)
        fun addCoord0(builder: FlatBufferBuilder, coord0: Int) = builder.addOffset(7, coord0, 0)
        fun addCoord1(builder: FlatBufferBuilder, coord1: Int) = builder.addOffset(8, coord1, 0)
        fun addBearing0(builder: FlatBufferBuilder, bearing0: Double) = builder.addDouble(9, bearing0, 0.0)
        fun addBearing1(builder: FlatBufferBuilder, bearing1: Double) = builder.addDouble(10, bearing1, 0.0)
        fun addRadMag0(builder: FlatBufferBuilder, radMag0: Double) = builder.addDouble(11, radMag0, 0.0)
        fun addRadMag1(builder: FlatBufferBuilder, radMag1: Double) = builder.addDouble(12, radMag1, 0.0)
        fun addRadMagUnit(builder: FlatBufferBuilder, radMagUnit: Int) = builder.addOffset(13, radMagUnit, 0)
        fun addPolyCoord(builder: FlatBufferBuilder, polyCoord: Int) = builder.addOffset(14, polyCoord, 0)
        fun createPolyCoordVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startPolyCoordVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addTrackLeg(builder: FlatBufferBuilder, trackLeg: Int) = builder.addInt(15, trackLeg, 0)
        fun addWidthLeft(builder: FlatBufferBuilder, widthLeft: Double) = builder.addDouble(16, widthLeft, 0.0)
        fun addWidthRight(builder: FlatBufferBuilder, widthRight: Double) = builder.addDouble(17, widthRight, 0.0)
        fun addWidth(builder: FlatBufferBuilder, width: Double) = builder.addDouble(18, width, 0.0)
        fun addWidthUnit(builder: FlatBufferBuilder, widthUnit: Int) = builder.addOffset(19, widthUnit, 0)
        fun addCorrWayPoints(builder: FlatBufferBuilder, corrWayPoints: Int) = builder.addOffset(20, corrWayPoints, 0)
        fun createCorrWayPointsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startCorrWayPointsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addOrbitAlignment(builder: FlatBufferBuilder, orbitAlignment: Int) = builder.addOffset(21, orbitAlignment, 0)
        fun addEffVDim(builder: FlatBufferBuilder, effVdim: Int) = builder.addOffset(22, effVdim, 0)
        fun addAirspaceTimePeriod(builder: FlatBufferBuilder, airspaceTimePeriod: Int) = builder.addOffset(23, airspaceTimePeriod, 0)
        fun createAirspaceTimePeriodVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAirspaceTimePeriodVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addAirspaceControlPoint(builder: FlatBufferBuilder, airspaceControlPoint: Int) = builder.addOffset(24, airspaceControlPoint, 0)
        fun createAirspaceControlPointVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAirspaceControlPointVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addCtrlAuth(builder: FlatBufferBuilder, ctrlAuth: Int) = builder.addOffset(25, ctrlAuth, 0)
        fun addCtrlAuthFreqs(builder: FlatBufferBuilder, ctrlAuthFreqs: Int) = builder.addOffset(26, ctrlAuthFreqs, 0)
        fun createCtrlAuthFreqsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startCtrlAuthFreqsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addGenTextInd(builder: FlatBufferBuilder, genTextInd: Int) = builder.addOffset(27, genTextInd, 0)
        fun addFreeText(builder: FlatBufferBuilder, freeText: Int) = builder.addOffset(28, freeText, 0)
        fun endAirspaceControlMeans_Abridged(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishAirspaceControlMeansAbridgedBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "AIRS")
        fun finishSizePrefixedAirspaceControlMeans_AbridgedBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "AIRS")
    }
}
