// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Discover' tab in the storefront to confirm coordinate frames by data provider.
 */
@Suppress("unused")
class StateVector_Full : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : StateVector_Full {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record, auto-generated by the system.
     * Example: /// Example: STATEVECTOR-ID
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val idStateVector : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idStateVectorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun idStateVectorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     * Example: /// Example: U
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val classificationMarking : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val classificationMarkingAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun classificationMarkingInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Time of validity for state vector in ISO 8601 UTC datetime format, with microsecond precision.
     * Example: /// Example: 2018-01-01T16:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val epoch : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val epochAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun epochInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * The pedigree of state vector, or methods used for its generation to include state update/orbit determination, propagation from another state, or a state from a calibration satellite (e.g. ORBIT_UPDATE, PROPAGATION, CALIBRATION, CONJUNCTION, FLIGHT_PLAN).
     * Example: /// Example: CONJUNCTION
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val pedigree : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val pedigreeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun pedigreeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
     * Example: /// Example: ONORBIT-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idOnOrbit : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idOnOrbitAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun idOnOrbitInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Satellite/Catalog number of the target OnOrbit object.
     * Example: /// Example: 12
     * Constraints: No constraints specified.
     */
    val satNo : Int
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Optional identifier provided by state vector source to indicate the target onorbit object of this state vector. This may be an internal identifier and not necessarily map to a valid satellite number.
     * Example: /// Example: ORIGOBJECT-ID
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origObjectId : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origObjectIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun origObjectIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * Unique identifier of the OD solution record that produced this state vector. This ID can be used to obtain additional information on an OrbitDetermination object using the 'get by ID' operation (e.g. /udl/orbitdetermination/{id}). For example, the OrbitDetermination with idOrbitDetermination = abc would be queries as /udl/orbitdetermination/abc.
     * Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idOrbitDetermination : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idOrbitDeterminationAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun idOrbitDeterminationInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * Boolean indicating this state vector was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
     * Example: /// Example: True
     * Constraints: No constraints specified.
     */
    val uct : Boolean
        get() {
            val o = __offset(20)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Cartesian X position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
     * Example: /// Example: -1118.577381
     * Constraints: No constraints specified.
     */
    val xpos : Double
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Y position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
     * Example: /// Example: 3026.231084
     * Constraints: No constraints specified.
     */
    val ypos : Double
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Z position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
     * Example: /// Example: 6167.831808
     * Constraints: No constraints specified.
     */
    val zpos : Double
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian X velocity of target, in kilometers/second, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
     * Example: /// Example: -4.25242784
     * Constraints: No constraints specified.
     */
    val xvel : Double
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Y velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
     * Example: /// Example: 5.291107434
     * Constraints: No constraints specified.
     */
    val yvel : Double
        get() {
            val o = __offset(30)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Z velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
     * Example: /// Example: -3.356493869
     * Constraints: No constraints specified.
     */
    val zvel : Double
        get() {
            val o = __offset(32)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
     * Example: /// Example: J2000
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val referenceFrame : Byte
        get() {
            val o = __offset(34)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.  If the covReferenceFrame is null it is assumed to be J2000.
     * The array values (1-21) represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR&nbsp;&nbsp;
     * x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
     * y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3
     * z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6
     * x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;10
     * y'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
     * z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;
     * The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
     * If additional covariance terms are included for DRAG, SRP, and/or THRUST, the matrix can be extended with the following order of elements:
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR
     * DRG&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;23&nbsp;&nbsp;24&nbsp;&nbsp;25&nbsp;&nbsp;26&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;
     * SRP&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;30&nbsp;&nbsp;31&nbsp;&nbsp;32&nbsp;&nbsp;33&nbsp;&nbsp;&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;
     * THR&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;38&nbsp;&nbsp;39&nbsp;&nbsp;40&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45&nbsp;
     * Example: /// Example: [1.1, 2.2]
     * Constraints: No constraints specified.
     */
    fun cov(j: Int) : String? {
        val o = __offset(36)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val covLength : Int
        get() {
            val o = __offset(36); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
     * Example: /// Example: J2000
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val covReferenceFrame : Byte
        get() {
            val o = __offset(38)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * The method used to generate the covariance during the orbit determination (OD) that produced the state vector, or whether an arbitrary, non-calculated default value was used (CALCULATED, DEFAULT).
     * Example: /// Example: CALCULATED
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val covMethod : String?
        get() {
            val o = __offset(40)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val covMethodAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(40, 1)
    fun covMethodInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 40, 1)
    /**
     * The covariance matrix values represent the lower triangular half of the covariance matrix in terms of equinoctial elements.&nbsp; The size of the covariance matrix is dynamic.&nbsp; The values are outputted in order across each row, i.e.:
     * 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5
     * 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp; 10
     * :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
     * :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
     * 51&nbsp; 52&nbsp; 53&nbsp; 54&nbsp; 55
     * :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
     * :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
     * The ordering of values is as follows:
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Af&nbsp;&nbsp; Ag&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp; N&nbsp;&nbsp; Chi&nbsp; Psi&nbsp;&nbsp; B&nbsp;&nbsp; BDOT AGOM&nbsp; T&nbsp;&nbsp; C1&nbsp;&nbsp; C2&nbsp; ...
     * Af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
     * Ag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3
     * L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 6
     * N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 10
     * Chi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; 12&nbsp;&nbsp; 13&nbsp;&nbsp; 14&nbsp;&nbsp; 15
     * Psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 17&nbsp;&nbsp; 18&nbsp;&nbsp; 19&nbsp;&nbsp; 20&nbsp;&nbsp; 21
     * B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 23&nbsp;&nbsp; 24 &nbsp;&nbsp;25&nbsp;&nbsp; 26&nbsp;&nbsp; 27&nbsp;&nbsp; 28
     * BDOT&nbsp;&nbsp; 29&nbsp;&nbsp; 30&nbsp;&nbsp; 31&nbsp;&nbsp; 32&nbsp;&nbsp; 33&nbsp;&nbsp; 34&nbsp;&nbsp; 35&nbsp;&nbsp; 36
     * AGOM&nbsp; 37&nbsp;&nbsp; 38&nbsp;&nbsp; 39&nbsp;&nbsp; 40&nbsp;&nbsp; 41&nbsp;&nbsp; 42&nbsp;&nbsp; 43&nbsp;&nbsp; 44&nbsp;&nbsp; 45
     * T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;&nbsp; 47&nbsp;&nbsp; 48&nbsp;&nbsp; 49&nbsp;&nbsp; 50&nbsp;&nbsp; 51&nbsp;&nbsp; 52&nbsp;&nbsp; 53&nbsp;&nbsp; 54&nbsp;&nbsp; 55
     * C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 56&nbsp;&nbsp; 57&nbsp;&nbsp; 58&nbsp;&nbsp; 59&nbsp;&nbsp; 60&nbsp;&nbsp; 61&nbsp;&nbsp; 62&nbsp;&nbsp; 63&nbsp;&nbsp; 64&nbsp;&nbsp; 65&nbsp;&nbsp; 66
     * C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67&nbsp;&nbsp; 68&nbsp;&nbsp; 69&nbsp;&nbsp; 70&nbsp;&nbsp; 71&nbsp; &nbsp;72&nbsp;&nbsp; 73&nbsp;&nbsp; 74&nbsp;&nbsp; 75&nbsp;&nbsp; 76&nbsp;&nbsp; 77&nbsp;&nbsp; 78
     * :
     * :
     * where C1, C2, etc, are the "consider parameters" that may be added to the covariance matrix.&nbsp; The covariance matrix will be as large as the last element/model parameter needed.&nbsp; In other words, if the DC solved for all 6 elements plus AGOM, the covariance matrix will be 9x9 (and the rows for B and BDOT will be all zeros).&nbsp; If the covariance matrix is unavailable, the size will be set to 0x0, and no data will follow.&nbsp; The cov field should contain only the lower left triangle values from top left down to bottom right, in order.
     * Example: /// Example: [1.1, 2.2]
     * Constraints: No constraints specified.
     */
    fun eqCov(j: Int) : String? {
        val o = __offset(42)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val eqCovLength : Int
        get() {
            val o = __offset(42); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Cartesian X position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: -1145.688502
     * Constraints: No constraints specified.
     */
    val xposAlt1 : Double
        get() {
            val o = __offset(44)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Y position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: 3020.729572
     * Constraints: No constraints specified.
     */
    val yposAlt1 : Double
        get() {
            val o = __offset(46)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Z position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: 6165.55187
     * Constraints: No constraints specified.
     */
    val zposAlt1 : Double
        get() {
            val o = __offset(48)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian X velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: -4.270832252
     * Constraints: No constraints specified.
     */
    val xvelAlt1 : Double
        get() {
            val o = __offset(50)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Y velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: 5.27074276
     * Constraints: No constraints specified.
     */
    val yvelAlt1 : Double
        get() {
            val o = __offset(52)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Z velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: -3.365155181
     * Constraints: No constraints specified.
     */
    val zvelAlt1 : Double
        get() {
            val o = __offset(54)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The reference frame of the alternate1 (Alt1) cartesian orbital state.
     * Example: /// Example: TEME
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val alt1ReferenceFrame : String?
        get() {
            val o = __offset(56)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val alt1ReferenceFrameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(56, 1)
    fun alt1ReferenceFrameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 56, 1)
    /**
     * Cartesian X position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: -1456.915926
     * Constraints: No constraints specified.
     */
    val xposAlt2 : Double
        get() {
            val o = __offset(58)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Y position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: -2883.540406
     * Constraints: No constraints specified.
     */
    val yposAlt2 : Double
        get() {
            val o = __offset(60)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Z position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: 6165.55187
     * Constraints: No constraints specified.
     */
    val zposAlt2 : Double
        get() {
            val o = __offset(62)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian X velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: -1.219814294
     * Constraints: No constraints specified.
     */
    val xvelAlt2 : Double
        get() {
            val o = __offset(64)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Y velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: -6.602080212
     * Constraints: No constraints specified.
     */
    val yvelAlt2 : Double
        get() {
            val o = __offset(66)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Cartesian Z velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
     * Example: /// Example: -3.365155181
     * Constraints: No constraints specified.
     */
    val zvelAlt2 : Double
        get() {
            val o = __offset(68)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The reference frame of the alternate2 (Alt2) cartesian orbital state.
     * Example: /// Example: EFG/TDR
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val alt2ReferenceFrame : String?
        get() {
            val o = __offset(70)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val alt2ReferenceFrameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(70, 1)
    fun alt2ReferenceFrameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 70, 1)
    /**
     * One sigma position uncertainty, in kilometers.
     * Example: /// Example: 0.333399744452
     * Constraints: No constraints specified.
     */
    val posUnc : Double
        get() {
            val o = __offset(72)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * One sigma velocity uncertainty, in kilometers/second.
     * Example: /// Example: 4e-06
     * Constraints: No constraints specified.
     */
    val velUnc : Double
        get() {
            val o = __offset(74)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The mass of the object, in kilograms.
     * Example: /// Example: 164.5
     * Constraints: No constraints specified.
     */
    val mass : Double
        get() {
            val o = __offset(76)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The actual area of the object at it's largest cross-section, expressed in meters^2.
     * Example: /// Example: 5.065
     * Constraints: No constraints specified.
     */
    val area : Double
        get() {
            val o = __offset(78)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Area-to-mass ratio coefficient for solar radiation pressure.
     * Example: /// Example: 0.0244394
     * Constraints: No constraints specified.
     */
    val solarRadPressCoeff : Double
        get() {
            val o = __offset(80)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Area-to-mass ratio coefficient for atmospheric ballistic drag (m2/kg).
     * Example: /// Example: 0.0224391269775
     * Constraints: No constraints specified.
     */
    val dragCoeff : Double
        get() {
            val o = __offset(82)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The effective area of the object exposed to atmospheric drag, expressed in meters^2.
     * Example: /// Example: 4.739
     * Constraints: No constraints specified.
     */
    val dragArea : Double
        get() {
            val o = __offset(84)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Epoch revolution number.
     * Example: /// Example: 7205
     * Constraints: No constraints specified.
     */
    val revNo : Int
        get() {
            val o = __offset(86)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Geopotential model used for this vector (e.g. EGM-96, WGS-84, WGS-72, JGM-2, or GEM-T3), including mm degree zonals, nn degree/order tesserals. E.g. EGM-96 24Z,24T.
     * Example: /// Example: EGM-96
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val geopotentialModel : String?
        get() {
            val o = __offset(88)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val geopotentialModelAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(88, 1)
    fun geopotentialModelInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 88, 1)
    /**
     * The Drag Model used for this vector (e.g. HARRIS-PRIESTER, JAC70, JBH09, MSIS90, NONE, etc.).
     * Example: /// Example: JAC70
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val dragModel : String?
        get() {
            val o = __offset(90)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val dragModelAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(90, 1)
    fun dragModelInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 90, 1)
    /**
     * Boolean indicating use of lunar/solar perturbations for this vector.
     * Example: /// Example: True
     * Constraints: No constraints specified.
     */
    val lunarSolar : Boolean
        get() {
            val o = __offset(92)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Boolean indicating use of solar radiation pressure perturbations for this vector.
     * Example: /// Example: True
     * Constraints: No constraints specified.
     */
    val solarRadPress : Boolean
        get() {
            val o = __offset(94)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * The effective area of the object exposed to solar radiation pressure, expressed in meters^2.
     * Example: /// Example: 4.311
     * Constraints: No constraints specified.
     */
    val srpArea : Double
        get() {
            val o = __offset(96)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Boolean indicating use of solid earth tide perturbations for this vector.
     * Example: /// Example: True
     * Constraints: No constraints specified.
     */
    val solidEarthTides : Boolean
        get() {
            val o = __offset(98)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Boolean indicating use of in-track thrust perturbations for this vector.
     * Example: /// Example: True
     * Constraints: No constraints specified.
     */
    val inTrackThrust : Boolean
        get() {
            val o = __offset(100)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * First derivative of drag/ballistic coefficient (m2/kg-s).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val bDot : Double
        get() {
            val o = __offset(102)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Model parameter value for energy dissipation rate (EDR) (w/kg).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val edr : Double
        get() {
            val o = __offset(104)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Model parameter value for thrust acceleration (m/s2).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val thrustAccel : Double
        get() {
            val o = __offset(106)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Model parameter value for center of mass offset (m).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val cmOffset : Double
        get() {
            val o = __offset(108)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The start of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
     * Example: /// Example: 2022-11-09T11:20:21.247192Z
     * Constraints: No constraints specified.
     */
    val lastObStart : String?
        get() {
            val o = __offset(110)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val lastObStartAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(110, 1)
    fun lastObStartInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 110, 1)
    /**
     * The end of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
     * Example: /// Example: 2022-11-09T11:20:21.247192Z
     * Constraints: No constraints specified.
     */
    val lastObEnd : String?
        get() {
            val o = __offset(112)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val lastObEndAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(112, 1)
    fun lastObEndInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 112, 1)
    /**
     * The number of observations available for the OD of the object.
     * Example: /// Example: 376
     * Constraints: No constraints specified.
     */
    val obsAvailable : Int
        get() {
            val o = __offset(114)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The number of observations accepted for the OD of the object.
     * Example: /// Example: 374
     * Constraints: No constraints specified.
     */
    val obsUsed : Int
        get() {
            val o = __offset(116)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The number of sensor tracks available for the OD of the object.
     * Example: /// Example: 163
     * Constraints: No constraints specified.
     */
    val tracksAvail : Int
        get() {
            val o = __offset(118)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The number of sensor tracks accepted for the OD of the object.
     * Example: /// Example: 163
     * Constraints: No constraints specified.
     */
    val tracksUsed : Int
        get() {
            val o = __offset(120)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The recommended OD time span calculated for the object, expressed in days.
     * Example: /// Example: 3.5
     * Constraints: No constraints specified.
     */
    val recOdspan : Double
        get() {
            val o = __offset(122)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The actual time span used for the OD of the object, expressed in days.
     * Example: /// Example: 3.5
     * Constraints: No constraints specified.
     */
    val actualOdspan : Double
        get() {
            val o = __offset(124)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The percentage of residuals accepted in the OD of the object.
     * Example: /// Example: 99.5
     * Constraints: No constraints specified.
     */
    val residualsAcc : Double
        get() {
            val o = __offset(126)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * F10 (10.7 cm) solar flux value.
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val solarFluxF10 : Double
        get() {
            val o = __offset(128)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * F10 (10.7 cm) solar flux 81-day average value.
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val solarFluxF10Avg : Double
        get() {
            val o = __offset(130)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Average solar flux geomagnetic index.
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val solarFluxApavg : Double
        get() {
            val o = __offset(132)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * TAI (Temps Atomique International) minus UTC (Universal Time Coordinates) offset in seconds.
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val taiUtc : Double
        get() {
            val o = __offset(134)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Universal Time-1 (UT1) minus UTC offset, in seconds.
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val ut1Utc : Double
        get() {
            val o = __offset(136)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Rate of change of UT1 (milliseconds/day) - first derivative of ut1Utc.
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val ut1Rate : Double
        get() {
            val o = __offset(138)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Polar Wander Motion X (arc seconds).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val polarMotionX : Double
        get() {
            val o = __offset(140)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Polar Wander Motion Y (arc seconds).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val polarMotionY : Double
        get() {
            val o = __offset(142)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Number of terms used in the IAU 1980 nutation model (4, 50, or 106).
     * Example: /// Example: 4
     * Constraints: No constraints specified.
     */
    val iau1980Terms : Int
        get() {
            val o = __offset(144)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Time of the next leap second after epoch in ISO 8601 UTC time. If the next leap second is not known, the time of the previous leap second is used.
     * Example: /// Example: 2021-01-01T01:01:01.123Z
     * Constraints: No constraints specified.
     */
    val leapSecondTime : String?
        get() {
            val o = __offset(146)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val leapSecondTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(146, 1)
    fun leapSecondTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 146, 1)
    /**
     * Integrator Mode.
     * Example: /// Example: integratorMode
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val integratorMode : String?
        get() {
            val o = __offset(148)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val integratorModeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(148, 1)
    fun integratorModeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 148, 1)
    /**
     * Type of partial derivatives used (ANALYTIC, FULL NUM, or FAST NUM).
     * Example: /// Example: ANALYTIC
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val partials : String?
        get() {
            val o = __offset(150)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val partialsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(150, 1)
    fun partialsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 150, 1)
    /**
     * Integrator step mode (AUTO, TIME, or S).
     * Example: /// Example: AUTO
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val stepMode : String?
        get() {
            val o = __offset(152)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val stepModeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(152, 1)
    fun stepModeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 152, 1)
    /**
     * Boolean indicating use of fixed step size for this vector.
     * Example: /// Example: True
     * Constraints: No constraints specified.
     */
    val fixedStep : Boolean
        get() {
            val o = __offset(154)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Initial step size selection (AUTO or MANUAL).
     * Example: /// Example: AUTO
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val stepSizeSelection : String?
        get() {
            val o = __offset(156)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val stepSizeSelectionAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(156, 1)
    fun stepSizeSelectionInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 156, 1)
    /**
     * Initial integration step size (seconds).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val stepSize : Double
        get() {
            val o = __offset(158)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Integrator error control.
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val errorControl : Double
        get() {
            val o = __offset(160)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Array containing the standard deviation of error in target object position, U, V and W direction respectively (km).
     * Example: /// Example: [1.23, 4.56]
     * Constraints: No constraints specified.
     */
    fun sigmaPosUvw(j: Int) : String? {
        val o = __offset(162)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val sigmaPosUvwLength : Int
        get() {
            val o = __offset(162); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array containing the standard deviation of error in target object velocity, U, V and W direction respectively (km/sec).
     * Example: /// Example: [1.23, 4.56]
     * Constraints: No constraints specified.
     */
    fun sigmaVelUvw(j: Int) : String? {
        val o = __offset(164)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val sigmaVelUvwLength : Int
        get() {
            val o = __offset(164); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The Weighted Root Mean Squared (RMS) of the differential correction on the target object that produced this vector.  WRMS is a quality indicator of the state vector update, with a value of 1.00 being optimal.  WRMS applies to Batch Least Squares (BLS) processes.
     * Example: /// Example: 0.991
     * Constraints: No constraints specified.
     */
    val rms : Double
        get() {
            val o = __offset(166)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Start time at which this state vector was the 'current' state vector for its satellite.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val effectiveFrom : String?
        get() {
            val o = __offset(168)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val effectiveFromAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(168, 1)
    fun effectiveFromInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 168, 1)
    /**
     * End time at which this state vector was no longer the 'current' state vector for its satellite.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val effectiveUntil : String?
        get() {
            val o = __offset(170)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val effectiveUntilAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(170, 1)
    fun effectiveUntilInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 170, 1)
    /**
     * Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
     * Example: /// Example: rawFileURI
     * Constraints: Minimum length = 0, Maximum length = 256
     */
    val rawFileUri : String?
        get() {
            val o = __offset(172)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val rawFileUriAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(172, 1)
    fun rawFileUriInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 172, 1)
    /**
     * Source of the data.
     * Example: /// Example: Bluestaq
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val source : String?
        get() {
            val o = __offset(174)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(174, 1)
    fun sourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 174, 1)
    /**
     * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     * Example: /// Example: THIRD_PARTY_DATASOURCE
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origin : String?
        get() {
            val o = __offset(176)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val originAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(176, 1)
    fun originInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 176, 1)
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
     * Example: /// Example: TEST
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val dataMode : Byte
        get() {
            val o = __offset(178)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
     * Example: /// Example: ['TAG1', 'TAG2']
     * Constraints: No constraints specified.
     */
    fun tags(j: Int) : String? {
        val o = __offset(180)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val tagsLength : Int
        get() {
            val o = __offset(180); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Optional algorithm used to produce this record.
     * Example: /// Example: SAMPLE_ALGORITHM
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val algorithm : String?
        get() {
            val o = __offset(182)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val algorithmAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(182, 1)
    fun algorithmInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 182, 1)
    /**
     * Optional array of UDL data (observation) UUIDs used to build this state vector. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
     * Example: /// Example: ['DATA1', 'DATA2']
     * Constraints: No constraints specified.
     */
    fun sourcedData(j: Int) : String? {
        val o = __offset(184)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val sourcedDataLength : Int
        get() {
            val o = __offset(184); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Optional array of UDL observation data types used to build this state vector (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
     * Example: /// Example: ['RADAR']
     * Constraints: No constraints specified.
     */
    val sourcedDataTypes : Byte
        get() {
            val o = __offset(186)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Time the row was created in the database, auto-populated by the system.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val createdAt : String?
        get() {
            val o = __offset(188)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdAtAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(188, 1)
    fun createdAtInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 188, 1)
    /**
     * Application user who created the row in the database, auto-populated by the system.
     * Example: /// Example: some.user
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val createdBy : String?
        get() {
            val o = __offset(190)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdByAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(190, 1)
    fun createdByInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 190, 1)
    /**
     * No description provided.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    val onOrbit : String?
        get() {
            val o = __offset(192)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val onOrbitAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(192, 1)
    fun onOrbitInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 192, 1)
    /**
     * Optional source-provided and searchable metadata or descriptor of the data.
     * Example: /// Example: descriptor
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val descriptor : String?
        get() {
            val o = __offset(194)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val descriptorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(194, 1)
    fun descriptorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 194, 1)
    /**
     * Optional identifier to track a commercial or marketplace transaction executed to produce this data.
     * Example: /// Example: transactionId
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val transactionId : String?
        get() {
            val o = __offset(196)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val transactionIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(196, 1)
    fun transactionIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 196, 1)
    /**
     * The originating source network on which this record was created, auto-populated by the system.
     * Example: /// Example: ORIG
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val origNetwork : String?
        get() {
            val o = __offset(198)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origNetworkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(198, 1)
    fun origNetworkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 198, 1)
    /**
     * The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
     * Example: /// Example: AXE
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val sourceDl : String?
        get() {
            val o = __offset(200)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceDlAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(200, 1)
    fun sourceDlInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 200, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsStateVector_Full(_bb: ByteBuffer): StateVector_Full = getRootAsStateVector_Full(_bb, StateVector_Full())
        fun getRootAsStateVector_Full(_bb: ByteBuffer, obj: StateVector_Full): StateVector_Full {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun StateVector_FullBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "STAT")
        fun createStateVector_Full(builder: FlatBufferBuilder, idStateVectorOffset: Int, classificationMarkingOffset: Int, epochOffset: Int, pedigreeOffset: Int, idOnOrbitOffset: Int, satNo: Int, origObjectIdOffset: Int, idOrbitDeterminationOffset: Int, uct: Boolean, xpos: Double, ypos: Double, zpos: Double, xvel: Double, yvel: Double, zvel: Double, referenceFrame: Byte, covOffset: Int, covReferenceFrame: Byte, covMethodOffset: Int, eqCovOffset: Int, xposAlt1: Double, yposAlt1: Double, zposAlt1: Double, xvelAlt1: Double, yvelAlt1: Double, zvelAlt1: Double, alt1ReferenceFrameOffset: Int, xposAlt2: Double, yposAlt2: Double, zposAlt2: Double, xvelAlt2: Double, yvelAlt2: Double, zvelAlt2: Double, alt2ReferenceFrameOffset: Int, posUnc: Double, velUnc: Double, mass: Double, area: Double, solarRadPressCoeff: Double, dragCoeff: Double, dragArea: Double, revNo: Int, geopotentialModelOffset: Int, dragModelOffset: Int, lunarSolar: Boolean, solarRadPress: Boolean, srpArea: Double, solidEarthTides: Boolean, inTrackThrust: Boolean, bDot: Double, edr: Double, thrustAccel: Double, cmOffset: Double, lastObStartOffset: Int, lastObEndOffset: Int, obsAvailable: Int, obsUsed: Int, tracksAvail: Int, tracksUsed: Int, recOdspan: Double, actualOdspan: Double, residualsAcc: Double, solarFluxF10: Double, solarFluxF10Avg: Double, solarFluxApavg: Double, taiUtc: Double, ut1Utc: Double, ut1Rate: Double, polarMotionX: Double, polarMotionY: Double, iau1980Terms: Int, leapSecondTimeOffset: Int, integratorModeOffset: Int, partialsOffset: Int, stepModeOffset: Int, fixedStep: Boolean, stepSizeSelectionOffset: Int, stepSize: Double, errorControl: Double, sigmaPosUvwOffset: Int, sigmaVelUvwOffset: Int, rms: Double, effectiveFromOffset: Int, effectiveUntilOffset: Int, rawFileUriOffset: Int, sourceOffset: Int, originOffset: Int, dataMode: Byte, tagsOffset: Int, algorithmOffset: Int, sourcedDataOffset: Int, sourcedDataTypes: Byte, createdAtOffset: Int, createdByOffset: Int, onOrbitOffset: Int, descriptorOffset: Int, transactionIdOffset: Int, origNetworkOffset: Int, sourceDlOffset: Int) : Int {
            builder.startTable(99)
            addRms(builder, rms)
            addErrorControl(builder, errorControl)
            addStepSize(builder, stepSize)
            addPolarMotionY(builder, polarMotionY)
            addPolarMotionX(builder, polarMotionX)
            addUt1Rate(builder, ut1Rate)
            addUt1Utc(builder, ut1Utc)
            addTaiUtc(builder, taiUtc)
            addSolarFluxAPAvg(builder, solarFluxApavg)
            addSolarFluxF10Avg(builder, solarFluxF10Avg)
            addSolarFluxF10(builder, solarFluxF10)
            addResidualsAcc(builder, residualsAcc)
            addActualODSpan(builder, actualOdspan)
            addRecODSpan(builder, recOdspan)
            addCmOffset(builder, cmOffset)
            addThrustAccel(builder, thrustAccel)
            addEdr(builder, edr)
            addBDot(builder, bDot)
            addSrpArea(builder, srpArea)
            addDragArea(builder, dragArea)
            addDragCoeff(builder, dragCoeff)
            addSolarRadPressCoeff(builder, solarRadPressCoeff)
            addArea(builder, area)
            addMass(builder, mass)
            addVelUnc(builder, velUnc)
            addPosUnc(builder, posUnc)
            addZvelAlt2(builder, zvelAlt2)
            addYvelAlt2(builder, yvelAlt2)
            addXvelAlt2(builder, xvelAlt2)
            addZposAlt2(builder, zposAlt2)
            addYposAlt2(builder, yposAlt2)
            addXposAlt2(builder, xposAlt2)
            addZvelAlt1(builder, zvelAlt1)
            addYvelAlt1(builder, yvelAlt1)
            addXvelAlt1(builder, xvelAlt1)
            addZposAlt1(builder, zposAlt1)
            addYposAlt1(builder, yposAlt1)
            addXposAlt1(builder, xposAlt1)
            addZvel(builder, zvel)
            addYvel(builder, yvel)
            addXvel(builder, xvel)
            addZpos(builder, zpos)
            addYpos(builder, ypos)
            addXpos(builder, xpos)
            addSourceDL(builder, sourceDlOffset)
            addOrigNetwork(builder, origNetworkOffset)
            addTransactionId(builder, transactionIdOffset)
            addDescriptor(builder, descriptorOffset)
            addOnOrbit(builder, onOrbitOffset)
            addCreatedBy(builder, createdByOffset)
            addCreatedAt(builder, createdAtOffset)
            addSourcedData(builder, sourcedDataOffset)
            addAlgorithm(builder, algorithmOffset)
            addTags(builder, tagsOffset)
            addOrigin(builder, originOffset)
            addSource(builder, sourceOffset)
            addRawFileURI(builder, rawFileUriOffset)
            addEffectiveUntil(builder, effectiveUntilOffset)
            addEffectiveFrom(builder, effectiveFromOffset)
            addSigmaVelUVW(builder, sigmaVelUvwOffset)
            addSigmaPosUVW(builder, sigmaPosUvwOffset)
            addStepSizeSelection(builder, stepSizeSelectionOffset)
            addStepMode(builder, stepModeOffset)
            addPartials(builder, partialsOffset)
            addIntegratorMode(builder, integratorModeOffset)
            addLeapSecondTime(builder, leapSecondTimeOffset)
            addIau1980Terms(builder, iau1980Terms)
            addTracksUsed(builder, tracksUsed)
            addTracksAvail(builder, tracksAvail)
            addObsUsed(builder, obsUsed)
            addObsAvailable(builder, obsAvailable)
            addLastObEnd(builder, lastObEndOffset)
            addLastObStart(builder, lastObStartOffset)
            addDragModel(builder, dragModelOffset)
            addGeopotentialModel(builder, geopotentialModelOffset)
            addRevNo(builder, revNo)
            addAlt2ReferenceFrame(builder, alt2ReferenceFrameOffset)
            addAlt1ReferenceFrame(builder, alt1ReferenceFrameOffset)
            addEqCov(builder, eqCovOffset)
            addCovMethod(builder, covMethodOffset)
            addCov(builder, covOffset)
            addIdOrbitDetermination(builder, idOrbitDeterminationOffset)
            addOrigObjectId(builder, origObjectIdOffset)
            addSatNo(builder, satNo)
            addIdOnOrbit(builder, idOnOrbitOffset)
            addPedigree(builder, pedigreeOffset)
            addEpoch(builder, epochOffset)
            addClassificationMarking(builder, classificationMarkingOffset)
            addIdStateVector(builder, idStateVectorOffset)
            addSourcedDataTypes(builder, sourcedDataTypes)
            addDataMode(builder, dataMode)
            addFixedStep(builder, fixedStep)
            addInTrackThrust(builder, inTrackThrust)
            addSolidEarthTides(builder, solidEarthTides)
            addSolarRadPress(builder, solarRadPress)
            addLunarSolar(builder, lunarSolar)
            addCovReferenceFrame(builder, covReferenceFrame)
            addReferenceFrame(builder, referenceFrame)
            addUct(builder, uct)
            return endStateVector_Full(builder)
        }
        fun startStateVector_Full(builder: FlatBufferBuilder) = builder.startTable(99)
        fun addIdStateVector(builder: FlatBufferBuilder, idStateVector: Int) = builder.addOffset(0, idStateVector, 0)
        fun addClassificationMarking(builder: FlatBufferBuilder, classificationMarking: Int) = builder.addOffset(1, classificationMarking, 0)
        fun addEpoch(builder: FlatBufferBuilder, epoch: Int) = builder.addOffset(2, epoch, 0)
        fun addPedigree(builder: FlatBufferBuilder, pedigree: Int) = builder.addOffset(3, pedigree, 0)
        fun addIdOnOrbit(builder: FlatBufferBuilder, idOnOrbit: Int) = builder.addOffset(4, idOnOrbit, 0)
        fun addSatNo(builder: FlatBufferBuilder, satNo: Int) = builder.addInt(5, satNo, 0)
        fun addOrigObjectId(builder: FlatBufferBuilder, origObjectId: Int) = builder.addOffset(6, origObjectId, 0)
        fun addIdOrbitDetermination(builder: FlatBufferBuilder, idOrbitDetermination: Int) = builder.addOffset(7, idOrbitDetermination, 0)
        fun addUct(builder: FlatBufferBuilder, uct: Boolean) = builder.addBoolean(8, uct, false)
        fun addXpos(builder: FlatBufferBuilder, xpos: Double) = builder.addDouble(9, xpos, 0.0)
        fun addYpos(builder: FlatBufferBuilder, ypos: Double) = builder.addDouble(10, ypos, 0.0)
        fun addZpos(builder: FlatBufferBuilder, zpos: Double) = builder.addDouble(11, zpos, 0.0)
        fun addXvel(builder: FlatBufferBuilder, xvel: Double) = builder.addDouble(12, xvel, 0.0)
        fun addYvel(builder: FlatBufferBuilder, yvel: Double) = builder.addDouble(13, yvel, 0.0)
        fun addZvel(builder: FlatBufferBuilder, zvel: Double) = builder.addDouble(14, zvel, 0.0)
        fun addReferenceFrame(builder: FlatBufferBuilder, referenceFrame: Byte) = builder.addByte(15, referenceFrame, 0)
        fun addCov(builder: FlatBufferBuilder, cov: Int) = builder.addOffset(16, cov, 0)
        fun createCovVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startCovVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addCovReferenceFrame(builder: FlatBufferBuilder, covReferenceFrame: Byte) = builder.addByte(17, covReferenceFrame, 0)
        fun addCovMethod(builder: FlatBufferBuilder, covMethod: Int) = builder.addOffset(18, covMethod, 0)
        fun addEqCov(builder: FlatBufferBuilder, eqCov: Int) = builder.addOffset(19, eqCov, 0)
        fun createEqCovVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startEqCovVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addXposAlt1(builder: FlatBufferBuilder, xposAlt1: Double) = builder.addDouble(20, xposAlt1, 0.0)
        fun addYposAlt1(builder: FlatBufferBuilder, yposAlt1: Double) = builder.addDouble(21, yposAlt1, 0.0)
        fun addZposAlt1(builder: FlatBufferBuilder, zposAlt1: Double) = builder.addDouble(22, zposAlt1, 0.0)
        fun addXvelAlt1(builder: FlatBufferBuilder, xvelAlt1: Double) = builder.addDouble(23, xvelAlt1, 0.0)
        fun addYvelAlt1(builder: FlatBufferBuilder, yvelAlt1: Double) = builder.addDouble(24, yvelAlt1, 0.0)
        fun addZvelAlt1(builder: FlatBufferBuilder, zvelAlt1: Double) = builder.addDouble(25, zvelAlt1, 0.0)
        fun addAlt1ReferenceFrame(builder: FlatBufferBuilder, alt1ReferenceFrame: Int) = builder.addOffset(26, alt1ReferenceFrame, 0)
        fun addXposAlt2(builder: FlatBufferBuilder, xposAlt2: Double) = builder.addDouble(27, xposAlt2, 0.0)
        fun addYposAlt2(builder: FlatBufferBuilder, yposAlt2: Double) = builder.addDouble(28, yposAlt2, 0.0)
        fun addZposAlt2(builder: FlatBufferBuilder, zposAlt2: Double) = builder.addDouble(29, zposAlt2, 0.0)
        fun addXvelAlt2(builder: FlatBufferBuilder, xvelAlt2: Double) = builder.addDouble(30, xvelAlt2, 0.0)
        fun addYvelAlt2(builder: FlatBufferBuilder, yvelAlt2: Double) = builder.addDouble(31, yvelAlt2, 0.0)
        fun addZvelAlt2(builder: FlatBufferBuilder, zvelAlt2: Double) = builder.addDouble(32, zvelAlt2, 0.0)
        fun addAlt2ReferenceFrame(builder: FlatBufferBuilder, alt2ReferenceFrame: Int) = builder.addOffset(33, alt2ReferenceFrame, 0)
        fun addPosUnc(builder: FlatBufferBuilder, posUnc: Double) = builder.addDouble(34, posUnc, 0.0)
        fun addVelUnc(builder: FlatBufferBuilder, velUnc: Double) = builder.addDouble(35, velUnc, 0.0)
        fun addMass(builder: FlatBufferBuilder, mass: Double) = builder.addDouble(36, mass, 0.0)
        fun addArea(builder: FlatBufferBuilder, area: Double) = builder.addDouble(37, area, 0.0)
        fun addSolarRadPressCoeff(builder: FlatBufferBuilder, solarRadPressCoeff: Double) = builder.addDouble(38, solarRadPressCoeff, 0.0)
        fun addDragCoeff(builder: FlatBufferBuilder, dragCoeff: Double) = builder.addDouble(39, dragCoeff, 0.0)
        fun addDragArea(builder: FlatBufferBuilder, dragArea: Double) = builder.addDouble(40, dragArea, 0.0)
        fun addRevNo(builder: FlatBufferBuilder, revNo: Int) = builder.addInt(41, revNo, 0)
        fun addGeopotentialModel(builder: FlatBufferBuilder, geopotentialModel: Int) = builder.addOffset(42, geopotentialModel, 0)
        fun addDragModel(builder: FlatBufferBuilder, dragModel: Int) = builder.addOffset(43, dragModel, 0)
        fun addLunarSolar(builder: FlatBufferBuilder, lunarSolar: Boolean) = builder.addBoolean(44, lunarSolar, false)
        fun addSolarRadPress(builder: FlatBufferBuilder, solarRadPress: Boolean) = builder.addBoolean(45, solarRadPress, false)
        fun addSrpArea(builder: FlatBufferBuilder, srpArea: Double) = builder.addDouble(46, srpArea, 0.0)
        fun addSolidEarthTides(builder: FlatBufferBuilder, solidEarthTides: Boolean) = builder.addBoolean(47, solidEarthTides, false)
        fun addInTrackThrust(builder: FlatBufferBuilder, inTrackThrust: Boolean) = builder.addBoolean(48, inTrackThrust, false)
        fun addBDot(builder: FlatBufferBuilder, bDot: Double) = builder.addDouble(49, bDot, 0.0)
        fun addEdr(builder: FlatBufferBuilder, edr: Double) = builder.addDouble(50, edr, 0.0)
        fun addThrustAccel(builder: FlatBufferBuilder, thrustAccel: Double) = builder.addDouble(51, thrustAccel, 0.0)
        fun addCmOffset(builder: FlatBufferBuilder, cmOffset: Double) = builder.addDouble(52, cmOffset, 0.0)
        fun addLastObStart(builder: FlatBufferBuilder, lastObStart: Int) = builder.addOffset(53, lastObStart, 0)
        fun addLastObEnd(builder: FlatBufferBuilder, lastObEnd: Int) = builder.addOffset(54, lastObEnd, 0)
        fun addObsAvailable(builder: FlatBufferBuilder, obsAvailable: Int) = builder.addInt(55, obsAvailable, 0)
        fun addObsUsed(builder: FlatBufferBuilder, obsUsed: Int) = builder.addInt(56, obsUsed, 0)
        fun addTracksAvail(builder: FlatBufferBuilder, tracksAvail: Int) = builder.addInt(57, tracksAvail, 0)
        fun addTracksUsed(builder: FlatBufferBuilder, tracksUsed: Int) = builder.addInt(58, tracksUsed, 0)
        fun addRecODSpan(builder: FlatBufferBuilder, recOdspan: Double) = builder.addDouble(59, recOdspan, 0.0)
        fun addActualODSpan(builder: FlatBufferBuilder, actualOdspan: Double) = builder.addDouble(60, actualOdspan, 0.0)
        fun addResidualsAcc(builder: FlatBufferBuilder, residualsAcc: Double) = builder.addDouble(61, residualsAcc, 0.0)
        fun addSolarFluxF10(builder: FlatBufferBuilder, solarFluxF10: Double) = builder.addDouble(62, solarFluxF10, 0.0)
        fun addSolarFluxF10Avg(builder: FlatBufferBuilder, solarFluxF10Avg: Double) = builder.addDouble(63, solarFluxF10Avg, 0.0)
        fun addSolarFluxAPAvg(builder: FlatBufferBuilder, solarFluxApavg: Double) = builder.addDouble(64, solarFluxApavg, 0.0)
        fun addTaiUtc(builder: FlatBufferBuilder, taiUtc: Double) = builder.addDouble(65, taiUtc, 0.0)
        fun addUt1Utc(builder: FlatBufferBuilder, ut1Utc: Double) = builder.addDouble(66, ut1Utc, 0.0)
        fun addUt1Rate(builder: FlatBufferBuilder, ut1Rate: Double) = builder.addDouble(67, ut1Rate, 0.0)
        fun addPolarMotionX(builder: FlatBufferBuilder, polarMotionX: Double) = builder.addDouble(68, polarMotionX, 0.0)
        fun addPolarMotionY(builder: FlatBufferBuilder, polarMotionY: Double) = builder.addDouble(69, polarMotionY, 0.0)
        fun addIau1980Terms(builder: FlatBufferBuilder, iau1980Terms: Int) = builder.addInt(70, iau1980Terms, 0)
        fun addLeapSecondTime(builder: FlatBufferBuilder, leapSecondTime: Int) = builder.addOffset(71, leapSecondTime, 0)
        fun addIntegratorMode(builder: FlatBufferBuilder, integratorMode: Int) = builder.addOffset(72, integratorMode, 0)
        fun addPartials(builder: FlatBufferBuilder, partials: Int) = builder.addOffset(73, partials, 0)
        fun addStepMode(builder: FlatBufferBuilder, stepMode: Int) = builder.addOffset(74, stepMode, 0)
        fun addFixedStep(builder: FlatBufferBuilder, fixedStep: Boolean) = builder.addBoolean(75, fixedStep, false)
        fun addStepSizeSelection(builder: FlatBufferBuilder, stepSizeSelection: Int) = builder.addOffset(76, stepSizeSelection, 0)
        fun addStepSize(builder: FlatBufferBuilder, stepSize: Double) = builder.addDouble(77, stepSize, 0.0)
        fun addErrorControl(builder: FlatBufferBuilder, errorControl: Double) = builder.addDouble(78, errorControl, 0.0)
        fun addSigmaPosUVW(builder: FlatBufferBuilder, sigmaPosUvw: Int) = builder.addOffset(79, sigmaPosUvw, 0)
        fun createSigmaPosUvwVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSigmaPosUvwVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSigmaVelUVW(builder: FlatBufferBuilder, sigmaVelUvw: Int) = builder.addOffset(80, sigmaVelUvw, 0)
        fun createSigmaVelUvwVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSigmaVelUvwVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addRms(builder: FlatBufferBuilder, rms: Double) = builder.addDouble(81, rms, 0.0)
        fun addEffectiveFrom(builder: FlatBufferBuilder, effectiveFrom: Int) = builder.addOffset(82, effectiveFrom, 0)
        fun addEffectiveUntil(builder: FlatBufferBuilder, effectiveUntil: Int) = builder.addOffset(83, effectiveUntil, 0)
        fun addRawFileURI(builder: FlatBufferBuilder, rawFileUri: Int) = builder.addOffset(84, rawFileUri, 0)
        fun addSource(builder: FlatBufferBuilder, source: Int) = builder.addOffset(85, source, 0)
        fun addOrigin(builder: FlatBufferBuilder, origin: Int) = builder.addOffset(86, origin, 0)
        fun addDataMode(builder: FlatBufferBuilder, dataMode: Byte) = builder.addByte(87, dataMode, 0)
        fun addTags(builder: FlatBufferBuilder, tags: Int) = builder.addOffset(88, tags, 0)
        fun createTagsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTagsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addAlgorithm(builder: FlatBufferBuilder, algorithm: Int) = builder.addOffset(89, algorithm, 0)
        fun addSourcedData(builder: FlatBufferBuilder, sourcedData: Int) = builder.addOffset(90, sourcedData, 0)
        fun createSourcedDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSourcedDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSourcedDataTypes(builder: FlatBufferBuilder, sourcedDataTypes: Byte) = builder.addByte(91, sourcedDataTypes, 0)
        fun addCreatedAt(builder: FlatBufferBuilder, createdAt: Int) = builder.addOffset(92, createdAt, 0)
        fun addCreatedBy(builder: FlatBufferBuilder, createdBy: Int) = builder.addOffset(93, createdBy, 0)
        fun addOnOrbit(builder: FlatBufferBuilder, onOrbit: Int) = builder.addOffset(94, onOrbit, 0)
        fun addDescriptor(builder: FlatBufferBuilder, descriptor: Int) = builder.addOffset(95, descriptor, 0)
        fun addTransactionId(builder: FlatBufferBuilder, transactionId: Int) = builder.addOffset(96, transactionId, 0)
        fun addOrigNetwork(builder: FlatBufferBuilder, origNetwork: Int) = builder.addOffset(97, origNetwork, 0)
        fun addSourceDL(builder: FlatBufferBuilder, sourceDl: Int) = builder.addOffset(98, sourceDl, 0)
        fun endStateVector_Full(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishStateVectorFullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "STAT")
        fun finishSizePrefixedStateVector_FullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "STAT")
    }
}
