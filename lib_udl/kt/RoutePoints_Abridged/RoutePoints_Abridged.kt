// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// Points identified within the route.
 */
@Suppress("unused")
class RoutePoints_Abridged : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : RoutePoints_Abridged {
        __init(_i, _bb)
        return this
    }
    /**
     * Sequencing field for the track route. This is the identifier representing the sequence of waypoints associated to the track route.
     * Example: /// Example: 1
     * Constraints: No constraints specified.
     */
    val ptSequenceId : Int
        get() {
            val o = __offset(4)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Code representation of the point within the track route (ex. EP, EX, CP, IP, etc.).
     * Example: /// Example: EP
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val ptTypeCode : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ptTypeCodeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun ptTypeCodeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * The name that represents the point within the track route (ex. ENTRY POINT, EXIT POINT, CONTROL POINT, INITIAL POINT, etc.).
     * Example: /// Example: ENTRY POINT
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val ptTypeName : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ptTypeNameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun ptTypeNameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Name of a waypoint which identifies the location of the point.
     * Example: /// Example: KCHS
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val waypointName : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val waypointNameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun waypointNameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Flag indicating this is a Digital Aeronautical Flight Information File (DAFIF) point.
     * Example: /// Example: True
     * Constraints: No constraints specified.
     */
    val dafifPt : Boolean
        get() {
            val o = __offset(12)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * WGS84 latitude of the point location, in degrees. -90 to 90 degrees (negative values south of equator).
     * Example: /// Example: 45.23
     * Constraints: No constraints specified.
     */
    val ptLat : Double
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS84 longitude of the point location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
     * Example: /// Example: 179.1
     * Constraints: No constraints specified.
     */
    val ptLon : Double
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The magnetic declination/variation of the route point location from true north, in degrees. Positive values east of true north and negative values west of true north.
     * Example: /// Example: 7.35
     * Constraints: No constraints specified.
     */
    val magDec : Double
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The length of the course from the Navigational Aid (NAVAID) in nautical miles.
     * Example: /// Example: 100.2
     * Constraints: No constraints specified.
     */
    val navaidLength : Double
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Navigational Aid (NAVAID) identification code.
     * Example: /// Example: HTO
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val navaid : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val navaidAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun navaidInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * The DoD Standard Country Code designator for the country where the route point resides. This field should be set to "OTHR" if the source value does not match a UDL country code value (ISO-3166-ALPHA-2).
     * Example: /// Example: NL
     * Constraints: Minimum length = 0, Maximum length = 4
     */
    val countryCode : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val countryCodeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun countryCodeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * Specifies an alternate country code if the data provider code is not part of an official NAVAID Country Code standard such as ISO-3166 or FIPS. This field will be set to the value provided by the source and should be used for all Queries specifying a Country Code.
     * Example: /// Example: IZ
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val altCountryCode : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val altCountryCodeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun altCountryCodeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * The NAVAID type of this route point (ex. VOR, VORTAC, TACAN, etc.).
     * Example: /// Example: VORTAC
     * Constraints: Minimum length = 0, Maximum length = 12
     */
    val navaidType : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val navaidTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun navaidTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsRoutePoints_Abridged(_bb: ByteBuffer): RoutePoints_Abridged = getRootAsRoutePoints_Abridged(_bb, RoutePoints_Abridged())
        fun getRootAsRoutePoints_Abridged(_bb: ByteBuffer, obj: RoutePoints_Abridged): RoutePoints_Abridged {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun RoutePoints_AbridgedBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "ROUT")
        fun createRoutePoints_Abridged(builder: FlatBufferBuilder, ptSequenceId: Int, ptTypeCodeOffset: Int, ptTypeNameOffset: Int, waypointNameOffset: Int, dafifPt: Boolean, ptLat: Double, ptLon: Double, magDec: Double, navaidLength: Double, navaidOffset: Int, countryCodeOffset: Int, altCountryCodeOffset: Int, navaidTypeOffset: Int) : Int {
            builder.startTable(13)
            addNavaidLength(builder, navaidLength)
            addMagDec(builder, magDec)
            addPtLon(builder, ptLon)
            addPtLat(builder, ptLat)
            addNavaidType(builder, navaidTypeOffset)
            addAltCountryCode(builder, altCountryCodeOffset)
            addCountryCode(builder, countryCodeOffset)
            addNavaid(builder, navaidOffset)
            addWaypointName(builder, waypointNameOffset)
            addPtTypeName(builder, ptTypeNameOffset)
            addPtTypeCode(builder, ptTypeCodeOffset)
            addPtSequenceId(builder, ptSequenceId)
            addDafifPt(builder, dafifPt)
            return endRoutePoints_Abridged(builder)
        }
        fun startRoutePoints_Abridged(builder: FlatBufferBuilder) = builder.startTable(13)
        fun addPtSequenceId(builder: FlatBufferBuilder, ptSequenceId: Int) = builder.addInt(0, ptSequenceId, 0)
        fun addPtTypeCode(builder: FlatBufferBuilder, ptTypeCode: Int) = builder.addOffset(1, ptTypeCode, 0)
        fun addPtTypeName(builder: FlatBufferBuilder, ptTypeName: Int) = builder.addOffset(2, ptTypeName, 0)
        fun addWaypointName(builder: FlatBufferBuilder, waypointName: Int) = builder.addOffset(3, waypointName, 0)
        fun addDafifPt(builder: FlatBufferBuilder, dafifPt: Boolean) = builder.addBoolean(4, dafifPt, false)
        fun addPtLat(builder: FlatBufferBuilder, ptLat: Double) = builder.addDouble(5, ptLat, 0.0)
        fun addPtLon(builder: FlatBufferBuilder, ptLon: Double) = builder.addDouble(6, ptLon, 0.0)
        fun addMagDec(builder: FlatBufferBuilder, magDec: Double) = builder.addDouble(7, magDec, 0.0)
        fun addNavaidLength(builder: FlatBufferBuilder, navaidLength: Double) = builder.addDouble(8, navaidLength, 0.0)
        fun addNavaid(builder: FlatBufferBuilder, navaid: Int) = builder.addOffset(9, navaid, 0)
        fun addCountryCode(builder: FlatBufferBuilder, countryCode: Int) = builder.addOffset(10, countryCode, 0)
        fun addAltCountryCode(builder: FlatBufferBuilder, altCountryCode: Int) = builder.addOffset(11, altCountryCode, 0)
        fun addNavaidType(builder: FlatBufferBuilder, navaidType: Int) = builder.addOffset(12, navaidType, 0)
        fun endRoutePoints_Abridged(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishRoutePointsAbridgedBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "ROUT")
        fun finishSizePrefixedRoutePoints_AbridgedBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "ROUT")
    }
}
