// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// The airfield status contains dynamic data of an airfield's capabilities.
 */
@Suppress("unused")
class AirfieldStatus_Ingest : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : AirfieldStatus_Ingest {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record, auto-generated by the system.
     * Example: /// Example: be831d39-1822-da9f-7ace-6cc5643397dc
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val id : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun idInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     * Example: /// Example: U
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val classificationMarking : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val classificationMarkingAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun classificationMarkingInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Unique identifier of the Airfield for which this status is referencing.
     * Example: /// Example: 3136498f-2969-3535-1432-e984b2e2e686
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val idAirfield : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idAirfieldAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun idAirfieldInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Alternate airfield identifier provided by the source.
     * Example: /// Example: AIRFIELD-ID
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val altAirfieldId : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val altAirfieldIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun altAirfieldIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Maximum on ground (MOG) number of high-reach/wide-body passenger aircraft that can be serviced simultaneously based on spacing and manpower at the time of status.
     * Example: /// Example: 5
     * Constraints: No constraints specified.
     */
    val passengerServiceMog : Int
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Maximum on ground (MOG) number of fleet aircraft that can be serviced simultaneously based on spacing and manpower at the time of status.
     * Example: /// Example: 4
     * Constraints: No constraints specified.
     */
    val fleetServiceMog : Int
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Maximum on ground (MOG) number of high-reach/wide-body cargo aircraft that can be serviced simultaneously based on spacing and manpower at the time of status.
     * Example: /// Example: 8
     * Constraints: No constraints specified.
     */
    val cargoMog : Int
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Maximum on ground (MOG) number of aircraft that can be simultaneously refueled based on spacing and manpower at the time of status.
     * Example: /// Example: 9
     * Constraints: No constraints specified.
     */
    val fuelMog : Int
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Array of fuel types available at the airfield. This array must be the same length as fuelQtys.
     * Example: /// Example: ['JP-8', 'Jet A', 'AVGAS']
     * Constraints: No constraints specified.
     */
    fun fuelTypes(j: Int) : String? {
        val o = __offset(20)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val fuelTypesLength : Int
        get() {
            val o = __offset(20); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of quantities for each fuel type at the airfield, in kilograms. The values in this array must correspond to the position index in fuelTypes. This array must be the same length as fuelTypes.
     * Example: /// Example: [263083.6, 286674.9, 18143.69]
     * Constraints: No constraints specified.
     */
    fun fuelQtys(j: Int) : String? {
        val o = __offset(22)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val fuelQtysLength : Int
        get() {
            val o = __offset(22); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Maximum on ground (MOG) number of aircraft that can be simultaneously ground handled for standard maintenance based on spacing and manpower at the time of status.
     * Example: /// Example: 3
     * Constraints: No constraints specified.
     */
    val mxMog : Int
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Maximum on ground (MOG) number of aircraft due to items not directly related to the airfield infrastructure or aircraft servicing capability based on spacing and manpower at the time of status.
     * Example: /// Example: 4
     * Constraints: No constraints specified.
     */
    val operatingMog : Int
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The number of aircraft that are currently on ground (COG) at the airfield.
     * Example: /// Example: 2
     * Constraints: No constraints specified.
     */
    val numCog : Int
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Maximum on ground (MOG) number of working wide-body aircraft based on spacing and manpower at the time of status.
     * Example: /// Example: 3
     * Constraints: No constraints specified.
     */
    val wideWorkingMog : Int
        get() {
            val o = __offset(30)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Maximum on ground (MOG) number of parking wide-body aircraft based on spacing and manpower at the time of status.
     * Example: /// Example: 7
     * Constraints: No constraints specified.
     */
    val wideParkingMog : Int
        get() {
            val o = __offset(32)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Maximum on ground (MOG) number of working narrow-body aircraft based on spacing and manpower at the time of status.
     * Example: /// Example: 4
     * Constraints: No constraints specified.
     */
    val narrowWorkingMog : Int
        get() {
            val o = __offset(34)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Maximum on ground (MOG) number of parking narrow-body aircraft based on spacing and manpower at the time of status.
     * Example: /// Example: 5
     * Constraints: No constraints specified.
     */
    val narrowParkingMog : Int
        get() {
            val o = __offset(36)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Array of material handling equipment types at the airfield. This array must be the same length as mheQtys.
     * Example: /// Example: ['30k', 'AT', '60k']
     * Constraints: No constraints specified.
     */
    fun mheTypes(j: Int) : String? {
        val o = __offset(38)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val mheTypesLength : Int
        get() {
            val o = __offset(38); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of quantities for each material handling equipment types at the airfield. The values in this array must correspond to the position index in mheTypes. This array must be the same length as mheTypes.
     * Example: /// Example: [1, 3, 1]
     * Constraints: No constraints specified.
     */
    fun mheQtys(j: Int) : String? {
        val o = __offset(40)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val mheQtysLength : Int
        get() {
            val o = __offset(40); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The level of medical support and capabilities available at the airfield.
     * Example: /// Example: Large Field Hospital
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val medCap : String?
        get() {
            val o = __offset(42)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val medCapAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(42, 1)
    fun medCapInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 42, 1)
    /**
     * The category of aircraft rescue and fire fighting (ARFF) services that are currently available at the airfield. Entries should include  the code (FAA or ICAO) and the category.
     * Example: /// Example: FAA-A
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val arffCat : String?
        get() {
            val o = __offset(44)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val arffCatAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(44, 1)
    fun arffCatInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 44, 1)
    /**
     * The expected time to receive ground support equipment (e.g. power units, air units, cables, hoses, etc.), in minutes.
     * Example: /// Example: 10
     * Constraints: No constraints specified.
     */
    val gseTime : Int
        get() {
            val o = __offset(46)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The number or ID of primary runway at the airfield.
     * Example: /// Example: 35R
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val priRwyNum : String?
        get() {
            val o = __offset(48)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val priRwyNumAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(48, 1)
    fun priRwyNumInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 48, 1)
    /**
     * The primary runway condition reading value used for determining runway braking action, from 0 to 26. A value of 0 indicates braking action is poor or non-existent, where a value of 26 indicates braking action is good.
     * Example: /// Example: 23
     * Constraints: No constraints specified.
     */
    val rwyCondReading : Int
        get() {
            val o = __offset(50)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The primary runway friction factor which is dependent on the surface friction between the tires of the aircraft and the runway surface, from 0 to 100. A lower number indicates less friction and less braking response.
     * Example: /// Example: 10
     * Constraints: No constraints specified.
     */
    val rwyFrictionFactor : Int
        get() {
            val o = __offset(52)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Array of markings currently on the primary runway.
     * Example: /// Example: ['Aiming Point', 'Threshold']
     * Constraints: No constraints specified.
     */
    fun rwyMarkings(j: Int) : String? {
        val o = __offset(54)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val rwyMarkingsLength : Int
        get() {
            val o = __offset(54); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Description of the current status of the airfield.
     * Example: /// Example: Status message about the airfield.
     * Constraints: Minimum length = 0, Maximum length = 1024
     */
    val message : String?
        get() {
            val o = __offset(56)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val messageAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(56, 1)
    fun messageInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 56, 1)
    /**
     * The primary frequency which the airfield is currently operating, in megahertz.
     * Example: /// Example: 123.45
     * Constraints: No constraints specified.
     */
    val priFreq : Double
        get() {
            val o = __offset(58)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Array of slot types that an airfield requires a particular aircraft provide in order to consume a slot at this location.
     * Example: /// Example: ['PARKING', 'WORKING', 'LANDING']
     * Constraints: No constraints specified.
     */
    fun slotTypesReq(j: Int) : String? {
        val o = __offset(60)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val slotTypesReqLength : Int
        get() {
            val o = __offset(60); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Time the row was created in the database, auto-populated by the system.
     * Example: /// Example: 2022-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val createdAt : String?
        get() {
            val o = __offset(62)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdAtAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(62, 1)
    fun createdAtInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 62, 1)
    /**
     * Application user who created the row in the database, auto-populated by the system.
     * Example: /// Example: some.user
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val createdBy : String?
        get() {
            val o = __offset(64)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdByAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(64, 1)
    fun createdByInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 64, 1)
    /**
     * The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
     * Example: /// Example: AXE
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val sourceDl : String?
        get() {
            val o = __offset(66)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceDlAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(66, 1)
    fun sourceDlInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 66, 1)
    /**
     * Source of the data.
     * Example: /// Example: Bluestaq
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val source : String?
        get() {
            val o = __offset(68)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(68, 1)
    fun sourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 68, 1)
    /**
     * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     * Example: /// Example: THIRD_PARTY_DATASOURCE
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origin : String?
        get() {
            val o = __offset(70)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val originAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(70, 1)
    fun originInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 70, 1)
    /**
     * The originating source network on which this record was created, auto-populated by the system.
     * Example: /// Example: OPS1
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val origNetwork : String?
        get() {
            val o = __offset(72)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origNetworkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(72, 1)
    fun origNetworkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 72, 1)
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
     * Example: /// Example: TEST
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val dataMode : Byte
        get() {
            val o = __offset(74)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsAirfieldStatus_Ingest(_bb: ByteBuffer): AirfieldStatus_Ingest = getRootAsAirfieldStatus_Ingest(_bb, AirfieldStatus_Ingest())
        fun getRootAsAirfieldStatus_Ingest(_bb: ByteBuffer, obj: AirfieldStatus_Ingest): AirfieldStatus_Ingest {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun AirfieldStatus_IngestBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "AIRF")
        fun createAirfieldStatus_Ingest(builder: FlatBufferBuilder, idOffset: Int, classificationMarkingOffset: Int, idAirfieldOffset: Int, altAirfieldIdOffset: Int, passengerServiceMog: Int, fleetServiceMog: Int, cargoMog: Int, fuelMog: Int, fuelTypesOffset: Int, fuelQtysOffset: Int, mxMog: Int, operatingMog: Int, numCog: Int, wideWorkingMog: Int, wideParkingMog: Int, narrowWorkingMog: Int, narrowParkingMog: Int, mheTypesOffset: Int, mheQtysOffset: Int, medCapOffset: Int, arffCatOffset: Int, gseTime: Int, priRwyNumOffset: Int, rwyCondReading: Int, rwyFrictionFactor: Int, rwyMarkingsOffset: Int, messageOffset: Int, priFreq: Double, slotTypesReqOffset: Int, createdAtOffset: Int, createdByOffset: Int, sourceDlOffset: Int, sourceOffset: Int, originOffset: Int, origNetworkOffset: Int, dataMode: Byte) : Int {
            builder.startTable(36)
            addPriFreq(builder, priFreq)
            addOrigNetwork(builder, origNetworkOffset)
            addOrigin(builder, originOffset)
            addSource(builder, sourceOffset)
            addSourceDL(builder, sourceDlOffset)
            addCreatedBy(builder, createdByOffset)
            addCreatedAt(builder, createdAtOffset)
            addSlotTypesReq(builder, slotTypesReqOffset)
            addMessage(builder, messageOffset)
            addRwyMarkings(builder, rwyMarkingsOffset)
            addRwyFrictionFactor(builder, rwyFrictionFactor)
            addRwyCondReading(builder, rwyCondReading)
            addPriRwyNum(builder, priRwyNumOffset)
            addGseTime(builder, gseTime)
            addArffCat(builder, arffCatOffset)
            addMedCap(builder, medCapOffset)
            addMheQtys(builder, mheQtysOffset)
            addMheTypes(builder, mheTypesOffset)
            addNarrowParkingMOG(builder, narrowParkingMog)
            addNarrowWorkingMOG(builder, narrowWorkingMog)
            addWideParkingMOG(builder, wideParkingMog)
            addWideWorkingMOG(builder, wideWorkingMog)
            addNumCOG(builder, numCog)
            addOperatingMOG(builder, operatingMog)
            addMxMOG(builder, mxMog)
            addFuelQtys(builder, fuelQtysOffset)
            addFuelTypes(builder, fuelTypesOffset)
            addFuelMOG(builder, fuelMog)
            addCargoMOG(builder, cargoMog)
            addFleetServiceMOG(builder, fleetServiceMog)
            addPassengerServiceMOG(builder, passengerServiceMog)
            addAltAirfieldId(builder, altAirfieldIdOffset)
            addIdAirfield(builder, idAirfieldOffset)
            addClassificationMarking(builder, classificationMarkingOffset)
            addId(builder, idOffset)
            addDataMode(builder, dataMode)
            return endAirfieldStatus_Ingest(builder)
        }
        fun startAirfieldStatus_Ingest(builder: FlatBufferBuilder) = builder.startTable(36)
        fun addId(builder: FlatBufferBuilder, id: Int) = builder.addOffset(0, id, 0)
        fun addClassificationMarking(builder: FlatBufferBuilder, classificationMarking: Int) = builder.addOffset(1, classificationMarking, 0)
        fun addIdAirfield(builder: FlatBufferBuilder, idAirfield: Int) = builder.addOffset(2, idAirfield, 0)
        fun addAltAirfieldId(builder: FlatBufferBuilder, altAirfieldId: Int) = builder.addOffset(3, altAirfieldId, 0)
        fun addPassengerServiceMOG(builder: FlatBufferBuilder, passengerServiceMog: Int) = builder.addInt(4, passengerServiceMog, 0)
        fun addFleetServiceMOG(builder: FlatBufferBuilder, fleetServiceMog: Int) = builder.addInt(5, fleetServiceMog, 0)
        fun addCargoMOG(builder: FlatBufferBuilder, cargoMog: Int) = builder.addInt(6, cargoMog, 0)
        fun addFuelMOG(builder: FlatBufferBuilder, fuelMog: Int) = builder.addInt(7, fuelMog, 0)
        fun addFuelTypes(builder: FlatBufferBuilder, fuelTypes: Int) = builder.addOffset(8, fuelTypes, 0)
        fun createFuelTypesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startFuelTypesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addFuelQtys(builder: FlatBufferBuilder, fuelQtys: Int) = builder.addOffset(9, fuelQtys, 0)
        fun createFuelQtysVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startFuelQtysVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addMxMOG(builder: FlatBufferBuilder, mxMog: Int) = builder.addInt(10, mxMog, 0)
        fun addOperatingMOG(builder: FlatBufferBuilder, operatingMog: Int) = builder.addInt(11, operatingMog, 0)
        fun addNumCOG(builder: FlatBufferBuilder, numCog: Int) = builder.addInt(12, numCog, 0)
        fun addWideWorkingMOG(builder: FlatBufferBuilder, wideWorkingMog: Int) = builder.addInt(13, wideWorkingMog, 0)
        fun addWideParkingMOG(builder: FlatBufferBuilder, wideParkingMog: Int) = builder.addInt(14, wideParkingMog, 0)
        fun addNarrowWorkingMOG(builder: FlatBufferBuilder, narrowWorkingMog: Int) = builder.addInt(15, narrowWorkingMog, 0)
        fun addNarrowParkingMOG(builder: FlatBufferBuilder, narrowParkingMog: Int) = builder.addInt(16, narrowParkingMog, 0)
        fun addMheTypes(builder: FlatBufferBuilder, mheTypes: Int) = builder.addOffset(17, mheTypes, 0)
        fun createMheTypesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startMheTypesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addMheQtys(builder: FlatBufferBuilder, mheQtys: Int) = builder.addOffset(18, mheQtys, 0)
        fun createMheQtysVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startMheQtysVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addMedCap(builder: FlatBufferBuilder, medCap: Int) = builder.addOffset(19, medCap, 0)
        fun addArffCat(builder: FlatBufferBuilder, arffCat: Int) = builder.addOffset(20, arffCat, 0)
        fun addGseTime(builder: FlatBufferBuilder, gseTime: Int) = builder.addInt(21, gseTime, 0)
        fun addPriRwyNum(builder: FlatBufferBuilder, priRwyNum: Int) = builder.addOffset(22, priRwyNum, 0)
        fun addRwyCondReading(builder: FlatBufferBuilder, rwyCondReading: Int) = builder.addInt(23, rwyCondReading, 0)
        fun addRwyFrictionFactor(builder: FlatBufferBuilder, rwyFrictionFactor: Int) = builder.addInt(24, rwyFrictionFactor, 0)
        fun addRwyMarkings(builder: FlatBufferBuilder, rwyMarkings: Int) = builder.addOffset(25, rwyMarkings, 0)
        fun createRwyMarkingsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startRwyMarkingsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addMessage(builder: FlatBufferBuilder, message: Int) = builder.addOffset(26, message, 0)
        fun addPriFreq(builder: FlatBufferBuilder, priFreq: Double) = builder.addDouble(27, priFreq, 0.0)
        fun addSlotTypesReq(builder: FlatBufferBuilder, slotTypesReq: Int) = builder.addOffset(28, slotTypesReq, 0)
        fun createSlotTypesReqVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSlotTypesReqVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addCreatedAt(builder: FlatBufferBuilder, createdAt: Int) = builder.addOffset(29, createdAt, 0)
        fun addCreatedBy(builder: FlatBufferBuilder, createdBy: Int) = builder.addOffset(30, createdBy, 0)
        fun addSourceDL(builder: FlatBufferBuilder, sourceDl: Int) = builder.addOffset(31, sourceDl, 0)
        fun addSource(builder: FlatBufferBuilder, source: Int) = builder.addOffset(32, source, 0)
        fun addOrigin(builder: FlatBufferBuilder, origin: Int) = builder.addOffset(33, origin, 0)
        fun addOrigNetwork(builder: FlatBufferBuilder, origNetwork: Int) = builder.addOffset(34, origNetwork, 0)
        fun addDataMode(builder: FlatBufferBuilder, dataMode: Byte) = builder.addByte(35, dataMode, 0)
        fun endAirfieldStatus_Ingest(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishAirfieldStatusIngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "AIRF")
        fun finishSizePrefixedAirfieldStatus_IngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "AIRF")
    }
}
