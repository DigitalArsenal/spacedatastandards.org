// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// These services provide operations for querying of all available track details and amplifying track data. A track is a position and optionally a heading/velocity of an object such as an aircraft, marine vessel, etc at a particular timestamp. It also includes optional information regarding the identity/type of the target object and other amplifying object data, if known.
 */
@Suppress("unused")
class TrackDetails_Full : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : TrackDetails_Full {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record, auto-generated by the system.
     * Example: /// Example: TRACK-DETAILS-ID
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val id : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun idInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     * Example: /// Example: U
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val classificationMarking : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val classificationMarkingAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun classificationMarkingInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
     *  AIR: Between sea level and the K치rm치n line, which has an altitude of 100 kilometers (62 miles).
     *  LAND: On the surface of dry land.
     *  SPACE: Above the K치rm치n line, which has an altitude of 100 kilometers (62 miles).
     *  SURFACE: On the surface of a body of water.
     *  SUBSURFACE: Below the surface of a body of water.
     *  UNKNOWN: Environment is not known.
     * Example: /// Example: LAND
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val env : Byte
        get() {
            val o = __offset(8)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Optional message type designation.
     * Example: /// Example: PLATFORM
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val msgType : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val msgTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun msgTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * The vessel hull number designation of this maritime vessel.  The hull number is a 1-6 character alphanumeric entry assigned to a ship and painted on the hull.
     * Example: /// Example: A30081
     * Constraints: Minimum length = 0, Maximum length = 7
     */
    val hullNum : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val hullNumAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun hullNumInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * The Pseudo Identification Feature (PIF) number is a four digit code that provides an exact ID for the ship or aircraft. Friendly military only.
     * Example: /// Example: 0137
     * Constraints: Minimum length = 0, Maximum length = 5
     */
    val pif : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val pifAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun pifInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * The Ship Control Number (SCONUM) is a naval vessel identification number (alphanumeric code) assigned by the Office of Naval Intelligence. SCONUM is sometimes referred to as NOIC ID. SCONUMs are typically of the form A#####, where A is an alpha character and # is numerical.
     * Example: /// Example: B45524
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val sconum : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sconumAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun sconumInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * The Naval Tactical Data System (NTDS) track number assigned to this track.
     * Example: /// Example: ZZ777
     * Constraints: Minimum length = 0, Maximum length = 6
     */
    val ntds : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ntdsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun ntdsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * The Intel Discrete Identifier (IDI) code assigned to this track.  The IDI is a four-digit code representing hostile or unknown tracks.
     * Example: /// Example: 7670
     * Constraints: Minimum length = 0, Maximum length = 5
     */
    val disId : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val disIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun disIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * The category code that represents the associated facility purpose within the target system.  This value is the category code in the MIDB (Modernized Intelligence Database).
     * Example: /// Example: 20345
     * Constraints: Minimum length = 0, Maximum length = 6
     */
    val midbCat : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val midbCatAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun midbCatInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * The Basic Encyclopedia (BE) number associated with this installation or area.
     * Example: /// Example: ENC-123
     * Constraints: Minimum length = 0, Maximum length = 10
     */
    val beNumber : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val beNumberAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun beNumberInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * The O-suffix associated with this facility.  The O-suffix is a five-character alpha/numeric system used to identify a facility, or demographic area, within an installation. The Installation Basic Encyclopedia (beNumber), in conjunction with the O-suffix, uniquely identifies the facility within the Modernized Integrated Database (MIDB).  The Installation beNumber and oSuffix are also used in conjunction with the midbCat code to classify the function or purpose of the facility.
     * Example: /// Example: AA125
     * Constraints: Minimum length = 0, Maximum length = 6
     */
    val oSuffix : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val oSuffixAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun oSuffixInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * This value represents the site number of a specific electronic site or its associated equipment.
     * Example: /// Example: E12345012
     * Constraints: Minimum length = 0, Maximum length = 9
     */
    val pin : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val pinAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun pinInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    /**
     * Flag indicating whether the missile is considered lost, if reporting a missile track.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val lostTrkInd : Boolean
        get() {
            val o = __offset(30)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Track ID for the source of the Missile-Unique Identifier (MUID), if reporting a missile track.
     * Example: /// Example: MUID-SRC-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val muidSrcTrk : String?
        get() {
            val o = __offset(32)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val muidSrcTrkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(32, 1)
    fun muidSrcTrkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 32, 1)
    /**
     * Source of the Missile-Unique Identifier (MUID), if reporting a missile track.
     * Example: /// Example: MUID-SRC
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val muidSrc : String?
        get() {
            val o = __offset(34)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val muidSrcAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(34, 1)
    fun muidSrcInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 34, 1)
    /**
     * The status of the missile track in this record, if reporting a missile track (e.g. AT LAUNCH, AT OBSERVATION, FLYING, IMPACTED, LOST, STALE, DEBRIS).
     * Example: /// Example: AT LAUNCH
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val mslStatus : String?
        get() {
            val o = __offset(36)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val mslStatusAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(36, 1)
    fun mslStatusInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 36, 1)
    /**
     * Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
     * Example: /// Example: 0.95
     * Constraints: No constraints specified.
     */
    val trkConf : Double
        get() {
            val o = __offset(38)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track; Higher values indicate higher track quality, i.e., lower errors in reported position.
     * Example: /// Example: 1
     * Constraints: No constraints specified.
     */
    val trkQual : Int
        get() {
            val o = __offset(40)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * A track may be designated as an alert track with the following designations:
     * HIT - High Interest Track
     * TGT - Target
     * SUS - Suspect Carrier
     * NSP - Cleared Suspect
     * If alert is null, the track is assumed to be of non-alert status.
     * Example: /// Example: TGT
     * Constraints: Minimum length = 0, Maximum length = 3
     */
    val alert : String?
        get() {
            val o = __offset(42)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val alertAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(42, 1)
    fun alertInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 42, 1)
    /**
     * Original source cross-reference code for the Command that originated the report.
     * Example: /// Example: INT
     * Constraints: Minimum length = 0, Maximum length = 5
     */
    val origXref : String?
        get() {
            val o = __offset(44)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origXrefAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(44, 1)
    fun origXrefInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 44, 1)
    /**
     * Primary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
     * Example: /// Example: A123A
     * Constraints: Minimum length = 0, Maximum length = 5
     */
    val elnot1 : String?
        get() {
            val o = __offset(46)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val elnot1AsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(46, 1)
    fun elnot1InByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 46, 1)
    /**
     * Secondary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
     * Example: /// Example: A123B
     * Constraints: Minimum length = 0, Maximum length = 5
     */
    val elnot2 : String?
        get() {
            val o = __offset(48)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val elnot2AsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(48, 1)
    fun elnot2InByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 48, 1)
    /**
     * The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
     *  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
     *  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
     *  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
     *  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
     *  PENDING: Track object which has not been evaluated.
     *  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
     *  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
     * Example: /// Example: FRIEND
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val objIdent : Byte
        get() {
            val o = __offset(50)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * The generic classification of the track object/group (e.g., BALLISTIC, HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
     * Example: /// Example: TRACKED
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val objType : String?
        get() {
            val o = __offset(52)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val objTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(52, 1)
    fun objTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 52, 1)
    /**
     * The object platform type is intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. SATELLITE).
     * Example: /// Example: WEAPON
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val objPlat : String?
        get() {
            val o = __offset(54)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val objPlatAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(54, 1)
    fun objPlatInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 54, 1)
    /**
     * The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. ANTISPACE WARFARE).
     * Example: /// Example: HOLDING
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val objAct : String?
        get() {
            val o = __offset(56)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val objActAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(56, 1)
    fun objActInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 56, 1)
    /**
     * Nationality of the tracked object.
     * Example: /// Example: USA
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val objNat : String?
        get() {
            val o = __offset(58)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val objNatAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(58, 1)
    fun objNatInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 58, 1)
    /**
     * Track name.
     * Example: /// Example: TRACK-NAME
     * Constraints: Minimum length = 0, Maximum length = 48
     */
    val name : String?
        get() {
            val o = __offset(60)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val nameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(60, 1)
    fun nameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 60, 1)
    /**
     * Abbreviated track name.
     * Example: /// Example: COMMSCHECK
     * Constraints: Minimum length = 0, Maximum length = 11
     */
    val shortName : String?
        get() {
            val o = __offset(62)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val shortNameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(62, 1)
    fun shortNameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 62, 1)
    /**
     * UUID identifying the track, which should remain the same on subsequent tracks of the same object.
     * Example: /// Example: trkId
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val trkId : String?
        get() {
            val o = __offset(64)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val trkIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(64, 1)
    fun trkIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 64, 1)
    /**
     * The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
     * Example: /// Example: trkNum
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val trkNum : String?
        get() {
            val o = __offset(66)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val trkNumAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(66, 1)
    fun trkNumInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 66, 1)
    /**
     * Value Indicating the scope of this track:
     * 1 - TERMINAL  (Terminal) - available only on the workstation where they were created.
     * 2 - LOCAL  (Local) - available only on workstations in the local area network
     * 3 - OTH  (Over the Horizon) - available to everyone.
     * Example: /// Example: OTH
     * Constraints: Minimum length = 0, Maximum length = 12
     */
    val trkScope : String?
        get() {
            val o = __offset(68)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val trkScopeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(68, 1)
    fun trkScopeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 68, 1)
    /**
     * The unique identifier of the source node.
     * Example: /// Example: MCS
     * Constraints: Minimum length = 0, Maximum length = 4
     */
    val sourceUid : String?
        get() {
            val o = __offset(70)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceUidAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(70, 1)
    fun sourceUidInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 70, 1)
    /**
     * The call sign currently assigned to this track object.
     * Example: /// Example: Charlie
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val callSign : String?
        get() {
            val o = __offset(72)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val callSignAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(72, 1)
    fun callSignInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 72, 1)
    /**
     * Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
     *  FAKER: Friendly track, object, or entity acting as an exercise hostile.
     *  JOKER: Friendly track, object, or entity acting as an exercise suspect.
     *  KILO: Friendly high-value object.
     *  TRAVELLER: Suspect land or surface track following a recognized traffic route.
     *  ZOMBIE: Suspect track, object, or entity of special interest.
     * Example: /// Example: JOKER
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val identAmp : String?
        get() {
            val o = __offset(74)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val identAmpAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(74, 1)
    fun identAmpInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 74, 1)
    /**
     * Space amplification indicates additional information on the space environment object being reported (e.g. DEBRIS, FUEL-AIR EXPLOSIVE, NUCLEAR WARHEAD).
     * Example: /// Example: NUCLEAR WARHEAD
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val spaceAmp : String?
        get() {
            val o = __offset(76)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val spaceAmpAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(76, 1)
    fun spaceAmpInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 76, 1)
    /**
     * Confidence level of the amplifying characteristics.  Values range from 0 to 6, with 0 indicating the lowest confidence and 6 indicating the highest.
     * Example: /// Example: 6
     * Constraints: No constraints specified.
     */
    val spaceAmpConf : Int
        get() {
            val o = __offset(78)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Specific type of point or track with an environment of space.
     * Example: /// Example: SS-21_MOD_2_CRBM
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val spaceSpecType : String?
        get() {
            val o = __offset(80)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val spaceSpecTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(80, 1)
    fun spaceSpecTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 80, 1)
    /**
     * Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM:
     * SRBM - Short-Range Ballistic Missile
     * MRBM - Medium-Range Ballistic Missile
     * IRBM - Intermediate-Range Ballistic Missile
     * LRBM - Long-Range Ballistic Missile
     * ICBM - Intercontinental Ballistic Missile
     * SLBM - Submarine-Launched Ballistic Missile.
     * Example: /// Example: SLBM
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val acftSubType : String?
        get() {
            val o = __offset(82)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val acftSubTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(82, 1)
    fun acftSubTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 82, 1)
    /**
     * Track timestamp in ISO8601 UTC format with microsecond precision.
     * Example: /// Example: 2021-02-25T12:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val ts : String?
        get() {
            val o = __offset(84)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val tsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(84, 1)
    fun tsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 84, 1)
    /**
     * Missile launch timestamp in ISO8601 UTC format with microsecond precision.
     * Example: /// Example: 2021-02-25T12:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val launchTime : String?
        get() {
            val o = __offset(86)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val launchTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(86, 1)
    fun launchTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 86, 1)
    /**
     * Missile impact timestamp in ISO8601 UTC format with microsecond precision.
     * Example: /// Example: 2021-02-25T12:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val impactTime : String?
        get() {
            val o = __offset(88)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val impactTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(88, 1)
    fun impactTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 88, 1)
    /**
     * The message timestamp that the ftn track position was recorded, in ISO 8601 UTC format with microsecond precision.
     * Example: /// Example: 2021-02-25T12:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val ftnMsgTs : String?
        get() {
            val o = __offset(90)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ftnMsgTsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(90, 1)
    fun ftnMsgTsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 90, 1)
    /**
     * An ftn used to associate information and directives with the track.
     * Example: /// Example: FTN
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val ftn : String?
        get() {
            val o = __offset(92)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ftnAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(92, 1)
    fun ftnInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 92, 1)
    /**
     * The name of the Command reporting the Force Over-The-Horizon Track Coordinator (FOTC) track number.
     * Example: /// Example: TRUETT
     * Constraints: Minimum length = 0, Maximum length = 18
     */
    val ftnCmd : String?
        get() {
            val o = __offset(94)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ftnCmdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(94, 1)
    fun ftnCmdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 94, 1)
    /**
     * The message timestamp that the reference track position was recorded, in ISO 8601 UTC format with microsecond precision. The 'rtnMsgTs' and 'rtn' arrays must match in size.
     * Example: /// Example: ['2021-02-25T12:00:00.123456Z']
     * Constraints: No constraints specified.
     */
    fun rtnMsgTs(j: Int) : String? {
        val o = __offset(96)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val rtnMsgTsLength : Int
        get() {
            val o = __offset(96); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * A Reference Track Number used to associate information and directives with the track.  Referenced, but not constrained to, MIL-STD-6016F Reference Track Number. The 'rtnMsgTs' and 'rtn' arrays must match in size.
     * Example: /// Example: ['ex-a']
     * Constraints: No constraints specified.
     */
    fun rtn(j: Int) : String? {
        val o = __offset(98)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val rtnLength : Int
        get() {
            val o = __offset(98); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Value representing the state of the Received Track.
     * Example: /// Example: Local_RTN
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val rtnTrkState : String?
        get() {
            val o = __offset(100)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val rtnTrkStateAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(100, 1)
    fun rtnTrkStateInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 100, 1)
    /**
     * The name of the Command reporting the Received Track Number (RTN).
     * Example: /// Example: YORKTOWN
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val rtnCmd : String?
        get() {
            val o = __offset(102)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val rtnCmdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(102, 1)
    fun rtnCmdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 102, 1)
    /**
     * Id/name of sensor providing the track data.
     * Example: /// Example: OTH
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val sen : String?
        get() {
            val o = __offset(104)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val senAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(104, 1)
    fun senInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 104, 1)
    /**
     * Source cross-reference code for the Command that originated the track report.
     * Example: /// Example: INT
     * Constraints: Minimum length = 0, Maximum length = 18
     */
    val rptChxref : String?
        get() {
            val o = __offset(106)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val rptChxrefAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(106, 1)
    fun rptChxrefInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 106, 1)
    /**
     * Flag indicating whether this track is archived.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val rptArchived : Boolean
        get() {
            val o = __offset(108)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Flag indicating that this track is self reported.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val selfReport : Boolean
        get() {
            val o = __offset(110)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * The MIL-STD-2525B symbology code that applies to the subject of this track.
     * Example: /// Example: SHP*S----------
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val mil2525Bstr : String?
        get() {
            val o = __offset(112)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val mil2525BstrAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(112, 1)
    fun mil2525BstrInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 112, 1)
    /**
     * Transponder ID for the track.  This does not correspond to the UDL transponder schema.
     * Example: /// Example: 11
     * Constraints: Minimum length = 0, Maximum length = 61
     */
    val trnspdrId : String?
        get() {
            val o = __offset(114)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val trnspdrIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(114, 1)
    fun trnspdrIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 114, 1)
    /**
     * Transponder type for the track.
     * Example: /// Example: AFTS
     * Constraints: Minimum length = 0, Maximum length = 51
     */
    val trnspdrType : String?
        get() {
            val o = __offset(116)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val trnspdrTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(116, 1)
    fun trnspdrTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 116, 1)
    /**
     * Radar name of the sensor tracking this object (e.g., RAY1500, SPN-43, HEADNET).
     * Example: /// Example: RAY1500
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val emitterName : String?
        get() {
            val o = __offset(118)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val emitterNameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(118, 1)
    fun emitterNameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 118, 1)
    /**
     * Source code for source of information used to detect track.
     * Example: /// Example: S1
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val infoSource : String?
        get() {
            val o = __offset(120)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val infoSourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(120, 1)
    fun infoSourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 120, 1)
    /**
     * Flag indicating that the missile is currently in a state of boosting, if reporting a missile track.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val boosting : Boolean
        get() {
            val o = __offset(122)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Frequency, in hertz, for the signature report.
     * Example: /// Example: 63.65
     * Constraints: No constraints specified.
     */
    val freq : Double
        get() {
            val o = __offset(124)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Maximum frequency, in hertz, reported for this acoustic track.
     * Example: /// Example: 10324.53
     * Constraints: No constraints specified.
     */
    val maxFreq : Double
        get() {
            val o = __offset(126)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * List of harmonics of the signature report in descending order of predominance using 1-2 digit combinations separated by commas, e.g., 8,12,4. (1-22NS).
     * Example: /// Example: 8,12,4
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val harmonics : String?
        get() {
            val o = __offset(128)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val harmonicsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(128, 1)
    fun harmonicsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 128, 1)
    /**
     * Pulse repetition interval of the emitter, measured in microseconds.  The interval between the start of one pulse and the start of another.
     * Example: /// Example: 56657.2238
     * Constraints: No constraints specified.
     */
    val pri : Double
        get() {
            val o = __offset(130)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Pulse repetition frequency of the emitter, measured in pulses per second.  PRF is the number of pulses transmitted per second. This is the reciprocal of the pri value.
     * Example: /// Example: 17.65
     * Constraints: No constraints specified.
     */
    val prf : Double
        get() {
            val o = __offset(132)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Pulse width of the emitter, measured in microseconds.  This is the duration of the pulse.
     * Example: /// Example: 1347.45
     * Constraints: No constraints specified.
     */
    val pw : Double
        get() {
            val o = __offset(134)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Type of radar scan.
     * Example: /// Example: UNK
     * Constraints: Minimum length = 0, Maximum length = 5
     */
    val scanType : String?
        get() {
            val o = __offset(136)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val scanTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(136, 1)
    fun scanTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 136, 1)
    /**
     * Scan rate of the emitter, measured in seconds per rotation (SPR).
     * Example: /// Example: 12.01
     * Constraints: No constraints specified.
     */
    val scanRate : Double
        get() {
            val o = __offset(138)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The Sequential Contact Number (SCN) for this track.
     * Example: /// Example: 1474305
     * Constraints: No constraints specified.
     */
    val scn : Int
        get() {
            val o = __offset(140)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Correlation Index; reference code for the site that originally reported the track.
     * Example: /// Example: BB
     * Constraints: Minimum length = 0, Maximum length = 3
     */
    val cI : String?
        get() {
            val o = __offset(142)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val cIAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(142, 1)
    fun cIInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 142, 1)
    /**
     * The angle formed between the line of sight of the observer and the horizon, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
     * Example: /// Example: 15.2
     * Constraints: No constraints specified.
     */
    val angElev : Double
        get() {
            val o = __offset(144)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
     * Example: /// Example: 19.88550102
     * Constraints: No constraints specified.
     */
    val lat : Double
        get() {
            val o = __offset(146)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
     * Example: /// Example: 46.74596844
     * Constraints: No constraints specified.
     */
    val lon : Double
        get() {
            val o = __offset(148)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
     * Example: /// Example: 19.88550102
     * Constraints: No constraints specified.
     */
    val launchLat : Double
        get() {
            val o = __offset(150)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
     * Example: /// Example: 46.74550102
     * Constraints: No constraints specified.
     */
    val launchLon : Double
        get() {
            val o = __offset(152)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 latitude of the missile impact point, in degrees. -90 to 90 degrees (negative values south of equator).
     * Example: /// Example: 19.88550102
     * Constraints: No constraints specified.
     */
    val impactLat : Double
        get() {
            val o = __offset(154)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 longitude of the missile impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
     * Example: /// Example: 46.74550102
     * Constraints: No constraints specified.
     */
    val impactLon : Double
        get() {
            val o = __offset(156)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 azimuth corridor reference point latitude, in degrees. -90 to 90 degrees (negative values south of equator).
     * Example: /// Example: 19.88550102
     * Constraints: No constraints specified.
     */
    val polarSingLocLat : Double
        get() {
            val o = __offset(158)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 azimuth corridor reference point longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
     * Example: /// Example: 46.74550102
     * Constraints: No constraints specified.
     */
    val polarSingLocLon : Double
        get() {
            val o = __offset(160)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The azimuth corridor centerline angle measured in degrees clockwise from true north, of the center line of an azimuth corridor. The center line extends from the referenced corridor origin location.
     * Example: /// Example: 12.876
     * Constraints: No constraints specified.
     */
    val azCorrCenterLine : Double
        get() {
            val o = __offset(162)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Azimuth corridor arc distance measured in meters from reference point of azimuth corridor to far edge of bounded azimuth corridor wedge, measured along azimuth corridor center line.
     * Example: /// Example: 71.76
     * Constraints: No constraints specified.
     */
    val azCorrArcWidth : Double
        get() {
            val o = __offset(164)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The error in the semi-intermediate axis.  The semi-intermediate axis is intermediate in length between semi-major and semi-minor axes. This field is doubled and centered on intersection of area semi-major axis and area semi-minor axis at 90 degrees to the plane defined by those axes. For these shapes, the volume is defined as having a 50-percent probability of containing the true location of the referenced entity.
     * Example: /// Example: 7010.882
     * Constraints: No constraints specified.
     */
    val errSemiIntAxis : Double
        get() {
            val o = __offset(166)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The error in the Area Orientation.  Area Orientation is the angle or roll in degrees, between area semi-minor axis and plane defined by local vertical and area semi-major axis. When reported without major and minor axis, it is angle between an axis perpendicular to a 2D true north axis and plane defined by local vertical and a 2D true north axis.
     * Example: /// Example: 69.6
     * Constraints: No constraints specified.
     */
    val errAreaOrient : Double
        get() {
            val o = __offset(168)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The error in the Semi-major elevation axis. Semi-major elevation axis is the elevation of the cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical semi-major axis, in degrees, measured from local horizontal.
     * Example: /// Example: 168.8
     * Constraints: No constraints specified.
     */
    val errSemiMajElev : Double
        get() {
            val o = __offset(170)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Geometric area switch identifies the 3D shape of the error volume by providing the 2D shape for the 3D plane. The 3D plane is the plane orthogonal to the area semi-major axis and area semi-minor axis. Depending on whether the 2D plane is reported as an error ellipse 2D or as an error rectangle 2D, this switch reports a complete error volume that is cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical.
     * 0 - SWITCH_TYPE_UNKNOWN
     * 1 - SQUARE_RECTANGLE
     * 2 - CIRCLE_ELLIPSE.
     * Example: /// Example: CIRCLE_ELLIPSE
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val errGeoAreaSwitch : String?
        get() {
            val o = __offset(172)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val errGeoAreaSwitchAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(172, 1)
    fun errGeoAreaSwitchInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 172, 1)
    /**
     * Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
     * Example: /// Example: 30567.452
     * Constraints: No constraints specified.
     */
    val burnoutAlt : Double
        get() {
            val o = __offset(174)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Threat Event System Track ID.
     * Example: /// Example: 6217
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val tesEventId : String?
        get() {
            val o = __offset(176)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val tesEventIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(176, 1)
    fun tesEventIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 176, 1)
    /**
     * Track object speed, in meters/sec.
     * Example: /// Example: 15.03443
     * Constraints: No constraints specified.
     */
    val spd : Double
        get() {
            val o = __offset(178)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The average speed, in kilometers/hour, calculated for the subject during the latest voyage/excursion.
     * Example: /// Example: 18.25
     * Constraints: No constraints specified.
     */
    val avgSpd : Double
        get() {
            val o = __offset(180)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Motion model Time On Leg in hours.
     * Example: /// Example: 4.1
     * Constraints: No constraints specified.
     */
    val tol : Double
        get() {
            val o = __offset(182)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
     * Example: /// Example: 153.01
     * Constraints: No constraints specified.
     */
    val alt : Double
        get() {
            val o = __offset(184)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Track object heading, in degrees clockwise from true north.
     * Example: /// Example: 19.7
     * Constraints: No constraints specified.
     */
    val hdng : Double
        get() {
            val o = __offset(186)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
     * Example: /// Example: 4.3580153
     * Constraints: No constraints specified.
     */
    val course : Double
        get() {
            val o = __offset(188)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The number of propeller revolutions per minute for a submarine or ship.
     * Example: /// Example: 8.2
     * Constraints: No constraints specified.
     */
    val propRpm : Double
        get() {
            val o = __offset(190)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The number of turns of the vessel propellers per knot of forward motion.
     * Example: /// Example: 2.65
     * Constraints: No constraints specified.
     */
    val tpk : Double
        get() {
            val o = __offset(192)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The Cooperative Location Indicator specifies whether the reported entity location was derived using reported locations from sensors on more than one platform.
     * 0 - COOPERATIVE_LOCATOR_NONE
     * 1 - SINGLE_PLATFORM
     * 2 - FRAGMENT
     * 3 - COOPERATIVE.
     * Example: /// Example: COOPERATIVE
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val coopLocInd : String?
        get() {
            val o = __offset(194)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val coopLocIndAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(194, 1)
    fun coopLocIndInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 194, 1)
    /**
     * The manuevering indicator specifying the missile boost phase.
     * 0 - POST_BOOST_NONE
     * 1 - POST_BOOST_MANUEVER
     * 2 - POST_BOOST_COMPLETE_MANUEVER.
     * Example: /// Example: POST_BOOST_NONE
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val maneuverInd : String?
        get() {
            val o = __offset(196)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val maneuverIndAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(196, 1)
    fun maneuverIndInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 196, 1)
    /**
     * The launch location Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the launchAouData array and is required if launchAouData is not null. See the launchAouData field definition for specific information.
     * Example: /// Example: ELLIPSE
     * Constraints: Minimum length = 0, Maximum length = 20
     */
    val launchAouType : String?
        get() {
            val o = __offset(198)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val launchAouTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(198, 1)
    fun launchAouTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 198, 1)
    /**
     * Three element array representing the launch location Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the launchAouType specified in this record:
     *  ELLIPSE:
     *    brg - orientation in degrees of the ellipse
     *    a1 - semi-major axis in meters
     *    a2 - semi-minor axis in meters
     *  BEARING (BEARING BOX or MTST BEARING BOX):
     *    brg - orientation in degrees of the bearing box
     *    a1 - length of bearing box in meters
     *    a2 - half-width of bearing box in meters
     *  OTHER (All other type values):
     *    brg - line of bearing in degrees true
     *    a1 - bearing error in degrees
     *    a2 - estimated range in meters.
     * Example: /// Example: [34.3, 26.5, 1.2]
     * Constraints: No constraints specified.
     */
    fun launchAouData(j: Int) : String? {
        val o = __offset(200)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val launchAouDataLength : Int
        get() {
            val o = __offset(200); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The impact point Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the impactAouData array and is required if impactAouData is not null. See the impactAouData field definition for specific information.
     * Example: /// Example: ELLIPSE
     * Constraints: Minimum length = 0, Maximum length = 20
     */
    val impactAouType : String?
        get() {
            val o = __offset(202)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val impactAouTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(202, 1)
    fun impactAouTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 202, 1)
    /**
     * Three element array representing the impact point Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the impactAouType specified in this record:
     *  ELLIPSE:
     *    brg - orientation in degrees of the ellipse
     *    a1 - semi-major axis in meters
     *    a2 - semi-minor axis in meters
     *  BEARING (BEARING BOX or MTST BEARING BOX):
     *    brg - orientation in degrees of the bearing box
     *    a1 - length of bearing box in meters
     *    a2 - half-width of bearing box in meters
     *  OTHER (All other type values):
     *    brg - line of bearing in degrees true
     *    a1 - bearing error in degrees
     *    a2 - estimated range in meters.
     * Example: /// Example: [34.3, 26.5, 1.2]
     * Constraints: No constraints specified.
     */
    fun impactAouData(j: Int) : String? {
        val o = __offset(204)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val impactAouDataLength : Int
        get() {
            val o = __offset(204); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The track Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouRptData array and is required if aouRptData is not null. See the aouRptData field definition for specific information.
     * Example: /// Example: ELLIPSE
     * Constraints: Minimum length = 0, Maximum length = 20
     */
    val aouRptType : String?
        get() {
            val o = __offset(206)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val aouRptTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(206, 1)
    fun aouRptTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 206, 1)
    /**
     * Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouRptType specified in this record:
     *  ELLIPSE:
     *    brg - orientation in degrees of the ellipse
     *    a1 - semi-major axis in meters
     *    a2 - semi-minor axis in meters
     *  BEARING (BEARING BOX or MTST BEARING BOX):
     *    brg - orientation in degrees of the bearing box
     *    a1 - length of bearing box in meters
     *    a2 - half-width of bearing box in meters
     *  OTHER (All other type values):
     *    brg - line of bearing in degrees true
     *    a1 - bearing error in degrees
     *    a2 - estimated range in meters.
     * Example: /// Example: [34.3, 26.5, 1.2]
     * Constraints: No constraints specified.
     */
    fun aouRptData(j: Int) : String? {
        val o = __offset(208)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val aouRptDataLength : Int
        get() {
            val o = __offset(208); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
     * Example: /// Example: [1.23, 2.35, 3.42]
     * Constraints: No constraints specified.
     */
    fun ecefPos(j: Int) : String? {
        val o = __offset(210)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val ecefPosLength : Int
        get() {
            val o = __offset(210); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
     * Example: /// Example: [1.23, 2.35, 3.42]
     * Constraints: No constraints specified.
     */
    fun ecefVel(j: Int) : String? {
        val o = __offset(212)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val ecefVelLength : Int
        get() {
            val o = __offset(212); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
     * Example: /// Example: 97
     * Constraints: No constraints specified.
     */
    val containment : Double
        get() {
            val o = __offset(214)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The distance, in meters, of the closest point of approach between this track to the master reference track.
     * Example: /// Example: 500
     * Constraints: No constraints specified.
     */
    val cpa : Double
        get() {
            val o = __offset(216)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The time, in ISO 8601 UTC format with millisecond precision, of the  closest point of approach between this track and the master reference track.
     * Example: /// Example: 2021-02-25T12:00:00.123Z
     * Constraints: No constraints specified.
     */
    val tcpa : String?
        get() {
            val o = __offset(218)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val tcpaAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(218, 1)
    fun tcpaInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 218, 1)
    /**
     * The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
     * Example: /// Example: Underway Using Engine
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val navStatus : String?
        get() {
            val o = __offset(220)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val navStatusAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(220, 1)
    fun navStatusInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 220, 1)
    /**
     * The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
     * Example: /// Example: GPS
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val posDeviceType : String?
        get() {
            val o = __offset(222)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val posDeviceTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(222, 1)
    fun posDeviceTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 222, 1)
    /**
     * Type of Aid to Navigation. Intended as, but not constrained to, the USCG NAVCEN  aids to navigation. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
     * Example: /// Example: Cardinal Mark N
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val aton : String?
        get() {
            val o = __offset(224)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val atonAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(224, 1)
    fun atonInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 224, 1)
    /**
     * Indicator position (OFF, ON, UNK) for optional floating navigational aids only.
     * Example: /// Example: ON
     * Constraints: Minimum length = 0, Maximum length = 3
     */
    val offPosInd : String?
        get() {
            val o = __offset(226)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val offPosIndAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(226, 1)
    fun offPosIndInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 226, 1)
    /**
     * The reference dimensions of the vessel, reported as [A, B, C, D], in meters. Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna. Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
     * Example: /// Example: [50.1, 50.1, 20.1, 20.1]
     * Constraints: No constraints specified.
     */
    fun antennaRefDimensions(j: Int) : String? {
        val o = __offset(228)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val antennaRefDimensionsLength : Int
        get() {
            val o = __offset(228); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The common name for a group of ships with similar design, usually named for the first vessel of the class.
     * Example: /// Example: Nimitz
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val shipClass : String?
        get() {
            val o = __offset(230)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val shipClassAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(230, 1)
    fun shipClassInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 230, 1)
    /**
     * The International Maritime Organization Number of the vessel. IMON is a seven-digit number that uniquely identifies the vessel.
     * Example: /// Example: 9015462
     * Constraints: No constraints specified.
     */
    val imon : Int
        get() {
            val o = __offset(232)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The Maritime Mobile Service Identity of the vessel. MMSI is a nine-digit number that identifies the transmitter station of the vessel.
     * Example: /// Example: 304010417
     * Constraints: No constraints specified.
     */
    val mmsi : Int
        get() {
            val o = __offset(234)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The maximum static draught, in meters, of the vessel according to the AIS transmission.
     * Example: /// Example: 21.1
     * Constraints: No constraints specified.
     */
    val draught : Double
        get() {
            val o = __offset(236)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The overall length of the vessel, in meters. A value of 511 indicates a vessel length of 511 meters or greater.
     * Example: /// Example: 511.1
     * Constraints: No constraints specified.
     */
    val length : Double
        get() {
            val o = __offset(238)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The breadth of the vessel, in meters. A value of 63 indicates a vessel breadth of 63 meters or greater.
     * Example: /// Example: 24.1
     * Constraints: No constraints specified.
     */
    val width : Double
        get() {
            val o = __offset(240)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
     * Example: /// Example: Freight
     * Constraints: Minimum length = 0, Maximum length = 48
     */
    val cargoType : String?
        get() {
            val o = __offset(242)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val cargoTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(242, 1)
    fun cargoTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 242, 1)
    /**
     * Appearance group code.
     * GP1 - Superstructure exceeds 1/3 of ship length.
     * GP2 - Superstructure less than 1/3 of ship length.
     * GP3 - Stack aft.
     * Example: /// Example: GP1
     * Constraints: Minimum length = 0, Maximum length = 7
     */
    val appGrp : String?
        get() {
            val o = __offset(244)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val appGrpAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(244, 1)
    fun appGrpInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 244, 1)
    /**
     * Hull profile code. Based on GCCS-J hull profiles.
     * FLUSH           No breaks in Hull Profile.
     * RAISED 1        Hull Profile shows distinct raised area at bow. Remainder of deck is flush.
     * RAISED 2        Hull Profile shows distinct raised area amidships. Bow and stern are flush.
     * RAISED 3        Hull Profile shows distinct raised area at stern. Remainder of deck is flush.
     * RAISED 1-2-3    Distinct raised areas at bow, midships, and stern with breaks between each raise.
     * RAISED 1-2      Raised area at bow and midships with break between.
     * RAISED 1-3      Raised area at bow and stern with break between.
     * RAISED 12       Continuous raised area encompassing both bow and midships.
     * RAISED 23       Continuous raised area encompassing midships and stern.
     * RAISED 12-3     Raised areas at bow, midships and stern. Bow and midship raises are continuous. Break between midship and stern raises.
     * RAISED 1-23     Raised areas at bow, midships, and stern. Midship and stern raises are continuous with break between bow and midship raises.
     * RAISED 1-L2-3   Raised areas at bow, midships, and stern with break between each raise. Midships raise is longer than that associated with raised 1-2-3.
     * Example: /// Example: Raised 1-23
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val hullProf : String?
        get() {
            val o = __offset(246)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val hullProfAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(246, 1)
    fun hullProfInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 246, 1)
    /**
     * The type of propulsion employed by the track object (Diesel, Nuclear).
     * Example: /// Example: Diesel
     * Constraints: Minimum length = 0, Maximum length = 6
     */
    val propType : String?
        get() {
            val o = __offset(248)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val propTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(248, 1)
    fun propTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 248, 1)
    /**
     * The number of blades per shaft of the track object.  Applicable for maritime vessels.
     * Example: /// Example: 4
     * Constraints: No constraints specified.
     */
    val numBlades : Int
        get() {
            val o = __offset(250)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The number of shafts on the track object.  Applicable for maritime vessels.
     * Example: /// Example: 3
     * Constraints: No constraints specified.
     */
    val numShafts : Int
        get() {
            val o = __offset(252)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The stern type code (Counter, Cruiser) associated with the track object.
     * Example: /// Example: Cruiser
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val sternType : String?
        get() {
            val o = __offset(254)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sternTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(254, 1)
    fun sternTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 254, 1)
    /**
     * The weight, in tons, of the vessel associated with this track.
     * Example: /// Example: 3423.76
     * Constraints: No constraints specified.
     */
    val vslWt : Double
        get() {
            val o = __offset(256)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The Arrival Time of the vessel at the destination, in ISO 8601 UTC format with microsecond precision.
     * Example: /// Example: 2021-02-25T12:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val arrTime : String?
        get() {
            val o = __offset(258)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val arrTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(258, 1)
    fun arrTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 258, 1)
    /**
     * The flag of the arrival port.
     * Example: /// Example: USA
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val arrFlag : String?
        get() {
            val o = __offset(260)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val arrFlagAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(260, 1)
    fun arrFlagInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 260, 1)
    /**
     * The reported arrival cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
     * Example: /// Example: Freight
     * Constraints: Minimum length = 0, Maximum length = 48
     */
    val arrCargo : String?
        get() {
            val o = __offset(262)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val arrCargoAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(262, 1)
    fun arrCargoInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 262, 1)
    /**
     * The Arrival Port of the vessel according to the AIS transmission.
     * Example: /// Example: Lanshan
     * Constraints: Minimum length = 0, Maximum length = 20
     */
    val arrPort : String?
        get() {
            val o = __offset(264)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val arrPortAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(264, 1)
    fun arrPortInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 264, 1)
    /**
     * The Departure Port of the vessel according to the AIS transmission.
     * Example: /// Example: Lanshan
     * Constraints: Minimum length = 0, Maximum length = 20
     */
    val depPort : String?
        get() {
            val o = __offset(266)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val depPortAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(266, 1)
    fun depPortInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 266, 1)
    /**
     * The flag of the departure port.
     * Example: /// Example: USA
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val depFlag : String?
        get() {
            val o = __offset(268)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val depFlagAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(268, 1)
    fun depFlagInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 268, 1)
    /**
     * The reported departure cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
     * Example: /// Example: Freight
     * Constraints: Minimum length = 0, Maximum length = 48
     */
    val depCargo : String?
        get() {
            val o = __offset(270)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val depCargoAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(270, 1)
    fun depCargoInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 270, 1)
    /**
     * The flag of the destination port.
     * Example: /// Example: USA
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val desFlag : String?
        get() {
            val o = __offset(272)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val desFlagAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(272, 1)
    fun desFlagInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 272, 1)
    /**
     * The reported destination cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
     * Example: /// Example: Freight
     * Constraints: Minimum length = 0, Maximum length = 48
     */
    val desCargo : String?
        get() {
            val o = __offset(274)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val desCargoAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(274, 1)
    fun desCargoInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 274, 1)
    /**
     * The destination of the vessel according to the AIS transmission.
     * Example: /// Example: USCLE
     * Constraints: Minimum length = 0, Maximum length = 20
     */
    val destination : String?
        get() {
            val o = __offset(276)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val destinationAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(276, 1)
    fun destinationInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 276, 1)
    /**
     * The Estimated Time of Arrival of the vessel at the destination port, in ISO 8601 UTC format with microsecond precision.
     * Example: /// Example: 2021-02-25T12:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val eta : String?
        get() {
            val o = __offset(278)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val etaAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(278, 1)
    fun etaInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 278, 1)
    /**
     * The Estimated Time of Departure of the vessel from the departure port (depPort), according to Marine Traffic calculations, in ISO 8601 UTC format with microsecond precision.
     * Example: /// Example: 2021-02-25T12:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val etd : String?
        get() {
            val o = __offset(280)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val etdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(280, 1)
    fun etdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 280, 1)
    /**
     * A text amplifier displaying IFF/SIF/AIS Identification modes and codes.
     * Example: /// Example: ID Mode
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val iff : String?
        get() {
            val o = __offset(282)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val iffAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(282, 1)
    fun iffInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 282, 1)
    /**
     * Flag indicating that the track object has an emergency.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val emgInd : Boolean
        get() {
            val o = __offset(284)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * The drop-point indicator setting.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val dropPtInd : Boolean
        get() {
            val o = __offset(286)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val reinforced : Boolean
        get() {
            val o = __offset(288)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Flag indicating for the track represents a reduced force object or group.  Based on MIL-STD-2525 symbology definitions.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val reduced : Boolean
        get() {
            val o = __offset(290)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val hq : Boolean
        get() {
            val o = __offset(292)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val dummy : Boolean
        get() {
            val o = __offset(294)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val taskForce : Boolean
        get() {
            val o = __offset(296)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val feint : Boolean
        get() {
            val o = __offset(298)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val installation : Boolean
        get() {
            val o = __offset(300)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * A text amplifier for units, equipment and installations; content is implementation specific.
     * Example: /// Example: Staff Comments
     * Constraints: Minimum length = 0, Maximum length = 256
     */
    val staffCmts : String?
        get() {
            val o = __offset(302)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val staffCmtsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(302, 1)
    fun staffCmtsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 302, 1)
    /**
     * A text amplifier for units, equipment and installations; content is implementation specific.
     * Example: /// Example: Additional information
     * Constraints: Minimum length = 0, Maximum length = 256
     */
    val addInfo : String?
        get() {
            val o = __offset(304)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val addInfoAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(304, 1)
    fun addInfoInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 304, 1)
    /**
     * A text amplifier code for units, equipment, and installations that consists of a one-letter reliability rating and a one-number credibility rating based on the following definitions of each:
     *  Reliability Ratings:
     *   A-completely reliable
     *   B-usually reliable
     *   C-fairly reliable
     *   D-not usually reliable
     *   E-unreliable
     *   F-reliability cannot be judged
     *  Credibility Ratings:
     *   1-confirmed by other sources
     *   2-probably true
     *   3-possibly true
     *   4-doubtfully true
     *   5-improbable
     *   6-truth cannot be judged.
     * Example: /// Example: A1
     * Constraints: Minimum length = 0, Maximum length = 2
     */
    val evalRating : String?
        get() {
            val o = __offset(306)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val evalRatingAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(306, 1)
    fun evalRatingInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 306, 1)
    /**
     * Time the row was created in the database.
     * Example: /// Example: 2021-02-25T12:00:00.123Z
     * Constraints: No constraints specified.
     */
    val createdAt : String?
        get() {
            val o = __offset(308)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdAtAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(308, 1)
    fun createdAtInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 308, 1)
    /**
     * Application user who created the row in the database.
     * Example: /// Example: some.user
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val createdBy : String?
        get() {
            val o = __offset(310)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdByAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(310, 1)
    fun createdByInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 310, 1)
    /**
     * Source of the data.
     * Example: /// Example: Bluestaq
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val source : String?
        get() {
            val o = __offset(312)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(312, 1)
    fun sourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 312, 1)
    /**
     * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     * Example: /// Example: THIRD_PARTY_DATASOURCE
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origin : String?
        get() {
            val o = __offset(314)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val originAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(314, 1)
    fun originInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 314, 1)
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
     * Example: /// Example: TEST
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val dataMode : Byte
        get() {
            val o = __offset(316)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * The originating source network on which this record was created, auto-populated by the system.
     * Example: /// Example: ORIG
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val origNetwork : String?
        get() {
            val o = __offset(318)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origNetworkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(318, 1)
    fun origNetworkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 318, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsTrackDetails_Full(_bb: ByteBuffer): TrackDetails_Full = getRootAsTrackDetails_Full(_bb, TrackDetails_Full())
        fun getRootAsTrackDetails_Full(_bb: ByteBuffer, obj: TrackDetails_Full): TrackDetails_Full {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun TrackDetails_FullBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "TRAC")
        fun startTrackDetails_Full(builder: FlatBufferBuilder) = builder.startTable(158)
        fun addId(builder: FlatBufferBuilder, id: Int) = builder.addOffset(0, id, 0)
        fun addClassificationMarking(builder: FlatBufferBuilder, classificationMarking: Int) = builder.addOffset(1, classificationMarking, 0)
        fun addEnv(builder: FlatBufferBuilder, env: Byte) = builder.addByte(2, env, 0)
        fun addMsgType(builder: FlatBufferBuilder, msgType: Int) = builder.addOffset(3, msgType, 0)
        fun addHullNum(builder: FlatBufferBuilder, hullNum: Int) = builder.addOffset(4, hullNum, 0)
        fun addPif(builder: FlatBufferBuilder, pif: Int) = builder.addOffset(5, pif, 0)
        fun addSconum(builder: FlatBufferBuilder, sconum: Int) = builder.addOffset(6, sconum, 0)
        fun addNtds(builder: FlatBufferBuilder, ntds: Int) = builder.addOffset(7, ntds, 0)
        fun addDisId(builder: FlatBufferBuilder, disId: Int) = builder.addOffset(8, disId, 0)
        fun addMidbCat(builder: FlatBufferBuilder, midbCat: Int) = builder.addOffset(9, midbCat, 0)
        fun addBeNumber(builder: FlatBufferBuilder, beNumber: Int) = builder.addOffset(10, beNumber, 0)
        fun addOSuffix(builder: FlatBufferBuilder, oSuffix: Int) = builder.addOffset(11, oSuffix, 0)
        fun addPin(builder: FlatBufferBuilder, pin: Int) = builder.addOffset(12, pin, 0)
        fun addLostTrkInd(builder: FlatBufferBuilder, lostTrkInd: Boolean) = builder.addBoolean(13, lostTrkInd, false)
        fun addMuidSrcTrk(builder: FlatBufferBuilder, muidSrcTrk: Int) = builder.addOffset(14, muidSrcTrk, 0)
        fun addMuidSrc(builder: FlatBufferBuilder, muidSrc: Int) = builder.addOffset(15, muidSrc, 0)
        fun addMslStatus(builder: FlatBufferBuilder, mslStatus: Int) = builder.addOffset(16, mslStatus, 0)
        fun addTrkConf(builder: FlatBufferBuilder, trkConf: Double) = builder.addDouble(17, trkConf, 0.0)
        fun addTrkQual(builder: FlatBufferBuilder, trkQual: Int) = builder.addInt(18, trkQual, 0)
        fun addAlert(builder: FlatBufferBuilder, alert: Int) = builder.addOffset(19, alert, 0)
        fun addOrigXref(builder: FlatBufferBuilder, origXref: Int) = builder.addOffset(20, origXref, 0)
        fun addElnot1(builder: FlatBufferBuilder, elnot1: Int) = builder.addOffset(21, elnot1, 0)
        fun addElnot2(builder: FlatBufferBuilder, elnot2: Int) = builder.addOffset(22, elnot2, 0)
        fun addObjIdent(builder: FlatBufferBuilder, objIdent: Byte) = builder.addByte(23, objIdent, 0)
        fun addObjType(builder: FlatBufferBuilder, objType: Int) = builder.addOffset(24, objType, 0)
        fun addObjPlat(builder: FlatBufferBuilder, objPlat: Int) = builder.addOffset(25, objPlat, 0)
        fun addObjAct(builder: FlatBufferBuilder, objAct: Int) = builder.addOffset(26, objAct, 0)
        fun addObjNat(builder: FlatBufferBuilder, objNat: Int) = builder.addOffset(27, objNat, 0)
        fun addName(builder: FlatBufferBuilder, name: Int) = builder.addOffset(28, name, 0)
        fun addShortName(builder: FlatBufferBuilder, shortName: Int) = builder.addOffset(29, shortName, 0)
        fun addTrkId(builder: FlatBufferBuilder, trkId: Int) = builder.addOffset(30, trkId, 0)
        fun addTrkNum(builder: FlatBufferBuilder, trkNum: Int) = builder.addOffset(31, trkNum, 0)
        fun addTrkScope(builder: FlatBufferBuilder, trkScope: Int) = builder.addOffset(32, trkScope, 0)
        fun addSourceUid(builder: FlatBufferBuilder, sourceUid: Int) = builder.addOffset(33, sourceUid, 0)
        fun addCallSign(builder: FlatBufferBuilder, callSign: Int) = builder.addOffset(34, callSign, 0)
        fun addIdentAmp(builder: FlatBufferBuilder, identAmp: Int) = builder.addOffset(35, identAmp, 0)
        fun addSpaceAmp(builder: FlatBufferBuilder, spaceAmp: Int) = builder.addOffset(36, spaceAmp, 0)
        fun addSpaceAmpConf(builder: FlatBufferBuilder, spaceAmpConf: Int) = builder.addInt(37, spaceAmpConf, 0)
        fun addSpaceSpecType(builder: FlatBufferBuilder, spaceSpecType: Int) = builder.addOffset(38, spaceSpecType, 0)
        fun addAcftSubType(builder: FlatBufferBuilder, acftSubType: Int) = builder.addOffset(39, acftSubType, 0)
        fun addTs(builder: FlatBufferBuilder, ts: Int) = builder.addOffset(40, ts, 0)
        fun addLaunchTime(builder: FlatBufferBuilder, launchTime: Int) = builder.addOffset(41, launchTime, 0)
        fun addImpactTime(builder: FlatBufferBuilder, impactTime: Int) = builder.addOffset(42, impactTime, 0)
        fun addFtnMsgTs(builder: FlatBufferBuilder, ftnMsgTs: Int) = builder.addOffset(43, ftnMsgTs, 0)
        fun addFtn(builder: FlatBufferBuilder, ftn: Int) = builder.addOffset(44, ftn, 0)
        fun addFtnCmd(builder: FlatBufferBuilder, ftnCmd: Int) = builder.addOffset(45, ftnCmd, 0)
        fun addRtnMsgTs(builder: FlatBufferBuilder, rtnMsgTs: Int) = builder.addOffset(46, rtnMsgTs, 0)
        fun createRtnMsgTsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startRtnMsgTsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addRtn(builder: FlatBufferBuilder, rtn: Int) = builder.addOffset(47, rtn, 0)
        fun createRtnVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startRtnVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addRtnTrkState(builder: FlatBufferBuilder, rtnTrkState: Int) = builder.addOffset(48, rtnTrkState, 0)
        fun addRtnCmd(builder: FlatBufferBuilder, rtnCmd: Int) = builder.addOffset(49, rtnCmd, 0)
        fun addSen(builder: FlatBufferBuilder, sen: Int) = builder.addOffset(50, sen, 0)
        fun addRptChxref(builder: FlatBufferBuilder, rptChxref: Int) = builder.addOffset(51, rptChxref, 0)
        fun addRptArchived(builder: FlatBufferBuilder, rptArchived: Boolean) = builder.addBoolean(52, rptArchived, false)
        fun addSelfReport(builder: FlatBufferBuilder, selfReport: Boolean) = builder.addBoolean(53, selfReport, false)
        fun addMil2525Bstr(builder: FlatBufferBuilder, mil2525Bstr: Int) = builder.addOffset(54, mil2525Bstr, 0)
        fun addTrnspdrId(builder: FlatBufferBuilder, trnspdrId: Int) = builder.addOffset(55, trnspdrId, 0)
        fun addTrnspdrType(builder: FlatBufferBuilder, trnspdrType: Int) = builder.addOffset(56, trnspdrType, 0)
        fun addEmitterName(builder: FlatBufferBuilder, emitterName: Int) = builder.addOffset(57, emitterName, 0)
        fun addInfoSource(builder: FlatBufferBuilder, infoSource: Int) = builder.addOffset(58, infoSource, 0)
        fun addBoosting(builder: FlatBufferBuilder, boosting: Boolean) = builder.addBoolean(59, boosting, false)
        fun addFreq(builder: FlatBufferBuilder, freq: Double) = builder.addDouble(60, freq, 0.0)
        fun addMaxFreq(builder: FlatBufferBuilder, maxFreq: Double) = builder.addDouble(61, maxFreq, 0.0)
        fun addHarmonics(builder: FlatBufferBuilder, harmonics: Int) = builder.addOffset(62, harmonics, 0)
        fun addPri(builder: FlatBufferBuilder, pri: Double) = builder.addDouble(63, pri, 0.0)
        fun addPrf(builder: FlatBufferBuilder, prf: Double) = builder.addDouble(64, prf, 0.0)
        fun addPw(builder: FlatBufferBuilder, pw: Double) = builder.addDouble(65, pw, 0.0)
        fun addScanType(builder: FlatBufferBuilder, scanType: Int) = builder.addOffset(66, scanType, 0)
        fun addScanRate(builder: FlatBufferBuilder, scanRate: Double) = builder.addDouble(67, scanRate, 0.0)
        fun addScn(builder: FlatBufferBuilder, scn: Int) = builder.addInt(68, scn, 0)
        fun addCI(builder: FlatBufferBuilder, cI: Int) = builder.addOffset(69, cI, 0)
        fun addAngElev(builder: FlatBufferBuilder, angElev: Double) = builder.addDouble(70, angElev, 0.0)
        fun addLat(builder: FlatBufferBuilder, lat: Double) = builder.addDouble(71, lat, 0.0)
        fun addLon(builder: FlatBufferBuilder, lon: Double) = builder.addDouble(72, lon, 0.0)
        fun addLaunchLat(builder: FlatBufferBuilder, launchLat: Double) = builder.addDouble(73, launchLat, 0.0)
        fun addLaunchLon(builder: FlatBufferBuilder, launchLon: Double) = builder.addDouble(74, launchLon, 0.0)
        fun addImpactLat(builder: FlatBufferBuilder, impactLat: Double) = builder.addDouble(75, impactLat, 0.0)
        fun addImpactLon(builder: FlatBufferBuilder, impactLon: Double) = builder.addDouble(76, impactLon, 0.0)
        fun addPolarSingLocLat(builder: FlatBufferBuilder, polarSingLocLat: Double) = builder.addDouble(77, polarSingLocLat, 0.0)
        fun addPolarSingLocLon(builder: FlatBufferBuilder, polarSingLocLon: Double) = builder.addDouble(78, polarSingLocLon, 0.0)
        fun addAzCorrCenterLine(builder: FlatBufferBuilder, azCorrCenterLine: Double) = builder.addDouble(79, azCorrCenterLine, 0.0)
        fun addAzCorrArcWidth(builder: FlatBufferBuilder, azCorrArcWidth: Double) = builder.addDouble(80, azCorrArcWidth, 0.0)
        fun addErrSemiIntAxis(builder: FlatBufferBuilder, errSemiIntAxis: Double) = builder.addDouble(81, errSemiIntAxis, 0.0)
        fun addErrAreaOrient(builder: FlatBufferBuilder, errAreaOrient: Double) = builder.addDouble(82, errAreaOrient, 0.0)
        fun addErrSemiMajElev(builder: FlatBufferBuilder, errSemiMajElev: Double) = builder.addDouble(83, errSemiMajElev, 0.0)
        fun addErrGeoAreaSwitch(builder: FlatBufferBuilder, errGeoAreaSwitch: Int) = builder.addOffset(84, errGeoAreaSwitch, 0)
        fun addBurnoutAlt(builder: FlatBufferBuilder, burnoutAlt: Double) = builder.addDouble(85, burnoutAlt, 0.0)
        fun addTesEventId(builder: FlatBufferBuilder, tesEventId: Int) = builder.addOffset(86, tesEventId, 0)
        fun addSpd(builder: FlatBufferBuilder, spd: Double) = builder.addDouble(87, spd, 0.0)
        fun addAvgSpd(builder: FlatBufferBuilder, avgSpd: Double) = builder.addDouble(88, avgSpd, 0.0)
        fun addTol(builder: FlatBufferBuilder, tol: Double) = builder.addDouble(89, tol, 0.0)
        fun addAlt(builder: FlatBufferBuilder, alt: Double) = builder.addDouble(90, alt, 0.0)
        fun addHdng(builder: FlatBufferBuilder, hdng: Double) = builder.addDouble(91, hdng, 0.0)
        fun addCourse(builder: FlatBufferBuilder, course: Double) = builder.addDouble(92, course, 0.0)
        fun addPropRPM(builder: FlatBufferBuilder, propRpm: Double) = builder.addDouble(93, propRpm, 0.0)
        fun addTpk(builder: FlatBufferBuilder, tpk: Double) = builder.addDouble(94, tpk, 0.0)
        fun addCoopLocInd(builder: FlatBufferBuilder, coopLocInd: Int) = builder.addOffset(95, coopLocInd, 0)
        fun addManeuverInd(builder: FlatBufferBuilder, maneuverInd: Int) = builder.addOffset(96, maneuverInd, 0)
        fun addLaunchAouType(builder: FlatBufferBuilder, launchAouType: Int) = builder.addOffset(97, launchAouType, 0)
        fun addLaunchAouData(builder: FlatBufferBuilder, launchAouData: Int) = builder.addOffset(98, launchAouData, 0)
        fun createLaunchAouDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startLaunchAouDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addImpactAouType(builder: FlatBufferBuilder, impactAouType: Int) = builder.addOffset(99, impactAouType, 0)
        fun addImpactAouData(builder: FlatBufferBuilder, impactAouData: Int) = builder.addOffset(100, impactAouData, 0)
        fun createImpactAouDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startImpactAouDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addAouRptType(builder: FlatBufferBuilder, aouRptType: Int) = builder.addOffset(101, aouRptType, 0)
        fun addAouRptData(builder: FlatBufferBuilder, aouRptData: Int) = builder.addOffset(102, aouRptData, 0)
        fun createAouRptDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAouRptDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addEcefPos(builder: FlatBufferBuilder, ecefPos: Int) = builder.addOffset(103, ecefPos, 0)
        fun createEcefPosVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startEcefPosVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addEcefVel(builder: FlatBufferBuilder, ecefVel: Int) = builder.addOffset(104, ecefVel, 0)
        fun createEcefVelVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startEcefVelVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addContainment(builder: FlatBufferBuilder, containment: Double) = builder.addDouble(105, containment, 0.0)
        fun addCpa(builder: FlatBufferBuilder, cpa: Double) = builder.addDouble(106, cpa, 0.0)
        fun addTcpa(builder: FlatBufferBuilder, tcpa: Int) = builder.addOffset(107, tcpa, 0)
        fun addNavStatus(builder: FlatBufferBuilder, navStatus: Int) = builder.addOffset(108, navStatus, 0)
        fun addPosDeviceType(builder: FlatBufferBuilder, posDeviceType: Int) = builder.addOffset(109, posDeviceType, 0)
        fun addAton(builder: FlatBufferBuilder, aton: Int) = builder.addOffset(110, aton, 0)
        fun addOffPosInd(builder: FlatBufferBuilder, offPosInd: Int) = builder.addOffset(111, offPosInd, 0)
        fun addAntennaRefDimensions(builder: FlatBufferBuilder, antennaRefDimensions: Int) = builder.addOffset(112, antennaRefDimensions, 0)
        fun createAntennaRefDimensionsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAntennaRefDimensionsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addShipClass(builder: FlatBufferBuilder, shipClass: Int) = builder.addOffset(113, shipClass, 0)
        fun addImon(builder: FlatBufferBuilder, imon: Int) = builder.addInt(114, imon, 0)
        fun addMmsi(builder: FlatBufferBuilder, mmsi: Int) = builder.addInt(115, mmsi, 0)
        fun addDraught(builder: FlatBufferBuilder, draught: Double) = builder.addDouble(116, draught, 0.0)
        fun addLength(builder: FlatBufferBuilder, length: Double) = builder.addDouble(117, length, 0.0)
        fun addWidth(builder: FlatBufferBuilder, width: Double) = builder.addDouble(118, width, 0.0)
        fun addCargoType(builder: FlatBufferBuilder, cargoType: Int) = builder.addOffset(119, cargoType, 0)
        fun addAppGrp(builder: FlatBufferBuilder, appGrp: Int) = builder.addOffset(120, appGrp, 0)
        fun addHullProf(builder: FlatBufferBuilder, hullProf: Int) = builder.addOffset(121, hullProf, 0)
        fun addPropType(builder: FlatBufferBuilder, propType: Int) = builder.addOffset(122, propType, 0)
        fun addNumBlades(builder: FlatBufferBuilder, numBlades: Int) = builder.addInt(123, numBlades, 0)
        fun addNumShafts(builder: FlatBufferBuilder, numShafts: Int) = builder.addInt(124, numShafts, 0)
        fun addSternType(builder: FlatBufferBuilder, sternType: Int) = builder.addOffset(125, sternType, 0)
        fun addVslWt(builder: FlatBufferBuilder, vslWt: Double) = builder.addDouble(126, vslWt, 0.0)
        fun addArrTime(builder: FlatBufferBuilder, arrTime: Int) = builder.addOffset(127, arrTime, 0)
        fun addArrFlag(builder: FlatBufferBuilder, arrFlag: Int) = builder.addOffset(128, arrFlag, 0)
        fun addArrCargo(builder: FlatBufferBuilder, arrCargo: Int) = builder.addOffset(129, arrCargo, 0)
        fun addArrPort(builder: FlatBufferBuilder, arrPort: Int) = builder.addOffset(130, arrPort, 0)
        fun addDepPort(builder: FlatBufferBuilder, depPort: Int) = builder.addOffset(131, depPort, 0)
        fun addDepFlag(builder: FlatBufferBuilder, depFlag: Int) = builder.addOffset(132, depFlag, 0)
        fun addDepCargo(builder: FlatBufferBuilder, depCargo: Int) = builder.addOffset(133, depCargo, 0)
        fun addDesFlag(builder: FlatBufferBuilder, desFlag: Int) = builder.addOffset(134, desFlag, 0)
        fun addDesCargo(builder: FlatBufferBuilder, desCargo: Int) = builder.addOffset(135, desCargo, 0)
        fun addDestination(builder: FlatBufferBuilder, destination: Int) = builder.addOffset(136, destination, 0)
        fun addEta(builder: FlatBufferBuilder, eta: Int) = builder.addOffset(137, eta, 0)
        fun addEtd(builder: FlatBufferBuilder, etd: Int) = builder.addOffset(138, etd, 0)
        fun addIff(builder: FlatBufferBuilder, iff: Int) = builder.addOffset(139, iff, 0)
        fun addEmgInd(builder: FlatBufferBuilder, emgInd: Boolean) = builder.addBoolean(140, emgInd, false)
        fun addDropPtInd(builder: FlatBufferBuilder, dropPtInd: Boolean) = builder.addBoolean(141, dropPtInd, false)
        fun addReinforced(builder: FlatBufferBuilder, reinforced: Boolean) = builder.addBoolean(142, reinforced, false)
        fun addReduced(builder: FlatBufferBuilder, reduced: Boolean) = builder.addBoolean(143, reduced, false)
        fun addHq(builder: FlatBufferBuilder, hq: Boolean) = builder.addBoolean(144, hq, false)
        fun addDummy(builder: FlatBufferBuilder, dummy: Boolean) = builder.addBoolean(145, dummy, false)
        fun addTaskForce(builder: FlatBufferBuilder, taskForce: Boolean) = builder.addBoolean(146, taskForce, false)
        fun addFeint(builder: FlatBufferBuilder, feint: Boolean) = builder.addBoolean(147, feint, false)
        fun addInstallation(builder: FlatBufferBuilder, installation: Boolean) = builder.addBoolean(148, installation, false)
        fun addStaffCmts(builder: FlatBufferBuilder, staffCmts: Int) = builder.addOffset(149, staffCmts, 0)
        fun addAddInfo(builder: FlatBufferBuilder, addInfo: Int) = builder.addOffset(150, addInfo, 0)
        fun addEvalRating(builder: FlatBufferBuilder, evalRating: Int) = builder.addOffset(151, evalRating, 0)
        fun addCreatedAt(builder: FlatBufferBuilder, createdAt: Int) = builder.addOffset(152, createdAt, 0)
        fun addCreatedBy(builder: FlatBufferBuilder, createdBy: Int) = builder.addOffset(153, createdBy, 0)
        fun addSource(builder: FlatBufferBuilder, source: Int) = builder.addOffset(154, source, 0)
        fun addOrigin(builder: FlatBufferBuilder, origin: Int) = builder.addOffset(155, origin, 0)
        fun addDataMode(builder: FlatBufferBuilder, dataMode: Byte) = builder.addByte(156, dataMode, 0)
        fun addOrigNetwork(builder: FlatBufferBuilder, origNetwork: Int) = builder.addOffset(157, origNetwork, 0)
        fun endTrackDetails_Full(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishTrackDetailsFullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "TRAC")
        fun finishSizePrefixedTrackDetails_FullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "TRAC")
    }
}
