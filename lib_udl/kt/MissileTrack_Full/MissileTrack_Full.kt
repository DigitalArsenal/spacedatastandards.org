// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// These services provide operations for querying of all available missile track details and amplifying missile data. A missile track is a position and optionally a heading/velocity of an object across all environments at a particular timestamp. It also includes optional information regarding the identity/type of missile, impact location, launch location and other amplifying object data, if known.
 */
@Suppress("unused")
class MissileTrack_Full : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : MissileTrack_Full {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record, auto-generated by the system if not provided on create operations.
     * Example: /// Example: MissileTrack_ID
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val id : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun idInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     * Example: /// Example: U
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val classificationMarking : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val classificationMarkingAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun classificationMarkingInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * The type of external message from which this request originated.
     * Example: /// Example: MSG-TYPE
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val msgType : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val msgTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun msgTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * The message subtype is a finer grain categorization of message types as many messages can contain a variety of data content within the same structure.  Examples include but are not limited to Initial, Final, Launch, Update, etc.  Users should consult the appropriate documentation, based on the message type, for the definitions of the subtypes that apply to that message.
     * Example: /// Example: Update
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val msgSubType : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val msgSubTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun msgSubTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
     * Example: /// Example: 2024-04-25T08:17:01.346Z
     * Constraints: No constraints specified.
     */
    val msgCreateDate : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val msgCreateDateAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun msgCreateDateInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
     *  AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
     *  LAND: On the surface of dry land.
     *  SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
     *  SURFACE: On the surface of a body of water.
     *  SUBSURFACE: Below the surface of a body of water.
     *  UNKNOWN: Environment is not known.
     * Example: /// Example: AIR
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val env : Byte
        get() {
            val o = __offset(14)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * The type of object to which this record refers. The object type may be updated in later records based on assessment of additional data.
     * Example: /// Example: Ballistic
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val objType : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val objTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun objTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * Confidence of the object type, 0-100.
     * Example: /// Example: 90
     * Constraints: No constraints specified.
     */
    val objTypeConf : Int
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Space Platform field along with the Space Activity field further defines the identity of a Space track (examples: SATELLITE, WEAPON, PATROL). The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
     * Example: /// Example: WEAPON
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val objPlat : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val objPlatAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun objPlatInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
     *  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
     *  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
     *  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
     *  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
     *  PENDING: Track object which has not been evaluated.
     *  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
     *  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
     * Example: /// Example: FRIEND
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val objIdent : Byte
        get() {
            val o = __offset(22)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Space amplification indicates additional information on the space environment being reported (examples: NUCLEAR WARHEAD, FUEL-AIR EXPLOSIVE WARHEAD, DEBRIS).
     * Example: /// Example: NUCLEAR WARHEAD
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val spaceAmp : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val spaceAmpAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun spaceAmpInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * Space activity (examples: RECONNAISSANCE, ANTISPACE WARFARE, TELEVISION). The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.
     * Example: /// Example: HOLDING
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val objAct : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val objActAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun objActInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * Specific type of point or track with an environment of space.
     * Example: /// Example: SS-21_MOD_2_CRBM
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val spaceSpecType : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val spaceSpecTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun spaceSpecTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    /**
     * Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM. 
     * &nbsp;SRBM - Short-Range Ballistic Missile
     * &nbsp;MRBM - Medium-Range Ballistic Missile
     * &nbsp;IRBM - Intermediate-Range Ballistic Missile
     * &nbsp;LRBM - Long-Range Ballistic Missile
     * &nbsp;ICBM - Intercontinental Ballistic Missile
     * &nbsp;SLBM - Submarine-Launched Ballistic Missile.
     * Example: /// Example: SLBM
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val acftSubType : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val acftSubTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun acftSubTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    /**
     * Track name.
     * Example: /// Example: TRACK-NAME
     * Constraints: Minimum length = 0, Maximum length = 48
     */
    val name : String?
        get() {
            val o = __offset(32)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val nameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(32, 1)
    fun nameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 32, 1)
    /**
     * The call sign currently assigned to the track object.
     * Example: /// Example: Charlie
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val callSign : String?
        get() {
            val o = __offset(34)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val callSignAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(34, 1)
    fun callSignInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 34, 1)
    /**
     * Indicates whether or not the missile is considered lost.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val lostTrkInd : Boolean
        get() {
            val o = __offset(36)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Track ID within the originating system.
     * Example: /// Example: 102288
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val trackId : String?
        get() {
            val o = __offset(38)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val trackIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(38, 1)
    fun trackIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 38, 1)
    /**
     * Track ID of the parent track, within the originating system, from which the track was developed.
     * Example: /// Example: 102288
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val parentTrackId : String?
        get() {
            val o = __offset(40)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val parentTrackIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(40, 1)
    fun parentTrackIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 40, 1)
    /**
     * Track ID for the source of the missile-unique identifier.
     * Example: /// Example: MUID-SRC-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val muidSrcTrk : String?
        get() {
            val o = __offset(42)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val muidSrcTrkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(42, 1)
    fun muidSrcTrkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 42, 1)
    /**
     * Source of the missile-unique identifier (MUID).
     * Example: /// Example: MUID-SRC
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val muidSrc : String?
        get() {
            val o = __offset(44)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val muidSrcAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(44, 1)
    fun muidSrcInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 44, 1)
    /**
     * A track may be designated as a non-alert track or an alert track.
     * Examples include but are not limited to:
     * &nbsp;Non-alert tracks – choose None (Blank).
     * &nbsp;Alert tracks – enter the proper alert classification:
     * &nbsp;HIT - High Interest Track
     * &nbsp;TGT - Target
     * &nbsp;SUS - Suspect Carrier
     * &nbsp;NSP - Cleared Suspect.
     * Example: /// Example: HIT
     * Constraints: Minimum length = 0, Maximum length = 4
     */
    val alert : String?
        get() {
            val o = __offset(46)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val alertAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(46, 1)
    fun alertInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 46, 1)
    /**
     * Missile status enumeration examples include but are not limited to:
     * &nbsp;AT LAUNCH 
     * &nbsp;AT OBSERVATION 
     * &nbsp;FLYING 
     * &nbsp;IMPACTED 
     * &nbsp;LOST 
     * &nbsp;STALE
     * &nbsp;DEBRIS.
     * Example: /// Example: AT LAUNCH
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val mslStatus : String?
        get() {
            val o = __offset(48)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val mslStatusAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(48, 1)
    fun mslStatusInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 48, 1)
    /**
     * The receipt time of the data by the processing system, in ISO8601 UTC format with microsecond precision.
     * Example: /// Example: 2021-02-25T12:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val ts : String?
        get() {
            val o = __offset(50)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val tsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(50, 1)
    fun tsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 50, 1)
    /**
     * The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
     * Example: /// Example: ELLIPSE
     * Constraints: Minimum length = 0, Maximum length = 40
     */
    val aouRptType : String?
        get() {
            val o = __offset(52)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val aouRptTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(52, 1)
    fun aouRptTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 52, 1)
    /**
     * Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
     * &nbsp;ELLIPSE:
     * &nbsp;&nbsp;brg - orientation in degrees of the ellipse
     * &nbsp;&nbsp;a1 - semi-major axis in kilometers
     * &nbsp;&nbsp;a2 - semi-minor axis in kilometers
     * &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
     * &nbsp;&nbsp;brg - orientation in degrees of the bearing box
     * &nbsp;&nbsp;a1 - length of bearing box in kilometers
     * &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
     * &nbsp;OTHER (All other type values):
     * &nbsp;&nbsp;brg - line of bearing in degrees true
     * &nbsp;&nbsp;a1 - bearing error in degrees
     * &nbsp;&nbsp;a2 - estimated range in kilometers.
     * Example: /// Example: [34.3, 26.5, 1.2]
     * Constraints: No constraints specified.
     */
    fun aouRptData(j: Int) : String? {
        val o = __offset(54)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val aouRptDataLength : Int
        get() {
            val o = __offset(54); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The percentage of time that the estimated AoU will "cover" the true position of the track.
     * Example: /// Example: 90.64
     * Constraints: No constraints specified.
     */
    val containment : Double
        get() {
            val o = __offset(56)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
     * Example: /// Example: 0.95
     * Constraints: No constraints specified.
     */
    val trkConf : Double
        get() {
            val o = __offset(58)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track, with higher values indicating higher track quality; i.e., lower errors in reported position.
     * Example: /// Example: 1
     * Constraints: No constraints specified.
     */
    val trkQual : Int
        get() {
            val o = __offset(60)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Angle of elevation/depression between observer and missile in degrees.
     * Example: /// Example: 15.2
     * Constraints: No constraints specified.
     */
    val angElev : Double
        get() {
            val o = __offset(62)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Last report type received from the sensor (for example, OBSBO = observation burnout).
     * Example: /// Example: OBSBO
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val senMode : String?
        get() {
            val o = __offset(64)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val senModeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(64, 1)
    fun senModeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 64, 1)
    /**
     * Source code for source of information used to detect track.
     * Example: /// Example: S1
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val infoSource : String?
        get() {
            val o = __offset(66)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val infoSourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(66, 1)
    fun infoSourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 66, 1)
    /**
     * Indicates whether or not the missile is currently in a state of boosting.
     * Example: /// Example: True
     * Constraints: No constraints specified.
     */
    val boosting : Boolean
        get() {
            val o = __offset(68)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Azimuth corridor reference point latitude.
     * Example: /// Example: 19.88550102
     * Constraints: No constraints specified.
     */
    val polarSingLocLat : Double
        get() {
            val o = __offset(70)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Azimuth corridor reference point longitude.
     * Example: /// Example: 46.74596844
     * Constraints: No constraints specified.
     */
    val polarSingLocLon : Double
        get() {
            val o = __offset(72)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Indicates whether or not a track has an emergency.
     * Example: /// Example: True
     * Constraints: No constraints specified.
     */
    val emgInd : Boolean
        get() {
            val o = __offset(74)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * The drop-point indicator setting.
     * Example: /// Example: True
     * Constraints: No constraints specified.
     */
    val dropPtInd : Boolean
        get() {
            val o = __offset(76)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Confidence level of the amplifying characteristics. Values range from 0 to 6.
     * Example: /// Example: 6
     * Constraints: No constraints specified.
     */
    val spaceAmpConf : Int
        get() {
            val o = __offset(78)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Missile launch timestamp in ISO8601 UTC format with microsecond precision.
     * Example: /// Example: 2021-02-25T12:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val launchTime : String?
        get() {
            val o = __offset(80)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val launchTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(80, 1)
    fun launchTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 80, 1)
    /**
     * WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
     * Example: /// Example: 19.88550102
     * Constraints: No constraints specified.
     */
    val launchLat : Double
        get() {
            val o = __offset(82)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
     * Example: /// Example: 46.74596844
     * Constraints: No constraints specified.
     */
    val launchLon : Double
        get() {
            val o = __offset(84)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Missile azimuth corridor data.
     * Example: /// Example: 12.876
     * Constraints: No constraints specified.
     */
    val azCorr : Double
        get() {
            val o = __offset(86)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Track point burnout altitude relative to WGS-84 ellipsoid, in kilometers.
     * Example: /// Example: 30567.452
     * Constraints: No constraints specified.
     */
    val burnoutAlt : Double
        get() {
            val o = __offset(88)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
     * Example: /// Example: ELLIPSE
     * Constraints: Minimum length = 0, Maximum length = 40
     */
    val launchAouType : String?
        get() {
            val o = __offset(90)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val launchAouTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(90, 1)
    fun launchAouTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 90, 1)
    /**
     * Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
     * &nbsp;ELLIPSE:
     * &nbsp;&nbsp;brg - orientation in degrees of the ellipse
     * &nbsp;&nbsp;a1 - semi-major axis in kilometers
     * &nbsp;&nbsp;a2 - semi-minor axis in kilometers
     * &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
     * &nbsp;&nbsp;brg - orientation in degrees of the bearing box
     * &nbsp;&nbsp;a1 - length of bearing box in kilometers
     * &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
     * &nbsp;OTHER (All other type values):
     * &nbsp;&nbsp;brg - line of bearing in degrees true
     * &nbsp;&nbsp;a1 - bearing error in degrees
     * &nbsp;&nbsp;a2 - estimated range in kilometers.
     * Example: /// Example: [1.23, 2.34, 3.45]
     * Constraints: No constraints specified.
     */
    fun launchAouData(j: Int) : String? {
        val o = __offset(92)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val launchAouDataLength : Int
        get() {
            val o = __offset(92); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Estimated time of impact timestamp in ISO8601 UTC format with microsecond precision.
     * Example: /// Example: 2021-02-25T12:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val impactTime : String?
        get() {
            val o = __offset(94)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val impactTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(94, 1)
    fun impactTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 94, 1)
    /**
     * WGS-84 latitude of the missile object impact point, in degrees. -90 to 90 degrees (negative values south of equator).
     * Example: /// Example: 19.88550102
     * Constraints: No constraints specified.
     */
    val impactLat : Double
        get() {
            val o = __offset(96)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 longitude of the missile object impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
     * Example: /// Example: 46.74596844
     * Constraints: No constraints specified.
     */
    val impactLon : Double
        get() {
            val o = __offset(98)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
     * Example: /// Example: ELLIPSE
     * Constraints: Minimum length = 0, Maximum length = 40
     */
    val impactAouType : String?
        get() {
            val o = __offset(100)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val impactAouTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(100, 1)
    fun impactAouTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 100, 1)
    /**
     * Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
     * &nbsp;ELLIPSE:
     * &nbsp;&nbsp;brg - orientation in degrees of the ellipse
     * &nbsp;&nbsp;a1 - semi-major axis in kilometers
     * &nbsp;&nbsp;a2 - semi-minor axis in kilometers
     * &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
     * &nbsp;&nbsp;brg - orientation in degrees of the bearing box
     * &nbsp;&nbsp;a1 - length of bearing box in kilometers
     * &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
     * &nbsp;OTHER (All other type values):
     * &nbsp;&nbsp;brg - line of bearing in degrees true
     * &nbsp;&nbsp;a1 - bearing error in degrees
     * &nbsp;&nbsp;a2 - estimated range in kilometers.
     * Example: /// Example: [34.3, 26.5, 1.2]
     * Constraints: No constraints specified.
     */
    fun impactAouData(j: Int) : String? {
        val o = __offset(102)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val impactAouDataLength : Int
        get() {
            val o = __offset(102); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of MissileTrackVector objects. Missile track vectors are cartesian vectors of position, velocity, and acceleration that, together with their time, 'epoch', uniquely determine the trajectory of the missile. ECEF is the preferred coordinate frame but in some cases data may be in another frame as specified by 'referenceFrame', depending on the provider.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    fun vectors(j: Int) : String? {
        val o = __offset(104)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val vectorsLength : Int
        get() {
            val o = __offset(104); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * The originating source network on which this record was created, auto-populated by the system.
     * Example: /// Example: ORIG
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val origNetwork : String?
        get() {
            val o = __offset(106)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origNetworkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(106, 1)
    fun origNetworkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 106, 1)
    /**
     * Time the row was created in the database.
     * Example: /// Example: 2021-02-25T12:00:00.123Z
     * Constraints: No constraints specified.
     */
    val createdAt : String?
        get() {
            val o = __offset(108)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdAtAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(108, 1)
    fun createdAtInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 108, 1)
    /**
     * Application user who created the row in the database.
     * Example: /// Example: some.user
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val createdBy : String?
        get() {
            val o = __offset(110)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdByAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(110, 1)
    fun createdByInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 110, 1)
    /**
     * Source of the data.
     * Example: /// Example: Bluestaq
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val source : String?
        get() {
            val o = __offset(112)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(112, 1)
    fun sourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 112, 1)
    /**
     * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     * Example: /// Example: THIRD_PARTY_DATASOURCE
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origin : String?
        get() {
            val o = __offset(114)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val originAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(114, 1)
    fun originInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 114, 1)
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
     * Example: /// Example: TEST
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val dataMode : Byte
        get() {
            val o = __offset(116)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsMissileTrack_Full(_bb: ByteBuffer): MissileTrack_Full = getRootAsMissileTrack_Full(_bb, MissileTrack_Full())
        fun getRootAsMissileTrack_Full(_bb: ByteBuffer, obj: MissileTrack_Full): MissileTrack_Full {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun MissileTrack_FullBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "MISS")
        fun createMissileTrack_Full(builder: FlatBufferBuilder, idOffset: Int, classificationMarkingOffset: Int, msgTypeOffset: Int, msgSubTypeOffset: Int, msgCreateDateOffset: Int, env: Byte, objTypeOffset: Int, objTypeConf: Int, objPlatOffset: Int, objIdent: Byte, spaceAmpOffset: Int, objActOffset: Int, spaceSpecTypeOffset: Int, acftSubTypeOffset: Int, nameOffset: Int, callSignOffset: Int, lostTrkInd: Boolean, trackIdOffset: Int, parentTrackIdOffset: Int, muidSrcTrkOffset: Int, muidSrcOffset: Int, alertOffset: Int, mslStatusOffset: Int, tsOffset: Int, aouRptTypeOffset: Int, aouRptDataOffset: Int, containment: Double, trkConf: Double, trkQual: Int, angElev: Double, senModeOffset: Int, infoSourceOffset: Int, boosting: Boolean, polarSingLocLat: Double, polarSingLocLon: Double, emgInd: Boolean, dropPtInd: Boolean, spaceAmpConf: Int, launchTimeOffset: Int, launchLat: Double, launchLon: Double, azCorr: Double, burnoutAlt: Double, launchAouTypeOffset: Int, launchAouDataOffset: Int, impactTimeOffset: Int, impactLat: Double, impactLon: Double, impactAouTypeOffset: Int, impactAouDataOffset: Int, vectorsOffset: Int, origNetworkOffset: Int, createdAtOffset: Int, createdByOffset: Int, sourceOffset: Int, originOffset: Int, dataMode: Byte) : Int {
            builder.startTable(57)
            addImpactLon(builder, impactLon)
            addImpactLat(builder, impactLat)
            addBurnoutAlt(builder, burnoutAlt)
            addAzCorr(builder, azCorr)
            addLaunchLon(builder, launchLon)
            addLaunchLat(builder, launchLat)
            addPolarSingLocLon(builder, polarSingLocLon)
            addPolarSingLocLat(builder, polarSingLocLat)
            addAngElev(builder, angElev)
            addTrkConf(builder, trkConf)
            addContainment(builder, containment)
            addOrigin(builder, originOffset)
            addSource(builder, sourceOffset)
            addCreatedBy(builder, createdByOffset)
            addCreatedAt(builder, createdAtOffset)
            addOrigNetwork(builder, origNetworkOffset)
            addVectors(builder, vectorsOffset)
            addImpactAouData(builder, impactAouDataOffset)
            addImpactAouType(builder, impactAouTypeOffset)
            addImpactTime(builder, impactTimeOffset)
            addLaunchAouData(builder, launchAouDataOffset)
            addLaunchAouType(builder, launchAouTypeOffset)
            addLaunchTime(builder, launchTimeOffset)
            addSpaceAmpConf(builder, spaceAmpConf)
            addInfoSource(builder, infoSourceOffset)
            addSenMode(builder, senModeOffset)
            addTrkQual(builder, trkQual)
            addAouRptData(builder, aouRptDataOffset)
            addAouRptType(builder, aouRptTypeOffset)
            addTs(builder, tsOffset)
            addMslStatus(builder, mslStatusOffset)
            addAlert(builder, alertOffset)
            addMuidSrc(builder, muidSrcOffset)
            addMuidSrcTrk(builder, muidSrcTrkOffset)
            addParentTrackId(builder, parentTrackIdOffset)
            addTrackId(builder, trackIdOffset)
            addCallSign(builder, callSignOffset)
            addName(builder, nameOffset)
            addAcftSubType(builder, acftSubTypeOffset)
            addSpaceSpecType(builder, spaceSpecTypeOffset)
            addObjAct(builder, objActOffset)
            addSpaceAmp(builder, spaceAmpOffset)
            addObjPlat(builder, objPlatOffset)
            addObjTypeConf(builder, objTypeConf)
            addObjType(builder, objTypeOffset)
            addMsgCreateDate(builder, msgCreateDateOffset)
            addMsgSubType(builder, msgSubTypeOffset)
            addMsgType(builder, msgTypeOffset)
            addClassificationMarking(builder, classificationMarkingOffset)
            addId(builder, idOffset)
            addDataMode(builder, dataMode)
            addDropPtInd(builder, dropPtInd)
            addEmgInd(builder, emgInd)
            addBoosting(builder, boosting)
            addLostTrkInd(builder, lostTrkInd)
            addObjIdent(builder, objIdent)
            addEnv(builder, env)
            return endMissileTrack_Full(builder)
        }
        fun startMissileTrack_Full(builder: FlatBufferBuilder) = builder.startTable(57)
        fun addId(builder: FlatBufferBuilder, id: Int) = builder.addOffset(0, id, 0)
        fun addClassificationMarking(builder: FlatBufferBuilder, classificationMarking: Int) = builder.addOffset(1, classificationMarking, 0)
        fun addMsgType(builder: FlatBufferBuilder, msgType: Int) = builder.addOffset(2, msgType, 0)
        fun addMsgSubType(builder: FlatBufferBuilder, msgSubType: Int) = builder.addOffset(3, msgSubType, 0)
        fun addMsgCreateDate(builder: FlatBufferBuilder, msgCreateDate: Int) = builder.addOffset(4, msgCreateDate, 0)
        fun addEnv(builder: FlatBufferBuilder, env: Byte) = builder.addByte(5, env, 0)
        fun addObjType(builder: FlatBufferBuilder, objType: Int) = builder.addOffset(6, objType, 0)
        fun addObjTypeConf(builder: FlatBufferBuilder, objTypeConf: Int) = builder.addInt(7, objTypeConf, 0)
        fun addObjPlat(builder: FlatBufferBuilder, objPlat: Int) = builder.addOffset(8, objPlat, 0)
        fun addObjIdent(builder: FlatBufferBuilder, objIdent: Byte) = builder.addByte(9, objIdent, 0)
        fun addSpaceAmp(builder: FlatBufferBuilder, spaceAmp: Int) = builder.addOffset(10, spaceAmp, 0)
        fun addObjAct(builder: FlatBufferBuilder, objAct: Int) = builder.addOffset(11, objAct, 0)
        fun addSpaceSpecType(builder: FlatBufferBuilder, spaceSpecType: Int) = builder.addOffset(12, spaceSpecType, 0)
        fun addAcftSubType(builder: FlatBufferBuilder, acftSubType: Int) = builder.addOffset(13, acftSubType, 0)
        fun addName(builder: FlatBufferBuilder, name: Int) = builder.addOffset(14, name, 0)
        fun addCallSign(builder: FlatBufferBuilder, callSign: Int) = builder.addOffset(15, callSign, 0)
        fun addLostTrkInd(builder: FlatBufferBuilder, lostTrkInd: Boolean) = builder.addBoolean(16, lostTrkInd, false)
        fun addTrackId(builder: FlatBufferBuilder, trackId: Int) = builder.addOffset(17, trackId, 0)
        fun addParentTrackId(builder: FlatBufferBuilder, parentTrackId: Int) = builder.addOffset(18, parentTrackId, 0)
        fun addMuidSrcTrk(builder: FlatBufferBuilder, muidSrcTrk: Int) = builder.addOffset(19, muidSrcTrk, 0)
        fun addMuidSrc(builder: FlatBufferBuilder, muidSrc: Int) = builder.addOffset(20, muidSrc, 0)
        fun addAlert(builder: FlatBufferBuilder, alert: Int) = builder.addOffset(21, alert, 0)
        fun addMslStatus(builder: FlatBufferBuilder, mslStatus: Int) = builder.addOffset(22, mslStatus, 0)
        fun addTs(builder: FlatBufferBuilder, ts: Int) = builder.addOffset(23, ts, 0)
        fun addAouRptType(builder: FlatBufferBuilder, aouRptType: Int) = builder.addOffset(24, aouRptType, 0)
        fun addAouRptData(builder: FlatBufferBuilder, aouRptData: Int) = builder.addOffset(25, aouRptData, 0)
        fun createAouRptDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAouRptDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addContainment(builder: FlatBufferBuilder, containment: Double) = builder.addDouble(26, containment, 0.0)
        fun addTrkConf(builder: FlatBufferBuilder, trkConf: Double) = builder.addDouble(27, trkConf, 0.0)
        fun addTrkQual(builder: FlatBufferBuilder, trkQual: Int) = builder.addInt(28, trkQual, 0)
        fun addAngElev(builder: FlatBufferBuilder, angElev: Double) = builder.addDouble(29, angElev, 0.0)
        fun addSenMode(builder: FlatBufferBuilder, senMode: Int) = builder.addOffset(30, senMode, 0)
        fun addInfoSource(builder: FlatBufferBuilder, infoSource: Int) = builder.addOffset(31, infoSource, 0)
        fun addBoosting(builder: FlatBufferBuilder, boosting: Boolean) = builder.addBoolean(32, boosting, false)
        fun addPolarSingLocLat(builder: FlatBufferBuilder, polarSingLocLat: Double) = builder.addDouble(33, polarSingLocLat, 0.0)
        fun addPolarSingLocLon(builder: FlatBufferBuilder, polarSingLocLon: Double) = builder.addDouble(34, polarSingLocLon, 0.0)
        fun addEmgInd(builder: FlatBufferBuilder, emgInd: Boolean) = builder.addBoolean(35, emgInd, false)
        fun addDropPtInd(builder: FlatBufferBuilder, dropPtInd: Boolean) = builder.addBoolean(36, dropPtInd, false)
        fun addSpaceAmpConf(builder: FlatBufferBuilder, spaceAmpConf: Int) = builder.addInt(37, spaceAmpConf, 0)
        fun addLaunchTime(builder: FlatBufferBuilder, launchTime: Int) = builder.addOffset(38, launchTime, 0)
        fun addLaunchLat(builder: FlatBufferBuilder, launchLat: Double) = builder.addDouble(39, launchLat, 0.0)
        fun addLaunchLon(builder: FlatBufferBuilder, launchLon: Double) = builder.addDouble(40, launchLon, 0.0)
        fun addAzCorr(builder: FlatBufferBuilder, azCorr: Double) = builder.addDouble(41, azCorr, 0.0)
        fun addBurnoutAlt(builder: FlatBufferBuilder, burnoutAlt: Double) = builder.addDouble(42, burnoutAlt, 0.0)
        fun addLaunchAouType(builder: FlatBufferBuilder, launchAouType: Int) = builder.addOffset(43, launchAouType, 0)
        fun addLaunchAouData(builder: FlatBufferBuilder, launchAouData: Int) = builder.addOffset(44, launchAouData, 0)
        fun createLaunchAouDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startLaunchAouDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addImpactTime(builder: FlatBufferBuilder, impactTime: Int) = builder.addOffset(45, impactTime, 0)
        fun addImpactLat(builder: FlatBufferBuilder, impactLat: Double) = builder.addDouble(46, impactLat, 0.0)
        fun addImpactLon(builder: FlatBufferBuilder, impactLon: Double) = builder.addDouble(47, impactLon, 0.0)
        fun addImpactAouType(builder: FlatBufferBuilder, impactAouType: Int) = builder.addOffset(48, impactAouType, 0)
        fun addImpactAouData(builder: FlatBufferBuilder, impactAouData: Int) = builder.addOffset(49, impactAouData, 0)
        fun createImpactAouDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startImpactAouDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addVectors(builder: FlatBufferBuilder, vectors: Int) = builder.addOffset(50, vectors, 0)
        fun createVectorsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startVectorsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addOrigNetwork(builder: FlatBufferBuilder, origNetwork: Int) = builder.addOffset(51, origNetwork, 0)
        fun addCreatedAt(builder: FlatBufferBuilder, createdAt: Int) = builder.addOffset(52, createdAt, 0)
        fun addCreatedBy(builder: FlatBufferBuilder, createdBy: Int) = builder.addOffset(53, createdBy, 0)
        fun addSource(builder: FlatBufferBuilder, source: Int) = builder.addOffset(54, source, 0)
        fun addOrigin(builder: FlatBufferBuilder, origin: Int) = builder.addOffset(55, origin, 0)
        fun addDataMode(builder: FlatBufferBuilder, dataMode: Byte) = builder.addByte(56, dataMode, 0)
        fun endMissileTrack_Full(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishMissileTrackFullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "MISS")
        fun finishSizePrefixedMissileTrack_FullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "MISS")
    }
}
