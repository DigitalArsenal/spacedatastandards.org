// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// Mandatory nested segment to report multiple airspace control means statuses within an ACOID.
 */
@Suppress("unused")
class AirspaceControlMeansStatus_Ingest : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : AirspaceControlMeansStatus_Ingest {
        __init(_i, _bb)
        return this
    }
    /**
     * Status of Airspace Control Means. Must be ADD, CHANGE, or DELETE.
     * Example: /// Example: ADD
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val cmStat : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val cmStatAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun cmStatInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Airspace control means name or designator. Mandatory if acmStat equals "DELETE," otherwise this field is prohibited.
     * Example: /// Example: ['DESIGN:B35', 'NAME:ERMA', 'RANG:C21-C25']
     * Constraints: No constraints specified.
     */
    fun cmStatId(j: Int) : String? {
        val o = __offset(6)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val cmStatIdLength : Int
        get() {
            val o = __offset(6); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * A conditional nested segment to report multiple airspace control means within a particular airspace control means status.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    fun airspaceControlMeans(j: Int) : String? {
        val o = __offset(8)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val airspaceControlMeansLength : Int
        get() {
            val o = __offset(8); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsAirspaceControlMeansStatus_Ingest(_bb: ByteBuffer): AirspaceControlMeansStatus_Ingest = getRootAsAirspaceControlMeansStatus_Ingest(_bb, AirspaceControlMeansStatus_Ingest())
        fun getRootAsAirspaceControlMeansStatus_Ingest(_bb: ByteBuffer, obj: AirspaceControlMeansStatus_Ingest): AirspaceControlMeansStatus_Ingest {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun AirspaceControlMeansStatus_IngestBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "AIRS")
        fun createAirspaceControlMeansStatus_Ingest(builder: FlatBufferBuilder, cmStatOffset: Int, cmStatIdOffset: Int, airspaceControlMeansOffset: Int) : Int {
            builder.startTable(3)
            addAirspaceControlMeans(builder, airspaceControlMeansOffset)
            addCmStatId(builder, cmStatIdOffset)
            addCmStat(builder, cmStatOffset)
            return endAirspaceControlMeansStatus_Ingest(builder)
        }
        fun startAirspaceControlMeansStatus_Ingest(builder: FlatBufferBuilder) = builder.startTable(3)
        fun addCmStat(builder: FlatBufferBuilder, cmStat: Int) = builder.addOffset(0, cmStat, 0)
        fun addCmStatId(builder: FlatBufferBuilder, cmStatId: Int) = builder.addOffset(1, cmStatId, 0)
        fun createCmStatIdVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startCmStatIdVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addAirspaceControlMeans(builder: FlatBufferBuilder, airspaceControlMeans: Int) = builder.addOffset(2, airspaceControlMeans, 0)
        fun createAirspaceControlMeansVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAirspaceControlMeansVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endAirspaceControlMeansStatus_Ingest(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishAirspaceControlMeansStatusIngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "AIRS")
        fun finishSizePrefixedAirspaceControlMeansStatus_IngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "AIRS")
    }
}
