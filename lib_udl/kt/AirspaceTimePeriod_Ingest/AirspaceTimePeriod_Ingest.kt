// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// The timePeriod set describes the effective datetime for a given airspace control means.
 */
@Suppress("unused")
class AirspaceTimePeriod_Ingest : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : AirspaceTimePeriod_Ingest {
        __init(_i, _bb)
        return this
    }
    /**
     * The airspace time code associated with the ACO. Can be DISCRETE, a fixed time block, or INTERVAL, a repeating time block.
     * Example: /// Example: DISCRETE
     * Constraints: Minimum length = 0, Maximum length = 8
     */
    val timeMode : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val timeModeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun timeModeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * The start time designating that the airspace control order is active.
     * Example: /// Example: 141325ZFEB2002
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val timeStart : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val timeStartAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun timeStartInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * The end time designating that the airspace control order is no longer active. Can contain datetime information or a stop time qualifier code, such as AFTER, NET, UFN, etc.
     * Example: /// Example: 141325ZFEB2002
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val timeEnd : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val timeEndAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun timeEndInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Mandatory if timeMode is INTERVAL. Can be on of the interval frequency codes, such as BIWEEKLY, DAILY, YEARLY, etc.
     * Example: /// Example: ['WEEKLY']
     * Constraints: No constraints specified.
     */
    fun intFreq(j: Int) : String? {
        val o = __offset(10)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val intFreqLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Mandatory if timeMode is INTERVAL. Can be a numerical multiplier on an interval frequency code, a stop time qualifier code such as AFTER, NET, UFN, etc, or a datetime like string.
     * Example: /// Example: ['65WK']
     * Constraints: No constraints specified.
     */
    fun intDur(j: Int) : String? {
        val o = __offset(12)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val intDurLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsAirspaceTimePeriod_Ingest(_bb: ByteBuffer): AirspaceTimePeriod_Ingest = getRootAsAirspaceTimePeriod_Ingest(_bb, AirspaceTimePeriod_Ingest())
        fun getRootAsAirspaceTimePeriod_Ingest(_bb: ByteBuffer, obj: AirspaceTimePeriod_Ingest): AirspaceTimePeriod_Ingest {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun AirspaceTimePeriod_IngestBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "AIRS")
        fun createAirspaceTimePeriod_Ingest(builder: FlatBufferBuilder, timeModeOffset: Int, timeStartOffset: Int, timeEndOffset: Int, intFreqOffset: Int, intDurOffset: Int) : Int {
            builder.startTable(5)
            addIntDur(builder, intDurOffset)
            addIntFreq(builder, intFreqOffset)
            addTimeEnd(builder, timeEndOffset)
            addTimeStart(builder, timeStartOffset)
            addTimeMode(builder, timeModeOffset)
            return endAirspaceTimePeriod_Ingest(builder)
        }
        fun startAirspaceTimePeriod_Ingest(builder: FlatBufferBuilder) = builder.startTable(5)
        fun addTimeMode(builder: FlatBufferBuilder, timeMode: Int) = builder.addOffset(0, timeMode, 0)
        fun addTimeStart(builder: FlatBufferBuilder, timeStart: Int) = builder.addOffset(1, timeStart, 0)
        fun addTimeEnd(builder: FlatBufferBuilder, timeEnd: Int) = builder.addOffset(2, timeEnd, 0)
        fun addIntFreq(builder: FlatBufferBuilder, intFreq: Int) = builder.addOffset(3, intFreq, 0)
        fun createIntFreqVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startIntFreqVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addIntDur(builder: FlatBufferBuilder, intDur: Int) = builder.addOffset(4, intDur, 0)
        fun createIntDurVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startIntDurVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endAirspaceTimePeriod_Ingest(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishAirspaceTimePeriodIngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "AIRS")
        fun finishSizePrefixedAirspaceTimePeriod_IngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "AIRS")
    }
}
