// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// High priority time windows.
 */
@Suppress("unused")
class ISRCollectionCriticalTimes_Full : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : ISRCollectionCriticalTimes_Full {
        __init(_i, _bb)
        return this
    }
    /**
     * Critical start time to collect an image for this requirement.
     * Example: /// Example: 2021-01-19T01:01:15.001Z
     * Constraints: No constraints specified.
     */
    val earliestImagingTime : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val earliestImagingTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun earliestImagingTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Critical stop time to collect an image for this requirement.
     * Example: /// Example: 2021-01-19T01:11:15.001Z
     * Constraints: No constraints specified.
     */
    val latestImagingTime : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val latestImagingTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun latestImagingTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsISRCollectionCriticalTimes_Full(_bb: ByteBuffer): ISRCollectionCriticalTimes_Full = getRootAsISRCollectionCriticalTimes_Full(_bb, ISRCollectionCriticalTimes_Full())
        fun getRootAsISRCollectionCriticalTimes_Full(_bb: ByteBuffer, obj: ISRCollectionCriticalTimes_Full): ISRCollectionCriticalTimes_Full {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun ISRCollectionCriticalTimes_FullBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "ISRC")
        fun createISRCollectionCriticalTimes_Full(builder: FlatBufferBuilder, earliestImagingTimeOffset: Int, latestImagingTimeOffset: Int) : Int {
            builder.startTable(2)
            addLatestImagingTime(builder, latestImagingTimeOffset)
            addEarliestImagingTime(builder, earliestImagingTimeOffset)
            return endISRCollectionCriticalTimes_Full(builder)
        }
        fun startISRCollectionCriticalTimes_Full(builder: FlatBufferBuilder) = builder.startTable(2)
        fun addEarliestImagingTime(builder: FlatBufferBuilder, earliestImagingTime: Int) = builder.addOffset(0, earliestImagingTime, 0)
        fun addLatestImagingTime(builder: FlatBufferBuilder, latestImagingTime: Int) = builder.addOffset(1, latestImagingTime, 0)
        fun endISRCollectionCriticalTimes_Full(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishISRCollectionCriticalTimesFullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "ISRC")
        fun finishSizePrefixedISRCollectionCriticalTimes_FullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "ISRC")
    }
}
