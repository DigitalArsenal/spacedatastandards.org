// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
 */
@Suppress("unused")
class Sensorlimits_Ingest : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : Sensorlimits_Ingest {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record, auto-generated by the system.
     * Example: /// Example: SENSORLIMITS-ID
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val idSensorLimits : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idSensorLimitsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun idSensorLimitsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     * Example: /// Example: U
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val classificationMarking : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val classificationMarkingAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun classificationMarkingInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * The originating source network on which this record was created, auto-populated by the system.
     * Example: /// Example: ORIG
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val origNetwork : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origNetworkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun origNetworkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val upperLeftAzimuthLimit : Double
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val upperRightAzimuthLimit : Double
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val lowerRightAzimuthLimit : Double
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val lowerLeftAzimuthLimit : Double
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val lowerLeftElevationLimit : Double
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val upperLeftElevationLimit : Double
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val lowerRightElevationLimit : Double
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
     * Example: /// Example: 1.23
     * Constraints: No constraints specified.
     */
    val upperRightElevationLimit : Double
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Source of the data.
     * Example: /// Example: Bluestaq
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val source : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun sourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
     * Example: /// Example: TEST
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val dataMode : Byte
        get() {
            val o = __offset(28)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Time the row was created in the database, auto-populated by the system.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val createdAt : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdAtAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun createdAtInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    /**
     * Application user who created the row in the database, auto-populated by the system.
     * Example: /// Example: some.user
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val createdBy : String?
        get() {
            val o = __offset(32)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdByAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(32, 1)
    fun createdByInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 32, 1)
    /**
     * Unique identifier of the target sensor object.
     * Example: /// Example: SENSORLIMITS-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idSensor : String?
        get() {
            val o = __offset(34)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idSensorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(34, 1)
    fun idSensorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 34, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsSensorlimits_Ingest(_bb: ByteBuffer): Sensorlimits_Ingest = getRootAsSensorlimits_Ingest(_bb, Sensorlimits_Ingest())
        fun getRootAsSensorlimits_Ingest(_bb: ByteBuffer, obj: Sensorlimits_Ingest): Sensorlimits_Ingest {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun Sensorlimits_IngestBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "SENS")
        fun createSensorlimits_Ingest(builder: FlatBufferBuilder, idSensorLimitsOffset: Int, classificationMarkingOffset: Int, origNetworkOffset: Int, upperLeftAzimuthLimit: Double, upperRightAzimuthLimit: Double, lowerRightAzimuthLimit: Double, lowerLeftAzimuthLimit: Double, lowerLeftElevationLimit: Double, upperLeftElevationLimit: Double, lowerRightElevationLimit: Double, upperRightElevationLimit: Double, sourceOffset: Int, dataMode: Byte, createdAtOffset: Int, createdByOffset: Int, idSensorOffset: Int) : Int {
            builder.startTable(16)
            addUpperRightElevationLimit(builder, upperRightElevationLimit)
            addLowerRightElevationLimit(builder, lowerRightElevationLimit)
            addUpperLeftElevationLimit(builder, upperLeftElevationLimit)
            addLowerLeftElevationLimit(builder, lowerLeftElevationLimit)
            addLowerLeftAzimuthLimit(builder, lowerLeftAzimuthLimit)
            addLowerRightAzimuthLimit(builder, lowerRightAzimuthLimit)
            addUpperRightAzimuthLimit(builder, upperRightAzimuthLimit)
            addUpperLeftAzimuthLimit(builder, upperLeftAzimuthLimit)
            addIdSensor(builder, idSensorOffset)
            addCreatedBy(builder, createdByOffset)
            addCreatedAt(builder, createdAtOffset)
            addSource(builder, sourceOffset)
            addOrigNetwork(builder, origNetworkOffset)
            addClassificationMarking(builder, classificationMarkingOffset)
            addIdSensorLimits(builder, idSensorLimitsOffset)
            addDataMode(builder, dataMode)
            return endSensorlimits_Ingest(builder)
        }
        fun startSensorlimits_Ingest(builder: FlatBufferBuilder) = builder.startTable(16)
        fun addIdSensorLimits(builder: FlatBufferBuilder, idSensorLimits: Int) = builder.addOffset(0, idSensorLimits, 0)
        fun addClassificationMarking(builder: FlatBufferBuilder, classificationMarking: Int) = builder.addOffset(1, classificationMarking, 0)
        fun addOrigNetwork(builder: FlatBufferBuilder, origNetwork: Int) = builder.addOffset(2, origNetwork, 0)
        fun addUpperLeftAzimuthLimit(builder: FlatBufferBuilder, upperLeftAzimuthLimit: Double) = builder.addDouble(3, upperLeftAzimuthLimit, 0.0)
        fun addUpperRightAzimuthLimit(builder: FlatBufferBuilder, upperRightAzimuthLimit: Double) = builder.addDouble(4, upperRightAzimuthLimit, 0.0)
        fun addLowerRightAzimuthLimit(builder: FlatBufferBuilder, lowerRightAzimuthLimit: Double) = builder.addDouble(5, lowerRightAzimuthLimit, 0.0)
        fun addLowerLeftAzimuthLimit(builder: FlatBufferBuilder, lowerLeftAzimuthLimit: Double) = builder.addDouble(6, lowerLeftAzimuthLimit, 0.0)
        fun addLowerLeftElevationLimit(builder: FlatBufferBuilder, lowerLeftElevationLimit: Double) = builder.addDouble(7, lowerLeftElevationLimit, 0.0)
        fun addUpperLeftElevationLimit(builder: FlatBufferBuilder, upperLeftElevationLimit: Double) = builder.addDouble(8, upperLeftElevationLimit, 0.0)
        fun addLowerRightElevationLimit(builder: FlatBufferBuilder, lowerRightElevationLimit: Double) = builder.addDouble(9, lowerRightElevationLimit, 0.0)
        fun addUpperRightElevationLimit(builder: FlatBufferBuilder, upperRightElevationLimit: Double) = builder.addDouble(10, upperRightElevationLimit, 0.0)
        fun addSource(builder: FlatBufferBuilder, source: Int) = builder.addOffset(11, source, 0)
        fun addDataMode(builder: FlatBufferBuilder, dataMode: Byte) = builder.addByte(12, dataMode, 0)
        fun addCreatedAt(builder: FlatBufferBuilder, createdAt: Int) = builder.addOffset(13, createdAt, 0)
        fun addCreatedBy(builder: FlatBufferBuilder, createdBy: Int) = builder.addOffset(14, createdBy, 0)
        fun addIdSensor(builder: FlatBufferBuilder, idSensor: Int) = builder.addOffset(15, idSensor, 0)
        fun endSensorlimits_Ingest(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishSensorlimitsIngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "SENS")
        fun finishSizePrefixedSensorlimits_IngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "SENS")
    }
}
