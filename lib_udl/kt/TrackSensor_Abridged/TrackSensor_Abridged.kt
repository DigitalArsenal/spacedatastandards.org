// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// Schema for Track Sensor data.
 */
@Suppress("unused")
class TrackSensor_Abridged : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : TrackSensor_Abridged {
        __init(_i, _bb)
        return this
    }
    /**
     * The track object range from the observing sensor, in kilometers.
     * Example: /// Example: 4023.95
     * Constraints: No constraints specified.
     */
    val range : Double
        get() {
            val o = __offset(4)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The observing sensor azimuth angle, in degrees and topocentric frame.
     * Example: /// Example: 90
     * Constraints: No constraints specified.
     */
    val az : Double
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
     * Example: /// Example: 1234
     * Constraints: No constraints specified.
     */
    val sensorNumber : Int
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Unique name of this sensor.
     * Example: /// Example: SENSOR_NAME
     * Constraints: Minimum length = 0, Maximum length = 128
     */
    val sensorName : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sensorNameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun sensorNameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * The mission number which produced this track observation.
     * Example: /// Example: Example Mission
     * Constraints: Minimum length = 0, Maximum length = 128
     */
    val missionNumber : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val missionNumberAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun missionNumberInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Minimum range measurement capability of the sensor, in kilometers.
     * Example: /// Example: 20.23
     * Constraints: No constraints specified.
     */
    val minRangeLimit : Double
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
     * Example: /// Example: UNKNOWN
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val sensorFovtype : Byte
        get() {
            val o = __offset(16)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsTrackSensor_Abridged(_bb: ByteBuffer): TrackSensor_Abridged = getRootAsTrackSensor_Abridged(_bb, TrackSensor_Abridged())
        fun getRootAsTrackSensor_Abridged(_bb: ByteBuffer, obj: TrackSensor_Abridged): TrackSensor_Abridged {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun TrackSensor_AbridgedBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "TRAC")
        fun createTrackSensor_Abridged(builder: FlatBufferBuilder, range: Double, az: Double, sensorNumber: Int, sensorNameOffset: Int, missionNumberOffset: Int, minRangeLimit: Double, sensorFovtype: Byte) : Int {
            builder.startTable(7)
            addMinRangeLimit(builder, minRangeLimit)
            addAz(builder, az)
            addRange(builder, range)
            addMissionNumber(builder, missionNumberOffset)
            addSensorName(builder, sensorNameOffset)
            addSensorNumber(builder, sensorNumber)
            addSensorFOVType(builder, sensorFovtype)
            return endTrackSensor_Abridged(builder)
        }
        fun startTrackSensor_Abridged(builder: FlatBufferBuilder) = builder.startTable(7)
        fun addRange(builder: FlatBufferBuilder, range: Double) = builder.addDouble(0, range, 0.0)
        fun addAz(builder: FlatBufferBuilder, az: Double) = builder.addDouble(1, az, 0.0)
        fun addSensorNumber(builder: FlatBufferBuilder, sensorNumber: Int) = builder.addInt(2, sensorNumber, 0)
        fun addSensorName(builder: FlatBufferBuilder, sensorName: Int) = builder.addOffset(3, sensorName, 0)
        fun addMissionNumber(builder: FlatBufferBuilder, missionNumber: Int) = builder.addOffset(4, missionNumber, 0)
        fun addMinRangeLimit(builder: FlatBufferBuilder, minRangeLimit: Double) = builder.addDouble(5, minRangeLimit, 0.0)
        fun addSensorFOVType(builder: FlatBufferBuilder, sensorFovtype: Byte) = builder.addByte(6, sensorFovtype, 0)
        fun endTrackSensor_Abridged(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishTrackSensorAbridgedBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "TRAC")
        fun finishSizePrefixedTrackSensor_AbridgedBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "TRAC")
    }
}
