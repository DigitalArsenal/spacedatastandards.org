// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
 */
@Suppress("unused")
class EphemerisSet_Full : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : EphemerisSet_Full {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record, auto-generated by the system.
     * Example: /// Example: EPHEMERISSET-ID
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val id : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun idInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     * Example: /// Example: U
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val classificationMarking : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val classificationMarkingAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun classificationMarkingInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Unique identifier of the primary satellite on-orbit object.
     * Example: /// Example: ONORBIT-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idOnOrbit : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idOnOrbitAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun idOnOrbitInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
     * Example: /// Example: ORIGOBJECT-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val origObjectId : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origObjectIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun origObjectIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Start time/first time point of the ephemeris, in ISO 8601 UTC format.
     * Example: /// Example: 2018-01-01T16:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val pointStartTime : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val pointStartTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun pointStartTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Optional start time of the usable time span for the ephemeris data, in ISO 8601 UTC format with microsecond precision.
     * Example: /// Example: 2018-01-01T16:10:00.123456Z
     * Constraints: No constraints specified.
     */
    val usableStartTime : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val usableStartTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun usableStartTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * End time/last time point of the ephemeris, in ISO 8601 UTC format.
     * Example: /// Example: 2018-01-01T16:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val pointEndTime : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val pointEndTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun pointEndTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * Optional end time of the usable time span for the ephemeris data, in ISO 8601 UTC format with microsecond precision.
     * Example: /// Example: 2018-01-01T20:50:00.123456Z
     * Constraints: No constraints specified.
     */
    val usableEndTime : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val usableEndTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun usableEndTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * Ephemeris step size, in seconds.
     * Example: /// Example: 1
     * Constraints: No constraints specified.
     */
    val stepSize : Int
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Number of points contained in the ephemeris.
     * Example: /// Example: 1
     * Constraints: No constraints specified.
     */
    val numPoints : Int
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The type/purpose of the ephemeris (e.g., CALIBRATION, LAUNCH, MNVR_PLAN, ROUTINE, SCREENING).
     * Example: /// Example: LAUNCH
     * Constraints: Minimum length = 1, Maximum length = 24
     */
    val type : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val typeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun typeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID).
     * Example: /// Example: PROPAGATED
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val pedigree : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val pedigreeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun pedigreeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL).
     * Example: /// Example: ANALYST
     * Constraints: Minimum length = 1, Maximum length = 24
     */
    val category : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val categoryAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun categoryInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    /**
     * ID of the State Vector used to generate the ephemeris.
     * Example: /// Example: STATEVECTOR-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idStateVector : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idStateVectorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun idStateVectorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    /**
     * Boolean indicating whether maneuver(s) are incorporated into the ephemeris.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val hasMnvr : Boolean
        get() {
            val o = __offset(32)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Array of the maneuver IDs of all maneuvers incorporated in the ephemeris.
     * Example: /// Example: ['EXAMPLE_ID1', 'EXAMPLE_ID2']
     * Constraints: No constraints specified.
     */
    fun idManeuvers(j: Int) : String? {
        val o = __offset(34)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val idManeuversLength : Int
        get() {
            val o = __offset(34); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Boolean indicating whether covariance data is provided with the ephemeris.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val hasCov : Boolean
        get() {
            val o = __offset(36)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Boolean indicating whether acceleration data is provided with the ephemeris.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val hasAccel : Boolean
        get() {
            val o = __offset(38)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated.
     * Example: /// Example: Earth
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val centBody : String?
        get() {
            val o = __offset(40)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val centBodyAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(40, 1)
    fun centBodyInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 40, 1)
    /**
     * Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY).
     * Example: /// Example: COWELL
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val integrator : String?
        get() {
            val o = __offset(42)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val integratorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(42, 1)
    fun integratorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 42, 1)
    /**
     * Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T).
     * Example: /// Example: GEM-T3
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val geopotentialModel : String?
        get() {
            val o = __offset(44)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val geopotentialModelAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(44, 1)
    fun geopotentialModelInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 44, 1)
    /**
     * Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.).
     * Example: /// Example: JAC70
     * Constraints: Minimum length = 0, Maximum length = 32
     */
    val dragModel : String?
        get() {
            val o = __offset(46)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val dragModelAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(46, 1)
    fun dragModelInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 46, 1)
    /**
     * Boolean indicating use of lunar/solar data in ephemeris generation.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val lunarSolar : Boolean
        get() {
            val o = __offset(48)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Boolean indicating use of solid earth tide data in ephemeris generation.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val solidEarthTides : Boolean
        get() {
            val o = __offset(50)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * First derivative of ballistic coefficient (m^2/kg-s).
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val bDot : Double
        get() {
            val o = __offset(52)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Model parameter value for energy dissipation rate (EDR), expressed in w/kg.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val edr : Double
        get() {
            val o = __offset(54)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The recommended interpolation method for the ephemeris data.
     * Example: /// Example: LINEAR
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val interpolation : String?
        get() {
            val o = __offset(56)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val interpolationAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(56, 1)
    fun interpolationInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 56, 1)
    /**
     * The recommended interpolation degree for the ephemeris data.
     * Example: /// Example: 5
     * Constraints: No constraints specified.
     */
    val interpolationDegree : Int
        get() {
            val o = __offset(58)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the 'EphemerisSet' OpenAPI docs.
     * Example: /// Example: Example file name
     * Constraints: Minimum length = 0, Maximum length = 128
     */
    val filename : String?
        get() {
            val o = __offset(60)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val filenameAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(60, 1)
    fun filenameInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 60, 1)
    /**
     * Additional source provided comments associated with the ephemeris.
     * Example: /// Example: Example notes
     * Constraints: Minimum length = 0, Maximum length = 512
     */
    val comments : String?
        get() {
            val o = __offset(62)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val commentsAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(62, 1)
    fun commentsInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 62, 1)
    /**
     * Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
     * Example: /// Example: Example notes
     * Constraints: Minimum length = 0, Maximum length = 512
     */
    val description : String?
        get() {
            val o = __offset(64)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val descriptionAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(64, 1)
    fun descriptionInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 64, 1)
    /**
     * Optional source-provided and searchable metadata or descriptor of the data.
     * Example: /// Example: Example descriptor
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val descriptor : String?
        get() {
            val o = __offset(66)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val descriptorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(66, 1)
    fun descriptorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 66, 1)
    /**
     * The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
     * Example: /// Example: J2000
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val referenceFrame : Byte
        get() {
            val o = __offset(68)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
     * Example: /// Example: J2000
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val covReferenceFrame : Byte
        get() {
            val o = __offset(70)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Time the row was created in the database, in UTC.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val createdAt : String?
        get() {
            val o = __offset(72)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdAtAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(72, 1)
    fun createdAtInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 72, 1)
    /**
     * Application user who created the row in the database.
     * Example: /// Example: some.user
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val createdBy : String?
        get() {
            val o = __offset(74)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdByAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(74, 1)
    fun createdByInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 74, 1)
    /**
     * Source of the data.
     * Example: /// Example: Bluestaq
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val source : String?
        get() {
            val o = __offset(76)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(76, 1)
    fun sourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 76, 1)
    /**
     * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     * Example: /// Example: THIRD_PARTY_DATASOURCE
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origin : String?
        get() {
            val o = __offset(78)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val originAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(78, 1)
    fun originInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 78, 1)
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
     * Example: /// Example: TEST
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val dataMode : Byte
        get() {
            val o = __offset(80)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * No description provided.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    val stateVector : String?
        get() {
            val o = __offset(82)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val stateVectorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(82, 1)
    fun stateVectorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 82, 1)
    /**
     * Satellite/catalog number of the target on-orbit object.
     * Example: /// Example: 2
     * Constraints: No constraints specified.
     */
    val satNo : Int
        get() {
            val o = __offset(84)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The list of ephemeris states belonging to the EphemerisSet. Each ephemeris point is associated with a parent Ephemeris Set via the EphemerisSet ID (esId).
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    fun ephemerisList(j: Int) : String? {
        val o = __offset(86)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val ephemerisListLength : Int
        get() {
            val o = __offset(86); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * No description provided.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    val onOrbit : String?
        get() {
            val o = __offset(88)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val onOrbitAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(88, 1)
    fun onOrbitInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 88, 1)
    /**
     * Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
     * Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
     * Constraints: No constraints specified.
     */
    fun tags(j: Int) : String? {
        val o = __offset(90)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val tagsLength : Int
        get() {
            val o = __offset(90); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Optional identifier to track a commercial or marketplace transaction executed to produce this data.
     * Example: /// Example: TRANSACTION-ID
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val transactionId : String?
        get() {
            val o = __offset(92)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val transactionIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(92, 1)
    fun transactionIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 92, 1)
    /**
     * The originating source network on which this record was created, auto-populated by the system.
     * Example: /// Example: ORIG
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val origNetwork : String?
        get() {
            val o = __offset(94)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origNetworkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(94, 1)
    fun origNetworkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 94, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsEphemerisSet_Full(_bb: ByteBuffer): EphemerisSet_Full = getRootAsEphemerisSet_Full(_bb, EphemerisSet_Full())
        fun getRootAsEphemerisSet_Full(_bb: ByteBuffer, obj: EphemerisSet_Full): EphemerisSet_Full {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun EphemerisSet_FullBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "EPHE")
        fun createEphemerisSet_Full(builder: FlatBufferBuilder, idOffset: Int, classificationMarkingOffset: Int, idOnOrbitOffset: Int, origObjectIdOffset: Int, pointStartTimeOffset: Int, usableStartTimeOffset: Int, pointEndTimeOffset: Int, usableEndTimeOffset: Int, stepSize: Int, numPoints: Int, typeOffset: Int, pedigreeOffset: Int, categoryOffset: Int, idStateVectorOffset: Int, hasMnvr: Boolean, idManeuversOffset: Int, hasCov: Boolean, hasAccel: Boolean, centBodyOffset: Int, integratorOffset: Int, geopotentialModelOffset: Int, dragModelOffset: Int, lunarSolar: Boolean, solidEarthTides: Boolean, bDot: Double, edr: Double, interpolationOffset: Int, interpolationDegree: Int, filenameOffset: Int, commentsOffset: Int, descriptionOffset: Int, descriptorOffset: Int, referenceFrame: Byte, covReferenceFrame: Byte, createdAtOffset: Int, createdByOffset: Int, sourceOffset: Int, originOffset: Int, dataMode: Byte, stateVectorOffset: Int, satNo: Int, ephemerisListOffset: Int, onOrbitOffset: Int, tagsOffset: Int, transactionIdOffset: Int, origNetworkOffset: Int) : Int {
            builder.startTable(46)
            addEdr(builder, edr)
            addBDot(builder, bDot)
            addOrigNetwork(builder, origNetworkOffset)
            addTransactionId(builder, transactionIdOffset)
            addTags(builder, tagsOffset)
            addOnOrbit(builder, onOrbitOffset)
            addEphemerisList(builder, ephemerisListOffset)
            addSatNo(builder, satNo)
            addStateVector(builder, stateVectorOffset)
            addOrigin(builder, originOffset)
            addSource(builder, sourceOffset)
            addCreatedBy(builder, createdByOffset)
            addCreatedAt(builder, createdAtOffset)
            addDescriptor(builder, descriptorOffset)
            addDescription(builder, descriptionOffset)
            addComments(builder, commentsOffset)
            addFilename(builder, filenameOffset)
            addInterpolationDegree(builder, interpolationDegree)
            addInterpolation(builder, interpolationOffset)
            addDragModel(builder, dragModelOffset)
            addGeopotentialModel(builder, geopotentialModelOffset)
            addIntegrator(builder, integratorOffset)
            addCentBody(builder, centBodyOffset)
            addIdManeuvers(builder, idManeuversOffset)
            addIdStateVector(builder, idStateVectorOffset)
            addCategory(builder, categoryOffset)
            addPedigree(builder, pedigreeOffset)
            addType(builder, typeOffset)
            addNumPoints(builder, numPoints)
            addStepSize(builder, stepSize)
            addUsableEndTime(builder, usableEndTimeOffset)
            addPointEndTime(builder, pointEndTimeOffset)
            addUsableStartTime(builder, usableStartTimeOffset)
            addPointStartTime(builder, pointStartTimeOffset)
            addOrigObjectId(builder, origObjectIdOffset)
            addIdOnOrbit(builder, idOnOrbitOffset)
            addClassificationMarking(builder, classificationMarkingOffset)
            addId(builder, idOffset)
            addDataMode(builder, dataMode)
            addCovReferenceFrame(builder, covReferenceFrame)
            addReferenceFrame(builder, referenceFrame)
            addSolidEarthTides(builder, solidEarthTides)
            addLunarSolar(builder, lunarSolar)
            addHasAccel(builder, hasAccel)
            addHasCov(builder, hasCov)
            addHasMnvr(builder, hasMnvr)
            return endEphemerisSet_Full(builder)
        }
        fun startEphemerisSet_Full(builder: FlatBufferBuilder) = builder.startTable(46)
        fun addId(builder: FlatBufferBuilder, id: Int) = builder.addOffset(0, id, 0)
        fun addClassificationMarking(builder: FlatBufferBuilder, classificationMarking: Int) = builder.addOffset(1, classificationMarking, 0)
        fun addIdOnOrbit(builder: FlatBufferBuilder, idOnOrbit: Int) = builder.addOffset(2, idOnOrbit, 0)
        fun addOrigObjectId(builder: FlatBufferBuilder, origObjectId: Int) = builder.addOffset(3, origObjectId, 0)
        fun addPointStartTime(builder: FlatBufferBuilder, pointStartTime: Int) = builder.addOffset(4, pointStartTime, 0)
        fun addUsableStartTime(builder: FlatBufferBuilder, usableStartTime: Int) = builder.addOffset(5, usableStartTime, 0)
        fun addPointEndTime(builder: FlatBufferBuilder, pointEndTime: Int) = builder.addOffset(6, pointEndTime, 0)
        fun addUsableEndTime(builder: FlatBufferBuilder, usableEndTime: Int) = builder.addOffset(7, usableEndTime, 0)
        fun addStepSize(builder: FlatBufferBuilder, stepSize: Int) = builder.addInt(8, stepSize, 0)
        fun addNumPoints(builder: FlatBufferBuilder, numPoints: Int) = builder.addInt(9, numPoints, 0)
        fun addType(builder: FlatBufferBuilder, type: Int) = builder.addOffset(10, type, 0)
        fun addPedigree(builder: FlatBufferBuilder, pedigree: Int) = builder.addOffset(11, pedigree, 0)
        fun addCategory(builder: FlatBufferBuilder, category: Int) = builder.addOffset(12, category, 0)
        fun addIdStateVector(builder: FlatBufferBuilder, idStateVector: Int) = builder.addOffset(13, idStateVector, 0)
        fun addHasMnvr(builder: FlatBufferBuilder, hasMnvr: Boolean) = builder.addBoolean(14, hasMnvr, false)
        fun addIdManeuvers(builder: FlatBufferBuilder, idManeuvers: Int) = builder.addOffset(15, idManeuvers, 0)
        fun createIdManeuversVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startIdManeuversVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addHasCov(builder: FlatBufferBuilder, hasCov: Boolean) = builder.addBoolean(16, hasCov, false)
        fun addHasAccel(builder: FlatBufferBuilder, hasAccel: Boolean) = builder.addBoolean(17, hasAccel, false)
        fun addCentBody(builder: FlatBufferBuilder, centBody: Int) = builder.addOffset(18, centBody, 0)
        fun addIntegrator(builder: FlatBufferBuilder, integrator: Int) = builder.addOffset(19, integrator, 0)
        fun addGeopotentialModel(builder: FlatBufferBuilder, geopotentialModel: Int) = builder.addOffset(20, geopotentialModel, 0)
        fun addDragModel(builder: FlatBufferBuilder, dragModel: Int) = builder.addOffset(21, dragModel, 0)
        fun addLunarSolar(builder: FlatBufferBuilder, lunarSolar: Boolean) = builder.addBoolean(22, lunarSolar, false)
        fun addSolidEarthTides(builder: FlatBufferBuilder, solidEarthTides: Boolean) = builder.addBoolean(23, solidEarthTides, false)
        fun addBDot(builder: FlatBufferBuilder, bDot: Double) = builder.addDouble(24, bDot, 0.0)
        fun addEdr(builder: FlatBufferBuilder, edr: Double) = builder.addDouble(25, edr, 0.0)
        fun addInterpolation(builder: FlatBufferBuilder, interpolation: Int) = builder.addOffset(26, interpolation, 0)
        fun addInterpolationDegree(builder: FlatBufferBuilder, interpolationDegree: Int) = builder.addInt(27, interpolationDegree, 0)
        fun addFilename(builder: FlatBufferBuilder, filename: Int) = builder.addOffset(28, filename, 0)
        fun addComments(builder: FlatBufferBuilder, comments: Int) = builder.addOffset(29, comments, 0)
        fun addDescription(builder: FlatBufferBuilder, description: Int) = builder.addOffset(30, description, 0)
        fun addDescriptor(builder: FlatBufferBuilder, descriptor: Int) = builder.addOffset(31, descriptor, 0)
        fun addReferenceFrame(builder: FlatBufferBuilder, referenceFrame: Byte) = builder.addByte(32, referenceFrame, 0)
        fun addCovReferenceFrame(builder: FlatBufferBuilder, covReferenceFrame: Byte) = builder.addByte(33, covReferenceFrame, 0)
        fun addCreatedAt(builder: FlatBufferBuilder, createdAt: Int) = builder.addOffset(34, createdAt, 0)
        fun addCreatedBy(builder: FlatBufferBuilder, createdBy: Int) = builder.addOffset(35, createdBy, 0)
        fun addSource(builder: FlatBufferBuilder, source: Int) = builder.addOffset(36, source, 0)
        fun addOrigin(builder: FlatBufferBuilder, origin: Int) = builder.addOffset(37, origin, 0)
        fun addDataMode(builder: FlatBufferBuilder, dataMode: Byte) = builder.addByte(38, dataMode, 0)
        fun addStateVector(builder: FlatBufferBuilder, stateVector: Int) = builder.addOffset(39, stateVector, 0)
        fun addSatNo(builder: FlatBufferBuilder, satNo: Int) = builder.addInt(40, satNo, 0)
        fun addEphemerisList(builder: FlatBufferBuilder, ephemerisList: Int) = builder.addOffset(41, ephemerisList, 0)
        fun createEphemerisListVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startEphemerisListVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addOnOrbit(builder: FlatBufferBuilder, onOrbit: Int) = builder.addOffset(42, onOrbit, 0)
        fun addTags(builder: FlatBufferBuilder, tags: Int) = builder.addOffset(43, tags, 0)
        fun createTagsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTagsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addTransactionId(builder: FlatBufferBuilder, transactionId: Int) = builder.addOffset(44, transactionId, 0)
        fun addOrigNetwork(builder: FlatBufferBuilder, origNetwork: Int) = builder.addOffset(45, origNetwork, 0)
        fun endEphemerisSet_Full(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishEphemerisSetFullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "EPHE")
        fun finishSizePrefixedEphemerisSet_FullBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "EPHE")
    }
}
