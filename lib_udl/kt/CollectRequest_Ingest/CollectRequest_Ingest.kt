// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// Collect Requests support several types of individual requests, or planned/scheduled tasks on sensors and/or orbital objects. Options are provided to accomodate most common sensor contact and collection applications, including single sensor-object tasking, search operations, and TT&C support. Multiple requests originating from a plan or schedule may be associated to a sensor plan if desired.
 */
@Suppress("unused")
class CollectRequest_Ingest : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : CollectRequest_Ingest {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record, auto-generated by the system.
     * Example: /// Example: COLLECTREQUEST-ID
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val id : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun idInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     * Example: /// Example: U
     * Constraints: Minimum length = 1, Maximum length = 128
     */
    val classificationMarking : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val classificationMarkingAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun classificationMarkingInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * The unique ID of the collect request record from which this request originated. This may be used for cases of sensor-to-sensor tasking, such as tip/cue operations.
     * Example: /// Example: da98671b-34db-47bf-8c8d-7c668b92c800
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idParentReq : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idParentReqAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun idParentReqInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * The type of external message from which this request originated.
     * Example: /// Example: SU67
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val msgType : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val msgTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun msgTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
     * Example: /// Example: 2024-04-25T08:17:01.346Z
     * Constraints: No constraints specified.
     */
    val msgCreateDate : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val msgCreateDateAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun msgCreateDateInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * The type of this collect or contact request (DIRECTED SEARCH, DWELL, OBJECT, POL, RATE TRACK, SEARCH, SOI, STARE, TTC, VOLUME SEARCH, etc.).
     * Example: /// Example: DWELL
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val type : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val typeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun typeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Unique identifier of the parent plan or schedule associated with this request.  If null, this request is assumed not associated with a plan or schedule.
     * Example: /// Example: REF-PLAN-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idPlan : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idPlanAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun idPlanInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * Index number (integer) for records within a collection plan or schedule.
     * Example: /// Example: 8
     * Constraints: No constraints specified.
     */
    val planIndex : Int
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Task ID associated with this request.  A task ID may be associated with a single collect request or may be used to tie together the sub-requests of a full collect, for example a DWELL consisting of many dwell points.
     * Example: /// Example: TASK-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val taskId : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val taskIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun taskIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * The dwell ID associated with this request.  A dwell ID is dwell point specific and a DWELL request consist of many dwell point requests.
     * Example: /// Example: DWELL-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val dwellId : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val dwellIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun dwellIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * Optional ID from external systems.  This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
     * Example: /// Example: EXTERNAL-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val externalId : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val externalIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun externalIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * Unique identifier of the requested/scheduled/planned sensor associated with this request.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
     * Example: /// Example: REF-SENSOR-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idSensor : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idSensorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun idSensorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request. This may be an internal identifier and not necessarily a valid sensor ID.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
     * Example: /// Example: ORIGSENSOR-ID
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origSensorId : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origSensorIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun origSensorIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    /**
     * Optional type of observation (EO, IR, RADAR, RF-ACTIVE, RF-PASSIVE, OTHER) requested.  This field may correspond to a request of a specific sensor, or to a general non sensor specific request.
     * Example: /// Example: RADAR
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val obType : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val obTypeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun obTypeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    /**
     * The priority of the collect request  (EMERGENCY, FLASH, IMMEDIATE, PRIORITY, ROUTINE).
     * Example: /// Example: EMERGENCY
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val priority : String?
        get() {
            val o = __offset(32)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val priorityAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(32, 1)
    fun priorityInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 32, 1)
    /**
     * The (SSN) tasking category (1-5) associated with this request.  The tasking category defines the priority of gathering and transmitting the requested observational data.  Note that category definitions are sensor type specific.
     * Example: /// Example: 4
     * Constraints: No constraints specified.
     */
    val taskCategory : Int
        get() {
            val o = __offset(34)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The (SSN) tasking suffix (A-Z) associated with this request.  The suffix defines the amount of observational data and the frequency of collection.  Note that suffix definitions are sensor type specific.
     * Example: /// Example: T
     * Constraints: Minimum length = 0, Maximum length = 1
     */
    val suffix : String?
        get() {
            val o = __offset(36)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val suffixAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(36, 1)
    fun suffixInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 36, 1)
    /**
     * Boolean indicating that this collect request is UCT follow-up.
     * Example: /// Example: False
     * Constraints: No constraints specified.
     */
    val uctFollowUp : Boolean
        get() {
            val o = __offset(38)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * The start time or earliest time of the collect or contact request window, in ISO 8601 UTC format.
     * Example: /// Example: 2018-01-01T16:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val startTime : String?
        get() {
            val o = __offset(40)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val startTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(40, 1)
    fun startTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 40, 1)
    /**
     * The end time of the collect or contact request window, in ISO 8601 UTC format.  If no endTime or duration is provided it is assumed the request is either ongoing or that the request is for a specified number of tracks (numTracks).  If both duration and endTime are provided, the endTime is assumed to take precedence.
     * Example: /// Example: 2018-01-01T18:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val endTime : String?
        get() {
            val o = __offset(42)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val endTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(42, 1)
    fun endTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 42, 1)
    /**
     * Unique identifier of the target on-orbit object for this request.
     * Example: /// Example: REF-ONORBIT-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idOnOrbit : String?
        get() {
            val o = __offset(44)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idOnOrbitAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(44, 1)
    fun idOnOrbitInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 44, 1)
    /**
     * Satellite/catalog number of the target on-orbit object for this request.
     * Example: /// Example: 101
     * Constraints: No constraints specified.
     */
    val satNo : Int
        get() {
            val o = __offset(46)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Optional identifier provided by the data source to indicate the target object of this request. This may be an internal identifier and not necessarily map to a valid satellite number.
     * Example: /// Example: ORIGOBJECT-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val origObjectId : String?
        get() {
            val o = __offset(48)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origObjectIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(48, 1)
    fun origObjectIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 48, 1)
    /**
     * The tasking group to which the target object is assigned.
     * Example: /// Example: 729
     * Constraints: Minimum length = 0, Maximum length = 16
     */
    val taskGroup : String?
        get() {
            val o = __offset(50)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val taskGroupAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(50, 1)
    fun taskGroupInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 50, 1)
    /**
     * Inter-Range Operations Number.  Four-digit identifier used to schedule and identify AFSCN contact support for booster, launch, and on-orbit operations.
     * Example: /// Example: 3
     * Constraints: No constraints specified.
     */
    val iron : Int
        get() {
            val o = __offset(52)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The orbit regime of the target (GEO, HEO, LAUNCH, LEO, MEO, OTHER).
     * Example: /// Example: GEO
     * Constraints: Minimum length = 0, Maximum length = 12
     */
    val orbitRegime : String?
        get() {
            val o = __offset(54)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val orbitRegimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(54, 1)
    fun orbitRegimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 54, 1)
    /**
     * The minimum object (diameter) size, in meters, to be reported.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val targetSize : Double
        get() {
            val o = __offset(56)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The minimum Radar Cross-Section of the target, in m^2.  If only minimum RCS is provided it is assumed to be minimum reportable RCS.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val rcsMin : Double
        get() {
            val o = __offset(58)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The Radar Cross-Section of the target, in m^2.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val rcs : Double
        get() {
            val o = __offset(60)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The maximum Radar Cross-Section of the target, in m^2.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val rcsMax : Double
        get() {
            val o = __offset(62)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The minimum frequency of interest, in MHz.  If only minimum frequency is provided it is assumed to be minimum reportable frequency.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val freqMin : Double
        get() {
            val o = __offset(64)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The estimated or expected emission frequency of the target, in MHz.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val freq : Double
        get() {
            val o = __offset(66)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The maximum frequency of interest, in MHz.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val freqMax : Double
        get() {
            val o = __offset(68)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The RF polarization (H, LHC, RHC, V).
     * Example: /// Example: H
     * Constraints: Minimum length = 0, Maximum length = 4
     */
    val polarization : String?
        get() {
            val o = __offset(70)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val polarizationAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(70, 1)
    fun polarizationInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 70, 1)
    /**
     * The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).  If only minimum vismag is provided it is assumed to be minimum reportable vismag.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val visMagMin : Double
        get() {
            val o = __offset(72)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The estimated or expected visual magnitude of the target, in Magnitudes (M).
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val visMag : Double
        get() {
            val o = __offset(74)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val visMagMax : Double
        get() {
            val o = __offset(76)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The spectral model used for the irradiance calculation.
     * Example: /// Example: Example Model
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val spectralModel : String?
        get() {
            val o = __offset(78)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val spectralModelAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(78, 1)
    fun spectralModelInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 78, 1)
    /**
     * The fraction of solar energy reflected from target.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val reflectance : Double
        get() {
            val o = __offset(80)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The target object irradiance value.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val irradiance : Double
        get() {
            val o = __offset(82)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * For optical sensors, the requested number of frames to capture at each sensor step.
     * Example: /// Example: 6
     * Constraints: No constraints specified.
     */
    val numFrames : Int
        get() {
            val o = __offset(84)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * For optical sensors, the frame rate of the camera, in Hz.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val frameRate : Double
        get() {
            val o = __offset(86)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * For optical sensors, the integration time per camera frame, in milliseconds.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val integrationTime : Double
        get() {
            val o = __offset(88)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The number of requested tracks on the target.  If numTracks is not provided it is assumed to indicate all possible observations every pass over the request duration or within the request start/end window.
     * Example: /// Example: 3
     * Constraints: No constraints specified.
     */
    val numTracks : Int
        get() {
            val o = __offset(90)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The number of requested observations on the target.
     * Example: /// Example: 9
     * Constraints: No constraints specified.
     */
    val numObs : Int
        get() {
            val o = __offset(92)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The duration of the collect request, in seconds.  If both duration and endTime are provided, the endTime is assumed to take precedence.
     * Example: /// Example: 11
     * Constraints: No constraints specified.
     */
    val duration : Int
        get() {
            val o = __offset(94)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The search pattern to be executed for this request (e.g. PICKET-FENCE, SCAN, etc.).
     * Example: /// Example: SCAN
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val srchPattern : String?
        get() {
            val o = __offset(96)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val srchPatternAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(96, 1)
    fun srchPatternInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 96, 1)
    /**
     * Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
     * Example: /// Example: Example direction
     * Constraints: Minimum length = 0, Maximum length = 24
     */
    val scenario : String?
        get() {
            val o = __offset(98)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val scenarioAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(98, 1)
    fun scenarioInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 98, 1)
    /**
     * ID of the UDL Elset of the object associated with this request.
     * Example: /// Example: REF-ELSET-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idElset : String?
        get() {
            val o = __offset(100)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idElsetAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(100, 1)
    fun idElsetInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 100, 1)
    /**
     * ID of the UDL Manifold Elset of the object associated with this request.  A Manifold Elset provides theoretical Keplerian orbital elements belonging to an object of interest's manifold describing a possible/theoretical orbit for an object of interest for tasking purposes.
     * Example: /// Example: REF-MANIFOLD-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idManifold : String?
        get() {
            val o = __offset(102)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idManifoldAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(102, 1)
    fun idManifoldInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 102, 1)
    /**
     * ID of the UDL State Vector of the object or central vector associated with this request.
     * Example: /// Example: STATEVECTOR-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idStateVector : String?
        get() {
            val o = __offset(104)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idStateVectorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(104, 1)
    fun idStateVectorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 104, 1)
    /**
     * ID of the UDL Ephemeris Set of the object associated with this request.
     * Example: /// Example: ES-ID
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val esId : String?
        get() {
            val o = __offset(106)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val esIdAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(106, 1)
    fun esIdInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 106, 1)
    /**
     * Epoch time, in ISO 8601 UTC format, of the orbital elements.
     * Example: /// Example: 2018-01-01T16:00:00.123456Z
     * Constraints: No constraints specified.
     */
    val epoch : String?
        get() {
            val o = __offset(108)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val epochAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(108, 1)
    fun epochInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 108, 1)
    /**
     * The average of the periapsis and apoapsis distances, in kilometers. For circular orbits, the semimajor axis is the distance between the centers of the bodies.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val semiMajorAxis : Double
        get() {
            val o = __offset(110)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val eccentricity : Double
        get() {
            val o = __offset(112)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The angle, in degrees, between the equator and the orbit plane when looking from the center of the Earth. Inclination ranges from 0-180 degrees, with 0-90 representing posigrade orbits and 90-180 representing retrograde orbits.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val inclination : Double
        get() {
            val o = __offset(114)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val raan : Double
        get() {
            val o = __offset(116)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The argument of perigee is the angle, in degrees, formed between the perigee and the ascending node.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val argOfPerigee : Double
        get() {
            val o = __offset(118)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The true anomaly defines the angular position, in degrees, of the object on it's orbital path as measured from the orbit focal point at epoch.  The true anomaly is referenced from perigee.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val trueAnomoly : Double
        get() {
            val o = __offset(120)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The expected or directed right ascension angle, in degrees, for search or target acquisition.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val ra : Double
        get() {
            val o = __offset(122)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The expected or directed declination angle, in degrees, for search or target acquisition.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val dec : Double
        get() {
            val o = __offset(124)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The expected or directed azimuth angle, in degrees, for search or target acquisition.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val az : Double
        get() {
            val o = __offset(126)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The expected or directed elevation angle, in degrees, for search or target acquisition.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val el : Double
        get() {
            val o = __offset(128)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The expected acquisition range or defined center range, in km.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val range : Double
        get() {
            val o = __offset(130)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The extent of the azimuth angle, in degrees, from center azimuth to define a spatial volume.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val extentAz : Double
        get() {
            val o = __offset(132)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The extent of the elevation angle, in degrees, from center elevation to define a spatial volume.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val extentEl : Double
        get() {
            val o = __offset(134)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The extent of the range, in km, from center range to define a spatial volume.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val extentRange : Double
        get() {
            val o = __offset(136)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 latitude, in degrees. -90 to 90 degrees (negative values south of equator).  If an accompanying stopLat is provided, then the lat value can be assumed to be the starting latitude of a volume definition.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val lat : Double
        get() {
            val o = __offset(138)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).  If an accompanying stopLon is provided, then lon value can be assumed to be the starting longitude of a volume definition.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val lon : Double
        get() {
            val o = __offset(140)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Height above WGS-84 ellipsoid (HAE), in kilometers.  If an accompanying stopAlt is provided, then alt value can be assumed to be the starting altitude of a volume definition.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val alt : Double
        get() {
            val o = __offset(142)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The stopping WGS-84 latitude of a volume definition, in degrees.  -90 to 90 degrees (negative values south of equator).  The stopLat value is only meaningful if a (starting) lat value is provided.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val stopLat : Double
        get() {
            val o = __offset(144)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The stopping WGS-84 longitude of a volume definition, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian).  The stopLon value is only meaningful if a (starting) lon value is provided.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val stopLon : Double
        get() {
            val o = __offset(146)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The stopping HAE WGS-84 height above ellipsoid (HAE), of a volume definition, in kilometers.  The stopAlt value is only meaningful if a (starting) alt value is provided.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val stopAlt : Double
        get() {
            val o = __offset(148)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The maximum inclination, in degrees, to be used in search operations.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val srchInc : Double
        get() {
            val o = __offset(150)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The angular distance, in degrees, in the sensor-x direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val xAngle : Double
        get() {
            val o = __offset(152)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The angular distance, in degrees, in the sensor-y direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val yAngle : Double
        get() {
            val o = __offset(154)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.  A positive value indicates clockwise rotation about the sensor boresight vector.
     * Example: /// Example: 1.1
     * Constraints: No constraints specified.
     */
    val orientAngle : Double
        get() {
            val o = __offset(156)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The customer for this request.
     * Example: /// Example: Bluestaq
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val customer : String?
        get() {
            val o = __offset(158)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val customerAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(158, 1)
    fun customerInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 158, 1)
    /**
     * Notes or comments associated with this request.
     * Example: /// Example: Example notes
     * Constraints: Minimum length = 0, Maximum length = 512
     */
    val notes : String?
        get() {
            val o = __offset(160)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val notesAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(160, 1)
    fun notesInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 160, 1)
    /**
     * Time the row was created in the database, auto-populated by the system.
     * Example: /// Example: 2018-01-01T16:00:00.123Z
     * Constraints: No constraints specified.
     */
    val createdAt : String?
        get() {
            val o = __offset(162)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdAtAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(162, 1)
    fun createdAtInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 162, 1)
    /**
     * Application user who created the row in the database, auto-populated by the system.
     * Example: /// Example: some.user
     * Constraints: Minimum length = 1, Maximum length = 64
     */
    val createdBy : String?
        get() {
            val o = __offset(164)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val createdByAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(164, 1)
    fun createdByInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 164, 1)
    /**
     * Source of the data.
     * Example: /// Example: Bluestaq
     * Constraints: Minimum length = 1, Maximum length = 36
     */
    val source : String?
        get() {
            val o = __offset(166)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val sourceAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(166, 1)
    fun sourceInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 166, 1)
    /**
     * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     * Example: /// Example: Example source
     * Constraints: Minimum length = 0, Maximum length = 64
     */
    val origin : String?
        get() {
            val o = __offset(168)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val originAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(168, 1)
    fun originInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 168, 1)
    /**
     * The originating source network on which this record was created, auto-populated by the system.
     * Example: /// Example: ORIG
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val origNetwork : String?
        get() {
            val o = __offset(170)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val origNetworkAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(170, 1)
    fun origNetworkInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 170, 1)
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
     * Example: /// Example: TEST
     * Constraints: Minimum length = 1, Maximum length = 32
     */
    val dataMode : Byte
        get() {
            val o = __offset(172)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * No description provided.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    val stateVector : String?
        get() {
            val o = __offset(174)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val stateVectorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(174, 1)
    fun stateVectorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 174, 1)
    /**
     * No description provided.
     * Example: /// Example: No example provided.
     * Constraints: No constraints specified.
     */
    val elset : String?
        get() {
            val o = __offset(176)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val elsetAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(176, 1)
    fun elsetInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 176, 1)
    /**
     * Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
     * Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
     * Constraints: No constraints specified.
     */
    fun tags(j: Int) : String? {
        val o = __offset(178)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val tagsLength : Int
        get() {
            val o = __offset(178); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsCollectRequest_Ingest(_bb: ByteBuffer): CollectRequest_Ingest = getRootAsCollectRequest_Ingest(_bb, CollectRequest_Ingest())
        fun getRootAsCollectRequest_Ingest(_bb: ByteBuffer, obj: CollectRequest_Ingest): CollectRequest_Ingest {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun CollectRequest_IngestBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "COLL")
        fun createCollectRequest_Ingest(builder: FlatBufferBuilder, idOffset: Int, classificationMarkingOffset: Int, idParentReqOffset: Int, msgTypeOffset: Int, msgCreateDateOffset: Int, typeOffset: Int, idPlanOffset: Int, planIndex: Int, taskIdOffset: Int, dwellIdOffset: Int, externalIdOffset: Int, idSensorOffset: Int, origSensorIdOffset: Int, obTypeOffset: Int, priorityOffset: Int, taskCategory: Int, suffixOffset: Int, uctFollowUp: Boolean, startTimeOffset: Int, endTimeOffset: Int, idOnOrbitOffset: Int, satNo: Int, origObjectIdOffset: Int, taskGroupOffset: Int, iron: Int, orbitRegimeOffset: Int, targetSize: Double, rcsMin: Double, rcs: Double, rcsMax: Double, freqMin: Double, freq: Double, freqMax: Double, polarizationOffset: Int, visMagMin: Double, visMag: Double, visMagMax: Double, spectralModelOffset: Int, reflectance: Double, irradiance: Double, numFrames: Int, frameRate: Double, integrationTime: Double, numTracks: Int, numObs: Int, duration: Int, srchPatternOffset: Int, scenarioOffset: Int, idElsetOffset: Int, idManifoldOffset: Int, idStateVectorOffset: Int, esIdOffset: Int, epochOffset: Int, semiMajorAxis: Double, eccentricity: Double, inclination: Double, raan: Double, argOfPerigee: Double, trueAnomoly: Double, ra: Double, dec: Double, az: Double, el: Double, range: Double, extentAz: Double, extentEl: Double, extentRange: Double, lat: Double, lon: Double, alt: Double, stopLat: Double, stopLon: Double, stopAlt: Double, srchInc: Double, xAngle: Double, yAngle: Double, orientAngle: Double, customerOffset: Int, notesOffset: Int, createdAtOffset: Int, createdByOffset: Int, sourceOffset: Int, originOffset: Int, origNetworkOffset: Int, dataMode: Byte, stateVectorOffset: Int, elsetOffset: Int, tagsOffset: Int) : Int {
            builder.startTable(88)
            addOrientAngle(builder, orientAngle)
            addYAngle(builder, yAngle)
            addXAngle(builder, xAngle)
            addSrchInc(builder, srchInc)
            addStopAlt(builder, stopAlt)
            addStopLon(builder, stopLon)
            addStopLat(builder, stopLat)
            addAlt(builder, alt)
            addLon(builder, lon)
            addLat(builder, lat)
            addExtentRange(builder, extentRange)
            addExtentEl(builder, extentEl)
            addExtentAz(builder, extentAz)
            addRange(builder, range)
            addEl(builder, el)
            addAz(builder, az)
            addDec(builder, dec)
            addRa(builder, ra)
            addTrueAnomoly(builder, trueAnomoly)
            addArgOfPerigee(builder, argOfPerigee)
            addRaan(builder, raan)
            addInclination(builder, inclination)
            addEccentricity(builder, eccentricity)
            addSemiMajorAxis(builder, semiMajorAxis)
            addIntegrationTime(builder, integrationTime)
            addFrameRate(builder, frameRate)
            addIrradiance(builder, irradiance)
            addReflectance(builder, reflectance)
            addVisMagMax(builder, visMagMax)
            addVisMag(builder, visMag)
            addVisMagMin(builder, visMagMin)
            addFreqMax(builder, freqMax)
            addFreq(builder, freq)
            addFreqMin(builder, freqMin)
            addRcsMax(builder, rcsMax)
            addRcs(builder, rcs)
            addRcsMin(builder, rcsMin)
            addTargetSize(builder, targetSize)
            addTags(builder, tagsOffset)
            addElset(builder, elsetOffset)
            addStateVector(builder, stateVectorOffset)
            addOrigNetwork(builder, origNetworkOffset)
            addOrigin(builder, originOffset)
            addSource(builder, sourceOffset)
            addCreatedBy(builder, createdByOffset)
            addCreatedAt(builder, createdAtOffset)
            addNotes(builder, notesOffset)
            addCustomer(builder, customerOffset)
            addEpoch(builder, epochOffset)
            addEsId(builder, esIdOffset)
            addIdStateVector(builder, idStateVectorOffset)
            addIdManifold(builder, idManifoldOffset)
            addIdElset(builder, idElsetOffset)
            addScenario(builder, scenarioOffset)
            addSrchPattern(builder, srchPatternOffset)
            addDuration(builder, duration)
            addNumObs(builder, numObs)
            addNumTracks(builder, numTracks)
            addNumFrames(builder, numFrames)
            addSpectralModel(builder, spectralModelOffset)
            addPolarization(builder, polarizationOffset)
            addOrbitRegime(builder, orbitRegimeOffset)
            addIron(builder, iron)
            addTaskGroup(builder, taskGroupOffset)
            addOrigObjectId(builder, origObjectIdOffset)
            addSatNo(builder, satNo)
            addIdOnOrbit(builder, idOnOrbitOffset)
            addEndTime(builder, endTimeOffset)
            addStartTime(builder, startTimeOffset)
            addSuffix(builder, suffixOffset)
            addTaskCategory(builder, taskCategory)
            addPriority(builder, priorityOffset)
            addObType(builder, obTypeOffset)
            addOrigSensorId(builder, origSensorIdOffset)
            addIdSensor(builder, idSensorOffset)
            addExternalId(builder, externalIdOffset)
            addDwellId(builder, dwellIdOffset)
            addTaskId(builder, taskIdOffset)
            addPlanIndex(builder, planIndex)
            addIdPlan(builder, idPlanOffset)
            addType(builder, typeOffset)
            addMsgCreateDate(builder, msgCreateDateOffset)
            addMsgType(builder, msgTypeOffset)
            addIdParentReq(builder, idParentReqOffset)
            addClassificationMarking(builder, classificationMarkingOffset)
            addId(builder, idOffset)
            addDataMode(builder, dataMode)
            addUctFollowUp(builder, uctFollowUp)
            return endCollectRequest_Ingest(builder)
        }
        fun startCollectRequest_Ingest(builder: FlatBufferBuilder) = builder.startTable(88)
        fun addId(builder: FlatBufferBuilder, id: Int) = builder.addOffset(0, id, 0)
        fun addClassificationMarking(builder: FlatBufferBuilder, classificationMarking: Int) = builder.addOffset(1, classificationMarking, 0)
        fun addIdParentReq(builder: FlatBufferBuilder, idParentReq: Int) = builder.addOffset(2, idParentReq, 0)
        fun addMsgType(builder: FlatBufferBuilder, msgType: Int) = builder.addOffset(3, msgType, 0)
        fun addMsgCreateDate(builder: FlatBufferBuilder, msgCreateDate: Int) = builder.addOffset(4, msgCreateDate, 0)
        fun addType(builder: FlatBufferBuilder, type: Int) = builder.addOffset(5, type, 0)
        fun addIdPlan(builder: FlatBufferBuilder, idPlan: Int) = builder.addOffset(6, idPlan, 0)
        fun addPlanIndex(builder: FlatBufferBuilder, planIndex: Int) = builder.addInt(7, planIndex, 0)
        fun addTaskId(builder: FlatBufferBuilder, taskId: Int) = builder.addOffset(8, taskId, 0)
        fun addDwellId(builder: FlatBufferBuilder, dwellId: Int) = builder.addOffset(9, dwellId, 0)
        fun addExternalId(builder: FlatBufferBuilder, externalId: Int) = builder.addOffset(10, externalId, 0)
        fun addIdSensor(builder: FlatBufferBuilder, idSensor: Int) = builder.addOffset(11, idSensor, 0)
        fun addOrigSensorId(builder: FlatBufferBuilder, origSensorId: Int) = builder.addOffset(12, origSensorId, 0)
        fun addObType(builder: FlatBufferBuilder, obType: Int) = builder.addOffset(13, obType, 0)
        fun addPriority(builder: FlatBufferBuilder, priority: Int) = builder.addOffset(14, priority, 0)
        fun addTaskCategory(builder: FlatBufferBuilder, taskCategory: Int) = builder.addInt(15, taskCategory, 0)
        fun addSuffix(builder: FlatBufferBuilder, suffix: Int) = builder.addOffset(16, suffix, 0)
        fun addUctFollowUp(builder: FlatBufferBuilder, uctFollowUp: Boolean) = builder.addBoolean(17, uctFollowUp, false)
        fun addStartTime(builder: FlatBufferBuilder, startTime: Int) = builder.addOffset(18, startTime, 0)
        fun addEndTime(builder: FlatBufferBuilder, endTime: Int) = builder.addOffset(19, endTime, 0)
        fun addIdOnOrbit(builder: FlatBufferBuilder, idOnOrbit: Int) = builder.addOffset(20, idOnOrbit, 0)
        fun addSatNo(builder: FlatBufferBuilder, satNo: Int) = builder.addInt(21, satNo, 0)
        fun addOrigObjectId(builder: FlatBufferBuilder, origObjectId: Int) = builder.addOffset(22, origObjectId, 0)
        fun addTaskGroup(builder: FlatBufferBuilder, taskGroup: Int) = builder.addOffset(23, taskGroup, 0)
        fun addIron(builder: FlatBufferBuilder, iron: Int) = builder.addInt(24, iron, 0)
        fun addOrbitRegime(builder: FlatBufferBuilder, orbitRegime: Int) = builder.addOffset(25, orbitRegime, 0)
        fun addTargetSize(builder: FlatBufferBuilder, targetSize: Double) = builder.addDouble(26, targetSize, 0.0)
        fun addRcsMin(builder: FlatBufferBuilder, rcsMin: Double) = builder.addDouble(27, rcsMin, 0.0)
        fun addRcs(builder: FlatBufferBuilder, rcs: Double) = builder.addDouble(28, rcs, 0.0)
        fun addRcsMax(builder: FlatBufferBuilder, rcsMax: Double) = builder.addDouble(29, rcsMax, 0.0)
        fun addFreqMin(builder: FlatBufferBuilder, freqMin: Double) = builder.addDouble(30, freqMin, 0.0)
        fun addFreq(builder: FlatBufferBuilder, freq: Double) = builder.addDouble(31, freq, 0.0)
        fun addFreqMax(builder: FlatBufferBuilder, freqMax: Double) = builder.addDouble(32, freqMax, 0.0)
        fun addPolarization(builder: FlatBufferBuilder, polarization: Int) = builder.addOffset(33, polarization, 0)
        fun addVisMagMin(builder: FlatBufferBuilder, visMagMin: Double) = builder.addDouble(34, visMagMin, 0.0)
        fun addVisMag(builder: FlatBufferBuilder, visMag: Double) = builder.addDouble(35, visMag, 0.0)
        fun addVisMagMax(builder: FlatBufferBuilder, visMagMax: Double) = builder.addDouble(36, visMagMax, 0.0)
        fun addSpectralModel(builder: FlatBufferBuilder, spectralModel: Int) = builder.addOffset(37, spectralModel, 0)
        fun addReflectance(builder: FlatBufferBuilder, reflectance: Double) = builder.addDouble(38, reflectance, 0.0)
        fun addIrradiance(builder: FlatBufferBuilder, irradiance: Double) = builder.addDouble(39, irradiance, 0.0)
        fun addNumFrames(builder: FlatBufferBuilder, numFrames: Int) = builder.addInt(40, numFrames, 0)
        fun addFrameRate(builder: FlatBufferBuilder, frameRate: Double) = builder.addDouble(41, frameRate, 0.0)
        fun addIntegrationTime(builder: FlatBufferBuilder, integrationTime: Double) = builder.addDouble(42, integrationTime, 0.0)
        fun addNumTracks(builder: FlatBufferBuilder, numTracks: Int) = builder.addInt(43, numTracks, 0)
        fun addNumObs(builder: FlatBufferBuilder, numObs: Int) = builder.addInt(44, numObs, 0)
        fun addDuration(builder: FlatBufferBuilder, duration: Int) = builder.addInt(45, duration, 0)
        fun addSrchPattern(builder: FlatBufferBuilder, srchPattern: Int) = builder.addOffset(46, srchPattern, 0)
        fun addScenario(builder: FlatBufferBuilder, scenario: Int) = builder.addOffset(47, scenario, 0)
        fun addIdElset(builder: FlatBufferBuilder, idElset: Int) = builder.addOffset(48, idElset, 0)
        fun addIdManifold(builder: FlatBufferBuilder, idManifold: Int) = builder.addOffset(49, idManifold, 0)
        fun addIdStateVector(builder: FlatBufferBuilder, idStateVector: Int) = builder.addOffset(50, idStateVector, 0)
        fun addEsId(builder: FlatBufferBuilder, esId: Int) = builder.addOffset(51, esId, 0)
        fun addEpoch(builder: FlatBufferBuilder, epoch: Int) = builder.addOffset(52, epoch, 0)
        fun addSemiMajorAxis(builder: FlatBufferBuilder, semiMajorAxis: Double) = builder.addDouble(53, semiMajorAxis, 0.0)
        fun addEccentricity(builder: FlatBufferBuilder, eccentricity: Double) = builder.addDouble(54, eccentricity, 0.0)
        fun addInclination(builder: FlatBufferBuilder, inclination: Double) = builder.addDouble(55, inclination, 0.0)
        fun addRaan(builder: FlatBufferBuilder, raan: Double) = builder.addDouble(56, raan, 0.0)
        fun addArgOfPerigee(builder: FlatBufferBuilder, argOfPerigee: Double) = builder.addDouble(57, argOfPerigee, 0.0)
        fun addTrueAnomoly(builder: FlatBufferBuilder, trueAnomoly: Double) = builder.addDouble(58, trueAnomoly, 0.0)
        fun addRa(builder: FlatBufferBuilder, ra: Double) = builder.addDouble(59, ra, 0.0)
        fun addDec(builder: FlatBufferBuilder, dec: Double) = builder.addDouble(60, dec, 0.0)
        fun addAz(builder: FlatBufferBuilder, az: Double) = builder.addDouble(61, az, 0.0)
        fun addEl(builder: FlatBufferBuilder, el: Double) = builder.addDouble(62, el, 0.0)
        fun addRange(builder: FlatBufferBuilder, range: Double) = builder.addDouble(63, range, 0.0)
        fun addExtentAz(builder: FlatBufferBuilder, extentAz: Double) = builder.addDouble(64, extentAz, 0.0)
        fun addExtentEl(builder: FlatBufferBuilder, extentEl: Double) = builder.addDouble(65, extentEl, 0.0)
        fun addExtentRange(builder: FlatBufferBuilder, extentRange: Double) = builder.addDouble(66, extentRange, 0.0)
        fun addLat(builder: FlatBufferBuilder, lat: Double) = builder.addDouble(67, lat, 0.0)
        fun addLon(builder: FlatBufferBuilder, lon: Double) = builder.addDouble(68, lon, 0.0)
        fun addAlt(builder: FlatBufferBuilder, alt: Double) = builder.addDouble(69, alt, 0.0)
        fun addStopLat(builder: FlatBufferBuilder, stopLat: Double) = builder.addDouble(70, stopLat, 0.0)
        fun addStopLon(builder: FlatBufferBuilder, stopLon: Double) = builder.addDouble(71, stopLon, 0.0)
        fun addStopAlt(builder: FlatBufferBuilder, stopAlt: Double) = builder.addDouble(72, stopAlt, 0.0)
        fun addSrchInc(builder: FlatBufferBuilder, srchInc: Double) = builder.addDouble(73, srchInc, 0.0)
        fun addXAngle(builder: FlatBufferBuilder, xAngle: Double) = builder.addDouble(74, xAngle, 0.0)
        fun addYAngle(builder: FlatBufferBuilder, yAngle: Double) = builder.addDouble(75, yAngle, 0.0)
        fun addOrientAngle(builder: FlatBufferBuilder, orientAngle: Double) = builder.addDouble(76, orientAngle, 0.0)
        fun addCustomer(builder: FlatBufferBuilder, customer: Int) = builder.addOffset(77, customer, 0)
        fun addNotes(builder: FlatBufferBuilder, notes: Int) = builder.addOffset(78, notes, 0)
        fun addCreatedAt(builder: FlatBufferBuilder, createdAt: Int) = builder.addOffset(79, createdAt, 0)
        fun addCreatedBy(builder: FlatBufferBuilder, createdBy: Int) = builder.addOffset(80, createdBy, 0)
        fun addSource(builder: FlatBufferBuilder, source: Int) = builder.addOffset(81, source, 0)
        fun addOrigin(builder: FlatBufferBuilder, origin: Int) = builder.addOffset(82, origin, 0)
        fun addOrigNetwork(builder: FlatBufferBuilder, origNetwork: Int) = builder.addOffset(83, origNetwork, 0)
        fun addDataMode(builder: FlatBufferBuilder, dataMode: Byte) = builder.addByte(84, dataMode, 0)
        fun addStateVector(builder: FlatBufferBuilder, stateVector: Int) = builder.addOffset(85, stateVector, 0)
        fun addElset(builder: FlatBufferBuilder, elset: Int) = builder.addOffset(86, elset, 0)
        fun addTags(builder: FlatBufferBuilder, tags: Int) = builder.addOffset(87, tags, 0)
        fun createTagsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTagsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endCollectRequest_Ingest(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishCollectRequestIngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "COLL")
        fun finishSizePrefixedCollectRequest_IngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "COLL")
    }
}
