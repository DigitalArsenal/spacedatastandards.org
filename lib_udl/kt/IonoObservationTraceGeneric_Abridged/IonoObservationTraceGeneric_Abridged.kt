// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// Multi dimensional array of trace generic data.
 */
@Suppress("unused")
class IonoObservationTraceGeneric_Abridged : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : IonoObservationTraceGeneric_Abridged {
        __init(_i, _bb)
        return this
    }
    /**
     * Multi-dimensional Array. The 1st dimension spans points along the trace while the 2nd dimension spans frequency-range pairs.
     * Example: /// Example: [[[1.23, 1.0903]]]
     * Constraints: No constraints specified.
     */
    fun data(j: Int) : String? {
        val o = __offset(4)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val dataLength : Int
        get() {
            val o = __offset(4); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of dimension names for trace generic data.
     * Example: /// Example: ['NAME1', 'NAME2']
     * Constraints: No constraints specified.
     */
    fun dimensionName(j: Int) : String? {
        val o = __offset(6)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val dimensionNameLength : Int
        get() {
            val o = __offset(6); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Notes for the trace generic data.
     * Example: /// Example: NOTES
     * Constraints: Minimum length = 0, Maximum length = 512
     */
    val notes : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val notesAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun notesInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsIonoObservationTraceGeneric_Abridged(_bb: ByteBuffer): IonoObservationTraceGeneric_Abridged = getRootAsIonoObservationTraceGeneric_Abridged(_bb, IonoObservationTraceGeneric_Abridged())
        fun getRootAsIonoObservationTraceGeneric_Abridged(_bb: ByteBuffer, obj: IonoObservationTraceGeneric_Abridged): IonoObservationTraceGeneric_Abridged {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun IonoObservationTraceGeneric_AbridgedBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "IONO")
        fun createIonoObservationTraceGeneric_Abridged(builder: FlatBufferBuilder, dataOffset: Int, dimensionNameOffset: Int, notesOffset: Int) : Int {
            builder.startTable(3)
            addNotes(builder, notesOffset)
            addDimensionName(builder, dimensionNameOffset)
            addData(builder, dataOffset)
            return endIonoObservationTraceGeneric_Abridged(builder)
        }
        fun startIonoObservationTraceGeneric_Abridged(builder: FlatBufferBuilder) = builder.startTable(3)
        fun addData(builder: FlatBufferBuilder, data: Int) = builder.addOffset(0, data, 0)
        fun createDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addDimensionName(builder: FlatBufferBuilder, dimensionName: Int) = builder.addOffset(1, dimensionName, 0)
        fun createDimensionNameVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startDimensionNameVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addNotes(builder: FlatBufferBuilder, notes: Int) = builder.addOffset(2, notes, 0)
        fun endIonoObservationTraceGeneric_Abridged(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishIonoObservationTraceGenericAbridgedBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "IONO")
        fun finishSizePrefixedIonoObservationTraceGeneric_AbridgedBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "IONO")
    }
}
