// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * /// A Radar SOI record contains observation information taken from a sensor about a Space Object.
 */
@Suppress("unused")
class RadarSOIObservation_Ingest : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : RadarSOIObservation_Ingest {
        __init(_i, _bb)
        return this
    }
    /**
     * Observation detection start time in ISO 8601 UTC format with microsecond precision.
     * Example: /// Example: 2018-01-01T16:00:00.888456Z
     * Constraints: No constraints specified.
     */
    val obStartTime : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val obStartTimeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun obStartTimeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Array of the times of validity in ISO 8601 UTC format with microsecond precision.
     * Example: /// Example: ['2018-01-01T16:00:00.888456Z', '2018-01-01T16:00:00.888456Z', '2018-01-01T16:00:00.888456Z']
     * Constraints: No constraints specified.
     */
    fun tovs(j: Int) : String? {
        val o = __offset(6)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val tovsLength : Int
        get() {
            val o = __offset(6); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of range sample spacing in meters. The 'tov' and 'rspace' arrays must match in size.
     * Example: /// Example: [0.006, 0.006, 0.006]
     * Constraints: No constraints specified.
     */
    fun rspaces(j: Int) : String? {
        val o = __offset(8)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val rspacesLength : Int
        get() {
            val o = __offset(8); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of cross-range sample spacing in meters. The 'tov' and 'xspace' arrays must match in size.
     * Example: /// Example: [0.006, 0.006, 0.006]
     * Constraints: No constraints specified.
     */
    fun xspaces(j: Int) : String? {
        val o = __offset(10)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val xspacesLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of conversion factors between Doppler in hertz and cross-range in meters. The 'tov' and 'doppler2XR' arrays must match in size.
     * Example: /// Example: [5644.27, 5644.27, 5644.27]
     * Constraints: No constraints specified.
     */
    fun doppler2Xrs(j: Int) : String? {
        val o = __offset(12)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val doppler2XrsLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of average Interpulse spacing in seconds. The 'tov' and 'deltaTime' arrays must match in size.
     * Example: /// Example: [0.005, 0.005, 0.005]
     * Constraints: No constraints specified.
     */
    fun deltaTimes(j: Int) : String? {
        val o = __offset(14)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val deltaTimesLength : Int
        get() {
            val o = __offset(14); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the aspect angle at the center of the image in degrees.  The 'tov' and 'aspectAngle' arrays must match in size.
     * Example: /// Example: [4.278, 4.278, 4.278]
     * Constraints: No constraints specified.
     */
    fun aspectAngles(j: Int) : String? {
        val o = __offset(16)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val aspectAnglesLength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the component of target angular velocity observable by radar in radians per second.  The 'tov' and 'projAngVel' arrays must match in size.
     * Example: /// Example: [0.166, 0.166, 0.166]
     * Constraints: No constraints specified.
     */
    fun projAngVels(j: Int) : String? {
        val o = __offset(18)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val projAngVelsLength : Int
        get() {
            val o = __offset(18); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Optional id of assumed StateVector of object being observed.
     * Example: /// Example: 99a0de63-b38f-4d81-b057
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idStateVector : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idStateVectorAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun idStateVectorInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Optional id of assumed AttitudeSet of object being observed.
     * Example: /// Example: 99a0de63-b38f-4d81-b057
     * Constraints: Minimum length = 0, Maximum length = 36
     */
    val idAttitudeSet : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idAttitudeSetAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun idAttitudeSetInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * Array of the range to target at image center in kilometers. The 'tov' and 'range' arrays must match in size.
     * Example: /// Example: [877.938, 877.938, 877.938]
     * Constraints: No constraints specified.
     */
    fun ranges(j: Int) : String? {
        val o = __offset(24)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val rangesLength : Int
        get() {
            val o = __offset(24); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the azimuth angle to target at image center in degrees. The 'tov' and 'azimuth' arrays must match in size.
     * Example: /// Example: [278.27, 278.27, 278.27]
     * Constraints: No constraints specified.
     */
    fun azimuths(j: Int) : String? {
        val o = __offset(26)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val azimuthsLength : Int
        get() {
            val o = __offset(26); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the elevation angle to target at image center in degrees. The 'tov' and 'elevation' arrays must match in size.
     * Example: /// Example: [70.85, 70.85, 70.85]
     * Constraints: No constraints specified.
     */
    fun elevations(j: Int) : String? {
        val o = __offset(28)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val elevationsLength : Int
        get() {
            val o = __offset(28); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the range rate of target at image center in kilometers per second. The 'tov' and 'rangeRate' arrays must match in size.
     * Example: /// Example: [0.317, 0.317, 0.317]
     * Constraints: No constraints specified.
     */
    fun rangeRates(j: Int) : String? {
        val o = __offset(30)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val rangeRatesLength : Int
        get() {
            val o = __offset(30); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the azimuth rate of target at image center in degrees per second. The 'tov' and 'azimuthRate' arrays must match in size.
     * Example: /// Example: [-1.481, -1.481, -1.481]
     * Constraints: No constraints specified.
     */
    fun azimuthRates(j: Int) : String? {
        val o = __offset(32)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val azimuthRatesLength : Int
        get() {
            val o = __offset(32); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the elevation rate of target at image center in degrees per second. The 'tov' and 'elevationRate' arrays must match in size.
     * Example: /// Example: [-0.074, -0.074, -0.074]
     * Constraints: No constraints specified.
     */
    fun elevationRates(j: Int) : String? {
        val o = __offset(34)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val elevationRatesLength : Int
        get() {
            val o = __offset(34); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of  sensor azimuth angle biases in degrees. The 'tov' and 'azimuthBias' arrays must match in size.
     * Example: /// Example: [45.23, 45.23, 45.23]
     * Constraints: No constraints specified.
     */
    fun azimuthBiases(j: Int) : String? {
        val o = __offset(36)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val azimuthBiasesLength : Int
        get() {
            val o = __offset(36); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of sensor elevation biases in degrees. The 'tov' and 'elevationBias' arrays must match in size.
     * Example: /// Example: [1.23, 1.23, 1.23]
     * Constraints: No constraints specified.
     */
    fun elevationBiases(j: Int) : String? {
        val o = __offset(38)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val elevationBiasesLength : Int
        get() {
            val o = __offset(38); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of sensor range biases in kilometers. The 'tov' and 'rangeBias' arrays must match in size.
     * Example: /// Example: [1.23, 1.23, 1.23]
     * Constraints: No constraints specified.
     */
    fun rangeBiases(j: Int) : String? {
        val o = __offset(40)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val rangeBiasesLength : Int
        get() {
            val o = __offset(40); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of Integration angles in degrees. The 'tov' and 'integrationAngle' arrays must match in size.
     * Example: /// Example: [8.594, 8.594, 8.594]
     * Constraints: No constraints specified.
     */
    fun integrationAngles(j: Int) : String? {
        val o = __offset(42)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val integrationAnglesLength : Int
        get() {
            val o = __offset(42); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of cross-range resolutions (accounting for weighting function) in kilometers. The 'tov' and 'crossRangeRes' arrays must match in size.
     * Example: /// Example: [11.301, 11.301, 11.301]
     * Constraints: No constraints specified.
     */
    fun crossRangeRes(j: Int) : String? {
        val o = __offset(44)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val crossRangeResLength : Int
        get() {
            val o = __offset(44); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Beta angle (between target and radar-image frame z axis) in degrees.
     * Example: /// Example: -89.97
     * Constraints: No constraints specified.
     */
    val beta : Double
        get() {
            val o = __offset(46)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Kappa angle (between radar-line-of-sight and target-frame x axis) in degrees.
     * Example: /// Example: 103.04
     * Constraints: No constraints specified.
     */
    val kappa : Double
        get() {
            val o = __offset(48)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Array of the peak pixel amplitude for each image in decibels. The 'tov' and 'peakAmplitude' arrays must match in size.
     * Example: /// Example: [33.1, 33.1, 33.1]
     * Constraints: No constraints specified.
     */
    fun peakAmplitudes(j: Int) : String? {
        val o = __offset(50)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val peakAmplitudesLength : Int
        get() {
            val o = __offset(50); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Radar center frequency of the radar in hertz.
     * Example: /// Example: 160047.0625
     * Constraints: No constraints specified.
     */
    val centerFrequency : Double
        get() {
            val o = __offset(52)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Bandwidth of radar pulse in hertz.
     * Example: /// Example: 24094.12
     * Constraints: No constraints specified.
     */
    val pulseBandwidth : Double
        get() {
            val o = __offset(54)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Array of the cartesian X positions of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'xpos' arrays must match in size.
     * Example: /// Example: [-1118.577381, -1118.577381, -1118.577381]
     * Constraints: No constraints specified.
     */
    fun xpos(j: Int) : String? {
        val o = __offset(56)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val xposLength : Int
        get() {
            val o = __offset(56); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the cartesian Y positions of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'ypos' arrays must match in size.
     * Example: /// Example: [3026.231084, 3026.231084, 3026.231084]
     * Constraints: No constraints specified.
     */
    fun ypos(j: Int) : String? {
        val o = __offset(58)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val yposLength : Int
        get() {
            val o = __offset(58); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the cartesian Z positions of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'zpos' arrays must match in size.
     * Example: /// Example: [6167.831808, 6167.831808, 6167.831808]
     * Constraints: No constraints specified.
     */
    fun zpos(j: Int) : String? {
        val o = __offset(60)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val zposLength : Int
        get() {
            val o = __offset(60); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the cartesian X velocities of target, in kilometers per second, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'xvel' arrays must match in size.
     * Example: /// Example: [-4.25242784, -4.25242784, -4.25242784]
     * Constraints: No constraints specified.
     */
    fun xvel(j: Int) : String? {
        val o = __offset(62)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val xvelLength : Int
        get() {
            val o = __offset(62); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the cartesian Y velocities of target, in kilometers per second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed. The 'tov' and 'yvel' arrays must match in size.
     * Example: /// Example: [5.291107434, 5.291107434, 5.291107434]
     * Constraints: No constraints specified.
     */
    fun yvel(j: Int) : String? {
        val o = __offset(64)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val yvelLength : Int
        get() {
            val o = __offset(64); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Array of the cartesian Z velocities of target, in kilometers per second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed. The 'tov' and 'zvel' arrays must match in size.
     * Example: /// Example: [-3.356493869, -3.356493869, -3.356493869]
     * Constraints: No constraints specified.
     */
    fun zvel(j: Int) : String? {
        val o = __offset(66)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val zvelLength : Int
        get() {
            val o = __offset(66); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsRadarSOIObservation_Ingest(_bb: ByteBuffer): RadarSOIObservation_Ingest = getRootAsRadarSOIObservation_Ingest(_bb, RadarSOIObservation_Ingest())
        fun getRootAsRadarSOIObservation_Ingest(_bb: ByteBuffer, obj: RadarSOIObservation_Ingest): RadarSOIObservation_Ingest {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun RadarSOIObservation_IngestBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "RADA")
        fun createRadarSOIObservation_Ingest(builder: FlatBufferBuilder, obStartTimeOffset: Int, tovsOffset: Int, rspacesOffset: Int, xspacesOffset: Int, doppler2XrsOffset: Int, deltaTimesOffset: Int, aspectAnglesOffset: Int, projAngVelsOffset: Int, idStateVectorOffset: Int, idAttitudeSetOffset: Int, rangesOffset: Int, azimuthsOffset: Int, elevationsOffset: Int, rangeRatesOffset: Int, azimuthRatesOffset: Int, elevationRatesOffset: Int, azimuthBiasesOffset: Int, elevationBiasesOffset: Int, rangeBiasesOffset: Int, integrationAnglesOffset: Int, crossRangeResOffset: Int, beta: Double, kappa: Double, peakAmplitudesOffset: Int, centerFrequency: Double, pulseBandwidth: Double, xposOffset: Int, yposOffset: Int, zposOffset: Int, xvelOffset: Int, yvelOffset: Int, zvelOffset: Int) : Int {
            builder.startTable(32)
            addPulseBandwidth(builder, pulseBandwidth)
            addCenterFrequency(builder, centerFrequency)
            addKappa(builder, kappa)
            addBeta(builder, beta)
            addZvel(builder, zvelOffset)
            addYvel(builder, yvelOffset)
            addXvel(builder, xvelOffset)
            addZpos(builder, zposOffset)
            addYpos(builder, yposOffset)
            addXpos(builder, xposOffset)
            addPeakAmplitudes(builder, peakAmplitudesOffset)
            addCrossRangeRes(builder, crossRangeResOffset)
            addIntegrationAngles(builder, integrationAnglesOffset)
            addRangeBiases(builder, rangeBiasesOffset)
            addElevationBiases(builder, elevationBiasesOffset)
            addAzimuthBiases(builder, azimuthBiasesOffset)
            addElevationRates(builder, elevationRatesOffset)
            addAzimuthRates(builder, azimuthRatesOffset)
            addRangeRates(builder, rangeRatesOffset)
            addElevations(builder, elevationsOffset)
            addAzimuths(builder, azimuthsOffset)
            addRanges(builder, rangesOffset)
            addIdAttitudeSet(builder, idAttitudeSetOffset)
            addIdStateVector(builder, idStateVectorOffset)
            addProjAngVels(builder, projAngVelsOffset)
            addAspectAngles(builder, aspectAnglesOffset)
            addDeltaTimes(builder, deltaTimesOffset)
            addDoppler2XRs(builder, doppler2XrsOffset)
            addXspaces(builder, xspacesOffset)
            addRspaces(builder, rspacesOffset)
            addTovs(builder, tovsOffset)
            addObStartTime(builder, obStartTimeOffset)
            return endRadarSOIObservation_Ingest(builder)
        }
        fun startRadarSOIObservation_Ingest(builder: FlatBufferBuilder) = builder.startTable(32)
        fun addObStartTime(builder: FlatBufferBuilder, obStartTime: Int) = builder.addOffset(0, obStartTime, 0)
        fun addTovs(builder: FlatBufferBuilder, tovs: Int) = builder.addOffset(1, tovs, 0)
        fun createTovsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTovsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addRspaces(builder: FlatBufferBuilder, rspaces: Int) = builder.addOffset(2, rspaces, 0)
        fun createRspacesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startRspacesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addXspaces(builder: FlatBufferBuilder, xspaces: Int) = builder.addOffset(3, xspaces, 0)
        fun createXspacesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startXspacesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addDoppler2XRs(builder: FlatBufferBuilder, doppler2Xrs: Int) = builder.addOffset(4, doppler2Xrs, 0)
        fun createDoppler2XrsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startDoppler2XrsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addDeltaTimes(builder: FlatBufferBuilder, deltaTimes: Int) = builder.addOffset(5, deltaTimes, 0)
        fun createDeltaTimesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startDeltaTimesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addAspectAngles(builder: FlatBufferBuilder, aspectAngles: Int) = builder.addOffset(6, aspectAngles, 0)
        fun createAspectAnglesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAspectAnglesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addProjAngVels(builder: FlatBufferBuilder, projAngVels: Int) = builder.addOffset(7, projAngVels, 0)
        fun createProjAngVelsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startProjAngVelsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addIdStateVector(builder: FlatBufferBuilder, idStateVector: Int) = builder.addOffset(8, idStateVector, 0)
        fun addIdAttitudeSet(builder: FlatBufferBuilder, idAttitudeSet: Int) = builder.addOffset(9, idAttitudeSet, 0)
        fun addRanges(builder: FlatBufferBuilder, ranges: Int) = builder.addOffset(10, ranges, 0)
        fun createRangesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startRangesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addAzimuths(builder: FlatBufferBuilder, azimuths: Int) = builder.addOffset(11, azimuths, 0)
        fun createAzimuthsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAzimuthsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addElevations(builder: FlatBufferBuilder, elevations: Int) = builder.addOffset(12, elevations, 0)
        fun createElevationsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startElevationsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addRangeRates(builder: FlatBufferBuilder, rangeRates: Int) = builder.addOffset(13, rangeRates, 0)
        fun createRangeRatesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startRangeRatesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addAzimuthRates(builder: FlatBufferBuilder, azimuthRates: Int) = builder.addOffset(14, azimuthRates, 0)
        fun createAzimuthRatesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAzimuthRatesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addElevationRates(builder: FlatBufferBuilder, elevationRates: Int) = builder.addOffset(15, elevationRates, 0)
        fun createElevationRatesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startElevationRatesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addAzimuthBiases(builder: FlatBufferBuilder, azimuthBiases: Int) = builder.addOffset(16, azimuthBiases, 0)
        fun createAzimuthBiasesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAzimuthBiasesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addElevationBiases(builder: FlatBufferBuilder, elevationBiases: Int) = builder.addOffset(17, elevationBiases, 0)
        fun createElevationBiasesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startElevationBiasesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addRangeBiases(builder: FlatBufferBuilder, rangeBiases: Int) = builder.addOffset(18, rangeBiases, 0)
        fun createRangeBiasesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startRangeBiasesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addIntegrationAngles(builder: FlatBufferBuilder, integrationAngles: Int) = builder.addOffset(19, integrationAngles, 0)
        fun createIntegrationAnglesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startIntegrationAnglesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addCrossRangeRes(builder: FlatBufferBuilder, crossRangeRes: Int) = builder.addOffset(20, crossRangeRes, 0)
        fun createCrossRangeResVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startCrossRangeResVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addBeta(builder: FlatBufferBuilder, beta: Double) = builder.addDouble(21, beta, 0.0)
        fun addKappa(builder: FlatBufferBuilder, kappa: Double) = builder.addDouble(22, kappa, 0.0)
        fun addPeakAmplitudes(builder: FlatBufferBuilder, peakAmplitudes: Int) = builder.addOffset(23, peakAmplitudes, 0)
        fun createPeakAmplitudesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startPeakAmplitudesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addCenterFrequency(builder: FlatBufferBuilder, centerFrequency: Double) = builder.addDouble(24, centerFrequency, 0.0)
        fun addPulseBandwidth(builder: FlatBufferBuilder, pulseBandwidth: Double) = builder.addDouble(25, pulseBandwidth, 0.0)
        fun addXpos(builder: FlatBufferBuilder, xpos: Int) = builder.addOffset(26, xpos, 0)
        fun createXposVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startXposVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addYpos(builder: FlatBufferBuilder, ypos: Int) = builder.addOffset(27, ypos, 0)
        fun createYposVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startYposVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addZpos(builder: FlatBufferBuilder, zpos: Int) = builder.addOffset(28, zpos, 0)
        fun createZposVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startZposVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addXvel(builder: FlatBufferBuilder, xvel: Int) = builder.addOffset(29, xvel, 0)
        fun createXvelVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startXvelVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addYvel(builder: FlatBufferBuilder, yvel: Int) = builder.addOffset(30, yvel, 0)
        fun createYvelVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startYvelVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addZvel(builder: FlatBufferBuilder, zvel: Int) = builder.addOffset(31, zvel, 0)
        fun createZvelVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startZvelVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endRadarSOIObservation_Ingest(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishRadarSOIObservationIngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "RADA")
        fun finishSizePrefixedRadarSOIObservation_IngestBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "RADA")
    }
}
