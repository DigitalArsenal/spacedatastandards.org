// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Surface_Abridged_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case real = 0
  ///  No description available.
  case test = 1
  ///  No description available.
  case simulated = 2
  ///  No description available.
  case exercise = 3

  public static var max: Surface_Abridged_dataMode_Enum { return .exercise }
  public static var min: Surface_Abridged_dataMode_Enum { return .real }
}


///  /// Surface information contains properties related to an airfield's runway, taxiway, and parking. The surface types and characteristics can dictate the airfield's capability of hosting a specific aircraft.
public struct Surface_Abridged: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "SURF" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Surface_Abridged.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case name = 8
    case type = 10
    case idSite = 12
    case altSiteId = 14
    case primary = 16
    case lengthFt = 18
    case ldaFt = 20
    case widthFt = 22
    case lengthM = 24
    case ldaM = 26
    case widthM = 28
    case material = 30
    case condition = 32
    case rawWbc = 34
    case pcn = 36
    case lcn = 38
    case sWtKip = 40
    case tWtKip = 42
    case stWtKip = 44
    case ttWtKip = 46
    case ddWtKip = 48
    case sbttWtKip = 50
    case tdtWtkip = 52
    case trtWtKip = 54
    case ddtWtKip = 56
    case sWtKn = 58
    case tWtKn = 60
    case stWtKn = 62
    case ttWtKn = 64
    case ddWtKn = 66
    case sbttWtKn = 68
    case tdtWtKn = 70
    case trtWtKn = 72
    case ddtWtKn = 74
    case lighting = 76
    case lightsUnkn = 78
    case lightsAprch = 80
    case lightsVasi = 82
    case lightsPapi = 84
    case lightsOls = 86
    case lightsReil = 88
    case lightsTdzl = 90
    case lightsCl = 92
    case obstacle = 94
    case createdAt = 96
    case createdBy = 98
    case source = 100
    case origin = 102
    case origNetwork = 104
    case dataMode = 106
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: be831d39-1822-da9f-7ace-6cc5643397dc
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  The surface name or identifier.
  ///  Example: /// Example: West lot
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  ///  The surface type of this record (e.g. RUNWAY, TAXIWAY, PARKING).
  ///  Example: /// Example: PARKING
  ///  Constraints: Minimum length = 1, Maximum length = 7
  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  ///  The ID of the site where this surface is located.
  ///  Example: /// Example: SITE-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idSite: String? { let o = _accessor.offset(VTOFFSET.idSite.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSiteSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSite.v) }
  ///  Alternate site identifier provided by the source.
  ///  Example: /// Example: ORIG-SITE-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var altSiteId: String? { let o = _accessor.offset(VTOFFSET.altSiteId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var altSiteIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.altSiteId.v) }
  ///  Flag indicating this is the primary runway.  Applicable for runway surface types only.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var primary: Bool { let o = _accessor.offset(VTOFFSET.primary.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  The length of the surface type, in feet.  Applicable for runway and parking surface types.
  ///  Example: /// Example: 1500
  ///  Constraints: No constraints specified.
  public var lengthFt: Int32 { let o = _accessor.offset(VTOFFSET.lengthFt.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The landing distance available for the runway, in feet.  Applicable for runway surface types only.
  ///  Example: /// Example: 475
  ///  Constraints: No constraints specified.
  public var ldaFt: Int32 { let o = _accessor.offset(VTOFFSET.ldaFt.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The width of the surface type, in feet.
  ///  Example: /// Example: 220
  ///  Constraints: No constraints specified.
  public var widthFt: Int32 { let o = _accessor.offset(VTOFFSET.widthFt.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The length of the surface type, in meters.  Applicable for runway and parking surface types.
  ///  Example: /// Example: 457
  ///  Constraints: No constraints specified.
  public var lengthM: Int32 { let o = _accessor.offset(VTOFFSET.lengthM.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The landing distance available for the runway, in meters.  Applicable for runway surface types only.
  ///  Example: /// Example: 145
  ///  Constraints: No constraints specified.
  public var ldaM: Int32 { let o = _accessor.offset(VTOFFSET.ldaM.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The width of the surface type, in meters.
  ///  Example: /// Example: 67
  ///  Constraints: No constraints specified.
  public var widthM: Int32 { let o = _accessor.offset(VTOFFSET.widthM.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The surface material (e.g. Asphalt, Concrete, Dirt).
  ///  Example: /// Example: Concrete
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var material: String? { let o = _accessor.offset(VTOFFSET.material.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var materialSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.material.v) }
  ///  The surface condition (e.g. GOOD, FAIR, POOR, SERIOUS, FAILED, CLOSED, UNKNOWN).
  ///  Example: /// Example: GOOD
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var condition: String? { let o = _accessor.offset(VTOFFSET.condition.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var conditionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.condition.v) }
  ///  Raw weight bearing capacity value or pavement strength.
  ///  Example: /// Example: LCN 42
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var rawWbc: String? { let o = _accessor.offset(VTOFFSET.rawWbc.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var rawWbcSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.rawWbc.v) }
  ///  Pavement classification number (PCN) and tire pressure code.
  ///  Example: /// Example: 73RBWT
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var pcn: String? { let o = _accessor.offset(VTOFFSET.pcn.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var pcnSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.pcn.v) }
  ///  Load classification number or pavement rating which ranks aircraft on a scale of 1 to 120.
  ///  Example: /// Example: 50
  ///  Constraints: No constraints specified.
  public var lcn: Int32 { let o = _accessor.offset(VTOFFSET.lcn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for an S-type (single) landing gear configuration, in kilopounds (kip). Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 143
  ///  Constraints: No constraints specified.
  public var sWtKip: Int32 { let o = _accessor.offset(VTOFFSET.sWtKip.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for a T-type (twin (dual)) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 188
  ///  Constraints: No constraints specified.
  public var tWtKip: Int32 { let o = _accessor.offset(VTOFFSET.tWtKip.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for an ST-type (single tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 195
  ///  Constraints: No constraints specified.
  public var stWtKip: Int32 { let o = _accessor.offset(VTOFFSET.stWtKip.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for a GDSS TT-type (twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 414
  ///  Constraints: No constraints specified.
  public var ttWtKip: Int32 { let o = _accessor.offset(VTOFFSET.ttWtKip.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for an FAA 2D-type (twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 416
  ///  Constraints: No constraints specified.
  public var ddWtKip: Int32 { let o = _accessor.offset(VTOFFSET.ddWtKip.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for an SBTT-type (single belly twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 603
  ///  Constraints: No constraints specified.
  public var sbttWtKip: Int32 { let o = _accessor.offset(VTOFFSET.sbttWtKip.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for a TDT-type (twin delta tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 870
  ///  Constraints: No constraints specified.
  public var tdtWtkip: Int32 { let o = _accessor.offset(VTOFFSET.tdtWtkip.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for a TRT-type (triple tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 622
  ///  Constraints: No constraints specified.
  public var trtWtKip: Int32 { let o = _accessor.offset(VTOFFSET.trtWtKip.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for a DDT-type (double dual tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 833
  ///  Constraints: No constraints specified.
  public var ddtWtKip: Int32 { let o = _accessor.offset(VTOFFSET.ddtWtKip.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for an S-type (single) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 636
  ///  Constraints: No constraints specified.
  public var sWtKn: Int32 { let o = _accessor.offset(VTOFFSET.sWtKn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for a T-type (twin (dual)) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 836
  ///  Constraints: No constraints specified.
  public var tWtKn: Int32 { let o = _accessor.offset(VTOFFSET.tWtKn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for an ST-type (single tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 867
  ///  Constraints: No constraints specified.
  public var stWtKn: Int32 { let o = _accessor.offset(VTOFFSET.stWtKn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for a GDSS TT-type (twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 1842
  ///  Constraints: No constraints specified.
  public var ttWtKn: Int32 { let o = _accessor.offset(VTOFFSET.ttWtKn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for an FAA 2D-type (twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 1850
  ///  Constraints: No constraints specified.
  public var ddWtKn: Int32 { let o = _accessor.offset(VTOFFSET.ddWtKn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for an SBTT-type (single belly twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 2682
  ///  Constraints: No constraints specified.
  public var sbttWtKn: Int32 { let o = _accessor.offset(VTOFFSET.sbttWtKn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for a TDT-type (twin delta tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 3870
  ///  Constraints: No constraints specified.
  public var tdtWtKn: Int32 { let o = _accessor.offset(VTOFFSET.tdtWtKn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for a TRT-type (triple tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 2767
  ///  Constraints: No constraints specified.
  public var trtWtKn: Int32 { let o = _accessor.offset(VTOFFSET.trtWtKn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The max weight allowable on this surface type for a DDT-type (double dual tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 3705
  ///  Constraints: No constraints specified.
  public var ddtWtKn: Int32 { let o = _accessor.offset(VTOFFSET.ddtWtKn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Flag indicating the surface has lighting.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var lighting: Bool { let o = _accessor.offset(VTOFFSET.lighting.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating the runway lighting is unknown. Applicable for runway surface types only.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var lightsUnkn: Bool { let o = _accessor.offset(VTOFFSET.lightsUnkn.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating the runway has approach lights. Applicable for runway surface types only.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var lightsAprch: Bool { let o = _accessor.offset(VTOFFSET.lightsAprch.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating the runway has Visual Approach Slope Indicator (VASI) lights. Applicable for runway surface types only.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var lightsVasi: Bool { let o = _accessor.offset(VTOFFSET.lightsVasi.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating the runway has Precision Approach Path Indicator (PAPI) lights. Applicable for runway surface types only.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var lightsPapi: Bool { let o = _accessor.offset(VTOFFSET.lightsPapi.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating the runway has Optical Landing System (OLS) lights. Applicable for runway surface types only.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var lightsOls: Bool { let o = _accessor.offset(VTOFFSET.lightsOls.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating the runway has Runway End Identifier Lights (REIL). Applicable for runway surface types only.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var lightsReil: Bool { let o = _accessor.offset(VTOFFSET.lightsReil.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating the runway has Touchdown Zone lights. Applicable for runway surface types only.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var lightsTdzl: Bool { let o = _accessor.offset(VTOFFSET.lightsTdzl.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating the runway has centerline lights. Applicable for runway surface types only.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var lightsCl: Bool { let o = _accessor.offset(VTOFFSET.lightsCl.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating the surface type has an obstacle. Applicable for taxiway and parking surface types.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var obstacle: Bool { let o = _accessor.offset(VTOFFSET.obstacle.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2022-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: OPS1
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: Surface_Abridged_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : Surface_Abridged_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  public static func startSurface_Abridged(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 52) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func add(idSite: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSite, at: VTOFFSET.idSite.p) }
  public static func add(altSiteId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: altSiteId, at: VTOFFSET.altSiteId.p) }
  public static func add(primary: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: primary, def: false,
   at: VTOFFSET.primary.p) }
  public static func add(lengthFt: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lengthFt, def: 0, at: VTOFFSET.lengthFt.p) }
  public static func add(ldaFt: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ldaFt, def: 0, at: VTOFFSET.ldaFt.p) }
  public static func add(widthFt: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: widthFt, def: 0, at: VTOFFSET.widthFt.p) }
  public static func add(lengthM: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lengthM, def: 0, at: VTOFFSET.lengthM.p) }
  public static func add(ldaM: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ldaM, def: 0, at: VTOFFSET.ldaM.p) }
  public static func add(widthM: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: widthM, def: 0, at: VTOFFSET.widthM.p) }
  public static func add(material: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: material, at: VTOFFSET.material.p) }
  public static func add(condition: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: condition, at: VTOFFSET.condition.p) }
  public static func add(rawWbc: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rawWbc, at: VTOFFSET.rawWbc.p) }
  public static func add(pcn: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: pcn, at: VTOFFSET.pcn.p) }
  public static func add(lcn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lcn, def: 0, at: VTOFFSET.lcn.p) }
  public static func add(sWtKip: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sWtKip, def: 0, at: VTOFFSET.sWtKip.p) }
  public static func add(tWtKip: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tWtKip, def: 0, at: VTOFFSET.tWtKip.p) }
  public static func add(stWtKip: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stWtKip, def: 0, at: VTOFFSET.stWtKip.p) }
  public static func add(ttWtKip: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ttWtKip, def: 0, at: VTOFFSET.ttWtKip.p) }
  public static func add(ddWtKip: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ddWtKip, def: 0, at: VTOFFSET.ddWtKip.p) }
  public static func add(sbttWtKip: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sbttWtKip, def: 0, at: VTOFFSET.sbttWtKip.p) }
  public static func add(tdtWtkip: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tdtWtkip, def: 0, at: VTOFFSET.tdtWtkip.p) }
  public static func add(trtWtKip: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trtWtKip, def: 0, at: VTOFFSET.trtWtKip.p) }
  public static func add(ddtWtKip: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ddtWtKip, def: 0, at: VTOFFSET.ddtWtKip.p) }
  public static func add(sWtKn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sWtKn, def: 0, at: VTOFFSET.sWtKn.p) }
  public static func add(tWtKn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tWtKn, def: 0, at: VTOFFSET.tWtKn.p) }
  public static func add(stWtKn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stWtKn, def: 0, at: VTOFFSET.stWtKn.p) }
  public static func add(ttWtKn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ttWtKn, def: 0, at: VTOFFSET.ttWtKn.p) }
  public static func add(ddWtKn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ddWtKn, def: 0, at: VTOFFSET.ddWtKn.p) }
  public static func add(sbttWtKn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sbttWtKn, def: 0, at: VTOFFSET.sbttWtKn.p) }
  public static func add(tdtWtKn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tdtWtKn, def: 0, at: VTOFFSET.tdtWtKn.p) }
  public static func add(trtWtKn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trtWtKn, def: 0, at: VTOFFSET.trtWtKn.p) }
  public static func add(ddtWtKn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ddtWtKn, def: 0, at: VTOFFSET.ddtWtKn.p) }
  public static func add(lighting: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lighting, def: false,
   at: VTOFFSET.lighting.p) }
  public static func add(lightsUnkn: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lightsUnkn, def: false,
   at: VTOFFSET.lightsUnkn.p) }
  public static func add(lightsAprch: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lightsAprch, def: false,
   at: VTOFFSET.lightsAprch.p) }
  public static func add(lightsVasi: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lightsVasi, def: false,
   at: VTOFFSET.lightsVasi.p) }
  public static func add(lightsPapi: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lightsPapi, def: false,
   at: VTOFFSET.lightsPapi.p) }
  public static func add(lightsOls: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lightsOls, def: false,
   at: VTOFFSET.lightsOls.p) }
  public static func add(lightsReil: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lightsReil, def: false,
   at: VTOFFSET.lightsReil.p) }
  public static func add(lightsTdzl: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lightsTdzl, def: false,
   at: VTOFFSET.lightsTdzl.p) }
  public static func add(lightsCl: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lightsCl, def: false,
   at: VTOFFSET.lightsCl.p) }
  public static func add(obstacle: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: obstacle, def: false,
   at: VTOFFSET.obstacle.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: Surface_Abridged_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func endSurface_Abridged(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSurface_Abridged(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    typeOffset type: Offset = Offset(),
    idSiteOffset idSite: Offset = Offset(),
    altSiteIdOffset altSiteId: Offset = Offset(),
    primary: Bool = false,
    lengthFt: Int32 = 0,
    ldaFt: Int32 = 0,
    widthFt: Int32 = 0,
    lengthM: Int32 = 0,
    ldaM: Int32 = 0,
    widthM: Int32 = 0,
    materialOffset material: Offset = Offset(),
    conditionOffset condition: Offset = Offset(),
    rawWbcOffset rawWbc: Offset = Offset(),
    pcnOffset pcn: Offset = Offset(),
    lcn: Int32 = 0,
    sWtKip: Int32 = 0,
    tWtKip: Int32 = 0,
    stWtKip: Int32 = 0,
    ttWtKip: Int32 = 0,
    ddWtKip: Int32 = 0,
    sbttWtKip: Int32 = 0,
    tdtWtkip: Int32 = 0,
    trtWtKip: Int32 = 0,
    ddtWtKip: Int32 = 0,
    sWtKn: Int32 = 0,
    tWtKn: Int32 = 0,
    stWtKn: Int32 = 0,
    ttWtKn: Int32 = 0,
    ddWtKn: Int32 = 0,
    sbttWtKn: Int32 = 0,
    tdtWtKn: Int32 = 0,
    trtWtKn: Int32 = 0,
    ddtWtKn: Int32 = 0,
    lighting: Bool = false,
    lightsUnkn: Bool = false,
    lightsAprch: Bool = false,
    lightsVasi: Bool = false,
    lightsPapi: Bool = false,
    lightsOls: Bool = false,
    lightsReil: Bool = false,
    lightsTdzl: Bool = false,
    lightsCl: Bool = false,
    obstacle: Bool = false,
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: Surface_Abridged_dataMode_Enum = .real
  ) -> Offset {
    let __start = Surface_Abridged.startSurface_Abridged(&fbb)
    Surface_Abridged.add(id: id, &fbb)
    Surface_Abridged.add(classificationMarking: classificationMarking, &fbb)
    Surface_Abridged.add(name: name, &fbb)
    Surface_Abridged.add(type: type, &fbb)
    Surface_Abridged.add(idSite: idSite, &fbb)
    Surface_Abridged.add(altSiteId: altSiteId, &fbb)
    Surface_Abridged.add(primary: primary, &fbb)
    Surface_Abridged.add(lengthFt: lengthFt, &fbb)
    Surface_Abridged.add(ldaFt: ldaFt, &fbb)
    Surface_Abridged.add(widthFt: widthFt, &fbb)
    Surface_Abridged.add(lengthM: lengthM, &fbb)
    Surface_Abridged.add(ldaM: ldaM, &fbb)
    Surface_Abridged.add(widthM: widthM, &fbb)
    Surface_Abridged.add(material: material, &fbb)
    Surface_Abridged.add(condition: condition, &fbb)
    Surface_Abridged.add(rawWbc: rawWbc, &fbb)
    Surface_Abridged.add(pcn: pcn, &fbb)
    Surface_Abridged.add(lcn: lcn, &fbb)
    Surface_Abridged.add(sWtKip: sWtKip, &fbb)
    Surface_Abridged.add(tWtKip: tWtKip, &fbb)
    Surface_Abridged.add(stWtKip: stWtKip, &fbb)
    Surface_Abridged.add(ttWtKip: ttWtKip, &fbb)
    Surface_Abridged.add(ddWtKip: ddWtKip, &fbb)
    Surface_Abridged.add(sbttWtKip: sbttWtKip, &fbb)
    Surface_Abridged.add(tdtWtkip: tdtWtkip, &fbb)
    Surface_Abridged.add(trtWtKip: trtWtKip, &fbb)
    Surface_Abridged.add(ddtWtKip: ddtWtKip, &fbb)
    Surface_Abridged.add(sWtKn: sWtKn, &fbb)
    Surface_Abridged.add(tWtKn: tWtKn, &fbb)
    Surface_Abridged.add(stWtKn: stWtKn, &fbb)
    Surface_Abridged.add(ttWtKn: ttWtKn, &fbb)
    Surface_Abridged.add(ddWtKn: ddWtKn, &fbb)
    Surface_Abridged.add(sbttWtKn: sbttWtKn, &fbb)
    Surface_Abridged.add(tdtWtKn: tdtWtKn, &fbb)
    Surface_Abridged.add(trtWtKn: trtWtKn, &fbb)
    Surface_Abridged.add(ddtWtKn: ddtWtKn, &fbb)
    Surface_Abridged.add(lighting: lighting, &fbb)
    Surface_Abridged.add(lightsUnkn: lightsUnkn, &fbb)
    Surface_Abridged.add(lightsAprch: lightsAprch, &fbb)
    Surface_Abridged.add(lightsVasi: lightsVasi, &fbb)
    Surface_Abridged.add(lightsPapi: lightsPapi, &fbb)
    Surface_Abridged.add(lightsOls: lightsOls, &fbb)
    Surface_Abridged.add(lightsReil: lightsReil, &fbb)
    Surface_Abridged.add(lightsTdzl: lightsTdzl, &fbb)
    Surface_Abridged.add(lightsCl: lightsCl, &fbb)
    Surface_Abridged.add(obstacle: obstacle, &fbb)
    Surface_Abridged.add(createdAt: createdAt, &fbb)
    Surface_Abridged.add(createdBy: createdBy, &fbb)
    Surface_Abridged.add(source: source, &fbb)
    Surface_Abridged.add(origin: origin, &fbb)
    Surface_Abridged.add(origNetwork: origNetwork, &fbb)
    Surface_Abridged.add(dataMode: dataMode, &fbb)
    return Surface_Abridged.endSurface_Abridged(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idSite.p, fieldName: "idSite", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.altSiteId.p, fieldName: "altSiteId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.primary.p, fieldName: "primary", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.lengthFt.p, fieldName: "lengthFt", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.ldaFt.p, fieldName: "ldaFt", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.widthFt.p, fieldName: "widthFt", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.lengthM.p, fieldName: "lengthM", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.ldaM.p, fieldName: "ldaM", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.widthM.p, fieldName: "widthM", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.material.p, fieldName: "material", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.condition.p, fieldName: "condition", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rawWbc.p, fieldName: "rawWbc", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.pcn.p, fieldName: "pcn", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.lcn.p, fieldName: "lcn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.sWtKip.p, fieldName: "sWtKip", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.tWtKip.p, fieldName: "tWtKip", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.stWtKip.p, fieldName: "stWtKip", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.ttWtKip.p, fieldName: "ttWtKip", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.ddWtKip.p, fieldName: "ddWtKip", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.sbttWtKip.p, fieldName: "sbttWtKip", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.tdtWtkip.p, fieldName: "tdtWtkip", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.trtWtKip.p, fieldName: "trtWtKip", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.ddtWtKip.p, fieldName: "ddtWtKip", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.sWtKn.p, fieldName: "sWtKn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.tWtKn.p, fieldName: "tWtKn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.stWtKn.p, fieldName: "stWtKn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.ttWtKn.p, fieldName: "ttWtKn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.ddWtKn.p, fieldName: "ddWtKn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.sbttWtKn.p, fieldName: "sbttWtKn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.tdtWtKn.p, fieldName: "tdtWtKn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.trtWtKn.p, fieldName: "trtWtKn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.ddtWtKn.p, fieldName: "ddtWtKn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.lighting.p, fieldName: "lighting", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.lightsUnkn.p, fieldName: "lightsUnkn", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.lightsAprch.p, fieldName: "lightsAprch", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.lightsVasi.p, fieldName: "lightsVasi", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.lightsPapi.p, fieldName: "lightsPapi", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.lightsOls.p, fieldName: "lightsOls", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.lightsReil.p, fieldName: "lightsReil", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.lightsTdzl.p, fieldName: "lightsTdzl", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.lightsCl.p, fieldName: "lightsCl", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.obstacle.p, fieldName: "obstacle", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: Surface_Abridged_dataMode_Enum.self)
    _v.finish()
  }
}

