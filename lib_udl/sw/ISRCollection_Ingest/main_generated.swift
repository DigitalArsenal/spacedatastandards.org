// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum ISRCollection_Ingest_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: ISRCollection_Ingest_dataMode_Enum { return .exercise }
  public static var min: ISRCollection_Ingest_dataMode_Enum { return .real }
}


///  /// ISR Collection data.
public struct ISRCollection_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "ISRC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ISRCollection_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case idexVersion = 8
    case name = 10
    case missionId = 12
    case missionAor = 14
    case missionPrimaryIntelDiscipline = 16
    case missionPrimarySubCategory = 18
    case missionSecondaryIntelDiscipline = 20
    case missionSecondarySubCategory = 22
    case missionRole = 24
    case missionOperation = 26
    case missionPriority = 28
    case missionSupportedUnit = 30
    case missionEmphasis = 32
    case missionStartPointLat = 34
    case missionStartPointLong = 36
    case missionCollectionArea = 38
    case missionJoa = 40
    case missionSyncMatrixBin = 42
    case missionCountry = 44
    case missionRegion = 46
    case missionSubRegion = 48
    case collectionRequirements = 50
    case transit = 52
    case taskings = 54
    case createdAt = 56
    case createdBy = 58
    case updatedAt = 60
    case updatedBy = 62
    case source = 64
    case origin = 66
    case dataMode = 68
    case origNetwork = 70
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: ISRCOLLECTION-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Version of the IDEX software the request came from for compatibility.
  ///  Example: /// Example: 2
  ///  Constraints: No constraints specified.
  public var idexVersion: Int32 { let o = _accessor.offset(VTOFFSET.idexVersion.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Human readable Mission Name.
  ///  Example: /// Example: Example mission name
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  ///  Mission Identifier.
  ///  Example: /// Example: myTask-2020-04-23T00:00:00.000Z
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionId: String? { let o = _accessor.offset(VTOFFSET.missionId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionId.v) }
  ///  Designation of mission Area Of Responsibility.
  ///  Example: /// Example: Kandahar
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionAor: String? { let o = _accessor.offset(VTOFFSET.missionAor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionAorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionAor.v) }
  ///  Primary type of intelligence to be collected during the mission.
  ///  Example: /// Example: Sig
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionPrimaryIntelDiscipline: String? { let o = _accessor.offset(VTOFFSET.missionPrimaryIntelDiscipline.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionPrimaryIntelDisciplineSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionPrimaryIntelDiscipline.v) }
  ///  Sub category of primary intelligence to be collected.
  ///  Example: /// Example: FMV
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionPrimarySubCategory: String? { let o = _accessor.offset(VTOFFSET.missionPrimarySubCategory.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionPrimarySubCategorySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionPrimarySubCategory.v) }
  ///  Type of intelligence to be collected second.
  ///  Example: /// Example: Intelligence_2
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionSecondaryIntelDiscipline: String? { let o = _accessor.offset(VTOFFSET.missionSecondaryIntelDiscipline.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionSecondaryIntelDisciplineSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionSecondaryIntelDiscipline.v) }
  ///  Mission sub category for secondary intelligence discipline to be collected.
  ///  Example: /// Example: Convoy
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionSecondarySubCategory: String? { let o = _accessor.offset(VTOFFSET.missionSecondarySubCategory.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionSecondarySubCategorySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionSecondarySubCategory.v) }
  ///  What is the primary objective(Role) of this mission.
  ///  Example: /// Example: Targeting of Lead Vehicle
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionRole: String? { let o = _accessor.offset(VTOFFSET.missionRole.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionRoleSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionRole.v) }
  ///  Mission operation name.
  ///  Example: /// Example: OP-HONEY-BADGER
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionOperation: String? { let o = _accessor.offset(VTOFFSET.missionOperation.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionOperationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionOperation.v) }
  ///  Mission Priority (1-n).
  ///  Example: /// Example: 1
  ///  Constraints: No constraints specified.
  public var missionPriority: Int32 { let o = _accessor.offset(VTOFFSET.missionPriority.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Name of the Supporting unit/Location that is performing this mission.
  ///  Example: /// Example: ENVOYS
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionSupportedUnit: String? { let o = _accessor.offset(VTOFFSET.missionSupportedUnit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionSupportedUnitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionSupportedUnit.v) }
  ///  Text version of what we are emphasizing in this mission.
  ///  Example: /// Example: Mission emphasis
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionEmphasis: String? { let o = _accessor.offset(VTOFFSET.missionEmphasis.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionEmphasisSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionEmphasis.v) }
  ///  WGS-84 latitude of the start position, in degrees. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 45.23
  ///  Constraints: No constraints specified.
  public var missionStartPointLat: Double { let o = _accessor.offset(VTOFFSET.missionStartPointLat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 longitude of the start position, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 80.23
  ///  Constraints: No constraints specified.
  public var missionStartPointLong: Double { let o = _accessor.offset(VTOFFSET.missionStartPointLong.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Mission geographical collection area.
  ///  Example: /// Example: Example collection area
  ///  Constraints: Minimum length = 0, Maximum length = 512
  public var missionCollectionArea: String? { let o = _accessor.offset(VTOFFSET.missionCollectionArea.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionCollectionAreaSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionCollectionArea.v) }
  ///  Joint Operations Area.
  ///  Example: /// Example: Operation area
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionJoa: String? { let o = _accessor.offset(VTOFFSET.missionJoa.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionJoaSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionJoa.v) }
  ///  A synchronization matrix is used to organize the logistics synchronization process during a mission.
  ///  Example: /// Example: MATRIX
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionSyncMatrixBin: String? { let o = _accessor.offset(VTOFFSET.missionSyncMatrixBin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionSyncMatrixBinSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionSyncMatrixBin.v) }
  ///  Country code of the mission.  A Country may represent countries, multi-national consortiums, and international organizations.
  ///  Example: /// Example: US
  ///  Constraints: Minimum length = 0, Maximum length = 4
  public var missionCountry: String? { let o = _accessor.offset(VTOFFSET.missionCountry.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionCountrySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionCountry.v) }
  ///  Region of the mission.
  ///  Example: /// Example: Example Region
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionRegion: String? { let o = _accessor.offset(VTOFFSET.missionRegion.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionRegionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionRegion.v) }
  ///  Subregion of the mission.
  ///  Example: /// Example: Example Subregion
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var missionSubRegion: String? { let o = _accessor.offset(VTOFFSET.missionSubRegion.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionSubRegionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionSubRegion.v) }
  ///  Mission desired collection requirements.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasCollectionRequirements: Bool { let o = _accessor.offset(VTOFFSET.collectionRequirements.v); return o == 0 ? false : true }
  public var collectionRequirementsCount: Int32 { let o = _accessor.offset(VTOFFSET.collectionRequirements.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func collectionRequirements(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.collectionRequirements.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Object for data dissemination.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasTransit: Bool { let o = _accessor.offset(VTOFFSET.transit.v); return o == 0 ? false : true }
  public var transitCount: Int32 { let o = _accessor.offset(VTOFFSET.transit.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func transit(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.transit.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Individual taskings to complete the mission.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasTaskings: Bool { let o = _accessor.offset(VTOFFSET.taskings.v); return o == 0 ? false : true }
  public var taskingsCount: Int32 { let o = _accessor.offset(VTOFFSET.taskings.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func taskings(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.taskings.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2021-01-19T01:01:15.001Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Time the row was updated in the database, auto-populated by the system, example = 2018-01-01T16:00:00.123Z.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var updatedAt: String? { let o = _accessor.offset(VTOFFSET.updatedAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedAt.v) }
  ///  Application user who updated the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var updatedBy: String? { let o = _accessor.offset(VTOFFSET.updatedBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: ISRCollection_Ingest_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : ISRCollection_Ingest_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  public static func startISRCollection_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 34) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(idexVersion: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: idexVersion, def: 0, at: VTOFFSET.idexVersion.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(missionId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionId, at: VTOFFSET.missionId.p) }
  public static func add(missionAor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionAor, at: VTOFFSET.missionAor.p) }
  public static func add(missionPrimaryIntelDiscipline: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionPrimaryIntelDiscipline, at: VTOFFSET.missionPrimaryIntelDiscipline.p) }
  public static func add(missionPrimarySubCategory: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionPrimarySubCategory, at: VTOFFSET.missionPrimarySubCategory.p) }
  public static func add(missionSecondaryIntelDiscipline: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionSecondaryIntelDiscipline, at: VTOFFSET.missionSecondaryIntelDiscipline.p) }
  public static func add(missionSecondarySubCategory: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionSecondarySubCategory, at: VTOFFSET.missionSecondarySubCategory.p) }
  public static func add(missionRole: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionRole, at: VTOFFSET.missionRole.p) }
  public static func add(missionOperation: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionOperation, at: VTOFFSET.missionOperation.p) }
  public static func add(missionPriority: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: missionPriority, def: 0, at: VTOFFSET.missionPriority.p) }
  public static func add(missionSupportedUnit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionSupportedUnit, at: VTOFFSET.missionSupportedUnit.p) }
  public static func add(missionEmphasis: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionEmphasis, at: VTOFFSET.missionEmphasis.p) }
  public static func add(missionStartPointLat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: missionStartPointLat, def: 0.0, at: VTOFFSET.missionStartPointLat.p) }
  public static func add(missionStartPointLong: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: missionStartPointLong, def: 0.0, at: VTOFFSET.missionStartPointLong.p) }
  public static func add(missionCollectionArea: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionCollectionArea, at: VTOFFSET.missionCollectionArea.p) }
  public static func add(missionJoa: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionJoa, at: VTOFFSET.missionJoa.p) }
  public static func add(missionSyncMatrixBin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionSyncMatrixBin, at: VTOFFSET.missionSyncMatrixBin.p) }
  public static func add(missionCountry: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionCountry, at: VTOFFSET.missionCountry.p) }
  public static func add(missionRegion: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionRegion, at: VTOFFSET.missionRegion.p) }
  public static func add(missionSubRegion: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionSubRegion, at: VTOFFSET.missionSubRegion.p) }
  public static func addVectorOf(collectionRequirements: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: collectionRequirements, at: VTOFFSET.collectionRequirements.p) }
  public static func addVectorOf(transit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: transit, at: VTOFFSET.transit.p) }
  public static func addVectorOf(taskings: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: taskings, at: VTOFFSET.taskings.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(updatedAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedAt, at: VTOFFSET.updatedAt.p) }
  public static func add(updatedBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedBy, at: VTOFFSET.updatedBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(dataMode: ISRCollection_Ingest_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func endISRCollection_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createISRCollection_Ingest(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    idexVersion: Int32 = 0,
    nameOffset name: Offset = Offset(),
    missionIdOffset missionId: Offset = Offset(),
    missionAorOffset missionAor: Offset = Offset(),
    missionPrimaryIntelDisciplineOffset missionPrimaryIntelDiscipline: Offset = Offset(),
    missionPrimarySubCategoryOffset missionPrimarySubCategory: Offset = Offset(),
    missionSecondaryIntelDisciplineOffset missionSecondaryIntelDiscipline: Offset = Offset(),
    missionSecondarySubCategoryOffset missionSecondarySubCategory: Offset = Offset(),
    missionRoleOffset missionRole: Offset = Offset(),
    missionOperationOffset missionOperation: Offset = Offset(),
    missionPriority: Int32 = 0,
    missionSupportedUnitOffset missionSupportedUnit: Offset = Offset(),
    missionEmphasisOffset missionEmphasis: Offset = Offset(),
    missionStartPointLat: Double = 0.0,
    missionStartPointLong: Double = 0.0,
    missionCollectionAreaOffset missionCollectionArea: Offset = Offset(),
    missionJoaOffset missionJoa: Offset = Offset(),
    missionSyncMatrixBinOffset missionSyncMatrixBin: Offset = Offset(),
    missionCountryOffset missionCountry: Offset = Offset(),
    missionRegionOffset missionRegion: Offset = Offset(),
    missionSubRegionOffset missionSubRegion: Offset = Offset(),
    collectionRequirementsVectorOffset collectionRequirements: Offset = Offset(),
    transitVectorOffset transit: Offset = Offset(),
    taskingsVectorOffset taskings: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    updatedAtOffset updatedAt: Offset = Offset(),
    updatedByOffset updatedBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    dataMode: ISRCollection_Ingest_dataMode_Enum = .real,
    origNetworkOffset origNetwork: Offset = Offset()
  ) -> Offset {
    let __start = ISRCollection_Ingest.startISRCollection_Ingest(&fbb)
    ISRCollection_Ingest.add(id: id, &fbb)
    ISRCollection_Ingest.add(classificationMarking: classificationMarking, &fbb)
    ISRCollection_Ingest.add(idexVersion: idexVersion, &fbb)
    ISRCollection_Ingest.add(name: name, &fbb)
    ISRCollection_Ingest.add(missionId: missionId, &fbb)
    ISRCollection_Ingest.add(missionAor: missionAor, &fbb)
    ISRCollection_Ingest.add(missionPrimaryIntelDiscipline: missionPrimaryIntelDiscipline, &fbb)
    ISRCollection_Ingest.add(missionPrimarySubCategory: missionPrimarySubCategory, &fbb)
    ISRCollection_Ingest.add(missionSecondaryIntelDiscipline: missionSecondaryIntelDiscipline, &fbb)
    ISRCollection_Ingest.add(missionSecondarySubCategory: missionSecondarySubCategory, &fbb)
    ISRCollection_Ingest.add(missionRole: missionRole, &fbb)
    ISRCollection_Ingest.add(missionOperation: missionOperation, &fbb)
    ISRCollection_Ingest.add(missionPriority: missionPriority, &fbb)
    ISRCollection_Ingest.add(missionSupportedUnit: missionSupportedUnit, &fbb)
    ISRCollection_Ingest.add(missionEmphasis: missionEmphasis, &fbb)
    ISRCollection_Ingest.add(missionStartPointLat: missionStartPointLat, &fbb)
    ISRCollection_Ingest.add(missionStartPointLong: missionStartPointLong, &fbb)
    ISRCollection_Ingest.add(missionCollectionArea: missionCollectionArea, &fbb)
    ISRCollection_Ingest.add(missionJoa: missionJoa, &fbb)
    ISRCollection_Ingest.add(missionSyncMatrixBin: missionSyncMatrixBin, &fbb)
    ISRCollection_Ingest.add(missionCountry: missionCountry, &fbb)
    ISRCollection_Ingest.add(missionRegion: missionRegion, &fbb)
    ISRCollection_Ingest.add(missionSubRegion: missionSubRegion, &fbb)
    ISRCollection_Ingest.addVectorOf(collectionRequirements: collectionRequirements, &fbb)
    ISRCollection_Ingest.addVectorOf(transit: transit, &fbb)
    ISRCollection_Ingest.addVectorOf(taskings: taskings, &fbb)
    ISRCollection_Ingest.add(createdAt: createdAt, &fbb)
    ISRCollection_Ingest.add(createdBy: createdBy, &fbb)
    ISRCollection_Ingest.add(updatedAt: updatedAt, &fbb)
    ISRCollection_Ingest.add(updatedBy: updatedBy, &fbb)
    ISRCollection_Ingest.add(source: source, &fbb)
    ISRCollection_Ingest.add(origin: origin, &fbb)
    ISRCollection_Ingest.add(dataMode: dataMode, &fbb)
    ISRCollection_Ingest.add(origNetwork: origNetwork, &fbb)
    return ISRCollection_Ingest.endISRCollection_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idexVersion.p, fieldName: "idexVersion", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionId.p, fieldName: "missionId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionAor.p, fieldName: "missionAor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionPrimaryIntelDiscipline.p, fieldName: "missionPrimaryIntelDiscipline", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionPrimarySubCategory.p, fieldName: "missionPrimarySubCategory", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionSecondaryIntelDiscipline.p, fieldName: "missionSecondaryIntelDiscipline", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionSecondarySubCategory.p, fieldName: "missionSecondarySubCategory", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionRole.p, fieldName: "missionRole", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionOperation.p, fieldName: "missionOperation", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionPriority.p, fieldName: "missionPriority", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.missionSupportedUnit.p, fieldName: "missionSupportedUnit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionEmphasis.p, fieldName: "missionEmphasis", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionStartPointLat.p, fieldName: "missionStartPointLat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.missionStartPointLong.p, fieldName: "missionStartPointLong", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.missionCollectionArea.p, fieldName: "missionCollectionArea", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionJoa.p, fieldName: "missionJoa", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionSyncMatrixBin.p, fieldName: "missionSyncMatrixBin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionCountry.p, fieldName: "missionCountry", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionRegion.p, fieldName: "missionRegion", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionSubRegion.p, fieldName: "missionSubRegion", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.collectionRequirements.p, fieldName: "collectionRequirements", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.transit.p, fieldName: "transit", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.taskings.p, fieldName: "taskings", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedAt.p, fieldName: "updatedAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedBy.p, fieldName: "updatedBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: ISRCollection_Ingest_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

