// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum StateVector_Ingest_referenceFrame_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case j2000 = 0
  ///  No description available.
  case efgTdr = 1
  ///  No description available.
  case ecrEcef = 2
  ///  No description available.
  case teme = 3
  ///  No description available.
  case itrf = 4
  ///  No description available.
  case gcrf = 5

  public static var max: StateVector_Ingest_referenceFrame_Enum { return .gcrf }
  public static var min: StateVector_Ingest_referenceFrame_Enum { return .j2000 }
}


public enum StateVector_Ingest_covReferenceFrame_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case j2000 = 0
  ///  No description available.
  case uvw = 1

  public static var max: StateVector_Ingest_covReferenceFrame_Enum { return .uvw }
  public static var min: StateVector_Ingest_covReferenceFrame_Enum { return .j2000 }
}


public enum StateVector_Ingest_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: StateVector_Ingest_dataMode_Enum { return .exercise }
  public static var min: StateVector_Ingest_dataMode_Enum { return .real }
}


public enum StateVector_Ingest_sourcedDataTypes_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case eo = 0
  ///  No description available.
  case radar = 1
  ///  No description available.
  case rf = 2
  ///  No description available.
  case doa = 3
  ///  No description available.
  case elset = 4
  ///  No description available.
  case sv = 5

  public static var max: StateVector_Ingest_sourcedDataTypes_Enum { return .sv }
  public static var min: StateVector_Ingest_sourcedDataTypes_Enum { return .eo }
}


///  /// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Discover' tab in the storefront to confirm coordinate frames by data provider.
public struct StateVector_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "STAT" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: StateVector_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case idStateVector = 4
    case classificationMarking = 6
    case epoch = 8
    case pedigree = 10
    case idOnOrbit = 12
    case satNo = 14
    case origObjectId = 16
    case idOrbitDetermination = 18
    case uct = 20
    case xpos = 22
    case ypos = 24
    case zpos = 26
    case xvel = 28
    case yvel = 30
    case zvel = 32
    case referenceFrame = 34
    case cov = 36
    case covReferenceFrame = 38
    case covMethod = 40
    case eqCov = 42
    case xposAlt1 = 44
    case yposAlt1 = 46
    case zposAlt1 = 48
    case xvelAlt1 = 50
    case yvelAlt1 = 52
    case zvelAlt1 = 54
    case alt1ReferenceFrame = 56
    case xposAlt2 = 58
    case yposAlt2 = 60
    case zposAlt2 = 62
    case xvelAlt2 = 64
    case yvelAlt2 = 66
    case zvelAlt2 = 68
    case alt2ReferenceFrame = 70
    case posUnc = 72
    case velUnc = 74
    case mass = 76
    case area = 78
    case solarRadPressCoeff = 80
    case dragCoeff = 82
    case dragArea = 84
    case revNo = 86
    case geopotentialModel = 88
    case dragModel = 90
    case lunarSolar = 92
    case solarRadPress = 94
    case srpArea = 96
    case solidEarthTides = 98
    case inTrackThrust = 100
    case bDot = 102
    case edr = 104
    case thrustAccel = 106
    case cmOffset = 108
    case lastObStart = 110
    case lastObEnd = 112
    case obsAvailable = 114
    case obsUsed = 116
    case tracksAvail = 118
    case tracksUsed = 120
    case recOdspan = 122
    case actualOdspan = 124
    case residualsAcc = 126
    case solarFluxF10 = 128
    case solarFluxF10Avg = 130
    case solarFluxApavg = 132
    case taiUtc = 134
    case ut1Utc = 136
    case ut1Rate = 138
    case polarMotionX = 140
    case polarMotionY = 142
    case iau1980Terms = 144
    case leapSecondTime = 146
    case integratorMode = 148
    case partials = 150
    case stepMode = 152
    case fixedStep = 154
    case stepSizeSelection = 156
    case stepSize = 158
    case errorControl = 160
    case sigmaPosUvw = 162
    case sigmaVelUvw = 164
    case rms = 166
    case rawFileUri = 168
    case source = 170
    case origin = 172
    case dataMode = 174
    case tags = 176
    case algorithm = 178
    case sourcedData = 180
    case sourcedDataTypes = 182
    case createdAt = 184
    case createdBy = 186
    case descriptor = 188
    case transactionId = 190
    case origNetwork = 192
    case sourceDl = 194
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: STATEVECTOR-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var idStateVector: String? { let o = _accessor.offset(VTOFFSET.idStateVector.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idStateVectorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idStateVector.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Time of validity for state vector in ISO 8601 UTC datetime format, with microsecond precision.
  ///  Example: /// Example: 2018-01-01T16:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var epoch: String? { let o = _accessor.offset(VTOFFSET.epoch.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var epochSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.epoch.v) }
  ///  The pedigree of state vector, or methods used for its generation to include state update/orbit determination, propagation from another state, or a state from a calibration satellite (e.g. ORBIT_UPDATE, PROPAGATION, CALIBRATION, CONJUNCTION, FLIGHT_PLAN).
  ///  Example: /// Example: CONJUNCTION
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var pedigree: String? { let o = _accessor.offset(VTOFFSET.pedigree.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var pedigreeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.pedigree.v) }
  ///  Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
  ///  Example: /// Example: ONORBIT-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idOnOrbit: String? { let o = _accessor.offset(VTOFFSET.idOnOrbit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idOnOrbitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idOnOrbit.v) }
  ///  Satellite/Catalog number of the target OnOrbit object.
  ///  Example: /// Example: 12
  ///  Constraints: No constraints specified.
  public var satNo: Int32 { let o = _accessor.offset(VTOFFSET.satNo.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Optional identifier provided by state vector source to indicate the target onorbit object of this state vector. This may be an internal identifier and not necessarily map to a valid satellite number.
  ///  Example: /// Example: ORIGOBJECT-ID
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origObjectId: String? { let o = _accessor.offset(VTOFFSET.origObjectId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origObjectIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origObjectId.v) }
  ///  Unique identifier of the OD solution record that produced this state vector. This ID can be used to obtain additional information on an OrbitDetermination object using the 'get by ID' operation (e.g. /udl/orbitdetermination/{id}). For example, the OrbitDetermination with idOrbitDetermination = abc would be queries as /udl/orbitdetermination/abc.
  ///  Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idOrbitDetermination: String? { let o = _accessor.offset(VTOFFSET.idOrbitDetermination.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idOrbitDeterminationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idOrbitDetermination.v) }
  ///  Boolean indicating this state vector was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var uct: Bool { let o = _accessor.offset(VTOFFSET.uct.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Cartesian X position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: -1118.577381
  ///  Constraints: No constraints specified.
  public var xpos: Double { let o = _accessor.offset(VTOFFSET.xpos.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Y position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 3026.231084
  ///  Constraints: No constraints specified.
  public var ypos: Double { let o = _accessor.offset(VTOFFSET.ypos.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Z position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 6167.831808
  ///  Constraints: No constraints specified.
  public var zpos: Double { let o = _accessor.offset(VTOFFSET.zpos.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian X velocity of target, in kilometers/second, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: -4.25242784
  ///  Constraints: No constraints specified.
  public var xvel: Double { let o = _accessor.offset(VTOFFSET.xvel.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Y velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 5.291107434
  ///  Constraints: No constraints specified.
  public var yvel: Double { let o = _accessor.offset(VTOFFSET.yvel.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Z velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: -3.356493869
  ///  Constraints: No constraints specified.
  public var zvel: Double { let o = _accessor.offset(VTOFFSET.zvel.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
  ///  Example: /// Example: J2000
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var referenceFrame: StateVector_Ingest_referenceFrame_Enum { let o = _accessor.offset(VTOFFSET.referenceFrame.v); return o == 0 ? .j2000 : StateVector_Ingest_referenceFrame_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .j2000 }
  ///  Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.  If the covReferenceFrame is null it is assumed to be J2000.
  ///  The array values (1-21) represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
  ///  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR&nbsp;&nbsp;
  ///  x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
  ///  y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3
  ///  z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6
  ///  x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;10
  ///  y'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
  ///  z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;
  ///  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
  ///  If additional covariance terms are included for DRAG, SRP, and/or THRUST, the matrix can be extended with the following order of elements:
  ///  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR
  ///  DRG&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;23&nbsp;&nbsp;24&nbsp;&nbsp;25&nbsp;&nbsp;26&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;
  ///  SRP&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;30&nbsp;&nbsp;31&nbsp;&nbsp;32&nbsp;&nbsp;33&nbsp;&nbsp;&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;
  ///  THR&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;38&nbsp;&nbsp;39&nbsp;&nbsp;40&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45&nbsp;
  ///  Example: /// Example: [1.1, 2.2]
  ///  Constraints: No constraints specified.
  public var hasCov: Bool { let o = _accessor.offset(VTOFFSET.cov.v); return o == 0 ? false : true }
  public var covCount: Int32 { let o = _accessor.offset(VTOFFSET.cov.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func cov(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.cov.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
  ///  Example: /// Example: J2000
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var covReferenceFrame: StateVector_Ingest_covReferenceFrame_Enum { let o = _accessor.offset(VTOFFSET.covReferenceFrame.v); return o == 0 ? .j2000 : StateVector_Ingest_covReferenceFrame_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .j2000 }
  ///  The method used to generate the covariance during the orbit determination (OD) that produced the state vector, or whether an arbitrary, non-calculated default value was used (CALCULATED, DEFAULT).
  ///  Example: /// Example: CALCULATED
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var covMethod: String? { let o = _accessor.offset(VTOFFSET.covMethod.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var covMethodSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.covMethod.v) }
  ///  The covariance matrix values represent the lower triangular half of the covariance matrix in terms of equinoctial elements.&nbsp; The size of the covariance matrix is dynamic.&nbsp; The values are outputted in order across each row, i.e.:
  ///  1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5
  ///  6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp; 10
  ///  :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  ///  :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  ///  51&nbsp; 52&nbsp; 53&nbsp; 54&nbsp; 55
  ///  :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  ///  :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  ///  The ordering of values is as follows:
  ///  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Af&nbsp;&nbsp; Ag&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp; N&nbsp;&nbsp; Chi&nbsp; Psi&nbsp;&nbsp; B&nbsp;&nbsp; BDOT AGOM&nbsp; T&nbsp;&nbsp; C1&nbsp;&nbsp; C2&nbsp; ...
  ///  Af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
  ///  Ag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3
  ///  L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 6
  ///  N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 10
  ///  Chi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; 12&nbsp;&nbsp; 13&nbsp;&nbsp; 14&nbsp;&nbsp; 15
  ///  Psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 17&nbsp;&nbsp; 18&nbsp;&nbsp; 19&nbsp;&nbsp; 20&nbsp;&nbsp; 21
  ///  B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 23&nbsp;&nbsp; 24 &nbsp;&nbsp;25&nbsp;&nbsp; 26&nbsp;&nbsp; 27&nbsp;&nbsp; 28
  ///  BDOT&nbsp;&nbsp; 29&nbsp;&nbsp; 30&nbsp;&nbsp; 31&nbsp;&nbsp; 32&nbsp;&nbsp; 33&nbsp;&nbsp; 34&nbsp;&nbsp; 35&nbsp;&nbsp; 36
  ///  AGOM&nbsp; 37&nbsp;&nbsp; 38&nbsp;&nbsp; 39&nbsp;&nbsp; 40&nbsp;&nbsp; 41&nbsp;&nbsp; 42&nbsp;&nbsp; 43&nbsp;&nbsp; 44&nbsp;&nbsp; 45
  ///  T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;&nbsp; 47&nbsp;&nbsp; 48&nbsp;&nbsp; 49&nbsp;&nbsp; 50&nbsp;&nbsp; 51&nbsp;&nbsp; 52&nbsp;&nbsp; 53&nbsp;&nbsp; 54&nbsp;&nbsp; 55
  ///  C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 56&nbsp;&nbsp; 57&nbsp;&nbsp; 58&nbsp;&nbsp; 59&nbsp;&nbsp; 60&nbsp;&nbsp; 61&nbsp;&nbsp; 62&nbsp;&nbsp; 63&nbsp;&nbsp; 64&nbsp;&nbsp; 65&nbsp;&nbsp; 66
  ///  C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67&nbsp;&nbsp; 68&nbsp;&nbsp; 69&nbsp;&nbsp; 70&nbsp;&nbsp; 71&nbsp; &nbsp;72&nbsp;&nbsp; 73&nbsp;&nbsp; 74&nbsp;&nbsp; 75&nbsp;&nbsp; 76&nbsp;&nbsp; 77&nbsp;&nbsp; 78
  ///  :
  ///  :
  ///  where C1, C2, etc, are the "consider parameters" that may be added to the covariance matrix.&nbsp; The covariance matrix will be as large as the last element/model parameter needed.&nbsp; In other words, if the DC solved for all 6 elements plus AGOM, the covariance matrix will be 9x9 (and the rows for B and BDOT will be all zeros).&nbsp; If the covariance matrix is unavailable, the size will be set to 0x0, and no data will follow.&nbsp; The cov field should contain only the lower left triangle values from top left down to bottom right, in order.
  ///  Example: /// Example: [1.1, 2.2]
  ///  Constraints: No constraints specified.
  public var hasEqCov: Bool { let o = _accessor.offset(VTOFFSET.eqCov.v); return o == 0 ? false : true }
  public var eqCovCount: Int32 { let o = _accessor.offset(VTOFFSET.eqCov.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func eqCov(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.eqCov.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Cartesian X position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: -1145.688502
  ///  Constraints: No constraints specified.
  public var xposAlt1: Double { let o = _accessor.offset(VTOFFSET.xposAlt1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Y position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: 3020.729572
  ///  Constraints: No constraints specified.
  public var yposAlt1: Double { let o = _accessor.offset(VTOFFSET.yposAlt1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Z position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: 6165.55187
  ///  Constraints: No constraints specified.
  public var zposAlt1: Double { let o = _accessor.offset(VTOFFSET.zposAlt1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian X velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: -4.270832252
  ///  Constraints: No constraints specified.
  public var xvelAlt1: Double { let o = _accessor.offset(VTOFFSET.xvelAlt1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Y velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: 5.27074276
  ///  Constraints: No constraints specified.
  public var yvelAlt1: Double { let o = _accessor.offset(VTOFFSET.yvelAlt1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Z velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: -3.365155181
  ///  Constraints: No constraints specified.
  public var zvelAlt1: Double { let o = _accessor.offset(VTOFFSET.zvelAlt1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The reference frame of the alternate1 (Alt1) cartesian orbital state.
  ///  Example: /// Example: TEME
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var alt1ReferenceFrame: String? { let o = _accessor.offset(VTOFFSET.alt1ReferenceFrame.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var alt1ReferenceFrameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.alt1ReferenceFrame.v) }
  ///  Cartesian X position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: -1456.915926
  ///  Constraints: No constraints specified.
  public var xposAlt2: Double { let o = _accessor.offset(VTOFFSET.xposAlt2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Y position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: -2883.540406
  ///  Constraints: No constraints specified.
  public var yposAlt2: Double { let o = _accessor.offset(VTOFFSET.yposAlt2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Z position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: 6165.55187
  ///  Constraints: No constraints specified.
  public var zposAlt2: Double { let o = _accessor.offset(VTOFFSET.zposAlt2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian X velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: -1.219814294
  ///  Constraints: No constraints specified.
  public var xvelAlt2: Double { let o = _accessor.offset(VTOFFSET.xvelAlt2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Y velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: -6.602080212
  ///  Constraints: No constraints specified.
  public var yvelAlt2: Double { let o = _accessor.offset(VTOFFSET.yvelAlt2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Z velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  ///  Example: /// Example: -3.365155181
  ///  Constraints: No constraints specified.
  public var zvelAlt2: Double { let o = _accessor.offset(VTOFFSET.zvelAlt2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The reference frame of the alternate2 (Alt2) cartesian orbital state.
  ///  Example: /// Example: EFG/TDR
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var alt2ReferenceFrame: String? { let o = _accessor.offset(VTOFFSET.alt2ReferenceFrame.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var alt2ReferenceFrameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.alt2ReferenceFrame.v) }
  ///  One sigma position uncertainty, in kilometers.
  ///  Example: /// Example: 0.333399744452
  ///  Constraints: No constraints specified.
  public var posUnc: Double { let o = _accessor.offset(VTOFFSET.posUnc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  One sigma velocity uncertainty, in kilometers/second.
  ///  Example: /// Example: 4e-06
  ///  Constraints: No constraints specified.
  public var velUnc: Double { let o = _accessor.offset(VTOFFSET.velUnc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The mass of the object, in kilograms.
  ///  Example: /// Example: 164.5
  ///  Constraints: No constraints specified.
  public var mass: Double { let o = _accessor.offset(VTOFFSET.mass.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The actual area of the object at it's largest cross-section, expressed in meters^2.
  ///  Example: /// Example: 5.065
  ///  Constraints: No constraints specified.
  public var area: Double { let o = _accessor.offset(VTOFFSET.area.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Area-to-mass ratio coefficient for solar radiation pressure.
  ///  Example: /// Example: 0.0244394
  ///  Constraints: No constraints specified.
  public var solarRadPressCoeff: Double { let o = _accessor.offset(VTOFFSET.solarRadPressCoeff.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Area-to-mass ratio coefficient for atmospheric ballistic drag (m2/kg).
  ///  Example: /// Example: 0.0224391269775
  ///  Constraints: No constraints specified.
  public var dragCoeff: Double { let o = _accessor.offset(VTOFFSET.dragCoeff.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The effective area of the object exposed to atmospheric drag, expressed in meters^2.
  ///  Example: /// Example: 4.739
  ///  Constraints: No constraints specified.
  public var dragArea: Double { let o = _accessor.offset(VTOFFSET.dragArea.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Epoch revolution number.
  ///  Example: /// Example: 7205
  ///  Constraints: No constraints specified.
  public var revNo: Int32 { let o = _accessor.offset(VTOFFSET.revNo.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Geopotential model used for this vector (e.g. EGM-96, WGS-84, WGS-72, JGM-2, or GEM-T3), including mm degree zonals, nn degree/order tesserals. E.g. EGM-96 24Z,24T.
  ///  Example: /// Example: EGM-96
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var geopotentialModel: String? { let o = _accessor.offset(VTOFFSET.geopotentialModel.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var geopotentialModelSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.geopotentialModel.v) }
  ///  The Drag Model used for this vector (e.g. HARRIS-PRIESTER, JAC70, JBH09, MSIS90, NONE, etc.).
  ///  Example: /// Example: JAC70
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var dragModel: String? { let o = _accessor.offset(VTOFFSET.dragModel.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var dragModelSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.dragModel.v) }
  ///  Boolean indicating use of lunar/solar perturbations for this vector.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var lunarSolar: Bool { let o = _accessor.offset(VTOFFSET.lunarSolar.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Boolean indicating use of solar radiation pressure perturbations for this vector.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var solarRadPress: Bool { let o = _accessor.offset(VTOFFSET.solarRadPress.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  The effective area of the object exposed to solar radiation pressure, expressed in meters^2.
  ///  Example: /// Example: 4.311
  ///  Constraints: No constraints specified.
  public var srpArea: Double { let o = _accessor.offset(VTOFFSET.srpArea.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Boolean indicating use of solid earth tide perturbations for this vector.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var solidEarthTides: Bool { let o = _accessor.offset(VTOFFSET.solidEarthTides.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Boolean indicating use of in-track thrust perturbations for this vector.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var inTrackThrust: Bool { let o = _accessor.offset(VTOFFSET.inTrackThrust.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  First derivative of drag/ballistic coefficient (m2/kg-s).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var bDot: Double { let o = _accessor.offset(VTOFFSET.bDot.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Model parameter value for energy dissipation rate (EDR) (w/kg).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var edr: Double { let o = _accessor.offset(VTOFFSET.edr.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Model parameter value for thrust acceleration (m/s2).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var thrustAccel: Double { let o = _accessor.offset(VTOFFSET.thrustAccel.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Model parameter value for center of mass offset (m).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var cmOffset: Double { let o = _accessor.offset(VTOFFSET.cmOffset.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The start of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
  ///  Example: /// Example: 2022-11-09T11:20:21.247192Z
  ///  Constraints: No constraints specified.
  public var lastObStart: String? { let o = _accessor.offset(VTOFFSET.lastObStart.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var lastObStartSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.lastObStart.v) }
  ///  The end of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
  ///  Example: /// Example: 2022-11-09T11:20:21.247192Z
  ///  Constraints: No constraints specified.
  public var lastObEnd: String? { let o = _accessor.offset(VTOFFSET.lastObEnd.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var lastObEndSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.lastObEnd.v) }
  ///  The number of observations available for the OD of the object.
  ///  Example: /// Example: 376
  ///  Constraints: No constraints specified.
  public var obsAvailable: Int32 { let o = _accessor.offset(VTOFFSET.obsAvailable.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The number of observations accepted for the OD of the object.
  ///  Example: /// Example: 374
  ///  Constraints: No constraints specified.
  public var obsUsed: Int32 { let o = _accessor.offset(VTOFFSET.obsUsed.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The number of sensor tracks available for the OD of the object.
  ///  Example: /// Example: 163
  ///  Constraints: No constraints specified.
  public var tracksAvail: Int32 { let o = _accessor.offset(VTOFFSET.tracksAvail.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The number of sensor tracks accepted for the OD of the object.
  ///  Example: /// Example: 163
  ///  Constraints: No constraints specified.
  public var tracksUsed: Int32 { let o = _accessor.offset(VTOFFSET.tracksUsed.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The recommended OD time span calculated for the object, expressed in days.
  ///  Example: /// Example: 3.5
  ///  Constraints: No constraints specified.
  public var recOdspan: Double { let o = _accessor.offset(VTOFFSET.recOdspan.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The actual time span used for the OD of the object, expressed in days.
  ///  Example: /// Example: 3.5
  ///  Constraints: No constraints specified.
  public var actualOdspan: Double { let o = _accessor.offset(VTOFFSET.actualOdspan.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The percentage of residuals accepted in the OD of the object.
  ///  Example: /// Example: 99.5
  ///  Constraints: No constraints specified.
  public var residualsAcc: Double { let o = _accessor.offset(VTOFFSET.residualsAcc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  F10 (10.7 cm) solar flux value.
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var solarFluxF10: Double { let o = _accessor.offset(VTOFFSET.solarFluxF10.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  F10 (10.7 cm) solar flux 81-day average value.
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var solarFluxF10Avg: Double { let o = _accessor.offset(VTOFFSET.solarFluxF10Avg.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Average solar flux geomagnetic index.
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var solarFluxApavg: Double { let o = _accessor.offset(VTOFFSET.solarFluxApavg.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  TAI (Temps Atomique International) minus UTC (Universal Time Coordinates) offset in seconds.
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var taiUtc: Double { let o = _accessor.offset(VTOFFSET.taiUtc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Universal Time-1 (UT1) minus UTC offset, in seconds.
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var ut1Utc: Double { let o = _accessor.offset(VTOFFSET.ut1Utc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Rate of change of UT1 (milliseconds/day) - first derivative of ut1Utc.
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var ut1Rate: Double { let o = _accessor.offset(VTOFFSET.ut1Rate.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Polar Wander Motion X (arc seconds).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var polarMotionX: Double { let o = _accessor.offset(VTOFFSET.polarMotionX.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Polar Wander Motion Y (arc seconds).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var polarMotionY: Double { let o = _accessor.offset(VTOFFSET.polarMotionY.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Number of terms used in the IAU 1980 nutation model (4, 50, or 106).
  ///  Example: /// Example: 4
  ///  Constraints: No constraints specified.
  public var iau1980Terms: Int32 { let o = _accessor.offset(VTOFFSET.iau1980Terms.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Time of the next leap second after epoch in ISO 8601 UTC time. If the next leap second is not known, the time of the previous leap second is used.
  ///  Example: /// Example: 2021-01-01T01:01:01.123Z
  ///  Constraints: No constraints specified.
  public var leapSecondTime: String? { let o = _accessor.offset(VTOFFSET.leapSecondTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var leapSecondTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.leapSecondTime.v) }
  ///  Integrator Mode.
  ///  Example: /// Example: integratorMode
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var integratorMode: String? { let o = _accessor.offset(VTOFFSET.integratorMode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var integratorModeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.integratorMode.v) }
  ///  Type of partial derivatives used (ANALYTIC, FULL NUM, or FAST NUM).
  ///  Example: /// Example: ANALYTIC
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var partials: String? { let o = _accessor.offset(VTOFFSET.partials.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var partialsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.partials.v) }
  ///  Integrator step mode (AUTO, TIME, or S).
  ///  Example: /// Example: AUTO
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var stepMode: String? { let o = _accessor.offset(VTOFFSET.stepMode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var stepModeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.stepMode.v) }
  ///  Boolean indicating use of fixed step size for this vector.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var fixedStep: Bool { let o = _accessor.offset(VTOFFSET.fixedStep.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Initial step size selection (AUTO or MANUAL).
  ///  Example: /// Example: AUTO
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var stepSizeSelection: String? { let o = _accessor.offset(VTOFFSET.stepSizeSelection.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var stepSizeSelectionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.stepSizeSelection.v) }
  ///  Initial integration step size (seconds).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var stepSize: Double { let o = _accessor.offset(VTOFFSET.stepSize.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Integrator error control.
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var errorControl: Double { let o = _accessor.offset(VTOFFSET.errorControl.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Array containing the standard deviation of error in target object position, U, V and W direction respectively (km).
  ///  Example: /// Example: [1.23, 4.56]
  ///  Constraints: No constraints specified.
  public var hasSigmaPosUvw: Bool { let o = _accessor.offset(VTOFFSET.sigmaPosUvw.v); return o == 0 ? false : true }
  public var sigmaPosUvwCount: Int32 { let o = _accessor.offset(VTOFFSET.sigmaPosUvw.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func sigmaPosUvw(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.sigmaPosUvw.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array containing the standard deviation of error in target object velocity, U, V and W direction respectively (km/sec).
  ///  Example: /// Example: [1.23, 4.56]
  ///  Constraints: No constraints specified.
  public var hasSigmaVelUvw: Bool { let o = _accessor.offset(VTOFFSET.sigmaVelUvw.v); return o == 0 ? false : true }
  public var sigmaVelUvwCount: Int32 { let o = _accessor.offset(VTOFFSET.sigmaVelUvw.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func sigmaVelUvw(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.sigmaVelUvw.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The Weighted Root Mean Squared (RMS) of the differential correction on the target object that produced this vector.  WRMS is a quality indicator of the state vector update, with a value of 1.00 being optimal.  WRMS applies to Batch Least Squares (BLS) processes.
  ///  Example: /// Example: 0.991
  ///  Constraints: No constraints specified.
  public var rms: Double { let o = _accessor.offset(VTOFFSET.rms.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  ///  Example: /// Example: rawFileURI
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var rawFileUri: String? { let o = _accessor.offset(VTOFFSET.rawFileUri.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var rawFileUriSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.rawFileUri.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: StateVector_Ingest_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : StateVector_Ingest_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  ///  Example: /// Example: ['TAG1', 'TAG2']
  ///  Constraints: No constraints specified.
  public var hasTags: Bool { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? false : true }
  public var tagsCount: Int32 { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tags(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Optional algorithm used to produce this record.
  ///  Example: /// Example: SAMPLE_ALGORITHM
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var algorithm: String? { let o = _accessor.offset(VTOFFSET.algorithm.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var algorithmSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.algorithm.v) }
  ///  Optional array of UDL data (observation) UUIDs used to build this state vector. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
  ///  Example: /// Example: ['DATA1', 'DATA2']
  ///  Constraints: No constraints specified.
  public var hasSourcedData: Bool { let o = _accessor.offset(VTOFFSET.sourcedData.v); return o == 0 ? false : true }
  public var sourcedDataCount: Int32 { let o = _accessor.offset(VTOFFSET.sourcedData.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func sourcedData(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.sourcedData.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Optional array of UDL observation data types used to build this state vector (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
  ///  Example: /// Example: ['RADAR']
  ///  Constraints: No constraints specified.
  public var sourcedDataTypes: StateVector_Ingest_sourcedDataTypes_Enum { let o = _accessor.offset(VTOFFSET.sourcedDataTypes.v); return o == 0 ? .eo : StateVector_Ingest_sourcedDataTypes_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .eo }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Optional source-provided and searchable metadata or descriptor of the data.
  ///  Example: /// Example: descriptor
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var descriptor: String? { let o = _accessor.offset(VTOFFSET.descriptor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.descriptor.v) }
  ///  Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  ///  Example: /// Example: transactionId
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var transactionId: String? { let o = _accessor.offset(VTOFFSET.transactionId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var transactionIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.transactionId.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  ///  Example: /// Example: AXE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var sourceDl: String? { let o = _accessor.offset(VTOFFSET.sourceDl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceDlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceDl.v) }
  public static func startStateVector_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 96) }
  public static func add(idStateVector: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idStateVector, at: VTOFFSET.idStateVector.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(epoch: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: epoch, at: VTOFFSET.epoch.p) }
  public static func add(pedigree: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: pedigree, at: VTOFFSET.pedigree.p) }
  public static func add(idOnOrbit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idOnOrbit, at: VTOFFSET.idOnOrbit.p) }
  public static func add(satNo: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: satNo, def: 0, at: VTOFFSET.satNo.p) }
  public static func add(origObjectId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origObjectId, at: VTOFFSET.origObjectId.p) }
  public static func add(idOrbitDetermination: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idOrbitDetermination, at: VTOFFSET.idOrbitDetermination.p) }
  public static func add(uct: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: uct, def: false,
   at: VTOFFSET.uct.p) }
  public static func add(xpos: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: xpos, def: 0.0, at: VTOFFSET.xpos.p) }
  public static func add(ypos: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ypos, def: 0.0, at: VTOFFSET.ypos.p) }
  public static func add(zpos: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zpos, def: 0.0, at: VTOFFSET.zpos.p) }
  public static func add(xvel: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: xvel, def: 0.0, at: VTOFFSET.xvel.p) }
  public static func add(yvel: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: yvel, def: 0.0, at: VTOFFSET.yvel.p) }
  public static func add(zvel: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zvel, def: 0.0, at: VTOFFSET.zvel.p) }
  public static func add(referenceFrame: StateVector_Ingest_referenceFrame_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: referenceFrame.rawValue, def: 0, at: VTOFFSET.referenceFrame.p) }
  public static func addVectorOf(cov: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: cov, at: VTOFFSET.cov.p) }
  public static func add(covReferenceFrame: StateVector_Ingest_covReferenceFrame_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: covReferenceFrame.rawValue, def: 0, at: VTOFFSET.covReferenceFrame.p) }
  public static func add(covMethod: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: covMethod, at: VTOFFSET.covMethod.p) }
  public static func addVectorOf(eqCov: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: eqCov, at: VTOFFSET.eqCov.p) }
  public static func add(xposAlt1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: xposAlt1, def: 0.0, at: VTOFFSET.xposAlt1.p) }
  public static func add(yposAlt1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: yposAlt1, def: 0.0, at: VTOFFSET.yposAlt1.p) }
  public static func add(zposAlt1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zposAlt1, def: 0.0, at: VTOFFSET.zposAlt1.p) }
  public static func add(xvelAlt1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: xvelAlt1, def: 0.0, at: VTOFFSET.xvelAlt1.p) }
  public static func add(yvelAlt1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: yvelAlt1, def: 0.0, at: VTOFFSET.yvelAlt1.p) }
  public static func add(zvelAlt1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zvelAlt1, def: 0.0, at: VTOFFSET.zvelAlt1.p) }
  public static func add(alt1ReferenceFrame: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: alt1ReferenceFrame, at: VTOFFSET.alt1ReferenceFrame.p) }
  public static func add(xposAlt2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: xposAlt2, def: 0.0, at: VTOFFSET.xposAlt2.p) }
  public static func add(yposAlt2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: yposAlt2, def: 0.0, at: VTOFFSET.yposAlt2.p) }
  public static func add(zposAlt2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zposAlt2, def: 0.0, at: VTOFFSET.zposAlt2.p) }
  public static func add(xvelAlt2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: xvelAlt2, def: 0.0, at: VTOFFSET.xvelAlt2.p) }
  public static func add(yvelAlt2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: yvelAlt2, def: 0.0, at: VTOFFSET.yvelAlt2.p) }
  public static func add(zvelAlt2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zvelAlt2, def: 0.0, at: VTOFFSET.zvelAlt2.p) }
  public static func add(alt2ReferenceFrame: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: alt2ReferenceFrame, at: VTOFFSET.alt2ReferenceFrame.p) }
  public static func add(posUnc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: posUnc, def: 0.0, at: VTOFFSET.posUnc.p) }
  public static func add(velUnc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: velUnc, def: 0.0, at: VTOFFSET.velUnc.p) }
  public static func add(mass: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mass, def: 0.0, at: VTOFFSET.mass.p) }
  public static func add(area: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: area, def: 0.0, at: VTOFFSET.area.p) }
  public static func add(solarRadPressCoeff: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: solarRadPressCoeff, def: 0.0, at: VTOFFSET.solarRadPressCoeff.p) }
  public static func add(dragCoeff: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dragCoeff, def: 0.0, at: VTOFFSET.dragCoeff.p) }
  public static func add(dragArea: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dragArea, def: 0.0, at: VTOFFSET.dragArea.p) }
  public static func add(revNo: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: revNo, def: 0, at: VTOFFSET.revNo.p) }
  public static func add(geopotentialModel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: geopotentialModel, at: VTOFFSET.geopotentialModel.p) }
  public static func add(dragModel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dragModel, at: VTOFFSET.dragModel.p) }
  public static func add(lunarSolar: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lunarSolar, def: false,
   at: VTOFFSET.lunarSolar.p) }
  public static func add(solarRadPress: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: solarRadPress, def: false,
   at: VTOFFSET.solarRadPress.p) }
  public static func add(srpArea: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: srpArea, def: 0.0, at: VTOFFSET.srpArea.p) }
  public static func add(solidEarthTides: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: solidEarthTides, def: false,
   at: VTOFFSET.solidEarthTides.p) }
  public static func add(inTrackThrust: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: inTrackThrust, def: false,
   at: VTOFFSET.inTrackThrust.p) }
  public static func add(bDot: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bDot, def: 0.0, at: VTOFFSET.bDot.p) }
  public static func add(edr: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: edr, def: 0.0, at: VTOFFSET.edr.p) }
  public static func add(thrustAccel: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: thrustAccel, def: 0.0, at: VTOFFSET.thrustAccel.p) }
  public static func add(cmOffset: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cmOffset, def: 0.0, at: VTOFFSET.cmOffset.p) }
  public static func add(lastObStart: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lastObStart, at: VTOFFSET.lastObStart.p) }
  public static func add(lastObEnd: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lastObEnd, at: VTOFFSET.lastObEnd.p) }
  public static func add(obsAvailable: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: obsAvailable, def: 0, at: VTOFFSET.obsAvailable.p) }
  public static func add(obsUsed: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: obsUsed, def: 0, at: VTOFFSET.obsUsed.p) }
  public static func add(tracksAvail: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tracksAvail, def: 0, at: VTOFFSET.tracksAvail.p) }
  public static func add(tracksUsed: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tracksUsed, def: 0, at: VTOFFSET.tracksUsed.p) }
  public static func add(recOdspan: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: recOdspan, def: 0.0, at: VTOFFSET.recOdspan.p) }
  public static func add(actualOdspan: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: actualOdspan, def: 0.0, at: VTOFFSET.actualOdspan.p) }
  public static func add(residualsAcc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: residualsAcc, def: 0.0, at: VTOFFSET.residualsAcc.p) }
  public static func add(solarFluxF10: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: solarFluxF10, def: 0.0, at: VTOFFSET.solarFluxF10.p) }
  public static func add(solarFluxF10Avg: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: solarFluxF10Avg, def: 0.0, at: VTOFFSET.solarFluxF10Avg.p) }
  public static func add(solarFluxApavg: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: solarFluxApavg, def: 0.0, at: VTOFFSET.solarFluxApavg.p) }
  public static func add(taiUtc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: taiUtc, def: 0.0, at: VTOFFSET.taiUtc.p) }
  public static func add(ut1Utc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ut1Utc, def: 0.0, at: VTOFFSET.ut1Utc.p) }
  public static func add(ut1Rate: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ut1Rate, def: 0.0, at: VTOFFSET.ut1Rate.p) }
  public static func add(polarMotionX: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: polarMotionX, def: 0.0, at: VTOFFSET.polarMotionX.p) }
  public static func add(polarMotionY: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: polarMotionY, def: 0.0, at: VTOFFSET.polarMotionY.p) }
  public static func add(iau1980Terms: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: iau1980Terms, def: 0, at: VTOFFSET.iau1980Terms.p) }
  public static func add(leapSecondTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: leapSecondTime, at: VTOFFSET.leapSecondTime.p) }
  public static func add(integratorMode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: integratorMode, at: VTOFFSET.integratorMode.p) }
  public static func add(partials: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: partials, at: VTOFFSET.partials.p) }
  public static func add(stepMode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: stepMode, at: VTOFFSET.stepMode.p) }
  public static func add(fixedStep: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fixedStep, def: false,
   at: VTOFFSET.fixedStep.p) }
  public static func add(stepSizeSelection: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: stepSizeSelection, at: VTOFFSET.stepSizeSelection.p) }
  public static func add(stepSize: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stepSize, def: 0.0, at: VTOFFSET.stepSize.p) }
  public static func add(errorControl: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: errorControl, def: 0.0, at: VTOFFSET.errorControl.p) }
  public static func addVectorOf(sigmaPosUvw: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sigmaPosUvw, at: VTOFFSET.sigmaPosUvw.p) }
  public static func addVectorOf(sigmaVelUvw: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sigmaVelUvw, at: VTOFFSET.sigmaVelUvw.p) }
  public static func add(rms: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: rms, def: 0.0, at: VTOFFSET.rms.p) }
  public static func add(rawFileUri: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rawFileUri, at: VTOFFSET.rawFileUri.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(dataMode: StateVector_Ingest_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func addVectorOf(tags: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tags, at: VTOFFSET.tags.p) }
  public static func add(algorithm: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: algorithm, at: VTOFFSET.algorithm.p) }
  public static func addVectorOf(sourcedData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourcedData, at: VTOFFSET.sourcedData.p) }
  public static func add(sourcedDataTypes: StateVector_Ingest_sourcedDataTypes_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sourcedDataTypes.rawValue, def: 0, at: VTOFFSET.sourcedDataTypes.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(descriptor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: descriptor, at: VTOFFSET.descriptor.p) }
  public static func add(transactionId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: transactionId, at: VTOFFSET.transactionId.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(sourceDl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceDl, at: VTOFFSET.sourceDl.p) }
  public static func endStateVector_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStateVector_Ingest(
    _ fbb: inout FlatBufferBuilder,
    idStateVectorOffset idStateVector: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    epochOffset epoch: Offset = Offset(),
    pedigreeOffset pedigree: Offset = Offset(),
    idOnOrbitOffset idOnOrbit: Offset = Offset(),
    satNo: Int32 = 0,
    origObjectIdOffset origObjectId: Offset = Offset(),
    idOrbitDeterminationOffset idOrbitDetermination: Offset = Offset(),
    uct: Bool = false,
    xpos: Double = 0.0,
    ypos: Double = 0.0,
    zpos: Double = 0.0,
    xvel: Double = 0.0,
    yvel: Double = 0.0,
    zvel: Double = 0.0,
    referenceFrame: StateVector_Ingest_referenceFrame_Enum = .j2000,
    covVectorOffset cov: Offset = Offset(),
    covReferenceFrame: StateVector_Ingest_covReferenceFrame_Enum = .j2000,
    covMethodOffset covMethod: Offset = Offset(),
    eqCovVectorOffset eqCov: Offset = Offset(),
    xposAlt1: Double = 0.0,
    yposAlt1: Double = 0.0,
    zposAlt1: Double = 0.0,
    xvelAlt1: Double = 0.0,
    yvelAlt1: Double = 0.0,
    zvelAlt1: Double = 0.0,
    alt1ReferenceFrameOffset alt1ReferenceFrame: Offset = Offset(),
    xposAlt2: Double = 0.0,
    yposAlt2: Double = 0.0,
    zposAlt2: Double = 0.0,
    xvelAlt2: Double = 0.0,
    yvelAlt2: Double = 0.0,
    zvelAlt2: Double = 0.0,
    alt2ReferenceFrameOffset alt2ReferenceFrame: Offset = Offset(),
    posUnc: Double = 0.0,
    velUnc: Double = 0.0,
    mass: Double = 0.0,
    area: Double = 0.0,
    solarRadPressCoeff: Double = 0.0,
    dragCoeff: Double = 0.0,
    dragArea: Double = 0.0,
    revNo: Int32 = 0,
    geopotentialModelOffset geopotentialModel: Offset = Offset(),
    dragModelOffset dragModel: Offset = Offset(),
    lunarSolar: Bool = false,
    solarRadPress: Bool = false,
    srpArea: Double = 0.0,
    solidEarthTides: Bool = false,
    inTrackThrust: Bool = false,
    bDot: Double = 0.0,
    edr: Double = 0.0,
    thrustAccel: Double = 0.0,
    cmOffset: Double = 0.0,
    lastObStartOffset lastObStart: Offset = Offset(),
    lastObEndOffset lastObEnd: Offset = Offset(),
    obsAvailable: Int32 = 0,
    obsUsed: Int32 = 0,
    tracksAvail: Int32 = 0,
    tracksUsed: Int32 = 0,
    recOdspan: Double = 0.0,
    actualOdspan: Double = 0.0,
    residualsAcc: Double = 0.0,
    solarFluxF10: Double = 0.0,
    solarFluxF10Avg: Double = 0.0,
    solarFluxApavg: Double = 0.0,
    taiUtc: Double = 0.0,
    ut1Utc: Double = 0.0,
    ut1Rate: Double = 0.0,
    polarMotionX: Double = 0.0,
    polarMotionY: Double = 0.0,
    iau1980Terms: Int32 = 0,
    leapSecondTimeOffset leapSecondTime: Offset = Offset(),
    integratorModeOffset integratorMode: Offset = Offset(),
    partialsOffset partials: Offset = Offset(),
    stepModeOffset stepMode: Offset = Offset(),
    fixedStep: Bool = false,
    stepSizeSelectionOffset stepSizeSelection: Offset = Offset(),
    stepSize: Double = 0.0,
    errorControl: Double = 0.0,
    sigmaPosUvwVectorOffset sigmaPosUvw: Offset = Offset(),
    sigmaVelUvwVectorOffset sigmaVelUvw: Offset = Offset(),
    rms: Double = 0.0,
    rawFileUriOffset rawFileUri: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    dataMode: StateVector_Ingest_dataMode_Enum = .real,
    tagsVectorOffset tags: Offset = Offset(),
    algorithmOffset algorithm: Offset = Offset(),
    sourcedDataVectorOffset sourcedData: Offset = Offset(),
    sourcedDataTypes: StateVector_Ingest_sourcedDataTypes_Enum = .eo,
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    descriptorOffset descriptor: Offset = Offset(),
    transactionIdOffset transactionId: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    sourceDlOffset sourceDl: Offset = Offset()
  ) -> Offset {
    let __start = StateVector_Ingest.startStateVector_Ingest(&fbb)
    StateVector_Ingest.add(idStateVector: idStateVector, &fbb)
    StateVector_Ingest.add(classificationMarking: classificationMarking, &fbb)
    StateVector_Ingest.add(epoch: epoch, &fbb)
    StateVector_Ingest.add(pedigree: pedigree, &fbb)
    StateVector_Ingest.add(idOnOrbit: idOnOrbit, &fbb)
    StateVector_Ingest.add(satNo: satNo, &fbb)
    StateVector_Ingest.add(origObjectId: origObjectId, &fbb)
    StateVector_Ingest.add(idOrbitDetermination: idOrbitDetermination, &fbb)
    StateVector_Ingest.add(uct: uct, &fbb)
    StateVector_Ingest.add(xpos: xpos, &fbb)
    StateVector_Ingest.add(ypos: ypos, &fbb)
    StateVector_Ingest.add(zpos: zpos, &fbb)
    StateVector_Ingest.add(xvel: xvel, &fbb)
    StateVector_Ingest.add(yvel: yvel, &fbb)
    StateVector_Ingest.add(zvel: zvel, &fbb)
    StateVector_Ingest.add(referenceFrame: referenceFrame, &fbb)
    StateVector_Ingest.addVectorOf(cov: cov, &fbb)
    StateVector_Ingest.add(covReferenceFrame: covReferenceFrame, &fbb)
    StateVector_Ingest.add(covMethod: covMethod, &fbb)
    StateVector_Ingest.addVectorOf(eqCov: eqCov, &fbb)
    StateVector_Ingest.add(xposAlt1: xposAlt1, &fbb)
    StateVector_Ingest.add(yposAlt1: yposAlt1, &fbb)
    StateVector_Ingest.add(zposAlt1: zposAlt1, &fbb)
    StateVector_Ingest.add(xvelAlt1: xvelAlt1, &fbb)
    StateVector_Ingest.add(yvelAlt1: yvelAlt1, &fbb)
    StateVector_Ingest.add(zvelAlt1: zvelAlt1, &fbb)
    StateVector_Ingest.add(alt1ReferenceFrame: alt1ReferenceFrame, &fbb)
    StateVector_Ingest.add(xposAlt2: xposAlt2, &fbb)
    StateVector_Ingest.add(yposAlt2: yposAlt2, &fbb)
    StateVector_Ingest.add(zposAlt2: zposAlt2, &fbb)
    StateVector_Ingest.add(xvelAlt2: xvelAlt2, &fbb)
    StateVector_Ingest.add(yvelAlt2: yvelAlt2, &fbb)
    StateVector_Ingest.add(zvelAlt2: zvelAlt2, &fbb)
    StateVector_Ingest.add(alt2ReferenceFrame: alt2ReferenceFrame, &fbb)
    StateVector_Ingest.add(posUnc: posUnc, &fbb)
    StateVector_Ingest.add(velUnc: velUnc, &fbb)
    StateVector_Ingest.add(mass: mass, &fbb)
    StateVector_Ingest.add(area: area, &fbb)
    StateVector_Ingest.add(solarRadPressCoeff: solarRadPressCoeff, &fbb)
    StateVector_Ingest.add(dragCoeff: dragCoeff, &fbb)
    StateVector_Ingest.add(dragArea: dragArea, &fbb)
    StateVector_Ingest.add(revNo: revNo, &fbb)
    StateVector_Ingest.add(geopotentialModel: geopotentialModel, &fbb)
    StateVector_Ingest.add(dragModel: dragModel, &fbb)
    StateVector_Ingest.add(lunarSolar: lunarSolar, &fbb)
    StateVector_Ingest.add(solarRadPress: solarRadPress, &fbb)
    StateVector_Ingest.add(srpArea: srpArea, &fbb)
    StateVector_Ingest.add(solidEarthTides: solidEarthTides, &fbb)
    StateVector_Ingest.add(inTrackThrust: inTrackThrust, &fbb)
    StateVector_Ingest.add(bDot: bDot, &fbb)
    StateVector_Ingest.add(edr: edr, &fbb)
    StateVector_Ingest.add(thrustAccel: thrustAccel, &fbb)
    StateVector_Ingest.add(cmOffset: cmOffset, &fbb)
    StateVector_Ingest.add(lastObStart: lastObStart, &fbb)
    StateVector_Ingest.add(lastObEnd: lastObEnd, &fbb)
    StateVector_Ingest.add(obsAvailable: obsAvailable, &fbb)
    StateVector_Ingest.add(obsUsed: obsUsed, &fbb)
    StateVector_Ingest.add(tracksAvail: tracksAvail, &fbb)
    StateVector_Ingest.add(tracksUsed: tracksUsed, &fbb)
    StateVector_Ingest.add(recOdspan: recOdspan, &fbb)
    StateVector_Ingest.add(actualOdspan: actualOdspan, &fbb)
    StateVector_Ingest.add(residualsAcc: residualsAcc, &fbb)
    StateVector_Ingest.add(solarFluxF10: solarFluxF10, &fbb)
    StateVector_Ingest.add(solarFluxF10Avg: solarFluxF10Avg, &fbb)
    StateVector_Ingest.add(solarFluxApavg: solarFluxApavg, &fbb)
    StateVector_Ingest.add(taiUtc: taiUtc, &fbb)
    StateVector_Ingest.add(ut1Utc: ut1Utc, &fbb)
    StateVector_Ingest.add(ut1Rate: ut1Rate, &fbb)
    StateVector_Ingest.add(polarMotionX: polarMotionX, &fbb)
    StateVector_Ingest.add(polarMotionY: polarMotionY, &fbb)
    StateVector_Ingest.add(iau1980Terms: iau1980Terms, &fbb)
    StateVector_Ingest.add(leapSecondTime: leapSecondTime, &fbb)
    StateVector_Ingest.add(integratorMode: integratorMode, &fbb)
    StateVector_Ingest.add(partials: partials, &fbb)
    StateVector_Ingest.add(stepMode: stepMode, &fbb)
    StateVector_Ingest.add(fixedStep: fixedStep, &fbb)
    StateVector_Ingest.add(stepSizeSelection: stepSizeSelection, &fbb)
    StateVector_Ingest.add(stepSize: stepSize, &fbb)
    StateVector_Ingest.add(errorControl: errorControl, &fbb)
    StateVector_Ingest.addVectorOf(sigmaPosUvw: sigmaPosUvw, &fbb)
    StateVector_Ingest.addVectorOf(sigmaVelUvw: sigmaVelUvw, &fbb)
    StateVector_Ingest.add(rms: rms, &fbb)
    StateVector_Ingest.add(rawFileUri: rawFileUri, &fbb)
    StateVector_Ingest.add(source: source, &fbb)
    StateVector_Ingest.add(origin: origin, &fbb)
    StateVector_Ingest.add(dataMode: dataMode, &fbb)
    StateVector_Ingest.addVectorOf(tags: tags, &fbb)
    StateVector_Ingest.add(algorithm: algorithm, &fbb)
    StateVector_Ingest.addVectorOf(sourcedData: sourcedData, &fbb)
    StateVector_Ingest.add(sourcedDataTypes: sourcedDataTypes, &fbb)
    StateVector_Ingest.add(createdAt: createdAt, &fbb)
    StateVector_Ingest.add(createdBy: createdBy, &fbb)
    StateVector_Ingest.add(descriptor: descriptor, &fbb)
    StateVector_Ingest.add(transactionId: transactionId, &fbb)
    StateVector_Ingest.add(origNetwork: origNetwork, &fbb)
    StateVector_Ingest.add(sourceDl: sourceDl, &fbb)
    return StateVector_Ingest.endStateVector_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.idStateVector.p, fieldName: "idStateVector", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.epoch.p, fieldName: "epoch", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.pedigree.p, fieldName: "pedigree", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idOnOrbit.p, fieldName: "idOnOrbit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.satNo.p, fieldName: "satNo", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.origObjectId.p, fieldName: "origObjectId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idOrbitDetermination.p, fieldName: "idOrbitDetermination", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.uct.p, fieldName: "uct", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.xpos.p, fieldName: "xpos", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ypos.p, fieldName: "ypos", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.zpos.p, fieldName: "zpos", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.xvel.p, fieldName: "xvel", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.yvel.p, fieldName: "yvel", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.zvel.p, fieldName: "zvel", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.referenceFrame.p, fieldName: "referenceFrame", required: false, type: StateVector_Ingest_referenceFrame_Enum.self)
    try _v.visit(field: VTOFFSET.cov.p, fieldName: "cov", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.covReferenceFrame.p, fieldName: "covReferenceFrame", required: false, type: StateVector_Ingest_covReferenceFrame_Enum.self)
    try _v.visit(field: VTOFFSET.covMethod.p, fieldName: "covMethod", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.eqCov.p, fieldName: "eqCov", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.xposAlt1.p, fieldName: "xposAlt1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.yposAlt1.p, fieldName: "yposAlt1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.zposAlt1.p, fieldName: "zposAlt1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.xvelAlt1.p, fieldName: "xvelAlt1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.yvelAlt1.p, fieldName: "yvelAlt1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.zvelAlt1.p, fieldName: "zvelAlt1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.alt1ReferenceFrame.p, fieldName: "alt1ReferenceFrame", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.xposAlt2.p, fieldName: "xposAlt2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.yposAlt2.p, fieldName: "yposAlt2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.zposAlt2.p, fieldName: "zposAlt2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.xvelAlt2.p, fieldName: "xvelAlt2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.yvelAlt2.p, fieldName: "yvelAlt2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.zvelAlt2.p, fieldName: "zvelAlt2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.alt2ReferenceFrame.p, fieldName: "alt2ReferenceFrame", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.posUnc.p, fieldName: "posUnc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.velUnc.p, fieldName: "velUnc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.mass.p, fieldName: "mass", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.area.p, fieldName: "area", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.solarRadPressCoeff.p, fieldName: "solarRadPressCoeff", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.dragCoeff.p, fieldName: "dragCoeff", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.dragArea.p, fieldName: "dragArea", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.revNo.p, fieldName: "revNo", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.geopotentialModel.p, fieldName: "geopotentialModel", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dragModel.p, fieldName: "dragModel", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.lunarSolar.p, fieldName: "lunarSolar", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.solarRadPress.p, fieldName: "solarRadPress", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.srpArea.p, fieldName: "srpArea", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.solidEarthTides.p, fieldName: "solidEarthTides", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.inTrackThrust.p, fieldName: "inTrackThrust", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.bDot.p, fieldName: "bDot", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.edr.p, fieldName: "edr", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.thrustAccel.p, fieldName: "thrustAccel", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.cmOffset.p, fieldName: "cmOffset", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.lastObStart.p, fieldName: "lastObStart", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.lastObEnd.p, fieldName: "lastObEnd", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.obsAvailable.p, fieldName: "obsAvailable", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.obsUsed.p, fieldName: "obsUsed", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.tracksAvail.p, fieldName: "tracksAvail", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.tracksUsed.p, fieldName: "tracksUsed", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.recOdspan.p, fieldName: "recOdspan", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.actualOdspan.p, fieldName: "actualOdspan", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.residualsAcc.p, fieldName: "residualsAcc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.solarFluxF10.p, fieldName: "solarFluxF10", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.solarFluxF10Avg.p, fieldName: "solarFluxF10Avg", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.solarFluxApavg.p, fieldName: "solarFluxApavg", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.taiUtc.p, fieldName: "taiUtc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ut1Utc.p, fieldName: "ut1Utc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ut1Rate.p, fieldName: "ut1Rate", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.polarMotionX.p, fieldName: "polarMotionX", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.polarMotionY.p, fieldName: "polarMotionY", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.iau1980Terms.p, fieldName: "iau1980Terms", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.leapSecondTime.p, fieldName: "leapSecondTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.integratorMode.p, fieldName: "integratorMode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.partials.p, fieldName: "partials", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.stepMode.p, fieldName: "stepMode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.fixedStep.p, fieldName: "fixedStep", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.stepSizeSelection.p, fieldName: "stepSizeSelection", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.stepSize.p, fieldName: "stepSize", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.errorControl.p, fieldName: "errorControl", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.sigmaPosUvw.p, fieldName: "sigmaPosUvw", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.sigmaVelUvw.p, fieldName: "sigmaVelUvw", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.rms.p, fieldName: "rms", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.rawFileUri.p, fieldName: "rawFileUri", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: StateVector_Ingest_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.tags.p, fieldName: "tags", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.algorithm.p, fieldName: "algorithm", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourcedData.p, fieldName: "sourcedData", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.sourcedDataTypes.p, fieldName: "sourcedDataTypes", required: false, type: StateVector_Ingest_sourcedDataTypes_Enum.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.descriptor.p, fieldName: "descriptor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.transactionId.p, fieldName: "transactionId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceDl.p, fieldName: "sourceDl", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

