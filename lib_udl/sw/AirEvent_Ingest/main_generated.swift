// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum AirEvent_Ingest_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: AirEvent_Ingest_dataMode_Enum { return .exercise }
  public static var min: AirEvent_Ingest_dataMode_Enum { return .real }
}


///  /// Information related to an air event (e.g. FUEL TRANSFER, AIR DROP) and the associated aircraft.
public struct AirEvent_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "AIRE" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AirEvent_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case type = 8
    case idSortie = 10
    case idMission = 12
    case externalAirEventId = 14
    case legNum = 16
    case location = 18
    case arrPurpose = 20
    case plannedArrTime = 22
    case estArrTime = 24
    case actualArrTime = 26
    case depPurpose = 28
    case plannedDepTime = 30
    case estDepTime = 32
    case actualDepTime = 34
    case externalArtrackId = 36
    case arTrackId = 38
    case arTrackName = 40
    case rzct = 42
    case arct = 44
    case baseAlt = 46
    case priority = 48
    case trackTime = 50
    case statusCode = 52
    case rzPoint = 54
    case rzType = 56
    case arEventType = 58
    case numTankers = 60
    case revTrack = 62
    case shortTrack = 64
    case cancelled = 66
    case tankers = 68
    case receivers = 70
    case remarks = 72
    case createdAt = 74
    case createdBy = 76
    case updatedAt = 78
    case updatedBy = 80
    case sourceDl = 82
    case source = 84
    case origin = 86
    case origNetwork = 88
    case dataMode = 90
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system if not provided on create operations.
  ///  Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Type of air event (e.g. FUEL TRANSFER, AIR DROP, etc).
  ///  Example: /// Example: FUEL TRANSFER
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  ///  The UDL unique identifier of the sortie associated with this air event.
  ///  Example: /// Example: b9866c03-2397-4506-8153-852e72d9b54f
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idSortie: String? { let o = _accessor.offset(VTOFFSET.idSortie.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSortieSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSortie.v) }
  ///  The UDL unique identifier of the mission associated with this air event.
  ///  Example: /// Example: 190dea6d-2a90-45a2-a276-be9047d9b96c
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idMission: String? { let o = _accessor.offset(VTOFFSET.idMission.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idMissionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idMission.v) }
  ///  Optional air event ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  ///  Example: /// Example: MB014313032022407540
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var externalAirEventId: String? { let o = _accessor.offset(VTOFFSET.externalAirEventId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var externalAirEventIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.externalAirEventId.v) }
  ///  Identifies the Itinerary point of a sortie where an air event occurs.
  ///  Example: /// Example: 825
  ///  Constraints: No constraints specified.
  public var legNum: Int32 { let o = _accessor.offset(VTOFFSET.legNum.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The location representing this air event specified as a feature Id. Locations specified include air refueling track Ids and air drop event locations.
  ///  Example: /// Example: 901EW
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var location: String? { let o = _accessor.offset(VTOFFSET.location.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var locationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.location.v) }
  ///  The purpose of the air event at the arrival location. Can be either descriptive text such as 'fuel onload' or a purpose code specified by the provider, such as 'A'.
  ///  Example: /// Example: A
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var arrPurpose: String? { let o = _accessor.offset(VTOFFSET.arrPurpose.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var arrPurposeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.arrPurpose.v) }
  ///  The scheduled arrival time of the aircraft at the air event, in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-01-07T13:55:43.123Z
  ///  Constraints: No constraints specified.
  public var plannedArrTime: String? { let o = _accessor.offset(VTOFFSET.plannedArrTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var plannedArrTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.plannedArrTime.v) }
  ///  The current estimated arrival time of the aircraft at the air event, in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-01-07T13:59:48.123Z
  ///  Constraints: No constraints specified.
  public var estArrTime: String? { let o = _accessor.offset(VTOFFSET.estArrTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var estArrTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.estArrTime.v) }
  ///  The actual arrival time of the aircraft at the air event, in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-01-07T14:00:03.123Z
  ///  Constraints: No constraints specified.
  public var actualArrTime: String? { let o = _accessor.offset(VTOFFSET.actualArrTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var actualArrTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.actualArrTime.v) }
  ///  The purpose of the air event at the departure location. Can be either descriptive text such as 'fuel onload' or a purpose code specified by the provider, such as 'A'.
  ///  Example: /// Example: Q
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var depPurpose: String? { let o = _accessor.offset(VTOFFSET.depPurpose.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var depPurposeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.depPurpose.v) }
  ///  The scheduled departure time of the aircraft from the air event, in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-01-07T14:15:43.123Z
  ///  Constraints: No constraints specified.
  public var plannedDepTime: String? { let o = _accessor.offset(VTOFFSET.plannedDepTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var plannedDepTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.plannedDepTime.v) }
  ///  The current estimated departure time of the aircraft from the air event, in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-01-07T14:19:48.123Z
  ///  Constraints: No constraints specified.
  public var estDepTime: String? { let o = _accessor.offset(VTOFFSET.estDepTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var estDepTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.estDepTime.v) }
  ///  The actual departure time of the aircraft from the air event, in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-01-07T14:17:03.123Z
  ///  Constraints: No constraints specified.
  public var actualDepTime: String? { let o = _accessor.offset(VTOFFSET.actualDepTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var actualDepTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.actualDepTime.v) }
  ///  Optional air refueling track ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  ///  Example: /// Example: 6418a4b68e5c3896bf024cc79aa4174c
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var externalArtrackId: String? { let o = _accessor.offset(VTOFFSET.externalArtrackId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var externalArtrackIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.externalArtrackId.v) }
  ///  Identifier of the air refueling track, if applicable.
  ///  Example: /// Example: CH61
  ///  Constraints: Minimum length = 0, Maximum length = 15
  public var arTrackId: String? { let o = _accessor.offset(VTOFFSET.arTrackId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var arTrackIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.arTrackId.v) }
  ///  Name of the air refueling track, if applicable.
  ///  Example: /// Example: CH61 POST
  ///  Constraints: Minimum length = 0, Maximum length = 50
  public var arTrackName: String? { let o = _accessor.offset(VTOFFSET.arTrackName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var arTrackNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.arTrackName.v) }
  ///  The Rendezvous Control Time is the planned time the tanker and receiver aircraft will rendezvous for an en route type air refueling event, in ISO 8601 UTC format, with millisecond precision.
  ///  Example: /// Example: 2024-01-07T13:55:43.123Z
  ///  Constraints: No constraints specified.
  public var rzct: String? { let o = _accessor.offset(VTOFFSET.rzct.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var rzctSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.rzct.v) }
  ///  The Air Refueling Control Time is the planned time the tanker aircraft will transfer fuel to the receiver aircraft, in ISO 8601 UTC format, with millisecond precision.
  ///  Example: /// Example: 2024-01-07T15:11:27.123Z
  ///  Constraints: No constraints specified.
  public var arct: String? { let o = _accessor.offset(VTOFFSET.arct.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var arctSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.arct.v) }
  ///  Altitude of this air event, in feet.
  ///  Example: /// Example: 28000.1
  ///  Constraints: No constraints specified.
  public var baseAlt: Double { let o = _accessor.offset(VTOFFSET.baseAlt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Priority of this air event.
  ///  Example: /// Example: 1A2
  ///  Constraints: Minimum length = 0, Maximum length = 3
  public var priority: String? { let o = _accessor.offset(VTOFFSET.priority.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var prioritySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.priority.v) }
  ///  Length of time the receiver unit has requested for an air event, in hours.
  ///  Example: /// Example: 1.5
  ///  Constraints: No constraints specified.
  public var trackTime: Double { let o = _accessor.offset(VTOFFSET.trackTime.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Status of this air refueling event track reservation. Receivers are responsible for scheduling or reserving air refueling tracks. Possible values are A (Altitude Reservation), R (Reserved), or Q (Questionable).
  ///  Example: /// Example: R
  ///  Constraints: Minimum length = 0, Maximum length = 2
  public var statusCode: String? { let o = _accessor.offset(VTOFFSET.statusCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var statusCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.statusCode.v) }
  ///  Rendezvous point for the tanker and receiver during this air refueling event. Possible values are AN (Anchor Nav Point), AP (Anchor Pattern), CP (Control Point), ET (Entry Point), EX (Exit Point), IP (Initial Point), NC (Nav Check Point).
  ///  Example: /// Example: AN
  ///  Constraints: Minimum length = 0, Maximum length = 20
  public var rzPoint: String? { let o = _accessor.offset(VTOFFSET.rzPoint.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var rzPointSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.rzPoint.v) }
  ///  Type of rendezvous used for this air refueling event. Possible values are BUD (Buddy), EN (Enroute), GCI (Ground Control), PP (Point Parallel).
  ///  Example: /// Example: PP
  ///  Constraints: Minimum length = 0, Maximum length = 3
  public var rzType: String? { let o = _accessor.offset(VTOFFSET.rzType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var rzTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.rzType.v) }
  ///  Type of process used by AMC to schedule this air refueling event. Possible values are A (Matched Long Range), F (Matched AMC Short Notice), N (Unmatched Theater Operation Short Notice (Theater Assets)), R, Unmatched Long Range, S (Soft Air Refueling), T (Matched Theater Operation Short Notice (Theater Assets)), V (Unmatched AMC Short Notice), X (Unmatched Theater Operation Short Notice (AMC Assets)), Y (Matched Theater Operation Short Notice (AMC Assets)), Z (Other Air Refueling).
  ///  Example: /// Example: V
  ///  Constraints: Minimum length = 0, Maximum length = 2
  public var arEventType: String? { let o = _accessor.offset(VTOFFSET.arEventType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var arEventTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.arEventType.v) }
  ///  The number of tankers requested for an air refueling event.
  ///  Example: /// Example: 1
  ///  Constraints: No constraints specified.
  public var numTankers: Int32 { let o = _accessor.offset(VTOFFSET.numTankers.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Flag indicating if the receiver unit has requested flying an air refueling track in both directions.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var revTrack: Bool { let o = _accessor.offset(VTOFFSET.revTrack.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating that the receiver unit has requested flying a short portion of an air refueling track.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var shortTrack: Bool { let o = _accessor.offset(VTOFFSET.shortTrack.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating that this air refueling event has been cancelled.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var cancelled: Bool { let o = _accessor.offset(VTOFFSET.cancelled.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Collection of tanker aircraft associated with this Air Event.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasTankers: Bool { let o = _accessor.offset(VTOFFSET.tankers.v); return o == 0 ? false : true }
  public var tankersCount: Int32 { let o = _accessor.offset(VTOFFSET.tankers.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tankers(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tankers.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Collection of receiver aircraft associated with this Air Event.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasReceivers: Bool { let o = _accessor.offset(VTOFFSET.receivers.v); return o == 0 ? false : true }
  public var receiversCount: Int32 { let o = _accessor.offset(VTOFFSET.receivers.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func receivers(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.receivers.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Collection of remarks associated with this Air Event.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasRemarks: Bool { let o = _accessor.offset(VTOFFSET.remarks.v); return o == 0 ? false : true }
  public var remarksCount: Int32 { let o = _accessor.offset(VTOFFSET.remarks.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func remarks(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.remarks.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Time the row was updated in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var updatedAt: String? { let o = _accessor.offset(VTOFFSET.updatedAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedAt.v) }
  ///  Application user who updated the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var updatedBy: String? { let o = _accessor.offset(VTOFFSET.updatedBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedBy.v) }
  ///  The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  ///  Example: /// Example: AXE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var sourceDl: String? { let o = _accessor.offset(VTOFFSET.sourceDl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceDlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceDl.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: AirEvent_Ingest_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : AirEvent_Ingest_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  public static func startAirEvent_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 44) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func add(idSortie: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSortie, at: VTOFFSET.idSortie.p) }
  public static func add(idMission: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idMission, at: VTOFFSET.idMission.p) }
  public static func add(externalAirEventId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: externalAirEventId, at: VTOFFSET.externalAirEventId.p) }
  public static func add(legNum: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: legNum, def: 0, at: VTOFFSET.legNum.p) }
  public static func add(location: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: location, at: VTOFFSET.location.p) }
  public static func add(arrPurpose: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arrPurpose, at: VTOFFSET.arrPurpose.p) }
  public static func add(plannedArrTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: plannedArrTime, at: VTOFFSET.plannedArrTime.p) }
  public static func add(estArrTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: estArrTime, at: VTOFFSET.estArrTime.p) }
  public static func add(actualArrTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: actualArrTime, at: VTOFFSET.actualArrTime.p) }
  public static func add(depPurpose: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: depPurpose, at: VTOFFSET.depPurpose.p) }
  public static func add(plannedDepTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: plannedDepTime, at: VTOFFSET.plannedDepTime.p) }
  public static func add(estDepTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: estDepTime, at: VTOFFSET.estDepTime.p) }
  public static func add(actualDepTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: actualDepTime, at: VTOFFSET.actualDepTime.p) }
  public static func add(externalArtrackId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: externalArtrackId, at: VTOFFSET.externalArtrackId.p) }
  public static func add(arTrackId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arTrackId, at: VTOFFSET.arTrackId.p) }
  public static func add(arTrackName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arTrackName, at: VTOFFSET.arTrackName.p) }
  public static func add(rzct: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rzct, at: VTOFFSET.rzct.p) }
  public static func add(arct: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arct, at: VTOFFSET.arct.p) }
  public static func add(baseAlt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: baseAlt, def: 0.0, at: VTOFFSET.baseAlt.p) }
  public static func add(priority: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: priority, at: VTOFFSET.priority.p) }
  public static func add(trackTime: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trackTime, def: 0.0, at: VTOFFSET.trackTime.p) }
  public static func add(statusCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: statusCode, at: VTOFFSET.statusCode.p) }
  public static func add(rzPoint: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rzPoint, at: VTOFFSET.rzPoint.p) }
  public static func add(rzType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rzType, at: VTOFFSET.rzType.p) }
  public static func add(arEventType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arEventType, at: VTOFFSET.arEventType.p) }
  public static func add(numTankers: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numTankers, def: 0, at: VTOFFSET.numTankers.p) }
  public static func add(revTrack: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: revTrack, def: false,
   at: VTOFFSET.revTrack.p) }
  public static func add(shortTrack: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shortTrack, def: false,
   at: VTOFFSET.shortTrack.p) }
  public static func add(cancelled: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cancelled, def: false,
   at: VTOFFSET.cancelled.p) }
  public static func addVectorOf(tankers: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tankers, at: VTOFFSET.tankers.p) }
  public static func addVectorOf(receivers: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: receivers, at: VTOFFSET.receivers.p) }
  public static func addVectorOf(remarks: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: remarks, at: VTOFFSET.remarks.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(updatedAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedAt, at: VTOFFSET.updatedAt.p) }
  public static func add(updatedBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedBy, at: VTOFFSET.updatedBy.p) }
  public static func add(sourceDl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceDl, at: VTOFFSET.sourceDl.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: AirEvent_Ingest_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func endAirEvent_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAirEvent_Ingest(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    typeOffset type: Offset = Offset(),
    idSortieOffset idSortie: Offset = Offset(),
    idMissionOffset idMission: Offset = Offset(),
    externalAirEventIdOffset externalAirEventId: Offset = Offset(),
    legNum: Int32 = 0,
    locationOffset location: Offset = Offset(),
    arrPurposeOffset arrPurpose: Offset = Offset(),
    plannedArrTimeOffset plannedArrTime: Offset = Offset(),
    estArrTimeOffset estArrTime: Offset = Offset(),
    actualArrTimeOffset actualArrTime: Offset = Offset(),
    depPurposeOffset depPurpose: Offset = Offset(),
    plannedDepTimeOffset plannedDepTime: Offset = Offset(),
    estDepTimeOffset estDepTime: Offset = Offset(),
    actualDepTimeOffset actualDepTime: Offset = Offset(),
    externalArtrackIdOffset externalArtrackId: Offset = Offset(),
    arTrackIdOffset arTrackId: Offset = Offset(),
    arTrackNameOffset arTrackName: Offset = Offset(),
    rzctOffset rzct: Offset = Offset(),
    arctOffset arct: Offset = Offset(),
    baseAlt: Double = 0.0,
    priorityOffset priority: Offset = Offset(),
    trackTime: Double = 0.0,
    statusCodeOffset statusCode: Offset = Offset(),
    rzPointOffset rzPoint: Offset = Offset(),
    rzTypeOffset rzType: Offset = Offset(),
    arEventTypeOffset arEventType: Offset = Offset(),
    numTankers: Int32 = 0,
    revTrack: Bool = false,
    shortTrack: Bool = false,
    cancelled: Bool = false,
    tankersVectorOffset tankers: Offset = Offset(),
    receiversVectorOffset receivers: Offset = Offset(),
    remarksVectorOffset remarks: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    updatedAtOffset updatedAt: Offset = Offset(),
    updatedByOffset updatedBy: Offset = Offset(),
    sourceDlOffset sourceDl: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: AirEvent_Ingest_dataMode_Enum = .real
  ) -> Offset {
    let __start = AirEvent_Ingest.startAirEvent_Ingest(&fbb)
    AirEvent_Ingest.add(id: id, &fbb)
    AirEvent_Ingest.add(classificationMarking: classificationMarking, &fbb)
    AirEvent_Ingest.add(type: type, &fbb)
    AirEvent_Ingest.add(idSortie: idSortie, &fbb)
    AirEvent_Ingest.add(idMission: idMission, &fbb)
    AirEvent_Ingest.add(externalAirEventId: externalAirEventId, &fbb)
    AirEvent_Ingest.add(legNum: legNum, &fbb)
    AirEvent_Ingest.add(location: location, &fbb)
    AirEvent_Ingest.add(arrPurpose: arrPurpose, &fbb)
    AirEvent_Ingest.add(plannedArrTime: plannedArrTime, &fbb)
    AirEvent_Ingest.add(estArrTime: estArrTime, &fbb)
    AirEvent_Ingest.add(actualArrTime: actualArrTime, &fbb)
    AirEvent_Ingest.add(depPurpose: depPurpose, &fbb)
    AirEvent_Ingest.add(plannedDepTime: plannedDepTime, &fbb)
    AirEvent_Ingest.add(estDepTime: estDepTime, &fbb)
    AirEvent_Ingest.add(actualDepTime: actualDepTime, &fbb)
    AirEvent_Ingest.add(externalArtrackId: externalArtrackId, &fbb)
    AirEvent_Ingest.add(arTrackId: arTrackId, &fbb)
    AirEvent_Ingest.add(arTrackName: arTrackName, &fbb)
    AirEvent_Ingest.add(rzct: rzct, &fbb)
    AirEvent_Ingest.add(arct: arct, &fbb)
    AirEvent_Ingest.add(baseAlt: baseAlt, &fbb)
    AirEvent_Ingest.add(priority: priority, &fbb)
    AirEvent_Ingest.add(trackTime: trackTime, &fbb)
    AirEvent_Ingest.add(statusCode: statusCode, &fbb)
    AirEvent_Ingest.add(rzPoint: rzPoint, &fbb)
    AirEvent_Ingest.add(rzType: rzType, &fbb)
    AirEvent_Ingest.add(arEventType: arEventType, &fbb)
    AirEvent_Ingest.add(numTankers: numTankers, &fbb)
    AirEvent_Ingest.add(revTrack: revTrack, &fbb)
    AirEvent_Ingest.add(shortTrack: shortTrack, &fbb)
    AirEvent_Ingest.add(cancelled: cancelled, &fbb)
    AirEvent_Ingest.addVectorOf(tankers: tankers, &fbb)
    AirEvent_Ingest.addVectorOf(receivers: receivers, &fbb)
    AirEvent_Ingest.addVectorOf(remarks: remarks, &fbb)
    AirEvent_Ingest.add(createdAt: createdAt, &fbb)
    AirEvent_Ingest.add(createdBy: createdBy, &fbb)
    AirEvent_Ingest.add(updatedAt: updatedAt, &fbb)
    AirEvent_Ingest.add(updatedBy: updatedBy, &fbb)
    AirEvent_Ingest.add(sourceDl: sourceDl, &fbb)
    AirEvent_Ingest.add(source: source, &fbb)
    AirEvent_Ingest.add(origin: origin, &fbb)
    AirEvent_Ingest.add(origNetwork: origNetwork, &fbb)
    AirEvent_Ingest.add(dataMode: dataMode, &fbb)
    return AirEvent_Ingest.endAirEvent_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idSortie.p, fieldName: "idSortie", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idMission.p, fieldName: "idMission", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.externalAirEventId.p, fieldName: "externalAirEventId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.legNum.p, fieldName: "legNum", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.location.p, fieldName: "location", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.arrPurpose.p, fieldName: "arrPurpose", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.plannedArrTime.p, fieldName: "plannedArrTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.estArrTime.p, fieldName: "estArrTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.actualArrTime.p, fieldName: "actualArrTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.depPurpose.p, fieldName: "depPurpose", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.plannedDepTime.p, fieldName: "plannedDepTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.estDepTime.p, fieldName: "estDepTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.actualDepTime.p, fieldName: "actualDepTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.externalArtrackId.p, fieldName: "externalArtrackId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.arTrackId.p, fieldName: "arTrackId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.arTrackName.p, fieldName: "arTrackName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rzct.p, fieldName: "rzct", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.arct.p, fieldName: "arct", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.baseAlt.p, fieldName: "baseAlt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.priority.p, fieldName: "priority", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.trackTime.p, fieldName: "trackTime", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.statusCode.p, fieldName: "statusCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rzPoint.p, fieldName: "rzPoint", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rzType.p, fieldName: "rzType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.arEventType.p, fieldName: "arEventType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.numTankers.p, fieldName: "numTankers", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.revTrack.p, fieldName: "revTrack", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.shortTrack.p, fieldName: "shortTrack", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.cancelled.p, fieldName: "cancelled", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.tankers.p, fieldName: "tankers", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.receivers.p, fieldName: "receivers", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.remarks.p, fieldName: "remarks", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedAt.p, fieldName: "updatedAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedBy.p, fieldName: "updatedBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceDl.p, fieldName: "sourceDl", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: AirEvent_Ingest_dataMode_Enum.self)
    _v.finish()
  }
}

