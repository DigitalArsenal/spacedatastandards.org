// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Sensorcharacteristics_Full_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: Sensorcharacteristics_Full_dataMode_Enum { return .exercise }
  public static var min: Sensorcharacteristics_Full_dataMode_Enum { return .real }
}


///  /// Model representation of characteristics and capabilities of a sensor.
public struct Sensorcharacteristics_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "SENS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Sensorcharacteristics_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case idSensor = 6
    case classificationMarking = 8
    case origNetwork = 10
    case azimuthRate = 12
    case elevationRateGeolm = 14
    case minRangeLimit = 16
    case maxRangeLimit = 18
    case leftClockAngle = 20
    case rightClockAngle = 22
    case boresight = 24
    case boresightOffAngle = 26
    case negativeRangeRateLimit = 28
    case positiveRangeRateLimit = 30
    case magnitudeLimit = 32
    case trackAngle = 34
    case minSignalNoiseRatio = 36
    case fanBeamWidth = 38
    case taskableRange = 40
    case maxObservableRange = 42
    case radioFrequency = 44
    case radarFrequency = 46
    case transmitPower = 48
    case hFov = 50
    case vFov = 52
    case hResPixels = 54
    case vResPixels = 56
    case band = 58
    case maxDeviationAngle = 60
    case aperture = 62
    case leftGeoBeltLimit = 64
    case rightGeoBeltLimit = 66
    case asrScanRate = 68
    case k = 70
    case focalPoint = 72
    case towerHeight = 74
    case trueNorthCorrector = 76
    case magDec = 78
    case z1MinRange = 80
    case z2MinRange = 82
    case z1MaxRange = 84
    case z2MaxRange = 86
    case radarMur = 88
    case probFalseAlarm = 90
    case prf = 92
    case radarPulseWidth = 94
    case numIntegratedPulses = 96
    case trueTilt = 98
    case radarMessageFormat = 100
    case systemNoiseTemperature = 102
    case source = 104
    case dataMode = 106
    case createdAt = 108
    case createdBy = 110
    case updatedAt = 112
    case updatedBy = 114
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: SENSORCHARACTERISTICS-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Unique identifier of the parent sensor.
  ///  Example: /// Example: SENSOR-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var idSensor: String? { let o = _accessor.offset(VTOFFSET.idSensor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSensorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSensor.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Azimuth rate acquisition limit (rad/min).
  ///  Example: /// Example: 10.23
  ///  Constraints: No constraints specified.
  public var azimuthRate: Double { let o = _accessor.offset(VTOFFSET.azimuthRate.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Elevation rate acquisition limit (rad/min).
  ///  Example: /// Example: 10.23
  ///  Constraints: No constraints specified.
  public var elevationRateGeolm: Double { let o = _accessor.offset(VTOFFSET.elevationRateGeolm.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum range measurement capability of the sensor (km).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var minRangeLimit: Double { let o = _accessor.offset(VTOFFSET.minRangeLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum observable range limit (km) -- sensor cannot acquire beyond this range.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var maxRangeLimit: Double { let o = _accessor.offset(VTOFFSET.maxRangeLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For Orbiting Sensors, First Card Azimuth limit #1 (left, deg).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var leftClockAngle: Double { let o = _accessor.offset(VTOFFSET.leftClockAngle.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For Orbiting Sensors, First Card Azimuth limit #3 (left, deg).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var rightClockAngle: Double { let o = _accessor.offset(VTOFFSET.rightClockAngle.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The angle of the center of a phased array sensor.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var boresight: Double { let o = _accessor.offset(VTOFFSET.boresight.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The number of degrees off of the boresight for the sensor (degrees).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var boresightOffAngle: Double { let o = _accessor.offset(VTOFFSET.boresightOffAngle.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Negative Range-rate/relative velocity limit (km/sec).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var negativeRangeRateLimit: Double { let o = _accessor.offset(VTOFFSET.negativeRangeRateLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Positive Range-rate/relative velocity limit (km/sec).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var positiveRangeRateLimit: Double { let o = _accessor.offset(VTOFFSET.positiveRangeRateLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Absolute magnitude acquisition limit for optical sensors.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var magnitudeLimit: Double { let o = _accessor.offset(VTOFFSET.magnitudeLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Beginning track angle limit (rad). Track angle is the angle between the camera axis and the gimbal plane. Values range from 0 - PI/2.
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var trackAngle: Double { let o = _accessor.offset(VTOFFSET.trackAngle.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Signal to Noise Ratio (in db). The values for this range from 0.0 - + 99.99 dB.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var minSignalNoiseRatio: Double { let o = _accessor.offset(VTOFFSET.minSignalNoiseRatio.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The beam width of a Sensor's Fan (range). The values for this range from (0.0 to PI).
  ///  Example: /// Example: 3.1
  ///  Constraints: No constraints specified.
  public var fanBeamWidth: Double { let o = _accessor.offset(VTOFFSET.fanBeamWidth.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum taskable range of the sensor (km).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var taskableRange: Double { let o = _accessor.offset(VTOFFSET.taskableRange.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum observable sensor range (km).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var maxObservableRange: Double { let o = _accessor.offset(VTOFFSET.maxObservableRange.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Radio frequency (if sensor is RF).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var radioFrequency: Double { let o = _accessor.offset(VTOFFSET.radioFrequency.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Radar frequency of the sensor (if a radar sensor).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var radarFrequency: Double { let o = _accessor.offset(VTOFFSET.radarFrequency.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Radar transmit power in Watts.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var transmitPower: Double { let o = _accessor.offset(VTOFFSET.transmitPower.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Horizontal field of view.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var hFov: Double { let o = _accessor.offset(VTOFFSET.hFov.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Vertical field of view.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var vFov: Double { let o = _accessor.offset(VTOFFSET.vFov.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Horizontal pixel resolution.
  ///  Example: /// Example: 1000
  ///  Constraints: No constraints specified.
  public var hResPixels: Int32 { let o = _accessor.offset(VTOFFSET.hResPixels.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Vertical pixel resolution.
  ///  Example: /// Example: 1000
  ///  Constraints: No constraints specified.
  public var vResPixels: Int32 { let o = _accessor.offset(VTOFFSET.vResPixels.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Sensor band.
  ///  Example: /// Example: BAND
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var band: String? { let o = _accessor.offset(VTOFFSET.band.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var bandSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.band.v) }
  ///  Max deviation angle of the sensor in degrees.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var maxDeviationAngle: Double { let o = _accessor.offset(VTOFFSET.maxDeviationAngle.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Optical sensor camera aperture.
  ///  Example: /// Example: 2.23
  ///  Constraints: No constraints specified.
  public var aperture: Double { let o = _accessor.offset(VTOFFSET.aperture.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Leftmost GEO belt longitude limit for this sensor (if applicable).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var leftGeoBeltLimit: Double { let o = _accessor.offset(VTOFFSET.leftGeoBeltLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Rightmost GEO belt longitude limit for this sensor (if applicable).
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var rightGeoBeltLimit: Double { let o = _accessor.offset(VTOFFSET.rightGeoBeltLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For ASR (Air Surveillance Radar) sensors, the scan (360 deg sweep) rate of the radar, in scans/minute.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var asrScanRate: Double { let o = _accessor.offset(VTOFFSET.asrScanRate.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For radar based sensors, K-factor is a relative indicator of refractivity that infers the amount of radar beam bending due to atmosphere. (1<K<2).
  ///  Example: /// Example: 1.4
  ///  Constraints: No constraints specified.
  public var k: Double { let o = _accessor.offset(VTOFFSET.k.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For radar based sensors, the focal point elevation of the radar at the site, in meters.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var focalPoint: Double { let o = _accessor.offset(VTOFFSET.focalPoint.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For tower sensors, the physical height of the sensor tower, in meters.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var towerHeight: Double { let o = _accessor.offset(VTOFFSET.towerHeight.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  True North correction for the sensor, in ACP (Azimunth Change Pulse) count.
  ///  Example: /// Example: 10
  ///  Constraints: No constraints specified.
  public var trueNorthCorrector: Int32 { let o = _accessor.offset(VTOFFSET.trueNorthCorrector.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Angle between magnetic north and true north at the sensor site, in degrees.
  ///  Example: /// Example: 45.23
  ///  Constraints: No constraints specified.
  public var magDec: Double { let o = _accessor.offset(VTOFFSET.magDec.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Peformance zone-1 minimum range, in km. Note that the zones apply only to the PSR/Search radars.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var z1MinRange: Double { let o = _accessor.offset(VTOFFSET.z1MinRange.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Peformance zone-2 minimum range, in km. Note that the zones apply only to the PSR/Search radars.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var z2MinRange: Double { let o = _accessor.offset(VTOFFSET.z2MinRange.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Peformance zone-1 maximum range, in km. Note that the zones apply only to the PSR/Search radars.
  ///  Example: /// Example: 50.23
  ///  Constraints: No constraints specified.
  public var z1MaxRange: Double { let o = _accessor.offset(VTOFFSET.z1MaxRange.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Peformance zone-2 maximum range, in km. Note that the zones apply only to the PSR/Search radars.
  ///  Example: /// Example: 50.23
  ///  Constraints: No constraints specified.
  public var z2MaxRange: Double { let o = _accessor.offset(VTOFFSET.z2MaxRange.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For radar based sensors, radar maximum unambiguous range, in km.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var radarMur: Double { let o = _accessor.offset(VTOFFSET.radarMur.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For radar based sensors, probability of the indication of the presence of a radar target due to noise or interference.
  ///  Example: /// Example: 0.5
  ///  Constraints: No constraints specified.
  public var probFalseAlarm: Double { let o = _accessor.offset(VTOFFSET.probFalseAlarm.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For radar based sensors, pulse repetition frequency, in Hz. Number of new pulses tranmistted per second.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var prf: Double { let o = _accessor.offset(VTOFFSET.prf.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For radar based sensors, radar pulse width, in microseconds. The transmit time of a pulse.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var radarPulseWidth: Double { let o = _accessor.offset(VTOFFSET.radarPulseWidth.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For radar based sensors, number of integrated pulses in a transmit cycle.
  ///  Example: /// Example: 10
  ///  Constraints: No constraints specified.
  public var numIntegratedPulses: Int32 { let o = _accessor.offset(VTOFFSET.numIntegratedPulses.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Antenna true tilt, in degrees.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var trueTilt: Double { let o = _accessor.offset(VTOFFSET.trueTilt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Message data format transmitted by the sensor digitizer.
  ///  Example: /// Example: DATA_FORMAT
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var radarMessageFormat: String? { let o = _accessor.offset(VTOFFSET.radarMessageFormat.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var radarMessageFormatSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.radarMessageFormat.v) }
  ///  For radar based sensors, expression of the radar system noise, aggregated as an equivalent thermal noise value, in degrees Kelvin.
  ///  Example: /// Example: 3.5
  ///  Constraints: No constraints specified.
  public var systemNoiseTemperature: Double { let o = _accessor.offset(VTOFFSET.systemNoiseTemperature.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: Sensorcharacteristics_Full_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : Sensorcharacteristics_Full_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Time the row was last updated in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var updatedAt: String? { let o = _accessor.offset(VTOFFSET.updatedAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedAt.v) }
  ///  Application user who updated the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var updatedBy: String? { let o = _accessor.offset(VTOFFSET.updatedBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedBy.v) }
  public static func startSensorcharacteristics_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 56) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(idSensor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSensor, at: VTOFFSET.idSensor.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(azimuthRate: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: azimuthRate, def: 0.0, at: VTOFFSET.azimuthRate.p) }
  public static func add(elevationRateGeolm: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: elevationRateGeolm, def: 0.0, at: VTOFFSET.elevationRateGeolm.p) }
  public static func add(minRangeLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: minRangeLimit, def: 0.0, at: VTOFFSET.minRangeLimit.p) }
  public static func add(maxRangeLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maxRangeLimit, def: 0.0, at: VTOFFSET.maxRangeLimit.p) }
  public static func add(leftClockAngle: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: leftClockAngle, def: 0.0, at: VTOFFSET.leftClockAngle.p) }
  public static func add(rightClockAngle: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: rightClockAngle, def: 0.0, at: VTOFFSET.rightClockAngle.p) }
  public static func add(boresight: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: boresight, def: 0.0, at: VTOFFSET.boresight.p) }
  public static func add(boresightOffAngle: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: boresightOffAngle, def: 0.0, at: VTOFFSET.boresightOffAngle.p) }
  public static func add(negativeRangeRateLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: negativeRangeRateLimit, def: 0.0, at: VTOFFSET.negativeRangeRateLimit.p) }
  public static func add(positiveRangeRateLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: positiveRangeRateLimit, def: 0.0, at: VTOFFSET.positiveRangeRateLimit.p) }
  public static func add(magnitudeLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: magnitudeLimit, def: 0.0, at: VTOFFSET.magnitudeLimit.p) }
  public static func add(trackAngle: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trackAngle, def: 0.0, at: VTOFFSET.trackAngle.p) }
  public static func add(minSignalNoiseRatio: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: minSignalNoiseRatio, def: 0.0, at: VTOFFSET.minSignalNoiseRatio.p) }
  public static func add(fanBeamWidth: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fanBeamWidth, def: 0.0, at: VTOFFSET.fanBeamWidth.p) }
  public static func add(taskableRange: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: taskableRange, def: 0.0, at: VTOFFSET.taskableRange.p) }
  public static func add(maxObservableRange: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maxObservableRange, def: 0.0, at: VTOFFSET.maxObservableRange.p) }
  public static func add(radioFrequency: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radioFrequency, def: 0.0, at: VTOFFSET.radioFrequency.p) }
  public static func add(radarFrequency: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radarFrequency, def: 0.0, at: VTOFFSET.radarFrequency.p) }
  public static func add(transmitPower: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: transmitPower, def: 0.0, at: VTOFFSET.transmitPower.p) }
  public static func add(hFov: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hFov, def: 0.0, at: VTOFFSET.hFov.p) }
  public static func add(vFov: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: vFov, def: 0.0, at: VTOFFSET.vFov.p) }
  public static func add(hResPixels: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hResPixels, def: 0, at: VTOFFSET.hResPixels.p) }
  public static func add(vResPixels: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: vResPixels, def: 0, at: VTOFFSET.vResPixels.p) }
  public static func add(band: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: band, at: VTOFFSET.band.p) }
  public static func add(maxDeviationAngle: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maxDeviationAngle, def: 0.0, at: VTOFFSET.maxDeviationAngle.p) }
  public static func add(aperture: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: aperture, def: 0.0, at: VTOFFSET.aperture.p) }
  public static func add(leftGeoBeltLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: leftGeoBeltLimit, def: 0.0, at: VTOFFSET.leftGeoBeltLimit.p) }
  public static func add(rightGeoBeltLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: rightGeoBeltLimit, def: 0.0, at: VTOFFSET.rightGeoBeltLimit.p) }
  public static func add(asrScanRate: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asrScanRate, def: 0.0, at: VTOFFSET.asrScanRate.p) }
  public static func add(k: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: k, def: 0.0, at: VTOFFSET.k.p) }
  public static func add(focalPoint: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: focalPoint, def: 0.0, at: VTOFFSET.focalPoint.p) }
  public static func add(towerHeight: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: towerHeight, def: 0.0, at: VTOFFSET.towerHeight.p) }
  public static func add(trueNorthCorrector: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trueNorthCorrector, def: 0, at: VTOFFSET.trueNorthCorrector.p) }
  public static func add(magDec: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: magDec, def: 0.0, at: VTOFFSET.magDec.p) }
  public static func add(z1MinRange: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: z1MinRange, def: 0.0, at: VTOFFSET.z1MinRange.p) }
  public static func add(z2MinRange: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: z2MinRange, def: 0.0, at: VTOFFSET.z2MinRange.p) }
  public static func add(z1MaxRange: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: z1MaxRange, def: 0.0, at: VTOFFSET.z1MaxRange.p) }
  public static func add(z2MaxRange: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: z2MaxRange, def: 0.0, at: VTOFFSET.z2MaxRange.p) }
  public static func add(radarMur: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radarMur, def: 0.0, at: VTOFFSET.radarMur.p) }
  public static func add(probFalseAlarm: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: probFalseAlarm, def: 0.0, at: VTOFFSET.probFalseAlarm.p) }
  public static func add(prf: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: prf, def: 0.0, at: VTOFFSET.prf.p) }
  public static func add(radarPulseWidth: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radarPulseWidth, def: 0.0, at: VTOFFSET.radarPulseWidth.p) }
  public static func add(numIntegratedPulses: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numIntegratedPulses, def: 0, at: VTOFFSET.numIntegratedPulses.p) }
  public static func add(trueTilt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trueTilt, def: 0.0, at: VTOFFSET.trueTilt.p) }
  public static func add(radarMessageFormat: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: radarMessageFormat, at: VTOFFSET.radarMessageFormat.p) }
  public static func add(systemNoiseTemperature: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: systemNoiseTemperature, def: 0.0, at: VTOFFSET.systemNoiseTemperature.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(dataMode: Sensorcharacteristics_Full_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(updatedAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedAt, at: VTOFFSET.updatedAt.p) }
  public static func add(updatedBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedBy, at: VTOFFSET.updatedBy.p) }
  public static func endSensorcharacteristics_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSensorcharacteristics_Full(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    idSensorOffset idSensor: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    azimuthRate: Double = 0.0,
    elevationRateGeolm: Double = 0.0,
    minRangeLimit: Double = 0.0,
    maxRangeLimit: Double = 0.0,
    leftClockAngle: Double = 0.0,
    rightClockAngle: Double = 0.0,
    boresight: Double = 0.0,
    boresightOffAngle: Double = 0.0,
    negativeRangeRateLimit: Double = 0.0,
    positiveRangeRateLimit: Double = 0.0,
    magnitudeLimit: Double = 0.0,
    trackAngle: Double = 0.0,
    minSignalNoiseRatio: Double = 0.0,
    fanBeamWidth: Double = 0.0,
    taskableRange: Double = 0.0,
    maxObservableRange: Double = 0.0,
    radioFrequency: Double = 0.0,
    radarFrequency: Double = 0.0,
    transmitPower: Double = 0.0,
    hFov: Double = 0.0,
    vFov: Double = 0.0,
    hResPixels: Int32 = 0,
    vResPixels: Int32 = 0,
    bandOffset band: Offset = Offset(),
    maxDeviationAngle: Double = 0.0,
    aperture: Double = 0.0,
    leftGeoBeltLimit: Double = 0.0,
    rightGeoBeltLimit: Double = 0.0,
    asrScanRate: Double = 0.0,
    k: Double = 0.0,
    focalPoint: Double = 0.0,
    towerHeight: Double = 0.0,
    trueNorthCorrector: Int32 = 0,
    magDec: Double = 0.0,
    z1MinRange: Double = 0.0,
    z2MinRange: Double = 0.0,
    z1MaxRange: Double = 0.0,
    z2MaxRange: Double = 0.0,
    radarMur: Double = 0.0,
    probFalseAlarm: Double = 0.0,
    prf: Double = 0.0,
    radarPulseWidth: Double = 0.0,
    numIntegratedPulses: Int32 = 0,
    trueTilt: Double = 0.0,
    radarMessageFormatOffset radarMessageFormat: Offset = Offset(),
    systemNoiseTemperature: Double = 0.0,
    sourceOffset source: Offset = Offset(),
    dataMode: Sensorcharacteristics_Full_dataMode_Enum = .real,
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    updatedAtOffset updatedAt: Offset = Offset(),
    updatedByOffset updatedBy: Offset = Offset()
  ) -> Offset {
    let __start = Sensorcharacteristics_Full.startSensorcharacteristics_Full(&fbb)
    Sensorcharacteristics_Full.add(id: id, &fbb)
    Sensorcharacteristics_Full.add(idSensor: idSensor, &fbb)
    Sensorcharacteristics_Full.add(classificationMarking: classificationMarking, &fbb)
    Sensorcharacteristics_Full.add(origNetwork: origNetwork, &fbb)
    Sensorcharacteristics_Full.add(azimuthRate: azimuthRate, &fbb)
    Sensorcharacteristics_Full.add(elevationRateGeolm: elevationRateGeolm, &fbb)
    Sensorcharacteristics_Full.add(minRangeLimit: minRangeLimit, &fbb)
    Sensorcharacteristics_Full.add(maxRangeLimit: maxRangeLimit, &fbb)
    Sensorcharacteristics_Full.add(leftClockAngle: leftClockAngle, &fbb)
    Sensorcharacteristics_Full.add(rightClockAngle: rightClockAngle, &fbb)
    Sensorcharacteristics_Full.add(boresight: boresight, &fbb)
    Sensorcharacteristics_Full.add(boresightOffAngle: boresightOffAngle, &fbb)
    Sensorcharacteristics_Full.add(negativeRangeRateLimit: negativeRangeRateLimit, &fbb)
    Sensorcharacteristics_Full.add(positiveRangeRateLimit: positiveRangeRateLimit, &fbb)
    Sensorcharacteristics_Full.add(magnitudeLimit: magnitudeLimit, &fbb)
    Sensorcharacteristics_Full.add(trackAngle: trackAngle, &fbb)
    Sensorcharacteristics_Full.add(minSignalNoiseRatio: minSignalNoiseRatio, &fbb)
    Sensorcharacteristics_Full.add(fanBeamWidth: fanBeamWidth, &fbb)
    Sensorcharacteristics_Full.add(taskableRange: taskableRange, &fbb)
    Sensorcharacteristics_Full.add(maxObservableRange: maxObservableRange, &fbb)
    Sensorcharacteristics_Full.add(radioFrequency: radioFrequency, &fbb)
    Sensorcharacteristics_Full.add(radarFrequency: radarFrequency, &fbb)
    Sensorcharacteristics_Full.add(transmitPower: transmitPower, &fbb)
    Sensorcharacteristics_Full.add(hFov: hFov, &fbb)
    Sensorcharacteristics_Full.add(vFov: vFov, &fbb)
    Sensorcharacteristics_Full.add(hResPixels: hResPixels, &fbb)
    Sensorcharacteristics_Full.add(vResPixels: vResPixels, &fbb)
    Sensorcharacteristics_Full.add(band: band, &fbb)
    Sensorcharacteristics_Full.add(maxDeviationAngle: maxDeviationAngle, &fbb)
    Sensorcharacteristics_Full.add(aperture: aperture, &fbb)
    Sensorcharacteristics_Full.add(leftGeoBeltLimit: leftGeoBeltLimit, &fbb)
    Sensorcharacteristics_Full.add(rightGeoBeltLimit: rightGeoBeltLimit, &fbb)
    Sensorcharacteristics_Full.add(asrScanRate: asrScanRate, &fbb)
    Sensorcharacteristics_Full.add(k: k, &fbb)
    Sensorcharacteristics_Full.add(focalPoint: focalPoint, &fbb)
    Sensorcharacteristics_Full.add(towerHeight: towerHeight, &fbb)
    Sensorcharacteristics_Full.add(trueNorthCorrector: trueNorthCorrector, &fbb)
    Sensorcharacteristics_Full.add(magDec: magDec, &fbb)
    Sensorcharacteristics_Full.add(z1MinRange: z1MinRange, &fbb)
    Sensorcharacteristics_Full.add(z2MinRange: z2MinRange, &fbb)
    Sensorcharacteristics_Full.add(z1MaxRange: z1MaxRange, &fbb)
    Sensorcharacteristics_Full.add(z2MaxRange: z2MaxRange, &fbb)
    Sensorcharacteristics_Full.add(radarMur: radarMur, &fbb)
    Sensorcharacteristics_Full.add(probFalseAlarm: probFalseAlarm, &fbb)
    Sensorcharacteristics_Full.add(prf: prf, &fbb)
    Sensorcharacteristics_Full.add(radarPulseWidth: radarPulseWidth, &fbb)
    Sensorcharacteristics_Full.add(numIntegratedPulses: numIntegratedPulses, &fbb)
    Sensorcharacteristics_Full.add(trueTilt: trueTilt, &fbb)
    Sensorcharacteristics_Full.add(radarMessageFormat: radarMessageFormat, &fbb)
    Sensorcharacteristics_Full.add(systemNoiseTemperature: systemNoiseTemperature, &fbb)
    Sensorcharacteristics_Full.add(source: source, &fbb)
    Sensorcharacteristics_Full.add(dataMode: dataMode, &fbb)
    Sensorcharacteristics_Full.add(createdAt: createdAt, &fbb)
    Sensorcharacteristics_Full.add(createdBy: createdBy, &fbb)
    Sensorcharacteristics_Full.add(updatedAt: updatedAt, &fbb)
    Sensorcharacteristics_Full.add(updatedBy: updatedBy, &fbb)
    return Sensorcharacteristics_Full.endSensorcharacteristics_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idSensor.p, fieldName: "idSensor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.azimuthRate.p, fieldName: "azimuthRate", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.elevationRateGeolm.p, fieldName: "elevationRateGeolm", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.minRangeLimit.p, fieldName: "minRangeLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.maxRangeLimit.p, fieldName: "maxRangeLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.leftClockAngle.p, fieldName: "leftClockAngle", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.rightClockAngle.p, fieldName: "rightClockAngle", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.boresight.p, fieldName: "boresight", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.boresightOffAngle.p, fieldName: "boresightOffAngle", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.negativeRangeRateLimit.p, fieldName: "negativeRangeRateLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.positiveRangeRateLimit.p, fieldName: "positiveRangeRateLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.magnitudeLimit.p, fieldName: "magnitudeLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.trackAngle.p, fieldName: "trackAngle", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.minSignalNoiseRatio.p, fieldName: "minSignalNoiseRatio", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fanBeamWidth.p, fieldName: "fanBeamWidth", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.taskableRange.p, fieldName: "taskableRange", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.maxObservableRange.p, fieldName: "maxObservableRange", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.radioFrequency.p, fieldName: "radioFrequency", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.radarFrequency.p, fieldName: "radarFrequency", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.transmitPower.p, fieldName: "transmitPower", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hFov.p, fieldName: "hFov", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.vFov.p, fieldName: "vFov", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hResPixels.p, fieldName: "hResPixels", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.vResPixels.p, fieldName: "vResPixels", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.band.p, fieldName: "band", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.maxDeviationAngle.p, fieldName: "maxDeviationAngle", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.aperture.p, fieldName: "aperture", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.leftGeoBeltLimit.p, fieldName: "leftGeoBeltLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.rightGeoBeltLimit.p, fieldName: "rightGeoBeltLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.asrScanRate.p, fieldName: "asrScanRate", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.k.p, fieldName: "k", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.focalPoint.p, fieldName: "focalPoint", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.towerHeight.p, fieldName: "towerHeight", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.trueNorthCorrector.p, fieldName: "trueNorthCorrector", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.magDec.p, fieldName: "magDec", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.z1MinRange.p, fieldName: "z1MinRange", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.z2MinRange.p, fieldName: "z2MinRange", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.z1MaxRange.p, fieldName: "z1MaxRange", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.z2MaxRange.p, fieldName: "z2MaxRange", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.radarMur.p, fieldName: "radarMur", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.probFalseAlarm.p, fieldName: "probFalseAlarm", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.prf.p, fieldName: "prf", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.radarPulseWidth.p, fieldName: "radarPulseWidth", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.numIntegratedPulses.p, fieldName: "numIntegratedPulses", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.trueTilt.p, fieldName: "trueTilt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.radarMessageFormat.p, fieldName: "radarMessageFormat", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.systemNoiseTemperature.p, fieldName: "systemNoiseTemperature", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: Sensorcharacteristics_Full_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedAt.p, fieldName: "updatedAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedBy.p, fieldName: "updatedBy", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

