// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum AirspaceControlMeans_Abridged_cmShape_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case polyarc = 0
  ///  No description available.
  case e1track = 1
  ///  No description available.
  case polygon = 2
  ///  No description available.
  case circle = 3
  ///  No description available.
  case corridor = 4
  ///  No description available.
  case apoint = 5
  ///  No description available.
  case aorbit = 6
  ///  No description available.
  case geoline = 7

  public static var max: AirspaceControlMeans_Abridged_cmShape_Enum { return .geoline }
  public static var min: AirspaceControlMeans_Abridged_cmShape_Enum { return .polyarc }
}


///  /// A conditional nested segment to report multiple airspace control means within a particular airspace control means status.
public struct AirspaceControlMeans_Abridged: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "AIRS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AirspaceControlMeans_Abridged.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case cmType = 4
    case cmId = 6
    case cmShape = 8
    case usage = 10
    case link16Id = 12
    case transAltitude = 14
    case geoDatumAlt = 16
    case coord0 = 18
    case coord1 = 20
    case bearing0 = 22
    case bearing1 = 24
    case radMag0 = 26
    case radMag1 = 28
    case radMagUnit = 30
    case polyCoord = 32
    case trackLeg = 34
    case widthLeft = 36
    case widthRight = 38
    case width = 40
    case widthUnit = 42
    case corrWayPoints = 44
    case orbitAlignment = 46
    case effVdim = 48
    case airspaceTimePeriod = 50
    case airspaceControlPoint = 52
    case ctrlAuth = 54
    case ctrlAuthFreqs = 56
    case genTextInd = 58
    case freeText = 60
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The code for the type of airspace control means.
  ///  Example: /// Example: ACM:ADAREA
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var cmType: String? { let o = _accessor.offset(VTOFFSET.cmType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var cmTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.cmType.v) }
  ///  Airspace control means name or designator.
  ///  Example: /// Example: DESIG:C34
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var cmId: String? { let o = _accessor.offset(VTOFFSET.cmId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var cmIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.cmId.v) }
  ///  Designates the geometric type that defines the airspace shape. One of CIRCLE, CORRIDOR, LINE, ORBIT, etc.
  ///  Example: /// Example: POLYARC
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var cmShape: AirspaceControlMeans_Abridged_cmShape_Enum { let o = _accessor.offset(VTOFFSET.cmShape.v); return o == 0 ? .polyarc : AirspaceControlMeans_Abridged_cmShape_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .polyarc }
  ///  Designates the means by which a defined airspace control means is to be used.
  ///  Example: /// Example: USE:AIRCOR
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var usage: String? { let o = _accessor.offset(VTOFFSET.usage.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var usageSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.usage.v) }
  ///  Unique Link 16 identifier assigned to the airspace control means.
  ///  Example: /// Example: F3356
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var link16Id: String? { let o = _accessor.offset(VTOFFSET.link16Id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var link16IdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.link16Id.v) }
  ///  The altitude at or below which the vertical position of an aircraft is controlled by reference to true altitude.
  ///  Example: /// Example: 18000FT
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var transAltitude: String? { let o = _accessor.offset(VTOFFSET.transAltitude.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var transAltitudeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.transAltitude.v) }
  ///  Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated, if different from the top level ACO datum.
  ///  Example: /// Example: NAR
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var geoDatumAlt: String? { let o = _accessor.offset(VTOFFSET.geoDatumAlt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var geoDatumAltSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.geoDatumAlt.v) }
  ///  A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
  ///  Example: /// Example: 152345N0505657E
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var coord0: String? { let o = _accessor.offset(VTOFFSET.coord0.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var coord0SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.coord0.v) }
  ///  A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
  ///  Example: /// Example: 1523N05057E
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var coord1: String? { let o = _accessor.offset(VTOFFSET.coord1.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var coord1SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.coord1.v) }
  ///  A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "beginning" radial bearing parameter.
  ///  Example: /// Example: 330
  ///  Constraints: No constraints specified.
  public var bearing0: Double { let o = _accessor.offset(VTOFFSET.bearing0.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "ending" radial bearing parameter.
  ///  Example: /// Example: 160
  ///  Constraints: No constraints specified.
  public var bearing1: Double { let o = _accessor.offset(VTOFFSET.bearing1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "inner" radial magnitude arc limit. If provided, the field radMagUnit is required.
  ///  Example: /// Example: 30.04
  ///  Constraints: No constraints specified.
  public var radMag0: Double { let o = _accessor.offset(VTOFFSET.radMag0.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "outer" radial magnitude arc limit. If provided, the field radMagUnit is required.
  ///  Example: /// Example: 50.12
  ///  Constraints: No constraints specified.
  public var radMag1: Double { let o = _accessor.offset(VTOFFSET.radMag1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Specifies the unit of length in which radial magnitudes are given. Use M for meters, KM for kilometers, or NM for nautical miles.
  ///  Example: /// Example: NM
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var radMagUnit: String? { let o = _accessor.offset(VTOFFSET.radMagUnit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var radMagUnitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.radMagUnit.v) }
  ///  A set of geospatial coordinates specified in DMS (Degrees, Minutes, Seconds) format which determine the vertices of a one or two dimensional geospatial shape. When shape is set to "POLYARC" or "POLYGON," this field is required as applied in the construction of the area boundary. If cmShape is set to "COORIDOR" or "GEOLINE," this field is required and can be interpreted as an ordered set of points along a path in space.
  ///  Example: /// Example: ['203632N0594256E', '155000N0594815E', '155000N0591343E']
  ///  Constraints: No constraints specified.
  public var hasPolyCoord: Bool { let o = _accessor.offset(VTOFFSET.polyCoord.v); return o == 0 ? false : true }
  public var polyCoordCount: Int32 { let o = _accessor.offset(VTOFFSET.polyCoord.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func polyCoord(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.polyCoord.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Index of a segment in an airtrack, which is defined by an ordered set of points.
  ///  Example: /// Example: 99
  ///  Constraints: No constraints specified.
  public var trackLeg: Int32 { let o = _accessor.offset(VTOFFSET.trackLeg.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the LEFT half-plane realtive to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the left of the track segment line. If provided, the field widthUnit is required.
  ///  Example: /// Example: 5.2
  ///  Constraints: No constraints specified.
  public var widthLeft: Double { let o = _accessor.offset(VTOFFSET.widthLeft.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the RIGHT half-plane relative to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the right of the track segment line. If provided, the field widthUnit is required.
  ///  Example: /// Example: 10.4
  ///  Constraints: No constraints specified.
  public var widthRight: Double { let o = _accessor.offset(VTOFFSET.widthRight.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Used to describe the "side to side" distance of a target, object or area. If cmShape is set to "CORRIDOR" or "AORBIT", this field is required and is mapped to the width parameter. If provided, the field widthUnit is required.
  ///  Example: /// Example: 15.6
  ///  Constraints: No constraints specified.
  public var width: Double { let o = _accessor.offset(VTOFFSET.width.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Specifies the unit of length for which widths are given. Use M for meters, KM for kilometers, or NM for nautical miles.
  ///  Example: /// Example: KM
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var widthUnit: String? { let o = _accessor.offset(VTOFFSET.widthUnit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var widthUnitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.widthUnit.v) }
  ///  An array of at least two alphanumeric symbols used to serially identify the corridor waypoints. If cmShape is set to "CORRIDOR," one of either corrWayPoints or polyCoord is required to specify the centerline of the corridor path.
  ///  Example: /// Example: ['POB', 'RDU', 'IAD']
  ///  Constraints: No constraints specified.
  public var hasCorrWayPoints: Bool { let o = _accessor.offset(VTOFFSET.corrWayPoints.v); return o == 0 ? false : true }
  public var corrWayPointsCount: Int32 { let o = _accessor.offset(VTOFFSET.corrWayPoints.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func corrWayPoints(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.corrWayPoints.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Orbit alignment look-up code. Can be C=Center, L=Left, R=Right.
  ///  Example: /// Example: C
  ///  Constraints: Minimum length = 0, Maximum length = 1
  public var orbitAlignment: String? { let o = _accessor.offset(VTOFFSET.orbitAlignment.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var orbitAlignmentSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.orbitAlignment.v) }
  ///  Description of the airspace vertical dimension.
  ///  Example: /// Example: BRRA:GL-100AGL
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var effVdim: String? { let o = _accessor.offset(VTOFFSET.effVdim.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var effVdimSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.effVdim.v) }
  ///  The timePeriod set describes the effective datetime for a given airspace control means.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasAirspaceTimePeriod: Bool { let o = _accessor.offset(VTOFFSET.airspaceTimePeriod.v); return o == 0 ? false : true }
  public var airspaceTimePeriodCount: Int32 { let o = _accessor.offset(VTOFFSET.airspaceTimePeriod.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func airspaceTimePeriod(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.airspaceTimePeriod.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The controlPoint set describes any reference/controlling/rendevous point for a given airspace control means.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasAirspaceControlPoint: Bool { let o = _accessor.offset(VTOFFSET.airspaceControlPoint.v); return o == 0 ? false : true }
  public var airspaceControlPointCount: Int32 { let o = _accessor.offset(VTOFFSET.airspaceControlPoint.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func airspaceControlPoint(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.airspaceControlPoint.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The commander responsible within a specified geographical area for the airspace control operation assigned to him.
  ///  Example: /// Example: RHEIN MAIN CP
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var ctrlAuth: String? { let o = _accessor.offset(VTOFFSET.ctrlAuth.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ctrlAuthSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ctrlAuth.v) }
  ///  The frequency for the airspace control authority. Can specify HZ, KHZ, MHZ, GHZ or a DESIG frequency designator code.
  ///  Example: /// Example: ['125.25MHZ']
  ///  Constraints: No constraints specified.
  public var hasCtrlAuthFreqs: Bool { let o = _accessor.offset(VTOFFSET.ctrlAuthFreqs.v); return o == 0 ? false : true }
  public var ctrlAuthFreqsCount: Int32 { let o = _accessor.offset(VTOFFSET.ctrlAuthFreqs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ctrlAuthFreqs(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.ctrlAuthFreqs.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Used to provide transit intstructions for the airspace control means.
  ///  Example: /// Example: SITUATION
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var genTextInd: String? { let o = _accessor.offset(VTOFFSET.genTextInd.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var genTextIndSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.genTextInd.v) }
  ///  General informat detailing the transit instruction for the airspace control means.
  ///  Example: /// Example: 1. CAPACITY: MDM TK, 50 VEHICLE CONVOY. 2. CHOKE POINTS: EXIT 5
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var freeText: String? { let o = _accessor.offset(VTOFFSET.freeText.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var freeTextSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.freeText.v) }
  public static func startAirspaceControlMeans_Abridged(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 29) }
  public static func add(cmType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: cmType, at: VTOFFSET.cmType.p) }
  public static func add(cmId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: cmId, at: VTOFFSET.cmId.p) }
  public static func add(cmShape: AirspaceControlMeans_Abridged_cmShape_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cmShape.rawValue, def: 0, at: VTOFFSET.cmShape.p) }
  public static func add(usage: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: usage, at: VTOFFSET.usage.p) }
  public static func add(link16Id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: link16Id, at: VTOFFSET.link16Id.p) }
  public static func add(transAltitude: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: transAltitude, at: VTOFFSET.transAltitude.p) }
  public static func add(geoDatumAlt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: geoDatumAlt, at: VTOFFSET.geoDatumAlt.p) }
  public static func add(coord0: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: coord0, at: VTOFFSET.coord0.p) }
  public static func add(coord1: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: coord1, at: VTOFFSET.coord1.p) }
  public static func add(bearing0: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bearing0, def: 0.0, at: VTOFFSET.bearing0.p) }
  public static func add(bearing1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bearing1, def: 0.0, at: VTOFFSET.bearing1.p) }
  public static func add(radMag0: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radMag0, def: 0.0, at: VTOFFSET.radMag0.p) }
  public static func add(radMag1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radMag1, def: 0.0, at: VTOFFSET.radMag1.p) }
  public static func add(radMagUnit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: radMagUnit, at: VTOFFSET.radMagUnit.p) }
  public static func addVectorOf(polyCoord: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: polyCoord, at: VTOFFSET.polyCoord.p) }
  public static func add(trackLeg: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trackLeg, def: 0, at: VTOFFSET.trackLeg.p) }
  public static func add(widthLeft: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: widthLeft, def: 0.0, at: VTOFFSET.widthLeft.p) }
  public static func add(widthRight: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: widthRight, def: 0.0, at: VTOFFSET.widthRight.p) }
  public static func add(width: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: width, def: 0.0, at: VTOFFSET.width.p) }
  public static func add(widthUnit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: widthUnit, at: VTOFFSET.widthUnit.p) }
  public static func addVectorOf(corrWayPoints: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: corrWayPoints, at: VTOFFSET.corrWayPoints.p) }
  public static func add(orbitAlignment: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: orbitAlignment, at: VTOFFSET.orbitAlignment.p) }
  public static func add(effVdim: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: effVdim, at: VTOFFSET.effVdim.p) }
  public static func addVectorOf(airspaceTimePeriod: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: airspaceTimePeriod, at: VTOFFSET.airspaceTimePeriod.p) }
  public static func addVectorOf(airspaceControlPoint: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: airspaceControlPoint, at: VTOFFSET.airspaceControlPoint.p) }
  public static func add(ctrlAuth: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ctrlAuth, at: VTOFFSET.ctrlAuth.p) }
  public static func addVectorOf(ctrlAuthFreqs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ctrlAuthFreqs, at: VTOFFSET.ctrlAuthFreqs.p) }
  public static func add(genTextInd: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: genTextInd, at: VTOFFSET.genTextInd.p) }
  public static func add(freeText: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: freeText, at: VTOFFSET.freeText.p) }
  public static func endAirspaceControlMeans_Abridged(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAirspaceControlMeans_Abridged(
    _ fbb: inout FlatBufferBuilder,
    cmTypeOffset cmType: Offset = Offset(),
    cmIdOffset cmId: Offset = Offset(),
    cmShape: AirspaceControlMeans_Abridged_cmShape_Enum = .polyarc,
    usageOffset usage: Offset = Offset(),
    link16IdOffset link16Id: Offset = Offset(),
    transAltitudeOffset transAltitude: Offset = Offset(),
    geoDatumAltOffset geoDatumAlt: Offset = Offset(),
    coord0Offset coord0: Offset = Offset(),
    coord1Offset coord1: Offset = Offset(),
    bearing0: Double = 0.0,
    bearing1: Double = 0.0,
    radMag0: Double = 0.0,
    radMag1: Double = 0.0,
    radMagUnitOffset radMagUnit: Offset = Offset(),
    polyCoordVectorOffset polyCoord: Offset = Offset(),
    trackLeg: Int32 = 0,
    widthLeft: Double = 0.0,
    widthRight: Double = 0.0,
    width: Double = 0.0,
    widthUnitOffset widthUnit: Offset = Offset(),
    corrWayPointsVectorOffset corrWayPoints: Offset = Offset(),
    orbitAlignmentOffset orbitAlignment: Offset = Offset(),
    effVdimOffset effVdim: Offset = Offset(),
    airspaceTimePeriodVectorOffset airspaceTimePeriod: Offset = Offset(),
    airspaceControlPointVectorOffset airspaceControlPoint: Offset = Offset(),
    ctrlAuthOffset ctrlAuth: Offset = Offset(),
    ctrlAuthFreqsVectorOffset ctrlAuthFreqs: Offset = Offset(),
    genTextIndOffset genTextInd: Offset = Offset(),
    freeTextOffset freeText: Offset = Offset()
  ) -> Offset {
    let __start = AirspaceControlMeans_Abridged.startAirspaceControlMeans_Abridged(&fbb)
    AirspaceControlMeans_Abridged.add(cmType: cmType, &fbb)
    AirspaceControlMeans_Abridged.add(cmId: cmId, &fbb)
    AirspaceControlMeans_Abridged.add(cmShape: cmShape, &fbb)
    AirspaceControlMeans_Abridged.add(usage: usage, &fbb)
    AirspaceControlMeans_Abridged.add(link16Id: link16Id, &fbb)
    AirspaceControlMeans_Abridged.add(transAltitude: transAltitude, &fbb)
    AirspaceControlMeans_Abridged.add(geoDatumAlt: geoDatumAlt, &fbb)
    AirspaceControlMeans_Abridged.add(coord0: coord0, &fbb)
    AirspaceControlMeans_Abridged.add(coord1: coord1, &fbb)
    AirspaceControlMeans_Abridged.add(bearing0: bearing0, &fbb)
    AirspaceControlMeans_Abridged.add(bearing1: bearing1, &fbb)
    AirspaceControlMeans_Abridged.add(radMag0: radMag0, &fbb)
    AirspaceControlMeans_Abridged.add(radMag1: radMag1, &fbb)
    AirspaceControlMeans_Abridged.add(radMagUnit: radMagUnit, &fbb)
    AirspaceControlMeans_Abridged.addVectorOf(polyCoord: polyCoord, &fbb)
    AirspaceControlMeans_Abridged.add(trackLeg: trackLeg, &fbb)
    AirspaceControlMeans_Abridged.add(widthLeft: widthLeft, &fbb)
    AirspaceControlMeans_Abridged.add(widthRight: widthRight, &fbb)
    AirspaceControlMeans_Abridged.add(width: width, &fbb)
    AirspaceControlMeans_Abridged.add(widthUnit: widthUnit, &fbb)
    AirspaceControlMeans_Abridged.addVectorOf(corrWayPoints: corrWayPoints, &fbb)
    AirspaceControlMeans_Abridged.add(orbitAlignment: orbitAlignment, &fbb)
    AirspaceControlMeans_Abridged.add(effVdim: effVdim, &fbb)
    AirspaceControlMeans_Abridged.addVectorOf(airspaceTimePeriod: airspaceTimePeriod, &fbb)
    AirspaceControlMeans_Abridged.addVectorOf(airspaceControlPoint: airspaceControlPoint, &fbb)
    AirspaceControlMeans_Abridged.add(ctrlAuth: ctrlAuth, &fbb)
    AirspaceControlMeans_Abridged.addVectorOf(ctrlAuthFreqs: ctrlAuthFreqs, &fbb)
    AirspaceControlMeans_Abridged.add(genTextInd: genTextInd, &fbb)
    AirspaceControlMeans_Abridged.add(freeText: freeText, &fbb)
    return AirspaceControlMeans_Abridged.endAirspaceControlMeans_Abridged(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.cmType.p, fieldName: "cmType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.cmId.p, fieldName: "cmId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.cmShape.p, fieldName: "cmShape", required: false, type: AirspaceControlMeans_Abridged_cmShape_Enum.self)
    try _v.visit(field: VTOFFSET.usage.p, fieldName: "usage", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.link16Id.p, fieldName: "link16Id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.transAltitude.p, fieldName: "transAltitude", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.geoDatumAlt.p, fieldName: "geoDatumAlt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.coord0.p, fieldName: "coord0", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.coord1.p, fieldName: "coord1", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.bearing0.p, fieldName: "bearing0", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.bearing1.p, fieldName: "bearing1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.radMag0.p, fieldName: "radMag0", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.radMag1.p, fieldName: "radMag1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.radMagUnit.p, fieldName: "radMagUnit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.polyCoord.p, fieldName: "polyCoord", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.trackLeg.p, fieldName: "trackLeg", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.widthLeft.p, fieldName: "widthLeft", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.widthRight.p, fieldName: "widthRight", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.width.p, fieldName: "width", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.widthUnit.p, fieldName: "widthUnit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.corrWayPoints.p, fieldName: "corrWayPoints", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.orbitAlignment.p, fieldName: "orbitAlignment", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.effVdim.p, fieldName: "effVdim", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.airspaceTimePeriod.p, fieldName: "airspaceTimePeriod", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.airspaceControlPoint.p, fieldName: "airspaceControlPoint", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.ctrlAuth.p, fieldName: "ctrlAuth", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ctrlAuthFreqs.p, fieldName: "ctrlAuthFreqs", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.genTextInd.p, fieldName: "genTextInd", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.freeText.p, fieldName: "freeText", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

