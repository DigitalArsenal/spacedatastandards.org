// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  /// Points identified within the route.
public struct RoutePoints_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "ROUT" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: RoutePoints_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ptSequenceId = 4
    case ptTypeCode = 6
    case ptTypeName = 8
    case waypointName = 10
    case dafifPt = 12
    case ptLat = 14
    case ptLon = 16
    case magDec = 18
    case navaidLength = 20
    case navaid = 22
    case countryCode = 24
    case altCountryCode = 26
    case navaidType = 28
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Sequencing field for the track route. This is the identifier representing the sequence of waypoints associated to the track route.
  ///  Example: /// Example: 1
  ///  Constraints: No constraints specified.
  public var ptSequenceId: Int32 { let o = _accessor.offset(VTOFFSET.ptSequenceId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Code representation of the point within the track route (ex. EP, EX, CP, IP, etc.).
  ///  Example: /// Example: EP
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var ptTypeCode: String? { let o = _accessor.offset(VTOFFSET.ptTypeCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ptTypeCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ptTypeCode.v) }
  ///  The name that represents the point within the track route (ex. ENTRY POINT, EXIT POINT, CONTROL POINT, INITIAL POINT, etc.).
  ///  Example: /// Example: ENTRY POINT
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var ptTypeName: String? { let o = _accessor.offset(VTOFFSET.ptTypeName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ptTypeNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ptTypeName.v) }
  ///  Name of a waypoint which identifies the location of the point.
  ///  Example: /// Example: KCHS
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var waypointName: String? { let o = _accessor.offset(VTOFFSET.waypointName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var waypointNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.waypointName.v) }
  ///  Flag indicating this is a Digital Aeronautical Flight Information File (DAFIF) point.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var dafifPt: Bool { let o = _accessor.offset(VTOFFSET.dafifPt.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  WGS84 latitude of the point location, in degrees. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 45.23
  ///  Constraints: No constraints specified.
  public var ptLat: Double { let o = _accessor.offset(VTOFFSET.ptLat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS84 longitude of the point location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 179.1
  ///  Constraints: No constraints specified.
  public var ptLon: Double { let o = _accessor.offset(VTOFFSET.ptLon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The magnetic declination/variation of the route point location from true north, in degrees. Positive values east of true north and negative values west of true north.
  ///  Example: /// Example: 7.35
  ///  Constraints: No constraints specified.
  public var magDec: Double { let o = _accessor.offset(VTOFFSET.magDec.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The length of the course from the Navigational Aid (NAVAID) in nautical miles.
  ///  Example: /// Example: 100.2
  ///  Constraints: No constraints specified.
  public var navaidLength: Double { let o = _accessor.offset(VTOFFSET.navaidLength.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Navigational Aid (NAVAID) identification code.
  ///  Example: /// Example: HTO
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var navaid: String? { let o = _accessor.offset(VTOFFSET.navaid.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var navaidSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.navaid.v) }
  ///  The DoD Standard Country Code designator for the country where the route point resides. This field should be set to "OTHR" if the source value does not match a UDL country code value (ISO-3166-ALPHA-2).
  ///  Example: /// Example: NL
  ///  Constraints: Minimum length = 0, Maximum length = 4
  public var countryCode: String? { let o = _accessor.offset(VTOFFSET.countryCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var countryCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.countryCode.v) }
  ///  Specifies an alternate country code if the data provider code is not part of an official NAVAID Country Code standard such as ISO-3166 or FIPS. This field will be set to the value provided by the source and should be used for all Queries specifying a Country Code.
  ///  Example: /// Example: IZ
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var altCountryCode: String? { let o = _accessor.offset(VTOFFSET.altCountryCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var altCountryCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.altCountryCode.v) }
  ///  The NAVAID type of this route point (ex. VOR, VORTAC, TACAN, etc.).
  ///  Example: /// Example: VORTAC
  ///  Constraints: Minimum length = 0, Maximum length = 12
  public var navaidType: String? { let o = _accessor.offset(VTOFFSET.navaidType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var navaidTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.navaidType.v) }
  public static func startRoutePoints_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 13) }
  public static func add(ptSequenceId: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ptSequenceId, def: 0, at: VTOFFSET.ptSequenceId.p) }
  public static func add(ptTypeCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ptTypeCode, at: VTOFFSET.ptTypeCode.p) }
  public static func add(ptTypeName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ptTypeName, at: VTOFFSET.ptTypeName.p) }
  public static func add(waypointName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: waypointName, at: VTOFFSET.waypointName.p) }
  public static func add(dafifPt: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dafifPt, def: false,
   at: VTOFFSET.dafifPt.p) }
  public static func add(ptLat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ptLat, def: 0.0, at: VTOFFSET.ptLat.p) }
  public static func add(ptLon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ptLon, def: 0.0, at: VTOFFSET.ptLon.p) }
  public static func add(magDec: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: magDec, def: 0.0, at: VTOFFSET.magDec.p) }
  public static func add(navaidLength: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: navaidLength, def: 0.0, at: VTOFFSET.navaidLength.p) }
  public static func add(navaid: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: navaid, at: VTOFFSET.navaid.p) }
  public static func add(countryCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: countryCode, at: VTOFFSET.countryCode.p) }
  public static func add(altCountryCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: altCountryCode, at: VTOFFSET.altCountryCode.p) }
  public static func add(navaidType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: navaidType, at: VTOFFSET.navaidType.p) }
  public static func endRoutePoints_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRoutePoints_Ingest(
    _ fbb: inout FlatBufferBuilder,
    ptSequenceId: Int32 = 0,
    ptTypeCodeOffset ptTypeCode: Offset = Offset(),
    ptTypeNameOffset ptTypeName: Offset = Offset(),
    waypointNameOffset waypointName: Offset = Offset(),
    dafifPt: Bool = false,
    ptLat: Double = 0.0,
    ptLon: Double = 0.0,
    magDec: Double = 0.0,
    navaidLength: Double = 0.0,
    navaidOffset navaid: Offset = Offset(),
    countryCodeOffset countryCode: Offset = Offset(),
    altCountryCodeOffset altCountryCode: Offset = Offset(),
    navaidTypeOffset navaidType: Offset = Offset()
  ) -> Offset {
    let __start = RoutePoints_Ingest.startRoutePoints_Ingest(&fbb)
    RoutePoints_Ingest.add(ptSequenceId: ptSequenceId, &fbb)
    RoutePoints_Ingest.add(ptTypeCode: ptTypeCode, &fbb)
    RoutePoints_Ingest.add(ptTypeName: ptTypeName, &fbb)
    RoutePoints_Ingest.add(waypointName: waypointName, &fbb)
    RoutePoints_Ingest.add(dafifPt: dafifPt, &fbb)
    RoutePoints_Ingest.add(ptLat: ptLat, &fbb)
    RoutePoints_Ingest.add(ptLon: ptLon, &fbb)
    RoutePoints_Ingest.add(magDec: magDec, &fbb)
    RoutePoints_Ingest.add(navaidLength: navaidLength, &fbb)
    RoutePoints_Ingest.add(navaid: navaid, &fbb)
    RoutePoints_Ingest.add(countryCode: countryCode, &fbb)
    RoutePoints_Ingest.add(altCountryCode: altCountryCode, &fbb)
    RoutePoints_Ingest.add(navaidType: navaidType, &fbb)
    return RoutePoints_Ingest.endRoutePoints_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ptSequenceId.p, fieldName: "ptSequenceId", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.ptTypeCode.p, fieldName: "ptTypeCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ptTypeName.p, fieldName: "ptTypeName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.waypointName.p, fieldName: "waypointName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dafifPt.p, fieldName: "dafifPt", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.ptLat.p, fieldName: "ptLat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ptLon.p, fieldName: "ptLon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.magDec.p, fieldName: "magDec", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.navaidLength.p, fieldName: "navaidLength", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.navaid.p, fieldName: "navaid", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.countryCode.p, fieldName: "countryCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.altCountryCode.p, fieldName: "altCountryCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.navaidType.p, fieldName: "navaidType", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

