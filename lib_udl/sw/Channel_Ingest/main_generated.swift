// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Channel_Ingest_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: Channel_Ingest_dataMode_Enum { return .exercise }
  public static var min: Channel_Ingest_dataMode_Enum { return .real }
}


///  /// Channel information on a particular transponder.
public struct Channel_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "CHAN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Channel_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case idTransponder = 6
    case name = 8
    case classificationMarking = 10
    case type = 12
    case idBeam = 14
    case beamName = 16
    case idRfband = 18
    case encryption = 20
    case pkg = 22
    case res = 24
    case compression = 26
    case vpid = 28
    case apid = 30
    case sid = 32
    case owner = 34
    case source = 36
    case origin = 38
    case origNetwork = 40
    case dataMode = 42
    case createdAt = 44
    case createdBy = 46
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: CHANNEL-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  ID of the parent transponder object for this Channel.
  ///  Example: /// Example: REF-TRANSPONDER-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var idTransponder: String? { let o = _accessor.offset(VTOFFSET.idTransponder.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idTransponderSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idTransponder.v) }
  ///  Channel name.
  ///  Example: /// Example: Example name
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Channel type.
  ///  Example: /// Example: Example type
  ///  Constraints: Minimum length = 0, Maximum length = 45
  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  ///  Identifier of the particular beam for this channel.
  ///  Example: /// Example: REF-BEAM-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idBeam: String? { let o = _accessor.offset(VTOFFSET.idBeam.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idBeamSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idBeam.v) }
  ///  The antenna beam ID of the particular beam for this channel.  beamName is not unique across payloads.
  ///  Example: /// Example: B8VD
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var beamName: String? { let o = _accessor.offset(VTOFFSET.beamName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var beamNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.beamName.v) }
  ///  ID of the RF Band object for this channel.
  ///  Example: /// Example: REF-RFBAND-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idRfband: String? { let o = _accessor.offset(VTOFFSET.idRfband.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idRfbandSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idRfband.v) }
  ///  Channel encryption.
  ///  Example: /// Example: Example encryption
  ///  Constraints: Minimum length = 0, Maximum length = 45
  public var encryption: String? { let o = _accessor.offset(VTOFFSET.encryption.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var encryptionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.encryption.v) }
  ///  Pkg.
  ///  Example: /// Example: Example pkg
  ///  Constraints: Minimum length = 0, Maximum length = 45
  public var pkg: String? { let o = _accessor.offset(VTOFFSET.pkg.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var pkgSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.pkg.v) }
  ///  Res.
  ///  Example: /// Example: Example res
  ///  Constraints: Minimum length = 0, Maximum length = 45
  public var res: String? { let o = _accessor.offset(VTOFFSET.res.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var resSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.res.v) }
  ///  Channel compression.
  ///  Example: /// Example: Example compression
  ///  Constraints: Minimum length = 0, Maximum length = 45
  public var compression: String? { let o = _accessor.offset(VTOFFSET.compression.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var compressionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.compression.v) }
  ///  Channel vPid.
  ///  Example: /// Example: VP-ID
  ///  Constraints: Minimum length = 0, Maximum length = 45
  public var vpid: String? { let o = _accessor.offset(VTOFFSET.vpid.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var vpidSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.vpid.v) }
  ///  Channel aPid.
  ///  Example: /// Example: AP-ID
  ///  Constraints: Minimum length = 0, Maximum length = 45
  public var apid: String? { let o = _accessor.offset(VTOFFSET.apid.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var apidSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.apid.v) }
  ///  SID.
  ///  Example: /// Example: S-ID
  ///  Constraints: Minimum length = 0, Maximum length = 45
  public var sid: String? { let o = _accessor.offset(VTOFFSET.sid.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sidSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sid.v) }
  ///  Owner.
  ///  Example: /// Example: example_owner
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var owner: String? { let o = _accessor.offset(VTOFFSET.owner.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ownerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.owner.v) }
  ///  Source of the data.
  ///  Example: /// Example: system.source
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: example_origin
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: Channel_Ingest_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : Channel_Ingest_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  public static func startChannel_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 22) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(idTransponder: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idTransponder, at: VTOFFSET.idTransponder.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func add(idBeam: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idBeam, at: VTOFFSET.idBeam.p) }
  public static func add(beamName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: beamName, at: VTOFFSET.beamName.p) }
  public static func add(idRfband: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idRfband, at: VTOFFSET.idRfband.p) }
  public static func add(encryption: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: encryption, at: VTOFFSET.encryption.p) }
  public static func add(pkg: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: pkg, at: VTOFFSET.pkg.p) }
  public static func add(res: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: res, at: VTOFFSET.res.p) }
  public static func add(compression: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: compression, at: VTOFFSET.compression.p) }
  public static func add(vpid: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vpid, at: VTOFFSET.vpid.p) }
  public static func add(apid: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: apid, at: VTOFFSET.apid.p) }
  public static func add(sid: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sid, at: VTOFFSET.sid.p) }
  public static func add(owner: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: owner, at: VTOFFSET.owner.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: Channel_Ingest_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func endChannel_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createChannel_Ingest(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    idTransponderOffset idTransponder: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    typeOffset type: Offset = Offset(),
    idBeamOffset idBeam: Offset = Offset(),
    beamNameOffset beamName: Offset = Offset(),
    idRfbandOffset idRfband: Offset = Offset(),
    encryptionOffset encryption: Offset = Offset(),
    pkgOffset pkg: Offset = Offset(),
    resOffset res: Offset = Offset(),
    compressionOffset compression: Offset = Offset(),
    vpidOffset vpid: Offset = Offset(),
    apidOffset apid: Offset = Offset(),
    sidOffset sid: Offset = Offset(),
    ownerOffset owner: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: Channel_Ingest_dataMode_Enum = .real,
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset()
  ) -> Offset {
    let __start = Channel_Ingest.startChannel_Ingest(&fbb)
    Channel_Ingest.add(id: id, &fbb)
    Channel_Ingest.add(idTransponder: idTransponder, &fbb)
    Channel_Ingest.add(name: name, &fbb)
    Channel_Ingest.add(classificationMarking: classificationMarking, &fbb)
    Channel_Ingest.add(type: type, &fbb)
    Channel_Ingest.add(idBeam: idBeam, &fbb)
    Channel_Ingest.add(beamName: beamName, &fbb)
    Channel_Ingest.add(idRfband: idRfband, &fbb)
    Channel_Ingest.add(encryption: encryption, &fbb)
    Channel_Ingest.add(pkg: pkg, &fbb)
    Channel_Ingest.add(res: res, &fbb)
    Channel_Ingest.add(compression: compression, &fbb)
    Channel_Ingest.add(vpid: vpid, &fbb)
    Channel_Ingest.add(apid: apid, &fbb)
    Channel_Ingest.add(sid: sid, &fbb)
    Channel_Ingest.add(owner: owner, &fbb)
    Channel_Ingest.add(source: source, &fbb)
    Channel_Ingest.add(origin: origin, &fbb)
    Channel_Ingest.add(origNetwork: origNetwork, &fbb)
    Channel_Ingest.add(dataMode: dataMode, &fbb)
    Channel_Ingest.add(createdAt: createdAt, &fbb)
    Channel_Ingest.add(createdBy: createdBy, &fbb)
    return Channel_Ingest.endChannel_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idTransponder.p, fieldName: "idTransponder", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idBeam.p, fieldName: "idBeam", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.beamName.p, fieldName: "beamName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idRfband.p, fieldName: "idRfband", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.encryption.p, fieldName: "encryption", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.pkg.p, fieldName: "pkg", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.res.p, fieldName: "res", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.compression.p, fieldName: "compression", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.vpid.p, fieldName: "vpid", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.apid.p, fieldName: "apid", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sid.p, fieldName: "sid", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.owner.p, fieldName: "owner", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: Channel_Ingest_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

