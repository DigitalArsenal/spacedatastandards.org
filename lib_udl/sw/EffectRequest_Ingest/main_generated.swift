// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum EffectRequest_Ingest_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: EffectRequest_Ingest_dataMode_Enum { return .exercise }
  public static var min: EffectRequest_Ingest_dataMode_Enum { return .real }
}


///  /// A request for various effects on a target.
public struct EffectRequest_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "EFFE" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EffectRequest_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case externalRequestId = 8
    case effectList = 10
    case state = 12
    case context = 14
    case startTime = 16
    case endTime = 18
    case deadlineType = 20
    case targetSrcType = 22
    case targetSrcId = 24
    case priority = 26
    case modelClass = 28
    case metricTypes = 30
    case metricWeights = 32
    case createdAt = 34
    case createdBy = 36
    case source = 38
    case origin = 40
    case dataMode = 42
    case origNetwork = 44
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: EFFECTREQUEST-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  The extenal system identifier of this request. A human readable unique id.
  ///  Example: /// Example: EXTERNALREQUEST-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var externalRequestId: String? { let o = _accessor.offset(VTOFFSET.externalRequestId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var externalRequestIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.externalRequestId.v) }
  ///  List of effects to be achieved on the target (e.g. COVER, DECEIVE, DEGRADE, DENY, DESTROY, DISRUPT, DIVERSION, DIVERT, FIX, INSPECT, INTERCEPT, ISOLATE, MANIPULATE, NEUTRALIZE, SHADOW, SUPPRESS, etc.).  The effects included in this list are connected by implied AND.
  ///  Example: /// Example: ['COVER', 'DECEIVE']
  ///  Constraints: No constraints specified.
  public var hasEffectList: Bool { let o = _accessor.offset(VTOFFSET.effectList.v); return o == 0 ? false : true }
  public var effectListCount: Int32 { let o = _accessor.offset(VTOFFSET.effectList.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func effectList(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.effectList.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  State of this effect request (e.g. CREATED, UPDATED, DELETED, etc.).
  ///  Example: /// Example: CREATED
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var state: String? { let o = _accessor.offset(VTOFFSET.state.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var stateSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.state.v) }
  ///  Specific descriptive instantiation of the effect, e.g., playbook to be used.
  ///  Example: /// Example: Example Notes
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var context: String? { let o = _accessor.offset(VTOFFSET.context.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var contextSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.context.v) }
  ///  The time the effect should start, in ISO8601 UTC format.
  ///  Example: /// Example: 2018-01-01T16:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var startTime: String? { let o = _accessor.offset(VTOFFSET.startTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var startTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.startTime.v) }
  ///  The time the effect should end, in ISO8601 UTC format.
  ///  Example: /// Example: 2018-01-01T16:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var endTime: String? { let o = _accessor.offset(VTOFFSET.endTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var endTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.endTime.v) }
  ///  The indicator of deadline of the bid request (e.g. BETWEEN, IMMEDIATE, NOEARLIERTHAN, NOLATERTHAN, etc.):
  ///  BETWEEN:&nbsp;Produce effect any time between the given start and end times, equal penalty for being early or late
  ///  IMMEDIATE:&nbsp;Start as soon as possible, earlier is always better
  ///  NOEARLIERTHAN:&nbsp;Produce effect at this time or later. Large penalty for being earlier, no reward for being later
  ///  NOLATERTHAN:&nbsp;Produce effect no later than the given startTime. Large penalty for being later, no reward for being even earlier as long as the effect starts by the given time.
  ///  Example: /// Example: NoLaterThan
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var deadlineType: String? { let o = _accessor.offset(VTOFFSET.deadlineType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var deadlineTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.deadlineType.v) }
  ///  The source type of the targetId identifier (POI, TRACK).
  ///  Example: /// Example: POI
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var targetSrcType: String? { let o = _accessor.offset(VTOFFSET.targetSrcType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var targetSrcTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.targetSrcType.v) }
  ///  The record ID, depending on the type identified in targetSrcType, of the requested target. This identifier corresponds to either poi.poiid or track.trkId from their respective schemas.
  ///  Example: /// Example: TARGETSRC-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var targetSrcId: String? { let o = _accessor.offset(VTOFFSET.targetSrcId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var targetSrcIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.targetSrcId.v) }
  ///  The priority (LOW, MEDIUM, HIGH) of this request.
  ///  Example: /// Example: LOW
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var priority: String? { let o = _accessor.offset(VTOFFSET.priority.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var prioritySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.priority.v) }
  ///  The type or class of the preference model used to evaluate this offer.
  ///  Example: /// Example: Preference model
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var modelClass: String? { let o = _accessor.offset(VTOFFSET.modelClass.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var modelClassSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.modelClass.v) }
  ///  Array of the the metric classes to be evaluated (e.g. Cost, GoalAchievement, OpportunityCost, Risk, Timeliness, Unavailable, etc.).  See the associated 'metricWeights' array for the weighting values, positionally corresponding to these types.  The 'metricTypes' and 'metricWeights' arrays must match in size.
  ///  Example: /// Example: ['COST', 'RISK']
  ///  Constraints: No constraints specified.
  public var hasMetricTypes: Bool { let o = _accessor.offset(VTOFFSET.metricTypes.v); return o == 0 ? false : true }
  public var metricTypesCount: Int32 { let o = _accessor.offset(VTOFFSET.metricTypes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func metricTypes(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.metricTypes.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the weights for the metric in the final evaluation score. Normalized (0 to 1).  See the associated 'metricTypes' array for the metric classes, positionally corresponding to these values.  The 'metricTypes' and 'metricWeights' arrays must match in size.
  ///  Example: /// Example: [0.5, 0.6]
  ///  Constraints: No constraints specified.
  public var hasMetricWeights: Bool { let o = _accessor.offset(VTOFFSET.metricWeights.v); return o == 0 ? false : true }
  public var metricWeightsCount: Int32 { let o = _accessor.offset(VTOFFSET.metricWeights.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func metricWeights(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.metricWeights.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: EffectRequest_Ingest_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : EffectRequest_Ingest_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  public static func startEffectRequest_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 21) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(externalRequestId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: externalRequestId, at: VTOFFSET.externalRequestId.p) }
  public static func addVectorOf(effectList: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: effectList, at: VTOFFSET.effectList.p) }
  public static func add(state: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: state, at: VTOFFSET.state.p) }
  public static func add(context: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: context, at: VTOFFSET.context.p) }
  public static func add(startTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startTime, at: VTOFFSET.startTime.p) }
  public static func add(endTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: endTime, at: VTOFFSET.endTime.p) }
  public static func add(deadlineType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: deadlineType, at: VTOFFSET.deadlineType.p) }
  public static func add(targetSrcType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: targetSrcType, at: VTOFFSET.targetSrcType.p) }
  public static func add(targetSrcId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: targetSrcId, at: VTOFFSET.targetSrcId.p) }
  public static func add(priority: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: priority, at: VTOFFSET.priority.p) }
  public static func add(modelClass: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: modelClass, at: VTOFFSET.modelClass.p) }
  public static func addVectorOf(metricTypes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: metricTypes, at: VTOFFSET.metricTypes.p) }
  public static func addVectorOf(metricWeights: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: metricWeights, at: VTOFFSET.metricWeights.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(dataMode: EffectRequest_Ingest_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func endEffectRequest_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEffectRequest_Ingest(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    externalRequestIdOffset externalRequestId: Offset = Offset(),
    effectListVectorOffset effectList: Offset = Offset(),
    stateOffset state: Offset = Offset(),
    contextOffset context: Offset = Offset(),
    startTimeOffset startTime: Offset = Offset(),
    endTimeOffset endTime: Offset = Offset(),
    deadlineTypeOffset deadlineType: Offset = Offset(),
    targetSrcTypeOffset targetSrcType: Offset = Offset(),
    targetSrcIdOffset targetSrcId: Offset = Offset(),
    priorityOffset priority: Offset = Offset(),
    modelClassOffset modelClass: Offset = Offset(),
    metricTypesVectorOffset metricTypes: Offset = Offset(),
    metricWeightsVectorOffset metricWeights: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    dataMode: EffectRequest_Ingest_dataMode_Enum = .real,
    origNetworkOffset origNetwork: Offset = Offset()
  ) -> Offset {
    let __start = EffectRequest_Ingest.startEffectRequest_Ingest(&fbb)
    EffectRequest_Ingest.add(id: id, &fbb)
    EffectRequest_Ingest.add(classificationMarking: classificationMarking, &fbb)
    EffectRequest_Ingest.add(externalRequestId: externalRequestId, &fbb)
    EffectRequest_Ingest.addVectorOf(effectList: effectList, &fbb)
    EffectRequest_Ingest.add(state: state, &fbb)
    EffectRequest_Ingest.add(context: context, &fbb)
    EffectRequest_Ingest.add(startTime: startTime, &fbb)
    EffectRequest_Ingest.add(endTime: endTime, &fbb)
    EffectRequest_Ingest.add(deadlineType: deadlineType, &fbb)
    EffectRequest_Ingest.add(targetSrcType: targetSrcType, &fbb)
    EffectRequest_Ingest.add(targetSrcId: targetSrcId, &fbb)
    EffectRequest_Ingest.add(priority: priority, &fbb)
    EffectRequest_Ingest.add(modelClass: modelClass, &fbb)
    EffectRequest_Ingest.addVectorOf(metricTypes: metricTypes, &fbb)
    EffectRequest_Ingest.addVectorOf(metricWeights: metricWeights, &fbb)
    EffectRequest_Ingest.add(createdAt: createdAt, &fbb)
    EffectRequest_Ingest.add(createdBy: createdBy, &fbb)
    EffectRequest_Ingest.add(source: source, &fbb)
    EffectRequest_Ingest.add(origin: origin, &fbb)
    EffectRequest_Ingest.add(dataMode: dataMode, &fbb)
    EffectRequest_Ingest.add(origNetwork: origNetwork, &fbb)
    return EffectRequest_Ingest.endEffectRequest_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.externalRequestId.p, fieldName: "externalRequestId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.effectList.p, fieldName: "effectList", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.state.p, fieldName: "state", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.context.p, fieldName: "context", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.startTime.p, fieldName: "startTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.endTime.p, fieldName: "endTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.deadlineType.p, fieldName: "deadlineType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.targetSrcType.p, fieldName: "targetSrcType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.targetSrcId.p, fieldName: "targetSrcId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.priority.p, fieldName: "priority", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.modelClass.p, fieldName: "modelClass", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.metricTypes.p, fieldName: "metricTypes", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.metricWeights.p, fieldName: "metricWeights", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: EffectRequest_Ingest_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

