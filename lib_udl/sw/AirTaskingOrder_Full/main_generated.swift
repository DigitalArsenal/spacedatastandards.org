// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum AirTaskingOrder_Full_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: AirTaskingOrder_Full_dataMode_Enum { return .exercise }
  public static var min: AirTaskingOrder_Full_dataMode_Enum { return .real }
}


///  /// Beta Version Air Tasking Order: The ATO is used to task air missions, assign cross force tasking as well as intraservice tasking.
public struct AirTaskingOrder_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "AIRT" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AirTaskingOrder_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case rawFileUri = 8
    case opExerName = 10
    case msgOriginator = 12
    case msgSn = 14
    case msgMonth = 16
    case msgQualifier = 18
    case ackReqInd = 20
    case ackUnitInstructions = 22
    case beginTs = 24
    case endTs = 26
    case genText = 28
    case acMsnTasking = 30
    case navalFltOps = 32
    case createdAt = 34
    case createdBy = 36
    case source = 38
    case sourceDl = 40
    case origin = 42
    case origNetwork = 44
    case dataMode = 46
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: POI-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  ///  Example: /// Example: Example URI
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var rawFileUri: String? { let o = _accessor.offset(VTOFFSET.rawFileUri.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var rawFileUriSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.rawFileUri.v) }
  ///  Specifies the unique operation or exercise name, nickname, or codeword assigned to a joint exercise or operation plan.
  ///  Example: /// Example: DESERT WIND
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var opExerName: String? { let o = _accessor.offset(VTOFFSET.opExerName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var opExerNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.opExerName.v) }
  ///  The identifier of the originator of the message.
  ///  Example: /// Example: USCENTCOM
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var msgOriginator: String? { let o = _accessor.offset(VTOFFSET.msgOriginator.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var msgOriginatorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.msgOriginator.v) }
  ///  The unique message identifier sequentially assigned by the originator.
  ///  Example: /// Example: ATO A
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var msgSn: String? { let o = _accessor.offset(VTOFFSET.msgSn.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var msgSnSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.msgSn.v) }
  ///  The month in which the message originated.
  ///  Example: /// Example: OCT
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var msgMonth: String? { let o = _accessor.offset(VTOFFSET.msgMonth.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var msgMonthSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.msgMonth.v) }
  ///  The qualifier which caveats the message status.
  ///  Example: /// Example: CHG
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var msgQualifier: String? { let o = _accessor.offset(VTOFFSET.msgQualifier.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var msgQualifierSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.msgQualifier.v) }
  ///  The indicator specifying an affirmative or a negatice condition for this message.
  ///  Example: /// Example: YES
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var ackReqInd: String? { let o = _accessor.offset(VTOFFSET.ackReqInd.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ackReqIndSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ackReqInd.v) }
  ///  Specifies textual data amplifying the data contained in the acknowledgement requirement indicator (ackRedInd) field or the unit required to acknowledge.
  ///  Example: /// Example: INST:45TS
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var ackUnitInstructions: String? { let o = _accessor.offset(VTOFFSET.ackUnitInstructions.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ackUnitInstructionsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ackUnitInstructions.v) }
  ///  The effective begin time for this ATO in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2023-10-25T12:00:00.123Z
  ///  Constraints: No constraints specified.
  public var beginTs: String? { let o = _accessor.offset(VTOFFSET.beginTs.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var beginTsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.beginTs.v) }
  ///  The effective end time for this ATO in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2023-10-27T12:00:00.123Z
  ///  Constraints: No constraints specified.
  public var endTs: String? { let o = _accessor.offset(VTOFFSET.endTs.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var endTsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.endTs.v) }
  ///  A collection that details special instructions, important information, guidance, and amplifying information regarding this ATO.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasGenText: Bool { let o = _accessor.offset(VTOFFSET.genText.v); return o == 0 ? false : true }
  public var genTextCount: Int32 { let o = _accessor.offset(VTOFFSET.genText.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func genText(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.genText.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  A collection that specifies the tasked country, tasked service, unit and mission level tasking for this ATO.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasAcMsnTasking: Bool { let o = _accessor.offset(VTOFFSET.acMsnTasking.v); return o == 0 ? false : true }
  public var acMsnTaskingCount: Int32 { let o = _accessor.offset(VTOFFSET.acMsnTasking.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func acMsnTasking(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.acMsnTasking.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  A collection that specifies the naval flight operations for this ATO.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasNavalFltOps: Bool { let o = _accessor.offset(VTOFFSET.navalFltOps.v); return o == 0 ? false : true }
  public var navalFltOpsCount: Int32 { let o = _accessor.offset(VTOFFSET.navalFltOps.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func navalFltOps(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.navalFltOps.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Time the row was created in the database.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  ///  Example: /// Example: AXE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var sourceDl: String? { let o = _accessor.offset(VTOFFSET.sourceDl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceDlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceDl.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: AirTaskingOrder_Full_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : AirTaskingOrder_Full_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  public static func startAirTaskingOrder_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 22) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(rawFileUri: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rawFileUri, at: VTOFFSET.rawFileUri.p) }
  public static func add(opExerName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: opExerName, at: VTOFFSET.opExerName.p) }
  public static func add(msgOriginator: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: msgOriginator, at: VTOFFSET.msgOriginator.p) }
  public static func add(msgSn: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: msgSn, at: VTOFFSET.msgSn.p) }
  public static func add(msgMonth: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: msgMonth, at: VTOFFSET.msgMonth.p) }
  public static func add(msgQualifier: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: msgQualifier, at: VTOFFSET.msgQualifier.p) }
  public static func add(ackReqInd: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ackReqInd, at: VTOFFSET.ackReqInd.p) }
  public static func add(ackUnitInstructions: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ackUnitInstructions, at: VTOFFSET.ackUnitInstructions.p) }
  public static func add(beginTs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: beginTs, at: VTOFFSET.beginTs.p) }
  public static func add(endTs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: endTs, at: VTOFFSET.endTs.p) }
  public static func addVectorOf(genText: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: genText, at: VTOFFSET.genText.p) }
  public static func addVectorOf(acMsnTasking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: acMsnTasking, at: VTOFFSET.acMsnTasking.p) }
  public static func addVectorOf(navalFltOps: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: navalFltOps, at: VTOFFSET.navalFltOps.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(sourceDl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceDl, at: VTOFFSET.sourceDl.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: AirTaskingOrder_Full_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func endAirTaskingOrder_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAirTaskingOrder_Full(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    rawFileUriOffset rawFileUri: Offset = Offset(),
    opExerNameOffset opExerName: Offset = Offset(),
    msgOriginatorOffset msgOriginator: Offset = Offset(),
    msgSnOffset msgSn: Offset = Offset(),
    msgMonthOffset msgMonth: Offset = Offset(),
    msgQualifierOffset msgQualifier: Offset = Offset(),
    ackReqIndOffset ackReqInd: Offset = Offset(),
    ackUnitInstructionsOffset ackUnitInstructions: Offset = Offset(),
    beginTsOffset beginTs: Offset = Offset(),
    endTsOffset endTs: Offset = Offset(),
    genTextVectorOffset genText: Offset = Offset(),
    acMsnTaskingVectorOffset acMsnTasking: Offset = Offset(),
    navalFltOpsVectorOffset navalFltOps: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    sourceDlOffset sourceDl: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: AirTaskingOrder_Full_dataMode_Enum = .real
  ) -> Offset {
    let __start = AirTaskingOrder_Full.startAirTaskingOrder_Full(&fbb)
    AirTaskingOrder_Full.add(id: id, &fbb)
    AirTaskingOrder_Full.add(classificationMarking: classificationMarking, &fbb)
    AirTaskingOrder_Full.add(rawFileUri: rawFileUri, &fbb)
    AirTaskingOrder_Full.add(opExerName: opExerName, &fbb)
    AirTaskingOrder_Full.add(msgOriginator: msgOriginator, &fbb)
    AirTaskingOrder_Full.add(msgSn: msgSn, &fbb)
    AirTaskingOrder_Full.add(msgMonth: msgMonth, &fbb)
    AirTaskingOrder_Full.add(msgQualifier: msgQualifier, &fbb)
    AirTaskingOrder_Full.add(ackReqInd: ackReqInd, &fbb)
    AirTaskingOrder_Full.add(ackUnitInstructions: ackUnitInstructions, &fbb)
    AirTaskingOrder_Full.add(beginTs: beginTs, &fbb)
    AirTaskingOrder_Full.add(endTs: endTs, &fbb)
    AirTaskingOrder_Full.addVectorOf(genText: genText, &fbb)
    AirTaskingOrder_Full.addVectorOf(acMsnTasking: acMsnTasking, &fbb)
    AirTaskingOrder_Full.addVectorOf(navalFltOps: navalFltOps, &fbb)
    AirTaskingOrder_Full.add(createdAt: createdAt, &fbb)
    AirTaskingOrder_Full.add(createdBy: createdBy, &fbb)
    AirTaskingOrder_Full.add(source: source, &fbb)
    AirTaskingOrder_Full.add(sourceDl: sourceDl, &fbb)
    AirTaskingOrder_Full.add(origin: origin, &fbb)
    AirTaskingOrder_Full.add(origNetwork: origNetwork, &fbb)
    AirTaskingOrder_Full.add(dataMode: dataMode, &fbb)
    return AirTaskingOrder_Full.endAirTaskingOrder_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rawFileUri.p, fieldName: "rawFileUri", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.opExerName.p, fieldName: "opExerName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msgOriginator.p, fieldName: "msgOriginator", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msgSn.p, fieldName: "msgSn", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msgMonth.p, fieldName: "msgMonth", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msgQualifier.p, fieldName: "msgQualifier", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ackReqInd.p, fieldName: "ackReqInd", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ackUnitInstructions.p, fieldName: "ackUnitInstructions", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.beginTs.p, fieldName: "beginTs", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.endTs.p, fieldName: "endTs", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.genText.p, fieldName: "genText", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.acMsnTasking.p, fieldName: "acMsnTasking", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.navalFltOps.p, fieldName: "navalFltOps", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceDl.p, fieldName: "sourceDl", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: AirTaskingOrder_Full_dataMode_Enum.self)
    _v.finish()
  }
}

