// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum IonoObservation_Full_transmitSensorType_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case mobile = 0
  ///  No description available.
  case static_ = 1

  public static var max: IonoObservation_Full_transmitSensorType_Enum { return .static_ }
  public static var min: IonoObservation_Full_transmitSensorType_Enum { return .mobile }
}


public enum IonoObservation_Full_receiveSensorType_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case mobile = 0
  ///  No description available.
  case static_ = 1

  public static var max: IonoObservation_Full_receiveSensorType_Enum { return .static_ }
  public static var min: IonoObservation_Full_receiveSensorType_Enum { return .mobile }
}


public enum IonoObservation_Full_antennaElementPositionCoordinateSystem_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case j2000 = 0
  ///  No description available.
  case ecrEcef = 1
  ///  No description available.
  case teme = 2
  ///  No description available.
  case gcrf = 3
  ///  No description available.
  case wgs84_geodeticLat_long_alt_ = 4
  ///  No description available.
  case geocentric_lat_long_radii_ = 5

  public static var max: IonoObservation_Full_antennaElementPositionCoordinateSystem_Enum { return .geocentric_lat_long_radii_ }
  public static var min: IonoObservation_Full_antennaElementPositionCoordinateSystem_Enum { return .j2000 }
}


public enum IonoObservation_Full_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: IonoObservation_Full_dataMode_Enum { return .exercise }
  public static var min: IonoObservation_Full_dataMode_Enum { return .real }
}


///  /// These services provide operations for posting and querying ionospheric observation data. Characteristics are defined by the CHARS: URSI IIWG format for archiving monthly ionospheric characteristics, INAG Bulletin No. 62 specification. Qualifying and Descriptive letters are defined by the URSI Handbook for Ionogram Interpretation and reduction, Report UAG, No. 23A specification.
public struct IonoObservation_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "IONO" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: IonoObservation_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case idSensor = 8
    case origSensorId = 10
    case system = 12
    case neProfileName = 14
    case neProfileVersion = 16
    case scalerInfo = 18
    case densityProfile = 20
    case stationId = 22
    case startTimeUtc = 24
    case systemInfo = 26
    case systemNotes = 28
    case transmitCoordinates = 30
    case transmitSensorType = 32
    case receiveCoordinates = 34
    case receiveSensorType = 36
    case antennaElementPosition = 38
    case antennaElementPositionCoordinateSystem = 40
    case power = 42
    case range = 44
    case frequency = 46
    case polarization = 48
    case azimuth = 50
    case elevation = 52
    case restrictedFrequency = 54
    case restrictedFrequencyNotes = 56
    case doppler = 58
    case time = 60
    case stokes = 62
    case amplitude = 64
    case phase = 66
    case foF2 = 68
    case foF1 = 70
    case fxF2 = 72
    case fxF1 = 74
    case md = 76
    case luf = 78
    case mufd = 80
    case fmin = 82
    case foEs = 84
    case fminF = 86
    case fminE = 88
    case foE = 90
    case fxE = 92
    case fxI = 94
    case hprimeF = 96
    case hprimeF2 = 98
    case hprimeF1 = 100
    case hprimeE = 102
    case hprimeEs = 104
    case zmE = 106
    case yE = 108
    case qf = 110
    case qe = 112
    case downF = 114
    case downE = 116
    case downEs = 118
    case ff = 120
    case fe = 122
    case d = 124
    case fmuf = 126
    case hprimefMuf = 128
    case deltafoF2 = 130
    case foEp = 132
    case fhprimeF = 134
    case fhprimeF2 = 136
    case foF1p = 138
    case foF2p = 140
    case hmF2 = 142
    case hmF1 = 144
    case hmE = 146
    case zhalfNm = 148
    case fminEs = 150
    case yF2 = 152
    case yF1 = 154
    case tec = 156
    case scaleHeightF2Peak = 158
    case b0 = 160
    case b1 = 162
    case d1 = 164
    case foEa = 166
    case hprimeEa = 168
    case foP = 170
    case hprimeP = 172
    case fbEs = 174
    case typeEs = 176
    case charAtts = 178
    case height = 180
    case plasmaFrequency = 182
    case plasmaFrequencyUncertainty = 184
    case electronDensity = 186
    case electronDensityUncertainty = 188
    case artistFlags = 190
    case traceGeneric = 192
    case tidPhaseSpeeds = 194
    case tidAzimuth = 196
    case tidPeriods = 198
    case datum = 200
    case platformName = 202
    case createdAt = 204
    case createdBy = 206
    case updatedAt = 208
    case updatedBy = 210
    case source = 212
    case origin = 214
    case dataMode = 216
    case origNetwork = 218
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: IONOOBSERVATION-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Unique identifier of the reporting sensor.
  ///  Example: /// Example: SENSOR-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idSensor: String? { let o = _accessor.offset(VTOFFSET.idSensor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSensorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSensor.v) }
  ///  Optional identifier provided by observation source to indicate the sensor identifier which produced this observation. This may be an internal identifier and not necessarily a valid sensor ID.
  ///  Example: /// Example: ORIGSENSOR-ID
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origSensorId: String? { let o = _accessor.offset(VTOFFSET.origSensorId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origSensorIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origSensorId.v) }
  ///  Ionosonde hardware type or data collection type together with possible additional descriptors.
  ///  Example: /// Example: Example hardware type
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var system: String? { let o = _accessor.offset(VTOFFSET.system.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var systemSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.system.v) }
  ///  Name of the algorithm used for the electron density profile.
  ///  Example: /// Example: NH
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var neProfileName: String? { let o = _accessor.offset(VTOFFSET.neProfileName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var neProfileNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.neProfileName.v) }
  ///  Version of the algorithm used for the electron density profile.
  ///  Example: /// Example: 4.32
  ///  Constraints: No constraints specified.
  public var neProfileVersion: Double { let o = _accessor.offset(VTOFFSET.neProfileVersion.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var scalerInfo: String? { let o = _accessor.offset(VTOFFSET.scalerInfo.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var scalerInfoSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.scalerInfo.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var densityProfile: String? { let o = _accessor.offset(VTOFFSET.densityProfile.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var densityProfileSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.densityProfile.v) }
  ///  URSI code for station or stations producing the ionosonde.
  ///  Example: /// Example: STATION-ID
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var stationId: String? { let o = _accessor.offset(VTOFFSET.stationId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var stationIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.stationId.v) }
  ///  Sounding Start time in ISO8601 UTC format.
  ///  Example: /// Example: 2021-01-01T01:01:01.123456Z
  ///  Constraints: No constraints specified.
  public var startTimeUtc: String? { let o = _accessor.offset(VTOFFSET.startTimeUtc.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var startTimeUtcSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.startTimeUtc.v) }
  ///  Names of settings.
  ///  Example: /// Example: Example settings
  ///  Constraints: Minimum length = 1, Maximum length = 1024
  public var systemInfo: String? { let o = _accessor.offset(VTOFFSET.systemInfo.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var systemInfoSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.systemInfo.v) }
  ///  Details concerning the composition/intention/interpretation/audience/etc. of any data recorded here. This field may contain all of the intended information e.g. info on signal waveforms used, antenna setup, etc. OR may describe the data/settings to be provided in the “data” field.
  ///  Example: /// Example: Example notes
  ///  Constraints: Minimum length = 0, Maximum length = 1024
  public var systemNotes: String? { let o = _accessor.offset(VTOFFSET.systemNotes.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var systemNotesSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.systemNotes.v) }
  ///  List of Geodetic Latitude, Longitude, and Altitude coordinates in km of the receiver. Coordinates List must always have 3 elements. Valid ranges are -90.0 to 90.0 for Latitude and -180.0 to 180.0 for Longitude. Altitude is in km and its value must be 0 or greater.
  ///  Example: /// Example: [[45.5, 179.3, 35.6], [-80.2, -20.5, 43.2]]
  ///  Constraints: No constraints specified.
  public var hasTransmitCoordinates: Bool { let o = _accessor.offset(VTOFFSET.transmitCoordinates.v); return o == 0 ? false : true }
  public var transmitCoordinatesCount: Int32 { let o = _accessor.offset(VTOFFSET.transmitCoordinates.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func transmitCoordinates(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.transmitCoordinates.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Enums: Mobile, Static.
  ///  Example: /// Example: Mobile
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var transmitSensorType: IonoObservation_Full_transmitSensorType_Enum { let o = _accessor.offset(VTOFFSET.transmitSensorType.v); return o == 0 ? .mobile : IonoObservation_Full_transmitSensorType_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .mobile }
  ///  List of Geodetic Latitude, Longitude, and Altitude coordinates in km of the receiver. Coordinates List must always have 3 elements. Valid ranges are -90.0 to 90.0 for Latitude and -180.0 to 180.0 for Longitude. Altitude is in km and its value must be 0 or greater.
  ///  Example: /// Example: [[45.5, 179.3, 35.6], [-80.2, -20.5, 43.2]]
  ///  Constraints: No constraints specified.
  public var hasReceiveCoordinates: Bool { let o = _accessor.offset(VTOFFSET.receiveCoordinates.v); return o == 0 ? false : true }
  public var receiveCoordinatesCount: Int32 { let o = _accessor.offset(VTOFFSET.receiveCoordinates.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func receiveCoordinates(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.receiveCoordinates.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Enums: Mobile, Static.
  ///  Example: /// Example: Mobile
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var receiveSensorType: IonoObservation_Full_receiveSensorType_Enum { let o = _accessor.offset(VTOFFSET.receiveSensorType.v); return o == 0 ? .mobile : IonoObservation_Full_receiveSensorType_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .mobile }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var antennaElementPosition: String? { let o = _accessor.offset(VTOFFSET.antennaElementPosition.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var antennaElementPositionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.antennaElementPosition.v) }
  ///  Enums: J2000, ECR/ECEF, TEME, GCRF, WGS84 (GEODetic lat, long, alt), GEOCentric (lat, long, radii).
  ///  Example: /// Example: J2000
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var antennaElementPositionCoordinateSystem: IonoObservation_Full_antennaElementPositionCoordinateSystem_Enum { let o = _accessor.offset(VTOFFSET.antennaElementPositionCoordinateSystem.v); return o == 0 ? .j2000 : IonoObservation_Full_antennaElementPositionCoordinateSystem_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .j2000 }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var power: String? { let o = _accessor.offset(VTOFFSET.power.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var powerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.power.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var range: String? { let o = _accessor.offset(VTOFFSET.range.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var rangeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.range.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var frequency: String? { let o = _accessor.offset(VTOFFSET.frequency.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var frequencySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.frequency.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var polarization: String? { let o = _accessor.offset(VTOFFSET.polarization.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var polarizationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.polarization.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var azimuth: String? { let o = _accessor.offset(VTOFFSET.azimuth.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var azimuthSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.azimuth.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var elevation: String? { let o = _accessor.offset(VTOFFSET.elevation.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var elevationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.elevation.v) }
  ///  Array of restricted frequencies.
  ///  Example: /// Example: [12.5, 34.5, 45.3]
  ///  Constraints: No constraints specified.
  public var hasRestrictedFrequency: Bool { let o = _accessor.offset(VTOFFSET.restrictedFrequency.v); return o == 0 ? false : true }
  public var restrictedFrequencyCount: Int32 { let o = _accessor.offset(VTOFFSET.restrictedFrequency.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func restrictedFrequency(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.restrictedFrequency.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Notes for the restrictedFrequency data.
  ///  Example: /// Example: Example notes
  ///  Constraints: Minimum length = 0, Maximum length = 512
  public var restrictedFrequencyNotes: String? { let o = _accessor.offset(VTOFFSET.restrictedFrequencyNotes.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var restrictedFrequencyNotesSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.restrictedFrequencyNotes.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var doppler: String? { let o = _accessor.offset(VTOFFSET.doppler.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var dopplerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.doppler.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var time: String? { let o = _accessor.offset(VTOFFSET.time.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var timeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.time.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var stokes: String? { let o = _accessor.offset(VTOFFSET.stokes.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var stokesSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.stokes.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var amplitude: String? { let o = _accessor.offset(VTOFFSET.amplitude.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var amplitudeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.amplitude.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var phase: String? { let o = _accessor.offset(VTOFFSET.phase.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var phaseSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.phase.v) }
  ///  The ordinary wave critical frequency of the highest stratification in the F region, specified in MHz. URSI ID: 00.
  ///  Example: /// Example: 6.75
  ///  Constraints: No constraints specified.
  public var foF2: Double { let o = _accessor.offset(VTOFFSET.foF2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The ordinary wave F1 critical frequency, in MHz. URSI ID: 10.
  ///  Example: /// Example: 8.2
  ///  Constraints: No constraints specified.
  public var foF1: Double { let o = _accessor.offset(VTOFFSET.foF1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The extraordinary wave F2 critical frequency, in MHz. URSI ID: 01.
  ///  Example: /// Example: 4.5
  ///  Constraints: No constraints specified.
  public var fxF2: Double { let o = _accessor.offset(VTOFFSET.fxF2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The extraordinary wave F1 critical frequency, in MHz. URSI ID: 11.
  ///  Example: /// Example: 4.2
  ///  Constraints: No constraints specified.
  public var fxF1: Double { let o = _accessor.offset(VTOFFSET.fxF1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  MUF(D)/foF2.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var md: Double { let o = _accessor.offset(VTOFFSET.md.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Lowest usable frequency.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var luf: Double { let o = _accessor.offset(VTOFFSET.luf.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum Usable Frequency for ground distance D in MHz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var mufd: Double { let o = _accessor.offset(VTOFFSET.mufd.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Lowest frequency at which echo traces are observed on the ionogram, in MHz. URSI ID: 42.
  ///  Example: /// Example: 2.025
  ///  Constraints: No constraints specified.
  public var fmin: Double { let o = _accessor.offset(VTOFFSET.fmin.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Highest ordinary wave frequency at which a mainly continuous Es trace is observed, in MHz. URSI ID: 30.
  ///  Example: /// Example: 2.35
  ///  Constraints: No constraints specified.
  public var foEs: Double { let o = _accessor.offset(VTOFFSET.foEs.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum frequency of F layer echoes in MHz. URSI ID: 80.
  ///  Example: /// Example: 2.7
  ///  Constraints: No constraints specified.
  public var fminF: Double { let o = _accessor.offset(VTOFFSET.fminF.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum frequency of E layer echoes in MHz. URSI ID: 81.
  ///  Example: /// Example: 2.025
  ///  Constraints: No constraints specified.
  public var fminE: Double { let o = _accessor.offset(VTOFFSET.fminE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The ordinary wave critical frequency of the lowest thick layer which causes a discontinuity, in MHz. URSI ID: 20.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var foE: Double { let o = _accessor.offset(VTOFFSET.foE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The extraordinary wave E critical frequency, in MHz. URSI ID: 21.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var fxE: Double { let o = _accessor.offset(VTOFFSET.fxE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The highest frequency of F-trace in MHz. Note: fxI is with capital i. URSI ID: 51.
  ///  Example: /// Example: 7.525
  ///  Constraints: No constraints specified.
  public var fxI: Double { let o = _accessor.offset(VTOFFSET.fxI.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The minimum virtual height of the ordinary wave trace taken as a whole, in km. URSI ID: 16.
  ///  Example: /// Example: 238.5
  ///  Constraints: No constraints specified.
  public var hprimeF: Double { let o = _accessor.offset(VTOFFSET.hprimeF.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The minimum virtual height of ordinary wave trace for the highest stable stratification in the F region in km. URSI ID: 4.
  ///  Example: /// Example: 238.5
  ///  Constraints: No constraints specified.
  public var hprimeF2: Double { let o = _accessor.offset(VTOFFSET.hprimeF2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The minimum virtual height of reflection at a point where the trace is horizontal in the F region in km. URSI ID: 14.
  ///  Example: /// Example: 230.1
  ///  Constraints: No constraints specified.
  public var hprimeF1: Double { let o = _accessor.offset(VTOFFSET.hprimeF1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The minimum virtual height of the normal E layer trace in km. URSI ID: 24.
  ///  Example: /// Example: 98.47
  ///  Constraints: No constraints specified.
  public var hprimeE: Double { let o = _accessor.offset(VTOFFSET.hprimeE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The minimum height of the trace used to give foEs in km. URSI ID: 34.
  ///  Example: /// Example: 95
  ///  Constraints: No constraints specified.
  public var hprimeEs: Double { let o = _accessor.offset(VTOFFSET.hprimeEs.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Peak height of E-layer in km. URSI ID: 90.
  ///  Example: /// Example: 91.744
  ///  Constraints: No constraints specified.
  public var zmE: Double { let o = _accessor.offset(VTOFFSET.zmE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Parabolic E layer semi-thickness in km. URSI ID: 83.
  ///  Example: /// Example: 1.722
  ///  Constraints: No constraints specified.
  public var yE: Double { let o = _accessor.offset(VTOFFSET.yE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Average range spread of F layer in km. URSI ID: 84.
  ///  Example: /// Example: 1.83
  ///  Constraints: No constraints specified.
  public var qf: Double { let o = _accessor.offset(VTOFFSET.qf.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Average range spread of E layer in km. URSI ID: 85.
  ///  Example: /// Example: 0.95
  ///  Constraints: No constraints specified.
  public var qe: Double { let o = _accessor.offset(VTOFFSET.qe.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Lowering of F trace to the leading edge in km.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var downF: Double { let o = _accessor.offset(VTOFFSET.downF.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Lowering of E trace to the leading edge in km.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var downE: Double { let o = _accessor.offset(VTOFFSET.downE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Lowering of Es trace to the leading edge in km.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var downEs: Double { let o = _accessor.offset(VTOFFSET.downEs.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Frequency spread between fxF2 and FxI in MHz. URSI ID: 86.
  ///  Example: /// Example: 0.075
  ///  Constraints: No constraints specified.
  public var ff: Double { let o = _accessor.offset(VTOFFSET.ff.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Frequency spread beyond foE in MHz. URSI ID: 87.
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var fe: Double { let o = _accessor.offset(VTOFFSET.fe.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Distance for MUF calculation in km.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var d: Double { let o = _accessor.offset(VTOFFSET.d.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  MUF/OblFactor in MHz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var fmuf: Double { let o = _accessor.offset(VTOFFSET.fmuf.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Virtual height at MUF/OblFactor frequency in MHz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var hprimefMuf: Double { let o = _accessor.offset(VTOFFSET.hprimefMuf.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Adjustment to the scaled foF2 during profile inversion in MHz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var deltafoF2: Double { let o = _accessor.offset(VTOFFSET.deltafoF2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Predicted value of foE in MHz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var foEp: Double { let o = _accessor.offset(VTOFFSET.foEp.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The frequency at which hprimeF is measured in MHz. URSI ID: 61.
  ///  Example: /// Example: 2.5
  ///  Constraints: No constraints specified.
  public var fhprimeF: Double { let o = _accessor.offset(VTOFFSET.fhprimeF.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The frequency at which hprimeF2 is measured in MHz. URSI ID: 60.
  ///  Example: /// Example: 2.5
  ///  Constraints: No constraints specified.
  public var fhprimeF2: Double { let o = _accessor.offset(VTOFFSET.fhprimeF2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Predicted value of foF1 in MHz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var foF1p: Double { let o = _accessor.offset(VTOFFSET.foF1p.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Predicted value of foF2 in MHz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var foF2p: Double { let o = _accessor.offset(VTOFFSET.foF2p.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  True height of the F2 peak in km. URSI ID: AE.
  ///  Example: /// Example: 240.498
  ///  Constraints: No constraints specified.
  public var hmF2: Double { let o = _accessor.offset(VTOFFSET.hmF2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  True height of the F1 peak in km. URSI ID: BE.
  ///  Example: /// Example: 230.128
  ///  Constraints: No constraints specified.
  public var hmF1: Double { let o = _accessor.offset(VTOFFSET.hmF1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  True height of the E peak in km. URSI ID: CE.
  ///  Example: /// Example: 215.643
  ///  Constraints: No constraints specified.
  public var hmE: Double { let o = _accessor.offset(VTOFFSET.hmE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  True height at half peak electron density in the F2 layer in km. URSI ID: 93.
  ///  Example: /// Example: 240.498
  ///  Constraints: No constraints specified.
  public var zhalfNm: Double { let o = _accessor.offset(VTOFFSET.zhalfNm.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum frequency of Es layer in MHz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var fminEs: Double { let o = _accessor.offset(VTOFFSET.fminEs.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Parabolic F2 layer semi-thickness in km. URSI ID: 94.
  ///  Example: /// Example: 62.178
  ///  Constraints: No constraints specified.
  public var yF2: Double { let o = _accessor.offset(VTOFFSET.yF2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Parabolic F1 layer semi-thickness in km. URSI ID: 95.
  ///  Example: /// Example: 55.645
  ///  Constraints: No constraints specified.
  public var yF1: Double { let o = _accessor.offset(VTOFFSET.yF1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Total Ionospheric Electron Content *10^16e/m^2. 1 TEC Unit (TECU) = 10^16 electrons/m^2. URSI ID: 72.
  ///  Example: /// Example: 24.673
  ///  Constraints: No constraints specified.
  public var tec: Double { let o = _accessor.offset(VTOFFSET.tec.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Effective scale height at hmF2 Titheridge method in km. URSI ID: 69.
  ///  Example: /// Example: 35.613
  ///  Constraints: No constraints specified.
  public var scaleHeightF2Peak: Double { let o = _accessor.offset(VTOFFSET.scaleHeightF2Peak.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  IRI thickness parameter in km. URSI ID: D0.
  ///  Example: /// Example: 68.07
  ///  Constraints: No constraints specified.
  public var b0: Double { let o = _accessor.offset(VTOFFSET.b0.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  IRI profile shape parameter. URSI ID: D1.
  ///  Example: /// Example: 1.87
  ///  Constraints: No constraints specified.
  public var b1: Double { let o = _accessor.offset(VTOFFSET.b1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  IRI profile shape parameter, F1 layer. URSI ID: D2.
  ///  Example: /// Example: 1.94
  ///  Constraints: No constraints specified.
  public var d1: Double { let o = _accessor.offset(VTOFFSET.d1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Critical frequency of night time auroral E layer in MHz. URSI ID: 23.
  ///  Example: /// Example: 45.764
  ///  Constraints: No constraints specified.
  public var foEa: Double { let o = _accessor.offset(VTOFFSET.foEa.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum virtual height of night time auroral E layer trace in km. URSI ID: 27.
  ///  Example: /// Example: 102.6
  ///  Constraints: No constraints specified.
  public var hprimeEa: Double { let o = _accessor.offset(VTOFFSET.hprimeEa.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Highest ordinary wave critical frequency of F region patch trace in MHz. URSI ID: 55.
  ///  Example: /// Example: 87.21
  ///  Constraints: No constraints specified.
  public var foP: Double { let o = _accessor.offset(VTOFFSET.foP.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum virtual height of the trace used to determine foP in km. URSI ID: 56.
  ///  Example: /// Example: 89.45
  ///  Constraints: No constraints specified.
  public var hprimeP: Double { let o = _accessor.offset(VTOFFSET.hprimeP.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The blanketing frequency of layer used to derive foEs in MHz. URSI ID: 32.
  ///  Example: /// Example: 34.867
  ///  Constraints: No constraints specified.
  public var fbEs: Double { let o = _accessor.offset(VTOFFSET.fbEs.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Characterization of the shape of Es trace. URSI ID: 36.
  ///  Example: /// Example: Auroral
  ///  Constraints: Minimum length = 0, Maximum length = 25
  public var typeEs: String? { let o = _accessor.offset(VTOFFSET.typeEs.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeEsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.typeEs.v) }
  ///  List of attributes that are associated with the specified characteristics. Characteristics are defined by the CHARS: URSI IIWG format for archiving monthly ionospheric characteristics, INAG Bulletin No. 62 specification. 
  ///  Qualifying and Descriptive letters are defined by the URSI Handbook for Ionogram Interpretation and reduction, Report UAG, No. 23A specification.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasCharAtts: Bool { let o = _accessor.offset(VTOFFSET.charAtts.v); return o == 0 ? false : true }
  public var charAttsCount: Int32 { let o = _accessor.offset(VTOFFSET.charAtts.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func charAtts(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.charAtts.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of altitudes above station level for plasma frequency/density arrays in km (must match the size of the plasmaFrequency and electronDensity Arrays).
  ///  Example: /// Example: [1.1, 2.1, 3.1]
  ///  Constraints: No constraints specified.
  public var hasHeight: Bool { let o = _accessor.offset(VTOFFSET.height.v); return o == 0 ? false : true }
  public var heightCount: Int32 { let o = _accessor.offset(VTOFFSET.height.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func height(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.height.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of plasma frequencies in MHz (must match the size of the height and electronDensity arrays).
  ///  Example: /// Example: [1.1, 2.1, 3.1]
  ///  Constraints: No constraints specified.
  public var hasPlasmaFrequency: Bool { let o = _accessor.offset(VTOFFSET.plasmaFrequency.v); return o == 0 ? false : true }
  public var plasmaFrequencyCount: Int32 { let o = _accessor.offset(VTOFFSET.plasmaFrequency.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func plasmaFrequency(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.plasmaFrequency.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Uncertainty in specifying the electron plasma frequency at each height point of the profile (must match the size of the plasmaFrequency array).
  ///  Example: /// Example: [0.8, 0.2, 0.5]
  ///  Constraints: No constraints specified.
  public var hasPlasmaFrequencyUncertainty: Bool { let o = _accessor.offset(VTOFFSET.plasmaFrequencyUncertainty.v); return o == 0 ? false : true }
  public var plasmaFrequencyUncertaintyCount: Int32 { let o = _accessor.offset(VTOFFSET.plasmaFrequencyUncertainty.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func plasmaFrequencyUncertainty(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.plasmaFrequencyUncertainty.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of electron densities in cm^-3 (must match the size of the height and plasmaFrequency arrays).
  ///  Example: /// Example: [1.1, 2.1, 3.1]
  ///  Constraints: No constraints specified.
  public var hasElectronDensity: Bool { let o = _accessor.offset(VTOFFSET.electronDensity.v); return o == 0 ? false : true }
  public var electronDensityCount: Int32 { let o = _accessor.offset(VTOFFSET.electronDensity.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func electronDensity(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.electronDensity.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Uncertainty in specifying the electron density at each height point of the profile (must match the size of the electronDensity array).
  ///  Example: /// Example: [0.8, 0.2, 0.5]
  ///  Constraints: No constraints specified.
  public var hasElectronDensityUncertainty: Bool { let o = _accessor.offset(VTOFFSET.electronDensityUncertainty.v); return o == 0 ? false : true }
  public var electronDensityUncertaintyCount: Int32 { let o = _accessor.offset(VTOFFSET.electronDensityUncertainty.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func electronDensityUncertainty(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.electronDensityUncertainty.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of Legacy Artist Flags.
  ///  Example: /// Example: [1, 2, 3]
  ///  Constraints: No constraints specified.
  public var hasArtistFlags: Bool { let o = _accessor.offset(VTOFFSET.artistFlags.v); return o == 0 ? false : true }
  public var artistFlagsCount: Int32 { let o = _accessor.offset(VTOFFSET.artistFlags.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func artistFlags(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.artistFlags.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var traceGeneric: String? { let o = _accessor.offset(VTOFFSET.traceGeneric.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var traceGenericSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.traceGeneric.v) }
  ///  Array of speed in m/s at which the disturbance travels through the ionosphere.
  ///  Example: /// Example: [1.1, 2.1, 3.1]
  ///  Constraints: No constraints specified.
  public var hasTidPhaseSpeeds: Bool { let o = _accessor.offset(VTOFFSET.tidPhaseSpeeds.v); return o == 0 ? false : true }
  public var tidPhaseSpeedsCount: Int32 { let o = _accessor.offset(VTOFFSET.tidPhaseSpeeds.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tidPhaseSpeeds(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tidPhaseSpeeds.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of degrees clockwise from true North of the TID.
  ///  Example: /// Example: [1.1, 2.1, 3.1]
  ///  Constraints: No constraints specified.
  public var hasTidAzimuth: Bool { let o = _accessor.offset(VTOFFSET.tidAzimuth.v); return o == 0 ? false : true }
  public var tidAzimuthCount: Int32 { let o = _accessor.offset(VTOFFSET.tidAzimuth.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tidAzimuth(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tidAzimuth.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of 1/frequency of the TID wave.
  ///  Example: /// Example: [1.1, 2.1, 3.1]
  ///  Constraints: No constraints specified.
  public var hasTidPeriods: Bool { let o = _accessor.offset(VTOFFSET.tidPeriods.v); return o == 0 ? false : true }
  public var tidPeriodsCount: Int32 { let o = _accessor.offset(VTOFFSET.tidPeriods.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tidPeriods(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tidPeriods.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var datum: String? { let o = _accessor.offset(VTOFFSET.datum.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var datumSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.datum.v) }
  ///  Equipment location.
  ///  Example: /// Example: Millstone Hill
  ///  Constraints: Minimum length = 0, Maximum length = 512
  public var platformName: String? { let o = _accessor.offset(VTOFFSET.platformName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var platformNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.platformName.v) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Time the row was updated in the database, auto-populated by the system, example = 2018-01-01T16:00:00.123Z.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var updatedAt: String? { let o = _accessor.offset(VTOFFSET.updatedAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedAt.v) }
  ///  Application user who updated the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var updatedBy: String? { let o = _accessor.offset(VTOFFSET.updatedBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: IonoObservation_Full_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : IonoObservation_Full_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  public static func startIonoObservation_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 108) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(idSensor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSensor, at: VTOFFSET.idSensor.p) }
  public static func add(origSensorId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origSensorId, at: VTOFFSET.origSensorId.p) }
  public static func add(system: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: system, at: VTOFFSET.system.p) }
  public static func add(neProfileName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: neProfileName, at: VTOFFSET.neProfileName.p) }
  public static func add(neProfileVersion: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: neProfileVersion, def: 0.0, at: VTOFFSET.neProfileVersion.p) }
  public static func add(scalerInfo: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: scalerInfo, at: VTOFFSET.scalerInfo.p) }
  public static func add(densityProfile: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: densityProfile, at: VTOFFSET.densityProfile.p) }
  public static func add(stationId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: stationId, at: VTOFFSET.stationId.p) }
  public static func add(startTimeUtc: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startTimeUtc, at: VTOFFSET.startTimeUtc.p) }
  public static func add(systemInfo: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: systemInfo, at: VTOFFSET.systemInfo.p) }
  public static func add(systemNotes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: systemNotes, at: VTOFFSET.systemNotes.p) }
  public static func addVectorOf(transmitCoordinates: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: transmitCoordinates, at: VTOFFSET.transmitCoordinates.p) }
  public static func add(transmitSensorType: IonoObservation_Full_transmitSensorType_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: transmitSensorType.rawValue, def: 0, at: VTOFFSET.transmitSensorType.p) }
  public static func addVectorOf(receiveCoordinates: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: receiveCoordinates, at: VTOFFSET.receiveCoordinates.p) }
  public static func add(receiveSensorType: IonoObservation_Full_receiveSensorType_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: receiveSensorType.rawValue, def: 0, at: VTOFFSET.receiveSensorType.p) }
  public static func add(antennaElementPosition: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: antennaElementPosition, at: VTOFFSET.antennaElementPosition.p) }
  public static func add(antennaElementPositionCoordinateSystem: IonoObservation_Full_antennaElementPositionCoordinateSystem_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: antennaElementPositionCoordinateSystem.rawValue, def: 0, at: VTOFFSET.antennaElementPositionCoordinateSystem.p) }
  public static func add(power: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: power, at: VTOFFSET.power.p) }
  public static func add(range: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: range, at: VTOFFSET.range.p) }
  public static func add(frequency: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: frequency, at: VTOFFSET.frequency.p) }
  public static func add(polarization: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: polarization, at: VTOFFSET.polarization.p) }
  public static func add(azimuth: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: azimuth, at: VTOFFSET.azimuth.p) }
  public static func add(elevation: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: elevation, at: VTOFFSET.elevation.p) }
  public static func addVectorOf(restrictedFrequency: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: restrictedFrequency, at: VTOFFSET.restrictedFrequency.p) }
  public static func add(restrictedFrequencyNotes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: restrictedFrequencyNotes, at: VTOFFSET.restrictedFrequencyNotes.p) }
  public static func add(doppler: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: doppler, at: VTOFFSET.doppler.p) }
  public static func add(time: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: time, at: VTOFFSET.time.p) }
  public static func add(stokes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: stokes, at: VTOFFSET.stokes.p) }
  public static func add(amplitude: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: amplitude, at: VTOFFSET.amplitude.p) }
  public static func add(phase: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: phase, at: VTOFFSET.phase.p) }
  public static func add(foF2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: foF2, def: 0.0, at: VTOFFSET.foF2.p) }
  public static func add(foF1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: foF1, def: 0.0, at: VTOFFSET.foF1.p) }
  public static func add(fxF2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fxF2, def: 0.0, at: VTOFFSET.fxF2.p) }
  public static func add(fxF1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fxF1, def: 0.0, at: VTOFFSET.fxF1.p) }
  public static func add(md: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: md, def: 0.0, at: VTOFFSET.md.p) }
  public static func add(luf: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: luf, def: 0.0, at: VTOFFSET.luf.p) }
  public static func add(mufd: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mufd, def: 0.0, at: VTOFFSET.mufd.p) }
  public static func add(fmin: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fmin, def: 0.0, at: VTOFFSET.fmin.p) }
  public static func add(foEs: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: foEs, def: 0.0, at: VTOFFSET.foEs.p) }
  public static func add(fminF: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fminF, def: 0.0, at: VTOFFSET.fminF.p) }
  public static func add(fminE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fminE, def: 0.0, at: VTOFFSET.fminE.p) }
  public static func add(foE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: foE, def: 0.0, at: VTOFFSET.foE.p) }
  public static func add(fxE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fxE, def: 0.0, at: VTOFFSET.fxE.p) }
  public static func add(fxI: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fxI, def: 0.0, at: VTOFFSET.fxI.p) }
  public static func add(hprimeF: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hprimeF, def: 0.0, at: VTOFFSET.hprimeF.p) }
  public static func add(hprimeF2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hprimeF2, def: 0.0, at: VTOFFSET.hprimeF2.p) }
  public static func add(hprimeF1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hprimeF1, def: 0.0, at: VTOFFSET.hprimeF1.p) }
  public static func add(hprimeE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hprimeE, def: 0.0, at: VTOFFSET.hprimeE.p) }
  public static func add(hprimeEs: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hprimeEs, def: 0.0, at: VTOFFSET.hprimeEs.p) }
  public static func add(zmE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zmE, def: 0.0, at: VTOFFSET.zmE.p) }
  public static func add(yE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: yE, def: 0.0, at: VTOFFSET.yE.p) }
  public static func add(qf: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: qf, def: 0.0, at: VTOFFSET.qf.p) }
  public static func add(qe: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: qe, def: 0.0, at: VTOFFSET.qe.p) }
  public static func add(downF: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: downF, def: 0.0, at: VTOFFSET.downF.p) }
  public static func add(downE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: downE, def: 0.0, at: VTOFFSET.downE.p) }
  public static func add(downEs: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: downEs, def: 0.0, at: VTOFFSET.downEs.p) }
  public static func add(ff: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ff, def: 0.0, at: VTOFFSET.ff.p) }
  public static func add(fe: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fe, def: 0.0, at: VTOFFSET.fe.p) }
  public static func add(d: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: d, def: 0.0, at: VTOFFSET.d.p) }
  public static func add(fmuf: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fmuf, def: 0.0, at: VTOFFSET.fmuf.p) }
  public static func add(hprimefMuf: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hprimefMuf, def: 0.0, at: VTOFFSET.hprimefMuf.p) }
  public static func add(deltafoF2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: deltafoF2, def: 0.0, at: VTOFFSET.deltafoF2.p) }
  public static func add(foEp: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: foEp, def: 0.0, at: VTOFFSET.foEp.p) }
  public static func add(fhprimeF: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fhprimeF, def: 0.0, at: VTOFFSET.fhprimeF.p) }
  public static func add(fhprimeF2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fhprimeF2, def: 0.0, at: VTOFFSET.fhprimeF2.p) }
  public static func add(foF1p: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: foF1p, def: 0.0, at: VTOFFSET.foF1p.p) }
  public static func add(foF2p: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: foF2p, def: 0.0, at: VTOFFSET.foF2p.p) }
  public static func add(hmF2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hmF2, def: 0.0, at: VTOFFSET.hmF2.p) }
  public static func add(hmF1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hmF1, def: 0.0, at: VTOFFSET.hmF1.p) }
  public static func add(hmE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hmE, def: 0.0, at: VTOFFSET.hmE.p) }
  public static func add(zhalfNm: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zhalfNm, def: 0.0, at: VTOFFSET.zhalfNm.p) }
  public static func add(fminEs: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fminEs, def: 0.0, at: VTOFFSET.fminEs.p) }
  public static func add(yF2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: yF2, def: 0.0, at: VTOFFSET.yF2.p) }
  public static func add(yF1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: yF1, def: 0.0, at: VTOFFSET.yF1.p) }
  public static func add(tec: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tec, def: 0.0, at: VTOFFSET.tec.p) }
  public static func add(scaleHeightF2Peak: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: scaleHeightF2Peak, def: 0.0, at: VTOFFSET.scaleHeightF2Peak.p) }
  public static func add(b0: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: b0, def: 0.0, at: VTOFFSET.b0.p) }
  public static func add(b1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: b1, def: 0.0, at: VTOFFSET.b1.p) }
  public static func add(d1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: d1, def: 0.0, at: VTOFFSET.d1.p) }
  public static func add(foEa: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: foEa, def: 0.0, at: VTOFFSET.foEa.p) }
  public static func add(hprimeEa: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hprimeEa, def: 0.0, at: VTOFFSET.hprimeEa.p) }
  public static func add(foP: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: foP, def: 0.0, at: VTOFFSET.foP.p) }
  public static func add(hprimeP: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hprimeP, def: 0.0, at: VTOFFSET.hprimeP.p) }
  public static func add(fbEs: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fbEs, def: 0.0, at: VTOFFSET.fbEs.p) }
  public static func add(typeEs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: typeEs, at: VTOFFSET.typeEs.p) }
  public static func addVectorOf(charAtts: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: charAtts, at: VTOFFSET.charAtts.p) }
  public static func addVectorOf(height: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: height, at: VTOFFSET.height.p) }
  public static func addVectorOf(plasmaFrequency: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: plasmaFrequency, at: VTOFFSET.plasmaFrequency.p) }
  public static func addVectorOf(plasmaFrequencyUncertainty: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: plasmaFrequencyUncertainty, at: VTOFFSET.plasmaFrequencyUncertainty.p) }
  public static func addVectorOf(electronDensity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: electronDensity, at: VTOFFSET.electronDensity.p) }
  public static func addVectorOf(electronDensityUncertainty: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: electronDensityUncertainty, at: VTOFFSET.electronDensityUncertainty.p) }
  public static func addVectorOf(artistFlags: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: artistFlags, at: VTOFFSET.artistFlags.p) }
  public static func add(traceGeneric: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: traceGeneric, at: VTOFFSET.traceGeneric.p) }
  public static func addVectorOf(tidPhaseSpeeds: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tidPhaseSpeeds, at: VTOFFSET.tidPhaseSpeeds.p) }
  public static func addVectorOf(tidAzimuth: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tidAzimuth, at: VTOFFSET.tidAzimuth.p) }
  public static func addVectorOf(tidPeriods: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tidPeriods, at: VTOFFSET.tidPeriods.p) }
  public static func add(datum: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: datum, at: VTOFFSET.datum.p) }
  public static func add(platformName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: platformName, at: VTOFFSET.platformName.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(updatedAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedAt, at: VTOFFSET.updatedAt.p) }
  public static func add(updatedBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedBy, at: VTOFFSET.updatedBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(dataMode: IonoObservation_Full_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func endIonoObservation_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createIonoObservation_Full(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    idSensorOffset idSensor: Offset = Offset(),
    origSensorIdOffset origSensorId: Offset = Offset(),
    systemOffset system: Offset = Offset(),
    neProfileNameOffset neProfileName: Offset = Offset(),
    neProfileVersion: Double = 0.0,
    scalerInfoOffset scalerInfo: Offset = Offset(),
    densityProfileOffset densityProfile: Offset = Offset(),
    stationIdOffset stationId: Offset = Offset(),
    startTimeUtcOffset startTimeUtc: Offset = Offset(),
    systemInfoOffset systemInfo: Offset = Offset(),
    systemNotesOffset systemNotes: Offset = Offset(),
    transmitCoordinatesVectorOffset transmitCoordinates: Offset = Offset(),
    transmitSensorType: IonoObservation_Full_transmitSensorType_Enum = .mobile,
    receiveCoordinatesVectorOffset receiveCoordinates: Offset = Offset(),
    receiveSensorType: IonoObservation_Full_receiveSensorType_Enum = .mobile,
    antennaElementPositionOffset antennaElementPosition: Offset = Offset(),
    antennaElementPositionCoordinateSystem: IonoObservation_Full_antennaElementPositionCoordinateSystem_Enum = .j2000,
    powerOffset power: Offset = Offset(),
    rangeOffset range: Offset = Offset(),
    frequencyOffset frequency: Offset = Offset(),
    polarizationOffset polarization: Offset = Offset(),
    azimuthOffset azimuth: Offset = Offset(),
    elevationOffset elevation: Offset = Offset(),
    restrictedFrequencyVectorOffset restrictedFrequency: Offset = Offset(),
    restrictedFrequencyNotesOffset restrictedFrequencyNotes: Offset = Offset(),
    dopplerOffset doppler: Offset = Offset(),
    timeOffset time: Offset = Offset(),
    stokesOffset stokes: Offset = Offset(),
    amplitudeOffset amplitude: Offset = Offset(),
    phaseOffset phase: Offset = Offset(),
    foF2: Double = 0.0,
    foF1: Double = 0.0,
    fxF2: Double = 0.0,
    fxF1: Double = 0.0,
    md: Double = 0.0,
    luf: Double = 0.0,
    mufd: Double = 0.0,
    fmin: Double = 0.0,
    foEs: Double = 0.0,
    fminF: Double = 0.0,
    fminE: Double = 0.0,
    foE: Double = 0.0,
    fxE: Double = 0.0,
    fxI: Double = 0.0,
    hprimeF: Double = 0.0,
    hprimeF2: Double = 0.0,
    hprimeF1: Double = 0.0,
    hprimeE: Double = 0.0,
    hprimeEs: Double = 0.0,
    zmE: Double = 0.0,
    yE: Double = 0.0,
    qf: Double = 0.0,
    qe: Double = 0.0,
    downF: Double = 0.0,
    downE: Double = 0.0,
    downEs: Double = 0.0,
    ff: Double = 0.0,
    fe: Double = 0.0,
    d: Double = 0.0,
    fmuf: Double = 0.0,
    hprimefMuf: Double = 0.0,
    deltafoF2: Double = 0.0,
    foEp: Double = 0.0,
    fhprimeF: Double = 0.0,
    fhprimeF2: Double = 0.0,
    foF1p: Double = 0.0,
    foF2p: Double = 0.0,
    hmF2: Double = 0.0,
    hmF1: Double = 0.0,
    hmE: Double = 0.0,
    zhalfNm: Double = 0.0,
    fminEs: Double = 0.0,
    yF2: Double = 0.0,
    yF1: Double = 0.0,
    tec: Double = 0.0,
    scaleHeightF2Peak: Double = 0.0,
    b0: Double = 0.0,
    b1: Double = 0.0,
    d1: Double = 0.0,
    foEa: Double = 0.0,
    hprimeEa: Double = 0.0,
    foP: Double = 0.0,
    hprimeP: Double = 0.0,
    fbEs: Double = 0.0,
    typeEsOffset typeEs: Offset = Offset(),
    charAttsVectorOffset charAtts: Offset = Offset(),
    heightVectorOffset height: Offset = Offset(),
    plasmaFrequencyVectorOffset plasmaFrequency: Offset = Offset(),
    plasmaFrequencyUncertaintyVectorOffset plasmaFrequencyUncertainty: Offset = Offset(),
    electronDensityVectorOffset electronDensity: Offset = Offset(),
    electronDensityUncertaintyVectorOffset electronDensityUncertainty: Offset = Offset(),
    artistFlagsVectorOffset artistFlags: Offset = Offset(),
    traceGenericOffset traceGeneric: Offset = Offset(),
    tidPhaseSpeedsVectorOffset tidPhaseSpeeds: Offset = Offset(),
    tidAzimuthVectorOffset tidAzimuth: Offset = Offset(),
    tidPeriodsVectorOffset tidPeriods: Offset = Offset(),
    datumOffset datum: Offset = Offset(),
    platformNameOffset platformName: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    updatedAtOffset updatedAt: Offset = Offset(),
    updatedByOffset updatedBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    dataMode: IonoObservation_Full_dataMode_Enum = .real,
    origNetworkOffset origNetwork: Offset = Offset()
  ) -> Offset {
    let __start = IonoObservation_Full.startIonoObservation_Full(&fbb)
    IonoObservation_Full.add(id: id, &fbb)
    IonoObservation_Full.add(classificationMarking: classificationMarking, &fbb)
    IonoObservation_Full.add(idSensor: idSensor, &fbb)
    IonoObservation_Full.add(origSensorId: origSensorId, &fbb)
    IonoObservation_Full.add(system: system, &fbb)
    IonoObservation_Full.add(neProfileName: neProfileName, &fbb)
    IonoObservation_Full.add(neProfileVersion: neProfileVersion, &fbb)
    IonoObservation_Full.add(scalerInfo: scalerInfo, &fbb)
    IonoObservation_Full.add(densityProfile: densityProfile, &fbb)
    IonoObservation_Full.add(stationId: stationId, &fbb)
    IonoObservation_Full.add(startTimeUtc: startTimeUtc, &fbb)
    IonoObservation_Full.add(systemInfo: systemInfo, &fbb)
    IonoObservation_Full.add(systemNotes: systemNotes, &fbb)
    IonoObservation_Full.addVectorOf(transmitCoordinates: transmitCoordinates, &fbb)
    IonoObservation_Full.add(transmitSensorType: transmitSensorType, &fbb)
    IonoObservation_Full.addVectorOf(receiveCoordinates: receiveCoordinates, &fbb)
    IonoObservation_Full.add(receiveSensorType: receiveSensorType, &fbb)
    IonoObservation_Full.add(antennaElementPosition: antennaElementPosition, &fbb)
    IonoObservation_Full.add(antennaElementPositionCoordinateSystem: antennaElementPositionCoordinateSystem, &fbb)
    IonoObservation_Full.add(power: power, &fbb)
    IonoObservation_Full.add(range: range, &fbb)
    IonoObservation_Full.add(frequency: frequency, &fbb)
    IonoObservation_Full.add(polarization: polarization, &fbb)
    IonoObservation_Full.add(azimuth: azimuth, &fbb)
    IonoObservation_Full.add(elevation: elevation, &fbb)
    IonoObservation_Full.addVectorOf(restrictedFrequency: restrictedFrequency, &fbb)
    IonoObservation_Full.add(restrictedFrequencyNotes: restrictedFrequencyNotes, &fbb)
    IonoObservation_Full.add(doppler: doppler, &fbb)
    IonoObservation_Full.add(time: time, &fbb)
    IonoObservation_Full.add(stokes: stokes, &fbb)
    IonoObservation_Full.add(amplitude: amplitude, &fbb)
    IonoObservation_Full.add(phase: phase, &fbb)
    IonoObservation_Full.add(foF2: foF2, &fbb)
    IonoObservation_Full.add(foF1: foF1, &fbb)
    IonoObservation_Full.add(fxF2: fxF2, &fbb)
    IonoObservation_Full.add(fxF1: fxF1, &fbb)
    IonoObservation_Full.add(md: md, &fbb)
    IonoObservation_Full.add(luf: luf, &fbb)
    IonoObservation_Full.add(mufd: mufd, &fbb)
    IonoObservation_Full.add(fmin: fmin, &fbb)
    IonoObservation_Full.add(foEs: foEs, &fbb)
    IonoObservation_Full.add(fminF: fminF, &fbb)
    IonoObservation_Full.add(fminE: fminE, &fbb)
    IonoObservation_Full.add(foE: foE, &fbb)
    IonoObservation_Full.add(fxE: fxE, &fbb)
    IonoObservation_Full.add(fxI: fxI, &fbb)
    IonoObservation_Full.add(hprimeF: hprimeF, &fbb)
    IonoObservation_Full.add(hprimeF2: hprimeF2, &fbb)
    IonoObservation_Full.add(hprimeF1: hprimeF1, &fbb)
    IonoObservation_Full.add(hprimeE: hprimeE, &fbb)
    IonoObservation_Full.add(hprimeEs: hprimeEs, &fbb)
    IonoObservation_Full.add(zmE: zmE, &fbb)
    IonoObservation_Full.add(yE: yE, &fbb)
    IonoObservation_Full.add(qf: qf, &fbb)
    IonoObservation_Full.add(qe: qe, &fbb)
    IonoObservation_Full.add(downF: downF, &fbb)
    IonoObservation_Full.add(downE: downE, &fbb)
    IonoObservation_Full.add(downEs: downEs, &fbb)
    IonoObservation_Full.add(ff: ff, &fbb)
    IonoObservation_Full.add(fe: fe, &fbb)
    IonoObservation_Full.add(d: d, &fbb)
    IonoObservation_Full.add(fmuf: fmuf, &fbb)
    IonoObservation_Full.add(hprimefMuf: hprimefMuf, &fbb)
    IonoObservation_Full.add(deltafoF2: deltafoF2, &fbb)
    IonoObservation_Full.add(foEp: foEp, &fbb)
    IonoObservation_Full.add(fhprimeF: fhprimeF, &fbb)
    IonoObservation_Full.add(fhprimeF2: fhprimeF2, &fbb)
    IonoObservation_Full.add(foF1p: foF1p, &fbb)
    IonoObservation_Full.add(foF2p: foF2p, &fbb)
    IonoObservation_Full.add(hmF2: hmF2, &fbb)
    IonoObservation_Full.add(hmF1: hmF1, &fbb)
    IonoObservation_Full.add(hmE: hmE, &fbb)
    IonoObservation_Full.add(zhalfNm: zhalfNm, &fbb)
    IonoObservation_Full.add(fminEs: fminEs, &fbb)
    IonoObservation_Full.add(yF2: yF2, &fbb)
    IonoObservation_Full.add(yF1: yF1, &fbb)
    IonoObservation_Full.add(tec: tec, &fbb)
    IonoObservation_Full.add(scaleHeightF2Peak: scaleHeightF2Peak, &fbb)
    IonoObservation_Full.add(b0: b0, &fbb)
    IonoObservation_Full.add(b1: b1, &fbb)
    IonoObservation_Full.add(d1: d1, &fbb)
    IonoObservation_Full.add(foEa: foEa, &fbb)
    IonoObservation_Full.add(hprimeEa: hprimeEa, &fbb)
    IonoObservation_Full.add(foP: foP, &fbb)
    IonoObservation_Full.add(hprimeP: hprimeP, &fbb)
    IonoObservation_Full.add(fbEs: fbEs, &fbb)
    IonoObservation_Full.add(typeEs: typeEs, &fbb)
    IonoObservation_Full.addVectorOf(charAtts: charAtts, &fbb)
    IonoObservation_Full.addVectorOf(height: height, &fbb)
    IonoObservation_Full.addVectorOf(plasmaFrequency: plasmaFrequency, &fbb)
    IonoObservation_Full.addVectorOf(plasmaFrequencyUncertainty: plasmaFrequencyUncertainty, &fbb)
    IonoObservation_Full.addVectorOf(electronDensity: electronDensity, &fbb)
    IonoObservation_Full.addVectorOf(electronDensityUncertainty: electronDensityUncertainty, &fbb)
    IonoObservation_Full.addVectorOf(artistFlags: artistFlags, &fbb)
    IonoObservation_Full.add(traceGeneric: traceGeneric, &fbb)
    IonoObservation_Full.addVectorOf(tidPhaseSpeeds: tidPhaseSpeeds, &fbb)
    IonoObservation_Full.addVectorOf(tidAzimuth: tidAzimuth, &fbb)
    IonoObservation_Full.addVectorOf(tidPeriods: tidPeriods, &fbb)
    IonoObservation_Full.add(datum: datum, &fbb)
    IonoObservation_Full.add(platformName: platformName, &fbb)
    IonoObservation_Full.add(createdAt: createdAt, &fbb)
    IonoObservation_Full.add(createdBy: createdBy, &fbb)
    IonoObservation_Full.add(updatedAt: updatedAt, &fbb)
    IonoObservation_Full.add(updatedBy: updatedBy, &fbb)
    IonoObservation_Full.add(source: source, &fbb)
    IonoObservation_Full.add(origin: origin, &fbb)
    IonoObservation_Full.add(dataMode: dataMode, &fbb)
    IonoObservation_Full.add(origNetwork: origNetwork, &fbb)
    return IonoObservation_Full.endIonoObservation_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idSensor.p, fieldName: "idSensor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origSensorId.p, fieldName: "origSensorId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.system.p, fieldName: "system", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.neProfileName.p, fieldName: "neProfileName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.neProfileVersion.p, fieldName: "neProfileVersion", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.scalerInfo.p, fieldName: "scalerInfo", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.densityProfile.p, fieldName: "densityProfile", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.stationId.p, fieldName: "stationId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.startTimeUtc.p, fieldName: "startTimeUtc", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.systemInfo.p, fieldName: "systemInfo", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.systemNotes.p, fieldName: "systemNotes", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.transmitCoordinates.p, fieldName: "transmitCoordinates", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.transmitSensorType.p, fieldName: "transmitSensorType", required: false, type: IonoObservation_Full_transmitSensorType_Enum.self)
    try _v.visit(field: VTOFFSET.receiveCoordinates.p, fieldName: "receiveCoordinates", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.receiveSensorType.p, fieldName: "receiveSensorType", required: false, type: IonoObservation_Full_receiveSensorType_Enum.self)
    try _v.visit(field: VTOFFSET.antennaElementPosition.p, fieldName: "antennaElementPosition", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.antennaElementPositionCoordinateSystem.p, fieldName: "antennaElementPositionCoordinateSystem", required: false, type: IonoObservation_Full_antennaElementPositionCoordinateSystem_Enum.self)
    try _v.visit(field: VTOFFSET.power.p, fieldName: "power", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.range.p, fieldName: "range", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.frequency.p, fieldName: "frequency", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.polarization.p, fieldName: "polarization", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.azimuth.p, fieldName: "azimuth", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.elevation.p, fieldName: "elevation", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.restrictedFrequency.p, fieldName: "restrictedFrequency", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.restrictedFrequencyNotes.p, fieldName: "restrictedFrequencyNotes", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.doppler.p, fieldName: "doppler", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.time.p, fieldName: "time", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.stokes.p, fieldName: "stokes", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.amplitude.p, fieldName: "amplitude", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.phase.p, fieldName: "phase", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.foF2.p, fieldName: "foF2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.foF1.p, fieldName: "foF1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fxF2.p, fieldName: "fxF2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fxF1.p, fieldName: "fxF1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.md.p, fieldName: "md", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.luf.p, fieldName: "luf", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.mufd.p, fieldName: "mufd", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fmin.p, fieldName: "fmin", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.foEs.p, fieldName: "foEs", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fminF.p, fieldName: "fminF", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fminE.p, fieldName: "fminE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.foE.p, fieldName: "foE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fxE.p, fieldName: "fxE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fxI.p, fieldName: "fxI", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hprimeF.p, fieldName: "hprimeF", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hprimeF2.p, fieldName: "hprimeF2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hprimeF1.p, fieldName: "hprimeF1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hprimeE.p, fieldName: "hprimeE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hprimeEs.p, fieldName: "hprimeEs", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.zmE.p, fieldName: "zmE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.yE.p, fieldName: "yE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.qf.p, fieldName: "qf", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.qe.p, fieldName: "qe", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.downF.p, fieldName: "downF", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.downE.p, fieldName: "downE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.downEs.p, fieldName: "downEs", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ff.p, fieldName: "ff", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fe.p, fieldName: "fe", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.d.p, fieldName: "d", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fmuf.p, fieldName: "fmuf", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hprimefMuf.p, fieldName: "hprimefMuf", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.deltafoF2.p, fieldName: "deltafoF2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.foEp.p, fieldName: "foEp", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fhprimeF.p, fieldName: "fhprimeF", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fhprimeF2.p, fieldName: "fhprimeF2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.foF1p.p, fieldName: "foF1p", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.foF2p.p, fieldName: "foF2p", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hmF2.p, fieldName: "hmF2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hmF1.p, fieldName: "hmF1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hmE.p, fieldName: "hmE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.zhalfNm.p, fieldName: "zhalfNm", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fminEs.p, fieldName: "fminEs", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.yF2.p, fieldName: "yF2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.yF1.p, fieldName: "yF1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.tec.p, fieldName: "tec", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.scaleHeightF2Peak.p, fieldName: "scaleHeightF2Peak", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.b0.p, fieldName: "b0", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.b1.p, fieldName: "b1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.d1.p, fieldName: "d1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.foEa.p, fieldName: "foEa", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hprimeEa.p, fieldName: "hprimeEa", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.foP.p, fieldName: "foP", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hprimeP.p, fieldName: "hprimeP", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fbEs.p, fieldName: "fbEs", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.typeEs.p, fieldName: "typeEs", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.charAtts.p, fieldName: "charAtts", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.height.p, fieldName: "height", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.plasmaFrequency.p, fieldName: "plasmaFrequency", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.plasmaFrequencyUncertainty.p, fieldName: "plasmaFrequencyUncertainty", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.electronDensity.p, fieldName: "electronDensity", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.electronDensityUncertainty.p, fieldName: "electronDensityUncertainty", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.artistFlags.p, fieldName: "artistFlags", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.traceGeneric.p, fieldName: "traceGeneric", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.tidPhaseSpeeds.p, fieldName: "tidPhaseSpeeds", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.tidAzimuth.p, fieldName: "tidAzimuth", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.tidPeriods.p, fieldName: "tidPeriods", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.datum.p, fieldName: "datum", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.platformName.p, fieldName: "platformName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedAt.p, fieldName: "updatedAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedBy.p, fieldName: "updatedBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: IonoObservation_Full_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

