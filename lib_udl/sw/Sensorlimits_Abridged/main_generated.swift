// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Sensorlimits_Abridged_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: Sensorlimits_Abridged_dataMode_Enum { return .exercise }
  public static var min: Sensorlimits_Abridged_dataMode_Enum { return .real }
}


///  /// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
public struct Sensorlimits_Abridged: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "SENS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Sensorlimits_Abridged.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case idSensorLimits = 4
    case classificationMarking = 6
    case origNetwork = 8
    case upperLeftAzimuthLimit = 10
    case upperRightAzimuthLimit = 12
    case lowerRightAzimuthLimit = 14
    case lowerLeftAzimuthLimit = 16
    case lowerLeftElevationLimit = 18
    case upperLeftElevationLimit = 20
    case lowerRightElevationLimit = 22
    case upperRightElevationLimit = 24
    case source = 26
    case dataMode = 28
    case createdAt = 30
    case createdBy = 32
    case idSensor = 34
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: SENSORLIMITS-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var idSensorLimits: String? { let o = _accessor.offset(VTOFFSET.idSensorLimits.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSensorLimitsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSensorLimits.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var upperLeftAzimuthLimit: Double { let o = _accessor.offset(VTOFFSET.upperLeftAzimuthLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var upperRightAzimuthLimit: Double { let o = _accessor.offset(VTOFFSET.upperRightAzimuthLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var lowerRightAzimuthLimit: Double { let o = _accessor.offset(VTOFFSET.lowerRightAzimuthLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var lowerLeftAzimuthLimit: Double { let o = _accessor.offset(VTOFFSET.lowerLeftAzimuthLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var lowerLeftElevationLimit: Double { let o = _accessor.offset(VTOFFSET.lowerLeftElevationLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var upperLeftElevationLimit: Double { let o = _accessor.offset(VTOFFSET.upperLeftElevationLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var lowerRightElevationLimit: Double { let o = _accessor.offset(VTOFFSET.lowerRightElevationLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var upperRightElevationLimit: Double { let o = _accessor.offset(VTOFFSET.upperRightElevationLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: Sensorlimits_Abridged_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : Sensorlimits_Abridged_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Unique identifier of the target sensor object.
  ///  Example: /// Example: SENSORLIMITS-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idSensor: String? { let o = _accessor.offset(VTOFFSET.idSensor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSensorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSensor.v) }
  public static func startSensorlimits_Abridged(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 16) }
  public static func add(idSensorLimits: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSensorLimits, at: VTOFFSET.idSensorLimits.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(upperLeftAzimuthLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: upperLeftAzimuthLimit, def: 0.0, at: VTOFFSET.upperLeftAzimuthLimit.p) }
  public static func add(upperRightAzimuthLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: upperRightAzimuthLimit, def: 0.0, at: VTOFFSET.upperRightAzimuthLimit.p) }
  public static func add(lowerRightAzimuthLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lowerRightAzimuthLimit, def: 0.0, at: VTOFFSET.lowerRightAzimuthLimit.p) }
  public static func add(lowerLeftAzimuthLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lowerLeftAzimuthLimit, def: 0.0, at: VTOFFSET.lowerLeftAzimuthLimit.p) }
  public static func add(lowerLeftElevationLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lowerLeftElevationLimit, def: 0.0, at: VTOFFSET.lowerLeftElevationLimit.p) }
  public static func add(upperLeftElevationLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: upperLeftElevationLimit, def: 0.0, at: VTOFFSET.upperLeftElevationLimit.p) }
  public static func add(lowerRightElevationLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lowerRightElevationLimit, def: 0.0, at: VTOFFSET.lowerRightElevationLimit.p) }
  public static func add(upperRightElevationLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: upperRightElevationLimit, def: 0.0, at: VTOFFSET.upperRightElevationLimit.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(dataMode: Sensorlimits_Abridged_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(idSensor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSensor, at: VTOFFSET.idSensor.p) }
  public static func endSensorlimits_Abridged(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSensorlimits_Abridged(
    _ fbb: inout FlatBufferBuilder,
    idSensorLimitsOffset idSensorLimits: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    upperLeftAzimuthLimit: Double = 0.0,
    upperRightAzimuthLimit: Double = 0.0,
    lowerRightAzimuthLimit: Double = 0.0,
    lowerLeftAzimuthLimit: Double = 0.0,
    lowerLeftElevationLimit: Double = 0.0,
    upperLeftElevationLimit: Double = 0.0,
    lowerRightElevationLimit: Double = 0.0,
    upperRightElevationLimit: Double = 0.0,
    sourceOffset source: Offset = Offset(),
    dataMode: Sensorlimits_Abridged_dataMode_Enum = .real,
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    idSensorOffset idSensor: Offset = Offset()
  ) -> Offset {
    let __start = Sensorlimits_Abridged.startSensorlimits_Abridged(&fbb)
    Sensorlimits_Abridged.add(idSensorLimits: idSensorLimits, &fbb)
    Sensorlimits_Abridged.add(classificationMarking: classificationMarking, &fbb)
    Sensorlimits_Abridged.add(origNetwork: origNetwork, &fbb)
    Sensorlimits_Abridged.add(upperLeftAzimuthLimit: upperLeftAzimuthLimit, &fbb)
    Sensorlimits_Abridged.add(upperRightAzimuthLimit: upperRightAzimuthLimit, &fbb)
    Sensorlimits_Abridged.add(lowerRightAzimuthLimit: lowerRightAzimuthLimit, &fbb)
    Sensorlimits_Abridged.add(lowerLeftAzimuthLimit: lowerLeftAzimuthLimit, &fbb)
    Sensorlimits_Abridged.add(lowerLeftElevationLimit: lowerLeftElevationLimit, &fbb)
    Sensorlimits_Abridged.add(upperLeftElevationLimit: upperLeftElevationLimit, &fbb)
    Sensorlimits_Abridged.add(lowerRightElevationLimit: lowerRightElevationLimit, &fbb)
    Sensorlimits_Abridged.add(upperRightElevationLimit: upperRightElevationLimit, &fbb)
    Sensorlimits_Abridged.add(source: source, &fbb)
    Sensorlimits_Abridged.add(dataMode: dataMode, &fbb)
    Sensorlimits_Abridged.add(createdAt: createdAt, &fbb)
    Sensorlimits_Abridged.add(createdBy: createdBy, &fbb)
    Sensorlimits_Abridged.add(idSensor: idSensor, &fbb)
    return Sensorlimits_Abridged.endSensorlimits_Abridged(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.idSensorLimits.p, fieldName: "idSensorLimits", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.upperLeftAzimuthLimit.p, fieldName: "upperLeftAzimuthLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.upperRightAzimuthLimit.p, fieldName: "upperRightAzimuthLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.lowerRightAzimuthLimit.p, fieldName: "lowerRightAzimuthLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.lowerLeftAzimuthLimit.p, fieldName: "lowerLeftAzimuthLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.lowerLeftElevationLimit.p, fieldName: "lowerLeftElevationLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.upperLeftElevationLimit.p, fieldName: "upperLeftElevationLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.lowerRightElevationLimit.p, fieldName: "lowerRightElevationLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.upperRightElevationLimit.p, fieldName: "upperRightElevationLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: Sensorlimits_Abridged_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idSensor.p, fieldName: "idSensor", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

