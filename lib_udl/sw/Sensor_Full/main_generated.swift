// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Sensor_Full_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: Sensor_Full_dataMode_Enum { return .exercise }
  public static var min: Sensor_Full_dataMode_Enum { return .real }
}


///  /// Model representation of observation data for electro-optical based sensor phenomenologies.
public struct Sensor_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "SENS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Sensor_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case idSensor = 4
    case sensorName = 6
    case classificationMarking = 8
    case sensorNumber = 10
    case shortName = 12
    case dataControl = 14
    case afId = 16
    case asrType = 18
    case source = 20
    case origin = 22
    case origNetwork = 24
    case dataMode = 26
    case createdAt = 28
    case createdBy = 30
    case updatedAt = 32
    case updatedBy = 34
    case active = 36
    case sensorcharacteristics = 38
    case sensorStats = 40
    case sensorlimitsCollection = 42
    case entity = 44
    case idEntity = 46
    case sensorObservationType = 48
    case sensorType = 50
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: SENSOR-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var idSensor: String? { let o = _accessor.offset(VTOFFSET.idSensor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSensorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSensor.v) }
  ///  Unique name of this sensor.
  ///  Example: /// Example: SENSOR_NAME
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var sensorName: String? { let o = _accessor.offset(VTOFFSET.sensorName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sensorNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sensorName.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
  ///  Example: /// Example: 1234
  ///  Constraints: No constraints specified.
  public var sensorNumber: Int32 { let o = _accessor.offset(VTOFFSET.sensorNumber.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Optional short name for the sensor.
  ///  Example: /// Example: SNR-1
  ///  Constraints: Minimum length = 0, Maximum length = 5
  public var shortName: String? { let o = _accessor.offset(VTOFFSET.shortName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var shortNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.shortName.v) }
  ///  Optional dissemination control required for accessing data (e.g observations) produced by this sensor. This is typically a proprietary data owner control for commercial sensors.
  ///  Example: /// Example: observations
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var dataControl: String? { let o = _accessor.offset(VTOFFSET.dataControl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var dataControlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.dataControl.v) }
  ///  Optional US Air Force identifier for the sensor/ASR site, typically for air surveillance radar (ASR) sensors.
  ///  Example: /// Example: AF-ID
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var afId: String? { let o = _accessor.offset(VTOFFSET.afId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var afIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.afId.v) }
  ///  The sensor type at the site. Optional field, intended primarily for ASRs.
  ///  Example: /// Example: SENSOR_TYPE
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var asrType: String? { let o = _accessor.offset(VTOFFSET.asrType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var asrTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.asrType.v) }
  ///  Source of the data.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: Sensor_Full_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : Sensor_Full_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Time the row was last updated in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var updatedAt: String? { let o = _accessor.offset(VTOFFSET.updatedAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedAt.v) }
  ///  Application user who updated the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var updatedBy: String? { let o = _accessor.offset(VTOFFSET.updatedBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedBy.v) }
  ///  Optional flag indicating if the sensor is active.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var active: Bool { let o = _accessor.offset(VTOFFSET.active.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Collection of Sensorcharacteristics which define characteristics and capabilities of a sensor.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasSensorcharacteristics: Bool { let o = _accessor.offset(VTOFFSET.sensorcharacteristics.v); return o == 0 ? false : true }
  public var sensorcharacteristicsCount: Int32 { let o = _accessor.offset(VTOFFSET.sensorcharacteristics.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func sensorcharacteristics(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.sensorcharacteristics.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Collection of SensorStats which contain statistics of a sensor.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasSensorStats: Bool { let o = _accessor.offset(VTOFFSET.sensorStats.v); return o == 0 ? false : true }
  public var sensorStatsCount: Int32 { let o = _accessor.offset(VTOFFSET.sensorStats.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func sensorStats(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.sensorStats.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasSensorlimitsCollection: Bool { let o = _accessor.offset(VTOFFSET.sensorlimitsCollection.v); return o == 0 ? false : true }
  public var sensorlimitsCollectionCount: Int32 { let o = _accessor.offset(VTOFFSET.sensorlimitsCollection.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func sensorlimitsCollection(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.sensorlimitsCollection.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var entity: String? { let o = _accessor.offset(VTOFFSET.entity.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var entitySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.entity.v) }
  ///  Unique identifier of the parent entity. idEntity is required for Put.
  ///  Example: /// Example: ENTITY-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idEntity: String? { let o = _accessor.offset(VTOFFSET.idEntity.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idEntitySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idEntity.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var sensorObservationType: String? { let o = _accessor.offset(VTOFFSET.sensorObservationType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sensorObservationTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sensorObservationType.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var sensorType: String? { let o = _accessor.offset(VTOFFSET.sensorType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sensorTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sensorType.v) }
  public static func startSensor_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 24) }
  public static func add(idSensor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSensor, at: VTOFFSET.idSensor.p) }
  public static func add(sensorName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sensorName, at: VTOFFSET.sensorName.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(sensorNumber: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sensorNumber, def: 0, at: VTOFFSET.sensorNumber.p) }
  public static func add(shortName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: shortName, at: VTOFFSET.shortName.p) }
  public static func add(dataControl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dataControl, at: VTOFFSET.dataControl.p) }
  public static func add(afId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: afId, at: VTOFFSET.afId.p) }
  public static func add(asrType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: asrType, at: VTOFFSET.asrType.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: Sensor_Full_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(updatedAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedAt, at: VTOFFSET.updatedAt.p) }
  public static func add(updatedBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedBy, at: VTOFFSET.updatedBy.p) }
  public static func add(active: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: active, def: false,
   at: VTOFFSET.active.p) }
  public static func addVectorOf(sensorcharacteristics: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sensorcharacteristics, at: VTOFFSET.sensorcharacteristics.p) }
  public static func addVectorOf(sensorStats: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sensorStats, at: VTOFFSET.sensorStats.p) }
  public static func addVectorOf(sensorlimitsCollection: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sensorlimitsCollection, at: VTOFFSET.sensorlimitsCollection.p) }
  public static func add(entity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: entity, at: VTOFFSET.entity.p) }
  public static func add(idEntity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idEntity, at: VTOFFSET.idEntity.p) }
  public static func add(sensorObservationType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sensorObservationType, at: VTOFFSET.sensorObservationType.p) }
  public static func add(sensorType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sensorType, at: VTOFFSET.sensorType.p) }
  public static func endSensor_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSensor_Full(
    _ fbb: inout FlatBufferBuilder,
    idSensorOffset idSensor: Offset = Offset(),
    sensorNameOffset sensorName: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    sensorNumber: Int32 = 0,
    shortNameOffset shortName: Offset = Offset(),
    dataControlOffset dataControl: Offset = Offset(),
    afIdOffset afId: Offset = Offset(),
    asrTypeOffset asrType: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: Sensor_Full_dataMode_Enum = .real,
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    updatedAtOffset updatedAt: Offset = Offset(),
    updatedByOffset updatedBy: Offset = Offset(),
    active: Bool = false,
    sensorcharacteristicsVectorOffset sensorcharacteristics: Offset = Offset(),
    sensorStatsVectorOffset sensorStats: Offset = Offset(),
    sensorlimitsCollectionVectorOffset sensorlimitsCollection: Offset = Offset(),
    entityOffset entity: Offset = Offset(),
    idEntityOffset idEntity: Offset = Offset(),
    sensorObservationTypeOffset sensorObservationType: Offset = Offset(),
    sensorTypeOffset sensorType: Offset = Offset()
  ) -> Offset {
    let __start = Sensor_Full.startSensor_Full(&fbb)
    Sensor_Full.add(idSensor: idSensor, &fbb)
    Sensor_Full.add(sensorName: sensorName, &fbb)
    Sensor_Full.add(classificationMarking: classificationMarking, &fbb)
    Sensor_Full.add(sensorNumber: sensorNumber, &fbb)
    Sensor_Full.add(shortName: shortName, &fbb)
    Sensor_Full.add(dataControl: dataControl, &fbb)
    Sensor_Full.add(afId: afId, &fbb)
    Sensor_Full.add(asrType: asrType, &fbb)
    Sensor_Full.add(source: source, &fbb)
    Sensor_Full.add(origin: origin, &fbb)
    Sensor_Full.add(origNetwork: origNetwork, &fbb)
    Sensor_Full.add(dataMode: dataMode, &fbb)
    Sensor_Full.add(createdAt: createdAt, &fbb)
    Sensor_Full.add(createdBy: createdBy, &fbb)
    Sensor_Full.add(updatedAt: updatedAt, &fbb)
    Sensor_Full.add(updatedBy: updatedBy, &fbb)
    Sensor_Full.add(active: active, &fbb)
    Sensor_Full.addVectorOf(sensorcharacteristics: sensorcharacteristics, &fbb)
    Sensor_Full.addVectorOf(sensorStats: sensorStats, &fbb)
    Sensor_Full.addVectorOf(sensorlimitsCollection: sensorlimitsCollection, &fbb)
    Sensor_Full.add(entity: entity, &fbb)
    Sensor_Full.add(idEntity: idEntity, &fbb)
    Sensor_Full.add(sensorObservationType: sensorObservationType, &fbb)
    Sensor_Full.add(sensorType: sensorType, &fbb)
    return Sensor_Full.endSensor_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.idSensor.p, fieldName: "idSensor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sensorName.p, fieldName: "sensorName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sensorNumber.p, fieldName: "sensorNumber", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.shortName.p, fieldName: "shortName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataControl.p, fieldName: "dataControl", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.afId.p, fieldName: "afId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.asrType.p, fieldName: "asrType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: Sensor_Full_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedAt.p, fieldName: "updatedAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedBy.p, fieldName: "updatedBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.active.p, fieldName: "active", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.sensorcharacteristics.p, fieldName: "sensorcharacteristics", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.sensorStats.p, fieldName: "sensorStats", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.sensorlimitsCollection.p, fieldName: "sensorlimitsCollection", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.entity.p, fieldName: "entity", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idEntity.p, fieldName: "idEntity", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sensorObservationType.p, fieldName: "sensorObservationType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sensorType.p, fieldName: "sensorType", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

