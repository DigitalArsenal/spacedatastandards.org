// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum SkyImagery_Abridged_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: SkyImagery_Abridged_dataMode_Enum { return .exercise }
  public static var min: SkyImagery_Abridged_dataMode_Enum { return .real }
}


///  /// Model representation of sky imagery data.  Sky imagery is ground or space based telescope imagery of RSO's and includes metadata on the image (time, source, etc) as well as binary image content (e.g. FITS, EOSSA, EOCHIP) . Binary content must be downloaded individually by ID using the 'getFile' operation.
public struct SkyImagery_Abridged: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "SKYI" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: SkyImagery_Abridged.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case idOnOrbit = 8
    case origObjectId = 10
    case idAttitudeSet = 12
    case idSensor = 14
    case satNo = 16
    case origSensorId = 18
    case senlat = 20
    case senlon = 22
    case senalt = 24
    case senx = 26
    case seny = 28
    case senz = 30
    case senQuat = 32
    case senQuatDot = 34
    case imageType = 36
    case expStartTime = 38
    case expEndTime = 40
    case imageSourceInfo = 42
    case topLeftStartAz = 44
    case topLeftStartEl = 46
    case topLeftStopAz = 48
    case topLeftStopEl = 50
    case imageSetId = 52
    case imageSetLength = 54
    case sequenceId = 56
    case frameFovwidth = 58
    case frameFovheight = 60
    case pixelFovwidth = 62
    case pixelFovheight = 64
    case frameWidthPixels = 66
    case frameHeightPixels = 68
    case pixelBitDepth = 70
    case annotationKey = 72
    case calibrationKey = 74
    case filename = 76
    case filesize = 78
    case checksumValue = 80
    case transactionId = 82
    case tags = 84
    case source = 86
    case origin = 88
    case origNetwork = 90
    case sourceDl = 92
    case description = 94
    case dataMode = 96
    case createdAt = 98
    case createdBy = 100
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: SKYIMAGERY-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Optional identifier of the target on-orbit object, if correlated.
  ///  Example: /// Example: 44920
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idOnOrbit: String? { let o = _accessor.offset(VTOFFSET.idOnOrbit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idOnOrbitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idOnOrbit.v) }
  ///  Optional identifier provided by the imaging source to indicate the target onorbit object of this image. This may be an internal identifier and not necessarily a valid satellite number.
  ///  Example: /// Example: X15-23452
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origObjectId: String? { let o = _accessor.offset(VTOFFSET.origObjectId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origObjectIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origObjectId.v) }
  ///  Optional identifier of the AttitudeSet data record describing the orientation of an object body.
  ///  Example: /// Example: d039ba29-52f4-4839-8a8f-e85fa416aec5
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idAttitudeSet: String? { let o = _accessor.offset(VTOFFSET.idAttitudeSet.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idAttitudeSetSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idAttitudeSet.v) }
  ///  Unique identifier of the reporting sensor.
  ///  Example: /// Example: 420
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idSensor: String? { let o = _accessor.offset(VTOFFSET.idSensor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSensorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSensor.v) }
  ///  Catalog number of the target on-orbit object.
  ///  Example: /// Example: 25544
  ///  Constraints: No constraints specified.
  public var satNo: Int32 { let o = _accessor.offset(VTOFFSET.satNo.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Optional identifier provided by the imaging source to indicate the sensor identifier which produced this image. This may be an internal identifier and not necessarily a valid sensor ID.
  ///  Example: /// Example: origSensorId
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origSensorId: String? { let o = _accessor.offset(VTOFFSET.origSensorId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origSensorIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origSensorId.v) }
  ///  Sensor latitude at exposure start epoch, in degrees. If null, can be obtained from sensor info. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: -33.283048
  ///  Constraints: No constraints specified.
  public var senlat: Double { let o = _accessor.offset(VTOFFSET.senlat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Sensor longitude at exposure start epoch, in degrees. If null, can be obtained from sensor info. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 149.372549
  ///  Constraints: No constraints specified.
  public var senlon: Double { let o = _accessor.offset(VTOFFSET.senlon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Sensor altitude at exposure start epoch, in km. If null, can be obtained from sensor info.
  ///  Example: /// Example: 14.483619321
  ///  Constraints: No constraints specified.
  public var senalt: Double { let o = _accessor.offset(VTOFFSET.senalt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Sensor x position at exposure start epoch, in km (if mobile/onorbit) in J2000 coordinate frame.
  ///  Example: /// Example: 14.52
  ///  Constraints: No constraints specified.
  public var senx: Double { let o = _accessor.offset(VTOFFSET.senx.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Sensor y position at exposure start epoch, in km (if mobile/onorbit) in J2000 coordinate frame.
  ///  Example: /// Example: 32.41
  ///  Constraints: No constraints specified.
  public var seny: Double { let o = _accessor.offset(VTOFFSET.seny.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Sensor z position at exposure start epoch, in km (if mobile/onorbit) in J2000 coordinate frame.
  ///  Example: /// Example: 376.12
  ///  Constraints: No constraints specified.
  public var senz: Double { let o = _accessor.offset(VTOFFSET.senz.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The quaternion describing the rotation of the body-fixed frame used for this system into the local geodetic frame, at exposure start epoch (expStartTime). The array element order convention is scalar component first, followed by the three vector components. For a vector u in the body-fixed frame, the corresponding vector u' in the geodetic frame should satisfy u' = quq*, where q is this quaternion.
  ///  Example: /// Example: [0.03, 0.02, 0.01, 0.012]
  ///  Constraints: No constraints specified.
  public var hasSenQuat: Bool { let o = _accessor.offset(VTOFFSET.senQuat.v); return o == 0 ? false : true }
  public var senQuatCount: Int32 { let o = _accessor.offset(VTOFFSET.senQuat.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func senQuat(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.senQuat.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The derivative of the quaternion describing the rotation of the body-fixed frame used for this system into the local geodetic frame, exposure start epoch (expStartTime). The array element order convention is scalar component first, followed by the three vector components. For a vector u in the body-fixed frame, the corresponding vector u' in the geodetic frame should satisfy u' = quq*, where q is this quaternion.
  ///  Example: /// Example: [0.03, 0.02, 0.01, 0.012]
  ///  Constraints: No constraints specified.
  public var hasSenQuatDot: Bool { let o = _accessor.offset(VTOFFSET.senQuatDot.v); return o == 0 ? false : true }
  public var senQuatDotCount: Int32 { let o = _accessor.offset(VTOFFSET.senQuatDot.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func senQuatDot(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.senQuatDot.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The type of image associated with this record (e.g. FITS, EOSSA, EOCHIP).
  ///  Example: /// Example: imageType
  ///  Constraints: Minimum length = 1, Maximum length = 24
  public var imageType: String? { let o = _accessor.offset(VTOFFSET.imageType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var imageTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.imageType.v) }
  ///  Start time of the exposure, in ISO 8601 UTC format with microsecond precision.
  ///  Example: /// Example: 2021-01-01T01:01:01.123456Z
  ///  Constraints: No constraints specified.
  public var expStartTime: String? { let o = _accessor.offset(VTOFFSET.expStartTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var expStartTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.expStartTime.v) }
  ///  End time of the exposure, in ISO 8601 UTC format with microsecond precision.
  ///  Example: /// Example: 2021-01-01T01:01:01.123456Z
  ///  Constraints: No constraints specified.
  public var expEndTime: String? { let o = _accessor.offset(VTOFFSET.expEndTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var expEndTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.expEndTime.v) }
  ///  String that uniquely identifies the data source.
  ///  Example: /// Example: imageSourceInfo
  ///  Constraints: Minimum length = 0, Maximum length = 100
  public var imageSourceInfo: String? { let o = _accessor.offset(VTOFFSET.imageSourceInfo.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var imageSourceInfoSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.imageSourceInfo.v) }
  ///  The telescope pointing azimuth, in degrees, at the exposure start epoch.
  ///  Example: /// Example: 146.321
  ///  Constraints: No constraints specified.
  public var topLeftStartAz: Double { let o = _accessor.offset(VTOFFSET.topLeftStartAz.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The telescope pointing elevation, in degrees, at the exposure start epoch.
  ///  Example: /// Example: 146.321
  ///  Constraints: No constraints specified.
  public var topLeftStartEl: Double { let o = _accessor.offset(VTOFFSET.topLeftStartEl.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The telescope pointing azimuth, in degrees, at the exposure stop epoch.
  ///  Example: /// Example: 3.7
  ///  Constraints: No constraints specified.
  public var topLeftStopAz: Double { let o = _accessor.offset(VTOFFSET.topLeftStopAz.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The telescope pointing elevation, in degrees, at the exposure stop epoch.
  ///  Example: /// Example: 34.233
  ///  Constraints: No constraints specified.
  public var topLeftStopEl: Double { let o = _accessor.offset(VTOFFSET.topLeftStopEl.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The user-defined set ID of a sequence of images.
  ///  Example: /// Example: imageSetId
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var imageSetId: String? { let o = _accessor.offset(VTOFFSET.imageSetId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var imageSetIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.imageSetId.v) }
  ///  The number of images in an image set.
  ///  Example: /// Example: 9
  ///  Constraints: No constraints specified.
  public var imageSetLength: Int32 { let o = _accessor.offset(VTOFFSET.imageSetLength.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The sequence ID of an image within an image set.
  ///  Example: /// Example: 1
  ///  Constraints: No constraints specified.
  public var sequenceId: Int32 { let o = _accessor.offset(VTOFFSET.sequenceId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Field Of View frame width, in degrees.
  ///  Example: /// Example: 21.23
  ///  Constraints: No constraints specified.
  public var frameFovwidth: Double { let o = _accessor.offset(VTOFFSET.frameFovwidth.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Field Of View frame height, in degrees.
  ///  Example: /// Example: 21.23
  ///  Constraints: No constraints specified.
  public var frameFovheight: Double { let o = _accessor.offset(VTOFFSET.frameFovheight.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Field Of View pixel width, in degrees.
  ///  Example: /// Example: 321.123
  ///  Constraints: No constraints specified.
  public var pixelFovwidth: Double { let o = _accessor.offset(VTOFFSET.pixelFovwidth.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Field Of View pixel height, in degrees.
  ///  Example: /// Example: 321.123
  ///  Constraints: No constraints specified.
  public var pixelFovheight: Double { let o = _accessor.offset(VTOFFSET.pixelFovheight.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Frame width of the image, in number of pixels.
  ///  Example: /// Example: 1
  ///  Constraints: No constraints specified.
  public var frameWidthPixels: Int32 { let o = _accessor.offset(VTOFFSET.frameWidthPixels.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Frame height of the image, in number of pixels.
  ///  Example: /// Example: 1
  ///  Constraints: No constraints specified.
  public var frameHeightPixels: Int32 { let o = _accessor.offset(VTOFFSET.frameHeightPixels.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Bit depth of the image, in number of pixels.
  ///  Example: /// Example: 1
  ///  Constraints: No constraints specified.
  public var pixelBitDepth: Int32 { let o = _accessor.offset(VTOFFSET.pixelBitDepth.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Reference to an annotation document associated with this image.
  ///  Example: /// Example: annotationKey
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var annotationKey: String? { let o = _accessor.offset(VTOFFSET.annotationKey.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var annotationKeySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.annotationKey.v) }
  ///  Reference to a calibration document associated with this image.
  ///  Example: /// Example: calibrationKey
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var calibrationKey: String? { let o = _accessor.offset(VTOFFSET.calibrationKey.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var calibrationKeySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.calibrationKey.v) }
  ///  Name of the uploaded image file.
  ///  Example: /// Example: filename.jpg
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var filename: String? { let o = _accessor.offset(VTOFFSET.filename.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var filenameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.filename.v) }
  ///  Size of the image file, in bytes.
  ///  Example: /// Example: 371945
  ///  Constraints: No constraints specified.
  public var filesize: Int64 { let o = _accessor.offset(VTOFFSET.filesize.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  ///  MD5 value of the file. The ingest/create operation will automatically generate the value.
  ///  Example: /// Example: checksumValue
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var checksumValue: String? { let o = _accessor.offset(VTOFFSET.checksumValue.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var checksumValueSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.checksumValue.v) }
  ///  Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  ///  Example: /// Example: a7bdef1f-5a4f-4716-bee4-7a1e0ec7d35a
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var transactionId: String? { let o = _accessor.offset(VTOFFSET.transactionId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var transactionIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.transactionId.v) }
  ///  Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  ///  Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
  ///  Constraints: No constraints specified.
  public var hasTags: Bool { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? false : true }
  public var tagsCount: Int32 { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tags(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  ///  Example: /// Example: AXE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var sourceDl: String? { let o = _accessor.offset(VTOFFSET.sourceDl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceDlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceDl.v) }
  ///  Optional name/description associated with this image.
  ///  Example: /// Example: description
  ///  Constraints: Minimum length = 0, Maximum length = 2147483647
  public var description: String? { let o = _accessor.offset(VTOFFSET.description.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.description.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: SkyImagery_Abridged_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : SkyImagery_Abridged_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  public static func startSkyImagery_Abridged(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 49) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(idOnOrbit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idOnOrbit, at: VTOFFSET.idOnOrbit.p) }
  public static func add(origObjectId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origObjectId, at: VTOFFSET.origObjectId.p) }
  public static func add(idAttitudeSet: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idAttitudeSet, at: VTOFFSET.idAttitudeSet.p) }
  public static func add(idSensor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSensor, at: VTOFFSET.idSensor.p) }
  public static func add(satNo: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: satNo, def: 0, at: VTOFFSET.satNo.p) }
  public static func add(origSensorId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origSensorId, at: VTOFFSET.origSensorId.p) }
  public static func add(senlat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: senlat, def: 0.0, at: VTOFFSET.senlat.p) }
  public static func add(senlon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: senlon, def: 0.0, at: VTOFFSET.senlon.p) }
  public static func add(senalt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: senalt, def: 0.0, at: VTOFFSET.senalt.p) }
  public static func add(senx: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: senx, def: 0.0, at: VTOFFSET.senx.p) }
  public static func add(seny: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: seny, def: 0.0, at: VTOFFSET.seny.p) }
  public static func add(senz: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: senz, def: 0.0, at: VTOFFSET.senz.p) }
  public static func addVectorOf(senQuat: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: senQuat, at: VTOFFSET.senQuat.p) }
  public static func addVectorOf(senQuatDot: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: senQuatDot, at: VTOFFSET.senQuatDot.p) }
  public static func add(imageType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: imageType, at: VTOFFSET.imageType.p) }
  public static func add(expStartTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: expStartTime, at: VTOFFSET.expStartTime.p) }
  public static func add(expEndTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: expEndTime, at: VTOFFSET.expEndTime.p) }
  public static func add(imageSourceInfo: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: imageSourceInfo, at: VTOFFSET.imageSourceInfo.p) }
  public static func add(topLeftStartAz: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: topLeftStartAz, def: 0.0, at: VTOFFSET.topLeftStartAz.p) }
  public static func add(topLeftStartEl: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: topLeftStartEl, def: 0.0, at: VTOFFSET.topLeftStartEl.p) }
  public static func add(topLeftStopAz: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: topLeftStopAz, def: 0.0, at: VTOFFSET.topLeftStopAz.p) }
  public static func add(topLeftStopEl: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: topLeftStopEl, def: 0.0, at: VTOFFSET.topLeftStopEl.p) }
  public static func add(imageSetId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: imageSetId, at: VTOFFSET.imageSetId.p) }
  public static func add(imageSetLength: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: imageSetLength, def: 0, at: VTOFFSET.imageSetLength.p) }
  public static func add(sequenceId: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sequenceId, def: 0, at: VTOFFSET.sequenceId.p) }
  public static func add(frameFovwidth: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: frameFovwidth, def: 0.0, at: VTOFFSET.frameFovwidth.p) }
  public static func add(frameFovheight: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: frameFovheight, def: 0.0, at: VTOFFSET.frameFovheight.p) }
  public static func add(pixelFovwidth: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pixelFovwidth, def: 0.0, at: VTOFFSET.pixelFovwidth.p) }
  public static func add(pixelFovheight: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pixelFovheight, def: 0.0, at: VTOFFSET.pixelFovheight.p) }
  public static func add(frameWidthPixels: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: frameWidthPixels, def: 0, at: VTOFFSET.frameWidthPixels.p) }
  public static func add(frameHeightPixels: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: frameHeightPixels, def: 0, at: VTOFFSET.frameHeightPixels.p) }
  public static func add(pixelBitDepth: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pixelBitDepth, def: 0, at: VTOFFSET.pixelBitDepth.p) }
  public static func add(annotationKey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: annotationKey, at: VTOFFSET.annotationKey.p) }
  public static func add(calibrationKey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: calibrationKey, at: VTOFFSET.calibrationKey.p) }
  public static func add(filename: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: filename, at: VTOFFSET.filename.p) }
  public static func add(filesize: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: filesize, def: 0, at: VTOFFSET.filesize.p) }
  public static func add(checksumValue: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: checksumValue, at: VTOFFSET.checksumValue.p) }
  public static func add(transactionId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: transactionId, at: VTOFFSET.transactionId.p) }
  public static func addVectorOf(tags: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tags, at: VTOFFSET.tags.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(sourceDl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceDl, at: VTOFFSET.sourceDl.p) }
  public static func add(description: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: description, at: VTOFFSET.description.p) }
  public static func add(dataMode: SkyImagery_Abridged_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func endSkyImagery_Abridged(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSkyImagery_Abridged(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    idOnOrbitOffset idOnOrbit: Offset = Offset(),
    origObjectIdOffset origObjectId: Offset = Offset(),
    idAttitudeSetOffset idAttitudeSet: Offset = Offset(),
    idSensorOffset idSensor: Offset = Offset(),
    satNo: Int32 = 0,
    origSensorIdOffset origSensorId: Offset = Offset(),
    senlat: Double = 0.0,
    senlon: Double = 0.0,
    senalt: Double = 0.0,
    senx: Double = 0.0,
    seny: Double = 0.0,
    senz: Double = 0.0,
    senQuatVectorOffset senQuat: Offset = Offset(),
    senQuatDotVectorOffset senQuatDot: Offset = Offset(),
    imageTypeOffset imageType: Offset = Offset(),
    expStartTimeOffset expStartTime: Offset = Offset(),
    expEndTimeOffset expEndTime: Offset = Offset(),
    imageSourceInfoOffset imageSourceInfo: Offset = Offset(),
    topLeftStartAz: Double = 0.0,
    topLeftStartEl: Double = 0.0,
    topLeftStopAz: Double = 0.0,
    topLeftStopEl: Double = 0.0,
    imageSetIdOffset imageSetId: Offset = Offset(),
    imageSetLength: Int32 = 0,
    sequenceId: Int32 = 0,
    frameFovwidth: Double = 0.0,
    frameFovheight: Double = 0.0,
    pixelFovwidth: Double = 0.0,
    pixelFovheight: Double = 0.0,
    frameWidthPixels: Int32 = 0,
    frameHeightPixels: Int32 = 0,
    pixelBitDepth: Int32 = 0,
    annotationKeyOffset annotationKey: Offset = Offset(),
    calibrationKeyOffset calibrationKey: Offset = Offset(),
    filenameOffset filename: Offset = Offset(),
    filesize: Int64 = 0,
    checksumValueOffset checksumValue: Offset = Offset(),
    transactionIdOffset transactionId: Offset = Offset(),
    tagsVectorOffset tags: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    sourceDlOffset sourceDl: Offset = Offset(),
    descriptionOffset description: Offset = Offset(),
    dataMode: SkyImagery_Abridged_dataMode_Enum = .real,
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset()
  ) -> Offset {
    let __start = SkyImagery_Abridged.startSkyImagery_Abridged(&fbb)
    SkyImagery_Abridged.add(id: id, &fbb)
    SkyImagery_Abridged.add(classificationMarking: classificationMarking, &fbb)
    SkyImagery_Abridged.add(idOnOrbit: idOnOrbit, &fbb)
    SkyImagery_Abridged.add(origObjectId: origObjectId, &fbb)
    SkyImagery_Abridged.add(idAttitudeSet: idAttitudeSet, &fbb)
    SkyImagery_Abridged.add(idSensor: idSensor, &fbb)
    SkyImagery_Abridged.add(satNo: satNo, &fbb)
    SkyImagery_Abridged.add(origSensorId: origSensorId, &fbb)
    SkyImagery_Abridged.add(senlat: senlat, &fbb)
    SkyImagery_Abridged.add(senlon: senlon, &fbb)
    SkyImagery_Abridged.add(senalt: senalt, &fbb)
    SkyImagery_Abridged.add(senx: senx, &fbb)
    SkyImagery_Abridged.add(seny: seny, &fbb)
    SkyImagery_Abridged.add(senz: senz, &fbb)
    SkyImagery_Abridged.addVectorOf(senQuat: senQuat, &fbb)
    SkyImagery_Abridged.addVectorOf(senQuatDot: senQuatDot, &fbb)
    SkyImagery_Abridged.add(imageType: imageType, &fbb)
    SkyImagery_Abridged.add(expStartTime: expStartTime, &fbb)
    SkyImagery_Abridged.add(expEndTime: expEndTime, &fbb)
    SkyImagery_Abridged.add(imageSourceInfo: imageSourceInfo, &fbb)
    SkyImagery_Abridged.add(topLeftStartAz: topLeftStartAz, &fbb)
    SkyImagery_Abridged.add(topLeftStartEl: topLeftStartEl, &fbb)
    SkyImagery_Abridged.add(topLeftStopAz: topLeftStopAz, &fbb)
    SkyImagery_Abridged.add(topLeftStopEl: topLeftStopEl, &fbb)
    SkyImagery_Abridged.add(imageSetId: imageSetId, &fbb)
    SkyImagery_Abridged.add(imageSetLength: imageSetLength, &fbb)
    SkyImagery_Abridged.add(sequenceId: sequenceId, &fbb)
    SkyImagery_Abridged.add(frameFovwidth: frameFovwidth, &fbb)
    SkyImagery_Abridged.add(frameFovheight: frameFovheight, &fbb)
    SkyImagery_Abridged.add(pixelFovwidth: pixelFovwidth, &fbb)
    SkyImagery_Abridged.add(pixelFovheight: pixelFovheight, &fbb)
    SkyImagery_Abridged.add(frameWidthPixels: frameWidthPixels, &fbb)
    SkyImagery_Abridged.add(frameHeightPixels: frameHeightPixels, &fbb)
    SkyImagery_Abridged.add(pixelBitDepth: pixelBitDepth, &fbb)
    SkyImagery_Abridged.add(annotationKey: annotationKey, &fbb)
    SkyImagery_Abridged.add(calibrationKey: calibrationKey, &fbb)
    SkyImagery_Abridged.add(filename: filename, &fbb)
    SkyImagery_Abridged.add(filesize: filesize, &fbb)
    SkyImagery_Abridged.add(checksumValue: checksumValue, &fbb)
    SkyImagery_Abridged.add(transactionId: transactionId, &fbb)
    SkyImagery_Abridged.addVectorOf(tags: tags, &fbb)
    SkyImagery_Abridged.add(source: source, &fbb)
    SkyImagery_Abridged.add(origin: origin, &fbb)
    SkyImagery_Abridged.add(origNetwork: origNetwork, &fbb)
    SkyImagery_Abridged.add(sourceDl: sourceDl, &fbb)
    SkyImagery_Abridged.add(description: description, &fbb)
    SkyImagery_Abridged.add(dataMode: dataMode, &fbb)
    SkyImagery_Abridged.add(createdAt: createdAt, &fbb)
    SkyImagery_Abridged.add(createdBy: createdBy, &fbb)
    return SkyImagery_Abridged.endSkyImagery_Abridged(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idOnOrbit.p, fieldName: "idOnOrbit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origObjectId.p, fieldName: "origObjectId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idAttitudeSet.p, fieldName: "idAttitudeSet", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idSensor.p, fieldName: "idSensor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.satNo.p, fieldName: "satNo", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.origSensorId.p, fieldName: "origSensorId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.senlat.p, fieldName: "senlat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.senlon.p, fieldName: "senlon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.senalt.p, fieldName: "senalt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.senx.p, fieldName: "senx", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.seny.p, fieldName: "seny", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.senz.p, fieldName: "senz", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.senQuat.p, fieldName: "senQuat", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.senQuatDot.p, fieldName: "senQuatDot", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.imageType.p, fieldName: "imageType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.expStartTime.p, fieldName: "expStartTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.expEndTime.p, fieldName: "expEndTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.imageSourceInfo.p, fieldName: "imageSourceInfo", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.topLeftStartAz.p, fieldName: "topLeftStartAz", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.topLeftStartEl.p, fieldName: "topLeftStartEl", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.topLeftStopAz.p, fieldName: "topLeftStopAz", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.topLeftStopEl.p, fieldName: "topLeftStopEl", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.imageSetId.p, fieldName: "imageSetId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.imageSetLength.p, fieldName: "imageSetLength", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.sequenceId.p, fieldName: "sequenceId", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.frameFovwidth.p, fieldName: "frameFovwidth", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.frameFovheight.p, fieldName: "frameFovheight", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.pixelFovwidth.p, fieldName: "pixelFovwidth", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.pixelFovheight.p, fieldName: "pixelFovheight", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.frameWidthPixels.p, fieldName: "frameWidthPixels", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.frameHeightPixels.p, fieldName: "frameHeightPixels", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.pixelBitDepth.p, fieldName: "pixelBitDepth", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.annotationKey.p, fieldName: "annotationKey", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.calibrationKey.p, fieldName: "calibrationKey", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.filename.p, fieldName: "filename", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.filesize.p, fieldName: "filesize", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.checksumValue.p, fieldName: "checksumValue", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.transactionId.p, fieldName: "transactionId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.tags.p, fieldName: "tags", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceDl.p, fieldName: "sourceDl", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.description.p, fieldName: "description", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: SkyImagery_Abridged_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

