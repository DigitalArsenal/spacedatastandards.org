// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum AirspaceControlOrder_Ingest_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: AirspaceControlOrder_Ingest_dataMode_Enum { return .exercise }
  public static var min: AirspaceControlOrder_Ingest_dataMode_Enum { return .real }
}


///  /// Beta Version Airspace Control Order: Contains airspace coordination information and instructions that have been issued by an airspace control authority.
public struct AirspaceControlOrder_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "AIRS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AirspaceControlOrder_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case rawFileUri = 8
    case opExName = 10
    case originator = 12
    case startTime = 14
    case stopTime = 16
    case stopQualifier = 18
    case opExInfo = 20
    case opExInfoAlt = 22
    case planOrigNum = 24
    case serialNum = 26
    case month = 28
    case qualifier = 30
    case qualSn = 32
    case areaOfValidity = 34
    case acoSerialNum = 36
    case geoDatum = 38
    case acoComments = 40
    case airspaceControlOrderReferences = 42
    case airspaceControlMeansStatus = 44
    case undLnkTrk = 46
    case classSource = 48
    case classReason = 50
    case downgradeInsDate = 52
    case declassExemptionCode = 54
    case createdAt = 56
    case createdBy = 58
    case sourceDl = 60
    case source = 62
    case origin = 64
    case origNetwork = 66
    case dataMode = 68
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system if not provided on create operations.
  ///  Example: /// Example: c44b0a80-9fef-63d9-6267-79037fb93e4c
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  ///  Example: /// Example: EXAMPLE URI
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var rawFileUri: String? { let o = _accessor.offset(VTOFFSET.rawFileUri.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var rawFileUriSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.rawFileUri.v) }
  ///  Specifies the code name or nickname assigned to a joint exercise or plan to designate message traffic.
  ///  Example: /// Example: DESERT WIND
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var opExName: String? { let o = _accessor.offset(VTOFFSET.opExName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var opExNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.opExName.v) }
  ///  The originator of this reference.
  ///  Example: /// Example: USCENTCOM
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var originator: String? { let o = _accessor.offset(VTOFFSET.originator.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originatorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.originator.v) }
  ///  The start of the effective time period of this airspace control order, in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-01-07T13:55:43.123Z
  ///  Constraints: No constraints specified.
  public var startTime: String? { let o = _accessor.offset(VTOFFSET.startTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var startTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.startTime.v) }
  ///  The end of the effective time period of this airspace control order, in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-01-08T13:55:43.123Z
  ///  Constraints: No constraints specified.
  public var stopTime: String? { let o = _accessor.offset(VTOFFSET.stopTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var stopTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.stopTime.v) }
  ///  A qualifier for the end of the effective time period of this airspace control order, such as AFTER, ASOF, NLT, etc. Used with field stopTime to indicate a relative time.
  ///  Example: /// Example: AFTER
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var stopQualifier: String? { let o = _accessor.offset(VTOFFSET.stopQualifier.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var stopQualifierSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.stopQualifier.v) }
  ///  Supplementary name that can be used to further identify exercise nicknames, or to provide the primary nickname of the option or the alternative of an operational plan.
  ///  Example: /// Example: CONTROL
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var opExInfo: String? { let o = _accessor.offset(VTOFFSET.opExInfo.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var opExInfoSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.opExInfo.v) }
  ///  The secondary supplementary nickname of the option or the alternative of the operational plan or order.
  ///  Example: /// Example: ORANGE
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var opExInfoAlt: String? { let o = _accessor.offset(VTOFFSET.opExInfoAlt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var opExInfoAltSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.opExInfoAlt.v) }
  ///  The official identifier of the military establishment responsible for the operation plan and the identification number assigned to this plan.
  ///  Example: /// Example: SACEUR 106
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var planOrigNum: String? { let o = _accessor.offset(VTOFFSET.planOrigNum.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var planOrigNumSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.planOrigNum.v) }
  ///  The unique message identifier sequentially assigned by the originator.
  ///  Example: /// Example: 1201003
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var serialNum: String? { let o = _accessor.offset(VTOFFSET.serialNum.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var serialNumSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.serialNum.v) }
  ///  The month in which the message originated.
  ///  Example: /// Example: OCT
  ///  Constraints: Minimum length = 0, Maximum length = 12
  public var month: String? { let o = _accessor.offset(VTOFFSET.month.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var monthSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.month.v) }
  ///  The qualifier which caveats the message status.
  ///  Example: /// Example: CHG
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var qualifier: String? { let o = _accessor.offset(VTOFFSET.qualifier.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var qualifierSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.qualifier.v) }
  ///  The serial number associated with the message qualifier.
  ///  Example: /// Example: 1
  ///  Constraints: No constraints specified.
  public var qualSn: Int32 { let o = _accessor.offset(VTOFFSET.qualSn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Name of the area of the command for which the ACO is valid.
  ///  Example: /// Example: FORT BRAGG
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var areaOfValidity: String? { let o = _accessor.offset(VTOFFSET.areaOfValidity.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var areaOfValiditySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.areaOfValidity.v) }
  ///  The serial number of this airspace control order.
  ///  Example: /// Example: 27B
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var acoSerialNum: String? { let o = _accessor.offset(VTOFFSET.acoSerialNum.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var acoSerialNumSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.acoSerialNum.v) }
  ///  Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated.
  ///  Example: /// Example: EUR-T
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var geoDatum: String? { let o = _accessor.offset(VTOFFSET.geoDatum.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var geoDatumSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.geoDatum.v) }
  ///  Free text information expressed in natural language.
  ///  Example: /// Example: CHOKE POINTS
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var acoComments: String? { let o = _accessor.offset(VTOFFSET.acoComments.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var acoCommentsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.acoComments.v) }
  ///  The airspaceControlReferences set provides both USMTF and non-USMTF references for this airspace control order.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasAirspaceControlOrderReferences: Bool { let o = _accessor.offset(VTOFFSET.airspaceControlOrderReferences.v); return o == 0 ? false : true }
  public var airspaceControlOrderReferencesCount: Int32 { let o = _accessor.offset(VTOFFSET.airspaceControlOrderReferences.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func airspaceControlOrderReferences(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.airspaceControlOrderReferences.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Mandatory nested segment to report multiple airspace control means statuses within an ACOID.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasAirspaceControlMeansStatus: Bool { let o = _accessor.offset(VTOFFSET.airspaceControlMeansStatus.v); return o == 0 ? false : true }
  public var airspaceControlMeansStatusCount: Int32 { let o = _accessor.offset(VTOFFSET.airspaceControlMeansStatus.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func airspaceControlMeansStatus(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.airspaceControlMeansStatus.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Collection of unique link 16 identifier that will be assigned to a future airspace control means.
  ///  Example: /// Example: ['A2467', 'A3466', 'AA232']
  ///  Constraints: No constraints specified.
  public var hasUndLnkTrk: Bool { let o = _accessor.offset(VTOFFSET.undLnkTrk.v); return o == 0 ? false : true }
  public var undLnkTrkCount: Int32 { let o = _accessor.offset(VTOFFSET.undLnkTrk.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func undLnkTrk(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.undLnkTrk.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Markings defining the source material or the original classification authority for the ACO message.
  ///  Example: /// Example: ORIG:USJFCOM
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var classSource: String? { let o = _accessor.offset(VTOFFSET.classSource.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classSourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classSource.v) }
  ///  Mandatory if classSource uses the "IORIG" designator. Must be a REASON FOR CLASSIFICATION code.
  ///  Example: /// Example: ['15C', '10C']
  ///  Constraints: No constraints specified.
  public var hasClassReason: Bool { let o = _accessor.offset(VTOFFSET.classReason.v); return o == 0 ? false : true }
  public var classReasonCount: Int32 { let o = _accessor.offset(VTOFFSET.classReason.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func classReason(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.classReason.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Markings providing the literal guidance or date for downgrading or declassifying the airspace control order. Manditory if declassExemptionCode is nul.
  ///  Example: /// Example: ['NST:AT EXERCISE ENDEX', 'DATE:25NOV1997']
  ///  Constraints: No constraints specified.
  public var hasDowngradeInsDate: Bool { let o = _accessor.offset(VTOFFSET.downgradeInsDate.v); return o == 0 ? false : true }
  public var downgradeInsDateCount: Int32 { let o = _accessor.offset(VTOFFSET.downgradeInsDate.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func downgradeInsDate(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.downgradeInsDate.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Coded entries that provide justification for exemption from automatic downgrading or declassification of the airspace control order.
  ///  Example: /// Example: ['X1', 'X2']
  ///  Constraints: No constraints specified.
  public var hasDeclassExemptionCode: Bool { let o = _accessor.offset(VTOFFSET.declassExemptionCode.v); return o == 0 ? false : true }
  public var declassExemptionCodeCount: Int32 { let o = _accessor.offset(VTOFFSET.declassExemptionCode.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func declassExemptionCode(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.declassExemptionCode.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  ///  Example: /// Example: AXE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var sourceDl: String? { let o = _accessor.offset(VTOFFSET.sourceDl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceDlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceDl.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: AirspaceControlOrder_Ingest_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : AirspaceControlOrder_Ingest_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  public static func startAirspaceControlOrder_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 33) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(rawFileUri: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rawFileUri, at: VTOFFSET.rawFileUri.p) }
  public static func add(opExName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: opExName, at: VTOFFSET.opExName.p) }
  public static func add(originator: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: originator, at: VTOFFSET.originator.p) }
  public static func add(startTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startTime, at: VTOFFSET.startTime.p) }
  public static func add(stopTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: stopTime, at: VTOFFSET.stopTime.p) }
  public static func add(stopQualifier: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: stopQualifier, at: VTOFFSET.stopQualifier.p) }
  public static func add(opExInfo: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: opExInfo, at: VTOFFSET.opExInfo.p) }
  public static func add(opExInfoAlt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: opExInfoAlt, at: VTOFFSET.opExInfoAlt.p) }
  public static func add(planOrigNum: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: planOrigNum, at: VTOFFSET.planOrigNum.p) }
  public static func add(serialNum: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: serialNum, at: VTOFFSET.serialNum.p) }
  public static func add(month: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: month, at: VTOFFSET.month.p) }
  public static func add(qualifier: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: qualifier, at: VTOFFSET.qualifier.p) }
  public static func add(qualSn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: qualSn, def: 0, at: VTOFFSET.qualSn.p) }
  public static func add(areaOfValidity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: areaOfValidity, at: VTOFFSET.areaOfValidity.p) }
  public static func add(acoSerialNum: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: acoSerialNum, at: VTOFFSET.acoSerialNum.p) }
  public static func add(geoDatum: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: geoDatum, at: VTOFFSET.geoDatum.p) }
  public static func add(acoComments: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: acoComments, at: VTOFFSET.acoComments.p) }
  public static func addVectorOf(airspaceControlOrderReferences: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: airspaceControlOrderReferences, at: VTOFFSET.airspaceControlOrderReferences.p) }
  public static func addVectorOf(airspaceControlMeansStatus: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: airspaceControlMeansStatus, at: VTOFFSET.airspaceControlMeansStatus.p) }
  public static func addVectorOf(undLnkTrk: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: undLnkTrk, at: VTOFFSET.undLnkTrk.p) }
  public static func add(classSource: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classSource, at: VTOFFSET.classSource.p) }
  public static func addVectorOf(classReason: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classReason, at: VTOFFSET.classReason.p) }
  public static func addVectorOf(downgradeInsDate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: downgradeInsDate, at: VTOFFSET.downgradeInsDate.p) }
  public static func addVectorOf(declassExemptionCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: declassExemptionCode, at: VTOFFSET.declassExemptionCode.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(sourceDl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceDl, at: VTOFFSET.sourceDl.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: AirspaceControlOrder_Ingest_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func endAirspaceControlOrder_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAirspaceControlOrder_Ingest(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    rawFileUriOffset rawFileUri: Offset = Offset(),
    opExNameOffset opExName: Offset = Offset(),
    originatorOffset originator: Offset = Offset(),
    startTimeOffset startTime: Offset = Offset(),
    stopTimeOffset stopTime: Offset = Offset(),
    stopQualifierOffset stopQualifier: Offset = Offset(),
    opExInfoOffset opExInfo: Offset = Offset(),
    opExInfoAltOffset opExInfoAlt: Offset = Offset(),
    planOrigNumOffset planOrigNum: Offset = Offset(),
    serialNumOffset serialNum: Offset = Offset(),
    monthOffset month: Offset = Offset(),
    qualifierOffset qualifier: Offset = Offset(),
    qualSn: Int32 = 0,
    areaOfValidityOffset areaOfValidity: Offset = Offset(),
    acoSerialNumOffset acoSerialNum: Offset = Offset(),
    geoDatumOffset geoDatum: Offset = Offset(),
    acoCommentsOffset acoComments: Offset = Offset(),
    airspaceControlOrderReferencesVectorOffset airspaceControlOrderReferences: Offset = Offset(),
    airspaceControlMeansStatusVectorOffset airspaceControlMeansStatus: Offset = Offset(),
    undLnkTrkVectorOffset undLnkTrk: Offset = Offset(),
    classSourceOffset classSource: Offset = Offset(),
    classReasonVectorOffset classReason: Offset = Offset(),
    downgradeInsDateVectorOffset downgradeInsDate: Offset = Offset(),
    declassExemptionCodeVectorOffset declassExemptionCode: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceDlOffset sourceDl: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: AirspaceControlOrder_Ingest_dataMode_Enum = .real
  ) -> Offset {
    let __start = AirspaceControlOrder_Ingest.startAirspaceControlOrder_Ingest(&fbb)
    AirspaceControlOrder_Ingest.add(id: id, &fbb)
    AirspaceControlOrder_Ingest.add(classificationMarking: classificationMarking, &fbb)
    AirspaceControlOrder_Ingest.add(rawFileUri: rawFileUri, &fbb)
    AirspaceControlOrder_Ingest.add(opExName: opExName, &fbb)
    AirspaceControlOrder_Ingest.add(originator: originator, &fbb)
    AirspaceControlOrder_Ingest.add(startTime: startTime, &fbb)
    AirspaceControlOrder_Ingest.add(stopTime: stopTime, &fbb)
    AirspaceControlOrder_Ingest.add(stopQualifier: stopQualifier, &fbb)
    AirspaceControlOrder_Ingest.add(opExInfo: opExInfo, &fbb)
    AirspaceControlOrder_Ingest.add(opExInfoAlt: opExInfoAlt, &fbb)
    AirspaceControlOrder_Ingest.add(planOrigNum: planOrigNum, &fbb)
    AirspaceControlOrder_Ingest.add(serialNum: serialNum, &fbb)
    AirspaceControlOrder_Ingest.add(month: month, &fbb)
    AirspaceControlOrder_Ingest.add(qualifier: qualifier, &fbb)
    AirspaceControlOrder_Ingest.add(qualSn: qualSn, &fbb)
    AirspaceControlOrder_Ingest.add(areaOfValidity: areaOfValidity, &fbb)
    AirspaceControlOrder_Ingest.add(acoSerialNum: acoSerialNum, &fbb)
    AirspaceControlOrder_Ingest.add(geoDatum: geoDatum, &fbb)
    AirspaceControlOrder_Ingest.add(acoComments: acoComments, &fbb)
    AirspaceControlOrder_Ingest.addVectorOf(airspaceControlOrderReferences: airspaceControlOrderReferences, &fbb)
    AirspaceControlOrder_Ingest.addVectorOf(airspaceControlMeansStatus: airspaceControlMeansStatus, &fbb)
    AirspaceControlOrder_Ingest.addVectorOf(undLnkTrk: undLnkTrk, &fbb)
    AirspaceControlOrder_Ingest.add(classSource: classSource, &fbb)
    AirspaceControlOrder_Ingest.addVectorOf(classReason: classReason, &fbb)
    AirspaceControlOrder_Ingest.addVectorOf(downgradeInsDate: downgradeInsDate, &fbb)
    AirspaceControlOrder_Ingest.addVectorOf(declassExemptionCode: declassExemptionCode, &fbb)
    AirspaceControlOrder_Ingest.add(createdAt: createdAt, &fbb)
    AirspaceControlOrder_Ingest.add(createdBy: createdBy, &fbb)
    AirspaceControlOrder_Ingest.add(sourceDl: sourceDl, &fbb)
    AirspaceControlOrder_Ingest.add(source: source, &fbb)
    AirspaceControlOrder_Ingest.add(origin: origin, &fbb)
    AirspaceControlOrder_Ingest.add(origNetwork: origNetwork, &fbb)
    AirspaceControlOrder_Ingest.add(dataMode: dataMode, &fbb)
    return AirspaceControlOrder_Ingest.endAirspaceControlOrder_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rawFileUri.p, fieldName: "rawFileUri", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.opExName.p, fieldName: "opExName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.originator.p, fieldName: "originator", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.startTime.p, fieldName: "startTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.stopTime.p, fieldName: "stopTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.stopQualifier.p, fieldName: "stopQualifier", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.opExInfo.p, fieldName: "opExInfo", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.opExInfoAlt.p, fieldName: "opExInfoAlt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.planOrigNum.p, fieldName: "planOrigNum", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.serialNum.p, fieldName: "serialNum", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.month.p, fieldName: "month", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.qualifier.p, fieldName: "qualifier", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.qualSn.p, fieldName: "qualSn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.areaOfValidity.p, fieldName: "areaOfValidity", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.acoSerialNum.p, fieldName: "acoSerialNum", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.geoDatum.p, fieldName: "geoDatum", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.acoComments.p, fieldName: "acoComments", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.airspaceControlOrderReferences.p, fieldName: "airspaceControlOrderReferences", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.airspaceControlMeansStatus.p, fieldName: "airspaceControlMeansStatus", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.undLnkTrk.p, fieldName: "undLnkTrk", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.classSource.p, fieldName: "classSource", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classReason.p, fieldName: "classReason", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.downgradeInsDate.p, fieldName: "downgradeInsDate", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.declassExemptionCode.p, fieldName: "declassExemptionCode", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceDl.p, fieldName: "sourceDl", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: AirspaceControlOrder_Ingest_dataMode_Enum.self)
    _v.finish()
  }
}

