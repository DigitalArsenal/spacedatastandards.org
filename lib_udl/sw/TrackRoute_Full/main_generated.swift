// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum TrackRoute_Full_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: TrackRoute_Full_dataMode_Enum { return .exercise }
  public static var min: TrackRoute_Full_dataMode_Enum { return .real }
}


///  /// A track route is a prescribed route for performing training events or operations such as air refueling.
public struct TrackRoute_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TRAC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: TrackRoute_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case type = 8
    case externalId = 10
    case direction = 12
    case creatingOrg = 14
    case locationTrackId = 16
    case trackId = 18
    case trackName = 20
    case shortName = 22
    case typeCode = 24
    case regionCode = 26
    case regionName = 28
    case apxBeaconCode = 30
    case receiverTankerChcode = 32
    case apnSetting = 34
    case sic = 36
    case reviewDate = 38
    case lastUsedDate = 40
    case lastUpdateDate = 42
    case priFreq = 44
    case secFreq = 46
    case artccMessage = 48
    case schedulerOrgName = 50
    case schedulerOrgUnit = 52
    case effectiveDate = 54
    case routePoints = 56
    case altitudeBlocks = 58
    case poc = 60
    case createdAt = 62
    case createdBy = 64
    case updatedAt = 66
    case updatedBy = 68
    case sourceDl = 70
    case source = 72
    case origin = 74
    case origNetwork = 76
    case dataMode = 78
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  The track route type represented by this record (ex. AIR REFUELING).
  ///  Example: /// Example: AIR REFUELING
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  ///  Optional air refueling track ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  ///  Example: /// Example: GDSSMH121004232315303094
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var externalId: String? { let o = _accessor.offset(VTOFFSET.externalId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var externalIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.externalId.v) }
  ///  The principal compass direction (cardinal or ordinal) of the track route.
  ///  Example: /// Example: NE
  ///  Constraints: Minimum length = 0, Maximum length = 2
  public var direction: String? { let o = _accessor.offset(VTOFFSET.direction.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var directionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.direction.v) }
  ///  The name of the creating organization of the track route.
  ///  Example: /// Example: HQPAC
  ///  Constraints: Minimum length = 0, Maximum length = 250
  public var creatingOrg: String? { let o = _accessor.offset(VTOFFSET.creatingOrg.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var creatingOrgSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.creatingOrg.v) }
  ///  Track location ID.
  ///  Example: /// Example: POACHR
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var locationTrackId: String? { let o = _accessor.offset(VTOFFSET.locationTrackId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var locationTrackIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.locationTrackId.v) }
  ///  Identifier of the track.
  ///  Example: /// Example: CH61A
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var trackId: String? { let o = _accessor.offset(VTOFFSET.trackId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var trackIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.trackId.v) }
  ///  Name of the track.
  ///  Example: /// Example: CH61 POST
  ///  Constraints: Minimum length = 0, Maximum length = 50
  public var trackName: String? { let o = _accessor.offset(VTOFFSET.trackName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var trackNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.trackName.v) }
  ///  Abbreviated name of the track.
  ///  Example: /// Example: CH61
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var shortName: String? { let o = _accessor.offset(VTOFFSET.shortName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var shortNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.shortName.v) }
  ///  Type of process used by AMC to schedule an air refueling event. Possible values are A (Matched Long Range), F (Matched AMC Short Notice), N (Unmatched Theater Operation Short Notice (Theater Assets)), R, Unmatched Long Range, S (Soft Air Refueling), T (Matched Theater Operation Short Notice (Theater Assets)), V (Unmatched AMC Short Notice), X (Unmatched Theater Operation Short Notice (AMC Assets)), Y (Matched Theater Operation Short Notice (AMC Assets)), Z (Other Air Refueling).
  ///  Example: /// Example: V
  ///  Constraints: Minimum length = 0, Maximum length = 2
  public var typeCode: String? { let o = _accessor.offset(VTOFFSET.typeCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.typeCode.v) }
  ///  Region code indicating where the track resides as determined by the data source.
  ///  Example: /// Example: 5
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var regionCode: String? { let o = _accessor.offset(VTOFFSET.regionCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var regionCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.regionCode.v) }
  ///  Region where the track resides.
  ///  Example: /// Example: North America
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var regionName: String? { let o = _accessor.offset(VTOFFSET.regionName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var regionNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.regionName.v) }
  ///  The APX radar code sent and received by the aircraft for identification.
  ///  Example: /// Example: 5/1
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var apxBeaconCode: String? { let o = _accessor.offset(VTOFFSET.apxBeaconCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var apxBeaconCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.apxBeaconCode.v) }
  ///  The receiver tanker channel identifer for air refueling tracks.
  ///  Example: /// Example: 31/094
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var receiverTankerChcode: String? { let o = _accessor.offset(VTOFFSET.receiverTankerChcode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var receiverTankerChcodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.receiverTankerChcode.v) }
  ///  The APN radar code sent and received by the aircraft for identification.
  ///  Example: /// Example: 1-3-1
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var apnSetting: String? { let o = _accessor.offset(VTOFFSET.apnSetting.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var apnSettingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.apnSetting.v) }
  ///  Standard Indicator Code of the air refueling track.
  ///  Example: /// Example: N
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var sic: String? { let o = _accessor.offset(VTOFFSET.sic.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sicSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sic.v) }
  ///  Date the track needs to be reviewed for accuracy or deletion in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-09-16T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var reviewDate: String? { let o = _accessor.offset(VTOFFSET.reviewDate.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reviewDateSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reviewDate.v) }
  ///  Used to show last time the track route was added to an itinerary in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-09-17T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var lastUsedDate: String? { let o = _accessor.offset(VTOFFSET.lastUsedDate.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var lastUsedDateSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.lastUsedDate.v) }
  ///  The last updated date of the track route in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-09-17T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var lastUpdateDate: String? { let o = _accessor.offset(VTOFFSET.lastUpdateDate.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var lastUpdateDateSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.lastUpdateDate.v) }
  ///  The primary UHF radio frequency used for the track route in megahertz.
  ///  Example: /// Example: 357.5
  ///  Constraints: No constraints specified.
  public var priFreq: Double { let o = _accessor.offset(VTOFFSET.priFreq.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The secondary UHF radio frequency used for the track route in megahertz.
  ///  Example: /// Example: 319.7
  ///  Constraints: No constraints specified.
  public var secFreq: Double { let o = _accessor.offset(VTOFFSET.secFreq.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Air Refueling Track Control Center message.
  ///  Example: /// Example: OAKLAND CTR/GUAM CERAP
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var artccMessage: String? { let o = _accessor.offset(VTOFFSET.artccMessage.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var artccMessageSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.artccMessage.v) }
  ///  Point of contact for the air refueling track route scheduler.
  ///  Example: /// Example: 97 OSS/OSOS DSN 866-5555
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var schedulerOrgName: String? { let o = _accessor.offset(VTOFFSET.schedulerOrgName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var schedulerOrgNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.schedulerOrgName.v) }
  ///  The unit responsible for scheduling the track route.
  ///  Example: /// Example: 612 AOC
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var schedulerOrgUnit: String? { let o = _accessor.offset(VTOFFSET.schedulerOrgUnit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var schedulerOrgUnitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.schedulerOrgUnit.v) }
  ///  The date which the DAFIF track was last updated/validated in ISO 8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-09-17T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var effectiveDate: String? { let o = _accessor.offset(VTOFFSET.effectiveDate.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var effectiveDateSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.effectiveDate.v) }
  ///  Points identified within the route.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasRoutePoints: Bool { let o = _accessor.offset(VTOFFSET.routePoints.v); return o == 0 ? false : true }
  public var routePointsCount: Int32 { let o = _accessor.offset(VTOFFSET.routePoints.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func routePoints(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.routePoints.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Minimum and maximum altitude bounds for the track.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasAltitudeBlocks: Bool { let o = _accessor.offset(VTOFFSET.altitudeBlocks.v); return o == 0 ? false : true }
  public var altitudeBlocksCount: Int32 { let o = _accessor.offset(VTOFFSET.altitudeBlocks.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func altitudeBlocks(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.altitudeBlocks.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Point of contacts for scheduling or modifying the route.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasPoc: Bool { let o = _accessor.offset(VTOFFSET.poc.v); return o == 0 ? false : true }
  public var pocCount: Int32 { let o = _accessor.offset(VTOFFSET.poc.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func poc(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.poc.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2022-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Time the row was updated in the database, auto-populated by the system.
  ///  Example: /// Example: 2022-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var updatedAt: String? { let o = _accessor.offset(VTOFFSET.updatedAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedAt.v) }
  ///  Application user who updated the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var updatedBy: String? { let o = _accessor.offset(VTOFFSET.updatedBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedBy.v) }
  ///  The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  ///  Example: /// Example: AXE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var sourceDl: String? { let o = _accessor.offset(VTOFFSET.sourceDl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceDlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceDl.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: OPS1
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: TrackRoute_Full_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : TrackRoute_Full_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  public static func startTrackRoute_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 38) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func add(externalId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: externalId, at: VTOFFSET.externalId.p) }
  public static func add(direction: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: direction, at: VTOFFSET.direction.p) }
  public static func add(creatingOrg: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: creatingOrg, at: VTOFFSET.creatingOrg.p) }
  public static func add(locationTrackId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: locationTrackId, at: VTOFFSET.locationTrackId.p) }
  public static func add(trackId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: trackId, at: VTOFFSET.trackId.p) }
  public static func add(trackName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: trackName, at: VTOFFSET.trackName.p) }
  public static func add(shortName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: shortName, at: VTOFFSET.shortName.p) }
  public static func add(typeCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: typeCode, at: VTOFFSET.typeCode.p) }
  public static func add(regionCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: regionCode, at: VTOFFSET.regionCode.p) }
  public static func add(regionName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: regionName, at: VTOFFSET.regionName.p) }
  public static func add(apxBeaconCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: apxBeaconCode, at: VTOFFSET.apxBeaconCode.p) }
  public static func add(receiverTankerChcode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: receiverTankerChcode, at: VTOFFSET.receiverTankerChcode.p) }
  public static func add(apnSetting: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: apnSetting, at: VTOFFSET.apnSetting.p) }
  public static func add(sic: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sic, at: VTOFFSET.sic.p) }
  public static func add(reviewDate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reviewDate, at: VTOFFSET.reviewDate.p) }
  public static func add(lastUsedDate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lastUsedDate, at: VTOFFSET.lastUsedDate.p) }
  public static func add(lastUpdateDate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lastUpdateDate, at: VTOFFSET.lastUpdateDate.p) }
  public static func add(priFreq: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: priFreq, def: 0.0, at: VTOFFSET.priFreq.p) }
  public static func add(secFreq: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: secFreq, def: 0.0, at: VTOFFSET.secFreq.p) }
  public static func add(artccMessage: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: artccMessage, at: VTOFFSET.artccMessage.p) }
  public static func add(schedulerOrgName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: schedulerOrgName, at: VTOFFSET.schedulerOrgName.p) }
  public static func add(schedulerOrgUnit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: schedulerOrgUnit, at: VTOFFSET.schedulerOrgUnit.p) }
  public static func add(effectiveDate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: effectiveDate, at: VTOFFSET.effectiveDate.p) }
  public static func addVectorOf(routePoints: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: routePoints, at: VTOFFSET.routePoints.p) }
  public static func addVectorOf(altitudeBlocks: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: altitudeBlocks, at: VTOFFSET.altitudeBlocks.p) }
  public static func addVectorOf(poc: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: poc, at: VTOFFSET.poc.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(updatedAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedAt, at: VTOFFSET.updatedAt.p) }
  public static func add(updatedBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedBy, at: VTOFFSET.updatedBy.p) }
  public static func add(sourceDl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceDl, at: VTOFFSET.sourceDl.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: TrackRoute_Full_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func endTrackRoute_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTrackRoute_Full(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    typeOffset type: Offset = Offset(),
    externalIdOffset externalId: Offset = Offset(),
    directionOffset direction: Offset = Offset(),
    creatingOrgOffset creatingOrg: Offset = Offset(),
    locationTrackIdOffset locationTrackId: Offset = Offset(),
    trackIdOffset trackId: Offset = Offset(),
    trackNameOffset trackName: Offset = Offset(),
    shortNameOffset shortName: Offset = Offset(),
    typeCodeOffset typeCode: Offset = Offset(),
    regionCodeOffset regionCode: Offset = Offset(),
    regionNameOffset regionName: Offset = Offset(),
    apxBeaconCodeOffset apxBeaconCode: Offset = Offset(),
    receiverTankerChcodeOffset receiverTankerChcode: Offset = Offset(),
    apnSettingOffset apnSetting: Offset = Offset(),
    sicOffset sic: Offset = Offset(),
    reviewDateOffset reviewDate: Offset = Offset(),
    lastUsedDateOffset lastUsedDate: Offset = Offset(),
    lastUpdateDateOffset lastUpdateDate: Offset = Offset(),
    priFreq: Double = 0.0,
    secFreq: Double = 0.0,
    artccMessageOffset artccMessage: Offset = Offset(),
    schedulerOrgNameOffset schedulerOrgName: Offset = Offset(),
    schedulerOrgUnitOffset schedulerOrgUnit: Offset = Offset(),
    effectiveDateOffset effectiveDate: Offset = Offset(),
    routePointsVectorOffset routePoints: Offset = Offset(),
    altitudeBlocksVectorOffset altitudeBlocks: Offset = Offset(),
    pocVectorOffset poc: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    updatedAtOffset updatedAt: Offset = Offset(),
    updatedByOffset updatedBy: Offset = Offset(),
    sourceDlOffset sourceDl: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: TrackRoute_Full_dataMode_Enum = .real
  ) -> Offset {
    let __start = TrackRoute_Full.startTrackRoute_Full(&fbb)
    TrackRoute_Full.add(id: id, &fbb)
    TrackRoute_Full.add(classificationMarking: classificationMarking, &fbb)
    TrackRoute_Full.add(type: type, &fbb)
    TrackRoute_Full.add(externalId: externalId, &fbb)
    TrackRoute_Full.add(direction: direction, &fbb)
    TrackRoute_Full.add(creatingOrg: creatingOrg, &fbb)
    TrackRoute_Full.add(locationTrackId: locationTrackId, &fbb)
    TrackRoute_Full.add(trackId: trackId, &fbb)
    TrackRoute_Full.add(trackName: trackName, &fbb)
    TrackRoute_Full.add(shortName: shortName, &fbb)
    TrackRoute_Full.add(typeCode: typeCode, &fbb)
    TrackRoute_Full.add(regionCode: regionCode, &fbb)
    TrackRoute_Full.add(regionName: regionName, &fbb)
    TrackRoute_Full.add(apxBeaconCode: apxBeaconCode, &fbb)
    TrackRoute_Full.add(receiverTankerChcode: receiverTankerChcode, &fbb)
    TrackRoute_Full.add(apnSetting: apnSetting, &fbb)
    TrackRoute_Full.add(sic: sic, &fbb)
    TrackRoute_Full.add(reviewDate: reviewDate, &fbb)
    TrackRoute_Full.add(lastUsedDate: lastUsedDate, &fbb)
    TrackRoute_Full.add(lastUpdateDate: lastUpdateDate, &fbb)
    TrackRoute_Full.add(priFreq: priFreq, &fbb)
    TrackRoute_Full.add(secFreq: secFreq, &fbb)
    TrackRoute_Full.add(artccMessage: artccMessage, &fbb)
    TrackRoute_Full.add(schedulerOrgName: schedulerOrgName, &fbb)
    TrackRoute_Full.add(schedulerOrgUnit: schedulerOrgUnit, &fbb)
    TrackRoute_Full.add(effectiveDate: effectiveDate, &fbb)
    TrackRoute_Full.addVectorOf(routePoints: routePoints, &fbb)
    TrackRoute_Full.addVectorOf(altitudeBlocks: altitudeBlocks, &fbb)
    TrackRoute_Full.addVectorOf(poc: poc, &fbb)
    TrackRoute_Full.add(createdAt: createdAt, &fbb)
    TrackRoute_Full.add(createdBy: createdBy, &fbb)
    TrackRoute_Full.add(updatedAt: updatedAt, &fbb)
    TrackRoute_Full.add(updatedBy: updatedBy, &fbb)
    TrackRoute_Full.add(sourceDl: sourceDl, &fbb)
    TrackRoute_Full.add(source: source, &fbb)
    TrackRoute_Full.add(origin: origin, &fbb)
    TrackRoute_Full.add(origNetwork: origNetwork, &fbb)
    TrackRoute_Full.add(dataMode: dataMode, &fbb)
    return TrackRoute_Full.endTrackRoute_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.externalId.p, fieldName: "externalId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.direction.p, fieldName: "direction", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.creatingOrg.p, fieldName: "creatingOrg", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.locationTrackId.p, fieldName: "locationTrackId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.trackId.p, fieldName: "trackId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.trackName.p, fieldName: "trackName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.shortName.p, fieldName: "shortName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.typeCode.p, fieldName: "typeCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.regionCode.p, fieldName: "regionCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.regionName.p, fieldName: "regionName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.apxBeaconCode.p, fieldName: "apxBeaconCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.receiverTankerChcode.p, fieldName: "receiverTankerChcode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.apnSetting.p, fieldName: "apnSetting", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sic.p, fieldName: "sic", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.reviewDate.p, fieldName: "reviewDate", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.lastUsedDate.p, fieldName: "lastUsedDate", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.lastUpdateDate.p, fieldName: "lastUpdateDate", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.priFreq.p, fieldName: "priFreq", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.secFreq.p, fieldName: "secFreq", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.artccMessage.p, fieldName: "artccMessage", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.schedulerOrgName.p, fieldName: "schedulerOrgName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.schedulerOrgUnit.p, fieldName: "schedulerOrgUnit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.effectiveDate.p, fieldName: "effectiveDate", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.routePoints.p, fieldName: "routePoints", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.altitudeBlocks.p, fieldName: "altitudeBlocks", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.poc.p, fieldName: "poc", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedAt.p, fieldName: "updatedAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedBy.p, fieldName: "updatedBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceDl.p, fieldName: "sourceDl", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: TrackRoute_Full_dataMode_Enum.self)
    _v.finish()
  }
}

