// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum LaunchDetection_Full_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: LaunchDetection_Full_dataMode_Enum { return .exercise }
  public static var min: LaunchDetection_Full_dataMode_Enum { return .real }
}


///  /// Data to analyze launch detections.
public struct LaunchDetection_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "LAUN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: LaunchDetection_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case launchTime = 8
    case messageType = 10
    case launchLatitude = 12
    case launchLongitude = 14
    case launchAzimuth = 16
    case raan = 18
    case inclination = 20
    case observationTime = 22
    case observationLatitude = 24
    case observationLongitude = 26
    case observationAltitude = 28
    case stereoFlag = 30
    case highZenithAzimuth = 32
    case sequenceNumber = 34
    case eventId = 36
    case source = 38
    case origin = 40
    case descriptor = 42
    case tags = 44
    case origNetwork = 46
    case dataMode = 48
    case createdAt = 50
    case createdBy = 52
    case updatedAt = 54
    case updatedBy = 56
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: LAUNCHDETECTION-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Time of Launch.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var launchTime: String? { let o = _accessor.offset(VTOFFSET.launchTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var launchTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.launchTime.v) }
  ///  Type of message for the data.
  ///  Example: /// Example: Example-Msg-Type
  ///  Constraints: Minimum length = 1, Maximum length = 16
  public var messageType: String? { let o = _accessor.offset(VTOFFSET.messageType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var messageTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.messageType.v) }
  ///  Geodetic Latitude of launch origin (in Degrees). -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var launchLatitude: Double { let o = _accessor.offset(VTOFFSET.launchLatitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Geodetic Longitude of launch origin (in Degrees). -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var launchLongitude: Double { let o = _accessor.offset(VTOFFSET.launchLongitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Angle measured clockwise from North for the launch heading (in Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var launchAzimuth: Double { let o = _accessor.offset(VTOFFSET.launchAzimuth.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Orbit Right Ascension of Ascending Node (in Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var raan: Double { let o = _accessor.offset(VTOFFSET.raan.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Orbit Inclination (in Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var inclination: Double { let o = _accessor.offset(VTOFFSET.inclination.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Time of observation.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var observationTime: String? { let o = _accessor.offset(VTOFFSET.observationTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var observationTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.observationTime.v) }
  ///  Latitude of launch vehicle at observation time (in Degrees). -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 45.23
  ///  Constraints: No constraints specified.
  public var observationLatitude: Double { let o = _accessor.offset(VTOFFSET.observationLatitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Longitude of launch vehicle at observation time (in Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var observationLongitude: Double { let o = _accessor.offset(VTOFFSET.observationLongitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Altitude of launch vehicle at observation time (in KM).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  public var observationAltitude: Double { let o = _accessor.offset(VTOFFSET.observationAltitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Flag indicating multiple observers were used.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var stereoFlag: Bool { let o = _accessor.offset(VTOFFSET.stereoFlag.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating that the Launch azimuth is uncertain due to near vertical flight path.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var highZenithAzimuth: Bool { let o = _accessor.offset(VTOFFSET.highZenithAzimuth.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Integer indicating how messages should be sequenced for a specific event.
  ///  Example: /// Example: 5
  ///  Constraints: No constraints specified.
  public var sequenceNumber: Int32 { let o = _accessor.offset(VTOFFSET.sequenceNumber.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Id to be able to correlate different messages to a specific event.
  ///  Example: /// Example: EVENT-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var eventId: String? { let o = _accessor.offset(VTOFFSET.eventId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var eventIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.eventId.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  Optional source-provided and searchable metadata or descriptor of the data.
  ///  Example: /// Example: Example descriptor
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var descriptor: String? { let o = _accessor.offset(VTOFFSET.descriptor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.descriptor.v) }
  ///  Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  ///  Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
  ///  Constraints: No constraints specified.
  public var hasTags: Bool { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? false : true }
  public var tagsCount: Int32 { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tags(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: LaunchDetection_Full_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : LaunchDetection_Full_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Time the row was created in the database.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Read-only time the row was updated in the database, set automatically by the system on update.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var updatedAt: String? { let o = _accessor.offset(VTOFFSET.updatedAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedAt.v) }
  ///  Application user who last updated the row in the database, set by the system automatically and ignored on create/edit operations.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var updatedBy: String? { let o = _accessor.offset(VTOFFSET.updatedBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedBy.v) }
  public static func startLaunchDetection_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 27) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(launchTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: launchTime, at: VTOFFSET.launchTime.p) }
  public static func add(messageType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: messageType, at: VTOFFSET.messageType.p) }
  public static func add(launchLatitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: launchLatitude, def: 0.0, at: VTOFFSET.launchLatitude.p) }
  public static func add(launchLongitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: launchLongitude, def: 0.0, at: VTOFFSET.launchLongitude.p) }
  public static func add(launchAzimuth: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: launchAzimuth, def: 0.0, at: VTOFFSET.launchAzimuth.p) }
  public static func add(raan: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: raan, def: 0.0, at: VTOFFSET.raan.p) }
  public static func add(inclination: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: inclination, def: 0.0, at: VTOFFSET.inclination.p) }
  public static func add(observationTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: observationTime, at: VTOFFSET.observationTime.p) }
  public static func add(observationLatitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: observationLatitude, def: 0.0, at: VTOFFSET.observationLatitude.p) }
  public static func add(observationLongitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: observationLongitude, def: 0.0, at: VTOFFSET.observationLongitude.p) }
  public static func add(observationAltitude: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: observationAltitude, def: 0.0, at: VTOFFSET.observationAltitude.p) }
  public static func add(stereoFlag: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stereoFlag, def: false,
   at: VTOFFSET.stereoFlag.p) }
  public static func add(highZenithAzimuth: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: highZenithAzimuth, def: false,
   at: VTOFFSET.highZenithAzimuth.p) }
  public static func add(sequenceNumber: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sequenceNumber, def: 0, at: VTOFFSET.sequenceNumber.p) }
  public static func add(eventId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: eventId, at: VTOFFSET.eventId.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(descriptor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: descriptor, at: VTOFFSET.descriptor.p) }
  public static func addVectorOf(tags: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tags, at: VTOFFSET.tags.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: LaunchDetection_Full_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(updatedAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedAt, at: VTOFFSET.updatedAt.p) }
  public static func add(updatedBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedBy, at: VTOFFSET.updatedBy.p) }
  public static func endLaunchDetection_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLaunchDetection_Full(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    launchTimeOffset launchTime: Offset = Offset(),
    messageTypeOffset messageType: Offset = Offset(),
    launchLatitude: Double = 0.0,
    launchLongitude: Double = 0.0,
    launchAzimuth: Double = 0.0,
    raan: Double = 0.0,
    inclination: Double = 0.0,
    observationTimeOffset observationTime: Offset = Offset(),
    observationLatitude: Double = 0.0,
    observationLongitude: Double = 0.0,
    observationAltitude: Double = 0.0,
    stereoFlag: Bool = false,
    highZenithAzimuth: Bool = false,
    sequenceNumber: Int32 = 0,
    eventIdOffset eventId: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    descriptorOffset descriptor: Offset = Offset(),
    tagsVectorOffset tags: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: LaunchDetection_Full_dataMode_Enum = .real,
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    updatedAtOffset updatedAt: Offset = Offset(),
    updatedByOffset updatedBy: Offset = Offset()
  ) -> Offset {
    let __start = LaunchDetection_Full.startLaunchDetection_Full(&fbb)
    LaunchDetection_Full.add(id: id, &fbb)
    LaunchDetection_Full.add(classificationMarking: classificationMarking, &fbb)
    LaunchDetection_Full.add(launchTime: launchTime, &fbb)
    LaunchDetection_Full.add(messageType: messageType, &fbb)
    LaunchDetection_Full.add(launchLatitude: launchLatitude, &fbb)
    LaunchDetection_Full.add(launchLongitude: launchLongitude, &fbb)
    LaunchDetection_Full.add(launchAzimuth: launchAzimuth, &fbb)
    LaunchDetection_Full.add(raan: raan, &fbb)
    LaunchDetection_Full.add(inclination: inclination, &fbb)
    LaunchDetection_Full.add(observationTime: observationTime, &fbb)
    LaunchDetection_Full.add(observationLatitude: observationLatitude, &fbb)
    LaunchDetection_Full.add(observationLongitude: observationLongitude, &fbb)
    LaunchDetection_Full.add(observationAltitude: observationAltitude, &fbb)
    LaunchDetection_Full.add(stereoFlag: stereoFlag, &fbb)
    LaunchDetection_Full.add(highZenithAzimuth: highZenithAzimuth, &fbb)
    LaunchDetection_Full.add(sequenceNumber: sequenceNumber, &fbb)
    LaunchDetection_Full.add(eventId: eventId, &fbb)
    LaunchDetection_Full.add(source: source, &fbb)
    LaunchDetection_Full.add(origin: origin, &fbb)
    LaunchDetection_Full.add(descriptor: descriptor, &fbb)
    LaunchDetection_Full.addVectorOf(tags: tags, &fbb)
    LaunchDetection_Full.add(origNetwork: origNetwork, &fbb)
    LaunchDetection_Full.add(dataMode: dataMode, &fbb)
    LaunchDetection_Full.add(createdAt: createdAt, &fbb)
    LaunchDetection_Full.add(createdBy: createdBy, &fbb)
    LaunchDetection_Full.add(updatedAt: updatedAt, &fbb)
    LaunchDetection_Full.add(updatedBy: updatedBy, &fbb)
    return LaunchDetection_Full.endLaunchDetection_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.launchTime.p, fieldName: "launchTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.messageType.p, fieldName: "messageType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.launchLatitude.p, fieldName: "launchLatitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.launchLongitude.p, fieldName: "launchLongitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.launchAzimuth.p, fieldName: "launchAzimuth", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.raan.p, fieldName: "raan", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.inclination.p, fieldName: "inclination", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.observationTime.p, fieldName: "observationTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.observationLatitude.p, fieldName: "observationLatitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.observationLongitude.p, fieldName: "observationLongitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.observationAltitude.p, fieldName: "observationAltitude", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.stereoFlag.p, fieldName: "stereoFlag", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.highZenithAzimuth.p, fieldName: "highZenithAzimuth", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.sequenceNumber.p, fieldName: "sequenceNumber", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.eventId.p, fieldName: "eventId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.descriptor.p, fieldName: "descriptor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.tags.p, fieldName: "tags", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: LaunchDetection_Full_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedAt.p, fieldName: "updatedAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedBy.p, fieldName: "updatedBy", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

