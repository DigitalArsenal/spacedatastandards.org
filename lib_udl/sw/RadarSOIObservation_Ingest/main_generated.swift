// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  /// A Radar SOI record contains observation information taken from a sensor about a Space Object.
public struct RadarSOIObservation_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "RADA" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: RadarSOIObservation_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case obStartTime = 4
    case tovs = 6
    case rspaces = 8
    case xspaces = 10
    case doppler2Xrs = 12
    case deltaTimes = 14
    case aspectAngles = 16
    case projAngVels = 18
    case idStateVector = 20
    case idAttitudeSet = 22
    case ranges = 24
    case azimuths = 26
    case elevations = 28
    case rangeRates = 30
    case azimuthRates = 32
    case elevationRates = 34
    case azimuthBiases = 36
    case elevationBiases = 38
    case rangeBiases = 40
    case integrationAngles = 42
    case crossRangeRes = 44
    case beta = 46
    case kappa = 48
    case peakAmplitudes = 50
    case centerFrequency = 52
    case pulseBandwidth = 54
    case xpos = 56
    case ypos = 58
    case zpos = 60
    case xvel = 62
    case yvel = 64
    case zvel = 66
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Observation detection start time in ISO 8601 UTC format with microsecond precision.
  ///  Example: /// Example: 2018-01-01T16:00:00.888456Z
  ///  Constraints: No constraints specified.
  public var obStartTime: String? { let o = _accessor.offset(VTOFFSET.obStartTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var obStartTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.obStartTime.v) }
  ///  Array of the times of validity in ISO 8601 UTC format with microsecond precision.
  ///  Example: /// Example: ['2018-01-01T16:00:00.888456Z', '2018-01-01T16:00:00.888456Z', '2018-01-01T16:00:00.888456Z']
  ///  Constraints: No constraints specified.
  public var hasTovs: Bool { let o = _accessor.offset(VTOFFSET.tovs.v); return o == 0 ? false : true }
  public var tovsCount: Int32 { let o = _accessor.offset(VTOFFSET.tovs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tovs(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tovs.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of range sample spacing in meters. The 'tov' and 'rspace' arrays must match in size.
  ///  Example: /// Example: [0.006, 0.006, 0.006]
  ///  Constraints: No constraints specified.
  public var hasRspaces: Bool { let o = _accessor.offset(VTOFFSET.rspaces.v); return o == 0 ? false : true }
  public var rspacesCount: Int32 { let o = _accessor.offset(VTOFFSET.rspaces.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func rspaces(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.rspaces.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of cross-range sample spacing in meters. The 'tov' and 'xspace' arrays must match in size.
  ///  Example: /// Example: [0.006, 0.006, 0.006]
  ///  Constraints: No constraints specified.
  public var hasXspaces: Bool { let o = _accessor.offset(VTOFFSET.xspaces.v); return o == 0 ? false : true }
  public var xspacesCount: Int32 { let o = _accessor.offset(VTOFFSET.xspaces.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func xspaces(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.xspaces.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of conversion factors between Doppler in hertz and cross-range in meters. The 'tov' and 'doppler2XR' arrays must match in size.
  ///  Example: /// Example: [5644.27, 5644.27, 5644.27]
  ///  Constraints: No constraints specified.
  public var hasDoppler2Xrs: Bool { let o = _accessor.offset(VTOFFSET.doppler2Xrs.v); return o == 0 ? false : true }
  public var doppler2XrsCount: Int32 { let o = _accessor.offset(VTOFFSET.doppler2Xrs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func doppler2Xrs(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.doppler2Xrs.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of average Interpulse spacing in seconds. The 'tov' and 'deltaTime' arrays must match in size.
  ///  Example: /// Example: [0.005, 0.005, 0.005]
  ///  Constraints: No constraints specified.
  public var hasDeltaTimes: Bool { let o = _accessor.offset(VTOFFSET.deltaTimes.v); return o == 0 ? false : true }
  public var deltaTimesCount: Int32 { let o = _accessor.offset(VTOFFSET.deltaTimes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func deltaTimes(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.deltaTimes.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the aspect angle at the center of the image in degrees.  The 'tov' and 'aspectAngle' arrays must match in size.
  ///  Example: /// Example: [4.278, 4.278, 4.278]
  ///  Constraints: No constraints specified.
  public var hasAspectAngles: Bool { let o = _accessor.offset(VTOFFSET.aspectAngles.v); return o == 0 ? false : true }
  public var aspectAnglesCount: Int32 { let o = _accessor.offset(VTOFFSET.aspectAngles.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func aspectAngles(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.aspectAngles.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the component of target angular velocity observable by radar in radians per second.  The 'tov' and 'projAngVel' arrays must match in size.
  ///  Example: /// Example: [0.166, 0.166, 0.166]
  ///  Constraints: No constraints specified.
  public var hasProjAngVels: Bool { let o = _accessor.offset(VTOFFSET.projAngVels.v); return o == 0 ? false : true }
  public var projAngVelsCount: Int32 { let o = _accessor.offset(VTOFFSET.projAngVels.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func projAngVels(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.projAngVels.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Optional id of assumed StateVector of object being observed.
  ///  Example: /// Example: 99a0de63-b38f-4d81-b057
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idStateVector: String? { let o = _accessor.offset(VTOFFSET.idStateVector.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idStateVectorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idStateVector.v) }
  ///  Optional id of assumed AttitudeSet of object being observed.
  ///  Example: /// Example: 99a0de63-b38f-4d81-b057
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idAttitudeSet: String? { let o = _accessor.offset(VTOFFSET.idAttitudeSet.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idAttitudeSetSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idAttitudeSet.v) }
  ///  Array of the range to target at image center in kilometers. The 'tov' and 'range' arrays must match in size.
  ///  Example: /// Example: [877.938, 877.938, 877.938]
  ///  Constraints: No constraints specified.
  public var hasRanges: Bool { let o = _accessor.offset(VTOFFSET.ranges.v); return o == 0 ? false : true }
  public var rangesCount: Int32 { let o = _accessor.offset(VTOFFSET.ranges.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ranges(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.ranges.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the azimuth angle to target at image center in degrees. The 'tov' and 'azimuth' arrays must match in size.
  ///  Example: /// Example: [278.27, 278.27, 278.27]
  ///  Constraints: No constraints specified.
  public var hasAzimuths: Bool { let o = _accessor.offset(VTOFFSET.azimuths.v); return o == 0 ? false : true }
  public var azimuthsCount: Int32 { let o = _accessor.offset(VTOFFSET.azimuths.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func azimuths(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.azimuths.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the elevation angle to target at image center in degrees. The 'tov' and 'elevation' arrays must match in size.
  ///  Example: /// Example: [70.85, 70.85, 70.85]
  ///  Constraints: No constraints specified.
  public var hasElevations: Bool { let o = _accessor.offset(VTOFFSET.elevations.v); return o == 0 ? false : true }
  public var elevationsCount: Int32 { let o = _accessor.offset(VTOFFSET.elevations.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func elevations(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.elevations.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the range rate of target at image center in kilometers per second. The 'tov' and 'rangeRate' arrays must match in size.
  ///  Example: /// Example: [0.317, 0.317, 0.317]
  ///  Constraints: No constraints specified.
  public var hasRangeRates: Bool { let o = _accessor.offset(VTOFFSET.rangeRates.v); return o == 0 ? false : true }
  public var rangeRatesCount: Int32 { let o = _accessor.offset(VTOFFSET.rangeRates.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func rangeRates(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.rangeRates.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the azimuth rate of target at image center in degrees per second. The 'tov' and 'azimuthRate' arrays must match in size.
  ///  Example: /// Example: [-1.481, -1.481, -1.481]
  ///  Constraints: No constraints specified.
  public var hasAzimuthRates: Bool { let o = _accessor.offset(VTOFFSET.azimuthRates.v); return o == 0 ? false : true }
  public var azimuthRatesCount: Int32 { let o = _accessor.offset(VTOFFSET.azimuthRates.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func azimuthRates(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.azimuthRates.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the elevation rate of target at image center in degrees per second. The 'tov' and 'elevationRate' arrays must match in size.
  ///  Example: /// Example: [-0.074, -0.074, -0.074]
  ///  Constraints: No constraints specified.
  public var hasElevationRates: Bool { let o = _accessor.offset(VTOFFSET.elevationRates.v); return o == 0 ? false : true }
  public var elevationRatesCount: Int32 { let o = _accessor.offset(VTOFFSET.elevationRates.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func elevationRates(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.elevationRates.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of  sensor azimuth angle biases in degrees. The 'tov' and 'azimuthBias' arrays must match in size.
  ///  Example: /// Example: [45.23, 45.23, 45.23]
  ///  Constraints: No constraints specified.
  public var hasAzimuthBiases: Bool { let o = _accessor.offset(VTOFFSET.azimuthBiases.v); return o == 0 ? false : true }
  public var azimuthBiasesCount: Int32 { let o = _accessor.offset(VTOFFSET.azimuthBiases.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func azimuthBiases(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.azimuthBiases.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of sensor elevation biases in degrees. The 'tov' and 'elevationBias' arrays must match in size.
  ///  Example: /// Example: [1.23, 1.23, 1.23]
  ///  Constraints: No constraints specified.
  public var hasElevationBiases: Bool { let o = _accessor.offset(VTOFFSET.elevationBiases.v); return o == 0 ? false : true }
  public var elevationBiasesCount: Int32 { let o = _accessor.offset(VTOFFSET.elevationBiases.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func elevationBiases(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.elevationBiases.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of sensor range biases in kilometers. The 'tov' and 'rangeBias' arrays must match in size.
  ///  Example: /// Example: [1.23, 1.23, 1.23]
  ///  Constraints: No constraints specified.
  public var hasRangeBiases: Bool { let o = _accessor.offset(VTOFFSET.rangeBiases.v); return o == 0 ? false : true }
  public var rangeBiasesCount: Int32 { let o = _accessor.offset(VTOFFSET.rangeBiases.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func rangeBiases(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.rangeBiases.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of Integration angles in degrees. The 'tov' and 'integrationAngle' arrays must match in size.
  ///  Example: /// Example: [8.594, 8.594, 8.594]
  ///  Constraints: No constraints specified.
  public var hasIntegrationAngles: Bool { let o = _accessor.offset(VTOFFSET.integrationAngles.v); return o == 0 ? false : true }
  public var integrationAnglesCount: Int32 { let o = _accessor.offset(VTOFFSET.integrationAngles.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func integrationAngles(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.integrationAngles.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of cross-range resolutions (accounting for weighting function) in kilometers. The 'tov' and 'crossRangeRes' arrays must match in size.
  ///  Example: /// Example: [11.301, 11.301, 11.301]
  ///  Constraints: No constraints specified.
  public var hasCrossRangeRes: Bool { let o = _accessor.offset(VTOFFSET.crossRangeRes.v); return o == 0 ? false : true }
  public var crossRangeResCount: Int32 { let o = _accessor.offset(VTOFFSET.crossRangeRes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func crossRangeRes(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.crossRangeRes.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Beta angle (between target and radar-image frame z axis) in degrees.
  ///  Example: /// Example: -89.97
  ///  Constraints: No constraints specified.
  public var beta: Double { let o = _accessor.offset(VTOFFSET.beta.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Kappa angle (between radar-line-of-sight and target-frame x axis) in degrees.
  ///  Example: /// Example: 103.04
  ///  Constraints: No constraints specified.
  public var kappa: Double { let o = _accessor.offset(VTOFFSET.kappa.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Array of the peak pixel amplitude for each image in decibels. The 'tov' and 'peakAmplitude' arrays must match in size.
  ///  Example: /// Example: [33.1, 33.1, 33.1]
  ///  Constraints: No constraints specified.
  public var hasPeakAmplitudes: Bool { let o = _accessor.offset(VTOFFSET.peakAmplitudes.v); return o == 0 ? false : true }
  public var peakAmplitudesCount: Int32 { let o = _accessor.offset(VTOFFSET.peakAmplitudes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func peakAmplitudes(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.peakAmplitudes.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Radar center frequency of the radar in hertz.
  ///  Example: /// Example: 160047.0625
  ///  Constraints: No constraints specified.
  public var centerFrequency: Double { let o = _accessor.offset(VTOFFSET.centerFrequency.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Bandwidth of radar pulse in hertz.
  ///  Example: /// Example: 24094.12
  ///  Constraints: No constraints specified.
  public var pulseBandwidth: Double { let o = _accessor.offset(VTOFFSET.pulseBandwidth.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Array of the cartesian X positions of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'xpos' arrays must match in size.
  ///  Example: /// Example: [-1118.577381, -1118.577381, -1118.577381]
  ///  Constraints: No constraints specified.
  public var hasXpos: Bool { let o = _accessor.offset(VTOFFSET.xpos.v); return o == 0 ? false : true }
  public var xposCount: Int32 { let o = _accessor.offset(VTOFFSET.xpos.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func xpos(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.xpos.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the cartesian Y positions of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'ypos' arrays must match in size.
  ///  Example: /// Example: [3026.231084, 3026.231084, 3026.231084]
  ///  Constraints: No constraints specified.
  public var hasYpos: Bool { let o = _accessor.offset(VTOFFSET.ypos.v); return o == 0 ? false : true }
  public var yposCount: Int32 { let o = _accessor.offset(VTOFFSET.ypos.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ypos(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.ypos.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the cartesian Z positions of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'zpos' arrays must match in size.
  ///  Example: /// Example: [6167.831808, 6167.831808, 6167.831808]
  ///  Constraints: No constraints specified.
  public var hasZpos: Bool { let o = _accessor.offset(VTOFFSET.zpos.v); return o == 0 ? false : true }
  public var zposCount: Int32 { let o = _accessor.offset(VTOFFSET.zpos.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func zpos(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.zpos.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the cartesian X velocities of target, in kilometers per second, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'xvel' arrays must match in size.
  ///  Example: /// Example: [-4.25242784, -4.25242784, -4.25242784]
  ///  Constraints: No constraints specified.
  public var hasXvel: Bool { let o = _accessor.offset(VTOFFSET.xvel.v); return o == 0 ? false : true }
  public var xvelCount: Int32 { let o = _accessor.offset(VTOFFSET.xvel.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func xvel(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.xvel.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the cartesian Y velocities of target, in kilometers per second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed. The 'tov' and 'yvel' arrays must match in size.
  ///  Example: /// Example: [5.291107434, 5.291107434, 5.291107434]
  ///  Constraints: No constraints specified.
  public var hasYvel: Bool { let o = _accessor.offset(VTOFFSET.yvel.v); return o == 0 ? false : true }
  public var yvelCount: Int32 { let o = _accessor.offset(VTOFFSET.yvel.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func yvel(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.yvel.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of the cartesian Z velocities of target, in kilometers per second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed. The 'tov' and 'zvel' arrays must match in size.
  ///  Example: /// Example: [-3.356493869, -3.356493869, -3.356493869]
  ///  Constraints: No constraints specified.
  public var hasZvel: Bool { let o = _accessor.offset(VTOFFSET.zvel.v); return o == 0 ? false : true }
  public var zvelCount: Int32 { let o = _accessor.offset(VTOFFSET.zvel.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func zvel(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.zvel.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startRadarSOIObservation_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 32) }
  public static func add(obStartTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: obStartTime, at: VTOFFSET.obStartTime.p) }
  public static func addVectorOf(tovs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tovs, at: VTOFFSET.tovs.p) }
  public static func addVectorOf(rspaces: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rspaces, at: VTOFFSET.rspaces.p) }
  public static func addVectorOf(xspaces: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: xspaces, at: VTOFFSET.xspaces.p) }
  public static func addVectorOf(doppler2Xrs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: doppler2Xrs, at: VTOFFSET.doppler2Xrs.p) }
  public static func addVectorOf(deltaTimes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: deltaTimes, at: VTOFFSET.deltaTimes.p) }
  public static func addVectorOf(aspectAngles: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: aspectAngles, at: VTOFFSET.aspectAngles.p) }
  public static func addVectorOf(projAngVels: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: projAngVels, at: VTOFFSET.projAngVels.p) }
  public static func add(idStateVector: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idStateVector, at: VTOFFSET.idStateVector.p) }
  public static func add(idAttitudeSet: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idAttitudeSet, at: VTOFFSET.idAttitudeSet.p) }
  public static func addVectorOf(ranges: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ranges, at: VTOFFSET.ranges.p) }
  public static func addVectorOf(azimuths: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: azimuths, at: VTOFFSET.azimuths.p) }
  public static func addVectorOf(elevations: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: elevations, at: VTOFFSET.elevations.p) }
  public static func addVectorOf(rangeRates: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rangeRates, at: VTOFFSET.rangeRates.p) }
  public static func addVectorOf(azimuthRates: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: azimuthRates, at: VTOFFSET.azimuthRates.p) }
  public static func addVectorOf(elevationRates: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: elevationRates, at: VTOFFSET.elevationRates.p) }
  public static func addVectorOf(azimuthBiases: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: azimuthBiases, at: VTOFFSET.azimuthBiases.p) }
  public static func addVectorOf(elevationBiases: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: elevationBiases, at: VTOFFSET.elevationBiases.p) }
  public static func addVectorOf(rangeBiases: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rangeBiases, at: VTOFFSET.rangeBiases.p) }
  public static func addVectorOf(integrationAngles: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: integrationAngles, at: VTOFFSET.integrationAngles.p) }
  public static func addVectorOf(crossRangeRes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: crossRangeRes, at: VTOFFSET.crossRangeRes.p) }
  public static func add(beta: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: beta, def: 0.0, at: VTOFFSET.beta.p) }
  public static func add(kappa: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: kappa, def: 0.0, at: VTOFFSET.kappa.p) }
  public static func addVectorOf(peakAmplitudes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: peakAmplitudes, at: VTOFFSET.peakAmplitudes.p) }
  public static func add(centerFrequency: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: centerFrequency, def: 0.0, at: VTOFFSET.centerFrequency.p) }
  public static func add(pulseBandwidth: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pulseBandwidth, def: 0.0, at: VTOFFSET.pulseBandwidth.p) }
  public static func addVectorOf(xpos: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: xpos, at: VTOFFSET.xpos.p) }
  public static func addVectorOf(ypos: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ypos, at: VTOFFSET.ypos.p) }
  public static func addVectorOf(zpos: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: zpos, at: VTOFFSET.zpos.p) }
  public static func addVectorOf(xvel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: xvel, at: VTOFFSET.xvel.p) }
  public static func addVectorOf(yvel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: yvel, at: VTOFFSET.yvel.p) }
  public static func addVectorOf(zvel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: zvel, at: VTOFFSET.zvel.p) }
  public static func endRadarSOIObservation_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRadarSOIObservation_Ingest(
    _ fbb: inout FlatBufferBuilder,
    obStartTimeOffset obStartTime: Offset = Offset(),
    tovsVectorOffset tovs: Offset = Offset(),
    rspacesVectorOffset rspaces: Offset = Offset(),
    xspacesVectorOffset xspaces: Offset = Offset(),
    doppler2XrsVectorOffset doppler2Xrs: Offset = Offset(),
    deltaTimesVectorOffset deltaTimes: Offset = Offset(),
    aspectAnglesVectorOffset aspectAngles: Offset = Offset(),
    projAngVelsVectorOffset projAngVels: Offset = Offset(),
    idStateVectorOffset idStateVector: Offset = Offset(),
    idAttitudeSetOffset idAttitudeSet: Offset = Offset(),
    rangesVectorOffset ranges: Offset = Offset(),
    azimuthsVectorOffset azimuths: Offset = Offset(),
    elevationsVectorOffset elevations: Offset = Offset(),
    rangeRatesVectorOffset rangeRates: Offset = Offset(),
    azimuthRatesVectorOffset azimuthRates: Offset = Offset(),
    elevationRatesVectorOffset elevationRates: Offset = Offset(),
    azimuthBiasesVectorOffset azimuthBiases: Offset = Offset(),
    elevationBiasesVectorOffset elevationBiases: Offset = Offset(),
    rangeBiasesVectorOffset rangeBiases: Offset = Offset(),
    integrationAnglesVectorOffset integrationAngles: Offset = Offset(),
    crossRangeResVectorOffset crossRangeRes: Offset = Offset(),
    beta: Double = 0.0,
    kappa: Double = 0.0,
    peakAmplitudesVectorOffset peakAmplitudes: Offset = Offset(),
    centerFrequency: Double = 0.0,
    pulseBandwidth: Double = 0.0,
    xposVectorOffset xpos: Offset = Offset(),
    yposVectorOffset ypos: Offset = Offset(),
    zposVectorOffset zpos: Offset = Offset(),
    xvelVectorOffset xvel: Offset = Offset(),
    yvelVectorOffset yvel: Offset = Offset(),
    zvelVectorOffset zvel: Offset = Offset()
  ) -> Offset {
    let __start = RadarSOIObservation_Ingest.startRadarSOIObservation_Ingest(&fbb)
    RadarSOIObservation_Ingest.add(obStartTime: obStartTime, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(tovs: tovs, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(rspaces: rspaces, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(xspaces: xspaces, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(doppler2Xrs: doppler2Xrs, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(deltaTimes: deltaTimes, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(aspectAngles: aspectAngles, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(projAngVels: projAngVels, &fbb)
    RadarSOIObservation_Ingest.add(idStateVector: idStateVector, &fbb)
    RadarSOIObservation_Ingest.add(idAttitudeSet: idAttitudeSet, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(ranges: ranges, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(azimuths: azimuths, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(elevations: elevations, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(rangeRates: rangeRates, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(azimuthRates: azimuthRates, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(elevationRates: elevationRates, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(azimuthBiases: azimuthBiases, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(elevationBiases: elevationBiases, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(rangeBiases: rangeBiases, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(integrationAngles: integrationAngles, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(crossRangeRes: crossRangeRes, &fbb)
    RadarSOIObservation_Ingest.add(beta: beta, &fbb)
    RadarSOIObservation_Ingest.add(kappa: kappa, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(peakAmplitudes: peakAmplitudes, &fbb)
    RadarSOIObservation_Ingest.add(centerFrequency: centerFrequency, &fbb)
    RadarSOIObservation_Ingest.add(pulseBandwidth: pulseBandwidth, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(xpos: xpos, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(ypos: ypos, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(zpos: zpos, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(xvel: xvel, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(yvel: yvel, &fbb)
    RadarSOIObservation_Ingest.addVectorOf(zvel: zvel, &fbb)
    return RadarSOIObservation_Ingest.endRadarSOIObservation_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.obStartTime.p, fieldName: "obStartTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.tovs.p, fieldName: "tovs", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.rspaces.p, fieldName: "rspaces", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.xspaces.p, fieldName: "xspaces", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.doppler2Xrs.p, fieldName: "doppler2Xrs", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.deltaTimes.p, fieldName: "deltaTimes", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.aspectAngles.p, fieldName: "aspectAngles", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.projAngVels.p, fieldName: "projAngVels", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.idStateVector.p, fieldName: "idStateVector", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idAttitudeSet.p, fieldName: "idAttitudeSet", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ranges.p, fieldName: "ranges", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.azimuths.p, fieldName: "azimuths", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.elevations.p, fieldName: "elevations", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.rangeRates.p, fieldName: "rangeRates", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.azimuthRates.p, fieldName: "azimuthRates", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.elevationRates.p, fieldName: "elevationRates", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.azimuthBiases.p, fieldName: "azimuthBiases", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.elevationBiases.p, fieldName: "elevationBiases", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.rangeBiases.p, fieldName: "rangeBiases", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.integrationAngles.p, fieldName: "integrationAngles", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.crossRangeRes.p, fieldName: "crossRangeRes", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.beta.p, fieldName: "beta", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.kappa.p, fieldName: "kappa", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.peakAmplitudes.p, fieldName: "peakAmplitudes", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.centerFrequency.p, fieldName: "centerFrequency", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.pulseBandwidth.p, fieldName: "pulseBandwidth", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.xpos.p, fieldName: "xpos", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.ypos.p, fieldName: "ypos", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.zpos.p, fieldName: "zpos", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.xvel.p, fieldName: "xvel", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.yvel.p, fieldName: "yvel", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.zvel.p, fieldName: "zvel", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

