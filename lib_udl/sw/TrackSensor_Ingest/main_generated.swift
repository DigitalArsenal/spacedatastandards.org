// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum TrackSensor_Ingest_sensorFOVType_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case butterfly = 0
  ///  No description available.
  case coneAngular = 1
  ///  No description available.
  case coneDistance = 2
  ///  No description available.
  case horizonToHorizon = 3
  ///  No description available.
  case unknown = 4

  public static var max: TrackSensor_Ingest_sensorFOVType_Enum { return .unknown }
  public static var min: TrackSensor_Ingest_sensorFOVType_Enum { return .butterfly }
}


///  /// Schema for Track Sensor data.
public struct TrackSensor_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TRAC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: TrackSensor_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case range = 4
    case az = 6
    case sensorNumber = 8
    case sensorName = 10
    case missionNumber = 12
    case minRangeLimit = 14
    case sensorFovtype = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The track object range from the observing sensor, in kilometers.
  ///  Example: /// Example: 4023.95
  ///  Constraints: No constraints specified.
  public var range: Double { let o = _accessor.offset(VTOFFSET.range.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The observing sensor azimuth angle, in degrees and topocentric frame.
  ///  Example: /// Example: 90
  ///  Constraints: No constraints specified.
  public var az: Double { let o = _accessor.offset(VTOFFSET.az.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
  ///  Example: /// Example: 1234
  ///  Constraints: No constraints specified.
  public var sensorNumber: Int32 { let o = _accessor.offset(VTOFFSET.sensorNumber.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Unique name of this sensor.
  ///  Example: /// Example: SENSOR_NAME
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var sensorName: String? { let o = _accessor.offset(VTOFFSET.sensorName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sensorNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sensorName.v) }
  ///  The mission number which produced this track observation.
  ///  Example: /// Example: Example Mission
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var missionNumber: String? { let o = _accessor.offset(VTOFFSET.missionNumber.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var missionNumberSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.missionNumber.v) }
  ///  Minimum range measurement capability of the sensor, in kilometers.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var minRangeLimit: Double { let o = _accessor.offset(VTOFFSET.minRangeLimit.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
  ///  Example: /// Example: UNKNOWN
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var sensorFovtype: TrackSensor_Ingest_sensorFOVType_Enum { let o = _accessor.offset(VTOFFSET.sensorFovtype.v); return o == 0 ? .butterfly : TrackSensor_Ingest_sensorFOVType_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .butterfly }
  public static func startTrackSensor_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(range: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: range, def: 0.0, at: VTOFFSET.range.p) }
  public static func add(az: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: az, def: 0.0, at: VTOFFSET.az.p) }
  public static func add(sensorNumber: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sensorNumber, def: 0, at: VTOFFSET.sensorNumber.p) }
  public static func add(sensorName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sensorName, at: VTOFFSET.sensorName.p) }
  public static func add(missionNumber: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: missionNumber, at: VTOFFSET.missionNumber.p) }
  public static func add(minRangeLimit: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: minRangeLimit, def: 0.0, at: VTOFFSET.minRangeLimit.p) }
  public static func add(sensorFovtype: TrackSensor_Ingest_sensorFOVType_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sensorFovtype.rawValue, def: 0, at: VTOFFSET.sensorFovtype.p) }
  public static func endTrackSensor_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTrackSensor_Ingest(
    _ fbb: inout FlatBufferBuilder,
    range: Double = 0.0,
    az: Double = 0.0,
    sensorNumber: Int32 = 0,
    sensorNameOffset sensorName: Offset = Offset(),
    missionNumberOffset missionNumber: Offset = Offset(),
    minRangeLimit: Double = 0.0,
    sensorFovtype: TrackSensor_Ingest_sensorFOVType_Enum = .butterfly
  ) -> Offset {
    let __start = TrackSensor_Ingest.startTrackSensor_Ingest(&fbb)
    TrackSensor_Ingest.add(range: range, &fbb)
    TrackSensor_Ingest.add(az: az, &fbb)
    TrackSensor_Ingest.add(sensorNumber: sensorNumber, &fbb)
    TrackSensor_Ingest.add(sensorName: sensorName, &fbb)
    TrackSensor_Ingest.add(missionNumber: missionNumber, &fbb)
    TrackSensor_Ingest.add(minRangeLimit: minRangeLimit, &fbb)
    TrackSensor_Ingest.add(sensorFovtype: sensorFovtype, &fbb)
    return TrackSensor_Ingest.endTrackSensor_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.range.p, fieldName: "range", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.az.p, fieldName: "az", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.sensorNumber.p, fieldName: "sensorNumber", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.sensorName.p, fieldName: "sensorName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.missionNumber.p, fieldName: "missionNumber", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.minRangeLimit.p, fieldName: "minRangeLimit", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.sensorFovtype.p, fieldName: "sensorFovtype", required: false, type: TrackSensor_Ingest_sensorFOVType_Enum.self)
    _v.finish()
  }
}

