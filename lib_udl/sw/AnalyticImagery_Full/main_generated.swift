// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum AnalyticImagery_Full_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case real = 0
  ///  No description available.
  case test = 1
  ///  No description available.
  case simulated = 2
  ///  No description available.
  case exercise = 3

  public static var max: AnalyticImagery_Full_dataMode_Enum { return .exercise }
  public static var min: AnalyticImagery_Full_dataMode_Enum { return .real }
}


///  /// The analytic imagery schema supports data plots and graphics of various types. The records contain general file information, allows for annotations to user-defined areas of interest on the graphics, and supports keyword searching.
public struct AnalyticImagery_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "ANAL" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AnalyticImagery_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case content = 8
    case msgTime = 10
    case imageType = 12
    case filename = 14
    case filesize = 16
    case imgWidth = 18
    case imgHeight = 20
    case xUnits = 22
    case yUnits = 24
    case zUnits = 26
    case imageSetId = 28
    case imageSetLength = 30
    case sequenceId = 32
    case description = 34
    case dataStart = 36
    case dataStop = 38
    case annLims = 40
    case annText = 42
    case keywords = 44
    case area = 46
    case atext = 48
    case agjson = 50
    case atype = 52
    case andims = 54
    case asrid = 56
    case satId = 58
    case satIdConf = 60
    case srcTyps = 62
    case srcIds = 64
    case tags = 66
    case checksumValue = 68
    case transactionId = 70
    case createdAt = 72
    case createdBy = 74
    case source = 76
    case origin = 78
    case origNetwork = 80
    case sourceDl = 82
    case dataMode = 84
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: ANALYTIC-IMAGERY-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  General type of content of this image (CONTOUR, DIAGRAM, HEATMAP, HISTOGRAM, PLOT, SCREENSHOT).
  ///  Example: /// Example: CONTOUR
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var content: String? { let o = _accessor.offset(VTOFFSET.content.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var contentSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.content.v) }
  ///  The message time of this image record, in ISO8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var msgTime: String? { let o = _accessor.offset(VTOFFSET.msgTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var msgTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.msgTime.v) }
  ///  The type of image associated with this record (GIF, JPG, PNG, TIF).
  ///  Example: /// Example: JPG
  ///  Constraints: Minimum length = 1, Maximum length = 16
  public var imageType: String? { let o = _accessor.offset(VTOFFSET.imageType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var imageTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.imageType.v) }
  ///  The image file name.
  ///  Example: /// Example: IMAGE-NAME
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var filename: String? { let o = _accessor.offset(VTOFFSET.filename.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var filenameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.filename.v) }
  ///  The image file size, in bytes.  The maximum file size for this service is 40,000,000 bytes (40MB). Files exceeding the maximum size will be rejected.
  ///  Example: /// Example: 7654321
  ///  Constraints: No constraints specified.
  public var filesize: Int64 { let o = _accessor.offset(VTOFFSET.filesize.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  ///  The image width (horizontal), in pixels.
  ///  Example: /// Example: 123
  ///  Constraints: No constraints specified.
  public var imgWidth: Int32 { let o = _accessor.offset(VTOFFSET.imgWidth.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The image height (vertical), in pixels.
  ///  Example: /// Example: 123
  ///  Constraints: No constraints specified.
  public var imgHeight: Int32 { let o = _accessor.offset(VTOFFSET.imgHeight.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Optional field indicating the units that apply to the x-axis of the attached image, when applicable.
  ///  Example: /// Example: pixels
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var xUnits: String? { let o = _accessor.offset(VTOFFSET.xUnits.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var xUnitsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.xUnits.v) }
  ///  Optional field indicating the units that apply to the y-axis of the attached image, when applicable.
  ///  Example: /// Example: pixels
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var yUnits: String? { let o = _accessor.offset(VTOFFSET.yUnits.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var yUnitsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.yUnits.v) }
  ///  Optional field indicating the units that apply to the z-axis of the attached image, when applicable.
  ///  Example: /// Example: pixels
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var zUnits: String? { let o = _accessor.offset(VTOFFSET.zUnits.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var zUnitsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.zUnits.v) }
  ///  User-defined set ID of a sequence of images.  Used to associate related analytic image records.
  ///  Example: /// Example: IMAGE-IDS
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var imageSetId: String? { let o = _accessor.offset(VTOFFSET.imageSetId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var imageSetIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.imageSetId.v) }
  ///  The number of images in an image set.
  ///  Example: /// Example: 123
  ///  Constraints: No constraints specified.
  public var imageSetLength: Int32 { let o = _accessor.offset(VTOFFSET.imageSetLength.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The sequence number of an image within an image set.  If null, then it is assumed that the order of images in an imageSet is not relevant.
  ///  Example: /// Example: 123
  ///  Constraints: No constraints specified.
  public var sequenceId: Int32 { let o = _accessor.offset(VTOFFSET.sequenceId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Description of the image content and utility.
  ///  Example: /// Example: Image description
  ///  Constraints: Minimum length = 1, Maximum length = 512
  public var description: String? { let o = _accessor.offset(VTOFFSET.description.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.description.v) }
  ///  The start time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var dataStart: String? { let o = _accessor.offset(VTOFFSET.dataStart.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var dataStartSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.dataStart.v) }
  ///  The stop time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var dataStop: String? { let o = _accessor.offset(VTOFFSET.dataStop.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var dataStopSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.dataStop.v) }
  ///  Rectangular annotation limits, specified in pixels, as an array of arrays of the coordinates [ [UL1x, UL1y], [UR1x, UR1y], [LR1x, LR1y], [LL1x, LL1y] ], indicating the corners of a rectangle beginning with the Upper Left (UL) and moving clockwise. Allows the image provider to highlight one or more rectangular area(s) of interest. The array must contain Nx4 two-element arrays, where N is the number of rectangles of interest.  The associated annotation(s) should be included in the annText array.
  ///  Example: /// Example: [[1, 1], [1, 2], [1, 3], [1, 4]]
  ///  Constraints: No constraints specified.
  public var hasAnnLims: Bool { let o = _accessor.offset(VTOFFSET.annLims.v); return o == 0 ? false : true }
  public var annLimsCount: Int32 { let o = _accessor.offset(VTOFFSET.annLims.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func annLims(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.annLims.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Annotation text, a string array of annotation(s) corresponding to the rectangular areas specified in annLims.  This array contains the annotation text associated with the areas of interest indicated in annLims, in order.  This array should contain one annotation per four values of the area (annLims) array.
  ///  Example: /// Example: ['rec1', 'rec2']
  ///  Constraints: No constraints specified.
  public var hasAnnText: Bool { let o = _accessor.offset(VTOFFSET.annText.v); return o == 0 ? false : true }
  public var annTextCount: Int32 { let o = _accessor.offset(VTOFFSET.annText.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func annText(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.annText.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of searchable keywords for this analytic imagery record.
  ///  Example: /// Example: ['Key1', 'Key2']
  ///  Constraints: No constraints specified.
  public var hasKeywords: Bool { let o = _accessor.offset(VTOFFSET.keywords.v); return o == 0 ? false : true }
  public var keywordsCount: Int32 { let o = _accessor.offset(VTOFFSET.keywords.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func keywords(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.keywords.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
  ///  Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  ///  Constraints: No constraints specified.
  public var area: String? { let o = _accessor.offset(VTOFFSET.area.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var areaSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.area.v) }
  ///  Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
  ///  Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  ///  Constraints: No constraints specified.
  public var atext: String? { let o = _accessor.offset(VTOFFSET.atext.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var atextSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.atext.v) }
  ///  Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
  ///  Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
  ///  Constraints: No constraints specified.
  public var agjson: String? { let o = _accessor.offset(VTOFFSET.agjson.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var agjsonSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.agjson.v) }
  ///  Type of region as projected on the ground.
  ///  Example: /// Example: POLYGON
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var atype: String? { let o = _accessor.offset(VTOFFSET.atype.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var atypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.atype.v) }
  ///  Number of dimensions of the geometry depicted by region.
  ///  Example: /// Example: 2
  ///  Constraints: No constraints specified.
  public var andims: Int32 { let o = _accessor.offset(VTOFFSET.andims.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Geographical spatial_ref_sys for region.
  ///  Example: /// Example: 4326
  ///  Constraints: No constraints specified.
  public var asrid: Int32 { let o = _accessor.offset(VTOFFSET.asrid.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Assessed satellite ID (NORAD RSO object number).  The 'satId' and 'satIdConf' arrays must match in size.
  ///  Example: /// Example: [12004, 12005]
  ///  Constraints: No constraints specified.
  public var hasSatId: Bool { let o = _accessor.offset(VTOFFSET.satId.v); return o == 0 ? false : true }
  public var satIdCount: Int32 { let o = _accessor.offset(VTOFFSET.satId.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func satId(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.satId.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Assessed satellite confidence corresponding to an assessment ID.  Values are between 0.0 and 1.0.  The 'satId' and 'satIdConf' arrays must match in size.
  ///  Example: /// Example: [0.98, 0.22]
  ///  Constraints: No constraints specified.
  public var hasSatIdConf: Bool { let o = _accessor.offset(VTOFFSET.satIdConf.v); return o == 0 ? false : true }
  public var satIdConfCount: Int32 { let o = _accessor.offset(VTOFFSET.satIdConf.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func satIdConf(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.satIdConf.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this image. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
  ///  Example: /// Example: ['MTI', 'POI']
  ///  Constraints: No constraints specified.
  public var hasSrcTyps: Bool { let o = _accessor.offset(VTOFFSET.srcTyps.v); return o == 0 ? false : true }
  public var srcTypsCount: Int32 { let o = _accessor.offset(VTOFFSET.srcTyps.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func srcTyps(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.srcTyps.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of UUIDs of the UDL data records that are related to this image. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
  ///  Example: /// Example: ['DOA_ID', 'DWELL_ID']
  ///  Constraints: No constraints specified.
  public var hasSrcIds: Bool { let o = _accessor.offset(VTOFFSET.srcIds.v); return o == 0 ? false : true }
  public var srcIdsCount: Int32 { let o = _accessor.offset(VTOFFSET.srcIds.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func srcIds(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.srcIds.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  ///  Example: /// Example: ['TAG1', 'TAG2']
  ///  Constraints: No constraints specified.
  public var hasTags: Bool { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? false : true }
  public var tagsCount: Int32 { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tags(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  MD5 checksum value of the file. The ingest/create operation will automatically generate the value.
  ///  Example: /// Example: 123
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var checksumValue: String? { let o = _accessor.offset(VTOFFSET.checksumValue.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var checksumValueSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.checksumValue.v) }
  ///  Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  ///  Example: /// Example: a7bdef1f-5a4f-4716-bee4-7a1e0ec7d35a
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var transactionId: String? { let o = _accessor.offset(VTOFFSET.transactionId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var transactionIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.transactionId.v) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: ORIGIN
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: TST1
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  ///  Example: /// Example: AXE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var sourceDl: String? { let o = _accessor.offset(VTOFFSET.sourceDl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceDlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceDl.v) }
  ///  Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: AnalyticImagery_Full_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : AnalyticImagery_Full_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  public static func startAnalyticImagery_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 41) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(content: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: content, at: VTOFFSET.content.p) }
  public static func add(msgTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: msgTime, at: VTOFFSET.msgTime.p) }
  public static func add(imageType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: imageType, at: VTOFFSET.imageType.p) }
  public static func add(filename: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: filename, at: VTOFFSET.filename.p) }
  public static func add(filesize: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: filesize, def: 0, at: VTOFFSET.filesize.p) }
  public static func add(imgWidth: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: imgWidth, def: 0, at: VTOFFSET.imgWidth.p) }
  public static func add(imgHeight: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: imgHeight, def: 0, at: VTOFFSET.imgHeight.p) }
  public static func add(xUnits: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: xUnits, at: VTOFFSET.xUnits.p) }
  public static func add(yUnits: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: yUnits, at: VTOFFSET.yUnits.p) }
  public static func add(zUnits: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: zUnits, at: VTOFFSET.zUnits.p) }
  public static func add(imageSetId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: imageSetId, at: VTOFFSET.imageSetId.p) }
  public static func add(imageSetLength: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: imageSetLength, def: 0, at: VTOFFSET.imageSetLength.p) }
  public static func add(sequenceId: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sequenceId, def: 0, at: VTOFFSET.sequenceId.p) }
  public static func add(description: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: description, at: VTOFFSET.description.p) }
  public static func add(dataStart: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dataStart, at: VTOFFSET.dataStart.p) }
  public static func add(dataStop: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dataStop, at: VTOFFSET.dataStop.p) }
  public static func addVectorOf(annLims: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: annLims, at: VTOFFSET.annLims.p) }
  public static func addVectorOf(annText: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: annText, at: VTOFFSET.annText.p) }
  public static func addVectorOf(keywords: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: keywords, at: VTOFFSET.keywords.p) }
  public static func add(area: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: area, at: VTOFFSET.area.p) }
  public static func add(atext: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: atext, at: VTOFFSET.atext.p) }
  public static func add(agjson: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: agjson, at: VTOFFSET.agjson.p) }
  public static func add(atype: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: atype, at: VTOFFSET.atype.p) }
  public static func add(andims: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: andims, def: 0, at: VTOFFSET.andims.p) }
  public static func add(asrid: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asrid, def: 0, at: VTOFFSET.asrid.p) }
  public static func addVectorOf(satId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: satId, at: VTOFFSET.satId.p) }
  public static func addVectorOf(satIdConf: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: satIdConf, at: VTOFFSET.satIdConf.p) }
  public static func addVectorOf(srcTyps: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: srcTyps, at: VTOFFSET.srcTyps.p) }
  public static func addVectorOf(srcIds: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: srcIds, at: VTOFFSET.srcIds.p) }
  public static func addVectorOf(tags: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tags, at: VTOFFSET.tags.p) }
  public static func add(checksumValue: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: checksumValue, at: VTOFFSET.checksumValue.p) }
  public static func add(transactionId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: transactionId, at: VTOFFSET.transactionId.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(sourceDl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceDl, at: VTOFFSET.sourceDl.p) }
  public static func add(dataMode: AnalyticImagery_Full_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func endAnalyticImagery_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAnalyticImagery_Full(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    contentOffset content: Offset = Offset(),
    msgTimeOffset msgTime: Offset = Offset(),
    imageTypeOffset imageType: Offset = Offset(),
    filenameOffset filename: Offset = Offset(),
    filesize: Int64 = 0,
    imgWidth: Int32 = 0,
    imgHeight: Int32 = 0,
    xUnitsOffset xUnits: Offset = Offset(),
    yUnitsOffset yUnits: Offset = Offset(),
    zUnitsOffset zUnits: Offset = Offset(),
    imageSetIdOffset imageSetId: Offset = Offset(),
    imageSetLength: Int32 = 0,
    sequenceId: Int32 = 0,
    descriptionOffset description: Offset = Offset(),
    dataStartOffset dataStart: Offset = Offset(),
    dataStopOffset dataStop: Offset = Offset(),
    annLimsVectorOffset annLims: Offset = Offset(),
    annTextVectorOffset annText: Offset = Offset(),
    keywordsVectorOffset keywords: Offset = Offset(),
    areaOffset area: Offset = Offset(),
    atextOffset atext: Offset = Offset(),
    agjsonOffset agjson: Offset = Offset(),
    atypeOffset atype: Offset = Offset(),
    andims: Int32 = 0,
    asrid: Int32 = 0,
    satIdVectorOffset satId: Offset = Offset(),
    satIdConfVectorOffset satIdConf: Offset = Offset(),
    srcTypsVectorOffset srcTyps: Offset = Offset(),
    srcIdsVectorOffset srcIds: Offset = Offset(),
    tagsVectorOffset tags: Offset = Offset(),
    checksumValueOffset checksumValue: Offset = Offset(),
    transactionIdOffset transactionId: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    sourceDlOffset sourceDl: Offset = Offset(),
    dataMode: AnalyticImagery_Full_dataMode_Enum = .real
  ) -> Offset {
    let __start = AnalyticImagery_Full.startAnalyticImagery_Full(&fbb)
    AnalyticImagery_Full.add(id: id, &fbb)
    AnalyticImagery_Full.add(classificationMarking: classificationMarking, &fbb)
    AnalyticImagery_Full.add(content: content, &fbb)
    AnalyticImagery_Full.add(msgTime: msgTime, &fbb)
    AnalyticImagery_Full.add(imageType: imageType, &fbb)
    AnalyticImagery_Full.add(filename: filename, &fbb)
    AnalyticImagery_Full.add(filesize: filesize, &fbb)
    AnalyticImagery_Full.add(imgWidth: imgWidth, &fbb)
    AnalyticImagery_Full.add(imgHeight: imgHeight, &fbb)
    AnalyticImagery_Full.add(xUnits: xUnits, &fbb)
    AnalyticImagery_Full.add(yUnits: yUnits, &fbb)
    AnalyticImagery_Full.add(zUnits: zUnits, &fbb)
    AnalyticImagery_Full.add(imageSetId: imageSetId, &fbb)
    AnalyticImagery_Full.add(imageSetLength: imageSetLength, &fbb)
    AnalyticImagery_Full.add(sequenceId: sequenceId, &fbb)
    AnalyticImagery_Full.add(description: description, &fbb)
    AnalyticImagery_Full.add(dataStart: dataStart, &fbb)
    AnalyticImagery_Full.add(dataStop: dataStop, &fbb)
    AnalyticImagery_Full.addVectorOf(annLims: annLims, &fbb)
    AnalyticImagery_Full.addVectorOf(annText: annText, &fbb)
    AnalyticImagery_Full.addVectorOf(keywords: keywords, &fbb)
    AnalyticImagery_Full.add(area: area, &fbb)
    AnalyticImagery_Full.add(atext: atext, &fbb)
    AnalyticImagery_Full.add(agjson: agjson, &fbb)
    AnalyticImagery_Full.add(atype: atype, &fbb)
    AnalyticImagery_Full.add(andims: andims, &fbb)
    AnalyticImagery_Full.add(asrid: asrid, &fbb)
    AnalyticImagery_Full.addVectorOf(satId: satId, &fbb)
    AnalyticImagery_Full.addVectorOf(satIdConf: satIdConf, &fbb)
    AnalyticImagery_Full.addVectorOf(srcTyps: srcTyps, &fbb)
    AnalyticImagery_Full.addVectorOf(srcIds: srcIds, &fbb)
    AnalyticImagery_Full.addVectorOf(tags: tags, &fbb)
    AnalyticImagery_Full.add(checksumValue: checksumValue, &fbb)
    AnalyticImagery_Full.add(transactionId: transactionId, &fbb)
    AnalyticImagery_Full.add(createdAt: createdAt, &fbb)
    AnalyticImagery_Full.add(createdBy: createdBy, &fbb)
    AnalyticImagery_Full.add(source: source, &fbb)
    AnalyticImagery_Full.add(origin: origin, &fbb)
    AnalyticImagery_Full.add(origNetwork: origNetwork, &fbb)
    AnalyticImagery_Full.add(sourceDl: sourceDl, &fbb)
    AnalyticImagery_Full.add(dataMode: dataMode, &fbb)
    return AnalyticImagery_Full.endAnalyticImagery_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.content.p, fieldName: "content", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msgTime.p, fieldName: "msgTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.imageType.p, fieldName: "imageType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.filename.p, fieldName: "filename", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.filesize.p, fieldName: "filesize", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.imgWidth.p, fieldName: "imgWidth", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.imgHeight.p, fieldName: "imgHeight", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.xUnits.p, fieldName: "xUnits", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.yUnits.p, fieldName: "yUnits", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.zUnits.p, fieldName: "zUnits", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.imageSetId.p, fieldName: "imageSetId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.imageSetLength.p, fieldName: "imageSetLength", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.sequenceId.p, fieldName: "sequenceId", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.description.p, fieldName: "description", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataStart.p, fieldName: "dataStart", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataStop.p, fieldName: "dataStop", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.annLims.p, fieldName: "annLims", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.annText.p, fieldName: "annText", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.keywords.p, fieldName: "keywords", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.area.p, fieldName: "area", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.atext.p, fieldName: "atext", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.agjson.p, fieldName: "agjson", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.atype.p, fieldName: "atype", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.andims.p, fieldName: "andims", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.asrid.p, fieldName: "asrid", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.satId.p, fieldName: "satId", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.satIdConf.p, fieldName: "satIdConf", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.srcTyps.p, fieldName: "srcTyps", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.srcIds.p, fieldName: "srcIds", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.tags.p, fieldName: "tags", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.checksumValue.p, fieldName: "checksumValue", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.transactionId.p, fieldName: "transactionId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceDl.p, fieldName: "sourceDl", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: AnalyticImagery_Full_dataMode_Enum.self)
    _v.finish()
  }
}

