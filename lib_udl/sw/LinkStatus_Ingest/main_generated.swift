// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum LinkStatus_Ingest_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: LinkStatus_Ingest_dataMode_Enum { return .exercise }
  public static var min: LinkStatus_Ingest_dataMode_Enum { return .real }
}


///  /// Captures link status.
public struct LinkStatus_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "LINK" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: LinkStatus_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case idOnOrbit1 = 8
    case idOnOrbit2 = 10
    case linkStartTime = 12
    case linkStopTime = 14
    case constellation = 16
    case linkName = 18
    case linkType = 20
    case band = 22
    case idBeam1 = 24
    case endPoint1Name = 26
    case endPoint1Lat = 28
    case endPoint1Lon = 30
    case idBeam2 = 32
    case endPoint2Name = 34
    case endPoint2Lat = 36
    case endPoint2Lon = 38
    case dataRate1To2 = 40
    case dataRate2To1 = 42
    case linkState = 44
    case sysCap = 46
    case opsCap = 48
    case createdAt = 50
    case createdBy = 52
    case source = 54
    case origin = 56
    case origNetwork = 58
    case dataMode = 60
    case satNo1 = 62
    case satNo2 = 64
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: LINKSTATUS-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Unique ID of the on-orbit satellite (Sat-1) forming the link.  A null value for idOnOrbit1 indicates that the link is formed over a LEO/MEO constellation.
  ///  Example: /// Example: REF-ONORBIT1-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idOnOrbit1: String? { let o = _accessor.offset(VTOFFSET.idOnOrbit1.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idOnOrbit1SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idOnOrbit1.v) }
  ///  Unique ID of the on-orbit satellite (Sat-2) forming the link.  A null value for idOnOrbit2 indicates either a link employing only Sat-1 or a link formed over a LEO/MEO constellation.
  ///  Example: /// Example: REF-ONORBIT2-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idOnOrbit2: String? { let o = _accessor.offset(VTOFFSET.idOnOrbit2.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idOnOrbit2SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idOnOrbit2.v) }
  ///  The link establishment time, or the time that the link becomes available for use, in ISO8601 UTC format.
  ///  Example: /// Example: 2021-01-01T01:01:01.123456Z
  ///  Constraints: No constraints specified.
  public var linkStartTime: String? { let o = _accessor.offset(VTOFFSET.linkStartTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var linkStartTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.linkStartTime.v) }
  ///  The link termination time, or the time that the link becomes unavailable for use, in ISO8601 UTC format.
  ///  Example: /// Example: 2021-01-01T01:01:01.123456Z
  ///  Constraints: No constraints specified.
  public var linkStopTime: String? { let o = _accessor.offset(VTOFFSET.linkStopTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var linkStopTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.linkStopTime.v) }
  ///  The constellation name if the link is established over a LEO/MEO constellation.  In this case, idOnOrbit1 and idOnOrbit2 will be null.
  ///  Example: /// Example: Fornax
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var constellation: String? { let o = _accessor.offset(VTOFFSET.constellation.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var constellationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.constellation.v) }
  ///  The name or description of the link.
  ///  Example: /// Example: Example description
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var linkName: String? { let o = _accessor.offset(VTOFFSET.linkName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var linkNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.linkName.v) }
  ///  The type of the link.
  ///  Example: /// Example: Example link
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var linkType: String? { let o = _accessor.offset(VTOFFSET.linkType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var linkTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.linkType.v) }
  ///  The RF band employed by the link (e.g. MIL-KA, COM-KA, X-BAND, C-BAND, etc.).
  ///  Example: /// Example: MIL-KA
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var band: String? { let o = _accessor.offset(VTOFFSET.band.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var bandSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.band.v) }
  ///  The ID of beam-1 forming the link.  In the case of two sat link, beam-1 corresponds to Sat-1.
  ///  Example: /// Example: REF-BEAM1-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idBeam1: String? { let o = _accessor.offset(VTOFFSET.idBeam1.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idBeam1SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idBeam1.v) }
  ///  The name or description of link endpoint-1, corresponding to beam-1.
  ///  Example: /// Example: Example endpoint
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var endPoint1Name: String? { let o = _accessor.offset(VTOFFSET.endPoint1Name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var endPoint1NameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.endPoint1Name.v) }
  ///  Latitude of link endpoint-1, WGS-84 in degrees. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 45.23
  ///  Constraints: No constraints specified.
  public var endPoint1Lat: Double { let o = _accessor.offset(VTOFFSET.endPoint1Lat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Longitude of link endpoint-1, WGS-84 longitude in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 80.23
  ///  Constraints: No constraints specified.
  public var endPoint1Lon: Double { let o = _accessor.offset(VTOFFSET.endPoint1Lon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The ID of beam-2 forming the link.  In the case of two sat link, beam-2 corresponds to Sat-2.
  ///  Example: /// Example: REF-BEAM2-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idBeam2: String? { let o = _accessor.offset(VTOFFSET.idBeam2.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idBeam2SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idBeam2.v) }
  ///  The name or description of link endpoint-2, corresponding to beam-2.
  ///  Example: /// Example: Example description
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var endPoint2Name: String? { let o = _accessor.offset(VTOFFSET.endPoint2Name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var endPoint2NameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.endPoint2Name.v) }
  ///  Latitude of link endpoint-2, WGS-84 in degrees. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 45.23
  ///  Constraints: No constraints specified.
  public var endPoint2Lat: Double { let o = _accessor.offset(VTOFFSET.endPoint2Lat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Longitude of link endpoint-2, WGS-84 longitude in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 80.23
  ///  Constraints: No constraints specified.
  public var endPoint2Lon: Double { let o = _accessor.offset(VTOFFSET.endPoint2Lon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The endpoint-1 to endpoint-2 data rate, in kbps.
  ///  Example: /// Example: 10.23
  ///  Constraints: No constraints specified.
  public var dataRate1To2: Double { let o = _accessor.offset(VTOFFSET.dataRate1To2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The endpoint-2 to endpoint-1 data rate, in kbps.
  ///  Example: /// Example: 10.23
  ///  Constraints: No constraints specified.
  public var dataRate2To1: Double { let o = _accessor.offset(VTOFFSET.dataRate2To1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The state of the link (e.g. OK, DEGRADED-WEATHER, DEGRADED-EMI, etc.).
  ///  Example: /// Example: DEGRADED-WEATHER
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var linkState: String? { let o = _accessor.offset(VTOFFSET.linkState.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var linkStateSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.linkState.v) }
  ///  The SYSCAP mission status of the system(s) forming the link.
  ///  Example: /// Example: Example status
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var sysCap: String? { let o = _accessor.offset(VTOFFSET.sysCap.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sysCapSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sysCap.v) }
  ///  The OPSCAP mission status of the system(s) forming the link.
  ///  Example: /// Example: Example status
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var opsCap: String? { let o = _accessor.offset(VTOFFSET.opsCap.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var opsCapSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.opsCap.v) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: LinkStatus_Ingest_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : LinkStatus_Ingest_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Satellite/catalog number of the target on-orbit primary object.
  ///  Example: /// Example: 1
  ///  Constraints: No constraints specified.
  public var satNo1: Int32 { let o = _accessor.offset(VTOFFSET.satNo1.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Satellite/catalog number of the target on-orbit secondary object.
  ///  Example: /// Example: 2
  ///  Constraints: No constraints specified.
  public var satNo2: Int32 { let o = _accessor.offset(VTOFFSET.satNo2.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startLinkStatus_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 31) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(idOnOrbit1: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idOnOrbit1, at: VTOFFSET.idOnOrbit1.p) }
  public static func add(idOnOrbit2: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idOnOrbit2, at: VTOFFSET.idOnOrbit2.p) }
  public static func add(linkStartTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: linkStartTime, at: VTOFFSET.linkStartTime.p) }
  public static func add(linkStopTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: linkStopTime, at: VTOFFSET.linkStopTime.p) }
  public static func add(constellation: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: constellation, at: VTOFFSET.constellation.p) }
  public static func add(linkName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: linkName, at: VTOFFSET.linkName.p) }
  public static func add(linkType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: linkType, at: VTOFFSET.linkType.p) }
  public static func add(band: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: band, at: VTOFFSET.band.p) }
  public static func add(idBeam1: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idBeam1, at: VTOFFSET.idBeam1.p) }
  public static func add(endPoint1Name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: endPoint1Name, at: VTOFFSET.endPoint1Name.p) }
  public static func add(endPoint1Lat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: endPoint1Lat, def: 0.0, at: VTOFFSET.endPoint1Lat.p) }
  public static func add(endPoint1Lon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: endPoint1Lon, def: 0.0, at: VTOFFSET.endPoint1Lon.p) }
  public static func add(idBeam2: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idBeam2, at: VTOFFSET.idBeam2.p) }
  public static func add(endPoint2Name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: endPoint2Name, at: VTOFFSET.endPoint2Name.p) }
  public static func add(endPoint2Lat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: endPoint2Lat, def: 0.0, at: VTOFFSET.endPoint2Lat.p) }
  public static func add(endPoint2Lon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: endPoint2Lon, def: 0.0, at: VTOFFSET.endPoint2Lon.p) }
  public static func add(dataRate1To2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataRate1To2, def: 0.0, at: VTOFFSET.dataRate1To2.p) }
  public static func add(dataRate2To1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataRate2To1, def: 0.0, at: VTOFFSET.dataRate2To1.p) }
  public static func add(linkState: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: linkState, at: VTOFFSET.linkState.p) }
  public static func add(sysCap: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sysCap, at: VTOFFSET.sysCap.p) }
  public static func add(opsCap: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: opsCap, at: VTOFFSET.opsCap.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: LinkStatus_Ingest_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(satNo1: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: satNo1, def: 0, at: VTOFFSET.satNo1.p) }
  public static func add(satNo2: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: satNo2, def: 0, at: VTOFFSET.satNo2.p) }
  public static func endLinkStatus_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLinkStatus_Ingest(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    idOnOrbit1Offset idOnOrbit1: Offset = Offset(),
    idOnOrbit2Offset idOnOrbit2: Offset = Offset(),
    linkStartTimeOffset linkStartTime: Offset = Offset(),
    linkStopTimeOffset linkStopTime: Offset = Offset(),
    constellationOffset constellation: Offset = Offset(),
    linkNameOffset linkName: Offset = Offset(),
    linkTypeOffset linkType: Offset = Offset(),
    bandOffset band: Offset = Offset(),
    idBeam1Offset idBeam1: Offset = Offset(),
    endPoint1NameOffset endPoint1Name: Offset = Offset(),
    endPoint1Lat: Double = 0.0,
    endPoint1Lon: Double = 0.0,
    idBeam2Offset idBeam2: Offset = Offset(),
    endPoint2NameOffset endPoint2Name: Offset = Offset(),
    endPoint2Lat: Double = 0.0,
    endPoint2Lon: Double = 0.0,
    dataRate1To2: Double = 0.0,
    dataRate2To1: Double = 0.0,
    linkStateOffset linkState: Offset = Offset(),
    sysCapOffset sysCap: Offset = Offset(),
    opsCapOffset opsCap: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: LinkStatus_Ingest_dataMode_Enum = .real,
    satNo1: Int32 = 0,
    satNo2: Int32 = 0
  ) -> Offset {
    let __start = LinkStatus_Ingest.startLinkStatus_Ingest(&fbb)
    LinkStatus_Ingest.add(id: id, &fbb)
    LinkStatus_Ingest.add(classificationMarking: classificationMarking, &fbb)
    LinkStatus_Ingest.add(idOnOrbit1: idOnOrbit1, &fbb)
    LinkStatus_Ingest.add(idOnOrbit2: idOnOrbit2, &fbb)
    LinkStatus_Ingest.add(linkStartTime: linkStartTime, &fbb)
    LinkStatus_Ingest.add(linkStopTime: linkStopTime, &fbb)
    LinkStatus_Ingest.add(constellation: constellation, &fbb)
    LinkStatus_Ingest.add(linkName: linkName, &fbb)
    LinkStatus_Ingest.add(linkType: linkType, &fbb)
    LinkStatus_Ingest.add(band: band, &fbb)
    LinkStatus_Ingest.add(idBeam1: idBeam1, &fbb)
    LinkStatus_Ingest.add(endPoint1Name: endPoint1Name, &fbb)
    LinkStatus_Ingest.add(endPoint1Lat: endPoint1Lat, &fbb)
    LinkStatus_Ingest.add(endPoint1Lon: endPoint1Lon, &fbb)
    LinkStatus_Ingest.add(idBeam2: idBeam2, &fbb)
    LinkStatus_Ingest.add(endPoint2Name: endPoint2Name, &fbb)
    LinkStatus_Ingest.add(endPoint2Lat: endPoint2Lat, &fbb)
    LinkStatus_Ingest.add(endPoint2Lon: endPoint2Lon, &fbb)
    LinkStatus_Ingest.add(dataRate1To2: dataRate1To2, &fbb)
    LinkStatus_Ingest.add(dataRate2To1: dataRate2To1, &fbb)
    LinkStatus_Ingest.add(linkState: linkState, &fbb)
    LinkStatus_Ingest.add(sysCap: sysCap, &fbb)
    LinkStatus_Ingest.add(opsCap: opsCap, &fbb)
    LinkStatus_Ingest.add(createdAt: createdAt, &fbb)
    LinkStatus_Ingest.add(createdBy: createdBy, &fbb)
    LinkStatus_Ingest.add(source: source, &fbb)
    LinkStatus_Ingest.add(origin: origin, &fbb)
    LinkStatus_Ingest.add(origNetwork: origNetwork, &fbb)
    LinkStatus_Ingest.add(dataMode: dataMode, &fbb)
    LinkStatus_Ingest.add(satNo1: satNo1, &fbb)
    LinkStatus_Ingest.add(satNo2: satNo2, &fbb)
    return LinkStatus_Ingest.endLinkStatus_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idOnOrbit1.p, fieldName: "idOnOrbit1", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idOnOrbit2.p, fieldName: "idOnOrbit2", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.linkStartTime.p, fieldName: "linkStartTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.linkStopTime.p, fieldName: "linkStopTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.constellation.p, fieldName: "constellation", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.linkName.p, fieldName: "linkName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.linkType.p, fieldName: "linkType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.band.p, fieldName: "band", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idBeam1.p, fieldName: "idBeam1", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.endPoint1Name.p, fieldName: "endPoint1Name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.endPoint1Lat.p, fieldName: "endPoint1Lat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.endPoint1Lon.p, fieldName: "endPoint1Lon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.idBeam2.p, fieldName: "idBeam2", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.endPoint2Name.p, fieldName: "endPoint2Name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.endPoint2Lat.p, fieldName: "endPoint2Lat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.endPoint2Lon.p, fieldName: "endPoint2Lon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.dataRate1To2.p, fieldName: "dataRate1To2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.dataRate2To1.p, fieldName: "dataRate2To1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.linkState.p, fieldName: "linkState", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sysCap.p, fieldName: "sysCap", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.opsCap.p, fieldName: "opsCap", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: LinkStatus_Ingest_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.satNo1.p, fieldName: "satNo1", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.satNo2.p, fieldName: "satNo2", required: false, type: Int32.self)
    _v.finish()
  }
}

