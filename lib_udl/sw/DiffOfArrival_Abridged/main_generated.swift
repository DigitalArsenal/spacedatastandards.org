// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum DiffOfArrival_Abridged_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: DiffOfArrival_Abridged_dataMode_Enum { return .exercise }
  public static var min: DiffOfArrival_Abridged_dataMode_Enum { return .real }
}


///  /// Model representation of Signal time and frequency difference of arrival (TDOA/FDOA) information obtained by using passive RF based sensor phenomenologies and sensor triangulation.
public struct DiffOfArrival_Abridged: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "DIFF" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: DiffOfArrival_Abridged.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case obTime = 8
    case idOnOrbit = 10
    case idSensor1 = 12
    case idSensor2 = 14
    case satNo = 16
    case taskId = 18
    case origObjectId = 20
    case origSensorId1 = 22
    case origSensorId2 = 24
    case uct = 26
    case sensor1Delay = 28
    case sensor2Delay = 30
    case senlat = 32
    case senlon = 34
    case senalt = 36
    case sen2lat = 38
    case sen2lon = 40
    case sen2alt = 42
    case frequency = 44
    case bandwidth = 46
    case deltaRange = 48
    case deltaRangeUnc = 50
    case deltaRangeRate = 52
    case deltaRangeRateUnc = 54
    case snr = 56
    case tdoa = 58
    case tdoaUnc = 60
    case fdoa = 62
    case fdoaUnc = 64
    case collectionMode = 66
    case source = 68
    case dataMode = 70
    case origin = 72
    case createdAt = 74
    case createdBy = 76
    case descriptor = 78
    case transactionId = 80
    case origNetwork = 82
    case sourceDl = 84
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: DIFFOFARRIVAL-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Ob detection time in ISO 8601 UTC with microsecond precision.
  ///  Example: /// Example: 2018-01-01T16:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var obTime: String? { let o = _accessor.offset(VTOFFSET.obTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var obTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.obTime.v) }
  ///  Unique identifier of the target on-orbit object, if correlated.
  ///  Example: /// Example: ONORBIT-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idOnOrbit: String? { let o = _accessor.offset(VTOFFSET.idOnOrbit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idOnOrbitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idOnOrbit.v) }
  ///  Sensor ID of the primary/1st sensor used for this measurement.
  ///  Example: /// Example: SENSOR1-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idSensor1: String? { let o = _accessor.offset(VTOFFSET.idSensor1.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSensor1SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSensor1.v) }
  ///  Sensor ID of the secondary/2nd sensor used for this measurement.
  ///  Example: /// Example: SENSOR2-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idSensor2: String? { let o = _accessor.offset(VTOFFSET.idSensor2.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSensor2SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSensor2.v) }
  ///  Catalog number of the target on-orbit object.
  ///  Example: /// Example: 25544
  ///  Constraints: No constraints specified.
  public var satNo: Int32 { let o = _accessor.offset(VTOFFSET.satNo.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Optional identifier to indicate the specific tasking which produced this observation.
  ///  Example: /// Example: TASK-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var taskId: String? { let o = _accessor.offset(VTOFFSET.taskId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var taskIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.taskId.v) }
  ///  Optional identifier provided by observation source to indicate the target onorbit object of this observation. This may be an internal identifier and not necessarily a valid satellite number.
  ///  Example: /// Example: ORIGOBJECT-ID
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origObjectId: String? { let o = _accessor.offset(VTOFFSET.origObjectId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origObjectIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origObjectId.v) }
  ///  Optional identifier provided by DOA source to indicate the primary/1st sensor identifier used for this measurement. This may be an internal identifier and not necessarily a valid sensor ID.
  ///  Example: /// Example: ORIGSENSOR1-ID
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origSensorId1: String? { let o = _accessor.offset(VTOFFSET.origSensorId1.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origSensorId1SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origSensorId1.v) }
  ///  Optional identifier provided by DOA source to indicate the secondary/2nd sensor identifier used for this this observation. This may be an internal identifier and not necessarily a valid sensor ID.
  ///  Example: /// Example: ORIGSENSOR2-ID
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origSensorId2: String? { let o = _accessor.offset(VTOFFSET.origSensorId2.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origSensorId2SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origSensorId2.v) }
  ///  Boolean indicating this observation is part of an uncorrelated track or was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var uct: Bool { let o = _accessor.offset(VTOFFSET.uct.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  The signal arrival delay relative to sensor 1 in seconds.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var sensor1Delay: Double { let o = _accessor.offset(VTOFFSET.sensor1Delay.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The signal arrival delay relative to sensor 2 in seconds.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var sensor2Delay: Double { let o = _accessor.offset(VTOFFSET.sensor2Delay.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Sensor WGS84 latitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 45.1
  ///  Constraints: No constraints specified.
  public var senlat: Double { let o = _accessor.offset(VTOFFSET.senlat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Sensor WGS84 longitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 120.1
  ///  Constraints: No constraints specified.
  public var senlon: Double { let o = _accessor.offset(VTOFFSET.senlon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Sensor altitude at obTime (if mobile/onorbit) in km. If null, can be obtained from sensor info.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var senalt: Double { let o = _accessor.offset(VTOFFSET.senalt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Sensor 2 WGS84 latitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var sen2lat: Double { let o = _accessor.offset(VTOFFSET.sen2lat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Sensor 2 WGS84 longitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var sen2lon: Double { let o = _accessor.offset(VTOFFSET.sen2lon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Sensor 2 altitude at obTime (if mobile/onorbit) in km. If null, can be obtained from sensor info.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var sen2alt: Double { let o = _accessor.offset(VTOFFSET.sen2alt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Center frequency of the collect in Hz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var frequency: Double { let o = _accessor.offset(VTOFFSET.frequency.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Bandwidth of the signal in Hz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var bandwidth: Double { let o = _accessor.offset(VTOFFSET.bandwidth.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Delta range, in km. Delta range calculation convention is (sensor2 - sensor1).
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var deltaRange: Double { let o = _accessor.offset(VTOFFSET.deltaRange.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  One sigma uncertainty in delta range, in km.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var deltaRangeUnc: Double { let o = _accessor.offset(VTOFFSET.deltaRangeUnc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Delta range rate, in km/sec. Delta range rate calculation convention is (sensor2 - sensor1).
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var deltaRangeRate: Double { let o = _accessor.offset(VTOFFSET.deltaRangeRate.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  One sigma uncertainty in the delta range rate, in km/sec.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var deltaRangeRateUnc: Double { let o = _accessor.offset(VTOFFSET.deltaRangeRateUnc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Signal to noise ratio, in dB.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var snr: Double { let o = _accessor.offset(VTOFFSET.snr.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Time difference of arrival of the center frequency signal, in seconds.  TDOA calculation convention is (sensor2 - sensor1).
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var tdoa: Double { let o = _accessor.offset(VTOFFSET.tdoa.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  One sigma uncertainty in time difference of arrival of the center frequency signal, in seconds.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var tdoaUnc: Double { let o = _accessor.offset(VTOFFSET.tdoaUnc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Frequency difference of arrival of the center frequency signal, in Hz.  FDOA calculation convention is (sensor2 - sensor1).
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var fdoa: Double { let o = _accessor.offset(VTOFFSET.fdoa.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  One sigma uncertainty in frequency difference of arrival of the center frequency signal, in Hz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var fdoaUnc: Double { let o = _accessor.offset(VTOFFSET.fdoaUnc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Collection mode (e.g. SURVEY, SPOT_SEARCH, NEIGHBORHOOD_WATCH, DIRECTED_SEARCH, MANUAL, etc).
  ///  Example: /// Example: SURVEY
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var collectionMode: String? { let o = _accessor.offset(VTOFFSET.collectionMode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var collectionModeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.collectionMode.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: DiffOfArrival_Abridged_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : DiffOfArrival_Abridged_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Optional source-provided and searchable metadata or descriptor of the data.
  ///  Example: /// Example: Example descriptor
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var descriptor: String? { let o = _accessor.offset(VTOFFSET.descriptor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.descriptor.v) }
  ///  Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  ///  Example: /// Example: TRANSACTION-ID
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var transactionId: String? { let o = _accessor.offset(VTOFFSET.transactionId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var transactionIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.transactionId.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  ///  Example: /// Example: AXE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var sourceDl: String? { let o = _accessor.offset(VTOFFSET.sourceDl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceDlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceDl.v) }
  public static func startDiffOfArrival_Abridged(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 41) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(obTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: obTime, at: VTOFFSET.obTime.p) }
  public static func add(idOnOrbit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idOnOrbit, at: VTOFFSET.idOnOrbit.p) }
  public static func add(idSensor1: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSensor1, at: VTOFFSET.idSensor1.p) }
  public static func add(idSensor2: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSensor2, at: VTOFFSET.idSensor2.p) }
  public static func add(satNo: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: satNo, def: 0, at: VTOFFSET.satNo.p) }
  public static func add(taskId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: taskId, at: VTOFFSET.taskId.p) }
  public static func add(origObjectId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origObjectId, at: VTOFFSET.origObjectId.p) }
  public static func add(origSensorId1: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origSensorId1, at: VTOFFSET.origSensorId1.p) }
  public static func add(origSensorId2: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origSensorId2, at: VTOFFSET.origSensorId2.p) }
  public static func add(uct: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: uct, def: false,
   at: VTOFFSET.uct.p) }
  public static func add(sensor1Delay: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sensor1Delay, def: 0.0, at: VTOFFSET.sensor1Delay.p) }
  public static func add(sensor2Delay: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sensor2Delay, def: 0.0, at: VTOFFSET.sensor2Delay.p) }
  public static func add(senlat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: senlat, def: 0.0, at: VTOFFSET.senlat.p) }
  public static func add(senlon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: senlon, def: 0.0, at: VTOFFSET.senlon.p) }
  public static func add(senalt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: senalt, def: 0.0, at: VTOFFSET.senalt.p) }
  public static func add(sen2lat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sen2lat, def: 0.0, at: VTOFFSET.sen2lat.p) }
  public static func add(sen2lon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sen2lon, def: 0.0, at: VTOFFSET.sen2lon.p) }
  public static func add(sen2alt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sen2alt, def: 0.0, at: VTOFFSET.sen2alt.p) }
  public static func add(frequency: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: frequency, def: 0.0, at: VTOFFSET.frequency.p) }
  public static func add(bandwidth: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bandwidth, def: 0.0, at: VTOFFSET.bandwidth.p) }
  public static func add(deltaRange: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: deltaRange, def: 0.0, at: VTOFFSET.deltaRange.p) }
  public static func add(deltaRangeUnc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: deltaRangeUnc, def: 0.0, at: VTOFFSET.deltaRangeUnc.p) }
  public static func add(deltaRangeRate: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: deltaRangeRate, def: 0.0, at: VTOFFSET.deltaRangeRate.p) }
  public static func add(deltaRangeRateUnc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: deltaRangeRateUnc, def: 0.0, at: VTOFFSET.deltaRangeRateUnc.p) }
  public static func add(snr: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: snr, def: 0.0, at: VTOFFSET.snr.p) }
  public static func add(tdoa: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tdoa, def: 0.0, at: VTOFFSET.tdoa.p) }
  public static func add(tdoaUnc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tdoaUnc, def: 0.0, at: VTOFFSET.tdoaUnc.p) }
  public static func add(fdoa: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fdoa, def: 0.0, at: VTOFFSET.fdoa.p) }
  public static func add(fdoaUnc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fdoaUnc, def: 0.0, at: VTOFFSET.fdoaUnc.p) }
  public static func add(collectionMode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: collectionMode, at: VTOFFSET.collectionMode.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(dataMode: DiffOfArrival_Abridged_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(descriptor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: descriptor, at: VTOFFSET.descriptor.p) }
  public static func add(transactionId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: transactionId, at: VTOFFSET.transactionId.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(sourceDl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceDl, at: VTOFFSET.sourceDl.p) }
  public static func endDiffOfArrival_Abridged(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createDiffOfArrival_Abridged(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    obTimeOffset obTime: Offset = Offset(),
    idOnOrbitOffset idOnOrbit: Offset = Offset(),
    idSensor1Offset idSensor1: Offset = Offset(),
    idSensor2Offset idSensor2: Offset = Offset(),
    satNo: Int32 = 0,
    taskIdOffset taskId: Offset = Offset(),
    origObjectIdOffset origObjectId: Offset = Offset(),
    origSensorId1Offset origSensorId1: Offset = Offset(),
    origSensorId2Offset origSensorId2: Offset = Offset(),
    uct: Bool = false,
    sensor1Delay: Double = 0.0,
    sensor2Delay: Double = 0.0,
    senlat: Double = 0.0,
    senlon: Double = 0.0,
    senalt: Double = 0.0,
    sen2lat: Double = 0.0,
    sen2lon: Double = 0.0,
    sen2alt: Double = 0.0,
    frequency: Double = 0.0,
    bandwidth: Double = 0.0,
    deltaRange: Double = 0.0,
    deltaRangeUnc: Double = 0.0,
    deltaRangeRate: Double = 0.0,
    deltaRangeRateUnc: Double = 0.0,
    snr: Double = 0.0,
    tdoa: Double = 0.0,
    tdoaUnc: Double = 0.0,
    fdoa: Double = 0.0,
    fdoaUnc: Double = 0.0,
    collectionModeOffset collectionMode: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    dataMode: DiffOfArrival_Abridged_dataMode_Enum = .real,
    originOffset origin: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    descriptorOffset descriptor: Offset = Offset(),
    transactionIdOffset transactionId: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    sourceDlOffset sourceDl: Offset = Offset()
  ) -> Offset {
    let __start = DiffOfArrival_Abridged.startDiffOfArrival_Abridged(&fbb)
    DiffOfArrival_Abridged.add(id: id, &fbb)
    DiffOfArrival_Abridged.add(classificationMarking: classificationMarking, &fbb)
    DiffOfArrival_Abridged.add(obTime: obTime, &fbb)
    DiffOfArrival_Abridged.add(idOnOrbit: idOnOrbit, &fbb)
    DiffOfArrival_Abridged.add(idSensor1: idSensor1, &fbb)
    DiffOfArrival_Abridged.add(idSensor2: idSensor2, &fbb)
    DiffOfArrival_Abridged.add(satNo: satNo, &fbb)
    DiffOfArrival_Abridged.add(taskId: taskId, &fbb)
    DiffOfArrival_Abridged.add(origObjectId: origObjectId, &fbb)
    DiffOfArrival_Abridged.add(origSensorId1: origSensorId1, &fbb)
    DiffOfArrival_Abridged.add(origSensorId2: origSensorId2, &fbb)
    DiffOfArrival_Abridged.add(uct: uct, &fbb)
    DiffOfArrival_Abridged.add(sensor1Delay: sensor1Delay, &fbb)
    DiffOfArrival_Abridged.add(sensor2Delay: sensor2Delay, &fbb)
    DiffOfArrival_Abridged.add(senlat: senlat, &fbb)
    DiffOfArrival_Abridged.add(senlon: senlon, &fbb)
    DiffOfArrival_Abridged.add(senalt: senalt, &fbb)
    DiffOfArrival_Abridged.add(sen2lat: sen2lat, &fbb)
    DiffOfArrival_Abridged.add(sen2lon: sen2lon, &fbb)
    DiffOfArrival_Abridged.add(sen2alt: sen2alt, &fbb)
    DiffOfArrival_Abridged.add(frequency: frequency, &fbb)
    DiffOfArrival_Abridged.add(bandwidth: bandwidth, &fbb)
    DiffOfArrival_Abridged.add(deltaRange: deltaRange, &fbb)
    DiffOfArrival_Abridged.add(deltaRangeUnc: deltaRangeUnc, &fbb)
    DiffOfArrival_Abridged.add(deltaRangeRate: deltaRangeRate, &fbb)
    DiffOfArrival_Abridged.add(deltaRangeRateUnc: deltaRangeRateUnc, &fbb)
    DiffOfArrival_Abridged.add(snr: snr, &fbb)
    DiffOfArrival_Abridged.add(tdoa: tdoa, &fbb)
    DiffOfArrival_Abridged.add(tdoaUnc: tdoaUnc, &fbb)
    DiffOfArrival_Abridged.add(fdoa: fdoa, &fbb)
    DiffOfArrival_Abridged.add(fdoaUnc: fdoaUnc, &fbb)
    DiffOfArrival_Abridged.add(collectionMode: collectionMode, &fbb)
    DiffOfArrival_Abridged.add(source: source, &fbb)
    DiffOfArrival_Abridged.add(dataMode: dataMode, &fbb)
    DiffOfArrival_Abridged.add(origin: origin, &fbb)
    DiffOfArrival_Abridged.add(createdAt: createdAt, &fbb)
    DiffOfArrival_Abridged.add(createdBy: createdBy, &fbb)
    DiffOfArrival_Abridged.add(descriptor: descriptor, &fbb)
    DiffOfArrival_Abridged.add(transactionId: transactionId, &fbb)
    DiffOfArrival_Abridged.add(origNetwork: origNetwork, &fbb)
    DiffOfArrival_Abridged.add(sourceDl: sourceDl, &fbb)
    return DiffOfArrival_Abridged.endDiffOfArrival_Abridged(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.obTime.p, fieldName: "obTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idOnOrbit.p, fieldName: "idOnOrbit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idSensor1.p, fieldName: "idSensor1", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idSensor2.p, fieldName: "idSensor2", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.satNo.p, fieldName: "satNo", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.taskId.p, fieldName: "taskId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origObjectId.p, fieldName: "origObjectId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origSensorId1.p, fieldName: "origSensorId1", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origSensorId2.p, fieldName: "origSensorId2", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.uct.p, fieldName: "uct", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.sensor1Delay.p, fieldName: "sensor1Delay", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.sensor2Delay.p, fieldName: "sensor2Delay", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.senlat.p, fieldName: "senlat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.senlon.p, fieldName: "senlon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.senalt.p, fieldName: "senalt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.sen2lat.p, fieldName: "sen2lat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.sen2lon.p, fieldName: "sen2lon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.sen2alt.p, fieldName: "sen2alt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.frequency.p, fieldName: "frequency", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.bandwidth.p, fieldName: "bandwidth", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.deltaRange.p, fieldName: "deltaRange", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.deltaRangeUnc.p, fieldName: "deltaRangeUnc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.deltaRangeRate.p, fieldName: "deltaRangeRate", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.deltaRangeRateUnc.p, fieldName: "deltaRangeRateUnc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.snr.p, fieldName: "snr", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.tdoa.p, fieldName: "tdoa", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.tdoaUnc.p, fieldName: "tdoaUnc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fdoa.p, fieldName: "fdoa", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.fdoaUnc.p, fieldName: "fdoaUnc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.collectionMode.p, fieldName: "collectionMode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: DiffOfArrival_Abridged_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.descriptor.p, fieldName: "descriptor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.transactionId.p, fieldName: "transactionId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceDl.p, fieldName: "sourceDl", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

