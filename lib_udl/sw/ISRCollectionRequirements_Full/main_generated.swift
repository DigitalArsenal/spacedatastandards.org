// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  /// Tasking desired collection requirements.
public struct ISRCollectionRequirements_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "ISRC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ISRCollectionRequirements_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case hash = 6
    case type = 8
    case cridNumbers = 10
    case priority = 12
    case recordId = 14
    case reconSurvey = 16
    case intelDiscipline = 18
    case secondary = 20
    case emphasized = 22
    case isPrismCr = 24
    case start = 26
    case stop = 28
    case operation = 30
    case supportedUnit = 32
    case country = 34
    case region = 36
    case subregion = 38
    case specialComGuidance = 40
    case criticalTimes = 42
    case exploitationRequirement = 44
    case targetList = 46
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Collection Requirement Unique Identifier.
  ///  Example: /// Example: ISCRCOLLECTIONREQUIREMENTS
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Encryption hashing algorithm.
  ///  Example: /// Example: HASH
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var hash: String? { let o = _accessor.offset(VTOFFSET.hash.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var hashSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.hash.v) }
  ///  Type collection this requirement applies to.
  ///  Example: /// Example: COLLECTION_TYPE
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  ///  Collection Requirement Unique Identifier.
  ///  Example: /// Example: CRID
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var cridNumbers: String? { let o = _accessor.offset(VTOFFSET.cridNumbers.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var cridNumbersSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.cridNumbers.v) }
  ///  1-n priority for this collection requirement.
  ///  Example: /// Example: 20.23
  ///  Constraints: No constraints specified.
  public var priority: Double { let o = _accessor.offset(VTOFFSET.priority.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Record id.
  ///  Example: /// Example: RECORD-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var recordId: String? { let o = _accessor.offset(VTOFFSET.recordId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var recordIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.recordId.v) }
  ///  Reconnaissance Survey information the operator needs.
  ///  Example: /// Example: SURVEY_INFO
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var reconSurvey: String? { let o = _accessor.offset(VTOFFSET.reconSurvey.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var reconSurveySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.reconSurvey.v) }
  ///  Primary type of intelligence to be collected for this requirement.
  ///  Example: /// Example: Sig
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var intelDiscipline: String? { let o = _accessor.offset(VTOFFSET.intelDiscipline.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var intelDisciplineSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.intelDiscipline.v) }
  ///  Sub category of primary intelligence to be collected for this requirement.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var secondary: Bool { let o = _accessor.offset(VTOFFSET.secondary.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Is this collection requirement an emphasized/critical requirement.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var emphasized: Bool { let o = _accessor.offset(VTOFFSET.emphasized.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Is this collection request for the Prism system?.
  ///  Example: /// Example: True
  ///  Constraints: No constraints specified.
  public var isPrismCr: Bool { let o = _accessor.offset(VTOFFSET.isPrismCr.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Start time for this requirement, should be within the mission time window.
  ///  Example: /// Example: 2021-01-19T01:01:15.001Z
  ///  Constraints: No constraints specified.
  public var start: String? { let o = _accessor.offset(VTOFFSET.start.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var startSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.start.v) }
  ///  Stop time for this requirement, should be within the mission time window.
  ///  Example: /// Example: 2021-01-19T01:20:01.001Z
  ///  Constraints: No constraints specified.
  public var stop: String? { let o = _accessor.offset(VTOFFSET.stop.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var stopSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.stop.v) }
  ///  Human readable name for this operation.
  ///  Example: /// Example: NAME
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var operation: String? { let o = _accessor.offset(VTOFFSET.operation.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var operationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.operation.v) }
  ///  The name of the military unit that this assigned collection requirement will support.
  ///  Example: /// Example: UNIT
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var supportedUnit: String? { let o = _accessor.offset(VTOFFSET.supportedUnit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var supportedUnitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.supportedUnit.v) }
  ///  Country code of the collection requirement. A Country may represent countries, multi-national consortiums, and international organizations.
  ///  Example: /// Example: COUNTRY_CODE
  ///  Constraints: Minimum length = 0, Maximum length = 4
  public var country: String? { let o = _accessor.offset(VTOFFSET.country.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var countrySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.country.v) }
  ///  Region of the collection requirement.
  ///  Example: /// Example: REGION
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var region: String? { let o = _accessor.offset(VTOFFSET.region.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var regionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.region.v) }
  ///  Subregion of the collection requirement.
  ///  Example: /// Example: SUBREGION
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var subregion: String? { let o = _accessor.offset(VTOFFSET.subregion.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var subregionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.subregion.v) }
  ///  Free text field for the user to specify special instructions needed for this collection.
  ///  Example: /// Example: TEXT
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var specialComGuidance: String? { let o = _accessor.offset(VTOFFSET.specialComGuidance.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var specialComGuidanceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.specialComGuidance.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var criticalTimes: String? { let o = _accessor.offset(VTOFFSET.criticalTimes.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var criticalTimesSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.criticalTimes.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var exploitationRequirement: String? { let o = _accessor.offset(VTOFFSET.exploitationRequirement.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var exploitationRequirementSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.exploitationRequirement.v) }
  ///  Array of POI Id's for the targets being tasked.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasTargetList: Bool { let o = _accessor.offset(VTOFFSET.targetList.v); return o == 0 ? false : true }
  public var targetListCount: Int32 { let o = _accessor.offset(VTOFFSET.targetList.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func targetList(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.targetList.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startISRCollectionRequirements_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 22) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(hash: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: hash, at: VTOFFSET.hash.p) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func add(cridNumbers: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: cridNumbers, at: VTOFFSET.cridNumbers.p) }
  public static func add(priority: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: priority, def: 0.0, at: VTOFFSET.priority.p) }
  public static func add(recordId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: recordId, at: VTOFFSET.recordId.p) }
  public static func add(reconSurvey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: reconSurvey, at: VTOFFSET.reconSurvey.p) }
  public static func add(intelDiscipline: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: intelDiscipline, at: VTOFFSET.intelDiscipline.p) }
  public static func add(secondary: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: secondary, def: false,
   at: VTOFFSET.secondary.p) }
  public static func add(emphasized: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: emphasized, def: false,
   at: VTOFFSET.emphasized.p) }
  public static func add(isPrismCr: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isPrismCr, def: false,
   at: VTOFFSET.isPrismCr.p) }
  public static func add(start: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: start, at: VTOFFSET.start.p) }
  public static func add(stop: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: stop, at: VTOFFSET.stop.p) }
  public static func add(operation: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: operation, at: VTOFFSET.operation.p) }
  public static func add(supportedUnit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: supportedUnit, at: VTOFFSET.supportedUnit.p) }
  public static func add(country: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: country, at: VTOFFSET.country.p) }
  public static func add(region: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: region, at: VTOFFSET.region.p) }
  public static func add(subregion: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: subregion, at: VTOFFSET.subregion.p) }
  public static func add(specialComGuidance: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: specialComGuidance, at: VTOFFSET.specialComGuidance.p) }
  public static func add(criticalTimes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: criticalTimes, at: VTOFFSET.criticalTimes.p) }
  public static func add(exploitationRequirement: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: exploitationRequirement, at: VTOFFSET.exploitationRequirement.p) }
  public static func addVectorOf(targetList: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: targetList, at: VTOFFSET.targetList.p) }
  public static func endISRCollectionRequirements_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createISRCollectionRequirements_Full(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    hashOffset hash: Offset = Offset(),
    typeOffset type: Offset = Offset(),
    cridNumbersOffset cridNumbers: Offset = Offset(),
    priority: Double = 0.0,
    recordIdOffset recordId: Offset = Offset(),
    reconSurveyOffset reconSurvey: Offset = Offset(),
    intelDisciplineOffset intelDiscipline: Offset = Offset(),
    secondary: Bool = false,
    emphasized: Bool = false,
    isPrismCr: Bool = false,
    startOffset start: Offset = Offset(),
    stopOffset stop: Offset = Offset(),
    operationOffset operation: Offset = Offset(),
    supportedUnitOffset supportedUnit: Offset = Offset(),
    countryOffset country: Offset = Offset(),
    regionOffset region: Offset = Offset(),
    subregionOffset subregion: Offset = Offset(),
    specialComGuidanceOffset specialComGuidance: Offset = Offset(),
    criticalTimesOffset criticalTimes: Offset = Offset(),
    exploitationRequirementOffset exploitationRequirement: Offset = Offset(),
    targetListVectorOffset targetList: Offset = Offset()
  ) -> Offset {
    let __start = ISRCollectionRequirements_Full.startISRCollectionRequirements_Full(&fbb)
    ISRCollectionRequirements_Full.add(id: id, &fbb)
    ISRCollectionRequirements_Full.add(hash: hash, &fbb)
    ISRCollectionRequirements_Full.add(type: type, &fbb)
    ISRCollectionRequirements_Full.add(cridNumbers: cridNumbers, &fbb)
    ISRCollectionRequirements_Full.add(priority: priority, &fbb)
    ISRCollectionRequirements_Full.add(recordId: recordId, &fbb)
    ISRCollectionRequirements_Full.add(reconSurvey: reconSurvey, &fbb)
    ISRCollectionRequirements_Full.add(intelDiscipline: intelDiscipline, &fbb)
    ISRCollectionRequirements_Full.add(secondary: secondary, &fbb)
    ISRCollectionRequirements_Full.add(emphasized: emphasized, &fbb)
    ISRCollectionRequirements_Full.add(isPrismCr: isPrismCr, &fbb)
    ISRCollectionRequirements_Full.add(start: start, &fbb)
    ISRCollectionRequirements_Full.add(stop: stop, &fbb)
    ISRCollectionRequirements_Full.add(operation: operation, &fbb)
    ISRCollectionRequirements_Full.add(supportedUnit: supportedUnit, &fbb)
    ISRCollectionRequirements_Full.add(country: country, &fbb)
    ISRCollectionRequirements_Full.add(region: region, &fbb)
    ISRCollectionRequirements_Full.add(subregion: subregion, &fbb)
    ISRCollectionRequirements_Full.add(specialComGuidance: specialComGuidance, &fbb)
    ISRCollectionRequirements_Full.add(criticalTimes: criticalTimes, &fbb)
    ISRCollectionRequirements_Full.add(exploitationRequirement: exploitationRequirement, &fbb)
    ISRCollectionRequirements_Full.addVectorOf(targetList: targetList, &fbb)
    return ISRCollectionRequirements_Full.endISRCollectionRequirements_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.hash.p, fieldName: "hash", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.cridNumbers.p, fieldName: "cridNumbers", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.priority.p, fieldName: "priority", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.recordId.p, fieldName: "recordId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.reconSurvey.p, fieldName: "reconSurvey", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.intelDiscipline.p, fieldName: "intelDiscipline", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.secondary.p, fieldName: "secondary", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.emphasized.p, fieldName: "emphasized", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.isPrismCr.p, fieldName: "isPrismCr", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.start.p, fieldName: "start", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.stop.p, fieldName: "stop", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.operation.p, fieldName: "operation", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.supportedUnit.p, fieldName: "supportedUnit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.country.p, fieldName: "country", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.region.p, fieldName: "region", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.subregion.p, fieldName: "subregion", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.specialComGuidance.p, fieldName: "specialComGuidance", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.criticalTimes.p, fieldName: "criticalTimes", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.exploitationRequirement.p, fieldName: "exploitationRequirement", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.targetList.p, fieldName: "targetList", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

