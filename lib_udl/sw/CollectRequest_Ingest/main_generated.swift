// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum CollectRequest_Ingest_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: CollectRequest_Ingest_dataMode_Enum { return .exercise }
  public static var min: CollectRequest_Ingest_dataMode_Enum { return .real }
}


///  /// Collect Requests support several types of individual requests, or planned/scheduled tasks on sensors and/or orbital objects. Options are provided to accomodate most common sensor contact and collection applications, including single sensor-object tasking, search operations, and TT&C support. Multiple requests originating from a plan or schedule may be associated to a sensor plan if desired.
public struct CollectRequest_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "COLL" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CollectRequest_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case idParentReq = 8
    case msgType = 10
    case msgCreateDate = 12
    case type = 14
    case idPlan = 16
    case planIndex = 18
    case taskId = 20
    case dwellId = 22
    case externalId = 24
    case idSensor = 26
    case origSensorId = 28
    case obType = 30
    case priority = 32
    case taskCategory = 34
    case suffix = 36
    case uctFollowUp = 38
    case startTime = 40
    case endTime = 42
    case idOnOrbit = 44
    case satNo = 46
    case origObjectId = 48
    case taskGroup = 50
    case iron = 52
    case orbitRegime = 54
    case targetSize = 56
    case rcsMin = 58
    case rcs = 60
    case rcsMax = 62
    case freqMin = 64
    case freq = 66
    case freqMax = 68
    case polarization = 70
    case visMagMin = 72
    case visMag = 74
    case visMagMax = 76
    case spectralModel = 78
    case reflectance = 80
    case irradiance = 82
    case numFrames = 84
    case frameRate = 86
    case integrationTime = 88
    case numTracks = 90
    case numObs = 92
    case duration = 94
    case srchPattern = 96
    case scenario = 98
    case idElset = 100
    case idManifold = 102
    case idStateVector = 104
    case esId = 106
    case epoch = 108
    case semiMajorAxis = 110
    case eccentricity = 112
    case inclination = 114
    case raan = 116
    case argOfPerigee = 118
    case trueAnomoly = 120
    case ra = 122
    case dec = 124
    case az = 126
    case el = 128
    case range = 130
    case extentAz = 132
    case extentEl = 134
    case extentRange = 136
    case lat = 138
    case lon = 140
    case alt = 142
    case stopLat = 144
    case stopLon = 146
    case stopAlt = 148
    case srchInc = 150
    case xAngle = 152
    case yAngle = 154
    case orientAngle = 156
    case customer = 158
    case notes = 160
    case createdAt = 162
    case createdBy = 164
    case source = 166
    case origin = 168
    case origNetwork = 170
    case dataMode = 172
    case stateVector = 174
    case elset = 176
    case tags = 178
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: COLLECTREQUEST-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  The unique ID of the collect request record from which this request originated. This may be used for cases of sensor-to-sensor tasking, such as tip/cue operations.
  ///  Example: /// Example: da98671b-34db-47bf-8c8d-7c668b92c800
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idParentReq: String? { let o = _accessor.offset(VTOFFSET.idParentReq.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idParentReqSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idParentReq.v) }
  ///  The type of external message from which this request originated.
  ///  Example: /// Example: SU67
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var msgType: String? { let o = _accessor.offset(VTOFFSET.msgType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var msgTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.msgType.v) }
  ///  The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
  ///  Example: /// Example: 2024-04-25T08:17:01.346Z
  ///  Constraints: No constraints specified.
  public var msgCreateDate: String? { let o = _accessor.offset(VTOFFSET.msgCreateDate.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var msgCreateDateSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.msgCreateDate.v) }
  ///  The type of this collect or contact request (DIRECTED SEARCH, DWELL, OBJECT, POL, RATE TRACK, SEARCH, SOI, STARE, TTC, VOLUME SEARCH, etc.).
  ///  Example: /// Example: DWELL
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  ///  Unique identifier of the parent plan or schedule associated with this request.  If null, this request is assumed not associated with a plan or schedule.
  ///  Example: /// Example: REF-PLAN-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idPlan: String? { let o = _accessor.offset(VTOFFSET.idPlan.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idPlanSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idPlan.v) }
  ///  Index number (integer) for records within a collection plan or schedule.
  ///  Example: /// Example: 8
  ///  Constraints: No constraints specified.
  public var planIndex: Int32 { let o = _accessor.offset(VTOFFSET.planIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Task ID associated with this request.  A task ID may be associated with a single collect request or may be used to tie together the sub-requests of a full collect, for example a DWELL consisting of many dwell points.
  ///  Example: /// Example: TASK-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var taskId: String? { let o = _accessor.offset(VTOFFSET.taskId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var taskIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.taskId.v) }
  ///  The dwell ID associated with this request.  A dwell ID is dwell point specific and a DWELL request consist of many dwell point requests.
  ///  Example: /// Example: DWELL-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var dwellId: String? { let o = _accessor.offset(VTOFFSET.dwellId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var dwellIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.dwellId.v) }
  ///  Optional ID from external systems.  This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  ///  Example: /// Example: EXTERNAL-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var externalId: String? { let o = _accessor.offset(VTOFFSET.externalId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var externalIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.externalId.v) }
  ///  Unique identifier of the requested/scheduled/planned sensor associated with this request.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
  ///  Example: /// Example: REF-SENSOR-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idSensor: String? { let o = _accessor.offset(VTOFFSET.idSensor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSensorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSensor.v) }
  ///  Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request. This may be an internal identifier and not necessarily a valid sensor ID.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
  ///  Example: /// Example: ORIGSENSOR-ID
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origSensorId: String? { let o = _accessor.offset(VTOFFSET.origSensorId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origSensorIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origSensorId.v) }
  ///  Optional type of observation (EO, IR, RADAR, RF-ACTIVE, RF-PASSIVE, OTHER) requested.  This field may correspond to a request of a specific sensor, or to a general non sensor specific request.
  ///  Example: /// Example: RADAR
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var obType: String? { let o = _accessor.offset(VTOFFSET.obType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var obTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.obType.v) }
  ///  The priority of the collect request  (EMERGENCY, FLASH, IMMEDIATE, PRIORITY, ROUTINE).
  ///  Example: /// Example: EMERGENCY
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var priority: String? { let o = _accessor.offset(VTOFFSET.priority.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var prioritySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.priority.v) }
  ///  The (SSN) tasking category (1-5) associated with this request.  The tasking category defines the priority of gathering and transmitting the requested observational data.  Note that category definitions are sensor type specific.
  ///  Example: /// Example: 4
  ///  Constraints: No constraints specified.
  public var taskCategory: Int32 { let o = _accessor.offset(VTOFFSET.taskCategory.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The (SSN) tasking suffix (A-Z) associated with this request.  The suffix defines the amount of observational data and the frequency of collection.  Note that suffix definitions are sensor type specific.
  ///  Example: /// Example: T
  ///  Constraints: Minimum length = 0, Maximum length = 1
  public var suffix: String? { let o = _accessor.offset(VTOFFSET.suffix.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var suffixSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.suffix.v) }
  ///  Boolean indicating that this collect request is UCT follow-up.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var uctFollowUp: Bool { let o = _accessor.offset(VTOFFSET.uctFollowUp.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  The start time or earliest time of the collect or contact request window, in ISO 8601 UTC format.
  ///  Example: /// Example: 2018-01-01T16:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var startTime: String? { let o = _accessor.offset(VTOFFSET.startTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var startTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.startTime.v) }
  ///  The end time of the collect or contact request window, in ISO 8601 UTC format.  If no endTime or duration is provided it is assumed the request is either ongoing or that the request is for a specified number of tracks (numTracks).  If both duration and endTime are provided, the endTime is assumed to take precedence.
  ///  Example: /// Example: 2018-01-01T18:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var endTime: String? { let o = _accessor.offset(VTOFFSET.endTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var endTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.endTime.v) }
  ///  Unique identifier of the target on-orbit object for this request.
  ///  Example: /// Example: REF-ONORBIT-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idOnOrbit: String? { let o = _accessor.offset(VTOFFSET.idOnOrbit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idOnOrbitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idOnOrbit.v) }
  ///  Satellite/catalog number of the target on-orbit object for this request.
  ///  Example: /// Example: 101
  ///  Constraints: No constraints specified.
  public var satNo: Int32 { let o = _accessor.offset(VTOFFSET.satNo.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Optional identifier provided by the data source to indicate the target object of this request. This may be an internal identifier and not necessarily map to a valid satellite number.
  ///  Example: /// Example: ORIGOBJECT-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var origObjectId: String? { let o = _accessor.offset(VTOFFSET.origObjectId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origObjectIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origObjectId.v) }
  ///  The tasking group to which the target object is assigned.
  ///  Example: /// Example: 729
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var taskGroup: String? { let o = _accessor.offset(VTOFFSET.taskGroup.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var taskGroupSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.taskGroup.v) }
  ///  Inter-Range Operations Number.  Four-digit identifier used to schedule and identify AFSCN contact support for booster, launch, and on-orbit operations.
  ///  Example: /// Example: 3
  ///  Constraints: No constraints specified.
  public var iron: Int32 { let o = _accessor.offset(VTOFFSET.iron.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The orbit regime of the target (GEO, HEO, LAUNCH, LEO, MEO, OTHER).
  ///  Example: /// Example: GEO
  ///  Constraints: Minimum length = 0, Maximum length = 12
  public var orbitRegime: String? { let o = _accessor.offset(VTOFFSET.orbitRegime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var orbitRegimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.orbitRegime.v) }
  ///  The minimum object (diameter) size, in meters, to be reported.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var targetSize: Double { let o = _accessor.offset(VTOFFSET.targetSize.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The minimum Radar Cross-Section of the target, in m^2.  If only minimum RCS is provided it is assumed to be minimum reportable RCS.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var rcsMin: Double { let o = _accessor.offset(VTOFFSET.rcsMin.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The Radar Cross-Section of the target, in m^2.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var rcs: Double { let o = _accessor.offset(VTOFFSET.rcs.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The maximum Radar Cross-Section of the target, in m^2.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var rcsMax: Double { let o = _accessor.offset(VTOFFSET.rcsMax.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The minimum frequency of interest, in MHz.  If only minimum frequency is provided it is assumed to be minimum reportable frequency.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var freqMin: Double { let o = _accessor.offset(VTOFFSET.freqMin.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The estimated or expected emission frequency of the target, in MHz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var freq: Double { let o = _accessor.offset(VTOFFSET.freq.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The maximum frequency of interest, in MHz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var freqMax: Double { let o = _accessor.offset(VTOFFSET.freqMax.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The RF polarization (H, LHC, RHC, V).
  ///  Example: /// Example: H
  ///  Constraints: Minimum length = 0, Maximum length = 4
  public var polarization: String? { let o = _accessor.offset(VTOFFSET.polarization.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var polarizationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.polarization.v) }
  ///  The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).  If only minimum vismag is provided it is assumed to be minimum reportable vismag.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var visMagMin: Double { let o = _accessor.offset(VTOFFSET.visMagMin.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The estimated or expected visual magnitude of the target, in Magnitudes (M).
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var visMag: Double { let o = _accessor.offset(VTOFFSET.visMag.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var visMagMax: Double { let o = _accessor.offset(VTOFFSET.visMagMax.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The spectral model used for the irradiance calculation.
  ///  Example: /// Example: Example Model
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var spectralModel: String? { let o = _accessor.offset(VTOFFSET.spectralModel.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var spectralModelSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.spectralModel.v) }
  ///  The fraction of solar energy reflected from target.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var reflectance: Double { let o = _accessor.offset(VTOFFSET.reflectance.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The target object irradiance value.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var irradiance: Double { let o = _accessor.offset(VTOFFSET.irradiance.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For optical sensors, the requested number of frames to capture at each sensor step.
  ///  Example: /// Example: 6
  ///  Constraints: No constraints specified.
  public var numFrames: Int32 { let o = _accessor.offset(VTOFFSET.numFrames.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  For optical sensors, the frame rate of the camera, in Hz.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var frameRate: Double { let o = _accessor.offset(VTOFFSET.frameRate.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  For optical sensors, the integration time per camera frame, in milliseconds.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var integrationTime: Double { let o = _accessor.offset(VTOFFSET.integrationTime.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The number of requested tracks on the target.  If numTracks is not provided it is assumed to indicate all possible observations every pass over the request duration or within the request start/end window.
  ///  Example: /// Example: 3
  ///  Constraints: No constraints specified.
  public var numTracks: Int32 { let o = _accessor.offset(VTOFFSET.numTracks.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The number of requested observations on the target.
  ///  Example: /// Example: 9
  ///  Constraints: No constraints specified.
  public var numObs: Int32 { let o = _accessor.offset(VTOFFSET.numObs.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The duration of the collect request, in seconds.  If both duration and endTime are provided, the endTime is assumed to take precedence.
  ///  Example: /// Example: 11
  ///  Constraints: No constraints specified.
  public var duration: Int32 { let o = _accessor.offset(VTOFFSET.duration.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The search pattern to be executed for this request (e.g. PICKET-FENCE, SCAN, etc.).
  ///  Example: /// Example: SCAN
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var srchPattern: String? { let o = _accessor.offset(VTOFFSET.srchPattern.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var srchPatternSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.srchPattern.v) }
  ///  Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
  ///  Example: /// Example: Example direction
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var scenario: String? { let o = _accessor.offset(VTOFFSET.scenario.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var scenarioSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.scenario.v) }
  ///  ID of the UDL Elset of the object associated with this request.
  ///  Example: /// Example: REF-ELSET-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idElset: String? { let o = _accessor.offset(VTOFFSET.idElset.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idElsetSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idElset.v) }
  ///  ID of the UDL Manifold Elset of the object associated with this request.  A Manifold Elset provides theoretical Keplerian orbital elements belonging to an object of interest's manifold describing a possible/theoretical orbit for an object of interest for tasking purposes.
  ///  Example: /// Example: REF-MANIFOLD-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idManifold: String? { let o = _accessor.offset(VTOFFSET.idManifold.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idManifoldSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idManifold.v) }
  ///  ID of the UDL State Vector of the object or central vector associated with this request.
  ///  Example: /// Example: STATEVECTOR-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idStateVector: String? { let o = _accessor.offset(VTOFFSET.idStateVector.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idStateVectorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idStateVector.v) }
  ///  ID of the UDL Ephemeris Set of the object associated with this request.
  ///  Example: /// Example: ES-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var esId: String? { let o = _accessor.offset(VTOFFSET.esId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var esIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.esId.v) }
  ///  Epoch time, in ISO 8601 UTC format, of the orbital elements.
  ///  Example: /// Example: 2018-01-01T16:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var epoch: String? { let o = _accessor.offset(VTOFFSET.epoch.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var epochSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.epoch.v) }
  ///  The average of the periapsis and apoapsis distances, in kilometers. For circular orbits, the semimajor axis is the distance between the centers of the bodies.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var semiMajorAxis: Double { let o = _accessor.offset(VTOFFSET.semiMajorAxis.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var eccentricity: Double { let o = _accessor.offset(VTOFFSET.eccentricity.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The angle, in degrees, between the equator and the orbit plane when looking from the center of the Earth. Inclination ranges from 0-180 degrees, with 0-90 representing posigrade orbits and 90-180 representing retrograde orbits.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var inclination: Double { let o = _accessor.offset(VTOFFSET.inclination.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var raan: Double { let o = _accessor.offset(VTOFFSET.raan.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The argument of perigee is the angle, in degrees, formed between the perigee and the ascending node.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var argOfPerigee: Double { let o = _accessor.offset(VTOFFSET.argOfPerigee.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The true anomaly defines the angular position, in degrees, of the object on it's orbital path as measured from the orbit focal point at epoch.  The true anomaly is referenced from perigee.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var trueAnomoly: Double { let o = _accessor.offset(VTOFFSET.trueAnomoly.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The expected or directed right ascension angle, in degrees, for search or target acquisition.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var ra: Double { let o = _accessor.offset(VTOFFSET.ra.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The expected or directed declination angle, in degrees, for search or target acquisition.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var dec: Double { let o = _accessor.offset(VTOFFSET.dec.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The expected or directed azimuth angle, in degrees, for search or target acquisition.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var az: Double { let o = _accessor.offset(VTOFFSET.az.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The expected or directed elevation angle, in degrees, for search or target acquisition.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var el: Double { let o = _accessor.offset(VTOFFSET.el.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The expected acquisition range or defined center range, in km.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var range: Double { let o = _accessor.offset(VTOFFSET.range.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The extent of the azimuth angle, in degrees, from center azimuth to define a spatial volume.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var extentAz: Double { let o = _accessor.offset(VTOFFSET.extentAz.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The extent of the elevation angle, in degrees, from center elevation to define a spatial volume.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var extentEl: Double { let o = _accessor.offset(VTOFFSET.extentEl.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The extent of the range, in km, from center range to define a spatial volume.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var extentRange: Double { let o = _accessor.offset(VTOFFSET.extentRange.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 latitude, in degrees. -90 to 90 degrees (negative values south of equator).  If an accompanying stopLat is provided, then the lat value can be assumed to be the starting latitude of a volume definition.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var lat: Double { let o = _accessor.offset(VTOFFSET.lat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).  If an accompanying stopLon is provided, then lon value can be assumed to be the starting longitude of a volume definition.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var lon: Double { let o = _accessor.offset(VTOFFSET.lon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Height above WGS-84 ellipsoid (HAE), in kilometers.  If an accompanying stopAlt is provided, then alt value can be assumed to be the starting altitude of a volume definition.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var alt: Double { let o = _accessor.offset(VTOFFSET.alt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The stopping WGS-84 latitude of a volume definition, in degrees.  -90 to 90 degrees (negative values south of equator).  The stopLat value is only meaningful if a (starting) lat value is provided.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var stopLat: Double { let o = _accessor.offset(VTOFFSET.stopLat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The stopping WGS-84 longitude of a volume definition, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian).  The stopLon value is only meaningful if a (starting) lon value is provided.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var stopLon: Double { let o = _accessor.offset(VTOFFSET.stopLon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The stopping HAE WGS-84 height above ellipsoid (HAE), of a volume definition, in kilometers.  The stopAlt value is only meaningful if a (starting) alt value is provided.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var stopAlt: Double { let o = _accessor.offset(VTOFFSET.stopAlt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The maximum inclination, in degrees, to be used in search operations.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var srchInc: Double { let o = _accessor.offset(VTOFFSET.srchInc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The angular distance, in degrees, in the sensor-x direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var xAngle: Double { let o = _accessor.offset(VTOFFSET.xAngle.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The angular distance, in degrees, in the sensor-y direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var yAngle: Double { let o = _accessor.offset(VTOFFSET.yAngle.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.  A positive value indicates clockwise rotation about the sensor boresight vector.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var orientAngle: Double { let o = _accessor.offset(VTOFFSET.orientAngle.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The customer for this request.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var customer: String? { let o = _accessor.offset(VTOFFSET.customer.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var customerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.customer.v) }
  ///  Notes or comments associated with this request.
  ///  Example: /// Example: Example notes
  ///  Constraints: Minimum length = 0, Maximum length = 512
  public var notes: String? { let o = _accessor.offset(VTOFFSET.notes.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var notesSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.notes.v) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: Example source
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: CollectRequest_Ingest_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : CollectRequest_Ingest_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var stateVector: String? { let o = _accessor.offset(VTOFFSET.stateVector.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var stateVectorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.stateVector.v) }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var elset: String? { let o = _accessor.offset(VTOFFSET.elset.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var elsetSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.elset.v) }
  ///  Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  ///  Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
  ///  Constraints: No constraints specified.
  public var hasTags: Bool { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? false : true }
  public var tagsCount: Int32 { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tags(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startCollectRequest_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 88) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(idParentReq: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idParentReq, at: VTOFFSET.idParentReq.p) }
  public static func add(msgType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: msgType, at: VTOFFSET.msgType.p) }
  public static func add(msgCreateDate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: msgCreateDate, at: VTOFFSET.msgCreateDate.p) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func add(idPlan: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idPlan, at: VTOFFSET.idPlan.p) }
  public static func add(planIndex: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: planIndex, def: 0, at: VTOFFSET.planIndex.p) }
  public static func add(taskId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: taskId, at: VTOFFSET.taskId.p) }
  public static func add(dwellId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dwellId, at: VTOFFSET.dwellId.p) }
  public static func add(externalId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: externalId, at: VTOFFSET.externalId.p) }
  public static func add(idSensor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSensor, at: VTOFFSET.idSensor.p) }
  public static func add(origSensorId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origSensorId, at: VTOFFSET.origSensorId.p) }
  public static func add(obType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: obType, at: VTOFFSET.obType.p) }
  public static func add(priority: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: priority, at: VTOFFSET.priority.p) }
  public static func add(taskCategory: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: taskCategory, def: 0, at: VTOFFSET.taskCategory.p) }
  public static func add(suffix: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: suffix, at: VTOFFSET.suffix.p) }
  public static func add(uctFollowUp: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: uctFollowUp, def: false,
   at: VTOFFSET.uctFollowUp.p) }
  public static func add(startTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startTime, at: VTOFFSET.startTime.p) }
  public static func add(endTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: endTime, at: VTOFFSET.endTime.p) }
  public static func add(idOnOrbit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idOnOrbit, at: VTOFFSET.idOnOrbit.p) }
  public static func add(satNo: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: satNo, def: 0, at: VTOFFSET.satNo.p) }
  public static func add(origObjectId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origObjectId, at: VTOFFSET.origObjectId.p) }
  public static func add(taskGroup: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: taskGroup, at: VTOFFSET.taskGroup.p) }
  public static func add(iron: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: iron, def: 0, at: VTOFFSET.iron.p) }
  public static func add(orbitRegime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: orbitRegime, at: VTOFFSET.orbitRegime.p) }
  public static func add(targetSize: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: targetSize, def: 0.0, at: VTOFFSET.targetSize.p) }
  public static func add(rcsMin: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: rcsMin, def: 0.0, at: VTOFFSET.rcsMin.p) }
  public static func add(rcs: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: rcs, def: 0.0, at: VTOFFSET.rcs.p) }
  public static func add(rcsMax: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: rcsMax, def: 0.0, at: VTOFFSET.rcsMax.p) }
  public static func add(freqMin: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: freqMin, def: 0.0, at: VTOFFSET.freqMin.p) }
  public static func add(freq: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: freq, def: 0.0, at: VTOFFSET.freq.p) }
  public static func add(freqMax: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: freqMax, def: 0.0, at: VTOFFSET.freqMax.p) }
  public static func add(polarization: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: polarization, at: VTOFFSET.polarization.p) }
  public static func add(visMagMin: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: visMagMin, def: 0.0, at: VTOFFSET.visMagMin.p) }
  public static func add(visMag: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: visMag, def: 0.0, at: VTOFFSET.visMag.p) }
  public static func add(visMagMax: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: visMagMax, def: 0.0, at: VTOFFSET.visMagMax.p) }
  public static func add(spectralModel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: spectralModel, at: VTOFFSET.spectralModel.p) }
  public static func add(reflectance: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: reflectance, def: 0.0, at: VTOFFSET.reflectance.p) }
  public static func add(irradiance: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: irradiance, def: 0.0, at: VTOFFSET.irradiance.p) }
  public static func add(numFrames: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numFrames, def: 0, at: VTOFFSET.numFrames.p) }
  public static func add(frameRate: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: frameRate, def: 0.0, at: VTOFFSET.frameRate.p) }
  public static func add(integrationTime: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: integrationTime, def: 0.0, at: VTOFFSET.integrationTime.p) }
  public static func add(numTracks: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numTracks, def: 0, at: VTOFFSET.numTracks.p) }
  public static func add(numObs: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numObs, def: 0, at: VTOFFSET.numObs.p) }
  public static func add(duration: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: duration, def: 0, at: VTOFFSET.duration.p) }
  public static func add(srchPattern: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: srchPattern, at: VTOFFSET.srchPattern.p) }
  public static func add(scenario: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: scenario, at: VTOFFSET.scenario.p) }
  public static func add(idElset: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idElset, at: VTOFFSET.idElset.p) }
  public static func add(idManifold: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idManifold, at: VTOFFSET.idManifold.p) }
  public static func add(idStateVector: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idStateVector, at: VTOFFSET.idStateVector.p) }
  public static func add(esId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: esId, at: VTOFFSET.esId.p) }
  public static func add(epoch: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: epoch, at: VTOFFSET.epoch.p) }
  public static func add(semiMajorAxis: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: semiMajorAxis, def: 0.0, at: VTOFFSET.semiMajorAxis.p) }
  public static func add(eccentricity: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: eccentricity, def: 0.0, at: VTOFFSET.eccentricity.p) }
  public static func add(inclination: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: inclination, def: 0.0, at: VTOFFSET.inclination.p) }
  public static func add(raan: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: raan, def: 0.0, at: VTOFFSET.raan.p) }
  public static func add(argOfPerigee: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: argOfPerigee, def: 0.0, at: VTOFFSET.argOfPerigee.p) }
  public static func add(trueAnomoly: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trueAnomoly, def: 0.0, at: VTOFFSET.trueAnomoly.p) }
  public static func add(ra: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ra, def: 0.0, at: VTOFFSET.ra.p) }
  public static func add(dec: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dec, def: 0.0, at: VTOFFSET.dec.p) }
  public static func add(az: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: az, def: 0.0, at: VTOFFSET.az.p) }
  public static func add(el: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: el, def: 0.0, at: VTOFFSET.el.p) }
  public static func add(range: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: range, def: 0.0, at: VTOFFSET.range.p) }
  public static func add(extentAz: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: extentAz, def: 0.0, at: VTOFFSET.extentAz.p) }
  public static func add(extentEl: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: extentEl, def: 0.0, at: VTOFFSET.extentEl.p) }
  public static func add(extentRange: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: extentRange, def: 0.0, at: VTOFFSET.extentRange.p) }
  public static func add(lat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lat, def: 0.0, at: VTOFFSET.lat.p) }
  public static func add(lon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lon, def: 0.0, at: VTOFFSET.lon.p) }
  public static func add(alt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: alt, def: 0.0, at: VTOFFSET.alt.p) }
  public static func add(stopLat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stopLat, def: 0.0, at: VTOFFSET.stopLat.p) }
  public static func add(stopLon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stopLon, def: 0.0, at: VTOFFSET.stopLon.p) }
  public static func add(stopAlt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stopAlt, def: 0.0, at: VTOFFSET.stopAlt.p) }
  public static func add(srchInc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: srchInc, def: 0.0, at: VTOFFSET.srchInc.p) }
  public static func add(xAngle: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: xAngle, def: 0.0, at: VTOFFSET.xAngle.p) }
  public static func add(yAngle: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: yAngle, def: 0.0, at: VTOFFSET.yAngle.p) }
  public static func add(orientAngle: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: orientAngle, def: 0.0, at: VTOFFSET.orientAngle.p) }
  public static func add(customer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: customer, at: VTOFFSET.customer.p) }
  public static func add(notes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: notes, at: VTOFFSET.notes.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: CollectRequest_Ingest_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(stateVector: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: stateVector, at: VTOFFSET.stateVector.p) }
  public static func add(elset: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: elset, at: VTOFFSET.elset.p) }
  public static func addVectorOf(tags: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tags, at: VTOFFSET.tags.p) }
  public static func endCollectRequest_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCollectRequest_Ingest(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    idParentReqOffset idParentReq: Offset = Offset(),
    msgTypeOffset msgType: Offset = Offset(),
    msgCreateDateOffset msgCreateDate: Offset = Offset(),
    typeOffset type: Offset = Offset(),
    idPlanOffset idPlan: Offset = Offset(),
    planIndex: Int32 = 0,
    taskIdOffset taskId: Offset = Offset(),
    dwellIdOffset dwellId: Offset = Offset(),
    externalIdOffset externalId: Offset = Offset(),
    idSensorOffset idSensor: Offset = Offset(),
    origSensorIdOffset origSensorId: Offset = Offset(),
    obTypeOffset obType: Offset = Offset(),
    priorityOffset priority: Offset = Offset(),
    taskCategory: Int32 = 0,
    suffixOffset suffix: Offset = Offset(),
    uctFollowUp: Bool = false,
    startTimeOffset startTime: Offset = Offset(),
    endTimeOffset endTime: Offset = Offset(),
    idOnOrbitOffset idOnOrbit: Offset = Offset(),
    satNo: Int32 = 0,
    origObjectIdOffset origObjectId: Offset = Offset(),
    taskGroupOffset taskGroup: Offset = Offset(),
    iron: Int32 = 0,
    orbitRegimeOffset orbitRegime: Offset = Offset(),
    targetSize: Double = 0.0,
    rcsMin: Double = 0.0,
    rcs: Double = 0.0,
    rcsMax: Double = 0.0,
    freqMin: Double = 0.0,
    freq: Double = 0.0,
    freqMax: Double = 0.0,
    polarizationOffset polarization: Offset = Offset(),
    visMagMin: Double = 0.0,
    visMag: Double = 0.0,
    visMagMax: Double = 0.0,
    spectralModelOffset spectralModel: Offset = Offset(),
    reflectance: Double = 0.0,
    irradiance: Double = 0.0,
    numFrames: Int32 = 0,
    frameRate: Double = 0.0,
    integrationTime: Double = 0.0,
    numTracks: Int32 = 0,
    numObs: Int32 = 0,
    duration: Int32 = 0,
    srchPatternOffset srchPattern: Offset = Offset(),
    scenarioOffset scenario: Offset = Offset(),
    idElsetOffset idElset: Offset = Offset(),
    idManifoldOffset idManifold: Offset = Offset(),
    idStateVectorOffset idStateVector: Offset = Offset(),
    esIdOffset esId: Offset = Offset(),
    epochOffset epoch: Offset = Offset(),
    semiMajorAxis: Double = 0.0,
    eccentricity: Double = 0.0,
    inclination: Double = 0.0,
    raan: Double = 0.0,
    argOfPerigee: Double = 0.0,
    trueAnomoly: Double = 0.0,
    ra: Double = 0.0,
    dec: Double = 0.0,
    az: Double = 0.0,
    el: Double = 0.0,
    range: Double = 0.0,
    extentAz: Double = 0.0,
    extentEl: Double = 0.0,
    extentRange: Double = 0.0,
    lat: Double = 0.0,
    lon: Double = 0.0,
    alt: Double = 0.0,
    stopLat: Double = 0.0,
    stopLon: Double = 0.0,
    stopAlt: Double = 0.0,
    srchInc: Double = 0.0,
    xAngle: Double = 0.0,
    yAngle: Double = 0.0,
    orientAngle: Double = 0.0,
    customerOffset customer: Offset = Offset(),
    notesOffset notes: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: CollectRequest_Ingest_dataMode_Enum = .real,
    stateVectorOffset stateVector: Offset = Offset(),
    elsetOffset elset: Offset = Offset(),
    tagsVectorOffset tags: Offset = Offset()
  ) -> Offset {
    let __start = CollectRequest_Ingest.startCollectRequest_Ingest(&fbb)
    CollectRequest_Ingest.add(id: id, &fbb)
    CollectRequest_Ingest.add(classificationMarking: classificationMarking, &fbb)
    CollectRequest_Ingest.add(idParentReq: idParentReq, &fbb)
    CollectRequest_Ingest.add(msgType: msgType, &fbb)
    CollectRequest_Ingest.add(msgCreateDate: msgCreateDate, &fbb)
    CollectRequest_Ingest.add(type: type, &fbb)
    CollectRequest_Ingest.add(idPlan: idPlan, &fbb)
    CollectRequest_Ingest.add(planIndex: planIndex, &fbb)
    CollectRequest_Ingest.add(taskId: taskId, &fbb)
    CollectRequest_Ingest.add(dwellId: dwellId, &fbb)
    CollectRequest_Ingest.add(externalId: externalId, &fbb)
    CollectRequest_Ingest.add(idSensor: idSensor, &fbb)
    CollectRequest_Ingest.add(origSensorId: origSensorId, &fbb)
    CollectRequest_Ingest.add(obType: obType, &fbb)
    CollectRequest_Ingest.add(priority: priority, &fbb)
    CollectRequest_Ingest.add(taskCategory: taskCategory, &fbb)
    CollectRequest_Ingest.add(suffix: suffix, &fbb)
    CollectRequest_Ingest.add(uctFollowUp: uctFollowUp, &fbb)
    CollectRequest_Ingest.add(startTime: startTime, &fbb)
    CollectRequest_Ingest.add(endTime: endTime, &fbb)
    CollectRequest_Ingest.add(idOnOrbit: idOnOrbit, &fbb)
    CollectRequest_Ingest.add(satNo: satNo, &fbb)
    CollectRequest_Ingest.add(origObjectId: origObjectId, &fbb)
    CollectRequest_Ingest.add(taskGroup: taskGroup, &fbb)
    CollectRequest_Ingest.add(iron: iron, &fbb)
    CollectRequest_Ingest.add(orbitRegime: orbitRegime, &fbb)
    CollectRequest_Ingest.add(targetSize: targetSize, &fbb)
    CollectRequest_Ingest.add(rcsMin: rcsMin, &fbb)
    CollectRequest_Ingest.add(rcs: rcs, &fbb)
    CollectRequest_Ingest.add(rcsMax: rcsMax, &fbb)
    CollectRequest_Ingest.add(freqMin: freqMin, &fbb)
    CollectRequest_Ingest.add(freq: freq, &fbb)
    CollectRequest_Ingest.add(freqMax: freqMax, &fbb)
    CollectRequest_Ingest.add(polarization: polarization, &fbb)
    CollectRequest_Ingest.add(visMagMin: visMagMin, &fbb)
    CollectRequest_Ingest.add(visMag: visMag, &fbb)
    CollectRequest_Ingest.add(visMagMax: visMagMax, &fbb)
    CollectRequest_Ingest.add(spectralModel: spectralModel, &fbb)
    CollectRequest_Ingest.add(reflectance: reflectance, &fbb)
    CollectRequest_Ingest.add(irradiance: irradiance, &fbb)
    CollectRequest_Ingest.add(numFrames: numFrames, &fbb)
    CollectRequest_Ingest.add(frameRate: frameRate, &fbb)
    CollectRequest_Ingest.add(integrationTime: integrationTime, &fbb)
    CollectRequest_Ingest.add(numTracks: numTracks, &fbb)
    CollectRequest_Ingest.add(numObs: numObs, &fbb)
    CollectRequest_Ingest.add(duration: duration, &fbb)
    CollectRequest_Ingest.add(srchPattern: srchPattern, &fbb)
    CollectRequest_Ingest.add(scenario: scenario, &fbb)
    CollectRequest_Ingest.add(idElset: idElset, &fbb)
    CollectRequest_Ingest.add(idManifold: idManifold, &fbb)
    CollectRequest_Ingest.add(idStateVector: idStateVector, &fbb)
    CollectRequest_Ingest.add(esId: esId, &fbb)
    CollectRequest_Ingest.add(epoch: epoch, &fbb)
    CollectRequest_Ingest.add(semiMajorAxis: semiMajorAxis, &fbb)
    CollectRequest_Ingest.add(eccentricity: eccentricity, &fbb)
    CollectRequest_Ingest.add(inclination: inclination, &fbb)
    CollectRequest_Ingest.add(raan: raan, &fbb)
    CollectRequest_Ingest.add(argOfPerigee: argOfPerigee, &fbb)
    CollectRequest_Ingest.add(trueAnomoly: trueAnomoly, &fbb)
    CollectRequest_Ingest.add(ra: ra, &fbb)
    CollectRequest_Ingest.add(dec: dec, &fbb)
    CollectRequest_Ingest.add(az: az, &fbb)
    CollectRequest_Ingest.add(el: el, &fbb)
    CollectRequest_Ingest.add(range: range, &fbb)
    CollectRequest_Ingest.add(extentAz: extentAz, &fbb)
    CollectRequest_Ingest.add(extentEl: extentEl, &fbb)
    CollectRequest_Ingest.add(extentRange: extentRange, &fbb)
    CollectRequest_Ingest.add(lat: lat, &fbb)
    CollectRequest_Ingest.add(lon: lon, &fbb)
    CollectRequest_Ingest.add(alt: alt, &fbb)
    CollectRequest_Ingest.add(stopLat: stopLat, &fbb)
    CollectRequest_Ingest.add(stopLon: stopLon, &fbb)
    CollectRequest_Ingest.add(stopAlt: stopAlt, &fbb)
    CollectRequest_Ingest.add(srchInc: srchInc, &fbb)
    CollectRequest_Ingest.add(xAngle: xAngle, &fbb)
    CollectRequest_Ingest.add(yAngle: yAngle, &fbb)
    CollectRequest_Ingest.add(orientAngle: orientAngle, &fbb)
    CollectRequest_Ingest.add(customer: customer, &fbb)
    CollectRequest_Ingest.add(notes: notes, &fbb)
    CollectRequest_Ingest.add(createdAt: createdAt, &fbb)
    CollectRequest_Ingest.add(createdBy: createdBy, &fbb)
    CollectRequest_Ingest.add(source: source, &fbb)
    CollectRequest_Ingest.add(origin: origin, &fbb)
    CollectRequest_Ingest.add(origNetwork: origNetwork, &fbb)
    CollectRequest_Ingest.add(dataMode: dataMode, &fbb)
    CollectRequest_Ingest.add(stateVector: stateVector, &fbb)
    CollectRequest_Ingest.add(elset: elset, &fbb)
    CollectRequest_Ingest.addVectorOf(tags: tags, &fbb)
    return CollectRequest_Ingest.endCollectRequest_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idParentReq.p, fieldName: "idParentReq", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msgType.p, fieldName: "msgType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.msgCreateDate.p, fieldName: "msgCreateDate", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idPlan.p, fieldName: "idPlan", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.planIndex.p, fieldName: "planIndex", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.taskId.p, fieldName: "taskId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dwellId.p, fieldName: "dwellId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.externalId.p, fieldName: "externalId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idSensor.p, fieldName: "idSensor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origSensorId.p, fieldName: "origSensorId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.obType.p, fieldName: "obType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.priority.p, fieldName: "priority", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.taskCategory.p, fieldName: "taskCategory", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.suffix.p, fieldName: "suffix", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.uctFollowUp.p, fieldName: "uctFollowUp", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.startTime.p, fieldName: "startTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.endTime.p, fieldName: "endTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idOnOrbit.p, fieldName: "idOnOrbit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.satNo.p, fieldName: "satNo", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.origObjectId.p, fieldName: "origObjectId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.taskGroup.p, fieldName: "taskGroup", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.iron.p, fieldName: "iron", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.orbitRegime.p, fieldName: "orbitRegime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.targetSize.p, fieldName: "targetSize", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.rcsMin.p, fieldName: "rcsMin", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.rcs.p, fieldName: "rcs", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.rcsMax.p, fieldName: "rcsMax", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.freqMin.p, fieldName: "freqMin", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.freq.p, fieldName: "freq", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.freqMax.p, fieldName: "freqMax", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.polarization.p, fieldName: "polarization", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.visMagMin.p, fieldName: "visMagMin", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.visMag.p, fieldName: "visMag", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.visMagMax.p, fieldName: "visMagMax", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.spectralModel.p, fieldName: "spectralModel", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.reflectance.p, fieldName: "reflectance", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.irradiance.p, fieldName: "irradiance", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.numFrames.p, fieldName: "numFrames", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.frameRate.p, fieldName: "frameRate", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.integrationTime.p, fieldName: "integrationTime", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.numTracks.p, fieldName: "numTracks", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.numObs.p, fieldName: "numObs", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.duration.p, fieldName: "duration", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.srchPattern.p, fieldName: "srchPattern", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.scenario.p, fieldName: "scenario", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idElset.p, fieldName: "idElset", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idManifold.p, fieldName: "idManifold", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idStateVector.p, fieldName: "idStateVector", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.esId.p, fieldName: "esId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.epoch.p, fieldName: "epoch", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.semiMajorAxis.p, fieldName: "semiMajorAxis", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.eccentricity.p, fieldName: "eccentricity", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.inclination.p, fieldName: "inclination", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.raan.p, fieldName: "raan", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.argOfPerigee.p, fieldName: "argOfPerigee", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.trueAnomoly.p, fieldName: "trueAnomoly", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ra.p, fieldName: "ra", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.dec.p, fieldName: "dec", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.az.p, fieldName: "az", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.el.p, fieldName: "el", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.range.p, fieldName: "range", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.extentAz.p, fieldName: "extentAz", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.extentEl.p, fieldName: "extentEl", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.extentRange.p, fieldName: "extentRange", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.lat.p, fieldName: "lat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.lon.p, fieldName: "lon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.alt.p, fieldName: "alt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.stopLat.p, fieldName: "stopLat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.stopLon.p, fieldName: "stopLon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.stopAlt.p, fieldName: "stopAlt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.srchInc.p, fieldName: "srchInc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.xAngle.p, fieldName: "xAngle", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.yAngle.p, fieldName: "yAngle", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.orientAngle.p, fieldName: "orientAngle", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.customer.p, fieldName: "customer", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.notes.p, fieldName: "notes", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: CollectRequest_Ingest_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.stateVector.p, fieldName: "stateVector", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.elset.p, fieldName: "elset", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.tags.p, fieldName: "tags", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

