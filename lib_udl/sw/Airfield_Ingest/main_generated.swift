// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Airfield_Ingest_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: Airfield_Ingest_dataMode_Enum { return .exercise }
  public static var min: Airfield_Ingest_dataMode_Enum { return .real }
}


///  /// Properties and characteristics of an airfield, which includes location, airfield codes, suitability codes, and remarks.
public struct Airfield_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "AIRF" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Airfield_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case idSite = 8
    case altAirfieldId = 10
    case wacInnr = 12
    case zarId = 14
    case icao = 16
    case iata = 18
    case faa = 20
    case hostNatCode = 22
    case name = 24
    case type = 26
    case lat = 28
    case lon = 30
    case elevFt = 32
    case elevM = 34
    case magDec = 36
    case regionName = 38
    case countryCode = 40
    case city = 42
    case state = 44
    case geoloc = 46
    case gmtOffset = 48
    case suitabilityCodes = 50
    case miscCodes = 52
    case runways = 54
    case maxRunwayLength = 56
    case infoUrl = 58
    case createdAt = 60
    case createdBy = 62
    case sourceDl = 64
    case source = 66
    case origin = 68
    case origNetwork = 70
    case dataMode = 72
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: 3f28f60b-3a50-2aef-ac88-8e9d0e39912b
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  The ID of the parent site.
  ///  Example: /// Example: a150b3ee-884b-b9ac-60a0-6408b4b16088
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idSite: String? { let o = _accessor.offset(VTOFFSET.idSite.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSiteSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSite.v) }
  ///  Alternate Airfield identifier provided by source.
  ///  Example: /// Example: 45301
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var altAirfieldId: String? { let o = _accessor.offset(VTOFFSET.altAirfieldId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var altAirfieldIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.altAirfieldId.v) }
  ///  The airfield's World Area Code installation number (WAC-INNR).
  ///  Example: /// Example: 0409-00039
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var wacInnr: String? { let o = _accessor.offset(VTOFFSET.wacInnr.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var wacInnrSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.wacInnr.v) }
  ///  Air Mobility Command (AMC) Zone availability Report identifier.
  ///  Example: /// Example: 231
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var zarId: String? { let o = _accessor.offset(VTOFFSET.zarId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var zarIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.zarId.v) }
  ///  The International Civil Aviation Organization (ICAO) code of the airfield.
  ///  Example: /// Example: KCOS
  ///  Constraints: Minimum length = 0, Maximum length = 4
  public var icao: String? { let o = _accessor.offset(VTOFFSET.icao.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var icaoSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.icao.v) }
  ///  The International Aviation Transport Association (IATA) code of the airfield.
  ///  Example: /// Example: AAA
  ///  Constraints: Minimum length = 0, Maximum length = 3
  public var iata: String? { let o = _accessor.offset(VTOFFSET.iata.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var iataSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.iata.v) }
  ///  The Federal Aviation Administration (FAA) location identifier of this airfield.
  ///  Example: /// Example: FAA1
  ///  Constraints: Minimum length = 0, Maximum length = 5
  public var faa: String? { let o = _accessor.offset(VTOFFSET.faa.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var faaSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.faa.v) }
  ///  The host nation code of this airfield, used for non-DoD/FAA locations.
  ///  Example: /// Example: ZPU
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var hostNatCode: String? { let o = _accessor.offset(VTOFFSET.hostNatCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var hostNatCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.hostNatCode.v) }
  ///  The name of the airfield.
  ///  Example: /// Example: USAF Academy AFLD
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  ///  The airfield activity use type (e.g. Commercial, Airport, Heliport, Gliderport, etc.).
  ///  Example: /// Example: Commercial
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  ///  WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 45.23
  ///  Constraints: No constraints specified.
  public var lat: Double { let o = _accessor.offset(VTOFFSET.lat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 179.1
  ///  Constraints: No constraints specified.
  public var lon: Double { let o = _accessor.offset(VTOFFSET.lon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Elevation of the airfield above mean sea level, in feet.
  ///  Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 33.562
  ///  Constraints: No constraints specified.
  public var elevFt: Double { let o = _accessor.offset(VTOFFSET.elevFt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Elevation of the airfield above mean sea level, in meters.
  ///  Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  ///  Example: /// Example: 10.29
  ///  Constraints: No constraints specified.
  public var elevM: Double { let o = _accessor.offset(VTOFFSET.elevM.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The magnetic declination/variation of the airfield's location from true north, in degrees.  Positive values east of true north and negative values west of true north.
  ///  Example: /// Example: 7.35
  ///  Constraints: No constraints specified.
  public var magDec: Double { let o = _accessor.offset(VTOFFSET.magDec.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Region where the airfield resides.
  ///  Example: /// Example: North America
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var regionName: String? { let o = _accessor.offset(VTOFFSET.regionName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var regionNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.regionName.v) }
  ///  The country code. This value is typically the ISO 3166 Alpha-2 two-character country code, however it can also represent various consortiums that do not appear in the ISO document. The code must correspond to an existing country in the UDLâ€™s country API. Call udl/country/{code} to get any associated FIPS code, ISO Alpha-3 code, or alternate code values that exist for the specified country code.
  ///  Example: /// Example: US
  ///  Constraints: Minimum length = 0, Maximum length = 4
  public var countryCode: String? { let o = _accessor.offset(VTOFFSET.countryCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var countryCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.countryCode.v) }
  ///  Closest city to the airfield's location.
  ///  Example: /// Example: Colorado Springs
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var city: String? { let o = _accessor.offset(VTOFFSET.city.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var citySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.city.v) }
  ///  State or province of the airfield's location.
  ///  Example: /// Example: Colorado
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var state: String? { let o = _accessor.offset(VTOFFSET.state.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var stateSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.state.v) }
  ///  Air Force geographic location code of the airfield.
  ///  Example: /// Example: XLSX
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var geoloc: String? { let o = _accessor.offset(VTOFFSET.geoloc.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var geolocSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.geoloc.v) }
  ///  Time difference between the location of the airfield and the Greenwich Mean Time (GMT), expressed as +/-HH:MM. Time zones east of Greenwich have positive offsets and time zones west of Greenwich are negative.
  ///  Example: /// Example: -4:30
  ///  Constraints: Minimum length = 0, Maximum length = 6
  public var gmtOffset: String? { let o = _accessor.offset(VTOFFSET.gmtOffset.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var gmtOffsetSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.gmtOffset.v) }
  ///  Associated suitability codes according to the Airfield Suitability and Restrictions Report (ASRR) for this airfield.
  ///  Example: /// Example: ABCDEF
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var suitabilityCodes: String? { let o = _accessor.offset(VTOFFSET.suitabilityCodes.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var suitabilityCodesSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.suitabilityCodes.v) }
  ///  Applicable miscellaneous codes according to the Airfield Suitability and Restrictions Report (ASRR) for this airfield.
  ///  Example: /// Example: AMZ
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var miscCodes: String? { let o = _accessor.offset(VTOFFSET.miscCodes.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var miscCodesSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.miscCodes.v) }
  ///  The number of runways at the site.
  ///  Example: /// Example: 5
  ///  Constraints: No constraints specified.
  public var runways: Int32 { let o = _accessor.offset(VTOFFSET.runways.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The length of the longest runway at this airfield in feet.
  ///  Example: /// Example: 1000
  ///  Constraints: No constraints specified.
  public var maxRunwayLength: Int32 { let o = _accessor.offset(VTOFFSET.maxRunwayLength.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The URL link to information about airfield.
  ///  Example: /// Example: URL Link to the Airfield
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var infoUrl: String? { let o = _accessor.offset(VTOFFSET.infoUrl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var infoUrlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.infoUrl.v) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2022-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  ///  Example: /// Example: AXE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var sourceDl: String? { let o = _accessor.offset(VTOFFSET.sourceDl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceDlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceDl.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: OPS1
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: Airfield_Ingest_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : Airfield_Ingest_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  public static func startAirfield_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 35) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(idSite: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSite, at: VTOFFSET.idSite.p) }
  public static func add(altAirfieldId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: altAirfieldId, at: VTOFFSET.altAirfieldId.p) }
  public static func add(wacInnr: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: wacInnr, at: VTOFFSET.wacInnr.p) }
  public static func add(zarId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: zarId, at: VTOFFSET.zarId.p) }
  public static func add(icao: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: icao, at: VTOFFSET.icao.p) }
  public static func add(iata: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: iata, at: VTOFFSET.iata.p) }
  public static func add(faa: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: faa, at: VTOFFSET.faa.p) }
  public static func add(hostNatCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: hostNatCode, at: VTOFFSET.hostNatCode.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func add(lat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lat, def: 0.0, at: VTOFFSET.lat.p) }
  public static func add(lon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lon, def: 0.0, at: VTOFFSET.lon.p) }
  public static func add(elevFt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: elevFt, def: 0.0, at: VTOFFSET.elevFt.p) }
  public static func add(elevM: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: elevM, def: 0.0, at: VTOFFSET.elevM.p) }
  public static func add(magDec: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: magDec, def: 0.0, at: VTOFFSET.magDec.p) }
  public static func add(regionName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: regionName, at: VTOFFSET.regionName.p) }
  public static func add(countryCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: countryCode, at: VTOFFSET.countryCode.p) }
  public static func add(city: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: city, at: VTOFFSET.city.p) }
  public static func add(state: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: state, at: VTOFFSET.state.p) }
  public static func add(geoloc: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: geoloc, at: VTOFFSET.geoloc.p) }
  public static func add(gmtOffset: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: gmtOffset, at: VTOFFSET.gmtOffset.p) }
  public static func add(suitabilityCodes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: suitabilityCodes, at: VTOFFSET.suitabilityCodes.p) }
  public static func add(miscCodes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: miscCodes, at: VTOFFSET.miscCodes.p) }
  public static func add(runways: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: runways, def: 0, at: VTOFFSET.runways.p) }
  public static func add(maxRunwayLength: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maxRunwayLength, def: 0, at: VTOFFSET.maxRunwayLength.p) }
  public static func add(infoUrl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: infoUrl, at: VTOFFSET.infoUrl.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(sourceDl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceDl, at: VTOFFSET.sourceDl.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: Airfield_Ingest_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func endAirfield_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAirfield_Ingest(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    idSiteOffset idSite: Offset = Offset(),
    altAirfieldIdOffset altAirfieldId: Offset = Offset(),
    wacInnrOffset wacInnr: Offset = Offset(),
    zarIdOffset zarId: Offset = Offset(),
    icaoOffset icao: Offset = Offset(),
    iataOffset iata: Offset = Offset(),
    faaOffset faa: Offset = Offset(),
    hostNatCodeOffset hostNatCode: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    typeOffset type: Offset = Offset(),
    lat: Double = 0.0,
    lon: Double = 0.0,
    elevFt: Double = 0.0,
    elevM: Double = 0.0,
    magDec: Double = 0.0,
    regionNameOffset regionName: Offset = Offset(),
    countryCodeOffset countryCode: Offset = Offset(),
    cityOffset city: Offset = Offset(),
    stateOffset state: Offset = Offset(),
    geolocOffset geoloc: Offset = Offset(),
    gmtOffsetOffset gmtOffset: Offset = Offset(),
    suitabilityCodesOffset suitabilityCodes: Offset = Offset(),
    miscCodesOffset miscCodes: Offset = Offset(),
    runways: Int32 = 0,
    maxRunwayLength: Int32 = 0,
    infoUrlOffset infoUrl: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceDlOffset sourceDl: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: Airfield_Ingest_dataMode_Enum = .real
  ) -> Offset {
    let __start = Airfield_Ingest.startAirfield_Ingest(&fbb)
    Airfield_Ingest.add(id: id, &fbb)
    Airfield_Ingest.add(classificationMarking: classificationMarking, &fbb)
    Airfield_Ingest.add(idSite: idSite, &fbb)
    Airfield_Ingest.add(altAirfieldId: altAirfieldId, &fbb)
    Airfield_Ingest.add(wacInnr: wacInnr, &fbb)
    Airfield_Ingest.add(zarId: zarId, &fbb)
    Airfield_Ingest.add(icao: icao, &fbb)
    Airfield_Ingest.add(iata: iata, &fbb)
    Airfield_Ingest.add(faa: faa, &fbb)
    Airfield_Ingest.add(hostNatCode: hostNatCode, &fbb)
    Airfield_Ingest.add(name: name, &fbb)
    Airfield_Ingest.add(type: type, &fbb)
    Airfield_Ingest.add(lat: lat, &fbb)
    Airfield_Ingest.add(lon: lon, &fbb)
    Airfield_Ingest.add(elevFt: elevFt, &fbb)
    Airfield_Ingest.add(elevM: elevM, &fbb)
    Airfield_Ingest.add(magDec: magDec, &fbb)
    Airfield_Ingest.add(regionName: regionName, &fbb)
    Airfield_Ingest.add(countryCode: countryCode, &fbb)
    Airfield_Ingest.add(city: city, &fbb)
    Airfield_Ingest.add(state: state, &fbb)
    Airfield_Ingest.add(geoloc: geoloc, &fbb)
    Airfield_Ingest.add(gmtOffset: gmtOffset, &fbb)
    Airfield_Ingest.add(suitabilityCodes: suitabilityCodes, &fbb)
    Airfield_Ingest.add(miscCodes: miscCodes, &fbb)
    Airfield_Ingest.add(runways: runways, &fbb)
    Airfield_Ingest.add(maxRunwayLength: maxRunwayLength, &fbb)
    Airfield_Ingest.add(infoUrl: infoUrl, &fbb)
    Airfield_Ingest.add(createdAt: createdAt, &fbb)
    Airfield_Ingest.add(createdBy: createdBy, &fbb)
    Airfield_Ingest.add(sourceDl: sourceDl, &fbb)
    Airfield_Ingest.add(source: source, &fbb)
    Airfield_Ingest.add(origin: origin, &fbb)
    Airfield_Ingest.add(origNetwork: origNetwork, &fbb)
    Airfield_Ingest.add(dataMode: dataMode, &fbb)
    return Airfield_Ingest.endAirfield_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idSite.p, fieldName: "idSite", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.altAirfieldId.p, fieldName: "altAirfieldId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.wacInnr.p, fieldName: "wacInnr", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.zarId.p, fieldName: "zarId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.icao.p, fieldName: "icao", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.iata.p, fieldName: "iata", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.faa.p, fieldName: "faa", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.hostNatCode.p, fieldName: "hostNatCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.lat.p, fieldName: "lat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.lon.p, fieldName: "lon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.elevFt.p, fieldName: "elevFt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.elevM.p, fieldName: "elevM", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.magDec.p, fieldName: "magDec", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.regionName.p, fieldName: "regionName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.countryCode.p, fieldName: "countryCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.city.p, fieldName: "city", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.state.p, fieldName: "state", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.geoloc.p, fieldName: "geoloc", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.gmtOffset.p, fieldName: "gmtOffset", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.suitabilityCodes.p, fieldName: "suitabilityCodes", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.miscCodes.p, fieldName: "miscCodes", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.runways.p, fieldName: "runways", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.maxRunwayLength.p, fieldName: "maxRunwayLength", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.infoUrl.p, fieldName: "infoUrl", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceDl.p, fieldName: "sourceDl", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: Airfield_Ingest_dataMode_Enum.self)
    _v.finish()
  }
}

