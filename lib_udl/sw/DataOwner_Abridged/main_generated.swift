// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  /// Information pertaining to UDL data owners.
public struct DataOwner_Abridged: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "DATA" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: DataOwner_Abridged.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case doName = 4
    case classificationMarking = 6
    case ownerType = 8
    case dataType = 10
    case provider = 12
    case countryCode = 14
    case idContact = 16
    case description = 18
    case control = 20
    case enabled = 22
    case comingSoon = 24
    case source = 26
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The name of the data owner.
  ///  Example: /// Example: Data owner name
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var doName: String? { let o = _accessor.offset(VTOFFSET.doName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var doNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.doName.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Type of organization which this data owner belongs to (e.g. Commercial, Government, Academic, Consortium, etc.).
  ///  Example: /// Example: Commercial
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var ownerType: String? { let o = _accessor.offset(VTOFFSET.ownerType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ownerTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ownerType.v) }
  ///  Type of data this data owner owns (e.g. EPHEMERIS, IMAGERY, MANEUVER, etc.).
  ///  Example: /// Example: ELSET
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var dataType: String? { let o = _accessor.offset(VTOFFSET.dataType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var dataTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.dataType.v) }
  ///  Organization name for the data provider.
  ///  Example: /// Example: ACME
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var provider: String? { let o = _accessor.offset(VTOFFSET.provider.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var providerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.provider.v) }
  ///  The country code. This value is typically the ISO 3166 Alpha-2 two-character country code, however it can also represent various consortiums that do not appear in the ISO document. The code must correspond to an existing country in the UDLâ€™s country API. Call udl/country/{code} to get any associated FIPS code, ISO Alpha-3 code, or alternate code values that exist for the specified country code.
  ///  Example: /// Example: US
  ///  Constraints: Minimum length = 1, Maximum length = 4
  public var countryCode: String? { let o = _accessor.offset(VTOFFSET.countryCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var countryCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.countryCode.v) }
  ///  Unique identifier of the contact for this data owner.
  ///  Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var idContact: String? { let o = _accessor.offset(VTOFFSET.idContact.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idContactSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idContact.v) }
  ///  Description of this data owner.
  ///  Example: /// Example: Description of this data owner.
  ///  Constraints: No constraints specified.
  public var description: String? { let o = _accessor.offset(VTOFFSET.description.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.description.v) }
  ///  Optional control required to access this data type from this owner.
  ///  Example: /// Example: PR-ACME-ELSETS
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var control: String? { let o = _accessor.offset(VTOFFSET.control.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var controlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.control.v) }
  ///  Boolean indicating if the data owner is enabled (if not enabled, they should not appear on the data products screen on the storefront).
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var enabled: Bool { let o = _accessor.offset(VTOFFSET.enabled.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Boolean indicating if the data owner is coming soon or not yet available.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var comingSoon: Bool { let o = _accessor.offset(VTOFFSET.comingSoon.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Source of the data.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  public static func startDataOwner_Abridged(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 12) }
  public static func add(doName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: doName, at: VTOFFSET.doName.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(ownerType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ownerType, at: VTOFFSET.ownerType.p) }
  public static func add(dataType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dataType, at: VTOFFSET.dataType.p) }
  public static func add(provider: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: provider, at: VTOFFSET.provider.p) }
  public static func add(countryCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: countryCode, at: VTOFFSET.countryCode.p) }
  public static func add(idContact: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idContact, at: VTOFFSET.idContact.p) }
  public static func add(description: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: description, at: VTOFFSET.description.p) }
  public static func add(control: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: control, at: VTOFFSET.control.p) }
  public static func add(enabled: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: enabled, def: false,
   at: VTOFFSET.enabled.p) }
  public static func add(comingSoon: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: comingSoon, def: false,
   at: VTOFFSET.comingSoon.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func endDataOwner_Abridged(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createDataOwner_Abridged(
    _ fbb: inout FlatBufferBuilder,
    doNameOffset doName: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    ownerTypeOffset ownerType: Offset = Offset(),
    dataTypeOffset dataType: Offset = Offset(),
    providerOffset provider: Offset = Offset(),
    countryCodeOffset countryCode: Offset = Offset(),
    idContactOffset idContact: Offset = Offset(),
    descriptionOffset description: Offset = Offset(),
    controlOffset control: Offset = Offset(),
    enabled: Bool = false,
    comingSoon: Bool = false,
    sourceOffset source: Offset = Offset()
  ) -> Offset {
    let __start = DataOwner_Abridged.startDataOwner_Abridged(&fbb)
    DataOwner_Abridged.add(doName: doName, &fbb)
    DataOwner_Abridged.add(classificationMarking: classificationMarking, &fbb)
    DataOwner_Abridged.add(ownerType: ownerType, &fbb)
    DataOwner_Abridged.add(dataType: dataType, &fbb)
    DataOwner_Abridged.add(provider: provider, &fbb)
    DataOwner_Abridged.add(countryCode: countryCode, &fbb)
    DataOwner_Abridged.add(idContact: idContact, &fbb)
    DataOwner_Abridged.add(description: description, &fbb)
    DataOwner_Abridged.add(control: control, &fbb)
    DataOwner_Abridged.add(enabled: enabled, &fbb)
    DataOwner_Abridged.add(comingSoon: comingSoon, &fbb)
    DataOwner_Abridged.add(source: source, &fbb)
    return DataOwner_Abridged.endDataOwner_Abridged(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.doName.p, fieldName: "doName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ownerType.p, fieldName: "ownerType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataType.p, fieldName: "dataType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.provider.p, fieldName: "provider", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.countryCode.p, fieldName: "countryCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idContact.p, fieldName: "idContact", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.description.p, fieldName: "description", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.control.p, fieldName: "control", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.enabled.p, fieldName: "enabled", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.comingSoon.p, fieldName: "comingSoon", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

