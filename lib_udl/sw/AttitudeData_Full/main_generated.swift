// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum AttitudeData_Full_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: AttitudeData_Full_dataMode_Enum { return .exercise }
  public static var min: AttitudeData_Full_dataMode_Enum { return .real }
}


///  /// These services provide operations for posting and querying attitude of on-orbit objects.  Attitude describes the orientation of an object, which can be represented by quaternions or euler angles.  The AttitudeSet ID (asId) identifies the 'AttitudeSet' record which contains details of the underlying data as well as a collection of attitude points. Points must be retrieved by first identifying a desired AttitudeSet and pulling its points by that AttitudeSet ID 'asId'.
public struct AttitudeData_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "ATTI" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AttitudeData_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case asId = 8
    case idOnOrbit = 10
    case satNo = 12
    case origObjectId = 14
    case ts = 16
    case motionType = 18
    case q1 = 20
    case q2 = 22
    case q3 = 24
    case qc = 26
    case q1Dot = 28
    case q2Dot = 30
    case q3Dot = 32
    case qcDot = 34
    case xAngle = 36
    case yAngle = 38
    case zAngle = 40
    case xRate = 42
    case yRate = 44
    case zRate = 46
    case ra = 48
    case declination = 50
    case coningAngle = 52
    case precPeriod = 54
    case spinPeriod = 56
    case createdAt = 58
    case createdBy = 60
    case source = 62
    case origin = 64
    case dataMode = 66
    case origNetwork = 68
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: ATTITUDEDATA-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Unique identifier of the parent AttitudeSet associated with this record.
  ///  Example: /// Example: 773c9887-e931-42eb-8155-f0fbd227b235
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var asId: String? { let o = _accessor.offset(VTOFFSET.asId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var asIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.asId.v) }
  ///  Unique identifier of the on-orbit satellite to which this attitude record applies.
  ///  Example: /// Example: 41947
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idOnOrbit: String? { let o = _accessor.offset(VTOFFSET.idOnOrbit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idOnOrbitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idOnOrbit.v) }
  ///  Satellite/catalog number of the on-orbit object to which this attitude record applies.
  ///  Example: /// Example: 41947
  ///  Constraints: No constraints specified.
  public var satNo: Int32 { let o = _accessor.offset(VTOFFSET.satNo.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Optional identifier provided by the record source to indicate the target object of this attitude record. This may be an internal identifier and not necessarily map to a valid satellite number.
  ///  Example: /// Example: D6593
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var origObjectId: String? { let o = _accessor.offset(VTOFFSET.origObjectId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origObjectIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origObjectId.v) }
  ///  Time associated with this attitude record, in ISO 8601 UTC format, with microsecond precision.
  ///  Example: /// Example: 2022-03-07T14:51:39.653043Z
  ///  Constraints: No constraints specified.
  public var ts: String? { let o = _accessor.offset(VTOFFSET.ts.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var tsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ts.v) }
  ///  Label specifying type of rotational motion of target.
  ///  Example: /// Example: PROSOL_MOTION
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var motionType: String? { let o = _accessor.offset(VTOFFSET.motionType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var motionTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.motionType.v) }
  ///  Quaternion vector component 1.
  ///  Example: /// Example: 0.0312
  ///  Constraints: No constraints specified.
  public var q1: Double { let o = _accessor.offset(VTOFFSET.q1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Quaternion vector component 2.
  ///  Example: /// Example: 0.7854
  ///  Constraints: No constraints specified.
  public var q2: Double { let o = _accessor.offset(VTOFFSET.q2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Quaternion vector component 3.
  ///  Example: /// Example: 0.3916
  ///  Constraints: No constraints specified.
  public var q3: Double { let o = _accessor.offset(VTOFFSET.q3.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Quaternion scalar component.
  ///  Example: /// Example: 0.4783
  ///  Constraints: No constraints specified.
  public var qc: Double { let o = _accessor.offset(VTOFFSET.qc.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Derivative of quaternion vector component 1.
  ///  Example: /// Example: 0.0043
  ///  Constraints: No constraints specified.
  public var q1Dot: Double { let o = _accessor.offset(VTOFFSET.q1Dot.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Derivative of quaternion vector component 2.
  ///  Example: /// Example: 0.06
  ///  Constraints: No constraints specified.
  public var q2Dot: Double { let o = _accessor.offset(VTOFFSET.q2Dot.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Derivative of quaternion vector component 3.
  ///  Example: /// Example: 0.499
  ///  Constraints: No constraints specified.
  public var q3Dot: Double { let o = _accessor.offset(VTOFFSET.q3Dot.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Derivative of quaternion scalar component.
  ///  Example: /// Example: 0.011
  ///  Constraints: No constraints specified.
  public var qcDot: Double { let o = _accessor.offset(VTOFFSET.qcDot.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Array of X body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
  ///  Example: /// Example: [139.753]
  ///  Constraints: No constraints specified.
  public var hasXAngle: Bool { let o = _accessor.offset(VTOFFSET.xAngle.v); return o == 0 ? false : true }
  public var xAngleCount: Int32 { let o = _accessor.offset(VTOFFSET.xAngle.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func xAngle(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.xAngle.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of Y body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
  ///  Example: /// Example: [25.066]
  ///  Constraints: No constraints specified.
  public var hasYAngle: Bool { let o = _accessor.offset(VTOFFSET.yAngle.v); return o == 0 ? false : true }
  public var yAngleCount: Int32 { let o = _accessor.offset(VTOFFSET.yAngle.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func yAngle(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.yAngle.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of Z body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
  ///  Example: /// Example: [-53.368]
  ///  Constraints: No constraints specified.
  public var hasZAngle: Bool { let o = _accessor.offset(VTOFFSET.zAngle.v); return o == 0 ? false : true }
  public var zAngleCount: Int32 { let o = _accessor.offset(VTOFFSET.zAngle.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func zAngle(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.zAngle.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of X body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
  ///  Example: /// Example: [0.105]
  ///  Constraints: No constraints specified.
  public var hasXRate: Bool { let o = _accessor.offset(VTOFFSET.xRate.v); return o == 0 ? false : true }
  public var xRateCount: Int32 { let o = _accessor.offset(VTOFFSET.xRate.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func xRate(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.xRate.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of Y body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
  ///  Example: /// Example: [0.032]
  ///  Constraints: No constraints specified.
  public var hasYRate: Bool { let o = _accessor.offset(VTOFFSET.yRate.v); return o == 0 ? false : true }
  public var yRateCount: Int32 { let o = _accessor.offset(VTOFFSET.yRate.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func yRate(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.yRate.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Array of Z body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence  Attitude rates are expressed in frame1 with respect to frame2.
  ///  Example: /// Example: [0.022]
  ///  Constraints: No constraints specified.
  public var hasZRate: Bool { let o = _accessor.offset(VTOFFSET.zRate.v); return o == 0 ? false : true }
  public var zRateCount: Int32 { let o = _accessor.offset(VTOFFSET.zRate.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func zRate(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.zRate.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Precession axis right ascension (ECI J2000 frame) in degrees.
  ///  Example: /// Example: -173.75
  ///  Constraints: No constraints specified.
  public var ra: Double { let o = _accessor.offset(VTOFFSET.ra.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Precession axis declination (ECI J2000 frame) in degrees.
  ///  Example: /// Example: 0.799
  ///  Constraints: No constraints specified.
  public var declination: Double { let o = _accessor.offset(VTOFFSET.declination.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Coning angle in degrees.
  ///  Example: /// Example: 0.1
  ///  Constraints: No constraints specified.
  public var coningAngle: Double { let o = _accessor.offset(VTOFFSET.coningAngle.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Precession period in seconds.
  ///  Example: /// Example: 36.1
  ///  Constraints: No constraints specified.
  public var precPeriod: Double { let o = _accessor.offset(VTOFFSET.precPeriod.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Spin period in seconds.
  ///  Example: /// Example: 0.1
  ///  Constraints: No constraints specified.
  public var spinPeriod: Double { let o = _accessor.offset(VTOFFSET.spinPeriod.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2022-07-05T12:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: AttitudeData_Full_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : AttitudeData_Full_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  public static func startAttitudeData_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 33) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(asId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: asId, at: VTOFFSET.asId.p) }
  public static func add(idOnOrbit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idOnOrbit, at: VTOFFSET.idOnOrbit.p) }
  public static func add(satNo: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: satNo, def: 0, at: VTOFFSET.satNo.p) }
  public static func add(origObjectId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origObjectId, at: VTOFFSET.origObjectId.p) }
  public static func add(ts: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ts, at: VTOFFSET.ts.p) }
  public static func add(motionType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: motionType, at: VTOFFSET.motionType.p) }
  public static func add(q1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: q1, def: 0.0, at: VTOFFSET.q1.p) }
  public static func add(q2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: q2, def: 0.0, at: VTOFFSET.q2.p) }
  public static func add(q3: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: q3, def: 0.0, at: VTOFFSET.q3.p) }
  public static func add(qc: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: qc, def: 0.0, at: VTOFFSET.qc.p) }
  public static func add(q1Dot: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: q1Dot, def: 0.0, at: VTOFFSET.q1Dot.p) }
  public static func add(q2Dot: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: q2Dot, def: 0.0, at: VTOFFSET.q2Dot.p) }
  public static func add(q3Dot: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: q3Dot, def: 0.0, at: VTOFFSET.q3Dot.p) }
  public static func add(qcDot: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: qcDot, def: 0.0, at: VTOFFSET.qcDot.p) }
  public static func addVectorOf(xAngle: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: xAngle, at: VTOFFSET.xAngle.p) }
  public static func addVectorOf(yAngle: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: yAngle, at: VTOFFSET.yAngle.p) }
  public static func addVectorOf(zAngle: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: zAngle, at: VTOFFSET.zAngle.p) }
  public static func addVectorOf(xRate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: xRate, at: VTOFFSET.xRate.p) }
  public static func addVectorOf(yRate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: yRate, at: VTOFFSET.yRate.p) }
  public static func addVectorOf(zRate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: zRate, at: VTOFFSET.zRate.p) }
  public static func add(ra: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ra, def: 0.0, at: VTOFFSET.ra.p) }
  public static func add(declination: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: declination, def: 0.0, at: VTOFFSET.declination.p) }
  public static func add(coningAngle: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: coningAngle, def: 0.0, at: VTOFFSET.coningAngle.p) }
  public static func add(precPeriod: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: precPeriod, def: 0.0, at: VTOFFSET.precPeriod.p) }
  public static func add(spinPeriod: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: spinPeriod, def: 0.0, at: VTOFFSET.spinPeriod.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(dataMode: AttitudeData_Full_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func endAttitudeData_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAttitudeData_Full(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    asIdOffset asId: Offset = Offset(),
    idOnOrbitOffset idOnOrbit: Offset = Offset(),
    satNo: Int32 = 0,
    origObjectIdOffset origObjectId: Offset = Offset(),
    tsOffset ts: Offset = Offset(),
    motionTypeOffset motionType: Offset = Offset(),
    q1: Double = 0.0,
    q2: Double = 0.0,
    q3: Double = 0.0,
    qc: Double = 0.0,
    q1Dot: Double = 0.0,
    q2Dot: Double = 0.0,
    q3Dot: Double = 0.0,
    qcDot: Double = 0.0,
    xAngleVectorOffset xAngle: Offset = Offset(),
    yAngleVectorOffset yAngle: Offset = Offset(),
    zAngleVectorOffset zAngle: Offset = Offset(),
    xRateVectorOffset xRate: Offset = Offset(),
    yRateVectorOffset yRate: Offset = Offset(),
    zRateVectorOffset zRate: Offset = Offset(),
    ra: Double = 0.0,
    declination: Double = 0.0,
    coningAngle: Double = 0.0,
    precPeriod: Double = 0.0,
    spinPeriod: Double = 0.0,
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    dataMode: AttitudeData_Full_dataMode_Enum = .real,
    origNetworkOffset origNetwork: Offset = Offset()
  ) -> Offset {
    let __start = AttitudeData_Full.startAttitudeData_Full(&fbb)
    AttitudeData_Full.add(id: id, &fbb)
    AttitudeData_Full.add(classificationMarking: classificationMarking, &fbb)
    AttitudeData_Full.add(asId: asId, &fbb)
    AttitudeData_Full.add(idOnOrbit: idOnOrbit, &fbb)
    AttitudeData_Full.add(satNo: satNo, &fbb)
    AttitudeData_Full.add(origObjectId: origObjectId, &fbb)
    AttitudeData_Full.add(ts: ts, &fbb)
    AttitudeData_Full.add(motionType: motionType, &fbb)
    AttitudeData_Full.add(q1: q1, &fbb)
    AttitudeData_Full.add(q2: q2, &fbb)
    AttitudeData_Full.add(q3: q3, &fbb)
    AttitudeData_Full.add(qc: qc, &fbb)
    AttitudeData_Full.add(q1Dot: q1Dot, &fbb)
    AttitudeData_Full.add(q2Dot: q2Dot, &fbb)
    AttitudeData_Full.add(q3Dot: q3Dot, &fbb)
    AttitudeData_Full.add(qcDot: qcDot, &fbb)
    AttitudeData_Full.addVectorOf(xAngle: xAngle, &fbb)
    AttitudeData_Full.addVectorOf(yAngle: yAngle, &fbb)
    AttitudeData_Full.addVectorOf(zAngle: zAngle, &fbb)
    AttitudeData_Full.addVectorOf(xRate: xRate, &fbb)
    AttitudeData_Full.addVectorOf(yRate: yRate, &fbb)
    AttitudeData_Full.addVectorOf(zRate: zRate, &fbb)
    AttitudeData_Full.add(ra: ra, &fbb)
    AttitudeData_Full.add(declination: declination, &fbb)
    AttitudeData_Full.add(coningAngle: coningAngle, &fbb)
    AttitudeData_Full.add(precPeriod: precPeriod, &fbb)
    AttitudeData_Full.add(spinPeriod: spinPeriod, &fbb)
    AttitudeData_Full.add(createdAt: createdAt, &fbb)
    AttitudeData_Full.add(createdBy: createdBy, &fbb)
    AttitudeData_Full.add(source: source, &fbb)
    AttitudeData_Full.add(origin: origin, &fbb)
    AttitudeData_Full.add(dataMode: dataMode, &fbb)
    AttitudeData_Full.add(origNetwork: origNetwork, &fbb)
    return AttitudeData_Full.endAttitudeData_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.asId.p, fieldName: "asId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idOnOrbit.p, fieldName: "idOnOrbit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.satNo.p, fieldName: "satNo", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.origObjectId.p, fieldName: "origObjectId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ts.p, fieldName: "ts", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.motionType.p, fieldName: "motionType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.q1.p, fieldName: "q1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.q2.p, fieldName: "q2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.q3.p, fieldName: "q3", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.qc.p, fieldName: "qc", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.q1Dot.p, fieldName: "q1Dot", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.q2Dot.p, fieldName: "q2Dot", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.q3Dot.p, fieldName: "q3Dot", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.qcDot.p, fieldName: "qcDot", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.xAngle.p, fieldName: "xAngle", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.yAngle.p, fieldName: "yAngle", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.zAngle.p, fieldName: "zAngle", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.xRate.p, fieldName: "xRate", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.yRate.p, fieldName: "yRate", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.zRate.p, fieldName: "zRate", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.ra.p, fieldName: "ra", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.declination.p, fieldName: "declination", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.coningAngle.p, fieldName: "coningAngle", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.precPeriod.p, fieldName: "precPeriod", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.spinPeriod.p, fieldName: "spinPeriod", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: AttitudeData_Full_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

