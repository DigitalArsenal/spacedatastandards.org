// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Country_Full_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: Country_Full_dataMode_Enum { return .exercise }
  public static var min: Country_Full_dataMode_Enum { return .real }
}


///  /// A Country may represent countries, multi-national consortiums, and international organizations.
public struct Country_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "COUN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Country_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case code = 4
    case name = 6
    case fipsCode = 8
    case iso3Code = 10
    case codeAlt = 12
    case createdAt = 14
    case createdBy = 16
    case updatedAt = 18
    case updatedBy = 20
    case source = 22
    case origNetwork = 24
    case dataMode = 26
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The country code. Optimally, this value is the ISO 3166 Alpha-2-two-character country code, however it can represent various consortiums that do not appear in the ISO document.
  ///  Example: /// Example: US
  ///  Constraints: Minimum length = 1, Maximum length = 4
  public var code: String? { let o = _accessor.offset(VTOFFSET.code.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var codeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.code.v) }
  ///  Country name.
  ///  Example: /// Example: UNITED STATES
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  ///  Federal Information Processing Standard (FIPS) two-character country code. This field is used when the country code for FIPS differs from the country code for ISO-3166 value. For example, the ISO-3166 Alpha-2-country code for Vanuatu is VU, whereas Vanuatu's FIPS equivalent country code is NH.
  ///  Example: /// Example: US
  ///  Constraints: Minimum length = 0, Maximum length = 2
  public var fipsCode: String? { let o = _accessor.offset(VTOFFSET.fipsCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var fipsCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.fipsCode.v) }
  ///  ISO 3166 Alpha-3 country code. This is a three-character code that represents a country name, which may be more closely related to the country name than its corresponding Alpha-2 code.
  ///  Example: /// Example: USA
  ///  Constraints: Minimum length = 0, Maximum length = 3
  public var iso3Code: String? { let o = _accessor.offset(VTOFFSET.iso3Code.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var iso3CodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.iso3Code.v) }
  ///  3 Digit or other alternate country code.
  ///  Example: /// Example: US
  ///  Constraints: Minimum length = 0, Maximum length = 4
  public var codeAlt: String? { let o = _accessor.offset(VTOFFSET.codeAlt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var codeAltSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.codeAlt.v) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Time the row was last updated in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var updatedAt: String? { let o = _accessor.offset(VTOFFSET.updatedAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedAt.v) }
  ///  Application user who updated the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var updatedBy: String? { let o = _accessor.offset(VTOFFSET.updatedBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: OPS1
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: Country_Full_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : Country_Full_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  public static func startCountry_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 12) }
  public static func add(code: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: code, at: VTOFFSET.code.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(fipsCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: fipsCode, at: VTOFFSET.fipsCode.p) }
  public static func add(iso3Code: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: iso3Code, at: VTOFFSET.iso3Code.p) }
  public static func add(codeAlt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: codeAlt, at: VTOFFSET.codeAlt.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(updatedAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedAt, at: VTOFFSET.updatedAt.p) }
  public static func add(updatedBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedBy, at: VTOFFSET.updatedBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(dataMode: Country_Full_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func endCountry_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCountry_Full(
    _ fbb: inout FlatBufferBuilder,
    codeOffset code: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    fipsCodeOffset fipsCode: Offset = Offset(),
    iso3CodeOffset iso3Code: Offset = Offset(),
    codeAltOffset codeAlt: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    updatedAtOffset updatedAt: Offset = Offset(),
    updatedByOffset updatedBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    dataMode: Country_Full_dataMode_Enum = .real
  ) -> Offset {
    let __start = Country_Full.startCountry_Full(&fbb)
    Country_Full.add(code: code, &fbb)
    Country_Full.add(name: name, &fbb)
    Country_Full.add(fipsCode: fipsCode, &fbb)
    Country_Full.add(iso3Code: iso3Code, &fbb)
    Country_Full.add(codeAlt: codeAlt, &fbb)
    Country_Full.add(createdAt: createdAt, &fbb)
    Country_Full.add(createdBy: createdBy, &fbb)
    Country_Full.add(updatedAt: updatedAt, &fbb)
    Country_Full.add(updatedBy: updatedBy, &fbb)
    Country_Full.add(source: source, &fbb)
    Country_Full.add(origNetwork: origNetwork, &fbb)
    Country_Full.add(dataMode: dataMode, &fbb)
    return Country_Full.endCountry_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.code.p, fieldName: "code", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.fipsCode.p, fieldName: "fipsCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.iso3Code.p, fieldName: "iso3Code", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.codeAlt.p, fieldName: "codeAlt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedAt.p, fieldName: "updatedAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedBy.p, fieldName: "updatedBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: Country_Full_dataMode_Enum.self)
    _v.finish()
  }
}

