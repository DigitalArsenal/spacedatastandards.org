// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum RFBand_Full_mode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case tx = 0
  ///  No description available.
  case rx = 1

  public static var max: RFBand_Full_mode_Enum { return .rx }
  public static var min: RFBand_Full_mode_Enum { return .tx }
}


public enum RFBand_Full_purpose_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case comm = 0
  ///  No description available.
  case ttc = 1
  ///  No description available.
  case ops = 2
  ///  No description available.
  case other = 3

  public static var max: RFBand_Full_purpose_Enum { return .other }
  public static var min: RFBand_Full_purpose_Enum { return .comm }
}


public enum RFBand_Full_polarization_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No description available.
  case h = 0
  ///  No description available.
  case v = 1
  ///  No description available.
  case r = 2
  ///  No description available.
  case l = 3

  public static var max: RFBand_Full_polarization_Enum { return .l }
  public static var min: RFBand_Full_polarization_Enum { return .h }
}


public enum RFBand_Full_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: RFBand_Full_dataMode_Enum { return .exercise }
  public static var min: RFBand_Full_dataMode_Enum { return .real }
}


///  /// Details on a particular Radio Frequency (RF) band, also known as a carrier, which may be in use by any type of Entity for communications or operations.
public struct RFBand_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "RFBA" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: RFBand_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case idEntity = 6
    case classificationMarking = 8
    case name = 10
    case band = 12
    case mode = 14
    case purpose = 16
    case freqMin = 18
    case freqMax = 20
    case centerFreq = 22
    case peakGain = 24
    case edgeGain = 26
    case bandwidth = 28
    case beamwidth = 30
    case polarization = 32
    case erp = 34
    case eirp = 36
    case source = 38
    case origin = 40
    case dataMode = 42
    case createdAt = 44
    case createdBy = 46
    case updatedAt = 48
    case updatedBy = 50
    case origNetwork = 52
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: RFBAND-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Unique identifier of the parent Entity which uses this band.
  ///  Example: /// Example: ENTITY-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var idEntity: String? { let o = _accessor.offset(VTOFFSET.idEntity.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idEntitySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idEntity.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  RF Band name.
  ///  Example: /// Example: BAND_NAME
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  ///  Name of the band of this RF range (e.g. X,K,Ku,Ka,L,S,C,UHF,VHF,EHF,SHF,UNK,VLF,HF,E,Q,V,W). See RFBandType for more details and descriptions of each band name.
  ///  Example: /// Example: Ku
  ///  Constraints: Minimum length = 0, Maximum length = 5
  public var band: String? { let o = _accessor.offset(VTOFFSET.band.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var bandSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.band.v) }
  ///  RF Band mode (e.g. TX, RX).
  ///  Example: /// Example: TX
  ///  Constraints: Minimum length = 0, Maximum length = 4
  public var mode: RFBand_Full_mode_Enum { let o = _accessor.offset(VTOFFSET.mode.v); return o == 0 ? .tx : RFBand_Full_mode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .tx }
  ///  Purpose or use of the RF Band -- COMM = communications, TTC = Telemetry/Tracking/Control, OPS = Operations, OTHER = Other).
  ///  Example: /// Example: TTC
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var purpose: RFBand_Full_purpose_Enum { let o = _accessor.offset(VTOFFSET.purpose.v); return o == 0 ? .comm : RFBand_Full_purpose_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .comm }
  ///  Start/minimum of transmit RF frequency range, if applicable, in Mhz.
  ///  Example: /// Example: 50.23
  ///  Constraints: No constraints specified.
  public var freqMin: Double { let o = _accessor.offset(VTOFFSET.freqMin.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  End/maximum of transmit RF frequency range, if applicable, in Mhz.
  ///  Example: /// Example: 2000.23
  ///  Constraints: No constraints specified.
  public var freqMax: Double { let o = _accessor.offset(VTOFFSET.freqMax.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Center frequency of RF frequency range, if applicable, in Mhz.
  ///  Example: /// Example: 1000.23
  ///  Constraints: No constraints specified.
  public var centerFreq: Double { let o = _accessor.offset(VTOFFSET.centerFreq.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  RF Range maximum gain, in dBi.
  ///  Example: /// Example: 120.23
  ///  Constraints: No constraints specified.
  public var peakGain: Double { let o = _accessor.offset(VTOFFSET.peakGain.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  RF Range edge gain, in dBi.
  ///  Example: /// Example: 100.23
  ///  Constraints: No constraints specified.
  public var edgeGain: Double { let o = _accessor.offset(VTOFFSET.edgeGain.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  RF Band frequency range bandwidth in Mhz.
  ///  Example: /// Example: 100.23
  ///  Constraints: No constraints specified.
  public var bandwidth: Double { let o = _accessor.offset(VTOFFSET.bandwidth.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Angle between the half-power (-3 dB) points of the main lobe of the antenna, in degrees.
  ///  Example: /// Example: 45.23
  ///  Constraints: No constraints specified.
  public var beamwidth: Double { let o = _accessor.offset(VTOFFSET.beamwidth.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Transponder polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the Earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the Earth's surface.
  ///  Example: /// Example: H
  ///  Constraints: Minimum length = 0, Maximum length = 4
  public var polarization: RFBand_Full_polarization_Enum { let o = _accessor.offset(VTOFFSET.polarization.v); return o == 0 ? .h : RFBand_Full_polarization_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .h }
  ///  Effective Radiated Power (ERP) is the total power in decibel watts radiated by an actual antenna relative to a half-wave dipole rather than a theoretical isotropic antenna. A half-wave dipole has a gain of 2.15 dB compared to an isotropic antenna.  EIRP(dB) = ERP (dB)+2.15 dB or EIRP (W) = 1.64*ERP(W). Effective radiated power and effective isotropic radiated power both measure the amount of power a radio transmitter and antenna (or other source of electromagnetic waves) radiates in a specific direction: in the direction of maximum signal strength (the "main lobe") of its radiation pattern.
  ///  Example: /// Example: 2.23
  ///  Constraints: No constraints specified.
  public var erp: Double { let o = _accessor.offset(VTOFFSET.erp.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  EIRP is defined as the RMS power input in decibel watts required to a lossless half-wave dipole antenna to give the same maximum power density far from the antenna as the actual transmitter. It is equal to the power input to the transmitter's antenna multiplied by the antenna gain relative to a half-wave dipole. Effective radiated power and effective isotropic radiated power both measure the amount of power a radio transmitter and antenna (or other source of electromagnetic waves) radiates in a specific direction: in the direction of maximum signal strength (the "main lobe") of its radiation pattern.
  ///  Example: /// Example: 2.23
  ///  Constraints: No constraints specified.
  public var eirp: Double { let o = _accessor.offset(VTOFFSET.eirp.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: RFBand_Full_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : RFBand_Full_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Time the row was last updated in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var updatedAt: String? { let o = _accessor.offset(VTOFFSET.updatedAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedAt.v) }
  ///  Application user who updated the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var updatedBy: String? { let o = _accessor.offset(VTOFFSET.updatedBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var updatedBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.updatedBy.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: OPS1
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  public static func startRFBand_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 25) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(idEntity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idEntity, at: VTOFFSET.idEntity.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(band: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: band, at: VTOFFSET.band.p) }
  public static func add(mode: RFBand_Full_mode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mode.rawValue, def: 0, at: VTOFFSET.mode.p) }
  public static func add(purpose: RFBand_Full_purpose_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: purpose.rawValue, def: 0, at: VTOFFSET.purpose.p) }
  public static func add(freqMin: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: freqMin, def: 0.0, at: VTOFFSET.freqMin.p) }
  public static func add(freqMax: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: freqMax, def: 0.0, at: VTOFFSET.freqMax.p) }
  public static func add(centerFreq: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: centerFreq, def: 0.0, at: VTOFFSET.centerFreq.p) }
  public static func add(peakGain: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: peakGain, def: 0.0, at: VTOFFSET.peakGain.p) }
  public static func add(edgeGain: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: edgeGain, def: 0.0, at: VTOFFSET.edgeGain.p) }
  public static func add(bandwidth: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bandwidth, def: 0.0, at: VTOFFSET.bandwidth.p) }
  public static func add(beamwidth: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: beamwidth, def: 0.0, at: VTOFFSET.beamwidth.p) }
  public static func add(polarization: RFBand_Full_polarization_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: polarization.rawValue, def: 0, at: VTOFFSET.polarization.p) }
  public static func add(erp: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: erp, def: 0.0, at: VTOFFSET.erp.p) }
  public static func add(eirp: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: eirp, def: 0.0, at: VTOFFSET.eirp.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(dataMode: RFBand_Full_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(updatedAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedAt, at: VTOFFSET.updatedAt.p) }
  public static func add(updatedBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: updatedBy, at: VTOFFSET.updatedBy.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func endRFBand_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRFBand_Full(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    idEntityOffset idEntity: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    bandOffset band: Offset = Offset(),
    mode: RFBand_Full_mode_Enum = .tx,
    purpose: RFBand_Full_purpose_Enum = .comm,
    freqMin: Double = 0.0,
    freqMax: Double = 0.0,
    centerFreq: Double = 0.0,
    peakGain: Double = 0.0,
    edgeGain: Double = 0.0,
    bandwidth: Double = 0.0,
    beamwidth: Double = 0.0,
    polarization: RFBand_Full_polarization_Enum = .h,
    erp: Double = 0.0,
    eirp: Double = 0.0,
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    dataMode: RFBand_Full_dataMode_Enum = .real,
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    updatedAtOffset updatedAt: Offset = Offset(),
    updatedByOffset updatedBy: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset()
  ) -> Offset {
    let __start = RFBand_Full.startRFBand_Full(&fbb)
    RFBand_Full.add(id: id, &fbb)
    RFBand_Full.add(idEntity: idEntity, &fbb)
    RFBand_Full.add(classificationMarking: classificationMarking, &fbb)
    RFBand_Full.add(name: name, &fbb)
    RFBand_Full.add(band: band, &fbb)
    RFBand_Full.add(mode: mode, &fbb)
    RFBand_Full.add(purpose: purpose, &fbb)
    RFBand_Full.add(freqMin: freqMin, &fbb)
    RFBand_Full.add(freqMax: freqMax, &fbb)
    RFBand_Full.add(centerFreq: centerFreq, &fbb)
    RFBand_Full.add(peakGain: peakGain, &fbb)
    RFBand_Full.add(edgeGain: edgeGain, &fbb)
    RFBand_Full.add(bandwidth: bandwidth, &fbb)
    RFBand_Full.add(beamwidth: beamwidth, &fbb)
    RFBand_Full.add(polarization: polarization, &fbb)
    RFBand_Full.add(erp: erp, &fbb)
    RFBand_Full.add(eirp: eirp, &fbb)
    RFBand_Full.add(source: source, &fbb)
    RFBand_Full.add(origin: origin, &fbb)
    RFBand_Full.add(dataMode: dataMode, &fbb)
    RFBand_Full.add(createdAt: createdAt, &fbb)
    RFBand_Full.add(createdBy: createdBy, &fbb)
    RFBand_Full.add(updatedAt: updatedAt, &fbb)
    RFBand_Full.add(updatedBy: updatedBy, &fbb)
    RFBand_Full.add(origNetwork: origNetwork, &fbb)
    return RFBand_Full.endRFBand_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idEntity.p, fieldName: "idEntity", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.band.p, fieldName: "band", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.mode.p, fieldName: "mode", required: false, type: RFBand_Full_mode_Enum.self)
    try _v.visit(field: VTOFFSET.purpose.p, fieldName: "purpose", required: false, type: RFBand_Full_purpose_Enum.self)
    try _v.visit(field: VTOFFSET.freqMin.p, fieldName: "freqMin", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.freqMax.p, fieldName: "freqMax", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.centerFreq.p, fieldName: "centerFreq", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.peakGain.p, fieldName: "peakGain", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.edgeGain.p, fieldName: "edgeGain", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.bandwidth.p, fieldName: "bandwidth", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.beamwidth.p, fieldName: "beamwidth", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.polarization.p, fieldName: "polarization", required: false, type: RFBand_Full_polarization_Enum.self)
    try _v.visit(field: VTOFFSET.erp.p, fieldName: "erp", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.eirp.p, fieldName: "eirp", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: RFBand_Full_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedAt.p, fieldName: "updatedAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.updatedBy.p, fieldName: "updatedBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

