// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Ephemeris_Abridged_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: Ephemeris_Abridged_dataMode_Enum { return .exercise }
  public static var min: Ephemeris_Abridged_dataMode_Enum { return .real }
}


///  /// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID (esId).
public struct Ephemeris_Abridged: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "EPHE" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Ephemeris_Abridged.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case esId = 8
    case ts = 10
    case xpos = 12
    case ypos = 14
    case zpos = 16
    case xvel = 18
    case yvel = 20
    case zvel = 22
    case xaccel = 24
    case yaccel = 26
    case zaccel = 28
    case cov = 30
    case createdAt = 32
    case createdBy = 34
    case source = 36
    case dataMode = 38
    case idOnOrbit = 40
    case origObjectId = 42
    case origin = 44
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: EPHEMERIS-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Unique identifier of the parent EphemerisSet, auto-generated by the system. The esId (ephemerisSet id) is used to identify all individual ephemeris states associated with a parent ephemerisSet.
  ///  Example: /// Example: ES-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var esId: String? { let o = _accessor.offset(VTOFFSET.esId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var esIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.esId.v) }
  ///  Time associated with the Ephemeris Point, in ISO8601 UTC format.
  ///  Example: /// Example: 2018-01-01T16:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var ts: String? { let o = _accessor.offset(VTOFFSET.ts.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var tsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ts.v) }
  ///  Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var xpos: Double { let o = _accessor.offset(VTOFFSET.xpos.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var ypos: Double { let o = _accessor.offset(VTOFFSET.ypos.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var zpos: Double { let o = _accessor.offset(VTOFFSET.zpos.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var xvel: Double { let o = _accessor.offset(VTOFFSET.xvel.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var yvel: Double { let o = _accessor.offset(VTOFFSET.yvel.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var zvel: Double { let o = _accessor.offset(VTOFFSET.zvel.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var xaccel: Double { let o = _accessor.offset(VTOFFSET.xaccel.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var yaccel: Double { let o = _accessor.offset(VTOFFSET.yaccel.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  ///  Example: /// Example: 1.1
  ///  Constraints: No constraints specified.
  public var zaccel: Double { let o = _accessor.offset(VTOFFSET.zaccel.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
  ///  The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
  ///  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
  ///  x&nbsp;&nbsp;&nbsp;&nbsp;1
  ///  y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
  ///  z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
  ///  x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
  ///  y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
  ///  z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
  ///  The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasCov: Bool { let o = _accessor.offset(VTOFFSET.cov.v); return o == 0 ? false : true }
  public var covCount: Int32 { let o = _accessor.offset(VTOFFSET.cov.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func cov(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.cov.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: Ephemeris_Abridged_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : Ephemeris_Abridged_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Unique identifier of the on-orbit satellite object.
  ///  Example: /// Example: ONORBIT-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idOnOrbit: String? { let o = _accessor.offset(VTOFFSET.idOnOrbit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idOnOrbitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idOnOrbit.v) }
  ///  Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
  ///  Example: /// Example: ORIGOBJECT-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var origObjectId: String? { let o = _accessor.offset(VTOFFSET.origObjectId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origObjectIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origObjectId.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  public static func startEphemeris_Abridged(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 21) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(esId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: esId, at: VTOFFSET.esId.p) }
  public static func add(ts: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ts, at: VTOFFSET.ts.p) }
  public static func add(xpos: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: xpos, def: 0.0, at: VTOFFSET.xpos.p) }
  public static func add(ypos: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ypos, def: 0.0, at: VTOFFSET.ypos.p) }
  public static func add(zpos: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zpos, def: 0.0, at: VTOFFSET.zpos.p) }
  public static func add(xvel: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: xvel, def: 0.0, at: VTOFFSET.xvel.p) }
  public static func add(yvel: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: yvel, def: 0.0, at: VTOFFSET.yvel.p) }
  public static func add(zvel: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zvel, def: 0.0, at: VTOFFSET.zvel.p) }
  public static func add(xaccel: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: xaccel, def: 0.0, at: VTOFFSET.xaccel.p) }
  public static func add(yaccel: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: yaccel, def: 0.0, at: VTOFFSET.yaccel.p) }
  public static func add(zaccel: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zaccel, def: 0.0, at: VTOFFSET.zaccel.p) }
  public static func addVectorOf(cov: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: cov, at: VTOFFSET.cov.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(dataMode: Ephemeris_Abridged_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(idOnOrbit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idOnOrbit, at: VTOFFSET.idOnOrbit.p) }
  public static func add(origObjectId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origObjectId, at: VTOFFSET.origObjectId.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func endEphemeris_Abridged(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEphemeris_Abridged(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    esIdOffset esId: Offset = Offset(),
    tsOffset ts: Offset = Offset(),
    xpos: Double = 0.0,
    ypos: Double = 0.0,
    zpos: Double = 0.0,
    xvel: Double = 0.0,
    yvel: Double = 0.0,
    zvel: Double = 0.0,
    xaccel: Double = 0.0,
    yaccel: Double = 0.0,
    zaccel: Double = 0.0,
    covVectorOffset cov: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    dataMode: Ephemeris_Abridged_dataMode_Enum = .real,
    idOnOrbitOffset idOnOrbit: Offset = Offset(),
    origObjectIdOffset origObjectId: Offset = Offset(),
    originOffset origin: Offset = Offset()
  ) -> Offset {
    let __start = Ephemeris_Abridged.startEphemeris_Abridged(&fbb)
    Ephemeris_Abridged.add(id: id, &fbb)
    Ephemeris_Abridged.add(classificationMarking: classificationMarking, &fbb)
    Ephemeris_Abridged.add(esId: esId, &fbb)
    Ephemeris_Abridged.add(ts: ts, &fbb)
    Ephemeris_Abridged.add(xpos: xpos, &fbb)
    Ephemeris_Abridged.add(ypos: ypos, &fbb)
    Ephemeris_Abridged.add(zpos: zpos, &fbb)
    Ephemeris_Abridged.add(xvel: xvel, &fbb)
    Ephemeris_Abridged.add(yvel: yvel, &fbb)
    Ephemeris_Abridged.add(zvel: zvel, &fbb)
    Ephemeris_Abridged.add(xaccel: xaccel, &fbb)
    Ephemeris_Abridged.add(yaccel: yaccel, &fbb)
    Ephemeris_Abridged.add(zaccel: zaccel, &fbb)
    Ephemeris_Abridged.addVectorOf(cov: cov, &fbb)
    Ephemeris_Abridged.add(createdAt: createdAt, &fbb)
    Ephemeris_Abridged.add(createdBy: createdBy, &fbb)
    Ephemeris_Abridged.add(source: source, &fbb)
    Ephemeris_Abridged.add(dataMode: dataMode, &fbb)
    Ephemeris_Abridged.add(idOnOrbit: idOnOrbit, &fbb)
    Ephemeris_Abridged.add(origObjectId: origObjectId, &fbb)
    Ephemeris_Abridged.add(origin: origin, &fbb)
    return Ephemeris_Abridged.endEphemeris_Abridged(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.esId.p, fieldName: "esId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ts.p, fieldName: "ts", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.xpos.p, fieldName: "xpos", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ypos.p, fieldName: "ypos", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.zpos.p, fieldName: "zpos", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.xvel.p, fieldName: "xvel", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.yvel.p, fieldName: "yvel", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.zvel.p, fieldName: "zvel", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.xaccel.p, fieldName: "xaccel", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.yaccel.p, fieldName: "yaccel", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.zaccel.p, fieldName: "zaccel", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.cov.p, fieldName: "cov", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: Ephemeris_Abridged_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.idOnOrbit.p, fieldName: "idOnOrbit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origObjectId.p, fieldName: "origObjectId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

