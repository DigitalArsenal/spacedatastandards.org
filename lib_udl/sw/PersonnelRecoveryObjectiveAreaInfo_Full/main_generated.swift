// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  /// Objective Area Information.
public struct PersonnelRecoveryObjectiveAreaInfo_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "PERS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PersonnelRecoveryObjectiveAreaInfo_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case pzLocation = 4
    case pzDesc = 6
    case oscCallSign = 8
    case oscFreq = 10
    case enemyData = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Array of the WGS-84 latitude (-90 to 90, negative values south of the equator) in degrees, longitude (-180 to 180, negative values west of Prime Meridian) in degrees, and altitude, in meters, of the pz location.  This array must contain a minimum of 2 elements (latitude and longitude), and may contain an optional 3rd element (altitude).
  ///  Example: /// Example: [103.23, 30.445]
  ///  Constraints: No constraints specified.
  public var hasPzLocation: Bool { let o = _accessor.offset(VTOFFSET.pzLocation.v); return o == 0 ? false : true }
  public var pzLocationCount: Int32 { let o = _accessor.offset(VTOFFSET.pzLocation.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func pzLocation(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.pzLocation.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Description of the pickup zone location.
  ///  Example: /// Example: Near the lake.
  ///  Constraints: Minimum length = 0, Maximum length = 1024
  public var pzDesc: String? { let o = _accessor.offset(VTOFFSET.pzDesc.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var pzDescSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.pzDesc.v) }
  ///  The call sign of the on-scene commander.
  ///  Example: /// Example: STARFOX
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var oscCallSign: String? { let o = _accessor.offset(VTOFFSET.oscCallSign.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var oscCallSignSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.oscCallSign.v) }
  ///  The radio frequency of the on-scene commander.
  ///  Example: /// Example: 12.55
  ///  Constraints: No constraints specified.
  public var oscFreq: Double { let o = _accessor.offset(VTOFFSET.oscFreq.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Information detailing knowledge of enemies in the area.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var hasEnemyData: Bool { let o = _accessor.offset(VTOFFSET.enemyData.v); return o == 0 ? false : true }
  public var enemyDataCount: Int32 { let o = _accessor.offset(VTOFFSET.enemyData.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func enemyData(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.enemyData.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startPersonnelRecoveryObjectiveAreaInfo_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func addVectorOf(pzLocation: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: pzLocation, at: VTOFFSET.pzLocation.p) }
  public static func add(pzDesc: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: pzDesc, at: VTOFFSET.pzDesc.p) }
  public static func add(oscCallSign: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: oscCallSign, at: VTOFFSET.oscCallSign.p) }
  public static func add(oscFreq: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: oscFreq, def: 0.0, at: VTOFFSET.oscFreq.p) }
  public static func addVectorOf(enemyData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: enemyData, at: VTOFFSET.enemyData.p) }
  public static func endPersonnelRecoveryObjectiveAreaInfo_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPersonnelRecoveryObjectiveAreaInfo_Full(
    _ fbb: inout FlatBufferBuilder,
    pzLocationVectorOffset pzLocation: Offset = Offset(),
    pzDescOffset pzDesc: Offset = Offset(),
    oscCallSignOffset oscCallSign: Offset = Offset(),
    oscFreq: Double = 0.0,
    enemyDataVectorOffset enemyData: Offset = Offset()
  ) -> Offset {
    let __start = PersonnelRecoveryObjectiveAreaInfo_Full.startPersonnelRecoveryObjectiveAreaInfo_Full(&fbb)
    PersonnelRecoveryObjectiveAreaInfo_Full.addVectorOf(pzLocation: pzLocation, &fbb)
    PersonnelRecoveryObjectiveAreaInfo_Full.add(pzDesc: pzDesc, &fbb)
    PersonnelRecoveryObjectiveAreaInfo_Full.add(oscCallSign: oscCallSign, &fbb)
    PersonnelRecoveryObjectiveAreaInfo_Full.add(oscFreq: oscFreq, &fbb)
    PersonnelRecoveryObjectiveAreaInfo_Full.addVectorOf(enemyData: enemyData, &fbb)
    return PersonnelRecoveryObjectiveAreaInfo_Full.endPersonnelRecoveryObjectiveAreaInfo_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.pzLocation.p, fieldName: "pzLocation", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.pzDesc.p, fieldName: "pzDesc", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.oscCallSign.p, fieldName: "oscCallSign", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.oscFreq.p, fieldName: "oscFreq", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.enemyData.p, fieldName: "enemyData", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

