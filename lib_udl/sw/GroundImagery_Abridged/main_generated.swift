// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum GroundImagery_Abridged_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: GroundImagery_Abridged_dataMode_Enum { return .exercise }
  public static var min: GroundImagery_Abridged_dataMode_Enum { return .real }
}


///  /// Imagery of terrestrial regions from on-orbit, air, and other sensors.
public struct GroundImagery_Abridged: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "GROU" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GroundImagery_Abridged.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case idSensor = 6
    case classificationMarking = 8
    case imageTime = 10
    case filename = 12
    case regionText = 14
    case regionGeoJson = 16
    case regionType = 18
    case regionNdims = 20
    case regionSrid = 22
    case origSensorId = 24
    case subjectId = 26
    case name = 28
    case source = 30
    case origin = 32
    case origNetwork = 34
    case sourceDl = 36
    case dataMode = 38
    case createdAt = 40
    case createdBy = 42
    case transactionId = 44
    case notes = 46
    case format = 48
    case filesize = 50
    case checksumValue = 52
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: GROUNDIMAGERY-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Optional ID of the sensor that produced this ground image.
  ///  Example: /// Example: SENSOR-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idSensor: String? { let o = _accessor.offset(VTOFFSET.idSensor.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSensorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idSensor.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  Timestamp the image was captured/produced.
  ///  Example: /// Example: 2021-01-01T01:01:01.123456Z
  ///  Constraints: No constraints specified.
  public var imageTime: String? { let o = _accessor.offset(VTOFFSET.imageTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var imageTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.imageTime.v) }
  ///  Name of the image file.
  ///  Example: /// Example: Example file name
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var filename: String? { let o = _accessor.offset(VTOFFSET.filename.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var filenameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.filename.v) }
  ///  Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a create operation that also specifies a valid region.
  ///  Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  ///  Constraints: Minimum length = 0, Maximum length = 65535
  public var regionText: String? { let o = _accessor.offset(VTOFFSET.regionText.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var regionTextSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.regionText.v) }
  ///  Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. Reference: https://geojson.org/. Ignored if included with a create operation that also specifies a valid region or regionText.
  ///  Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
  ///  Constraints: Minimum length = 0, Maximum length = 65535
  public var regionGeoJson: String? { let o = _accessor.offset(VTOFFSET.regionGeoJson.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var regionGeoJsonSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.regionGeoJson.v) }
  ///  Type of region as projected on the ground.
  ///  Example: /// Example: Polygon
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var regionType: String? { let o = _accessor.offset(VTOFFSET.regionType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var regionTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.regionType.v) }
  ///  Number of dimensions of the geometry depicted by region.
  ///  Example: /// Example: 2
  ///  Constraints: No constraints specified.
  public var regionNdims: Int32 { let o = _accessor.offset(VTOFFSET.regionNdims.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Geographical spatial_ref_sys for region.
  ///  Example: /// Example: 4326
  ///  Constraints: No constraints specified.
  public var regionSrid: Int32 { let o = _accessor.offset(VTOFFSET.regionSrid.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Optional identifier provided by source to indicate the sensor identifier used to detect this event. This may be an internal identifier and not necessarily a valid sensor ID.
  ///  Example: /// Example: ORIGSENSOR-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var origSensorId: String? { let o = _accessor.offset(VTOFFSET.origSensorId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origSensorIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origSensorId.v) }
  ///  Optional identifier of the subject/target of the image, useful for correlating multiple images of the same subject.
  ///  Example: /// Example: SUBJECT-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var subjectId: String? { let o = _accessor.offset(VTOFFSET.subjectId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var subjectIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.subjectId.v) }
  ///  Optional name/description associated with this image.
  ///  Example: /// Example: Example name
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  ///  Example: /// Example: AXE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var sourceDl: String? { let o = _accessor.offset(VTOFFSET.sourceDl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceDlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceDl.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: GroundImagery_Abridged_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : GroundImagery_Abridged_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  ///  Example: /// Example: 37bdef1f-5a4f-4776-bee4-7a1e0ec7d35a
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var transactionId: String? { let o = _accessor.offset(VTOFFSET.transactionId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var transactionIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.transactionId.v) }
  ///  Description and notes of the image.
  ///  Example: /// Example: Example notes
  ///  Constraints: Minimum length = 0, Maximum length = 1024
  public var notes: String? { let o = _accessor.offset(VTOFFSET.notes.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var notesSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.notes.v) }
  ///  Optional, field indicating type of image, NITF, PNG, etc.
  ///  Example: /// Example: PNG
  ///  Constraints: Minimum length = 1, Maximum length = 16
  public var format: String? { let o = _accessor.offset(VTOFFSET.format.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var formatSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.format.v) }
  ///  Size of the image file. Units in bytes. If filesize is provided without an associated file, it defaults to 0.
  ///  Example: /// Example: 0
  ///  Constraints: No constraints specified.
  public var filesize: Int64 { let o = _accessor.offset(VTOFFSET.filesize.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  ///  MD5 value of the file. The ingest/create operation will automatically generate the value.
  ///  Example: /// Example: 120EA8A25E5D487BF68B5F7096440019
  ///  Constraints: Minimum length = 1, Maximum length = 256
  public var checksumValue: String? { let o = _accessor.offset(VTOFFSET.checksumValue.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var checksumValueSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.checksumValue.v) }
  public static func startGroundImagery_Abridged(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 25) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(idSensor: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idSensor, at: VTOFFSET.idSensor.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(imageTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: imageTime, at: VTOFFSET.imageTime.p) }
  public static func add(filename: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: filename, at: VTOFFSET.filename.p) }
  public static func add(regionText: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: regionText, at: VTOFFSET.regionText.p) }
  public static func add(regionGeoJson: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: regionGeoJson, at: VTOFFSET.regionGeoJson.p) }
  public static func add(regionType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: regionType, at: VTOFFSET.regionType.p) }
  public static func add(regionNdims: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: regionNdims, def: 0, at: VTOFFSET.regionNdims.p) }
  public static func add(regionSrid: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: regionSrid, def: 0, at: VTOFFSET.regionSrid.p) }
  public static func add(origSensorId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origSensorId, at: VTOFFSET.origSensorId.p) }
  public static func add(subjectId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: subjectId, at: VTOFFSET.subjectId.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(sourceDl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceDl, at: VTOFFSET.sourceDl.p) }
  public static func add(dataMode: GroundImagery_Abridged_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(transactionId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: transactionId, at: VTOFFSET.transactionId.p) }
  public static func add(notes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: notes, at: VTOFFSET.notes.p) }
  public static func add(format: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: format, at: VTOFFSET.format.p) }
  public static func add(filesize: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: filesize, def: 0, at: VTOFFSET.filesize.p) }
  public static func add(checksumValue: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: checksumValue, at: VTOFFSET.checksumValue.p) }
  public static func endGroundImagery_Abridged(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGroundImagery_Abridged(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    idSensorOffset idSensor: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    imageTimeOffset imageTime: Offset = Offset(),
    filenameOffset filename: Offset = Offset(),
    regionTextOffset regionText: Offset = Offset(),
    regionGeoJsonOffset regionGeoJson: Offset = Offset(),
    regionTypeOffset regionType: Offset = Offset(),
    regionNdims: Int32 = 0,
    regionSrid: Int32 = 0,
    origSensorIdOffset origSensorId: Offset = Offset(),
    subjectIdOffset subjectId: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    sourceDlOffset sourceDl: Offset = Offset(),
    dataMode: GroundImagery_Abridged_dataMode_Enum = .real,
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    transactionIdOffset transactionId: Offset = Offset(),
    notesOffset notes: Offset = Offset(),
    formatOffset format: Offset = Offset(),
    filesize: Int64 = 0,
    checksumValueOffset checksumValue: Offset = Offset()
  ) -> Offset {
    let __start = GroundImagery_Abridged.startGroundImagery_Abridged(&fbb)
    GroundImagery_Abridged.add(id: id, &fbb)
    GroundImagery_Abridged.add(idSensor: idSensor, &fbb)
    GroundImagery_Abridged.add(classificationMarking: classificationMarking, &fbb)
    GroundImagery_Abridged.add(imageTime: imageTime, &fbb)
    GroundImagery_Abridged.add(filename: filename, &fbb)
    GroundImagery_Abridged.add(regionText: regionText, &fbb)
    GroundImagery_Abridged.add(regionGeoJson: regionGeoJson, &fbb)
    GroundImagery_Abridged.add(regionType: regionType, &fbb)
    GroundImagery_Abridged.add(regionNdims: regionNdims, &fbb)
    GroundImagery_Abridged.add(regionSrid: regionSrid, &fbb)
    GroundImagery_Abridged.add(origSensorId: origSensorId, &fbb)
    GroundImagery_Abridged.add(subjectId: subjectId, &fbb)
    GroundImagery_Abridged.add(name: name, &fbb)
    GroundImagery_Abridged.add(source: source, &fbb)
    GroundImagery_Abridged.add(origin: origin, &fbb)
    GroundImagery_Abridged.add(origNetwork: origNetwork, &fbb)
    GroundImagery_Abridged.add(sourceDl: sourceDl, &fbb)
    GroundImagery_Abridged.add(dataMode: dataMode, &fbb)
    GroundImagery_Abridged.add(createdAt: createdAt, &fbb)
    GroundImagery_Abridged.add(createdBy: createdBy, &fbb)
    GroundImagery_Abridged.add(transactionId: transactionId, &fbb)
    GroundImagery_Abridged.add(notes: notes, &fbb)
    GroundImagery_Abridged.add(format: format, &fbb)
    GroundImagery_Abridged.add(filesize: filesize, &fbb)
    GroundImagery_Abridged.add(checksumValue: checksumValue, &fbb)
    return GroundImagery_Abridged.endGroundImagery_Abridged(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idSensor.p, fieldName: "idSensor", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.imageTime.p, fieldName: "imageTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.filename.p, fieldName: "filename", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.regionText.p, fieldName: "regionText", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.regionGeoJson.p, fieldName: "regionGeoJson", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.regionType.p, fieldName: "regionType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.regionNdims.p, fieldName: "regionNdims", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.regionSrid.p, fieldName: "regionSrid", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.origSensorId.p, fieldName: "origSensorId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.subjectId.p, fieldName: "subjectId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceDl.p, fieldName: "sourceDl", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: GroundImagery_Abridged_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.transactionId.p, fieldName: "transactionId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.notes.p, fieldName: "notes", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.format.p, fieldName: "format", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.filesize.p, fieldName: "filesize", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.checksumValue.p, fieldName: "checksumValue", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

