// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum TrackDetails_Ingest_env_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
  case air = 0
  ///  On the surface of dry land.
  case land = 1
  ///  Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
  case space = 2
  ///  On the surface of a body of water.
  case surface = 3
  ///  Below the surface of a body of water.
  case subsurface = 4
  ///  Environment is not known.
  case unknown = 5

  public static var max: TrackDetails_Ingest_env_Enum { return .unknown }
  public static var min: TrackDetails_Ingest_env_Enum { return .air }
}


public enum TrackDetails_Ingest_objIdent_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  case assumedFriend = 0
  ///  Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  case friend = 1
  ///  Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  case hostile = 2
  ///  Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  case neutral = 3
  ///  Track object which has not been evaluated.
  case pending = 4
  ///  Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  case suspect = 5
  ///  Track object which has been evaluated and does not meet criteria for any standard identity.
  case unknown = 6

  public static var max: TrackDetails_Ingest_objIdent_Enum { return .unknown }
  public static var min: TrackDetails_Ingest_objIdent_Enum { return .assumedFriend }
}


public enum TrackDetails_Ingest_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: TrackDetails_Ingest_dataMode_Enum { return .exercise }
  public static var min: TrackDetails_Ingest_dataMode_Enum { return .real }
}


///  /// These services provide operations for querying of all available track details and amplifying track data. A track is a position and optionally a heading/velocity of an object such as an aircraft, marine vessel, etc at a particular timestamp. It also includes optional information regarding the identity/type of the target object and other amplifying object data, if known.
public struct TrackDetails_Ingest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TRAC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: TrackDetails_Ingest.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case env = 8
    case msgType = 10
    case hullNum = 12
    case pif = 14
    case sconum = 16
    case ntds = 18
    case disId = 20
    case midbCat = 22
    case beNumber = 24
    case oSuffix = 26
    case pin = 28
    case lostTrkInd = 30
    case muidSrcTrk = 32
    case muidSrc = 34
    case mslStatus = 36
    case trkConf = 38
    case trkQual = 40
    case alert = 42
    case origXref = 44
    case elnot1 = 46
    case elnot2 = 48
    case objIdent = 50
    case objType = 52
    case objPlat = 54
    case objAct = 56
    case objNat = 58
    case name = 60
    case shortName = 62
    case trkId = 64
    case trkNum = 66
    case trkScope = 68
    case sourceUid = 70
    case callSign = 72
    case identAmp = 74
    case spaceAmp = 76
    case spaceAmpConf = 78
    case spaceSpecType = 80
    case acftSubType = 82
    case ts = 84
    case launchTime = 86
    case impactTime = 88
    case ftnMsgTs = 90
    case ftn = 92
    case ftnCmd = 94
    case rtnMsgTs = 96
    case rtn = 98
    case rtnTrkState = 100
    case rtnCmd = 102
    case sen = 104
    case rptChxref = 106
    case rptArchived = 108
    case selfReport = 110
    case mil2525Bstr = 112
    case trnspdrId = 114
    case trnspdrType = 116
    case emitterName = 118
    case infoSource = 120
    case boosting = 122
    case freq = 124
    case maxFreq = 126
    case harmonics = 128
    case pri = 130
    case prf = 132
    case pw = 134
    case scanType = 136
    case scanRate = 138
    case scn = 140
    case cI = 142
    case angElev = 144
    case lat = 146
    case lon = 148
    case launchLat = 150
    case launchLon = 152
    case impactLat = 154
    case impactLon = 156
    case polarSingLocLat = 158
    case polarSingLocLon = 160
    case azCorrCenterLine = 162
    case azCorrArcWidth = 164
    case errSemiIntAxis = 166
    case errAreaOrient = 168
    case errSemiMajElev = 170
    case errGeoAreaSwitch = 172
    case burnoutAlt = 174
    case tesEventId = 176
    case spd = 178
    case avgSpd = 180
    case tol = 182
    case alt = 184
    case hdng = 186
    case course = 188
    case propRpm = 190
    case tpk = 192
    case coopLocInd = 194
    case maneuverInd = 196
    case launchAouType = 198
    case launchAouData = 200
    case impactAouType = 202
    case impactAouData = 204
    case aouRptType = 206
    case aouRptData = 208
    case ecefPos = 210
    case ecefVel = 212
    case containment = 214
    case cpa = 216
    case tcpa = 218
    case navStatus = 220
    case posDeviceType = 222
    case aton = 224
    case offPosInd = 226
    case antennaRefDimensions = 228
    case shipClass = 230
    case imon = 232
    case mmsi = 234
    case draught = 236
    case length = 238
    case width = 240
    case cargoType = 242
    case appGrp = 244
    case hullProf = 246
    case propType = 248
    case numBlades = 250
    case numShafts = 252
    case sternType = 254
    case vslWt = 256
    case arrTime = 258
    case arrFlag = 260
    case arrCargo = 262
    case arrPort = 264
    case depPort = 266
    case depFlag = 268
    case depCargo = 270
    case desFlag = 272
    case desCargo = 274
    case destination = 276
    case eta = 278
    case etd = 280
    case iff = 282
    case emgInd = 284
    case dropPtInd = 286
    case reinforced = 288
    case reduced = 290
    case hq = 292
    case dummy = 294
    case taskForce = 296
    case feint = 298
    case installation = 300
    case staffCmts = 302
    case addInfo = 304
    case evalRating = 306
    case createdAt = 308
    case createdBy = 310
    case source = 312
    case origin = 314
    case dataMode = 316
    case origNetwork = 318
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: TRACK-DETAILS-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
  ///   AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///   LAND: On the surface of dry land.
  ///   SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///   SURFACE: On the surface of a body of water.
  ///   SUBSURFACE: Below the surface of a body of water.
  ///   UNKNOWN: Environment is not known.
  ///  Example: /// Example: LAND
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var env: TrackDetails_Ingest_env_Enum { let o = _accessor.offset(VTOFFSET.env.v); return o == 0 ? .air : TrackDetails_Ingest_env_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .air }
  ///  Optional message type designation.
  ///  Example: /// Example: PLATFORM
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var msgType: String? { let o = _accessor.offset(VTOFFSET.msgType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var msgTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.msgType.v) }
  ///  The vessel hull number designation of this maritime vessel.  The hull number is a 1-6 character alphanumeric entry assigned to a ship and painted on the hull.
  ///  Example: /// Example: A30081
  ///  Constraints: Minimum length = 0, Maximum length = 7
  public var hullNum: String? { let o = _accessor.offset(VTOFFSET.hullNum.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var hullNumSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.hullNum.v) }
  ///  The Pseudo Identification Feature (PIF) number is a four digit code that provides an exact ID for the ship or aircraft. Friendly military only.
  ///  Example: /// Example: 0137
  ///  Constraints: Minimum length = 0, Maximum length = 5
  public var pif: String? { let o = _accessor.offset(VTOFFSET.pif.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var pifSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.pif.v) }
  ///  The Ship Control Number (SCONUM) is a naval vessel identification number (alphanumeric code) assigned by the Office of Naval Intelligence. SCONUM is sometimes referred to as NOIC ID. SCONUMs are typically of the form A#####, where A is an alpha character and # is numerical.
  ///  Example: /// Example: B45524
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var sconum: String? { let o = _accessor.offset(VTOFFSET.sconum.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sconumSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sconum.v) }
  ///  The Naval Tactical Data System (NTDS) track number assigned to this track.
  ///  Example: /// Example: ZZ777
  ///  Constraints: Minimum length = 0, Maximum length = 6
  public var ntds: String? { let o = _accessor.offset(VTOFFSET.ntds.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ntdsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ntds.v) }
  ///  The Intel Discrete Identifier (IDI) code assigned to this track.  The IDI is a four-digit code representing hostile or unknown tracks.
  ///  Example: /// Example: 7670
  ///  Constraints: Minimum length = 0, Maximum length = 5
  public var disId: String? { let o = _accessor.offset(VTOFFSET.disId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var disIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.disId.v) }
  ///  The category code that represents the associated facility purpose within the target system.  This value is the category code in the MIDB (Modernized Intelligence Database).
  ///  Example: /// Example: 20345
  ///  Constraints: Minimum length = 0, Maximum length = 6
  public var midbCat: String? { let o = _accessor.offset(VTOFFSET.midbCat.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var midbCatSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.midbCat.v) }
  ///  The Basic Encyclopedia (BE) number associated with this installation or area.
  ///  Example: /// Example: ENC-123
  ///  Constraints: Minimum length = 0, Maximum length = 10
  public var beNumber: String? { let o = _accessor.offset(VTOFFSET.beNumber.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var beNumberSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.beNumber.v) }
  ///  The O-suffix associated with this facility.  The O-suffix is a five-character alpha/numeric system used to identify a facility, or demographic area, within an installation. The Installation Basic Encyclopedia (beNumber), in conjunction with the O-suffix, uniquely identifies the facility within the Modernized Integrated Database (MIDB).  The Installation beNumber and oSuffix are also used in conjunction with the midbCat code to classify the function or purpose of the facility.
  ///  Example: /// Example: AA125
  ///  Constraints: Minimum length = 0, Maximum length = 6
  public var oSuffix: String? { let o = _accessor.offset(VTOFFSET.oSuffix.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var oSuffixSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.oSuffix.v) }
  ///  This value represents the site number of a specific electronic site or its associated equipment.
  ///  Example: /// Example: E12345012
  ///  Constraints: Minimum length = 0, Maximum length = 9
  public var pin: String? { let o = _accessor.offset(VTOFFSET.pin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var pinSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.pin.v) }
  ///  Flag indicating whether the missile is considered lost, if reporting a missile track.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var lostTrkInd: Bool { let o = _accessor.offset(VTOFFSET.lostTrkInd.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Track ID for the source of the Missile-Unique Identifier (MUID), if reporting a missile track.
  ///  Example: /// Example: MUID-SRC-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var muidSrcTrk: String? { let o = _accessor.offset(VTOFFSET.muidSrcTrk.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var muidSrcTrkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.muidSrcTrk.v) }
  ///  Source of the Missile-Unique Identifier (MUID), if reporting a missile track.
  ///  Example: /// Example: MUID-SRC
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var muidSrc: String? { let o = _accessor.offset(VTOFFSET.muidSrc.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var muidSrcSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.muidSrc.v) }
  ///  The status of the missile track in this record, if reporting a missile track (e.g. AT LAUNCH, AT OBSERVATION, FLYING, IMPACTED, LOST, STALE, DEBRIS).
  ///  Example: /// Example: AT LAUNCH
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var mslStatus: String? { let o = _accessor.offset(VTOFFSET.mslStatus.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var mslStatusSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.mslStatus.v) }
  ///  Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
  ///  Example: /// Example: 0.95
  ///  Constraints: No constraints specified.
  public var trkConf: Double { let o = _accessor.offset(VTOFFSET.trkConf.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track; Higher values indicate higher track quality, i.e., lower errors in reported position.
  ///  Example: /// Example: 1
  ///  Constraints: No constraints specified.
  public var trkQual: Int32 { let o = _accessor.offset(VTOFFSET.trkQual.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  A track may be designated as an alert track with the following designations:
  ///  HIT - High Interest Track
  ///  TGT - Target
  ///  SUS - Suspect Carrier
  ///  NSP - Cleared Suspect
  ///  If alert is null, the track is assumed to be of non-alert status.
  ///  Example: /// Example: TGT
  ///  Constraints: Minimum length = 0, Maximum length = 3
  public var alert: String? { let o = _accessor.offset(VTOFFSET.alert.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var alertSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.alert.v) }
  ///  Original source cross-reference code for the Command that originated the report.
  ///  Example: /// Example: INT
  ///  Constraints: Minimum length = 0, Maximum length = 5
  public var origXref: String? { let o = _accessor.offset(VTOFFSET.origXref.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origXrefSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origXref.v) }
  ///  Primary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
  ///  Example: /// Example: A123A
  ///  Constraints: Minimum length = 0, Maximum length = 5
  public var elnot1: String? { let o = _accessor.offset(VTOFFSET.elnot1.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var elnot1SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.elnot1.v) }
  ///  Secondary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
  ///  Example: /// Example: A123B
  ///  Constraints: Minimum length = 0, Maximum length = 5
  public var elnot2: String? { let o = _accessor.offset(VTOFFSET.elnot2.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var elnot2SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.elnot2.v) }
  ///  The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
  ///   ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  ///   FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  ///   HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  ///   NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  ///   PENDING: Track object which has not been evaluated.
  ///   SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  ///   UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
  ///  Example: /// Example: FRIEND
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var objIdent: TrackDetails_Ingest_objIdent_Enum { let o = _accessor.offset(VTOFFSET.objIdent.v); return o == 0 ? .assumedFriend : TrackDetails_Ingest_objIdent_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .assumedFriend }
  ///  The generic classification of the track object/group (e.g., BALLISTIC, HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
  ///  Example: /// Example: TRACKED
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var objType: String? { let o = _accessor.offset(VTOFFSET.objType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var objTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.objType.v) }
  ///  The object platform type is intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. SATELLITE).
  ///  Example: /// Example: WEAPON
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var objPlat: String? { let o = _accessor.offset(VTOFFSET.objPlat.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var objPlatSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.objPlat.v) }
  ///  The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. ANTISPACE WARFARE).
  ///  Example: /// Example: HOLDING
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var objAct: String? { let o = _accessor.offset(VTOFFSET.objAct.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var objActSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.objAct.v) }
  ///  Nationality of the tracked object.
  ///  Example: /// Example: USA
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var objNat: String? { let o = _accessor.offset(VTOFFSET.objNat.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var objNatSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.objNat.v) }
  ///  Track name.
  ///  Example: /// Example: TRACK-NAME
  ///  Constraints: Minimum length = 0, Maximum length = 48
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  ///  Abbreviated track name.
  ///  Example: /// Example: COMMSCHECK
  ///  Constraints: Minimum length = 0, Maximum length = 11
  public var shortName: String? { let o = _accessor.offset(VTOFFSET.shortName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var shortNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.shortName.v) }
  ///  UUID identifying the track, which should remain the same on subsequent tracks of the same object.
  ///  Example: /// Example: trkId
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var trkId: String? { let o = _accessor.offset(VTOFFSET.trkId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var trkIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.trkId.v) }
  ///  The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
  ///  Example: /// Example: trkNum
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var trkNum: String? { let o = _accessor.offset(VTOFFSET.trkNum.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var trkNumSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.trkNum.v) }
  ///  Value Indicating the scope of this track:
  ///  1 - TERMINAL  (Terminal) - available only on the workstation where they were created.
  ///  2 - LOCAL  (Local) - available only on workstations in the local area network
  ///  3 - OTH  (Over the Horizon) - available to everyone.
  ///  Example: /// Example: OTH
  ///  Constraints: Minimum length = 0, Maximum length = 12
  public var trkScope: String? { let o = _accessor.offset(VTOFFSET.trkScope.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var trkScopeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.trkScope.v) }
  ///  The unique identifier of the source node.
  ///  Example: /// Example: MCS
  ///  Constraints: Minimum length = 0, Maximum length = 4
  public var sourceUid: String? { let o = _accessor.offset(VTOFFSET.sourceUid.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceUidSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceUid.v) }
  ///  The call sign currently assigned to this track object.
  ///  Example: /// Example: Charlie
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var callSign: String? { let o = _accessor.offset(VTOFFSET.callSign.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var callSignSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.callSign.v) }
  ///  Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
  ///   FAKER: Friendly track, object, or entity acting as an exercise hostile.
  ///   JOKER: Friendly track, object, or entity acting as an exercise suspect.
  ///   KILO: Friendly high-value object.
  ///   TRAVELLER: Suspect land or surface track following a recognized traffic route.
  ///   ZOMBIE: Suspect track, object, or entity of special interest.
  ///  Example: /// Example: JOKER
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var identAmp: String? { let o = _accessor.offset(VTOFFSET.identAmp.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var identAmpSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.identAmp.v) }
  ///  Space amplification indicates additional information on the space environment object being reported (e.g. DEBRIS, FUEL-AIR EXPLOSIVE, NUCLEAR WARHEAD).
  ///  Example: /// Example: NUCLEAR WARHEAD
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var spaceAmp: String? { let o = _accessor.offset(VTOFFSET.spaceAmp.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var spaceAmpSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.spaceAmp.v) }
  ///  Confidence level of the amplifying characteristics.  Values range from 0 to 6, with 0 indicating the lowest confidence and 6 indicating the highest.
  ///  Example: /// Example: 6
  ///  Constraints: No constraints specified.
  public var spaceAmpConf: Int32 { let o = _accessor.offset(VTOFFSET.spaceAmpConf.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Specific type of point or track with an environment of space.
  ///  Example: /// Example: SS-21_MOD_2_CRBM
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var spaceSpecType: String? { let o = _accessor.offset(VTOFFSET.spaceSpecType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var spaceSpecTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.spaceSpecType.v) }
  ///  Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM:
  ///  SRBM - Short-Range Ballistic Missile
  ///  MRBM - Medium-Range Ballistic Missile
  ///  IRBM - Intermediate-Range Ballistic Missile
  ///  LRBM - Long-Range Ballistic Missile
  ///  ICBM - Intercontinental Ballistic Missile
  ///  SLBM - Submarine-Launched Ballistic Missile.
  ///  Example: /// Example: SLBM
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var acftSubType: String? { let o = _accessor.offset(VTOFFSET.acftSubType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var acftSubTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.acftSubType.v) }
  ///  Track timestamp in ISO8601 UTC format with microsecond precision.
  ///  Example: /// Example: 2021-02-25T12:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var ts: String? { let o = _accessor.offset(VTOFFSET.ts.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var tsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ts.v) }
  ///  Missile launch timestamp in ISO8601 UTC format with microsecond precision.
  ///  Example: /// Example: 2021-02-25T12:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var launchTime: String? { let o = _accessor.offset(VTOFFSET.launchTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var launchTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.launchTime.v) }
  ///  Missile impact timestamp in ISO8601 UTC format with microsecond precision.
  ///  Example: /// Example: 2021-02-25T12:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var impactTime: String? { let o = _accessor.offset(VTOFFSET.impactTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var impactTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.impactTime.v) }
  ///  The message timestamp that the ftn track position was recorded, in ISO 8601 UTC format with microsecond precision.
  ///  Example: /// Example: 2021-02-25T12:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var ftnMsgTs: String? { let o = _accessor.offset(VTOFFSET.ftnMsgTs.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ftnMsgTsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ftnMsgTs.v) }
  ///  An ftn used to associate information and directives with the track.
  ///  Example: /// Example: FTN
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var ftn: String? { let o = _accessor.offset(VTOFFSET.ftn.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ftnSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ftn.v) }
  ///  The name of the Command reporting the Force Over-The-Horizon Track Coordinator (FOTC) track number.
  ///  Example: /// Example: TRUETT
  ///  Constraints: Minimum length = 0, Maximum length = 18
  public var ftnCmd: String? { let o = _accessor.offset(VTOFFSET.ftnCmd.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ftnCmdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ftnCmd.v) }
  ///  The message timestamp that the reference track position was recorded, in ISO 8601 UTC format with microsecond precision. The 'rtnMsgTs' and 'rtn' arrays must match in size.
  ///  Example: /// Example: ['2021-02-25T12:00:00.123456Z']
  ///  Constraints: No constraints specified.
  public var hasRtnMsgTs: Bool { let o = _accessor.offset(VTOFFSET.rtnMsgTs.v); return o == 0 ? false : true }
  public var rtnMsgTsCount: Int32 { let o = _accessor.offset(VTOFFSET.rtnMsgTs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func rtnMsgTs(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.rtnMsgTs.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  A Reference Track Number used to associate information and directives with the track.  Referenced, but not constrained to, MIL-STD-6016F Reference Track Number. The 'rtnMsgTs' and 'rtn' arrays must match in size.
  ///  Example: /// Example: ['ex-a']
  ///  Constraints: No constraints specified.
  public var hasRtn: Bool { let o = _accessor.offset(VTOFFSET.rtn.v); return o == 0 ? false : true }
  public var rtnCount: Int32 { let o = _accessor.offset(VTOFFSET.rtn.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func rtn(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.rtn.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Value representing the state of the Received Track.
  ///  Example: /// Example: Local_RTN
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var rtnTrkState: String? { let o = _accessor.offset(VTOFFSET.rtnTrkState.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var rtnTrkStateSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.rtnTrkState.v) }
  ///  The name of the Command reporting the Received Track Number (RTN).
  ///  Example: /// Example: YORKTOWN
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var rtnCmd: String? { let o = _accessor.offset(VTOFFSET.rtnCmd.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var rtnCmdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.rtnCmd.v) }
  ///  Id/name of sensor providing the track data.
  ///  Example: /// Example: OTH
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var sen: String? { let o = _accessor.offset(VTOFFSET.sen.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var senSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sen.v) }
  ///  Source cross-reference code for the Command that originated the track report.
  ///  Example: /// Example: INT
  ///  Constraints: Minimum length = 0, Maximum length = 18
  public var rptChxref: String? { let o = _accessor.offset(VTOFFSET.rptChxref.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var rptChxrefSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.rptChxref.v) }
  ///  Flag indicating whether this track is archived.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var rptArchived: Bool { let o = _accessor.offset(VTOFFSET.rptArchived.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating that this track is self reported.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var selfReport: Bool { let o = _accessor.offset(VTOFFSET.selfReport.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  The MIL-STD-2525B symbology code that applies to the subject of this track.
  ///  Example: /// Example: SHP*S----------
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var mil2525Bstr: String? { let o = _accessor.offset(VTOFFSET.mil2525Bstr.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var mil2525BstrSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.mil2525Bstr.v) }
  ///  Transponder ID for the track.  This does not correspond to the UDL transponder schema.
  ///  Example: /// Example: 11
  ///  Constraints: Minimum length = 0, Maximum length = 61
  public var trnspdrId: String? { let o = _accessor.offset(VTOFFSET.trnspdrId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var trnspdrIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.trnspdrId.v) }
  ///  Transponder type for the track.
  ///  Example: /// Example: AFTS
  ///  Constraints: Minimum length = 0, Maximum length = 51
  public var trnspdrType: String? { let o = _accessor.offset(VTOFFSET.trnspdrType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var trnspdrTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.trnspdrType.v) }
  ///  Radar name of the sensor tracking this object (e.g., RAY1500, SPN-43, HEADNET).
  ///  Example: /// Example: RAY1500
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var emitterName: String? { let o = _accessor.offset(VTOFFSET.emitterName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var emitterNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.emitterName.v) }
  ///  Source code for source of information used to detect track.
  ///  Example: /// Example: S1
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var infoSource: String? { let o = _accessor.offset(VTOFFSET.infoSource.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var infoSourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.infoSource.v) }
  ///  Flag indicating that the missile is currently in a state of boosting, if reporting a missile track.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var boosting: Bool { let o = _accessor.offset(VTOFFSET.boosting.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Frequency, in hertz, for the signature report.
  ///  Example: /// Example: 63.65
  ///  Constraints: No constraints specified.
  public var freq: Double { let o = _accessor.offset(VTOFFSET.freq.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum frequency, in hertz, reported for this acoustic track.
  ///  Example: /// Example: 10324.53
  ///  Constraints: No constraints specified.
  public var maxFreq: Double { let o = _accessor.offset(VTOFFSET.maxFreq.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  List of harmonics of the signature report in descending order of predominance using 1-2 digit combinations separated by commas, e.g., 8,12,4. (1-22NS).
  ///  Example: /// Example: 8,12,4
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var harmonics: String? { let o = _accessor.offset(VTOFFSET.harmonics.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var harmonicsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.harmonics.v) }
  ///  Pulse repetition interval of the emitter, measured in microseconds.  The interval between the start of one pulse and the start of another.
  ///  Example: /// Example: 56657.2238
  ///  Constraints: No constraints specified.
  public var pri: Double { let o = _accessor.offset(VTOFFSET.pri.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Pulse repetition frequency of the emitter, measured in pulses per second.  PRF is the number of pulses transmitted per second. This is the reciprocal of the pri value.
  ///  Example: /// Example: 17.65
  ///  Constraints: No constraints specified.
  public var prf: Double { let o = _accessor.offset(VTOFFSET.prf.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Pulse width of the emitter, measured in microseconds.  This is the duration of the pulse.
  ///  Example: /// Example: 1347.45
  ///  Constraints: No constraints specified.
  public var pw: Double { let o = _accessor.offset(VTOFFSET.pw.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Type of radar scan.
  ///  Example: /// Example: UNK
  ///  Constraints: Minimum length = 0, Maximum length = 5
  public var scanType: String? { let o = _accessor.offset(VTOFFSET.scanType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var scanTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.scanType.v) }
  ///  Scan rate of the emitter, measured in seconds per rotation (SPR).
  ///  Example: /// Example: 12.01
  ///  Constraints: No constraints specified.
  public var scanRate: Double { let o = _accessor.offset(VTOFFSET.scanRate.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The Sequential Contact Number (SCN) for this track.
  ///  Example: /// Example: 1474305
  ///  Constraints: No constraints specified.
  public var scn: Int32 { let o = _accessor.offset(VTOFFSET.scn.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Correlation Index; reference code for the site that originally reported the track.
  ///  Example: /// Example: BB
  ///  Constraints: Minimum length = 0, Maximum length = 3
  public var cI: String? { let o = _accessor.offset(VTOFFSET.cI.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var cISegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.cI.v) }
  ///  The angle formed between the line of sight of the observer and the horizon, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
  ///  Example: /// Example: 15.2
  ///  Constraints: No constraints specified.
  public var angElev: Double { let o = _accessor.offset(VTOFFSET.angElev.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 19.88550102
  ///  Constraints: No constraints specified.
  public var lat: Double { let o = _accessor.offset(VTOFFSET.lat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 46.74596844
  ///  Constraints: No constraints specified.
  public var lon: Double { let o = _accessor.offset(VTOFFSET.lon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 19.88550102
  ///  Constraints: No constraints specified.
  public var launchLat: Double { let o = _accessor.offset(VTOFFSET.launchLat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 46.74550102
  ///  Constraints: No constraints specified.
  public var launchLon: Double { let o = _accessor.offset(VTOFFSET.launchLon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 latitude of the missile impact point, in degrees. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 19.88550102
  ///  Constraints: No constraints specified.
  public var impactLat: Double { let o = _accessor.offset(VTOFFSET.impactLat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 longitude of the missile impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 46.74550102
  ///  Constraints: No constraints specified.
  public var impactLon: Double { let o = _accessor.offset(VTOFFSET.impactLon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 azimuth corridor reference point latitude, in degrees. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 19.88550102
  ///  Constraints: No constraints specified.
  public var polarSingLocLat: Double { let o = _accessor.offset(VTOFFSET.polarSingLocLat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 azimuth corridor reference point longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 46.74550102
  ///  Constraints: No constraints specified.
  public var polarSingLocLon: Double { let o = _accessor.offset(VTOFFSET.polarSingLocLon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The azimuth corridor centerline angle measured in degrees clockwise from true north, of the center line of an azimuth corridor. The center line extends from the referenced corridor origin location.
  ///  Example: /// Example: 12.876
  ///  Constraints: No constraints specified.
  public var azCorrCenterLine: Double { let o = _accessor.offset(VTOFFSET.azCorrCenterLine.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Azimuth corridor arc distance measured in meters from reference point of azimuth corridor to far edge of bounded azimuth corridor wedge, measured along azimuth corridor center line.
  ///  Example: /// Example: 71.76
  ///  Constraints: No constraints specified.
  public var azCorrArcWidth: Double { let o = _accessor.offset(VTOFFSET.azCorrArcWidth.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The error in the semi-intermediate axis.  The semi-intermediate axis is intermediate in length between semi-major and semi-minor axes. This field is doubled and centered on intersection of area semi-major axis and area semi-minor axis at 90 degrees to the plane defined by those axes. For these shapes, the volume is defined as having a 50-percent probability of containing the true location of the referenced entity.
  ///  Example: /// Example: 7010.882
  ///  Constraints: No constraints specified.
  public var errSemiIntAxis: Double { let o = _accessor.offset(VTOFFSET.errSemiIntAxis.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The error in the Area Orientation.  Area Orientation is the angle or roll in degrees, between area semi-minor axis and plane defined by local vertical and area semi-major axis. When reported without major and minor axis, it is angle between an axis perpendicular to a 2D true north axis and plane defined by local vertical and a 2D true north axis.
  ///  Example: /// Example: 69.6
  ///  Constraints: No constraints specified.
  public var errAreaOrient: Double { let o = _accessor.offset(VTOFFSET.errAreaOrient.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The error in the Semi-major elevation axis. Semi-major elevation axis is the elevation of the cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical semi-major axis, in degrees, measured from local horizontal.
  ///  Example: /// Example: 168.8
  ///  Constraints: No constraints specified.
  public var errSemiMajElev: Double { let o = _accessor.offset(VTOFFSET.errSemiMajElev.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Geometric area switch identifies the 3D shape of the error volume by providing the 2D shape for the 3D plane. The 3D plane is the plane orthogonal to the area semi-major axis and area semi-minor axis. Depending on whether the 2D plane is reported as an error ellipse 2D or as an error rectangle 2D, this switch reports a complete error volume that is cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical.
  ///  0 - SWITCH_TYPE_UNKNOWN
  ///  1 - SQUARE_RECTANGLE
  ///  2 - CIRCLE_ELLIPSE.
  ///  Example: /// Example: CIRCLE_ELLIPSE
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var errGeoAreaSwitch: String? { let o = _accessor.offset(VTOFFSET.errGeoAreaSwitch.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var errGeoAreaSwitchSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.errGeoAreaSwitch.v) }
  ///  Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
  ///  Example: /// Example: 30567.452
  ///  Constraints: No constraints specified.
  public var burnoutAlt: Double { let o = _accessor.offset(VTOFFSET.burnoutAlt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Threat Event System Track ID.
  ///  Example: /// Example: 6217
  ///  Constraints: Minimum length = 0, Maximum length = 8
  public var tesEventId: String? { let o = _accessor.offset(VTOFFSET.tesEventId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var tesEventIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.tesEventId.v) }
  ///  Track object speed, in meters/sec.
  ///  Example: /// Example: 15.03443
  ///  Constraints: No constraints specified.
  public var spd: Double { let o = _accessor.offset(VTOFFSET.spd.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The average speed, in kilometers/hour, calculated for the subject during the latest voyage/excursion.
  ///  Example: /// Example: 18.25
  ///  Constraints: No constraints specified.
  public var avgSpd: Double { let o = _accessor.offset(VTOFFSET.avgSpd.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Motion model Time On Leg in hours.
  ///  Example: /// Example: 4.1
  ///  Constraints: No constraints specified.
  public var tol: Double { let o = _accessor.offset(VTOFFSET.tol.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
  ///  Example: /// Example: 153.01
  ///  Constraints: No constraints specified.
  public var alt: Double { let o = _accessor.offset(VTOFFSET.alt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Track object heading, in degrees clockwise from true north.
  ///  Example: /// Example: 19.7
  ///  Constraints: No constraints specified.
  public var hdng: Double { let o = _accessor.offset(VTOFFSET.hdng.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
  ///  Example: /// Example: 4.3580153
  ///  Constraints: No constraints specified.
  public var course: Double { let o = _accessor.offset(VTOFFSET.course.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The number of propeller revolutions per minute for a submarine or ship.
  ///  Example: /// Example: 8.2
  ///  Constraints: No constraints specified.
  public var propRpm: Double { let o = _accessor.offset(VTOFFSET.propRpm.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The number of turns of the vessel propellers per knot of forward motion.
  ///  Example: /// Example: 2.65
  ///  Constraints: No constraints specified.
  public var tpk: Double { let o = _accessor.offset(VTOFFSET.tpk.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The Cooperative Location Indicator specifies whether the reported entity location was derived using reported locations from sensors on more than one platform.
  ///  0 - COOPERATIVE_LOCATOR_NONE
  ///  1 - SINGLE_PLATFORM
  ///  2 - FRAGMENT
  ///  3 - COOPERATIVE.
  ///  Example: /// Example: COOPERATIVE
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var coopLocInd: String? { let o = _accessor.offset(VTOFFSET.coopLocInd.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var coopLocIndSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.coopLocInd.v) }
  ///  The manuevering indicator specifying the missile boost phase.
  ///  0 - POST_BOOST_NONE
  ///  1 - POST_BOOST_MANUEVER
  ///  2 - POST_BOOST_COMPLETE_MANUEVER.
  ///  Example: /// Example: POST_BOOST_NONE
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var maneuverInd: String? { let o = _accessor.offset(VTOFFSET.maneuverInd.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var maneuverIndSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.maneuverInd.v) }
  ///  The launch location Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the launchAouData array and is required if launchAouData is not null. See the launchAouData field definition for specific information.
  ///  Example: /// Example: ELLIPSE
  ///  Constraints: Minimum length = 0, Maximum length = 20
  public var launchAouType: String? { let o = _accessor.offset(VTOFFSET.launchAouType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var launchAouTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.launchAouType.v) }
  ///  Three element array representing the launch location Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the launchAouType specified in this record:
  ///   ELLIPSE:
  ///     brg - orientation in degrees of the ellipse
  ///     a1 - semi-major axis in meters
  ///     a2 - semi-minor axis in meters
  ///   BEARING (BEARING BOX or MTST BEARING BOX):
  ///     brg - orientation in degrees of the bearing box
  ///     a1 - length of bearing box in meters
  ///     a2 - half-width of bearing box in meters
  ///   OTHER (All other type values):
  ///     brg - line of bearing in degrees true
  ///     a1 - bearing error in degrees
  ///     a2 - estimated range in meters.
  ///  Example: /// Example: [34.3, 26.5, 1.2]
  ///  Constraints: No constraints specified.
  public var hasLaunchAouData: Bool { let o = _accessor.offset(VTOFFSET.launchAouData.v); return o == 0 ? false : true }
  public var launchAouDataCount: Int32 { let o = _accessor.offset(VTOFFSET.launchAouData.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func launchAouData(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.launchAouData.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The impact point Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the impactAouData array and is required if impactAouData is not null. See the impactAouData field definition for specific information.
  ///  Example: /// Example: ELLIPSE
  ///  Constraints: Minimum length = 0, Maximum length = 20
  public var impactAouType: String? { let o = _accessor.offset(VTOFFSET.impactAouType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var impactAouTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.impactAouType.v) }
  ///  Three element array representing the impact point Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the impactAouType specified in this record:
  ///   ELLIPSE:
  ///     brg - orientation in degrees of the ellipse
  ///     a1 - semi-major axis in meters
  ///     a2 - semi-minor axis in meters
  ///   BEARING (BEARING BOX or MTST BEARING BOX):
  ///     brg - orientation in degrees of the bearing box
  ///     a1 - length of bearing box in meters
  ///     a2 - half-width of bearing box in meters
  ///   OTHER (All other type values):
  ///     brg - line of bearing in degrees true
  ///     a1 - bearing error in degrees
  ///     a2 - estimated range in meters.
  ///  Example: /// Example: [34.3, 26.5, 1.2]
  ///  Constraints: No constraints specified.
  public var hasImpactAouData: Bool { let o = _accessor.offset(VTOFFSET.impactAouData.v); return o == 0 ? false : true }
  public var impactAouDataCount: Int32 { let o = _accessor.offset(VTOFFSET.impactAouData.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func impactAouData(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.impactAouData.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The track Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouRptData array and is required if aouRptData is not null. See the aouRptData field definition for specific information.
  ///  Example: /// Example: ELLIPSE
  ///  Constraints: Minimum length = 0, Maximum length = 20
  public var aouRptType: String? { let o = _accessor.offset(VTOFFSET.aouRptType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var aouRptTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.aouRptType.v) }
  ///  Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouRptType specified in this record:
  ///   ELLIPSE:
  ///     brg - orientation in degrees of the ellipse
  ///     a1 - semi-major axis in meters
  ///     a2 - semi-minor axis in meters
  ///   BEARING (BEARING BOX or MTST BEARING BOX):
  ///     brg - orientation in degrees of the bearing box
  ///     a1 - length of bearing box in meters
  ///     a2 - half-width of bearing box in meters
  ///   OTHER (All other type values):
  ///     brg - line of bearing in degrees true
  ///     a1 - bearing error in degrees
  ///     a2 - estimated range in meters.
  ///  Example: /// Example: [34.3, 26.5, 1.2]
  ///  Constraints: No constraints specified.
  public var hasAouRptData: Bool { let o = _accessor.offset(VTOFFSET.aouRptData.v); return o == 0 ? false : true }
  public var aouRptDataCount: Int32 { let o = _accessor.offset(VTOFFSET.aouRptData.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func aouRptData(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.aouRptData.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
  ///  Example: /// Example: [1.23, 2.35, 3.42]
  ///  Constraints: No constraints specified.
  public var hasEcefPos: Bool { let o = _accessor.offset(VTOFFSET.ecefPos.v); return o == 0 ? false : true }
  public var ecefPosCount: Int32 { let o = _accessor.offset(VTOFFSET.ecefPos.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ecefPos(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.ecefPos.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
  ///  Example: /// Example: [1.23, 2.35, 3.42]
  ///  Constraints: No constraints specified.
  public var hasEcefVel: Bool { let o = _accessor.offset(VTOFFSET.ecefVel.v); return o == 0 ? false : true }
  public var ecefVelCount: Int32 { let o = _accessor.offset(VTOFFSET.ecefVel.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ecefVel(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.ecefVel.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
  ///  Example: /// Example: 97
  ///  Constraints: No constraints specified.
  public var containment: Double { let o = _accessor.offset(VTOFFSET.containment.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The distance, in meters, of the closest point of approach between this track to the master reference track.
  ///  Example: /// Example: 500
  ///  Constraints: No constraints specified.
  public var cpa: Double { let o = _accessor.offset(VTOFFSET.cpa.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The time, in ISO 8601 UTC format with millisecond precision, of the  closest point of approach between this track and the master reference track.
  ///  Example: /// Example: 2021-02-25T12:00:00.123Z
  ///  Constraints: No constraints specified.
  public var tcpa: String? { let o = _accessor.offset(VTOFFSET.tcpa.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var tcpaSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.tcpa.v) }
  ///  The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  ///  Example: /// Example: Underway Using Engine
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var navStatus: String? { let o = _accessor.offset(VTOFFSET.navStatus.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var navStatusSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.navStatus.v) }
  ///  The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  ///  Example: /// Example: GPS
  ///  Constraints: Minimum length = 0, Maximum length = 24
  public var posDeviceType: String? { let o = _accessor.offset(VTOFFSET.posDeviceType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var posDeviceTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.posDeviceType.v) }
  ///  Type of Aid to Navigation. Intended as, but not constrained to, the USCG NAVCEN  aids to navigation. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  ///  Example: /// Example: Cardinal Mark N
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var aton: String? { let o = _accessor.offset(VTOFFSET.aton.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var atonSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.aton.v) }
  ///  Indicator position (OFF, ON, UNK) for optional floating navigational aids only.
  ///  Example: /// Example: ON
  ///  Constraints: Minimum length = 0, Maximum length = 3
  public var offPosInd: String? { let o = _accessor.offset(VTOFFSET.offPosInd.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var offPosIndSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.offPosInd.v) }
  ///  The reference dimensions of the vessel, reported as [A, B, C, D], in meters. Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna. Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
  ///  Example: /// Example: [50.1, 50.1, 20.1, 20.1]
  ///  Constraints: No constraints specified.
  public var hasAntennaRefDimensions: Bool { let o = _accessor.offset(VTOFFSET.antennaRefDimensions.v); return o == 0 ? false : true }
  public var antennaRefDimensionsCount: Int32 { let o = _accessor.offset(VTOFFSET.antennaRefDimensions.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func antennaRefDimensions(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.antennaRefDimensions.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  The common name for a group of ships with similar design, usually named for the first vessel of the class.
  ///  Example: /// Example: Nimitz
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var shipClass: String? { let o = _accessor.offset(VTOFFSET.shipClass.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var shipClassSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.shipClass.v) }
  ///  The International Maritime Organization Number of the vessel. IMON is a seven-digit number that uniquely identifies the vessel.
  ///  Example: /// Example: 9015462
  ///  Constraints: No constraints specified.
  public var imon: Int32 { let o = _accessor.offset(VTOFFSET.imon.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The Maritime Mobile Service Identity of the vessel. MMSI is a nine-digit number that identifies the transmitter station of the vessel.
  ///  Example: /// Example: 304010417
  ///  Constraints: No constraints specified.
  public var mmsi: Int32 { let o = _accessor.offset(VTOFFSET.mmsi.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The maximum static draught, in meters, of the vessel according to the AIS transmission.
  ///  Example: /// Example: 21.1
  ///  Constraints: No constraints specified.
  public var draught: Double { let o = _accessor.offset(VTOFFSET.draught.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The overall length of the vessel, in meters. A value of 511 indicates a vessel length of 511 meters or greater.
  ///  Example: /// Example: 511.1
  ///  Constraints: No constraints specified.
  public var length: Double { let o = _accessor.offset(VTOFFSET.length.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The breadth of the vessel, in meters. A value of 63 indicates a vessel breadth of 63 meters or greater.
  ///  Example: /// Example: 24.1
  ///  Constraints: No constraints specified.
  public var width: Double { let o = _accessor.offset(VTOFFSET.width.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  ///  Example: /// Example: Freight
  ///  Constraints: Minimum length = 0, Maximum length = 48
  public var cargoType: String? { let o = _accessor.offset(VTOFFSET.cargoType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var cargoTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.cargoType.v) }
  ///  Appearance group code.
  ///  GP1 - Superstructure exceeds 1/3 of ship length.
  ///  GP2 - Superstructure less than 1/3 of ship length.
  ///  GP3 - Stack aft.
  ///  Example: /// Example: GP1
  ///  Constraints: Minimum length = 0, Maximum length = 7
  public var appGrp: String? { let o = _accessor.offset(VTOFFSET.appGrp.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var appGrpSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.appGrp.v) }
  ///  Hull profile code. Based on GCCS-J hull profiles.
  ///  FLUSH           No breaks in Hull Profile.
  ///  RAISED 1        Hull Profile shows distinct raised area at bow. Remainder of deck is flush.
  ///  RAISED 2        Hull Profile shows distinct raised area amidships. Bow and stern are flush.
  ///  RAISED 3        Hull Profile shows distinct raised area at stern. Remainder of deck is flush.
  ///  RAISED 1-2-3    Distinct raised areas at bow, midships, and stern with breaks between each raise.
  ///  RAISED 1-2      Raised area at bow and midships with break between.
  ///  RAISED 1-3      Raised area at bow and stern with break between.
  ///  RAISED 12       Continuous raised area encompassing both bow and midships.
  ///  RAISED 23       Continuous raised area encompassing midships and stern.
  ///  RAISED 12-3     Raised areas at bow, midships and stern. Bow and midship raises are continuous. Break between midship and stern raises.
  ///  RAISED 1-23     Raised areas at bow, midships, and stern. Midship and stern raises are continuous with break between bow and midship raises.
  ///  RAISED 1-L2-3   Raised areas at bow, midships, and stern with break between each raise. Midships raise is longer than that associated with raised 1-2-3.
  ///  Example: /// Example: Raised 1-23
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var hullProf: String? { let o = _accessor.offset(VTOFFSET.hullProf.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var hullProfSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.hullProf.v) }
  ///  The type of propulsion employed by the track object (Diesel, Nuclear).
  ///  Example: /// Example: Diesel
  ///  Constraints: Minimum length = 0, Maximum length = 6
  public var propType: String? { let o = _accessor.offset(VTOFFSET.propType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var propTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.propType.v) }
  ///  The number of blades per shaft of the track object.  Applicable for maritime vessels.
  ///  Example: /// Example: 4
  ///  Constraints: No constraints specified.
  public var numBlades: Int32 { let o = _accessor.offset(VTOFFSET.numBlades.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The number of shafts on the track object.  Applicable for maritime vessels.
  ///  Example: /// Example: 3
  ///  Constraints: No constraints specified.
  public var numShafts: Int32 { let o = _accessor.offset(VTOFFSET.numShafts.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The stern type code (Counter, Cruiser) associated with the track object.
  ///  Example: /// Example: Cruiser
  ///  Constraints: Minimum length = 0, Maximum length = 16
  public var sternType: String? { let o = _accessor.offset(VTOFFSET.sternType.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sternTypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sternType.v) }
  ///  The weight, in tons, of the vessel associated with this track.
  ///  Example: /// Example: 3423.76
  ///  Constraints: No constraints specified.
  public var vslWt: Double { let o = _accessor.offset(VTOFFSET.vslWt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The Arrival Time of the vessel at the destination, in ISO 8601 UTC format with microsecond precision.
  ///  Example: /// Example: 2021-02-25T12:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var arrTime: String? { let o = _accessor.offset(VTOFFSET.arrTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var arrTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.arrTime.v) }
  ///  The flag of the arrival port.
  ///  Example: /// Example: USA
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var arrFlag: String? { let o = _accessor.offset(VTOFFSET.arrFlag.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var arrFlagSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.arrFlag.v) }
  ///  The reported arrival cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  ///  Example: /// Example: Freight
  ///  Constraints: Minimum length = 0, Maximum length = 48
  public var arrCargo: String? { let o = _accessor.offset(VTOFFSET.arrCargo.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var arrCargoSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.arrCargo.v) }
  ///  The Arrival Port of the vessel according to the AIS transmission.
  ///  Example: /// Example: Lanshan
  ///  Constraints: Minimum length = 0, Maximum length = 20
  public var arrPort: String? { let o = _accessor.offset(VTOFFSET.arrPort.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var arrPortSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.arrPort.v) }
  ///  The Departure Port of the vessel according to the AIS transmission.
  ///  Example: /// Example: Lanshan
  ///  Constraints: Minimum length = 0, Maximum length = 20
  public var depPort: String? { let o = _accessor.offset(VTOFFSET.depPort.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var depPortSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.depPort.v) }
  ///  The flag of the departure port.
  ///  Example: /// Example: USA
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var depFlag: String? { let o = _accessor.offset(VTOFFSET.depFlag.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var depFlagSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.depFlag.v) }
  ///  The reported departure cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  ///  Example: /// Example: Freight
  ///  Constraints: Minimum length = 0, Maximum length = 48
  public var depCargo: String? { let o = _accessor.offset(VTOFFSET.depCargo.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var depCargoSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.depCargo.v) }
  ///  The flag of the destination port.
  ///  Example: /// Example: USA
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var desFlag: String? { let o = _accessor.offset(VTOFFSET.desFlag.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var desFlagSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.desFlag.v) }
  ///  The reported destination cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  ///  Example: /// Example: Freight
  ///  Constraints: Minimum length = 0, Maximum length = 48
  public var desCargo: String? { let o = _accessor.offset(VTOFFSET.desCargo.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var desCargoSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.desCargo.v) }
  ///  The destination of the vessel according to the AIS transmission.
  ///  Example: /// Example: USCLE
  ///  Constraints: Minimum length = 0, Maximum length = 20
  public var destination: String? { let o = _accessor.offset(VTOFFSET.destination.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var destinationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.destination.v) }
  ///  The Estimated Time of Arrival of the vessel at the destination port, in ISO 8601 UTC format with microsecond precision.
  ///  Example: /// Example: 2021-02-25T12:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var eta: String? { let o = _accessor.offset(VTOFFSET.eta.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var etaSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.eta.v) }
  ///  The Estimated Time of Departure of the vessel from the departure port (depPort), according to Marine Traffic calculations, in ISO 8601 UTC format with microsecond precision.
  ///  Example: /// Example: 2021-02-25T12:00:00.123456Z
  ///  Constraints: No constraints specified.
  public var etd: String? { let o = _accessor.offset(VTOFFSET.etd.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var etdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.etd.v) }
  ///  A text amplifier displaying IFF/SIF/AIS Identification modes and codes.
  ///  Example: /// Example: ID Mode
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var iff: String? { let o = _accessor.offset(VTOFFSET.iff.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var iffSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.iff.v) }
  ///  Flag indicating that the track object has an emergency.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var emgInd: Bool { let o = _accessor.offset(VTOFFSET.emgInd.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  The drop-point indicator setting.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var dropPtInd: Bool { let o = _accessor.offset(VTOFFSET.dropPtInd.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var reinforced: Bool { let o = _accessor.offset(VTOFFSET.reinforced.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating for the track represents a reduced force object or group.  Based on MIL-STD-2525 symbology definitions.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var reduced: Bool { let o = _accessor.offset(VTOFFSET.reduced.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var hq: Bool { let o = _accessor.offset(VTOFFSET.hq.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var dummy: Bool { let o = _accessor.offset(VTOFFSET.dummy.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var taskForce: Bool { let o = _accessor.offset(VTOFFSET.taskForce.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var feint: Bool { let o = _accessor.offset(VTOFFSET.feint.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
  ///  Example: /// Example: False
  ///  Constraints: No constraints specified.
  public var installation: Bool { let o = _accessor.offset(VTOFFSET.installation.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  A text amplifier for units, equipment and installations; content is implementation specific.
  ///  Example: /// Example: Staff Comments
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var staffCmts: String? { let o = _accessor.offset(VTOFFSET.staffCmts.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var staffCmtsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.staffCmts.v) }
  ///  A text amplifier for units, equipment and installations; content is implementation specific.
  ///  Example: /// Example: Additional information
  ///  Constraints: Minimum length = 0, Maximum length = 256
  public var addInfo: String? { let o = _accessor.offset(VTOFFSET.addInfo.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var addInfoSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.addInfo.v) }
  ///  A text amplifier code for units, equipment, and installations that consists of a one-letter reliability rating and a one-number credibility rating based on the following definitions of each:
  ///   Reliability Ratings:
  ///    A-completely reliable
  ///    B-usually reliable
  ///    C-fairly reliable
  ///    D-not usually reliable
  ///    E-unreliable
  ///    F-reliability cannot be judged
  ///   Credibility Ratings:
  ///    1-confirmed by other sources
  ///    2-probably true
  ///    3-possibly true
  ///    4-doubtfully true
  ///    5-improbable
  ///    6-truth cannot be judged.
  ///  Example: /// Example: A1
  ///  Constraints: Minimum length = 0, Maximum length = 2
  public var evalRating: String? { let o = _accessor.offset(VTOFFSET.evalRating.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var evalRatingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.evalRating.v) }
  ///  Time the row was created in the database.
  ///  Example: /// Example: 2021-02-25T12:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: TrackDetails_Ingest_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : TrackDetails_Ingest_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  public static func startTrackDetails_Ingest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 158) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(env: TrackDetails_Ingest_env_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: env.rawValue, def: 0, at: VTOFFSET.env.p) }
  public static func add(msgType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: msgType, at: VTOFFSET.msgType.p) }
  public static func add(hullNum: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: hullNum, at: VTOFFSET.hullNum.p) }
  public static func add(pif: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: pif, at: VTOFFSET.pif.p) }
  public static func add(sconum: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sconum, at: VTOFFSET.sconum.p) }
  public static func add(ntds: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ntds, at: VTOFFSET.ntds.p) }
  public static func add(disId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: disId, at: VTOFFSET.disId.p) }
  public static func add(midbCat: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: midbCat, at: VTOFFSET.midbCat.p) }
  public static func add(beNumber: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: beNumber, at: VTOFFSET.beNumber.p) }
  public static func add(oSuffix: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: oSuffix, at: VTOFFSET.oSuffix.p) }
  public static func add(pin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: pin, at: VTOFFSET.pin.p) }
  public static func add(lostTrkInd: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lostTrkInd, def: false,
   at: VTOFFSET.lostTrkInd.p) }
  public static func add(muidSrcTrk: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: muidSrcTrk, at: VTOFFSET.muidSrcTrk.p) }
  public static func add(muidSrc: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: muidSrc, at: VTOFFSET.muidSrc.p) }
  public static func add(mslStatus: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: mslStatus, at: VTOFFSET.mslStatus.p) }
  public static func add(trkConf: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trkConf, def: 0.0, at: VTOFFSET.trkConf.p) }
  public static func add(trkQual: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: trkQual, def: 0, at: VTOFFSET.trkQual.p) }
  public static func add(alert: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: alert, at: VTOFFSET.alert.p) }
  public static func add(origXref: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origXref, at: VTOFFSET.origXref.p) }
  public static func add(elnot1: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: elnot1, at: VTOFFSET.elnot1.p) }
  public static func add(elnot2: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: elnot2, at: VTOFFSET.elnot2.p) }
  public static func add(objIdent: TrackDetails_Ingest_objIdent_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: objIdent.rawValue, def: 0, at: VTOFFSET.objIdent.p) }
  public static func add(objType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: objType, at: VTOFFSET.objType.p) }
  public static func add(objPlat: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: objPlat, at: VTOFFSET.objPlat.p) }
  public static func add(objAct: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: objAct, at: VTOFFSET.objAct.p) }
  public static func add(objNat: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: objNat, at: VTOFFSET.objNat.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(shortName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: shortName, at: VTOFFSET.shortName.p) }
  public static func add(trkId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: trkId, at: VTOFFSET.trkId.p) }
  public static func add(trkNum: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: trkNum, at: VTOFFSET.trkNum.p) }
  public static func add(trkScope: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: trkScope, at: VTOFFSET.trkScope.p) }
  public static func add(sourceUid: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceUid, at: VTOFFSET.sourceUid.p) }
  public static func add(callSign: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: callSign, at: VTOFFSET.callSign.p) }
  public static func add(identAmp: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: identAmp, at: VTOFFSET.identAmp.p) }
  public static func add(spaceAmp: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: spaceAmp, at: VTOFFSET.spaceAmp.p) }
  public static func add(spaceAmpConf: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: spaceAmpConf, def: 0, at: VTOFFSET.spaceAmpConf.p) }
  public static func add(spaceSpecType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: spaceSpecType, at: VTOFFSET.spaceSpecType.p) }
  public static func add(acftSubType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: acftSubType, at: VTOFFSET.acftSubType.p) }
  public static func add(ts: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ts, at: VTOFFSET.ts.p) }
  public static func add(launchTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: launchTime, at: VTOFFSET.launchTime.p) }
  public static func add(impactTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: impactTime, at: VTOFFSET.impactTime.p) }
  public static func add(ftnMsgTs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ftnMsgTs, at: VTOFFSET.ftnMsgTs.p) }
  public static func add(ftn: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ftn, at: VTOFFSET.ftn.p) }
  public static func add(ftnCmd: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ftnCmd, at: VTOFFSET.ftnCmd.p) }
  public static func addVectorOf(rtnMsgTs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rtnMsgTs, at: VTOFFSET.rtnMsgTs.p) }
  public static func addVectorOf(rtn: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rtn, at: VTOFFSET.rtn.p) }
  public static func add(rtnTrkState: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rtnTrkState, at: VTOFFSET.rtnTrkState.p) }
  public static func add(rtnCmd: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rtnCmd, at: VTOFFSET.rtnCmd.p) }
  public static func add(sen: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sen, at: VTOFFSET.sen.p) }
  public static func add(rptChxref: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rptChxref, at: VTOFFSET.rptChxref.p) }
  public static func add(rptArchived: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: rptArchived, def: false,
   at: VTOFFSET.rptArchived.p) }
  public static func add(selfReport: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: selfReport, def: false,
   at: VTOFFSET.selfReport.p) }
  public static func add(mil2525Bstr: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: mil2525Bstr, at: VTOFFSET.mil2525Bstr.p) }
  public static func add(trnspdrId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: trnspdrId, at: VTOFFSET.trnspdrId.p) }
  public static func add(trnspdrType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: trnspdrType, at: VTOFFSET.trnspdrType.p) }
  public static func add(emitterName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: emitterName, at: VTOFFSET.emitterName.p) }
  public static func add(infoSource: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: infoSource, at: VTOFFSET.infoSource.p) }
  public static func add(boosting: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: boosting, def: false,
   at: VTOFFSET.boosting.p) }
  public static func add(freq: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: freq, def: 0.0, at: VTOFFSET.freq.p) }
  public static func add(maxFreq: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maxFreq, def: 0.0, at: VTOFFSET.maxFreq.p) }
  public static func add(harmonics: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: harmonics, at: VTOFFSET.harmonics.p) }
  public static func add(pri: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pri, def: 0.0, at: VTOFFSET.pri.p) }
  public static func add(prf: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: prf, def: 0.0, at: VTOFFSET.prf.p) }
  public static func add(pw: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pw, def: 0.0, at: VTOFFSET.pw.p) }
  public static func add(scanType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: scanType, at: VTOFFSET.scanType.p) }
  public static func add(scanRate: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: scanRate, def: 0.0, at: VTOFFSET.scanRate.p) }
  public static func add(scn: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: scn, def: 0, at: VTOFFSET.scn.p) }
  public static func add(cI: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: cI, at: VTOFFSET.cI.p) }
  public static func add(angElev: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: angElev, def: 0.0, at: VTOFFSET.angElev.p) }
  public static func add(lat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lat, def: 0.0, at: VTOFFSET.lat.p) }
  public static func add(lon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: lon, def: 0.0, at: VTOFFSET.lon.p) }
  public static func add(launchLat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: launchLat, def: 0.0, at: VTOFFSET.launchLat.p) }
  public static func add(launchLon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: launchLon, def: 0.0, at: VTOFFSET.launchLon.p) }
  public static func add(impactLat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: impactLat, def: 0.0, at: VTOFFSET.impactLat.p) }
  public static func add(impactLon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: impactLon, def: 0.0, at: VTOFFSET.impactLon.p) }
  public static func add(polarSingLocLat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: polarSingLocLat, def: 0.0, at: VTOFFSET.polarSingLocLat.p) }
  public static func add(polarSingLocLon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: polarSingLocLon, def: 0.0, at: VTOFFSET.polarSingLocLon.p) }
  public static func add(azCorrCenterLine: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: azCorrCenterLine, def: 0.0, at: VTOFFSET.azCorrCenterLine.p) }
  public static func add(azCorrArcWidth: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: azCorrArcWidth, def: 0.0, at: VTOFFSET.azCorrArcWidth.p) }
  public static func add(errSemiIntAxis: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: errSemiIntAxis, def: 0.0, at: VTOFFSET.errSemiIntAxis.p) }
  public static func add(errAreaOrient: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: errAreaOrient, def: 0.0, at: VTOFFSET.errAreaOrient.p) }
  public static func add(errSemiMajElev: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: errSemiMajElev, def: 0.0, at: VTOFFSET.errSemiMajElev.p) }
  public static func add(errGeoAreaSwitch: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: errGeoAreaSwitch, at: VTOFFSET.errGeoAreaSwitch.p) }
  public static func add(burnoutAlt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: burnoutAlt, def: 0.0, at: VTOFFSET.burnoutAlt.p) }
  public static func add(tesEventId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tesEventId, at: VTOFFSET.tesEventId.p) }
  public static func add(spd: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: spd, def: 0.0, at: VTOFFSET.spd.p) }
  public static func add(avgSpd: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: avgSpd, def: 0.0, at: VTOFFSET.avgSpd.p) }
  public static func add(tol: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tol, def: 0.0, at: VTOFFSET.tol.p) }
  public static func add(alt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: alt, def: 0.0, at: VTOFFSET.alt.p) }
  public static func add(hdng: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hdng, def: 0.0, at: VTOFFSET.hdng.p) }
  public static func add(course: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: course, def: 0.0, at: VTOFFSET.course.p) }
  public static func add(propRpm: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: propRpm, def: 0.0, at: VTOFFSET.propRpm.p) }
  public static func add(tpk: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tpk, def: 0.0, at: VTOFFSET.tpk.p) }
  public static func add(coopLocInd: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: coopLocInd, at: VTOFFSET.coopLocInd.p) }
  public static func add(maneuverInd: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: maneuverInd, at: VTOFFSET.maneuverInd.p) }
  public static func add(launchAouType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: launchAouType, at: VTOFFSET.launchAouType.p) }
  public static func addVectorOf(launchAouData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: launchAouData, at: VTOFFSET.launchAouData.p) }
  public static func add(impactAouType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: impactAouType, at: VTOFFSET.impactAouType.p) }
  public static func addVectorOf(impactAouData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: impactAouData, at: VTOFFSET.impactAouData.p) }
  public static func add(aouRptType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: aouRptType, at: VTOFFSET.aouRptType.p) }
  public static func addVectorOf(aouRptData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: aouRptData, at: VTOFFSET.aouRptData.p) }
  public static func addVectorOf(ecefPos: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ecefPos, at: VTOFFSET.ecefPos.p) }
  public static func addVectorOf(ecefVel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ecefVel, at: VTOFFSET.ecefVel.p) }
  public static func add(containment: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: containment, def: 0.0, at: VTOFFSET.containment.p) }
  public static func add(cpa: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cpa, def: 0.0, at: VTOFFSET.cpa.p) }
  public static func add(tcpa: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tcpa, at: VTOFFSET.tcpa.p) }
  public static func add(navStatus: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: navStatus, at: VTOFFSET.navStatus.p) }
  public static func add(posDeviceType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: posDeviceType, at: VTOFFSET.posDeviceType.p) }
  public static func add(aton: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: aton, at: VTOFFSET.aton.p) }
  public static func add(offPosInd: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: offPosInd, at: VTOFFSET.offPosInd.p) }
  public static func addVectorOf(antennaRefDimensions: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: antennaRefDimensions, at: VTOFFSET.antennaRefDimensions.p) }
  public static func add(shipClass: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: shipClass, at: VTOFFSET.shipClass.p) }
  public static func add(imon: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: imon, def: 0, at: VTOFFSET.imon.p) }
  public static func add(mmsi: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mmsi, def: 0, at: VTOFFSET.mmsi.p) }
  public static func add(draught: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: draught, def: 0.0, at: VTOFFSET.draught.p) }
  public static func add(length: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: length, def: 0.0, at: VTOFFSET.length.p) }
  public static func add(width: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: width, def: 0.0, at: VTOFFSET.width.p) }
  public static func add(cargoType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: cargoType, at: VTOFFSET.cargoType.p) }
  public static func add(appGrp: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: appGrp, at: VTOFFSET.appGrp.p) }
  public static func add(hullProf: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: hullProf, at: VTOFFSET.hullProf.p) }
  public static func add(propType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: propType, at: VTOFFSET.propType.p) }
  public static func add(numBlades: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numBlades, def: 0, at: VTOFFSET.numBlades.p) }
  public static func add(numShafts: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numShafts, def: 0, at: VTOFFSET.numShafts.p) }
  public static func add(sternType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sternType, at: VTOFFSET.sternType.p) }
  public static func add(vslWt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: vslWt, def: 0.0, at: VTOFFSET.vslWt.p) }
  public static func add(arrTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arrTime, at: VTOFFSET.arrTime.p) }
  public static func add(arrFlag: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arrFlag, at: VTOFFSET.arrFlag.p) }
  public static func add(arrCargo: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arrCargo, at: VTOFFSET.arrCargo.p) }
  public static func add(arrPort: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arrPort, at: VTOFFSET.arrPort.p) }
  public static func add(depPort: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: depPort, at: VTOFFSET.depPort.p) }
  public static func add(depFlag: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: depFlag, at: VTOFFSET.depFlag.p) }
  public static func add(depCargo: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: depCargo, at: VTOFFSET.depCargo.p) }
  public static func add(desFlag: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: desFlag, at: VTOFFSET.desFlag.p) }
  public static func add(desCargo: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: desCargo, at: VTOFFSET.desCargo.p) }
  public static func add(destination: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: destination, at: VTOFFSET.destination.p) }
  public static func add(eta: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: eta, at: VTOFFSET.eta.p) }
  public static func add(etd: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: etd, at: VTOFFSET.etd.p) }
  public static func add(iff: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: iff, at: VTOFFSET.iff.p) }
  public static func add(emgInd: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: emgInd, def: false,
   at: VTOFFSET.emgInd.p) }
  public static func add(dropPtInd: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dropPtInd, def: false,
   at: VTOFFSET.dropPtInd.p) }
  public static func add(reinforced: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: reinforced, def: false,
   at: VTOFFSET.reinforced.p) }
  public static func add(reduced: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: reduced, def: false,
   at: VTOFFSET.reduced.p) }
  public static func add(hq: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hq, def: false,
   at: VTOFFSET.hq.p) }
  public static func add(dummy: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dummy, def: false,
   at: VTOFFSET.dummy.p) }
  public static func add(taskForce: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: taskForce, def: false,
   at: VTOFFSET.taskForce.p) }
  public static func add(feint: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: feint, def: false,
   at: VTOFFSET.feint.p) }
  public static func add(installation: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: installation, def: false,
   at: VTOFFSET.installation.p) }
  public static func add(staffCmts: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: staffCmts, at: VTOFFSET.staffCmts.p) }
  public static func add(addInfo: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: addInfo, at: VTOFFSET.addInfo.p) }
  public static func add(evalRating: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: evalRating, at: VTOFFSET.evalRating.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(dataMode: TrackDetails_Ingest_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func endTrackDetails_Ingest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTrackDetails_Ingest(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    env: TrackDetails_Ingest_env_Enum = .air,
    msgTypeOffset msgType: Offset = Offset(),
    hullNumOffset hullNum: Offset = Offset(),
    pifOffset pif: Offset = Offset(),
    sconumOffset sconum: Offset = Offset(),
    ntdsOffset ntds: Offset = Offset(),
    disIdOffset disId: Offset = Offset(),
    midbCatOffset midbCat: Offset = Offset(),
    beNumberOffset beNumber: Offset = Offset(),
    oSuffixOffset oSuffix: Offset = Offset(),
    pinOffset pin: Offset = Offset(),
    lostTrkInd: Bool = false,
    muidSrcTrkOffset muidSrcTrk: Offset = Offset(),
    muidSrcOffset muidSrc: Offset = Offset(),
    mslStatusOffset mslStatus: Offset = Offset(),
    trkConf: Double = 0.0,
    trkQual: Int32 = 0,
    alertOffset alert: Offset = Offset(),
    origXrefOffset origXref: Offset = Offset(),
    elnot1Offset elnot1: Offset = Offset(),
    elnot2Offset elnot2: Offset = Offset(),
    objIdent: TrackDetails_Ingest_objIdent_Enum = .assumedFriend,
    objTypeOffset objType: Offset = Offset(),
    objPlatOffset objPlat: Offset = Offset(),
    objActOffset objAct: Offset = Offset(),
    objNatOffset objNat: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    shortNameOffset shortName: Offset = Offset(),
    trkIdOffset trkId: Offset = Offset(),
    trkNumOffset trkNum: Offset = Offset(),
    trkScopeOffset trkScope: Offset = Offset(),
    sourceUidOffset sourceUid: Offset = Offset(),
    callSignOffset callSign: Offset = Offset(),
    identAmpOffset identAmp: Offset = Offset(),
    spaceAmpOffset spaceAmp: Offset = Offset(),
    spaceAmpConf: Int32 = 0,
    spaceSpecTypeOffset spaceSpecType: Offset = Offset(),
    acftSubTypeOffset acftSubType: Offset = Offset(),
    tsOffset ts: Offset = Offset(),
    launchTimeOffset launchTime: Offset = Offset(),
    impactTimeOffset impactTime: Offset = Offset(),
    ftnMsgTsOffset ftnMsgTs: Offset = Offset(),
    ftnOffset ftn: Offset = Offset(),
    ftnCmdOffset ftnCmd: Offset = Offset(),
    rtnMsgTsVectorOffset rtnMsgTs: Offset = Offset(),
    rtnVectorOffset rtn: Offset = Offset(),
    rtnTrkStateOffset rtnTrkState: Offset = Offset(),
    rtnCmdOffset rtnCmd: Offset = Offset(),
    senOffset sen: Offset = Offset(),
    rptChxrefOffset rptChxref: Offset = Offset(),
    rptArchived: Bool = false,
    selfReport: Bool = false,
    mil2525BstrOffset mil2525Bstr: Offset = Offset(),
    trnspdrIdOffset trnspdrId: Offset = Offset(),
    trnspdrTypeOffset trnspdrType: Offset = Offset(),
    emitterNameOffset emitterName: Offset = Offset(),
    infoSourceOffset infoSource: Offset = Offset(),
    boosting: Bool = false,
    freq: Double = 0.0,
    maxFreq: Double = 0.0,
    harmonicsOffset harmonics: Offset = Offset(),
    pri: Double = 0.0,
    prf: Double = 0.0,
    pw: Double = 0.0,
    scanTypeOffset scanType: Offset = Offset(),
    scanRate: Double = 0.0,
    scn: Int32 = 0,
    cIOffset cI: Offset = Offset(),
    angElev: Double = 0.0,
    lat: Double = 0.0,
    lon: Double = 0.0,
    launchLat: Double = 0.0,
    launchLon: Double = 0.0,
    impactLat: Double = 0.0,
    impactLon: Double = 0.0,
    polarSingLocLat: Double = 0.0,
    polarSingLocLon: Double = 0.0,
    azCorrCenterLine: Double = 0.0,
    azCorrArcWidth: Double = 0.0,
    errSemiIntAxis: Double = 0.0,
    errAreaOrient: Double = 0.0,
    errSemiMajElev: Double = 0.0,
    errGeoAreaSwitchOffset errGeoAreaSwitch: Offset = Offset(),
    burnoutAlt: Double = 0.0,
    tesEventIdOffset tesEventId: Offset = Offset(),
    spd: Double = 0.0,
    avgSpd: Double = 0.0,
    tol: Double = 0.0,
    alt: Double = 0.0,
    hdng: Double = 0.0,
    course: Double = 0.0,
    propRpm: Double = 0.0,
    tpk: Double = 0.0,
    coopLocIndOffset coopLocInd: Offset = Offset(),
    maneuverIndOffset maneuverInd: Offset = Offset(),
    launchAouTypeOffset launchAouType: Offset = Offset(),
    launchAouDataVectorOffset launchAouData: Offset = Offset(),
    impactAouTypeOffset impactAouType: Offset = Offset(),
    impactAouDataVectorOffset impactAouData: Offset = Offset(),
    aouRptTypeOffset aouRptType: Offset = Offset(),
    aouRptDataVectorOffset aouRptData: Offset = Offset(),
    ecefPosVectorOffset ecefPos: Offset = Offset(),
    ecefVelVectorOffset ecefVel: Offset = Offset(),
    containment: Double = 0.0,
    cpa: Double = 0.0,
    tcpaOffset tcpa: Offset = Offset(),
    navStatusOffset navStatus: Offset = Offset(),
    posDeviceTypeOffset posDeviceType: Offset = Offset(),
    atonOffset aton: Offset = Offset(),
    offPosIndOffset offPosInd: Offset = Offset(),
    antennaRefDimensionsVectorOffset antennaRefDimensions: Offset = Offset(),
    shipClassOffset shipClass: Offset = Offset(),
    imon: Int32 = 0,
    mmsi: Int32 = 0,
    draught: Double = 0.0,
    length: Double = 0.0,
    width: Double = 0.0,
    cargoTypeOffset cargoType: Offset = Offset(),
    appGrpOffset appGrp: Offset = Offset(),
    hullProfOffset hullProf: Offset = Offset(),
    propTypeOffset propType: Offset = Offset(),
    numBlades: Int32 = 0,
    numShafts: Int32 = 0,
    sternTypeOffset sternType: Offset = Offset(),
    vslWt: Double = 0.0,
    arrTimeOffset arrTime: Offset = Offset(),
    arrFlagOffset arrFlag: Offset = Offset(),
    arrCargoOffset arrCargo: Offset = Offset(),
    arrPortOffset arrPort: Offset = Offset(),
    depPortOffset depPort: Offset = Offset(),
    depFlagOffset depFlag: Offset = Offset(),
    depCargoOffset depCargo: Offset = Offset(),
    desFlagOffset desFlag: Offset = Offset(),
    desCargoOffset desCargo: Offset = Offset(),
    destinationOffset destination: Offset = Offset(),
    etaOffset eta: Offset = Offset(),
    etdOffset etd: Offset = Offset(),
    iffOffset iff: Offset = Offset(),
    emgInd: Bool = false,
    dropPtInd: Bool = false,
    reinforced: Bool = false,
    reduced: Bool = false,
    hq: Bool = false,
    dummy: Bool = false,
    taskForce: Bool = false,
    feint: Bool = false,
    installation: Bool = false,
    staffCmtsOffset staffCmts: Offset = Offset(),
    addInfoOffset addInfo: Offset = Offset(),
    evalRatingOffset evalRating: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    dataMode: TrackDetails_Ingest_dataMode_Enum = .real,
    origNetworkOffset origNetwork: Offset = Offset()
  ) -> Offset {
    let __start = TrackDetails_Ingest.startTrackDetails_Ingest(&fbb)
    TrackDetails_Ingest.add(id: id, &fbb)
    TrackDetails_Ingest.add(classificationMarking: classificationMarking, &fbb)
    TrackDetails_Ingest.add(env: env, &fbb)
    TrackDetails_Ingest.add(msgType: msgType, &fbb)
    TrackDetails_Ingest.add(hullNum: hullNum, &fbb)
    TrackDetails_Ingest.add(pif: pif, &fbb)
    TrackDetails_Ingest.add(sconum: sconum, &fbb)
    TrackDetails_Ingest.add(ntds: ntds, &fbb)
    TrackDetails_Ingest.add(disId: disId, &fbb)
    TrackDetails_Ingest.add(midbCat: midbCat, &fbb)
    TrackDetails_Ingest.add(beNumber: beNumber, &fbb)
    TrackDetails_Ingest.add(oSuffix: oSuffix, &fbb)
    TrackDetails_Ingest.add(pin: pin, &fbb)
    TrackDetails_Ingest.add(lostTrkInd: lostTrkInd, &fbb)
    TrackDetails_Ingest.add(muidSrcTrk: muidSrcTrk, &fbb)
    TrackDetails_Ingest.add(muidSrc: muidSrc, &fbb)
    TrackDetails_Ingest.add(mslStatus: mslStatus, &fbb)
    TrackDetails_Ingest.add(trkConf: trkConf, &fbb)
    TrackDetails_Ingest.add(trkQual: trkQual, &fbb)
    TrackDetails_Ingest.add(alert: alert, &fbb)
    TrackDetails_Ingest.add(origXref: origXref, &fbb)
    TrackDetails_Ingest.add(elnot1: elnot1, &fbb)
    TrackDetails_Ingest.add(elnot2: elnot2, &fbb)
    TrackDetails_Ingest.add(objIdent: objIdent, &fbb)
    TrackDetails_Ingest.add(objType: objType, &fbb)
    TrackDetails_Ingest.add(objPlat: objPlat, &fbb)
    TrackDetails_Ingest.add(objAct: objAct, &fbb)
    TrackDetails_Ingest.add(objNat: objNat, &fbb)
    TrackDetails_Ingest.add(name: name, &fbb)
    TrackDetails_Ingest.add(shortName: shortName, &fbb)
    TrackDetails_Ingest.add(trkId: trkId, &fbb)
    TrackDetails_Ingest.add(trkNum: trkNum, &fbb)
    TrackDetails_Ingest.add(trkScope: trkScope, &fbb)
    TrackDetails_Ingest.add(sourceUid: sourceUid, &fbb)
    TrackDetails_Ingest.add(callSign: callSign, &fbb)
    TrackDetails_Ingest.add(identAmp: identAmp, &fbb)
    TrackDetails_Ingest.add(spaceAmp: spaceAmp, &fbb)
    TrackDetails_Ingest.add(spaceAmpConf: spaceAmpConf, &fbb)
    TrackDetails_Ingest.add(spaceSpecType: spaceSpecType, &fbb)
    TrackDetails_Ingest.add(acftSubType: acftSubType, &fbb)
    TrackDetails_Ingest.add(ts: ts, &fbb)
    TrackDetails_Ingest.add(launchTime: launchTime, &fbb)
    TrackDetails_Ingest.add(impactTime: impactTime, &fbb)
    TrackDetails_Ingest.add(ftnMsgTs: ftnMsgTs, &fbb)
    TrackDetails_Ingest.add(ftn: ftn, &fbb)
    TrackDetails_Ingest.add(ftnCmd: ftnCmd, &fbb)
    TrackDetails_Ingest.addVectorOf(rtnMsgTs: rtnMsgTs, &fbb)
    TrackDetails_Ingest.addVectorOf(rtn: rtn, &fbb)
    TrackDetails_Ingest.add(rtnTrkState: rtnTrkState, &fbb)
    TrackDetails_Ingest.add(rtnCmd: rtnCmd, &fbb)
    TrackDetails_Ingest.add(sen: sen, &fbb)
    TrackDetails_Ingest.add(rptChxref: rptChxref, &fbb)
    TrackDetails_Ingest.add(rptArchived: rptArchived, &fbb)
    TrackDetails_Ingest.add(selfReport: selfReport, &fbb)
    TrackDetails_Ingest.add(mil2525Bstr: mil2525Bstr, &fbb)
    TrackDetails_Ingest.add(trnspdrId: trnspdrId, &fbb)
    TrackDetails_Ingest.add(trnspdrType: trnspdrType, &fbb)
    TrackDetails_Ingest.add(emitterName: emitterName, &fbb)
    TrackDetails_Ingest.add(infoSource: infoSource, &fbb)
    TrackDetails_Ingest.add(boosting: boosting, &fbb)
    TrackDetails_Ingest.add(freq: freq, &fbb)
    TrackDetails_Ingest.add(maxFreq: maxFreq, &fbb)
    TrackDetails_Ingest.add(harmonics: harmonics, &fbb)
    TrackDetails_Ingest.add(pri: pri, &fbb)
    TrackDetails_Ingest.add(prf: prf, &fbb)
    TrackDetails_Ingest.add(pw: pw, &fbb)
    TrackDetails_Ingest.add(scanType: scanType, &fbb)
    TrackDetails_Ingest.add(scanRate: scanRate, &fbb)
    TrackDetails_Ingest.add(scn: scn, &fbb)
    TrackDetails_Ingest.add(cI: cI, &fbb)
    TrackDetails_Ingest.add(angElev: angElev, &fbb)
    TrackDetails_Ingest.add(lat: lat, &fbb)
    TrackDetails_Ingest.add(lon: lon, &fbb)
    TrackDetails_Ingest.add(launchLat: launchLat, &fbb)
    TrackDetails_Ingest.add(launchLon: launchLon, &fbb)
    TrackDetails_Ingest.add(impactLat: impactLat, &fbb)
    TrackDetails_Ingest.add(impactLon: impactLon, &fbb)
    TrackDetails_Ingest.add(polarSingLocLat: polarSingLocLat, &fbb)
    TrackDetails_Ingest.add(polarSingLocLon: polarSingLocLon, &fbb)
    TrackDetails_Ingest.add(azCorrCenterLine: azCorrCenterLine, &fbb)
    TrackDetails_Ingest.add(azCorrArcWidth: azCorrArcWidth, &fbb)
    TrackDetails_Ingest.add(errSemiIntAxis: errSemiIntAxis, &fbb)
    TrackDetails_Ingest.add(errAreaOrient: errAreaOrient, &fbb)
    TrackDetails_Ingest.add(errSemiMajElev: errSemiMajElev, &fbb)
    TrackDetails_Ingest.add(errGeoAreaSwitch: errGeoAreaSwitch, &fbb)
    TrackDetails_Ingest.add(burnoutAlt: burnoutAlt, &fbb)
    TrackDetails_Ingest.add(tesEventId: tesEventId, &fbb)
    TrackDetails_Ingest.add(spd: spd, &fbb)
    TrackDetails_Ingest.add(avgSpd: avgSpd, &fbb)
    TrackDetails_Ingest.add(tol: tol, &fbb)
    TrackDetails_Ingest.add(alt: alt, &fbb)
    TrackDetails_Ingest.add(hdng: hdng, &fbb)
    TrackDetails_Ingest.add(course: course, &fbb)
    TrackDetails_Ingest.add(propRpm: propRpm, &fbb)
    TrackDetails_Ingest.add(tpk: tpk, &fbb)
    TrackDetails_Ingest.add(coopLocInd: coopLocInd, &fbb)
    TrackDetails_Ingest.add(maneuverInd: maneuverInd, &fbb)
    TrackDetails_Ingest.add(launchAouType: launchAouType, &fbb)
    TrackDetails_Ingest.addVectorOf(launchAouData: launchAouData, &fbb)
    TrackDetails_Ingest.add(impactAouType: impactAouType, &fbb)
    TrackDetails_Ingest.addVectorOf(impactAouData: impactAouData, &fbb)
    TrackDetails_Ingest.add(aouRptType: aouRptType, &fbb)
    TrackDetails_Ingest.addVectorOf(aouRptData: aouRptData, &fbb)
    TrackDetails_Ingest.addVectorOf(ecefPos: ecefPos, &fbb)
    TrackDetails_Ingest.addVectorOf(ecefVel: ecefVel, &fbb)
    TrackDetails_Ingest.add(containment: containment, &fbb)
    TrackDetails_Ingest.add(cpa: cpa, &fbb)
    TrackDetails_Ingest.add(tcpa: tcpa, &fbb)
    TrackDetails_Ingest.add(navStatus: navStatus, &fbb)
    TrackDetails_Ingest.add(posDeviceType: posDeviceType, &fbb)
    TrackDetails_Ingest.add(aton: aton, &fbb)
    TrackDetails_Ingest.add(offPosInd: offPosInd, &fbb)
    TrackDetails_Ingest.addVectorOf(antennaRefDimensions: antennaRefDimensions, &fbb)
    TrackDetails_Ingest.add(shipClass: shipClass, &fbb)
    TrackDetails_Ingest.add(imon: imon, &fbb)
    TrackDetails_Ingest.add(mmsi: mmsi, &fbb)
    TrackDetails_Ingest.add(draught: draught, &fbb)
    TrackDetails_Ingest.add(length: length, &fbb)
    TrackDetails_Ingest.add(width: width, &fbb)
    TrackDetails_Ingest.add(cargoType: cargoType, &fbb)
    TrackDetails_Ingest.add(appGrp: appGrp, &fbb)
    TrackDetails_Ingest.add(hullProf: hullProf, &fbb)
    TrackDetails_Ingest.add(propType: propType, &fbb)
    TrackDetails_Ingest.add(numBlades: numBlades, &fbb)
    TrackDetails_Ingest.add(numShafts: numShafts, &fbb)
    TrackDetails_Ingest.add(sternType: sternType, &fbb)
    TrackDetails_Ingest.add(vslWt: vslWt, &fbb)
    TrackDetails_Ingest.add(arrTime: arrTime, &fbb)
    TrackDetails_Ingest.add(arrFlag: arrFlag, &fbb)
    TrackDetails_Ingest.add(arrCargo: arrCargo, &fbb)
    TrackDetails_Ingest.add(arrPort: arrPort, &fbb)
    TrackDetails_Ingest.add(depPort: depPort, &fbb)
    TrackDetails_Ingest.add(depFlag: depFlag, &fbb)
    TrackDetails_Ingest.add(depCargo: depCargo, &fbb)
    TrackDetails_Ingest.add(desFlag: desFlag, &fbb)
    TrackDetails_Ingest.add(desCargo: desCargo, &fbb)
    TrackDetails_Ingest.add(destination: destination, &fbb)
    TrackDetails_Ingest.add(eta: eta, &fbb)
    TrackDetails_Ingest.add(etd: etd, &fbb)
    TrackDetails_Ingest.add(iff: iff, &fbb)
    TrackDetails_Ingest.add(emgInd: emgInd, &fbb)
    TrackDetails_Ingest.add(dropPtInd: dropPtInd, &fbb)
    TrackDetails_Ingest.add(reinforced: reinforced, &fbb)
    TrackDetails_Ingest.add(reduced: reduced, &fbb)
    TrackDetails_Ingest.add(hq: hq, &fbb)
    TrackDetails_Ingest.add(dummy: dummy, &fbb)
    TrackDetails_Ingest.add(taskForce: taskForce, &fbb)
    TrackDetails_Ingest.add(feint: feint, &fbb)
    TrackDetails_Ingest.add(installation: installation, &fbb)
    TrackDetails_Ingest.add(staffCmts: staffCmts, &fbb)
    TrackDetails_Ingest.add(addInfo: addInfo, &fbb)
    TrackDetails_Ingest.add(evalRating: evalRating, &fbb)
    TrackDetails_Ingest.add(createdAt: createdAt, &fbb)
    TrackDetails_Ingest.add(createdBy: createdBy, &fbb)
    TrackDetails_Ingest.add(source: source, &fbb)
    TrackDetails_Ingest.add(origin: origin, &fbb)
    TrackDetails_Ingest.add(dataMode: dataMode, &fbb)
    TrackDetails_Ingest.add(origNetwork: origNetwork, &fbb)
    return TrackDetails_Ingest.endTrackDetails_Ingest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.env.p, fieldName: "env", required: false, type: TrackDetails_Ingest_env_Enum.self)
    try _v.visit(field: VTOFFSET.msgType.p, fieldName: "msgType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.hullNum.p, fieldName: "hullNum", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.pif.p, fieldName: "pif", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sconum.p, fieldName: "sconum", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ntds.p, fieldName: "ntds", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.disId.p, fieldName: "disId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.midbCat.p, fieldName: "midbCat", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.beNumber.p, fieldName: "beNumber", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.oSuffix.p, fieldName: "oSuffix", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.pin.p, fieldName: "pin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.lostTrkInd.p, fieldName: "lostTrkInd", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.muidSrcTrk.p, fieldName: "muidSrcTrk", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.muidSrc.p, fieldName: "muidSrc", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.mslStatus.p, fieldName: "mslStatus", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.trkConf.p, fieldName: "trkConf", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.trkQual.p, fieldName: "trkQual", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.alert.p, fieldName: "alert", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origXref.p, fieldName: "origXref", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.elnot1.p, fieldName: "elnot1", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.elnot2.p, fieldName: "elnot2", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.objIdent.p, fieldName: "objIdent", required: false, type: TrackDetails_Ingest_objIdent_Enum.self)
    try _v.visit(field: VTOFFSET.objType.p, fieldName: "objType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.objPlat.p, fieldName: "objPlat", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.objAct.p, fieldName: "objAct", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.objNat.p, fieldName: "objNat", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.shortName.p, fieldName: "shortName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.trkId.p, fieldName: "trkId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.trkNum.p, fieldName: "trkNum", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.trkScope.p, fieldName: "trkScope", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceUid.p, fieldName: "sourceUid", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.callSign.p, fieldName: "callSign", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.identAmp.p, fieldName: "identAmp", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.spaceAmp.p, fieldName: "spaceAmp", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.spaceAmpConf.p, fieldName: "spaceAmpConf", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.spaceSpecType.p, fieldName: "spaceSpecType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.acftSubType.p, fieldName: "acftSubType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ts.p, fieldName: "ts", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.launchTime.p, fieldName: "launchTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.impactTime.p, fieldName: "impactTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ftnMsgTs.p, fieldName: "ftnMsgTs", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ftn.p, fieldName: "ftn", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ftnCmd.p, fieldName: "ftnCmd", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rtnMsgTs.p, fieldName: "rtnMsgTs", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.rtn.p, fieldName: "rtn", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.rtnTrkState.p, fieldName: "rtnTrkState", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rtnCmd.p, fieldName: "rtnCmd", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sen.p, fieldName: "sen", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rptChxref.p, fieldName: "rptChxref", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rptArchived.p, fieldName: "rptArchived", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.selfReport.p, fieldName: "selfReport", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.mil2525Bstr.p, fieldName: "mil2525Bstr", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.trnspdrId.p, fieldName: "trnspdrId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.trnspdrType.p, fieldName: "trnspdrType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.emitterName.p, fieldName: "emitterName", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.infoSource.p, fieldName: "infoSource", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.boosting.p, fieldName: "boosting", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.freq.p, fieldName: "freq", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.maxFreq.p, fieldName: "maxFreq", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.harmonics.p, fieldName: "harmonics", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.pri.p, fieldName: "pri", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.prf.p, fieldName: "prf", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.pw.p, fieldName: "pw", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.scanType.p, fieldName: "scanType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.scanRate.p, fieldName: "scanRate", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.scn.p, fieldName: "scn", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.cI.p, fieldName: "cI", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.angElev.p, fieldName: "angElev", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.lat.p, fieldName: "lat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.lon.p, fieldName: "lon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.launchLat.p, fieldName: "launchLat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.launchLon.p, fieldName: "launchLon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.impactLat.p, fieldName: "impactLat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.impactLon.p, fieldName: "impactLon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.polarSingLocLat.p, fieldName: "polarSingLocLat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.polarSingLocLon.p, fieldName: "polarSingLocLon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.azCorrCenterLine.p, fieldName: "azCorrCenterLine", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.azCorrArcWidth.p, fieldName: "azCorrArcWidth", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.errSemiIntAxis.p, fieldName: "errSemiIntAxis", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.errAreaOrient.p, fieldName: "errAreaOrient", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.errSemiMajElev.p, fieldName: "errSemiMajElev", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.errGeoAreaSwitch.p, fieldName: "errGeoAreaSwitch", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.burnoutAlt.p, fieldName: "burnoutAlt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.tesEventId.p, fieldName: "tesEventId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.spd.p, fieldName: "spd", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.avgSpd.p, fieldName: "avgSpd", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.tol.p, fieldName: "tol", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.alt.p, fieldName: "alt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.hdng.p, fieldName: "hdng", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.course.p, fieldName: "course", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.propRpm.p, fieldName: "propRpm", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.tpk.p, fieldName: "tpk", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.coopLocInd.p, fieldName: "coopLocInd", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.maneuverInd.p, fieldName: "maneuverInd", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.launchAouType.p, fieldName: "launchAouType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.launchAouData.p, fieldName: "launchAouData", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.impactAouType.p, fieldName: "impactAouType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.impactAouData.p, fieldName: "impactAouData", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.aouRptType.p, fieldName: "aouRptType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.aouRptData.p, fieldName: "aouRptData", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.ecefPos.p, fieldName: "ecefPos", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.ecefVel.p, fieldName: "ecefVel", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.containment.p, fieldName: "containment", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.cpa.p, fieldName: "cpa", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.tcpa.p, fieldName: "tcpa", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.navStatus.p, fieldName: "navStatus", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.posDeviceType.p, fieldName: "posDeviceType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.aton.p, fieldName: "aton", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.offPosInd.p, fieldName: "offPosInd", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.antennaRefDimensions.p, fieldName: "antennaRefDimensions", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.shipClass.p, fieldName: "shipClass", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.imon.p, fieldName: "imon", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.mmsi.p, fieldName: "mmsi", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.draught.p, fieldName: "draught", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.length.p, fieldName: "length", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.width.p, fieldName: "width", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.cargoType.p, fieldName: "cargoType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.appGrp.p, fieldName: "appGrp", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.hullProf.p, fieldName: "hullProf", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.propType.p, fieldName: "propType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.numBlades.p, fieldName: "numBlades", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.numShafts.p, fieldName: "numShafts", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.sternType.p, fieldName: "sternType", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.vslWt.p, fieldName: "vslWt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.arrTime.p, fieldName: "arrTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.arrFlag.p, fieldName: "arrFlag", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.arrCargo.p, fieldName: "arrCargo", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.arrPort.p, fieldName: "arrPort", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.depPort.p, fieldName: "depPort", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.depFlag.p, fieldName: "depFlag", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.depCargo.p, fieldName: "depCargo", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.desFlag.p, fieldName: "desFlag", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.desCargo.p, fieldName: "desCargo", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.destination.p, fieldName: "destination", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.eta.p, fieldName: "eta", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.etd.p, fieldName: "etd", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.iff.p, fieldName: "iff", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.emgInd.p, fieldName: "emgInd", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.dropPtInd.p, fieldName: "dropPtInd", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.reinforced.p, fieldName: "reinforced", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.reduced.p, fieldName: "reduced", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.hq.p, fieldName: "hq", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.dummy.p, fieldName: "dummy", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.taskForce.p, fieldName: "taskForce", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.feint.p, fieldName: "feint", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.installation.p, fieldName: "installation", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.staffCmts.p, fieldName: "staffCmts", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.addInfo.p, fieldName: "addInfo", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.evalRating.p, fieldName: "evalRating", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: TrackDetails_Ingest_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

