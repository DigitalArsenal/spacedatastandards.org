// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum RFGeoLocation_Full_dataMode_Enum: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  case real = 0
  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  case test = 1
  ///  Synthetic data generated by a model to mimic real-world datasets.
  case simulated = 2
  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  case exercise = 3

  public static var max: RFGeoLocation_Full_dataMode_Enum { return .exercise }
  public static var min: RFGeoLocation_Full_dataMode_Enum { return .real }
}


///  /// Model representation of geolocation data for a radio frequency (RF) signal or emitter.
public struct RFGeoLocation_Full: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "RFGE" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: RFGeoLocation_Full.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case classificationMarking = 6
    case orderId = 8
    case createdTs = 10
    case receivedTs = 12
    case startTime = 14
    case endTime = 16
    case idOnOrbit = 18
    case satNo = 20
    case origObjectId = 22
    case constellation = 24
    case signalOfInterest = 26
    case idRfemitter = 28
    case origRfemitterId = 30
    case numBursts = 32
    case minFreq = 34
    case maxFreq = 36
    case centerFreq = 38
    case detectLat = 40
    case detectLon = 42
    case detectAlt = 44
    case confSemiMajor = 46
    case confSemiMinor = 48
    case confOrientation = 50
    case confArea = 52
    case atype = 54
    case agjson = 56
    case atext = 58
    case area = 60
    case andims = 62
    case asrid = 64
    case passGroupId = 66
    case algVersion = 68
    case externalId = 70
    case tags = 72
    case createdAt = 74
    case createdBy = 76
    case source = 78
    case origin = 80
    case origNetwork = 82
    case sourceDl = 84
    case dataMode = 86
    case onOrbit = 88
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  public var classificationMarking: String? { let o = _accessor.offset(VTOFFSET.classificationMarking.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var classificationMarkingSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.classificationMarking.v) }
  ///  The order identifier for this RF Geo Location data set.
  ///  Example: /// Example: 155240
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var orderId: String? { let o = _accessor.offset(VTOFFSET.orderId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var orderIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.orderId.v) }
  ///  Specifies the creation time associated with the order in ISO 8601 UTC with microsecond precision.
  ///  Example: /// Example: 2024-05-31T23:06:18.123456Z
  ///  Constraints: No constraints specified.
  public var createdTs: String? { let o = _accessor.offset(VTOFFSET.createdTs.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdTsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdTs.v) }
  ///  The time representing the mean of the constituent single-burst observations in ISO 8601 UTC with microsecond precision.
  ///  Example: /// Example: 2024-05-31T21:16:58.123456Z
  ///  Constraints: No constraints specified.
  public var receivedTs: String? { let o = _accessor.offset(VTOFFSET.receivedTs.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var receivedTsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.receivedTs.v) }
  ///  The order start time for this RF Geo Location data set in ISO 8601 UTC with microsecond precision.
  ///  Example: /// Example: 2024-05-31T21:12:12.123456Z
  ///  Constraints: No constraints specified.
  public var startTime: String? { let o = _accessor.offset(VTOFFSET.startTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var startTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.startTime.v) }
  ///  The order end time for this RF Geo Location data set in ISO 8601 UTC with microsecond precision.
  ///  Example: /// Example: 2024-05-31T21:16:15.123456Z
  ///  Constraints: No constraints specified.
  public var endTime: String? { let o = _accessor.offset(VTOFFSET.endTime.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var endTimeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.endTime.v) }
  ///  Unique identifier of the satellite used to identify and geolocate RF signals of interest. This ID can be used to obtain additional information on an OnOrbit object using the 'get by ID' operation (e.g. /udl/onorbit/{id}). For example, the onorbit object with idOnOrbit = abc would be queried as /udl/onorbit/abc.
  ///  Example: /// Example: HawkEye360-7
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idOnOrbit: String? { let o = _accessor.offset(VTOFFSET.idOnOrbit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idOnOrbitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idOnOrbit.v) }
  ///  Satellite/catalog number of the target on-orbit object.
  ///  Example: /// Example: 101
  ///  Constraints: No constraints specified.
  public var satNo: Int32 { let o = _accessor.offset(VTOFFSET.satNo.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Optional identifier of the satellite used to identify and geolocate RF signals of interest of this observation. This may be an internal identifier and not necessarily a valid satellite number.
  ///  Example: /// Example: ORIGOBJECT-ID
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origObjectId: String? { let o = _accessor.offset(VTOFFSET.origObjectId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origObjectIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origObjectId.v) }
  ///  The name of the satellite constellation.
  ///  Example: /// Example: HawkEye360
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var constellation: String? { let o = _accessor.offset(VTOFFSET.constellation.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var constellationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.constellation.v) }
  ///  The name of the signal of interest.
  ///  Example: /// Example: GPS
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var signalOfInterest: String? { let o = _accessor.offset(VTOFFSET.signalOfInterest.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var signalOfInterestSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.signalOfInterest.v) }
  ///  Optional identifier of the geolocated signal of interest RF Emitter for this observation. This ID can be used to obtain additional information on an RF Emitter object using the 'get by ID' operation (e.g. /udl/rfemitter/{id}). For example, the rfemitter object with idRFEmitter = abc would be queried as /udl/rfemitter/abc.
  ///  Example: /// Example: RFEMITTER-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var idRfemitter: String? { let o = _accessor.offset(VTOFFSET.idRfemitter.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idRfemitterSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.idRfemitter.v) }
  ///  Optional identifier of the emitter of interest for this observation. This may be an internal identifier and not necessarily a valid emitter Id.
  ///  Example: /// Example: ORIGRFEMITTER-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var origRfemitterId: String? { let o = _accessor.offset(VTOFFSET.origRfemitterId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origRfemitterIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origRfemitterId.v) }
  ///  The count of single-burst observations used for this geolocation observation.
  ///  Example: /// Example: 17
  ///  Constraints: No constraints specified.
  public var numBursts: Int32 { let o = _accessor.offset(VTOFFSET.numBursts.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  The minimum detected frequency in megahertz.
  ///  Example: /// Example: 1575.42
  ///  Constraints: No constraints specified.
  public var minFreq: Double { let o = _accessor.offset(VTOFFSET.minFreq.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The maximum detected frequency in megahertz.
  ///  Example: /// Example: 1575.42
  ///  Constraints: No constraints specified.
  public var maxFreq: Double { let o = _accessor.offset(VTOFFSET.maxFreq.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The detected signal frequency in megahertz.
  ///  Example: /// Example: 1575.42
  ///  Constraints: No constraints specified.
  public var centerFreq: Double { let o = _accessor.offset(VTOFFSET.centerFreq.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 latitude of the most likely emitter location coordinate point, in degrees. -90 to 90 degrees (negative values south of equator).
  ///  Example: /// Example: 41.172
  ///  Constraints: No constraints specified.
  public var detectLat: Double { let o = _accessor.offset(VTOFFSET.detectLat.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  WGS-84 longitude of the most likely emitter location coordinate point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  ///  Example: /// Example: 37.019
  ///  Constraints: No constraints specified.
  public var detectLon: Double { let o = _accessor.offset(VTOFFSET.detectLon.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The altitude relative to WGS-84 ellipsoid, in meters.
  ///  Example: /// Example: 123.456
  ///  Constraints: No constraints specified.
  public var detectAlt: Double { let o = _accessor.offset(VTOFFSET.detectAlt.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Confidence ellipse semi-major axis about the detection location lat/lon point measured in meters.
  ///  Example: /// Example: 9435.896
  ///  Constraints: No constraints specified.
  public var confSemiMajor: Double { let o = _accessor.offset(VTOFFSET.confSemiMajor.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Confidence ellipse semi-minor axis about the detection location lat/lon point measured in meters.
  ///  Example: /// Example: 2751.929
  ///  Constraints: No constraints specified.
  public var confSemiMinor: Double { let o = _accessor.offset(VTOFFSET.confSemiMinor.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Confidence ellipse orientation of semi-major axis about the detection location lat/lon point measured in degrees.
  ///  Example: /// Example: 89.852
  ///  Constraints: No constraints specified.
  public var confOrientation: Double { let o = _accessor.offset(VTOFFSET.confOrientation.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  The area of the confidence ellipse specified in meters squared to contain the emitter with a 95% probability.
  ///  Example: /// Example: 81577480.056
  ///  Constraints: No constraints specified.
  public var confArea: Double { let o = _accessor.offset(VTOFFSET.confArea.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Type of region as projected on the ground.
  ///  Example: /// Example: MultiPolygon
  ///  Constraints: Minimum length = 0, Maximum length = 128
  public var atype: String? { let o = _accessor.offset(VTOFFSET.atype.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var atypeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.atype.v) }
  ///  Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
  ///  Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
  ///  Constraints: No constraints specified.
  public var agjson: String? { let o = _accessor.offset(VTOFFSET.agjson.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var agjsonSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.agjson.v) }
  ///  Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
  ///  Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  ///  Constraints: No constraints specified.
  public var atext: String? { let o = _accessor.offset(VTOFFSET.atext.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var atextSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.atext.v) }
  ///  Optional geographical region or polygon (lat/lon pairs) of the area surrounding the Point of Interest as projected on the ground.
  ///  Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  ///  Constraints: No constraints specified.
  public var area: String? { let o = _accessor.offset(VTOFFSET.area.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var areaSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.area.v) }
  ///  Number of dimensions of the geometry depicted by region.
  ///  Example: /// Example: 3
  ///  Constraints: No constraints specified.
  public var andims: Int32 { let o = _accessor.offset(VTOFFSET.andims.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Geographical spatial_ref_sys for region.
  ///  Example: /// Example: 3
  ///  Constraints: No constraints specified.
  public var asrid: Int32 { let o = _accessor.offset(VTOFFSET.asrid.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Optional external identifier referencing the entity used in the calculation of the geolocation.
  ///  Example: /// Example: 80fd25a8-8b41-448d-888a-91c9dfcd940b
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var passGroupId: String? { let o = _accessor.offset(VTOFFSET.passGroupId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var passGroupIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.passGroupId.v) }
  ///  The RFGeo algorithm type and version used in geolocation calculations.
  ///  Example: /// Example: v1.0-3-gps_nb_3ball
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var algVersion: String? { let o = _accessor.offset(VTOFFSET.algVersion.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var algVersionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.algVersion.v) }
  ///  Optional ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  ///  Example: /// Example: 780180925
  ///  Constraints: Minimum length = 0, Maximum length = 36
  public var externalId: String? { let o = _accessor.offset(VTOFFSET.externalId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var externalIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.externalId.v) }
  ///  Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  ///  Example: /// Example: ['TAG1', 'TAG2']
  ///  Constraints: No constraints specified.
  public var hasTags: Bool { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? false : true }
  public var tagsCount: Int32 { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tags(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  public var createdAt: String? { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdAt.v) }
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  public var createdBy: String? { let o = _accessor.offset(VTOFFSET.createdBy.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var createdBySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.createdBy.v) }
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 36
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  ///  Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  ///  Example: /// Example: THIRD_PARTY_DATASOURCE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var origin: String? { let o = _accessor.offset(VTOFFSET.origin.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var originSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origin.v) }
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: OPS1
  ///  Constraints: Minimum length = 0, Maximum length = 32
  public var origNetwork: String? { let o = _accessor.offset(VTOFFSET.origNetwork.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var origNetworkSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.origNetwork.v) }
  ///  The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  ///  Example: /// Example: AXE
  ///  Constraints: Minimum length = 0, Maximum length = 64
  public var sourceDl: String? { let o = _accessor.offset(VTOFFSET.sourceDl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceDlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sourceDl.v) }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  public var dataMode: RFGeoLocation_Full_dataMode_Enum { let o = _accessor.offset(VTOFFSET.dataMode.v); return o == 0 ? .real : RFGeoLocation_Full_dataMode_Enum(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .real }
  ///  No description provided.
  ///  Example: /// Example: No example provided.
  ///  Constraints: No constraints specified.
  public var onOrbit: String? { let o = _accessor.offset(VTOFFSET.onOrbit.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var onOrbitSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.onOrbit.v) }
  public static func startRFGeoLocation_Full(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 43) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(classificationMarking: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: classificationMarking, at: VTOFFSET.classificationMarking.p) }
  public static func add(orderId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: orderId, at: VTOFFSET.orderId.p) }
  public static func add(createdTs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdTs, at: VTOFFSET.createdTs.p) }
  public static func add(receivedTs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: receivedTs, at: VTOFFSET.receivedTs.p) }
  public static func add(startTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startTime, at: VTOFFSET.startTime.p) }
  public static func add(endTime: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: endTime, at: VTOFFSET.endTime.p) }
  public static func add(idOnOrbit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idOnOrbit, at: VTOFFSET.idOnOrbit.p) }
  public static func add(satNo: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: satNo, def: 0, at: VTOFFSET.satNo.p) }
  public static func add(origObjectId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origObjectId, at: VTOFFSET.origObjectId.p) }
  public static func add(constellation: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: constellation, at: VTOFFSET.constellation.p) }
  public static func add(signalOfInterest: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: signalOfInterest, at: VTOFFSET.signalOfInterest.p) }
  public static func add(idRfemitter: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: idRfemitter, at: VTOFFSET.idRfemitter.p) }
  public static func add(origRfemitterId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origRfemitterId, at: VTOFFSET.origRfemitterId.p) }
  public static func add(numBursts: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numBursts, def: 0, at: VTOFFSET.numBursts.p) }
  public static func add(minFreq: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: minFreq, def: 0.0, at: VTOFFSET.minFreq.p) }
  public static func add(maxFreq: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maxFreq, def: 0.0, at: VTOFFSET.maxFreq.p) }
  public static func add(centerFreq: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: centerFreq, def: 0.0, at: VTOFFSET.centerFreq.p) }
  public static func add(detectLat: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: detectLat, def: 0.0, at: VTOFFSET.detectLat.p) }
  public static func add(detectLon: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: detectLon, def: 0.0, at: VTOFFSET.detectLon.p) }
  public static func add(detectAlt: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: detectAlt, def: 0.0, at: VTOFFSET.detectAlt.p) }
  public static func add(confSemiMajor: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: confSemiMajor, def: 0.0, at: VTOFFSET.confSemiMajor.p) }
  public static func add(confSemiMinor: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: confSemiMinor, def: 0.0, at: VTOFFSET.confSemiMinor.p) }
  public static func add(confOrientation: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: confOrientation, def: 0.0, at: VTOFFSET.confOrientation.p) }
  public static func add(confArea: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: confArea, def: 0.0, at: VTOFFSET.confArea.p) }
  public static func add(atype: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: atype, at: VTOFFSET.atype.p) }
  public static func add(agjson: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: agjson, at: VTOFFSET.agjson.p) }
  public static func add(atext: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: atext, at: VTOFFSET.atext.p) }
  public static func add(area: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: area, at: VTOFFSET.area.p) }
  public static func add(andims: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: andims, def: 0, at: VTOFFSET.andims.p) }
  public static func add(asrid: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asrid, def: 0, at: VTOFFSET.asrid.p) }
  public static func add(passGroupId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: passGroupId, at: VTOFFSET.passGroupId.p) }
  public static func add(algVersion: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: algVersion, at: VTOFFSET.algVersion.p) }
  public static func add(externalId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: externalId, at: VTOFFSET.externalId.p) }
  public static func addVectorOf(tags: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tags, at: VTOFFSET.tags.p) }
  public static func add(createdAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdAt, at: VTOFFSET.createdAt.p) }
  public static func add(createdBy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: createdBy, at: VTOFFSET.createdBy.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(origin: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origin, at: VTOFFSET.origin.p) }
  public static func add(origNetwork: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: origNetwork, at: VTOFFSET.origNetwork.p) }
  public static func add(sourceDl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sourceDl, at: VTOFFSET.sourceDl.p) }
  public static func add(dataMode: RFGeoLocation_Full_dataMode_Enum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dataMode.rawValue, def: 0, at: VTOFFSET.dataMode.p) }
  public static func add(onOrbit: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: onOrbit, at: VTOFFSET.onOrbit.p) }
  public static func endRFGeoLocation_Full(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRFGeoLocation_Full(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    classificationMarkingOffset classificationMarking: Offset = Offset(),
    orderIdOffset orderId: Offset = Offset(),
    createdTsOffset createdTs: Offset = Offset(),
    receivedTsOffset receivedTs: Offset = Offset(),
    startTimeOffset startTime: Offset = Offset(),
    endTimeOffset endTime: Offset = Offset(),
    idOnOrbitOffset idOnOrbit: Offset = Offset(),
    satNo: Int32 = 0,
    origObjectIdOffset origObjectId: Offset = Offset(),
    constellationOffset constellation: Offset = Offset(),
    signalOfInterestOffset signalOfInterest: Offset = Offset(),
    idRfemitterOffset idRfemitter: Offset = Offset(),
    origRfemitterIdOffset origRfemitterId: Offset = Offset(),
    numBursts: Int32 = 0,
    minFreq: Double = 0.0,
    maxFreq: Double = 0.0,
    centerFreq: Double = 0.0,
    detectLat: Double = 0.0,
    detectLon: Double = 0.0,
    detectAlt: Double = 0.0,
    confSemiMajor: Double = 0.0,
    confSemiMinor: Double = 0.0,
    confOrientation: Double = 0.0,
    confArea: Double = 0.0,
    atypeOffset atype: Offset = Offset(),
    agjsonOffset agjson: Offset = Offset(),
    atextOffset atext: Offset = Offset(),
    areaOffset area: Offset = Offset(),
    andims: Int32 = 0,
    asrid: Int32 = 0,
    passGroupIdOffset passGroupId: Offset = Offset(),
    algVersionOffset algVersion: Offset = Offset(),
    externalIdOffset externalId: Offset = Offset(),
    tagsVectorOffset tags: Offset = Offset(),
    createdAtOffset createdAt: Offset = Offset(),
    createdByOffset createdBy: Offset = Offset(),
    sourceOffset source: Offset = Offset(),
    originOffset origin: Offset = Offset(),
    origNetworkOffset origNetwork: Offset = Offset(),
    sourceDlOffset sourceDl: Offset = Offset(),
    dataMode: RFGeoLocation_Full_dataMode_Enum = .real,
    onOrbitOffset onOrbit: Offset = Offset()
  ) -> Offset {
    let __start = RFGeoLocation_Full.startRFGeoLocation_Full(&fbb)
    RFGeoLocation_Full.add(id: id, &fbb)
    RFGeoLocation_Full.add(classificationMarking: classificationMarking, &fbb)
    RFGeoLocation_Full.add(orderId: orderId, &fbb)
    RFGeoLocation_Full.add(createdTs: createdTs, &fbb)
    RFGeoLocation_Full.add(receivedTs: receivedTs, &fbb)
    RFGeoLocation_Full.add(startTime: startTime, &fbb)
    RFGeoLocation_Full.add(endTime: endTime, &fbb)
    RFGeoLocation_Full.add(idOnOrbit: idOnOrbit, &fbb)
    RFGeoLocation_Full.add(satNo: satNo, &fbb)
    RFGeoLocation_Full.add(origObjectId: origObjectId, &fbb)
    RFGeoLocation_Full.add(constellation: constellation, &fbb)
    RFGeoLocation_Full.add(signalOfInterest: signalOfInterest, &fbb)
    RFGeoLocation_Full.add(idRfemitter: idRfemitter, &fbb)
    RFGeoLocation_Full.add(origRfemitterId: origRfemitterId, &fbb)
    RFGeoLocation_Full.add(numBursts: numBursts, &fbb)
    RFGeoLocation_Full.add(minFreq: minFreq, &fbb)
    RFGeoLocation_Full.add(maxFreq: maxFreq, &fbb)
    RFGeoLocation_Full.add(centerFreq: centerFreq, &fbb)
    RFGeoLocation_Full.add(detectLat: detectLat, &fbb)
    RFGeoLocation_Full.add(detectLon: detectLon, &fbb)
    RFGeoLocation_Full.add(detectAlt: detectAlt, &fbb)
    RFGeoLocation_Full.add(confSemiMajor: confSemiMajor, &fbb)
    RFGeoLocation_Full.add(confSemiMinor: confSemiMinor, &fbb)
    RFGeoLocation_Full.add(confOrientation: confOrientation, &fbb)
    RFGeoLocation_Full.add(confArea: confArea, &fbb)
    RFGeoLocation_Full.add(atype: atype, &fbb)
    RFGeoLocation_Full.add(agjson: agjson, &fbb)
    RFGeoLocation_Full.add(atext: atext, &fbb)
    RFGeoLocation_Full.add(area: area, &fbb)
    RFGeoLocation_Full.add(andims: andims, &fbb)
    RFGeoLocation_Full.add(asrid: asrid, &fbb)
    RFGeoLocation_Full.add(passGroupId: passGroupId, &fbb)
    RFGeoLocation_Full.add(algVersion: algVersion, &fbb)
    RFGeoLocation_Full.add(externalId: externalId, &fbb)
    RFGeoLocation_Full.addVectorOf(tags: tags, &fbb)
    RFGeoLocation_Full.add(createdAt: createdAt, &fbb)
    RFGeoLocation_Full.add(createdBy: createdBy, &fbb)
    RFGeoLocation_Full.add(source: source, &fbb)
    RFGeoLocation_Full.add(origin: origin, &fbb)
    RFGeoLocation_Full.add(origNetwork: origNetwork, &fbb)
    RFGeoLocation_Full.add(sourceDl: sourceDl, &fbb)
    RFGeoLocation_Full.add(dataMode: dataMode, &fbb)
    RFGeoLocation_Full.add(onOrbit: onOrbit, &fbb)
    return RFGeoLocation_Full.endRFGeoLocation_Full(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.classificationMarking.p, fieldName: "classificationMarking", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.orderId.p, fieldName: "orderId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdTs.p, fieldName: "createdTs", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.receivedTs.p, fieldName: "receivedTs", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.startTime.p, fieldName: "startTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.endTime.p, fieldName: "endTime", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idOnOrbit.p, fieldName: "idOnOrbit", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.satNo.p, fieldName: "satNo", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.origObjectId.p, fieldName: "origObjectId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.constellation.p, fieldName: "constellation", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.signalOfInterest.p, fieldName: "signalOfInterest", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idRfemitter.p, fieldName: "idRfemitter", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origRfemitterId.p, fieldName: "origRfemitterId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.numBursts.p, fieldName: "numBursts", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.minFreq.p, fieldName: "minFreq", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.maxFreq.p, fieldName: "maxFreq", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.centerFreq.p, fieldName: "centerFreq", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.detectLat.p, fieldName: "detectLat", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.detectLon.p, fieldName: "detectLon", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.detectAlt.p, fieldName: "detectAlt", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.confSemiMajor.p, fieldName: "confSemiMajor", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.confSemiMinor.p, fieldName: "confSemiMinor", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.confOrientation.p, fieldName: "confOrientation", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.confArea.p, fieldName: "confArea", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.atype.p, fieldName: "atype", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.agjson.p, fieldName: "agjson", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.atext.p, fieldName: "atext", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.area.p, fieldName: "area", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.andims.p, fieldName: "andims", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.asrid.p, fieldName: "asrid", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.passGroupId.p, fieldName: "passGroupId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.algVersion.p, fieldName: "algVersion", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.externalId.p, fieldName: "externalId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.tags.p, fieldName: "tags", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.createdBy.p, fieldName: "createdBy", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origin.p, fieldName: "origin", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.origNetwork.p, fieldName: "origNetwork", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sourceDl.p, fieldName: "sourceDl", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.dataMode.p, fieldName: "dataMode", required: false, type: RFGeoLocation_Full_dataMode_Enum.self)
    try _v.visit(field: VTOFFSET.onOrbit.p, fieldName: "onOrbit", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

