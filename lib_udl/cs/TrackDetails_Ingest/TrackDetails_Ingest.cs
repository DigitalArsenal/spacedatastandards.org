// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// These services provide operations for querying of all available track details and amplifying track data. A track is a position and optionally a heading/velocity of an object such as an aircraft, marine vessel, etc at a particular timestamp. It also includes optional information regarding the identity/type of the target object and other amplifying object data, if known.
public struct TrackDetails_Ingest : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static TrackDetails_Ingest GetRootAsTrackDetails_Ingest(ByteBuffer _bb) { return GetRootAsTrackDetails_Ingest(_bb, new TrackDetails_Ingest()); }
  public static TrackDetails_Ingest GetRootAsTrackDetails_Ingest(ByteBuffer _bb, TrackDetails_Ingest obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool TrackDetails_IngestBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "TRAC"); }
  public static bool VerifyTrackDetails_Ingest(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("TRAC", false, TrackDetails_IngestVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TrackDetails_Ingest __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: TRACK-DETAILS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string Id { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetIdBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetIdArray() { return __p.__vector_as_array<byte>(4); }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  public string ClassificationMarking { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetClassificationMarkingBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetClassificationMarkingBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetClassificationMarkingArray() { return __p.__vector_as_array<byte>(6); }
  /// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
  ///  AIR: Between sea level and the K치rm치n line, which has an altitude of 100 kilometers (62 miles).
  ///  LAND: On the surface of dry land.
  ///  SPACE: Above the K치rm치n line, which has an altitude of 100 kilometers (62 miles).
  ///  SURFACE: On the surface of a body of water.
  ///  SUBSURFACE: Below the surface of a body of water.
  ///  UNKNOWN: Environment is not known.
  /// Example: /// Example: LAND
  /// Constraints: Minimum length = 0, Maximum length = 16
  public TrackDetails_Ingest_env_Enum Env { get { int o = __p.__offset(8); return o != 0 ? (TrackDetails_Ingest_env_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : TrackDetails_Ingest_env_Enum.AIR; } }
  /// Optional message type designation.
  /// Example: /// Example: PLATFORM
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string MsgType { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMsgTypeBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetMsgTypeBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetMsgTypeArray() { return __p.__vector_as_array<byte>(10); }
  /// The vessel hull number designation of this maritime vessel.  The hull number is a 1-6 character alphanumeric entry assigned to a ship and painted on the hull.
  /// Example: /// Example: A30081
  /// Constraints: Minimum length = 0, Maximum length = 7
  public string HullNum { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetHullNumBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetHullNumBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetHullNumArray() { return __p.__vector_as_array<byte>(12); }
  /// The Pseudo Identification Feature (PIF) number is a four digit code that provides an exact ID for the ship or aircraft. Friendly military only.
  /// Example: /// Example: 0137
  /// Constraints: Minimum length = 0, Maximum length = 5
  public string Pif { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPifBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetPifBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetPifArray() { return __p.__vector_as_array<byte>(14); }
  /// The Ship Control Number (SCONUM) is a naval vessel identification number (alphanumeric code) assigned by the Office of Naval Intelligence. SCONUM is sometimes referred to as NOIC ID. SCONUMs are typically of the form A#####, where A is an alpha character and # is numerical.
  /// Example: /// Example: B45524
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string Sconum { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSconumBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetSconumBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetSconumArray() { return __p.__vector_as_array<byte>(16); }
  /// The Naval Tactical Data System (NTDS) track number assigned to this track.
  /// Example: /// Example: ZZ777
  /// Constraints: Minimum length = 0, Maximum length = 6
  public string Ntds { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNtdsBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetNtdsBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetNtdsArray() { return __p.__vector_as_array<byte>(18); }
  /// The Intel Discrete Identifier (IDI) code assigned to this track.  The IDI is a four-digit code representing hostile or unknown tracks.
  /// Example: /// Example: 7670
  /// Constraints: Minimum length = 0, Maximum length = 5
  public string DisId { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDisIdBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetDisIdBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetDisIdArray() { return __p.__vector_as_array<byte>(20); }
  /// The category code that represents the associated facility purpose within the target system.  This value is the category code in the MIDB (Modernized Intelligence Database).
  /// Example: /// Example: 20345
  /// Constraints: Minimum length = 0, Maximum length = 6
  public string MidbCat { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMidbCatBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetMidbCatBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetMidbCatArray() { return __p.__vector_as_array<byte>(22); }
  /// The Basic Encyclopedia (BE) number associated with this installation or area.
  /// Example: /// Example: ENC-123
  /// Constraints: Minimum length = 0, Maximum length = 10
  public string BeNumber { get { int o = __p.__offset(24); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBeNumberBytes() { return __p.__vector_as_span<byte>(24, 1); }
#else
  public ArraySegment<byte>? GetBeNumberBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public byte[] GetBeNumberArray() { return __p.__vector_as_array<byte>(24); }
  /// The O-suffix associated with this facility.  The O-suffix is a five-character alpha/numeric system used to identify a facility, or demographic area, within an installation. The Installation Basic Encyclopedia (beNumber), in conjunction with the O-suffix, uniquely identifies the facility within the Modernized Integrated Database (MIDB).  The Installation beNumber and oSuffix are also used in conjunction with the midbCat code to classify the function or purpose of the facility.
  /// Example: /// Example: AA125
  /// Constraints: Minimum length = 0, Maximum length = 6
  public string OSuffix { get { int o = __p.__offset(26); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOSuffixBytes() { return __p.__vector_as_span<byte>(26, 1); }
#else
  public ArraySegment<byte>? GetOSuffixBytes() { return __p.__vector_as_arraysegment(26); }
#endif
  public byte[] GetOSuffixArray() { return __p.__vector_as_array<byte>(26); }
  /// This value represents the site number of a specific electronic site or its associated equipment.
  /// Example: /// Example: E12345012
  /// Constraints: Minimum length = 0, Maximum length = 9
  public string Pin { get { int o = __p.__offset(28); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPinBytes() { return __p.__vector_as_span<byte>(28, 1); }
#else
  public ArraySegment<byte>? GetPinBytes() { return __p.__vector_as_arraysegment(28); }
#endif
  public byte[] GetPinArray() { return __p.__vector_as_array<byte>(28); }
  /// Flag indicating whether the missile is considered lost, if reporting a missile track.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool LostTrkInd { get { int o = __p.__offset(30); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Track ID for the source of the Missile-Unique Identifier (MUID), if reporting a missile track.
  /// Example: /// Example: MUID-SRC-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string MuidSrcTrk { get { int o = __p.__offset(32); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMuidSrcTrkBytes() { return __p.__vector_as_span<byte>(32, 1); }
#else
  public ArraySegment<byte>? GetMuidSrcTrkBytes() { return __p.__vector_as_arraysegment(32); }
#endif
  public byte[] GetMuidSrcTrkArray() { return __p.__vector_as_array<byte>(32); }
  /// Source of the Missile-Unique Identifier (MUID), if reporting a missile track.
  /// Example: /// Example: MUID-SRC
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string MuidSrc { get { int o = __p.__offset(34); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMuidSrcBytes() { return __p.__vector_as_span<byte>(34, 1); }
#else
  public ArraySegment<byte>? GetMuidSrcBytes() { return __p.__vector_as_arraysegment(34); }
#endif
  public byte[] GetMuidSrcArray() { return __p.__vector_as_array<byte>(34); }
  /// The status of the missile track in this record, if reporting a missile track (e.g. AT LAUNCH, AT OBSERVATION, FLYING, IMPACTED, LOST, STALE, DEBRIS).
  /// Example: /// Example: AT LAUNCH
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string MslStatus { get { int o = __p.__offset(36); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMslStatusBytes() { return __p.__vector_as_span<byte>(36, 1); }
#else
  public ArraySegment<byte>? GetMslStatusBytes() { return __p.__vector_as_arraysegment(36); }
#endif
  public byte[] GetMslStatusArray() { return __p.__vector_as_array<byte>(36); }
  /// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
  /// Example: /// Example: 0.95
  /// Constraints: No constraints specified.
  public double TrkConf { get { int o = __p.__offset(38); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track; Higher values indicate higher track quality, i.e., lower errors in reported position.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  public int TrkQual { get { int o = __p.__offset(40); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// A track may be designated as an alert track with the following designations:
  /// HIT - High Interest Track
  /// TGT - Target
  /// SUS - Suspect Carrier
  /// NSP - Cleared Suspect
  /// If alert is null, the track is assumed to be of non-alert status.
  /// Example: /// Example: TGT
  /// Constraints: Minimum length = 0, Maximum length = 3
  public string Alert { get { int o = __p.__offset(42); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAlertBytes() { return __p.__vector_as_span<byte>(42, 1); }
#else
  public ArraySegment<byte>? GetAlertBytes() { return __p.__vector_as_arraysegment(42); }
#endif
  public byte[] GetAlertArray() { return __p.__vector_as_array<byte>(42); }
  /// Original source cross-reference code for the Command that originated the report.
  /// Example: /// Example: INT
  /// Constraints: Minimum length = 0, Maximum length = 5
  public string OrigXref { get { int o = __p.__offset(44); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOrigXrefBytes() { return __p.__vector_as_span<byte>(44, 1); }
#else
  public ArraySegment<byte>? GetOrigXrefBytes() { return __p.__vector_as_arraysegment(44); }
#endif
  public byte[] GetOrigXrefArray() { return __p.__vector_as_array<byte>(44); }
  /// Primary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
  /// Example: /// Example: A123A
  /// Constraints: Minimum length = 0, Maximum length = 5
  public string Elnot1 { get { int o = __p.__offset(46); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetElnot1Bytes() { return __p.__vector_as_span<byte>(46, 1); }
#else
  public ArraySegment<byte>? GetElnot1Bytes() { return __p.__vector_as_arraysegment(46); }
#endif
  public byte[] GetElnot1Array() { return __p.__vector_as_array<byte>(46); }
  /// Secondary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
  /// Example: /// Example: A123B
  /// Constraints: Minimum length = 0, Maximum length = 5
  public string Elnot2 { get { int o = __p.__offset(48); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetElnot2Bytes() { return __p.__vector_as_span<byte>(48, 1); }
#else
  public ArraySegment<byte>? GetElnot2Bytes() { return __p.__vector_as_arraysegment(48); }
#endif
  public byte[] GetElnot2Array() { return __p.__vector_as_array<byte>(48); }
  /// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
  ///  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  ///  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  ///  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  ///  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  ///  PENDING: Track object which has not been evaluated.
  ///  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  ///  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
  /// Example: /// Example: FRIEND
  /// Constraints: Minimum length = 0, Maximum length = 32
  public TrackDetails_Ingest_objIdent_Enum ObjIdent { get { int o = __p.__offset(50); return o != 0 ? (TrackDetails_Ingest_objIdent_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : TrackDetails_Ingest_objIdent_Enum.ASSUMED_FRIEND; } }
  /// The generic classification of the track object/group (e.g., BALLISTIC, HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
  /// Example: /// Example: TRACKED
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string ObjType { get { int o = __p.__offset(52); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetObjTypeBytes() { return __p.__vector_as_span<byte>(52, 1); }
#else
  public ArraySegment<byte>? GetObjTypeBytes() { return __p.__vector_as_arraysegment(52); }
#endif
  public byte[] GetObjTypeArray() { return __p.__vector_as_array<byte>(52); }
  /// The object platform type is intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. SATELLITE).
  /// Example: /// Example: WEAPON
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string ObjPlat { get { int o = __p.__offset(54); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetObjPlatBytes() { return __p.__vector_as_span<byte>(54, 1); }
#else
  public ArraySegment<byte>? GetObjPlatBytes() { return __p.__vector_as_arraysegment(54); }
#endif
  public byte[] GetObjPlatArray() { return __p.__vector_as_array<byte>(54); }
  /// The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. ANTISPACE WARFARE).
  /// Example: /// Example: HOLDING
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string ObjAct { get { int o = __p.__offset(56); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetObjActBytes() { return __p.__vector_as_span<byte>(56, 1); }
#else
  public ArraySegment<byte>? GetObjActBytes() { return __p.__vector_as_arraysegment(56); }
#endif
  public byte[] GetObjActArray() { return __p.__vector_as_array<byte>(56); }
  /// Nationality of the tracked object.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string ObjNat { get { int o = __p.__offset(58); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetObjNatBytes() { return __p.__vector_as_span<byte>(58, 1); }
#else
  public ArraySegment<byte>? GetObjNatBytes() { return __p.__vector_as_arraysegment(58); }
#endif
  public byte[] GetObjNatArray() { return __p.__vector_as_array<byte>(58); }
  /// Track name.
  /// Example: /// Example: TRACK-NAME
  /// Constraints: Minimum length = 0, Maximum length = 48
  public string Name { get { int o = __p.__offset(60); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(60, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(60); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(60); }
  /// Abbreviated track name.
  /// Example: /// Example: COMMSCHECK
  /// Constraints: Minimum length = 0, Maximum length = 11
  public string ShortName { get { int o = __p.__offset(62); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetShortNameBytes() { return __p.__vector_as_span<byte>(62, 1); }
#else
  public ArraySegment<byte>? GetShortNameBytes() { return __p.__vector_as_arraysegment(62); }
#endif
  public byte[] GetShortNameArray() { return __p.__vector_as_array<byte>(62); }
  /// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
  /// Example: /// Example: trkId
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string TrkId { get { int o = __p.__offset(64); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTrkIdBytes() { return __p.__vector_as_span<byte>(64, 1); }
#else
  public ArraySegment<byte>? GetTrkIdBytes() { return __p.__vector_as_arraysegment(64); }
#endif
  public byte[] GetTrkIdArray() { return __p.__vector_as_array<byte>(64); }
  /// The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
  /// Example: /// Example: trkNum
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string TrkNum { get { int o = __p.__offset(66); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTrkNumBytes() { return __p.__vector_as_span<byte>(66, 1); }
#else
  public ArraySegment<byte>? GetTrkNumBytes() { return __p.__vector_as_arraysegment(66); }
#endif
  public byte[] GetTrkNumArray() { return __p.__vector_as_array<byte>(66); }
  /// Value Indicating the scope of this track:
  /// 1 - TERMINAL  (Terminal) - available only on the workstation where they were created.
  /// 2 - LOCAL  (Local) - available only on workstations in the local area network
  /// 3 - OTH  (Over the Horizon) - available to everyone.
  /// Example: /// Example: OTH
  /// Constraints: Minimum length = 0, Maximum length = 12
  public string TrkScope { get { int o = __p.__offset(68); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTrkScopeBytes() { return __p.__vector_as_span<byte>(68, 1); }
#else
  public ArraySegment<byte>? GetTrkScopeBytes() { return __p.__vector_as_arraysegment(68); }
#endif
  public byte[] GetTrkScopeArray() { return __p.__vector_as_array<byte>(68); }
  /// The unique identifier of the source node.
  /// Example: /// Example: MCS
  /// Constraints: Minimum length = 0, Maximum length = 4
  public string SourceUid { get { int o = __p.__offset(70); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceUidBytes() { return __p.__vector_as_span<byte>(70, 1); }
#else
  public ArraySegment<byte>? GetSourceUidBytes() { return __p.__vector_as_arraysegment(70); }
#endif
  public byte[] GetSourceUidArray() { return __p.__vector_as_array<byte>(70); }
  /// The call sign currently assigned to this track object.
  /// Example: /// Example: Charlie
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string CallSign { get { int o = __p.__offset(72); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCallSignBytes() { return __p.__vector_as_span<byte>(72, 1); }
#else
  public ArraySegment<byte>? GetCallSignBytes() { return __p.__vector_as_arraysegment(72); }
#endif
  public byte[] GetCallSignArray() { return __p.__vector_as_array<byte>(72); }
  /// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
  ///  FAKER: Friendly track, object, or entity acting as an exercise hostile.
  ///  JOKER: Friendly track, object, or entity acting as an exercise suspect.
  ///  KILO: Friendly high-value object.
  ///  TRAVELLER: Suspect land or surface track following a recognized traffic route.
  ///  ZOMBIE: Suspect track, object, or entity of special interest.
  /// Example: /// Example: JOKER
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string IdentAmp { get { int o = __p.__offset(74); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdentAmpBytes() { return __p.__vector_as_span<byte>(74, 1); }
#else
  public ArraySegment<byte>? GetIdentAmpBytes() { return __p.__vector_as_arraysegment(74); }
#endif
  public byte[] GetIdentAmpArray() { return __p.__vector_as_array<byte>(74); }
  /// Space amplification indicates additional information on the space environment object being reported (e.g. DEBRIS, FUEL-AIR EXPLOSIVE, NUCLEAR WARHEAD).
  /// Example: /// Example: NUCLEAR WARHEAD
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string SpaceAmp { get { int o = __p.__offset(76); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSpaceAmpBytes() { return __p.__vector_as_span<byte>(76, 1); }
#else
  public ArraySegment<byte>? GetSpaceAmpBytes() { return __p.__vector_as_arraysegment(76); }
#endif
  public byte[] GetSpaceAmpArray() { return __p.__vector_as_array<byte>(76); }
  /// Confidence level of the amplifying characteristics.  Values range from 0 to 6, with 0 indicating the lowest confidence and 6 indicating the highest.
  /// Example: /// Example: 6
  /// Constraints: No constraints specified.
  public int SpaceAmpConf { get { int o = __p.__offset(78); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Specific type of point or track with an environment of space.
  /// Example: /// Example: SS-21_MOD_2_CRBM
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string SpaceSpecType { get { int o = __p.__offset(80); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSpaceSpecTypeBytes() { return __p.__vector_as_span<byte>(80, 1); }
#else
  public ArraySegment<byte>? GetSpaceSpecTypeBytes() { return __p.__vector_as_arraysegment(80); }
#endif
  public byte[] GetSpaceSpecTypeArray() { return __p.__vector_as_array<byte>(80); }
  /// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM:
  /// SRBM - Short-Range Ballistic Missile
  /// MRBM - Medium-Range Ballistic Missile
  /// IRBM - Intermediate-Range Ballistic Missile
  /// LRBM - Long-Range Ballistic Missile
  /// ICBM - Intercontinental Ballistic Missile
  /// SLBM - Submarine-Launched Ballistic Missile.
  /// Example: /// Example: SLBM
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string AcftSubType { get { int o = __p.__offset(82); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAcftSubTypeBytes() { return __p.__vector_as_span<byte>(82, 1); }
#else
  public ArraySegment<byte>? GetAcftSubTypeBytes() { return __p.__vector_as_arraysegment(82); }
#endif
  public byte[] GetAcftSubTypeArray() { return __p.__vector_as_array<byte>(82); }
  /// Track timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string Ts { get { int o = __p.__offset(84); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTsBytes() { return __p.__vector_as_span<byte>(84, 1); }
#else
  public ArraySegment<byte>? GetTsBytes() { return __p.__vector_as_arraysegment(84); }
#endif
  public byte[] GetTsArray() { return __p.__vector_as_array<byte>(84); }
  /// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string LaunchTime { get { int o = __p.__offset(86); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLaunchTimeBytes() { return __p.__vector_as_span<byte>(86, 1); }
#else
  public ArraySegment<byte>? GetLaunchTimeBytes() { return __p.__vector_as_arraysegment(86); }
#endif
  public byte[] GetLaunchTimeArray() { return __p.__vector_as_array<byte>(86); }
  /// Missile impact timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string ImpactTime { get { int o = __p.__offset(88); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetImpactTimeBytes() { return __p.__vector_as_span<byte>(88, 1); }
#else
  public ArraySegment<byte>? GetImpactTimeBytes() { return __p.__vector_as_arraysegment(88); }
#endif
  public byte[] GetImpactTimeArray() { return __p.__vector_as_array<byte>(88); }
  /// The message timestamp that the ftn track position was recorded, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string FtnMsgTs { get { int o = __p.__offset(90); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetFtnMsgTsBytes() { return __p.__vector_as_span<byte>(90, 1); }
#else
  public ArraySegment<byte>? GetFtnMsgTsBytes() { return __p.__vector_as_arraysegment(90); }
#endif
  public byte[] GetFtnMsgTsArray() { return __p.__vector_as_array<byte>(90); }
  /// An ftn used to associate information and directives with the track.
  /// Example: /// Example: FTN
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string Ftn { get { int o = __p.__offset(92); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetFtnBytes() { return __p.__vector_as_span<byte>(92, 1); }
#else
  public ArraySegment<byte>? GetFtnBytes() { return __p.__vector_as_arraysegment(92); }
#endif
  public byte[] GetFtnArray() { return __p.__vector_as_array<byte>(92); }
  /// The name of the Command reporting the Force Over-The-Horizon Track Coordinator (FOTC) track number.
  /// Example: /// Example: TRUETT
  /// Constraints: Minimum length = 0, Maximum length = 18
  public string FtnCmd { get { int o = __p.__offset(94); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetFtnCmdBytes() { return __p.__vector_as_span<byte>(94, 1); }
#else
  public ArraySegment<byte>? GetFtnCmdBytes() { return __p.__vector_as_arraysegment(94); }
#endif
  public byte[] GetFtnCmdArray() { return __p.__vector_as_array<byte>(94); }
  /// The message timestamp that the reference track position was recorded, in ISO 8601 UTC format with microsecond precision. The 'rtnMsgTs' and 'rtn' arrays must match in size.
  /// Example: /// Example: ['2021-02-25T12:00:00.123456Z']
  /// Constraints: No constraints specified.
  public string RtnMsgTs(int j) { int o = __p.__offset(96); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int RtnMsgTsLength { get { int o = __p.__offset(96); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// A Reference Track Number used to associate information and directives with the track.  Referenced, but not constrained to, MIL-STD-6016F Reference Track Number. The 'rtnMsgTs' and 'rtn' arrays must match in size.
  /// Example: /// Example: ['ex-a']
  /// Constraints: No constraints specified.
  public string Rtn(int j) { int o = __p.__offset(98); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int RtnLength { get { int o = __p.__offset(98); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Value representing the state of the Received Track.
  /// Example: /// Example: Local_RTN
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string RtnTrkState { get { int o = __p.__offset(100); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRtnTrkStateBytes() { return __p.__vector_as_span<byte>(100, 1); }
#else
  public ArraySegment<byte>? GetRtnTrkStateBytes() { return __p.__vector_as_arraysegment(100); }
#endif
  public byte[] GetRtnTrkStateArray() { return __p.__vector_as_array<byte>(100); }
  /// The name of the Command reporting the Received Track Number (RTN).
  /// Example: /// Example: YORKTOWN
  /// Constraints: Minimum length = 0, Maximum length = 8
  public string RtnCmd { get { int o = __p.__offset(102); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRtnCmdBytes() { return __p.__vector_as_span<byte>(102, 1); }
#else
  public ArraySegment<byte>? GetRtnCmdBytes() { return __p.__vector_as_arraysegment(102); }
#endif
  public byte[] GetRtnCmdArray() { return __p.__vector_as_array<byte>(102); }
  /// Id/name of sensor providing the track data.
  /// Example: /// Example: OTH
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string Sen { get { int o = __p.__offset(104); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSenBytes() { return __p.__vector_as_span<byte>(104, 1); }
#else
  public ArraySegment<byte>? GetSenBytes() { return __p.__vector_as_arraysegment(104); }
#endif
  public byte[] GetSenArray() { return __p.__vector_as_array<byte>(104); }
  /// Source cross-reference code for the Command that originated the track report.
  /// Example: /// Example: INT
  /// Constraints: Minimum length = 0, Maximum length = 18
  public string RptChxref { get { int o = __p.__offset(106); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRptChxrefBytes() { return __p.__vector_as_span<byte>(106, 1); }
#else
  public ArraySegment<byte>? GetRptChxrefBytes() { return __p.__vector_as_arraysegment(106); }
#endif
  public byte[] GetRptChxrefArray() { return __p.__vector_as_array<byte>(106); }
  /// Flag indicating whether this track is archived.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool RptArchived { get { int o = __p.__offset(108); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Flag indicating that this track is self reported.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool SelfReport { get { int o = __p.__offset(110); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The MIL-STD-2525B symbology code that applies to the subject of this track.
  /// Example: /// Example: SHP*S----------
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string Mil2525Bstr { get { int o = __p.__offset(112); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMil2525BstrBytes() { return __p.__vector_as_span<byte>(112, 1); }
#else
  public ArraySegment<byte>? GetMil2525BstrBytes() { return __p.__vector_as_arraysegment(112); }
#endif
  public byte[] GetMil2525BstrArray() { return __p.__vector_as_array<byte>(112); }
  /// Transponder ID for the track.  This does not correspond to the UDL transponder schema.
  /// Example: /// Example: 11
  /// Constraints: Minimum length = 0, Maximum length = 61
  public string TrnspdrId { get { int o = __p.__offset(114); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTrnspdrIdBytes() { return __p.__vector_as_span<byte>(114, 1); }
#else
  public ArraySegment<byte>? GetTrnspdrIdBytes() { return __p.__vector_as_arraysegment(114); }
#endif
  public byte[] GetTrnspdrIdArray() { return __p.__vector_as_array<byte>(114); }
  /// Transponder type for the track.
  /// Example: /// Example: AFTS
  /// Constraints: Minimum length = 0, Maximum length = 51
  public string TrnspdrType { get { int o = __p.__offset(116); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTrnspdrTypeBytes() { return __p.__vector_as_span<byte>(116, 1); }
#else
  public ArraySegment<byte>? GetTrnspdrTypeBytes() { return __p.__vector_as_arraysegment(116); }
#endif
  public byte[] GetTrnspdrTypeArray() { return __p.__vector_as_array<byte>(116); }
  /// Radar name of the sensor tracking this object (e.g., RAY1500, SPN-43, HEADNET).
  /// Example: /// Example: RAY1500
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string EmitterName { get { int o = __p.__offset(118); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEmitterNameBytes() { return __p.__vector_as_span<byte>(118, 1); }
#else
  public ArraySegment<byte>? GetEmitterNameBytes() { return __p.__vector_as_arraysegment(118); }
#endif
  public byte[] GetEmitterNameArray() { return __p.__vector_as_array<byte>(118); }
  /// Source code for source of information used to detect track.
  /// Example: /// Example: S1
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string InfoSource { get { int o = __p.__offset(120); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetInfoSourceBytes() { return __p.__vector_as_span<byte>(120, 1); }
#else
  public ArraySegment<byte>? GetInfoSourceBytes() { return __p.__vector_as_arraysegment(120); }
#endif
  public byte[] GetInfoSourceArray() { return __p.__vector_as_array<byte>(120); }
  /// Flag indicating that the missile is currently in a state of boosting, if reporting a missile track.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool Boosting { get { int o = __p.__offset(122); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Frequency, in hertz, for the signature report.
  /// Example: /// Example: 63.65
  /// Constraints: No constraints specified.
  public double Freq { get { int o = __p.__offset(124); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Maximum frequency, in hertz, reported for this acoustic track.
  /// Example: /// Example: 10324.53
  /// Constraints: No constraints specified.
  public double MaxFreq { get { int o = __p.__offset(126); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// List of harmonics of the signature report in descending order of predominance using 1-2 digit combinations separated by commas, e.g., 8,12,4. (1-22NS).
  /// Example: /// Example: 8,12,4
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string Harmonics { get { int o = __p.__offset(128); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetHarmonicsBytes() { return __p.__vector_as_span<byte>(128, 1); }
#else
  public ArraySegment<byte>? GetHarmonicsBytes() { return __p.__vector_as_arraysegment(128); }
#endif
  public byte[] GetHarmonicsArray() { return __p.__vector_as_array<byte>(128); }
  /// Pulse repetition interval of the emitter, measured in microseconds.  The interval between the start of one pulse and the start of another.
  /// Example: /// Example: 56657.2238
  /// Constraints: No constraints specified.
  public double Pri { get { int o = __p.__offset(130); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Pulse repetition frequency of the emitter, measured in pulses per second.  PRF is the number of pulses transmitted per second. This is the reciprocal of the pri value.
  /// Example: /// Example: 17.65
  /// Constraints: No constraints specified.
  public double Prf { get { int o = __p.__offset(132); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Pulse width of the emitter, measured in microseconds.  This is the duration of the pulse.
  /// Example: /// Example: 1347.45
  /// Constraints: No constraints specified.
  public double Pw { get { int o = __p.__offset(134); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Type of radar scan.
  /// Example: /// Example: UNK
  /// Constraints: Minimum length = 0, Maximum length = 5
  public string ScanType { get { int o = __p.__offset(136); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetScanTypeBytes() { return __p.__vector_as_span<byte>(136, 1); }
#else
  public ArraySegment<byte>? GetScanTypeBytes() { return __p.__vector_as_arraysegment(136); }
#endif
  public byte[] GetScanTypeArray() { return __p.__vector_as_array<byte>(136); }
  /// Scan rate of the emitter, measured in seconds per rotation (SPR).
  /// Example: /// Example: 12.01
  /// Constraints: No constraints specified.
  public double ScanRate { get { int o = __p.__offset(138); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The Sequential Contact Number (SCN) for this track.
  /// Example: /// Example: 1474305
  /// Constraints: No constraints specified.
  public int Scn { get { int o = __p.__offset(140); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Correlation Index; reference code for the site that originally reported the track.
  /// Example: /// Example: BB
  /// Constraints: Minimum length = 0, Maximum length = 3
  public string CI { get { int o = __p.__offset(142); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCIBytes() { return __p.__vector_as_span<byte>(142, 1); }
#else
  public ArraySegment<byte>? GetCIBytes() { return __p.__vector_as_arraysegment(142); }
#endif
  public byte[] GetCIArray() { return __p.__vector_as_array<byte>(142); }
  /// The angle formed between the line of sight of the observer and the horizon, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
  /// Example: /// Example: 15.2
  /// Constraints: No constraints specified.
  public double AngElev { get { int o = __p.__offset(144); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  public double Lat { get { int o = __p.__offset(146); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  public double Lon { get { int o = __p.__offset(148); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  public double LaunchLat { get { int o = __p.__offset(150); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74550102
  /// Constraints: No constraints specified.
  public double LaunchLon { get { int o = __p.__offset(152); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS-84 latitude of the missile impact point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  public double ImpactLat { get { int o = __p.__offset(154); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS-84 longitude of the missile impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74550102
  /// Constraints: No constraints specified.
  public double ImpactLon { get { int o = __p.__offset(156); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS-84 azimuth corridor reference point latitude, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  public double PolarSingLocLat { get { int o = __p.__offset(158); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS-84 azimuth corridor reference point longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74550102
  /// Constraints: No constraints specified.
  public double PolarSingLocLon { get { int o = __p.__offset(160); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The azimuth corridor centerline angle measured in degrees clockwise from true north, of the center line of an azimuth corridor. The center line extends from the referenced corridor origin location.
  /// Example: /// Example: 12.876
  /// Constraints: No constraints specified.
  public double AzCorrCenterLine { get { int o = __p.__offset(162); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Azimuth corridor arc distance measured in meters from reference point of azimuth corridor to far edge of bounded azimuth corridor wedge, measured along azimuth corridor center line.
  /// Example: /// Example: 71.76
  /// Constraints: No constraints specified.
  public double AzCorrArcWidth { get { int o = __p.__offset(164); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The error in the semi-intermediate axis.  The semi-intermediate axis is intermediate in length between semi-major and semi-minor axes. This field is doubled and centered on intersection of area semi-major axis and area semi-minor axis at 90 degrees to the plane defined by those axes. For these shapes, the volume is defined as having a 50-percent probability of containing the true location of the referenced entity.
  /// Example: /// Example: 7010.882
  /// Constraints: No constraints specified.
  public double ErrSemiIntAxis { get { int o = __p.__offset(166); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The error in the Area Orientation.  Area Orientation is the angle or roll in degrees, between area semi-minor axis and plane defined by local vertical and area semi-major axis. When reported without major and minor axis, it is angle between an axis perpendicular to a 2D true north axis and plane defined by local vertical and a 2D true north axis.
  /// Example: /// Example: 69.6
  /// Constraints: No constraints specified.
  public double ErrAreaOrient { get { int o = __p.__offset(168); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The error in the Semi-major elevation axis. Semi-major elevation axis is the elevation of the cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical semi-major axis, in degrees, measured from local horizontal.
  /// Example: /// Example: 168.8
  /// Constraints: No constraints specified.
  public double ErrSemiMajElev { get { int o = __p.__offset(170); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Geometric area switch identifies the 3D shape of the error volume by providing the 2D shape for the 3D plane. The 3D plane is the plane orthogonal to the area semi-major axis and area semi-minor axis. Depending on whether the 2D plane is reported as an error ellipse 2D or as an error rectangle 2D, this switch reports a complete error volume that is cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical.
  /// 0 - SWITCH_TYPE_UNKNOWN
  /// 1 - SQUARE_RECTANGLE
  /// 2 - CIRCLE_ELLIPSE.
  /// Example: /// Example: CIRCLE_ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string ErrGeoAreaSwitch { get { int o = __p.__offset(172); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetErrGeoAreaSwitchBytes() { return __p.__vector_as_span<byte>(172, 1); }
#else
  public ArraySegment<byte>? GetErrGeoAreaSwitchBytes() { return __p.__vector_as_arraysegment(172); }
#endif
  public byte[] GetErrGeoAreaSwitchArray() { return __p.__vector_as_array<byte>(172); }
  /// Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
  /// Example: /// Example: 30567.452
  /// Constraints: No constraints specified.
  public double BurnoutAlt { get { int o = __p.__offset(174); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Threat Event System Track ID.
  /// Example: /// Example: 6217
  /// Constraints: Minimum length = 0, Maximum length = 8
  public string TesEventId { get { int o = __p.__offset(176); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTesEventIdBytes() { return __p.__vector_as_span<byte>(176, 1); }
#else
  public ArraySegment<byte>? GetTesEventIdBytes() { return __p.__vector_as_arraysegment(176); }
#endif
  public byte[] GetTesEventIdArray() { return __p.__vector_as_array<byte>(176); }
  /// Track object speed, in meters/sec.
  /// Example: /// Example: 15.03443
  /// Constraints: No constraints specified.
  public double Spd { get { int o = __p.__offset(178); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The average speed, in kilometers/hour, calculated for the subject during the latest voyage/excursion.
  /// Example: /// Example: 18.25
  /// Constraints: No constraints specified.
  public double AvgSpd { get { int o = __p.__offset(180); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Motion model Time On Leg in hours.
  /// Example: /// Example: 4.1
  /// Constraints: No constraints specified.
  public double Tol { get { int o = __p.__offset(182); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
  /// Example: /// Example: 153.01
  /// Constraints: No constraints specified.
  public double Alt { get { int o = __p.__offset(184); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Track object heading, in degrees clockwise from true north.
  /// Example: /// Example: 19.7
  /// Constraints: No constraints specified.
  public double Hdng { get { int o = __p.__offset(186); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
  /// Example: /// Example: 4.3580153
  /// Constraints: No constraints specified.
  public double Course { get { int o = __p.__offset(188); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The number of propeller revolutions per minute for a submarine or ship.
  /// Example: /// Example: 8.2
  /// Constraints: No constraints specified.
  public double PropRPM { get { int o = __p.__offset(190); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The number of turns of the vessel propellers per knot of forward motion.
  /// Example: /// Example: 2.65
  /// Constraints: No constraints specified.
  public double Tpk { get { int o = __p.__offset(192); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The Cooperative Location Indicator specifies whether the reported entity location was derived using reported locations from sensors on more than one platform.
  /// 0 - COOPERATIVE_LOCATOR_NONE
  /// 1 - SINGLE_PLATFORM
  /// 2 - FRAGMENT
  /// 3 - COOPERATIVE.
  /// Example: /// Example: COOPERATIVE
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string CoopLocInd { get { int o = __p.__offset(194); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCoopLocIndBytes() { return __p.__vector_as_span<byte>(194, 1); }
#else
  public ArraySegment<byte>? GetCoopLocIndBytes() { return __p.__vector_as_arraysegment(194); }
#endif
  public byte[] GetCoopLocIndArray() { return __p.__vector_as_array<byte>(194); }
  /// The manuevering indicator specifying the missile boost phase.
  /// 0 - POST_BOOST_NONE
  /// 1 - POST_BOOST_MANUEVER
  /// 2 - POST_BOOST_COMPLETE_MANUEVER.
  /// Example: /// Example: POST_BOOST_NONE
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string ManeuverInd { get { int o = __p.__offset(196); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetManeuverIndBytes() { return __p.__vector_as_span<byte>(196, 1); }
#else
  public ArraySegment<byte>? GetManeuverIndBytes() { return __p.__vector_as_arraysegment(196); }
#endif
  public byte[] GetManeuverIndArray() { return __p.__vector_as_array<byte>(196); }
  /// The launch location Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the launchAouData array and is required if launchAouData is not null. See the launchAouData field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 20
  public string LaunchAouType { get { int o = __p.__offset(198); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLaunchAouTypeBytes() { return __p.__vector_as_span<byte>(198, 1); }
#else
  public ArraySegment<byte>? GetLaunchAouTypeBytes() { return __p.__vector_as_arraysegment(198); }
#endif
  public byte[] GetLaunchAouTypeArray() { return __p.__vector_as_array<byte>(198); }
  /// Three element array representing the launch location Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the launchAouType specified in this record:
  ///  ELLIPSE:
  ///    brg - orientation in degrees of the ellipse
  ///    a1 - semi-major axis in meters
  ///    a2 - semi-minor axis in meters
  ///  BEARING (BEARING BOX or MTST BEARING BOX):
  ///    brg - orientation in degrees of the bearing box
  ///    a1 - length of bearing box in meters
  ///    a2 - half-width of bearing box in meters
  ///  OTHER (All other type values):
  ///    brg - line of bearing in degrees true
  ///    a1 - bearing error in degrees
  ///    a2 - estimated range in meters.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  public string LaunchAouData(int j) { int o = __p.__offset(200); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int LaunchAouDataLength { get { int o = __p.__offset(200); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The impact point Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the impactAouData array and is required if impactAouData is not null. See the impactAouData field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 20
  public string ImpactAouType { get { int o = __p.__offset(202); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetImpactAouTypeBytes() { return __p.__vector_as_span<byte>(202, 1); }
#else
  public ArraySegment<byte>? GetImpactAouTypeBytes() { return __p.__vector_as_arraysegment(202); }
#endif
  public byte[] GetImpactAouTypeArray() { return __p.__vector_as_array<byte>(202); }
  /// Three element array representing the impact point Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the impactAouType specified in this record:
  ///  ELLIPSE:
  ///    brg - orientation in degrees of the ellipse
  ///    a1 - semi-major axis in meters
  ///    a2 - semi-minor axis in meters
  ///  BEARING (BEARING BOX or MTST BEARING BOX):
  ///    brg - orientation in degrees of the bearing box
  ///    a1 - length of bearing box in meters
  ///    a2 - half-width of bearing box in meters
  ///  OTHER (All other type values):
  ///    brg - line of bearing in degrees true
  ///    a1 - bearing error in degrees
  ///    a2 - estimated range in meters.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  public string ImpactAouData(int j) { int o = __p.__offset(204); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int ImpactAouDataLength { get { int o = __p.__offset(204); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The track Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouRptData array and is required if aouRptData is not null. See the aouRptData field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 20
  public string AouRptType { get { int o = __p.__offset(206); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAouRptTypeBytes() { return __p.__vector_as_span<byte>(206, 1); }
#else
  public ArraySegment<byte>? GetAouRptTypeBytes() { return __p.__vector_as_arraysegment(206); }
#endif
  public byte[] GetAouRptTypeArray() { return __p.__vector_as_array<byte>(206); }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouRptType specified in this record:
  ///  ELLIPSE:
  ///    brg - orientation in degrees of the ellipse
  ///    a1 - semi-major axis in meters
  ///    a2 - semi-minor axis in meters
  ///  BEARING (BEARING BOX or MTST BEARING BOX):
  ///    brg - orientation in degrees of the bearing box
  ///    a1 - length of bearing box in meters
  ///    a2 - half-width of bearing box in meters
  ///  OTHER (All other type values):
  ///    brg - line of bearing in degrees true
  ///    a1 - bearing error in degrees
  ///    a2 - estimated range in meters.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  public string AouRptData(int j) { int o = __p.__offset(208); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int AouRptDataLength { get { int o = __p.__offset(208); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
  /// Example: /// Example: [1.23, 2.35, 3.42]
  /// Constraints: No constraints specified.
  public string EcefPos(int j) { int o = __p.__offset(210); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int EcefPosLength { get { int o = __p.__offset(210); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
  /// Example: /// Example: [1.23, 2.35, 3.42]
  /// Constraints: No constraints specified.
  public string EcefVel(int j) { int o = __p.__offset(212); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int EcefVelLength { get { int o = __p.__offset(212); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
  /// Example: /// Example: 97
  /// Constraints: No constraints specified.
  public double Containment { get { int o = __p.__offset(214); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The distance, in meters, of the closest point of approach between this track to the master reference track.
  /// Example: /// Example: 500
  /// Constraints: No constraints specified.
  public double Cpa { get { int o = __p.__offset(216); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The time, in ISO 8601 UTC format with millisecond precision, of the  closest point of approach between this track and the master reference track.
  /// Example: /// Example: 2021-02-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  public string Tcpa { get { int o = __p.__offset(218); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTcpaBytes() { return __p.__vector_as_span<byte>(218, 1); }
#else
  public ArraySegment<byte>? GetTcpaBytes() { return __p.__vector_as_arraysegment(218); }
#endif
  public byte[] GetTcpaArray() { return __p.__vector_as_array<byte>(218); }
  /// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Underway Using Engine
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string NavStatus { get { int o = __p.__offset(220); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNavStatusBytes() { return __p.__vector_as_span<byte>(220, 1); }
#else
  public ArraySegment<byte>? GetNavStatusBytes() { return __p.__vector_as_arraysegment(220); }
#endif
  public byte[] GetNavStatusArray() { return __p.__vector_as_array<byte>(220); }
  /// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: GPS
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string PosDeviceType { get { int o = __p.__offset(222); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPosDeviceTypeBytes() { return __p.__vector_as_span<byte>(222, 1); }
#else
  public ArraySegment<byte>? GetPosDeviceTypeBytes() { return __p.__vector_as_arraysegment(222); }
#endif
  public byte[] GetPosDeviceTypeArray() { return __p.__vector_as_array<byte>(222); }
  /// Type of Aid to Navigation. Intended as, but not constrained to, the USCG NAVCEN  aids to navigation. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Cardinal Mark N
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Aton { get { int o = __p.__offset(224); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAtonBytes() { return __p.__vector_as_span<byte>(224, 1); }
#else
  public ArraySegment<byte>? GetAtonBytes() { return __p.__vector_as_arraysegment(224); }
#endif
  public byte[] GetAtonArray() { return __p.__vector_as_array<byte>(224); }
  /// Indicator position (OFF, ON, UNK) for optional floating navigational aids only.
  /// Example: /// Example: ON
  /// Constraints: Minimum length = 0, Maximum length = 3
  public string OffPosInd { get { int o = __p.__offset(226); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOffPosIndBytes() { return __p.__vector_as_span<byte>(226, 1); }
#else
  public ArraySegment<byte>? GetOffPosIndBytes() { return __p.__vector_as_arraysegment(226); }
#endif
  public byte[] GetOffPosIndArray() { return __p.__vector_as_array<byte>(226); }
  /// The reference dimensions of the vessel, reported as [A, B, C, D], in meters. Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna. Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
  /// Example: /// Example: [50.1, 50.1, 20.1, 20.1]
  /// Constraints: No constraints specified.
  public string AntennaRefDimensions(int j) { int o = __p.__offset(228); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int AntennaRefDimensionsLength { get { int o = __p.__offset(228); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The common name for a group of ships with similar design, usually named for the first vessel of the class.
  /// Example: /// Example: Nimitz
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string ShipClass { get { int o = __p.__offset(230); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetShipClassBytes() { return __p.__vector_as_span<byte>(230, 1); }
#else
  public ArraySegment<byte>? GetShipClassBytes() { return __p.__vector_as_arraysegment(230); }
#endif
  public byte[] GetShipClassArray() { return __p.__vector_as_array<byte>(230); }
  /// The International Maritime Organization Number of the vessel. IMON is a seven-digit number that uniquely identifies the vessel.
  /// Example: /// Example: 9015462
  /// Constraints: No constraints specified.
  public int Imon { get { int o = __p.__offset(232); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The Maritime Mobile Service Identity of the vessel. MMSI is a nine-digit number that identifies the transmitter station of the vessel.
  /// Example: /// Example: 304010417
  /// Constraints: No constraints specified.
  public int Mmsi { get { int o = __p.__offset(234); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The maximum static draught, in meters, of the vessel according to the AIS transmission.
  /// Example: /// Example: 21.1
  /// Constraints: No constraints specified.
  public double Draught { get { int o = __p.__offset(236); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The overall length of the vessel, in meters. A value of 511 indicates a vessel length of 511 meters or greater.
  /// Example: /// Example: 511.1
  /// Constraints: No constraints specified.
  public double Length { get { int o = __p.__offset(238); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The breadth of the vessel, in meters. A value of 63 indicates a vessel breadth of 63 meters or greater.
  /// Example: /// Example: 24.1
  /// Constraints: No constraints specified.
  public double Width { get { int o = __p.__offset(240); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  public string CargoType { get { int o = __p.__offset(242); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCargoTypeBytes() { return __p.__vector_as_span<byte>(242, 1); }
#else
  public ArraySegment<byte>? GetCargoTypeBytes() { return __p.__vector_as_arraysegment(242); }
#endif
  public byte[] GetCargoTypeArray() { return __p.__vector_as_array<byte>(242); }
  /// Appearance group code.
  /// GP1 - Superstructure exceeds 1/3 of ship length.
  /// GP2 - Superstructure less than 1/3 of ship length.
  /// GP3 - Stack aft.
  /// Example: /// Example: GP1
  /// Constraints: Minimum length = 0, Maximum length = 7
  public string AppGrp { get { int o = __p.__offset(244); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAppGrpBytes() { return __p.__vector_as_span<byte>(244, 1); }
#else
  public ArraySegment<byte>? GetAppGrpBytes() { return __p.__vector_as_arraysegment(244); }
#endif
  public byte[] GetAppGrpArray() { return __p.__vector_as_array<byte>(244); }
  /// Hull profile code. Based on GCCS-J hull profiles.
  /// FLUSH           No breaks in Hull Profile.
  /// RAISED 1        Hull Profile shows distinct raised area at bow. Remainder of deck is flush.
  /// RAISED 2        Hull Profile shows distinct raised area amidships. Bow and stern are flush.
  /// RAISED 3        Hull Profile shows distinct raised area at stern. Remainder of deck is flush.
  /// RAISED 1-2-3    Distinct raised areas at bow, midships, and stern with breaks between each raise.
  /// RAISED 1-2      Raised area at bow and midships with break between.
  /// RAISED 1-3      Raised area at bow and stern with break between.
  /// RAISED 12       Continuous raised area encompassing both bow and midships.
  /// RAISED 23       Continuous raised area encompassing midships and stern.
  /// RAISED 12-3     Raised areas at bow, midships and stern. Bow and midship raises are continuous. Break between midship and stern raises.
  /// RAISED 1-23     Raised areas at bow, midships, and stern. Midship and stern raises are continuous with break between bow and midship raises.
  /// RAISED 1-L2-3   Raised areas at bow, midships, and stern with break between each raise. Midships raise is longer than that associated with raised 1-2-3.
  /// Example: /// Example: Raised 1-23
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string HullProf { get { int o = __p.__offset(246); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetHullProfBytes() { return __p.__vector_as_span<byte>(246, 1); }
#else
  public ArraySegment<byte>? GetHullProfBytes() { return __p.__vector_as_arraysegment(246); }
#endif
  public byte[] GetHullProfArray() { return __p.__vector_as_array<byte>(246); }
  /// The type of propulsion employed by the track object (Diesel, Nuclear).
  /// Example: /// Example: Diesel
  /// Constraints: Minimum length = 0, Maximum length = 6
  public string PropType { get { int o = __p.__offset(248); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPropTypeBytes() { return __p.__vector_as_span<byte>(248, 1); }
#else
  public ArraySegment<byte>? GetPropTypeBytes() { return __p.__vector_as_arraysegment(248); }
#endif
  public byte[] GetPropTypeArray() { return __p.__vector_as_array<byte>(248); }
  /// The number of blades per shaft of the track object.  Applicable for maritime vessels.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  public int NumBlades { get { int o = __p.__offset(250); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The number of shafts on the track object.  Applicable for maritime vessels.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  public int NumShafts { get { int o = __p.__offset(252); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The stern type code (Counter, Cruiser) associated with the track object.
  /// Example: /// Example: Cruiser
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string SternType { get { int o = __p.__offset(254); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSternTypeBytes() { return __p.__vector_as_span<byte>(254, 1); }
#else
  public ArraySegment<byte>? GetSternTypeBytes() { return __p.__vector_as_arraysegment(254); }
#endif
  public byte[] GetSternTypeArray() { return __p.__vector_as_array<byte>(254); }
  /// The weight, in tons, of the vessel associated with this track.
  /// Example: /// Example: 3423.76
  /// Constraints: No constraints specified.
  public double VslWt { get { int o = __p.__offset(256); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The Arrival Time of the vessel at the destination, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string ArrTime { get { int o = __p.__offset(258); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetArrTimeBytes() { return __p.__vector_as_span<byte>(258, 1); }
#else
  public ArraySegment<byte>? GetArrTimeBytes() { return __p.__vector_as_arraysegment(258); }
#endif
  public byte[] GetArrTimeArray() { return __p.__vector_as_array<byte>(258); }
  /// The flag of the arrival port.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string ArrFlag { get { int o = __p.__offset(260); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetArrFlagBytes() { return __p.__vector_as_span<byte>(260, 1); }
#else
  public ArraySegment<byte>? GetArrFlagBytes() { return __p.__vector_as_arraysegment(260); }
#endif
  public byte[] GetArrFlagArray() { return __p.__vector_as_array<byte>(260); }
  /// The reported arrival cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  public string ArrCargo { get { int o = __p.__offset(262); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetArrCargoBytes() { return __p.__vector_as_span<byte>(262, 1); }
#else
  public ArraySegment<byte>? GetArrCargoBytes() { return __p.__vector_as_arraysegment(262); }
#endif
  public byte[] GetArrCargoArray() { return __p.__vector_as_array<byte>(262); }
  /// The Arrival Port of the vessel according to the AIS transmission.
  /// Example: /// Example: Lanshan
  /// Constraints: Minimum length = 0, Maximum length = 20
  public string ArrPort { get { int o = __p.__offset(264); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetArrPortBytes() { return __p.__vector_as_span<byte>(264, 1); }
#else
  public ArraySegment<byte>? GetArrPortBytes() { return __p.__vector_as_arraysegment(264); }
#endif
  public byte[] GetArrPortArray() { return __p.__vector_as_array<byte>(264); }
  /// The Departure Port of the vessel according to the AIS transmission.
  /// Example: /// Example: Lanshan
  /// Constraints: Minimum length = 0, Maximum length = 20
  public string DepPort { get { int o = __p.__offset(266); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDepPortBytes() { return __p.__vector_as_span<byte>(266, 1); }
#else
  public ArraySegment<byte>? GetDepPortBytes() { return __p.__vector_as_arraysegment(266); }
#endif
  public byte[] GetDepPortArray() { return __p.__vector_as_array<byte>(266); }
  /// The flag of the departure port.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string DepFlag { get { int o = __p.__offset(268); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDepFlagBytes() { return __p.__vector_as_span<byte>(268, 1); }
#else
  public ArraySegment<byte>? GetDepFlagBytes() { return __p.__vector_as_arraysegment(268); }
#endif
  public byte[] GetDepFlagArray() { return __p.__vector_as_array<byte>(268); }
  /// The reported departure cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  public string DepCargo { get { int o = __p.__offset(270); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDepCargoBytes() { return __p.__vector_as_span<byte>(270, 1); }
#else
  public ArraySegment<byte>? GetDepCargoBytes() { return __p.__vector_as_arraysegment(270); }
#endif
  public byte[] GetDepCargoArray() { return __p.__vector_as_array<byte>(270); }
  /// The flag of the destination port.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string DesFlag { get { int o = __p.__offset(272); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDesFlagBytes() { return __p.__vector_as_span<byte>(272, 1); }
#else
  public ArraySegment<byte>? GetDesFlagBytes() { return __p.__vector_as_arraysegment(272); }
#endif
  public byte[] GetDesFlagArray() { return __p.__vector_as_array<byte>(272); }
  /// The reported destination cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  public string DesCargo { get { int o = __p.__offset(274); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDesCargoBytes() { return __p.__vector_as_span<byte>(274, 1); }
#else
  public ArraySegment<byte>? GetDesCargoBytes() { return __p.__vector_as_arraysegment(274); }
#endif
  public byte[] GetDesCargoArray() { return __p.__vector_as_array<byte>(274); }
  /// The destination of the vessel according to the AIS transmission.
  /// Example: /// Example: USCLE
  /// Constraints: Minimum length = 0, Maximum length = 20
  public string Destination { get { int o = __p.__offset(276); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDestinationBytes() { return __p.__vector_as_span<byte>(276, 1); }
#else
  public ArraySegment<byte>? GetDestinationBytes() { return __p.__vector_as_arraysegment(276); }
#endif
  public byte[] GetDestinationArray() { return __p.__vector_as_array<byte>(276); }
  /// The Estimated Time of Arrival of the vessel at the destination port, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string Eta { get { int o = __p.__offset(278); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEtaBytes() { return __p.__vector_as_span<byte>(278, 1); }
#else
  public ArraySegment<byte>? GetEtaBytes() { return __p.__vector_as_arraysegment(278); }
#endif
  public byte[] GetEtaArray() { return __p.__vector_as_array<byte>(278); }
  /// The Estimated Time of Departure of the vessel from the departure port (depPort), according to Marine Traffic calculations, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string Etd { get { int o = __p.__offset(280); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEtdBytes() { return __p.__vector_as_span<byte>(280, 1); }
#else
  public ArraySegment<byte>? GetEtdBytes() { return __p.__vector_as_arraysegment(280); }
#endif
  public byte[] GetEtdArray() { return __p.__vector_as_array<byte>(280); }
  /// A text amplifier displaying IFF/SIF/AIS Identification modes and codes.
  /// Example: /// Example: ID Mode
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Iff { get { int o = __p.__offset(282); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIffBytes() { return __p.__vector_as_span<byte>(282, 1); }
#else
  public ArraySegment<byte>? GetIffBytes() { return __p.__vector_as_arraysegment(282); }
#endif
  public byte[] GetIffArray() { return __p.__vector_as_array<byte>(282); }
  /// Flag indicating that the track object has an emergency.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool EmgInd { get { int o = __p.__offset(284); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The drop-point indicator setting.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool DropPtInd { get { int o = __p.__offset(286); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool Reinforced { get { int o = __p.__offset(288); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Flag indicating for the track represents a reduced force object or group.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool Reduced { get { int o = __p.__offset(290); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool Hq { get { int o = __p.__offset(292); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool Dummy { get { int o = __p.__offset(294); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool TaskForce { get { int o = __p.__offset(296); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool Feint { get { int o = __p.__offset(298); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool Installation { get { int o = __p.__offset(300); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// A text amplifier for units, equipment and installations; content is implementation specific.
  /// Example: /// Example: Staff Comments
  /// Constraints: Minimum length = 0, Maximum length = 256
  public string StaffCmts { get { int o = __p.__offset(302); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetStaffCmtsBytes() { return __p.__vector_as_span<byte>(302, 1); }
#else
  public ArraySegment<byte>? GetStaffCmtsBytes() { return __p.__vector_as_arraysegment(302); }
#endif
  public byte[] GetStaffCmtsArray() { return __p.__vector_as_array<byte>(302); }
  /// A text amplifier for units, equipment and installations; content is implementation specific.
  /// Example: /// Example: Additional information
  /// Constraints: Minimum length = 0, Maximum length = 256
  public string AddInfo { get { int o = __p.__offset(304); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAddInfoBytes() { return __p.__vector_as_span<byte>(304, 1); }
#else
  public ArraySegment<byte>? GetAddInfoBytes() { return __p.__vector_as_arraysegment(304); }
#endif
  public byte[] GetAddInfoArray() { return __p.__vector_as_array<byte>(304); }
  /// A text amplifier code for units, equipment, and installations that consists of a one-letter reliability rating and a one-number credibility rating based on the following definitions of each:
  ///  Reliability Ratings:
  ///   A-completely reliable
  ///   B-usually reliable
  ///   C-fairly reliable
  ///   D-not usually reliable
  ///   E-unreliable
  ///   F-reliability cannot be judged
  ///  Credibility Ratings:
  ///   1-confirmed by other sources
  ///   2-probably true
  ///   3-possibly true
  ///   4-doubtfully true
  ///   5-improbable
  ///   6-truth cannot be judged.
  /// Example: /// Example: A1
  /// Constraints: Minimum length = 0, Maximum length = 2
  public string EvalRating { get { int o = __p.__offset(306); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEvalRatingBytes() { return __p.__vector_as_span<byte>(306, 1); }
#else
  public ArraySegment<byte>? GetEvalRatingBytes() { return __p.__vector_as_arraysegment(306); }
#endif
  public byte[] GetEvalRatingArray() { return __p.__vector_as_array<byte>(306); }
  /// Time the row was created in the database.
  /// Example: /// Example: 2021-02-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  public string CreatedAt { get { int o = __p.__offset(308); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedAtBytes() { return __p.__vector_as_span<byte>(308, 1); }
#else
  public ArraySegment<byte>? GetCreatedAtBytes() { return __p.__vector_as_arraysegment(308); }
#endif
  public byte[] GetCreatedAtArray() { return __p.__vector_as_array<byte>(308); }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string CreatedBy { get { int o = __p.__offset(310); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedByBytes() { return __p.__vector_as_span<byte>(310, 1); }
#else
  public ArraySegment<byte>? GetCreatedByBytes() { return __p.__vector_as_arraysegment(310); }
#endif
  public byte[] GetCreatedByArray() { return __p.__vector_as_array<byte>(310); }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string Source { get { int o = __p.__offset(312); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceBytes() { return __p.__vector_as_span<byte>(312, 1); }
#else
  public ArraySegment<byte>? GetSourceBytes() { return __p.__vector_as_arraysegment(312); }
#endif
  public byte[] GetSourceArray() { return __p.__vector_as_array<byte>(312); }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Origin { get { int o = __p.__offset(314); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOriginBytes() { return __p.__vector_as_span<byte>(314, 1); }
#else
  public ArraySegment<byte>? GetOriginBytes() { return __p.__vector_as_arraysegment(314); }
#endif
  public byte[] GetOriginArray() { return __p.__vector_as_array<byte>(314); }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  public TrackDetails_Ingest_dataMode_Enum DataMode { get { int o = __p.__offset(316); return o != 0 ? (TrackDetails_Ingest_dataMode_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : TrackDetails_Ingest_dataMode_Enum.REAL; } }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string OrigNetwork { get { int o = __p.__offset(318); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOrigNetworkBytes() { return __p.__vector_as_span<byte>(318, 1); }
#else
  public ArraySegment<byte>? GetOrigNetworkBytes() { return __p.__vector_as_arraysegment(318); }
#endif
  public byte[] GetOrigNetworkArray() { return __p.__vector_as_array<byte>(318); }

  public static void StartTrackDetails_Ingest(FlatBufferBuilder builder) { builder.StartTable(158); }
  public static void AddId(FlatBufferBuilder builder, StringOffset idOffset) { builder.AddOffset(0, idOffset.Value, 0); }
  public static void AddClassificationMarking(FlatBufferBuilder builder, StringOffset classificationMarkingOffset) { builder.AddOffset(1, classificationMarkingOffset.Value, 0); }
  public static void AddEnv(FlatBufferBuilder builder, TrackDetails_Ingest_env_Enum env) { builder.AddSbyte(2, (sbyte)env, 0); }
  public static void AddMsgType(FlatBufferBuilder builder, StringOffset msgTypeOffset) { builder.AddOffset(3, msgTypeOffset.Value, 0); }
  public static void AddHullNum(FlatBufferBuilder builder, StringOffset hullNumOffset) { builder.AddOffset(4, hullNumOffset.Value, 0); }
  public static void AddPif(FlatBufferBuilder builder, StringOffset pifOffset) { builder.AddOffset(5, pifOffset.Value, 0); }
  public static void AddSconum(FlatBufferBuilder builder, StringOffset sconumOffset) { builder.AddOffset(6, sconumOffset.Value, 0); }
  public static void AddNtds(FlatBufferBuilder builder, StringOffset ntdsOffset) { builder.AddOffset(7, ntdsOffset.Value, 0); }
  public static void AddDisId(FlatBufferBuilder builder, StringOffset disIdOffset) { builder.AddOffset(8, disIdOffset.Value, 0); }
  public static void AddMidbCat(FlatBufferBuilder builder, StringOffset midbCatOffset) { builder.AddOffset(9, midbCatOffset.Value, 0); }
  public static void AddBeNumber(FlatBufferBuilder builder, StringOffset beNumberOffset) { builder.AddOffset(10, beNumberOffset.Value, 0); }
  public static void AddOSuffix(FlatBufferBuilder builder, StringOffset oSuffixOffset) { builder.AddOffset(11, oSuffixOffset.Value, 0); }
  public static void AddPin(FlatBufferBuilder builder, StringOffset pinOffset) { builder.AddOffset(12, pinOffset.Value, 0); }
  public static void AddLostTrkInd(FlatBufferBuilder builder, bool lostTrkInd) { builder.AddBool(13, lostTrkInd, false); }
  public static void AddMuidSrcTrk(FlatBufferBuilder builder, StringOffset muidSrcTrkOffset) { builder.AddOffset(14, muidSrcTrkOffset.Value, 0); }
  public static void AddMuidSrc(FlatBufferBuilder builder, StringOffset muidSrcOffset) { builder.AddOffset(15, muidSrcOffset.Value, 0); }
  public static void AddMslStatus(FlatBufferBuilder builder, StringOffset mslStatusOffset) { builder.AddOffset(16, mslStatusOffset.Value, 0); }
  public static void AddTrkConf(FlatBufferBuilder builder, double trkConf) { builder.AddDouble(17, trkConf, 0.0); }
  public static void AddTrkQual(FlatBufferBuilder builder, int trkQual) { builder.AddInt(18, trkQual, 0); }
  public static void AddAlert(FlatBufferBuilder builder, StringOffset alertOffset) { builder.AddOffset(19, alertOffset.Value, 0); }
  public static void AddOrigXref(FlatBufferBuilder builder, StringOffset origXrefOffset) { builder.AddOffset(20, origXrefOffset.Value, 0); }
  public static void AddElnot1(FlatBufferBuilder builder, StringOffset elnot1Offset) { builder.AddOffset(21, elnot1Offset.Value, 0); }
  public static void AddElnot2(FlatBufferBuilder builder, StringOffset elnot2Offset) { builder.AddOffset(22, elnot2Offset.Value, 0); }
  public static void AddObjIdent(FlatBufferBuilder builder, TrackDetails_Ingest_objIdent_Enum objIdent) { builder.AddSbyte(23, (sbyte)objIdent, 0); }
  public static void AddObjType(FlatBufferBuilder builder, StringOffset objTypeOffset) { builder.AddOffset(24, objTypeOffset.Value, 0); }
  public static void AddObjPlat(FlatBufferBuilder builder, StringOffset objPlatOffset) { builder.AddOffset(25, objPlatOffset.Value, 0); }
  public static void AddObjAct(FlatBufferBuilder builder, StringOffset objActOffset) { builder.AddOffset(26, objActOffset.Value, 0); }
  public static void AddObjNat(FlatBufferBuilder builder, StringOffset objNatOffset) { builder.AddOffset(27, objNatOffset.Value, 0); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(28, nameOffset.Value, 0); }
  public static void AddShortName(FlatBufferBuilder builder, StringOffset shortNameOffset) { builder.AddOffset(29, shortNameOffset.Value, 0); }
  public static void AddTrkId(FlatBufferBuilder builder, StringOffset trkIdOffset) { builder.AddOffset(30, trkIdOffset.Value, 0); }
  public static void AddTrkNum(FlatBufferBuilder builder, StringOffset trkNumOffset) { builder.AddOffset(31, trkNumOffset.Value, 0); }
  public static void AddTrkScope(FlatBufferBuilder builder, StringOffset trkScopeOffset) { builder.AddOffset(32, trkScopeOffset.Value, 0); }
  public static void AddSourceUid(FlatBufferBuilder builder, StringOffset sourceUidOffset) { builder.AddOffset(33, sourceUidOffset.Value, 0); }
  public static void AddCallSign(FlatBufferBuilder builder, StringOffset callSignOffset) { builder.AddOffset(34, callSignOffset.Value, 0); }
  public static void AddIdentAmp(FlatBufferBuilder builder, StringOffset identAmpOffset) { builder.AddOffset(35, identAmpOffset.Value, 0); }
  public static void AddSpaceAmp(FlatBufferBuilder builder, StringOffset spaceAmpOffset) { builder.AddOffset(36, spaceAmpOffset.Value, 0); }
  public static void AddSpaceAmpConf(FlatBufferBuilder builder, int spaceAmpConf) { builder.AddInt(37, spaceAmpConf, 0); }
  public static void AddSpaceSpecType(FlatBufferBuilder builder, StringOffset spaceSpecTypeOffset) { builder.AddOffset(38, spaceSpecTypeOffset.Value, 0); }
  public static void AddAcftSubType(FlatBufferBuilder builder, StringOffset acftSubTypeOffset) { builder.AddOffset(39, acftSubTypeOffset.Value, 0); }
  public static void AddTs(FlatBufferBuilder builder, StringOffset tsOffset) { builder.AddOffset(40, tsOffset.Value, 0); }
  public static void AddLaunchTime(FlatBufferBuilder builder, StringOffset launchTimeOffset) { builder.AddOffset(41, launchTimeOffset.Value, 0); }
  public static void AddImpactTime(FlatBufferBuilder builder, StringOffset impactTimeOffset) { builder.AddOffset(42, impactTimeOffset.Value, 0); }
  public static void AddFtnMsgTs(FlatBufferBuilder builder, StringOffset ftnMsgTsOffset) { builder.AddOffset(43, ftnMsgTsOffset.Value, 0); }
  public static void AddFtn(FlatBufferBuilder builder, StringOffset ftnOffset) { builder.AddOffset(44, ftnOffset.Value, 0); }
  public static void AddFtnCmd(FlatBufferBuilder builder, StringOffset ftnCmdOffset) { builder.AddOffset(45, ftnCmdOffset.Value, 0); }
  public static void AddRtnMsgTs(FlatBufferBuilder builder, VectorOffset rtnMsgTsOffset) { builder.AddOffset(46, rtnMsgTsOffset.Value, 0); }
  public static VectorOffset CreateRtnMsgTsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateRtnMsgTsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRtnMsgTsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRtnMsgTsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRtnMsgTsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddRtn(FlatBufferBuilder builder, VectorOffset rtnOffset) { builder.AddOffset(47, rtnOffset.Value, 0); }
  public static VectorOffset CreateRtnVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateRtnVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRtnVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRtnVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRtnVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddRtnTrkState(FlatBufferBuilder builder, StringOffset rtnTrkStateOffset) { builder.AddOffset(48, rtnTrkStateOffset.Value, 0); }
  public static void AddRtnCmd(FlatBufferBuilder builder, StringOffset rtnCmdOffset) { builder.AddOffset(49, rtnCmdOffset.Value, 0); }
  public static void AddSen(FlatBufferBuilder builder, StringOffset senOffset) { builder.AddOffset(50, senOffset.Value, 0); }
  public static void AddRptChxref(FlatBufferBuilder builder, StringOffset rptChxrefOffset) { builder.AddOffset(51, rptChxrefOffset.Value, 0); }
  public static void AddRptArchived(FlatBufferBuilder builder, bool rptArchived) { builder.AddBool(52, rptArchived, false); }
  public static void AddSelfReport(FlatBufferBuilder builder, bool selfReport) { builder.AddBool(53, selfReport, false); }
  public static void AddMil2525Bstr(FlatBufferBuilder builder, StringOffset mil2525BstrOffset) { builder.AddOffset(54, mil2525BstrOffset.Value, 0); }
  public static void AddTrnspdrId(FlatBufferBuilder builder, StringOffset trnspdrIdOffset) { builder.AddOffset(55, trnspdrIdOffset.Value, 0); }
  public static void AddTrnspdrType(FlatBufferBuilder builder, StringOffset trnspdrTypeOffset) { builder.AddOffset(56, trnspdrTypeOffset.Value, 0); }
  public static void AddEmitterName(FlatBufferBuilder builder, StringOffset emitterNameOffset) { builder.AddOffset(57, emitterNameOffset.Value, 0); }
  public static void AddInfoSource(FlatBufferBuilder builder, StringOffset infoSourceOffset) { builder.AddOffset(58, infoSourceOffset.Value, 0); }
  public static void AddBoosting(FlatBufferBuilder builder, bool boosting) { builder.AddBool(59, boosting, false); }
  public static void AddFreq(FlatBufferBuilder builder, double freq) { builder.AddDouble(60, freq, 0.0); }
  public static void AddMaxFreq(FlatBufferBuilder builder, double maxFreq) { builder.AddDouble(61, maxFreq, 0.0); }
  public static void AddHarmonics(FlatBufferBuilder builder, StringOffset harmonicsOffset) { builder.AddOffset(62, harmonicsOffset.Value, 0); }
  public static void AddPri(FlatBufferBuilder builder, double pri) { builder.AddDouble(63, pri, 0.0); }
  public static void AddPrf(FlatBufferBuilder builder, double prf) { builder.AddDouble(64, prf, 0.0); }
  public static void AddPw(FlatBufferBuilder builder, double pw) { builder.AddDouble(65, pw, 0.0); }
  public static void AddScanType(FlatBufferBuilder builder, StringOffset scanTypeOffset) { builder.AddOffset(66, scanTypeOffset.Value, 0); }
  public static void AddScanRate(FlatBufferBuilder builder, double scanRate) { builder.AddDouble(67, scanRate, 0.0); }
  public static void AddScn(FlatBufferBuilder builder, int scn) { builder.AddInt(68, scn, 0); }
  public static void AddCI(FlatBufferBuilder builder, StringOffset cIOffset) { builder.AddOffset(69, cIOffset.Value, 0); }
  public static void AddAngElev(FlatBufferBuilder builder, double angElev) { builder.AddDouble(70, angElev, 0.0); }
  public static void AddLat(FlatBufferBuilder builder, double lat) { builder.AddDouble(71, lat, 0.0); }
  public static void AddLon(FlatBufferBuilder builder, double lon) { builder.AddDouble(72, lon, 0.0); }
  public static void AddLaunchLat(FlatBufferBuilder builder, double launchLat) { builder.AddDouble(73, launchLat, 0.0); }
  public static void AddLaunchLon(FlatBufferBuilder builder, double launchLon) { builder.AddDouble(74, launchLon, 0.0); }
  public static void AddImpactLat(FlatBufferBuilder builder, double impactLat) { builder.AddDouble(75, impactLat, 0.0); }
  public static void AddImpactLon(FlatBufferBuilder builder, double impactLon) { builder.AddDouble(76, impactLon, 0.0); }
  public static void AddPolarSingLocLat(FlatBufferBuilder builder, double polarSingLocLat) { builder.AddDouble(77, polarSingLocLat, 0.0); }
  public static void AddPolarSingLocLon(FlatBufferBuilder builder, double polarSingLocLon) { builder.AddDouble(78, polarSingLocLon, 0.0); }
  public static void AddAzCorrCenterLine(FlatBufferBuilder builder, double azCorrCenterLine) { builder.AddDouble(79, azCorrCenterLine, 0.0); }
  public static void AddAzCorrArcWidth(FlatBufferBuilder builder, double azCorrArcWidth) { builder.AddDouble(80, azCorrArcWidth, 0.0); }
  public static void AddErrSemiIntAxis(FlatBufferBuilder builder, double errSemiIntAxis) { builder.AddDouble(81, errSemiIntAxis, 0.0); }
  public static void AddErrAreaOrient(FlatBufferBuilder builder, double errAreaOrient) { builder.AddDouble(82, errAreaOrient, 0.0); }
  public static void AddErrSemiMajElev(FlatBufferBuilder builder, double errSemiMajElev) { builder.AddDouble(83, errSemiMajElev, 0.0); }
  public static void AddErrGeoAreaSwitch(FlatBufferBuilder builder, StringOffset errGeoAreaSwitchOffset) { builder.AddOffset(84, errGeoAreaSwitchOffset.Value, 0); }
  public static void AddBurnoutAlt(FlatBufferBuilder builder, double burnoutAlt) { builder.AddDouble(85, burnoutAlt, 0.0); }
  public static void AddTesEventId(FlatBufferBuilder builder, StringOffset tesEventIdOffset) { builder.AddOffset(86, tesEventIdOffset.Value, 0); }
  public static void AddSpd(FlatBufferBuilder builder, double spd) { builder.AddDouble(87, spd, 0.0); }
  public static void AddAvgSpd(FlatBufferBuilder builder, double avgSpd) { builder.AddDouble(88, avgSpd, 0.0); }
  public static void AddTol(FlatBufferBuilder builder, double tol) { builder.AddDouble(89, tol, 0.0); }
  public static void AddAlt(FlatBufferBuilder builder, double alt) { builder.AddDouble(90, alt, 0.0); }
  public static void AddHdng(FlatBufferBuilder builder, double hdng) { builder.AddDouble(91, hdng, 0.0); }
  public static void AddCourse(FlatBufferBuilder builder, double course) { builder.AddDouble(92, course, 0.0); }
  public static void AddPropRPM(FlatBufferBuilder builder, double propRPM) { builder.AddDouble(93, propRPM, 0.0); }
  public static void AddTpk(FlatBufferBuilder builder, double tpk) { builder.AddDouble(94, tpk, 0.0); }
  public static void AddCoopLocInd(FlatBufferBuilder builder, StringOffset coopLocIndOffset) { builder.AddOffset(95, coopLocIndOffset.Value, 0); }
  public static void AddManeuverInd(FlatBufferBuilder builder, StringOffset maneuverIndOffset) { builder.AddOffset(96, maneuverIndOffset.Value, 0); }
  public static void AddLaunchAouType(FlatBufferBuilder builder, StringOffset launchAouTypeOffset) { builder.AddOffset(97, launchAouTypeOffset.Value, 0); }
  public static void AddLaunchAouData(FlatBufferBuilder builder, VectorOffset launchAouDataOffset) { builder.AddOffset(98, launchAouDataOffset.Value, 0); }
  public static VectorOffset CreateLaunchAouDataVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateLaunchAouDataVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLaunchAouDataVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLaunchAouDataVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartLaunchAouDataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddImpactAouType(FlatBufferBuilder builder, StringOffset impactAouTypeOffset) { builder.AddOffset(99, impactAouTypeOffset.Value, 0); }
  public static void AddImpactAouData(FlatBufferBuilder builder, VectorOffset impactAouDataOffset) { builder.AddOffset(100, impactAouDataOffset.Value, 0); }
  public static VectorOffset CreateImpactAouDataVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateImpactAouDataVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateImpactAouDataVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateImpactAouDataVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartImpactAouDataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddAouRptType(FlatBufferBuilder builder, StringOffset aouRptTypeOffset) { builder.AddOffset(101, aouRptTypeOffset.Value, 0); }
  public static void AddAouRptData(FlatBufferBuilder builder, VectorOffset aouRptDataOffset) { builder.AddOffset(102, aouRptDataOffset.Value, 0); }
  public static VectorOffset CreateAouRptDataVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAouRptDataVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAouRptDataVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAouRptDataVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAouRptDataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddEcefPos(FlatBufferBuilder builder, VectorOffset ecefPosOffset) { builder.AddOffset(103, ecefPosOffset.Value, 0); }
  public static VectorOffset CreateEcefPosVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateEcefPosVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEcefPosVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEcefPosVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartEcefPosVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddEcefVel(FlatBufferBuilder builder, VectorOffset ecefVelOffset) { builder.AddOffset(104, ecefVelOffset.Value, 0); }
  public static VectorOffset CreateEcefVelVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateEcefVelVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEcefVelVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEcefVelVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartEcefVelVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddContainment(FlatBufferBuilder builder, double containment) { builder.AddDouble(105, containment, 0.0); }
  public static void AddCpa(FlatBufferBuilder builder, double cpa) { builder.AddDouble(106, cpa, 0.0); }
  public static void AddTcpa(FlatBufferBuilder builder, StringOffset tcpaOffset) { builder.AddOffset(107, tcpaOffset.Value, 0); }
  public static void AddNavStatus(FlatBufferBuilder builder, StringOffset navStatusOffset) { builder.AddOffset(108, navStatusOffset.Value, 0); }
  public static void AddPosDeviceType(FlatBufferBuilder builder, StringOffset posDeviceTypeOffset) { builder.AddOffset(109, posDeviceTypeOffset.Value, 0); }
  public static void AddAton(FlatBufferBuilder builder, StringOffset atonOffset) { builder.AddOffset(110, atonOffset.Value, 0); }
  public static void AddOffPosInd(FlatBufferBuilder builder, StringOffset offPosIndOffset) { builder.AddOffset(111, offPosIndOffset.Value, 0); }
  public static void AddAntennaRefDimensions(FlatBufferBuilder builder, VectorOffset antennaRefDimensionsOffset) { builder.AddOffset(112, antennaRefDimensionsOffset.Value, 0); }
  public static VectorOffset CreateAntennaRefDimensionsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAntennaRefDimensionsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAntennaRefDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAntennaRefDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAntennaRefDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddShipClass(FlatBufferBuilder builder, StringOffset shipClassOffset) { builder.AddOffset(113, shipClassOffset.Value, 0); }
  public static void AddImon(FlatBufferBuilder builder, int imon) { builder.AddInt(114, imon, 0); }
  public static void AddMmsi(FlatBufferBuilder builder, int mmsi) { builder.AddInt(115, mmsi, 0); }
  public static void AddDraught(FlatBufferBuilder builder, double draught) { builder.AddDouble(116, draught, 0.0); }
  public static void AddLength(FlatBufferBuilder builder, double length) { builder.AddDouble(117, length, 0.0); }
  public static void AddWidth(FlatBufferBuilder builder, double width) { builder.AddDouble(118, width, 0.0); }
  public static void AddCargoType(FlatBufferBuilder builder, StringOffset cargoTypeOffset) { builder.AddOffset(119, cargoTypeOffset.Value, 0); }
  public static void AddAppGrp(FlatBufferBuilder builder, StringOffset appGrpOffset) { builder.AddOffset(120, appGrpOffset.Value, 0); }
  public static void AddHullProf(FlatBufferBuilder builder, StringOffset hullProfOffset) { builder.AddOffset(121, hullProfOffset.Value, 0); }
  public static void AddPropType(FlatBufferBuilder builder, StringOffset propTypeOffset) { builder.AddOffset(122, propTypeOffset.Value, 0); }
  public static void AddNumBlades(FlatBufferBuilder builder, int numBlades) { builder.AddInt(123, numBlades, 0); }
  public static void AddNumShafts(FlatBufferBuilder builder, int numShafts) { builder.AddInt(124, numShafts, 0); }
  public static void AddSternType(FlatBufferBuilder builder, StringOffset sternTypeOffset) { builder.AddOffset(125, sternTypeOffset.Value, 0); }
  public static void AddVslWt(FlatBufferBuilder builder, double vslWt) { builder.AddDouble(126, vslWt, 0.0); }
  public static void AddArrTime(FlatBufferBuilder builder, StringOffset arrTimeOffset) { builder.AddOffset(127, arrTimeOffset.Value, 0); }
  public static void AddArrFlag(FlatBufferBuilder builder, StringOffset arrFlagOffset) { builder.AddOffset(128, arrFlagOffset.Value, 0); }
  public static void AddArrCargo(FlatBufferBuilder builder, StringOffset arrCargoOffset) { builder.AddOffset(129, arrCargoOffset.Value, 0); }
  public static void AddArrPort(FlatBufferBuilder builder, StringOffset arrPortOffset) { builder.AddOffset(130, arrPortOffset.Value, 0); }
  public static void AddDepPort(FlatBufferBuilder builder, StringOffset depPortOffset) { builder.AddOffset(131, depPortOffset.Value, 0); }
  public static void AddDepFlag(FlatBufferBuilder builder, StringOffset depFlagOffset) { builder.AddOffset(132, depFlagOffset.Value, 0); }
  public static void AddDepCargo(FlatBufferBuilder builder, StringOffset depCargoOffset) { builder.AddOffset(133, depCargoOffset.Value, 0); }
  public static void AddDesFlag(FlatBufferBuilder builder, StringOffset desFlagOffset) { builder.AddOffset(134, desFlagOffset.Value, 0); }
  public static void AddDesCargo(FlatBufferBuilder builder, StringOffset desCargoOffset) { builder.AddOffset(135, desCargoOffset.Value, 0); }
  public static void AddDestination(FlatBufferBuilder builder, StringOffset destinationOffset) { builder.AddOffset(136, destinationOffset.Value, 0); }
  public static void AddEta(FlatBufferBuilder builder, StringOffset etaOffset) { builder.AddOffset(137, etaOffset.Value, 0); }
  public static void AddEtd(FlatBufferBuilder builder, StringOffset etdOffset) { builder.AddOffset(138, etdOffset.Value, 0); }
  public static void AddIff(FlatBufferBuilder builder, StringOffset iffOffset) { builder.AddOffset(139, iffOffset.Value, 0); }
  public static void AddEmgInd(FlatBufferBuilder builder, bool emgInd) { builder.AddBool(140, emgInd, false); }
  public static void AddDropPtInd(FlatBufferBuilder builder, bool dropPtInd) { builder.AddBool(141, dropPtInd, false); }
  public static void AddReinforced(FlatBufferBuilder builder, bool reinforced) { builder.AddBool(142, reinforced, false); }
  public static void AddReduced(FlatBufferBuilder builder, bool reduced) { builder.AddBool(143, reduced, false); }
  public static void AddHq(FlatBufferBuilder builder, bool hq) { builder.AddBool(144, hq, false); }
  public static void AddDummy(FlatBufferBuilder builder, bool dummy) { builder.AddBool(145, dummy, false); }
  public static void AddTaskForce(FlatBufferBuilder builder, bool taskForce) { builder.AddBool(146, taskForce, false); }
  public static void AddFeint(FlatBufferBuilder builder, bool feint) { builder.AddBool(147, feint, false); }
  public static void AddInstallation(FlatBufferBuilder builder, bool installation) { builder.AddBool(148, installation, false); }
  public static void AddStaffCmts(FlatBufferBuilder builder, StringOffset staffCmtsOffset) { builder.AddOffset(149, staffCmtsOffset.Value, 0); }
  public static void AddAddInfo(FlatBufferBuilder builder, StringOffset addInfoOffset) { builder.AddOffset(150, addInfoOffset.Value, 0); }
  public static void AddEvalRating(FlatBufferBuilder builder, StringOffset evalRatingOffset) { builder.AddOffset(151, evalRatingOffset.Value, 0); }
  public static void AddCreatedAt(FlatBufferBuilder builder, StringOffset createdAtOffset) { builder.AddOffset(152, createdAtOffset.Value, 0); }
  public static void AddCreatedBy(FlatBufferBuilder builder, StringOffset createdByOffset) { builder.AddOffset(153, createdByOffset.Value, 0); }
  public static void AddSource(FlatBufferBuilder builder, StringOffset sourceOffset) { builder.AddOffset(154, sourceOffset.Value, 0); }
  public static void AddOrigin(FlatBufferBuilder builder, StringOffset originOffset) { builder.AddOffset(155, originOffset.Value, 0); }
  public static void AddDataMode(FlatBufferBuilder builder, TrackDetails_Ingest_dataMode_Enum dataMode) { builder.AddSbyte(156, (sbyte)dataMode, 0); }
  public static void AddOrigNetwork(FlatBufferBuilder builder, StringOffset origNetworkOffset) { builder.AddOffset(157, origNetworkOffset.Value, 0); }
  public static Offset<TrackDetails_Ingest> EndTrackDetails_Ingest(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<TrackDetails_Ingest>(o);
  }
  public static void FinishTrackDetails_IngestBuffer(FlatBufferBuilder builder, Offset<TrackDetails_Ingest> offset) { builder.Finish(offset.Value, "TRAC"); }
  public static void FinishSizePrefixedTrackDetails_IngestBuffer(FlatBufferBuilder builder, Offset<TrackDetails_Ingest> offset) { builder.FinishSizePrefixed(offset.Value, "TRAC"); }
  public TrackDetails_IngestT UnPack() {
    var _o = new TrackDetails_IngestT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TrackDetails_IngestT _o) {
    _o.Id = this.Id;
    _o.ClassificationMarking = this.ClassificationMarking;
    _o.Env = this.Env;
    _o.MsgType = this.MsgType;
    _o.HullNum = this.HullNum;
    _o.Pif = this.Pif;
    _o.Sconum = this.Sconum;
    _o.Ntds = this.Ntds;
    _o.DisId = this.DisId;
    _o.MidbCat = this.MidbCat;
    _o.BeNumber = this.BeNumber;
    _o.OSuffix = this.OSuffix;
    _o.Pin = this.Pin;
    _o.LostTrkInd = this.LostTrkInd;
    _o.MuidSrcTrk = this.MuidSrcTrk;
    _o.MuidSrc = this.MuidSrc;
    _o.MslStatus = this.MslStatus;
    _o.TrkConf = this.TrkConf;
    _o.TrkQual = this.TrkQual;
    _o.Alert = this.Alert;
    _o.OrigXref = this.OrigXref;
    _o.Elnot1 = this.Elnot1;
    _o.Elnot2 = this.Elnot2;
    _o.ObjIdent = this.ObjIdent;
    _o.ObjType = this.ObjType;
    _o.ObjPlat = this.ObjPlat;
    _o.ObjAct = this.ObjAct;
    _o.ObjNat = this.ObjNat;
    _o.Name = this.Name;
    _o.ShortName = this.ShortName;
    _o.TrkId = this.TrkId;
    _o.TrkNum = this.TrkNum;
    _o.TrkScope = this.TrkScope;
    _o.SourceUid = this.SourceUid;
    _o.CallSign = this.CallSign;
    _o.IdentAmp = this.IdentAmp;
    _o.SpaceAmp = this.SpaceAmp;
    _o.SpaceAmpConf = this.SpaceAmpConf;
    _o.SpaceSpecType = this.SpaceSpecType;
    _o.AcftSubType = this.AcftSubType;
    _o.Ts = this.Ts;
    _o.LaunchTime = this.LaunchTime;
    _o.ImpactTime = this.ImpactTime;
    _o.FtnMsgTs = this.FtnMsgTs;
    _o.Ftn = this.Ftn;
    _o.FtnCmd = this.FtnCmd;
    _o.RtnMsgTs = new List<string>();
    for (var _j = 0; _j < this.RtnMsgTsLength; ++_j) {_o.RtnMsgTs.Add(this.RtnMsgTs(_j));}
    _o.Rtn = new List<string>();
    for (var _j = 0; _j < this.RtnLength; ++_j) {_o.Rtn.Add(this.Rtn(_j));}
    _o.RtnTrkState = this.RtnTrkState;
    _o.RtnCmd = this.RtnCmd;
    _o.Sen = this.Sen;
    _o.RptChxref = this.RptChxref;
    _o.RptArchived = this.RptArchived;
    _o.SelfReport = this.SelfReport;
    _o.Mil2525Bstr = this.Mil2525Bstr;
    _o.TrnspdrId = this.TrnspdrId;
    _o.TrnspdrType = this.TrnspdrType;
    _o.EmitterName = this.EmitterName;
    _o.InfoSource = this.InfoSource;
    _o.Boosting = this.Boosting;
    _o.Freq = this.Freq;
    _o.MaxFreq = this.MaxFreq;
    _o.Harmonics = this.Harmonics;
    _o.Pri = this.Pri;
    _o.Prf = this.Prf;
    _o.Pw = this.Pw;
    _o.ScanType = this.ScanType;
    _o.ScanRate = this.ScanRate;
    _o.Scn = this.Scn;
    _o.CI = this.CI;
    _o.AngElev = this.AngElev;
    _o.Lat = this.Lat;
    _o.Lon = this.Lon;
    _o.LaunchLat = this.LaunchLat;
    _o.LaunchLon = this.LaunchLon;
    _o.ImpactLat = this.ImpactLat;
    _o.ImpactLon = this.ImpactLon;
    _o.PolarSingLocLat = this.PolarSingLocLat;
    _o.PolarSingLocLon = this.PolarSingLocLon;
    _o.AzCorrCenterLine = this.AzCorrCenterLine;
    _o.AzCorrArcWidth = this.AzCorrArcWidth;
    _o.ErrSemiIntAxis = this.ErrSemiIntAxis;
    _o.ErrAreaOrient = this.ErrAreaOrient;
    _o.ErrSemiMajElev = this.ErrSemiMajElev;
    _o.ErrGeoAreaSwitch = this.ErrGeoAreaSwitch;
    _o.BurnoutAlt = this.BurnoutAlt;
    _o.TesEventId = this.TesEventId;
    _o.Spd = this.Spd;
    _o.AvgSpd = this.AvgSpd;
    _o.Tol = this.Tol;
    _o.Alt = this.Alt;
    _o.Hdng = this.Hdng;
    _o.Course = this.Course;
    _o.PropRPM = this.PropRPM;
    _o.Tpk = this.Tpk;
    _o.CoopLocInd = this.CoopLocInd;
    _o.ManeuverInd = this.ManeuverInd;
    _o.LaunchAouType = this.LaunchAouType;
    _o.LaunchAouData = new List<string>();
    for (var _j = 0; _j < this.LaunchAouDataLength; ++_j) {_o.LaunchAouData.Add(this.LaunchAouData(_j));}
    _o.ImpactAouType = this.ImpactAouType;
    _o.ImpactAouData = new List<string>();
    for (var _j = 0; _j < this.ImpactAouDataLength; ++_j) {_o.ImpactAouData.Add(this.ImpactAouData(_j));}
    _o.AouRptType = this.AouRptType;
    _o.AouRptData = new List<string>();
    for (var _j = 0; _j < this.AouRptDataLength; ++_j) {_o.AouRptData.Add(this.AouRptData(_j));}
    _o.EcefPos = new List<string>();
    for (var _j = 0; _j < this.EcefPosLength; ++_j) {_o.EcefPos.Add(this.EcefPos(_j));}
    _o.EcefVel = new List<string>();
    for (var _j = 0; _j < this.EcefVelLength; ++_j) {_o.EcefVel.Add(this.EcefVel(_j));}
    _o.Containment = this.Containment;
    _o.Cpa = this.Cpa;
    _o.Tcpa = this.Tcpa;
    _o.NavStatus = this.NavStatus;
    _o.PosDeviceType = this.PosDeviceType;
    _o.Aton = this.Aton;
    _o.OffPosInd = this.OffPosInd;
    _o.AntennaRefDimensions = new List<string>();
    for (var _j = 0; _j < this.AntennaRefDimensionsLength; ++_j) {_o.AntennaRefDimensions.Add(this.AntennaRefDimensions(_j));}
    _o.ShipClass = this.ShipClass;
    _o.Imon = this.Imon;
    _o.Mmsi = this.Mmsi;
    _o.Draught = this.Draught;
    _o.Length = this.Length;
    _o.Width = this.Width;
    _o.CargoType = this.CargoType;
    _o.AppGrp = this.AppGrp;
    _o.HullProf = this.HullProf;
    _o.PropType = this.PropType;
    _o.NumBlades = this.NumBlades;
    _o.NumShafts = this.NumShafts;
    _o.SternType = this.SternType;
    _o.VslWt = this.VslWt;
    _o.ArrTime = this.ArrTime;
    _o.ArrFlag = this.ArrFlag;
    _o.ArrCargo = this.ArrCargo;
    _o.ArrPort = this.ArrPort;
    _o.DepPort = this.DepPort;
    _o.DepFlag = this.DepFlag;
    _o.DepCargo = this.DepCargo;
    _o.DesFlag = this.DesFlag;
    _o.DesCargo = this.DesCargo;
    _o.Destination = this.Destination;
    _o.Eta = this.Eta;
    _o.Etd = this.Etd;
    _o.Iff = this.Iff;
    _o.EmgInd = this.EmgInd;
    _o.DropPtInd = this.DropPtInd;
    _o.Reinforced = this.Reinforced;
    _o.Reduced = this.Reduced;
    _o.Hq = this.Hq;
    _o.Dummy = this.Dummy;
    _o.TaskForce = this.TaskForce;
    _o.Feint = this.Feint;
    _o.Installation = this.Installation;
    _o.StaffCmts = this.StaffCmts;
    _o.AddInfo = this.AddInfo;
    _o.EvalRating = this.EvalRating;
    _o.CreatedAt = this.CreatedAt;
    _o.CreatedBy = this.CreatedBy;
    _o.Source = this.Source;
    _o.Origin = this.Origin;
    _o.DataMode = this.DataMode;
    _o.OrigNetwork = this.OrigNetwork;
  }
  public static Offset<TrackDetails_Ingest> Pack(FlatBufferBuilder builder, TrackDetails_IngestT _o) {
    if (_o == null) return default(Offset<TrackDetails_Ingest>);
    var _id = _o.Id == null ? default(StringOffset) : builder.CreateString(_o.Id);
    var _classificationMarking = _o.ClassificationMarking == null ? default(StringOffset) : builder.CreateString(_o.ClassificationMarking);
    var _msgType = _o.MsgType == null ? default(StringOffset) : builder.CreateString(_o.MsgType);
    var _hullNum = _o.HullNum == null ? default(StringOffset) : builder.CreateString(_o.HullNum);
    var _pif = _o.Pif == null ? default(StringOffset) : builder.CreateString(_o.Pif);
    var _sconum = _o.Sconum == null ? default(StringOffset) : builder.CreateString(_o.Sconum);
    var _ntds = _o.Ntds == null ? default(StringOffset) : builder.CreateString(_o.Ntds);
    var _disId = _o.DisId == null ? default(StringOffset) : builder.CreateString(_o.DisId);
    var _midbCat = _o.MidbCat == null ? default(StringOffset) : builder.CreateString(_o.MidbCat);
    var _beNumber = _o.BeNumber == null ? default(StringOffset) : builder.CreateString(_o.BeNumber);
    var _oSuffix = _o.OSuffix == null ? default(StringOffset) : builder.CreateString(_o.OSuffix);
    var _pin = _o.Pin == null ? default(StringOffset) : builder.CreateString(_o.Pin);
    var _muidSrcTrk = _o.MuidSrcTrk == null ? default(StringOffset) : builder.CreateString(_o.MuidSrcTrk);
    var _muidSrc = _o.MuidSrc == null ? default(StringOffset) : builder.CreateString(_o.MuidSrc);
    var _mslStatus = _o.MslStatus == null ? default(StringOffset) : builder.CreateString(_o.MslStatus);
    var _alert = _o.Alert == null ? default(StringOffset) : builder.CreateString(_o.Alert);
    var _origXref = _o.OrigXref == null ? default(StringOffset) : builder.CreateString(_o.OrigXref);
    var _elnot1 = _o.Elnot1 == null ? default(StringOffset) : builder.CreateString(_o.Elnot1);
    var _elnot2 = _o.Elnot2 == null ? default(StringOffset) : builder.CreateString(_o.Elnot2);
    var _objType = _o.ObjType == null ? default(StringOffset) : builder.CreateString(_o.ObjType);
    var _objPlat = _o.ObjPlat == null ? default(StringOffset) : builder.CreateString(_o.ObjPlat);
    var _objAct = _o.ObjAct == null ? default(StringOffset) : builder.CreateString(_o.ObjAct);
    var _objNat = _o.ObjNat == null ? default(StringOffset) : builder.CreateString(_o.ObjNat);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _shortName = _o.ShortName == null ? default(StringOffset) : builder.CreateString(_o.ShortName);
    var _trkId = _o.TrkId == null ? default(StringOffset) : builder.CreateString(_o.TrkId);
    var _trkNum = _o.TrkNum == null ? default(StringOffset) : builder.CreateString(_o.TrkNum);
    var _trkScope = _o.TrkScope == null ? default(StringOffset) : builder.CreateString(_o.TrkScope);
    var _sourceUid = _o.SourceUid == null ? default(StringOffset) : builder.CreateString(_o.SourceUid);
    var _callSign = _o.CallSign == null ? default(StringOffset) : builder.CreateString(_o.CallSign);
    var _identAmp = _o.IdentAmp == null ? default(StringOffset) : builder.CreateString(_o.IdentAmp);
    var _spaceAmp = _o.SpaceAmp == null ? default(StringOffset) : builder.CreateString(_o.SpaceAmp);
    var _spaceSpecType = _o.SpaceSpecType == null ? default(StringOffset) : builder.CreateString(_o.SpaceSpecType);
    var _acftSubType = _o.AcftSubType == null ? default(StringOffset) : builder.CreateString(_o.AcftSubType);
    var _ts = _o.Ts == null ? default(StringOffset) : builder.CreateString(_o.Ts);
    var _launchTime = _o.LaunchTime == null ? default(StringOffset) : builder.CreateString(_o.LaunchTime);
    var _impactTime = _o.ImpactTime == null ? default(StringOffset) : builder.CreateString(_o.ImpactTime);
    var _ftnMsgTs = _o.FtnMsgTs == null ? default(StringOffset) : builder.CreateString(_o.FtnMsgTs);
    var _ftn = _o.Ftn == null ? default(StringOffset) : builder.CreateString(_o.Ftn);
    var _ftnCmd = _o.FtnCmd == null ? default(StringOffset) : builder.CreateString(_o.FtnCmd);
    var _rtnMsgTs = default(VectorOffset);
    if (_o.RtnMsgTs != null) {
      var __rtnMsgTs = new StringOffset[_o.RtnMsgTs.Count];
      for (var _j = 0; _j < __rtnMsgTs.Length; ++_j) { __rtnMsgTs[_j] = builder.CreateString(_o.RtnMsgTs[_j]); }
      _rtnMsgTs = CreateRtnMsgTsVector(builder, __rtnMsgTs);
    }
    var _rtn = default(VectorOffset);
    if (_o.Rtn != null) {
      var __rtn = new StringOffset[_o.Rtn.Count];
      for (var _j = 0; _j < __rtn.Length; ++_j) { __rtn[_j] = builder.CreateString(_o.Rtn[_j]); }
      _rtn = CreateRtnVector(builder, __rtn);
    }
    var _rtnTrkState = _o.RtnTrkState == null ? default(StringOffset) : builder.CreateString(_o.RtnTrkState);
    var _rtnCmd = _o.RtnCmd == null ? default(StringOffset) : builder.CreateString(_o.RtnCmd);
    var _sen = _o.Sen == null ? default(StringOffset) : builder.CreateString(_o.Sen);
    var _rptChxref = _o.RptChxref == null ? default(StringOffset) : builder.CreateString(_o.RptChxref);
    var _mil2525Bstr = _o.Mil2525Bstr == null ? default(StringOffset) : builder.CreateString(_o.Mil2525Bstr);
    var _trnspdrId = _o.TrnspdrId == null ? default(StringOffset) : builder.CreateString(_o.TrnspdrId);
    var _trnspdrType = _o.TrnspdrType == null ? default(StringOffset) : builder.CreateString(_o.TrnspdrType);
    var _emitterName = _o.EmitterName == null ? default(StringOffset) : builder.CreateString(_o.EmitterName);
    var _infoSource = _o.InfoSource == null ? default(StringOffset) : builder.CreateString(_o.InfoSource);
    var _harmonics = _o.Harmonics == null ? default(StringOffset) : builder.CreateString(_o.Harmonics);
    var _scanType = _o.ScanType == null ? default(StringOffset) : builder.CreateString(_o.ScanType);
    var _cI = _o.CI == null ? default(StringOffset) : builder.CreateString(_o.CI);
    var _errGeoAreaSwitch = _o.ErrGeoAreaSwitch == null ? default(StringOffset) : builder.CreateString(_o.ErrGeoAreaSwitch);
    var _tesEventId = _o.TesEventId == null ? default(StringOffset) : builder.CreateString(_o.TesEventId);
    var _coopLocInd = _o.CoopLocInd == null ? default(StringOffset) : builder.CreateString(_o.CoopLocInd);
    var _maneuverInd = _o.ManeuverInd == null ? default(StringOffset) : builder.CreateString(_o.ManeuverInd);
    var _launchAouType = _o.LaunchAouType == null ? default(StringOffset) : builder.CreateString(_o.LaunchAouType);
    var _launchAouData = default(VectorOffset);
    if (_o.LaunchAouData != null) {
      var __launchAouData = new StringOffset[_o.LaunchAouData.Count];
      for (var _j = 0; _j < __launchAouData.Length; ++_j) { __launchAouData[_j] = builder.CreateString(_o.LaunchAouData[_j]); }
      _launchAouData = CreateLaunchAouDataVector(builder, __launchAouData);
    }
    var _impactAouType = _o.ImpactAouType == null ? default(StringOffset) : builder.CreateString(_o.ImpactAouType);
    var _impactAouData = default(VectorOffset);
    if (_o.ImpactAouData != null) {
      var __impactAouData = new StringOffset[_o.ImpactAouData.Count];
      for (var _j = 0; _j < __impactAouData.Length; ++_j) { __impactAouData[_j] = builder.CreateString(_o.ImpactAouData[_j]); }
      _impactAouData = CreateImpactAouDataVector(builder, __impactAouData);
    }
    var _aouRptType = _o.AouRptType == null ? default(StringOffset) : builder.CreateString(_o.AouRptType);
    var _aouRptData = default(VectorOffset);
    if (_o.AouRptData != null) {
      var __aouRptData = new StringOffset[_o.AouRptData.Count];
      for (var _j = 0; _j < __aouRptData.Length; ++_j) { __aouRptData[_j] = builder.CreateString(_o.AouRptData[_j]); }
      _aouRptData = CreateAouRptDataVector(builder, __aouRptData);
    }
    var _ecefPos = default(VectorOffset);
    if (_o.EcefPos != null) {
      var __ecefPos = new StringOffset[_o.EcefPos.Count];
      for (var _j = 0; _j < __ecefPos.Length; ++_j) { __ecefPos[_j] = builder.CreateString(_o.EcefPos[_j]); }
      _ecefPos = CreateEcefPosVector(builder, __ecefPos);
    }
    var _ecefVel = default(VectorOffset);
    if (_o.EcefVel != null) {
      var __ecefVel = new StringOffset[_o.EcefVel.Count];
      for (var _j = 0; _j < __ecefVel.Length; ++_j) { __ecefVel[_j] = builder.CreateString(_o.EcefVel[_j]); }
      _ecefVel = CreateEcefVelVector(builder, __ecefVel);
    }
    var _tcpa = _o.Tcpa == null ? default(StringOffset) : builder.CreateString(_o.Tcpa);
    var _navStatus = _o.NavStatus == null ? default(StringOffset) : builder.CreateString(_o.NavStatus);
    var _posDeviceType = _o.PosDeviceType == null ? default(StringOffset) : builder.CreateString(_o.PosDeviceType);
    var _aton = _o.Aton == null ? default(StringOffset) : builder.CreateString(_o.Aton);
    var _offPosInd = _o.OffPosInd == null ? default(StringOffset) : builder.CreateString(_o.OffPosInd);
    var _antennaRefDimensions = default(VectorOffset);
    if (_o.AntennaRefDimensions != null) {
      var __antennaRefDimensions = new StringOffset[_o.AntennaRefDimensions.Count];
      for (var _j = 0; _j < __antennaRefDimensions.Length; ++_j) { __antennaRefDimensions[_j] = builder.CreateString(_o.AntennaRefDimensions[_j]); }
      _antennaRefDimensions = CreateAntennaRefDimensionsVector(builder, __antennaRefDimensions);
    }
    var _shipClass = _o.ShipClass == null ? default(StringOffset) : builder.CreateString(_o.ShipClass);
    var _cargoType = _o.CargoType == null ? default(StringOffset) : builder.CreateString(_o.CargoType);
    var _appGrp = _o.AppGrp == null ? default(StringOffset) : builder.CreateString(_o.AppGrp);
    var _hullProf = _o.HullProf == null ? default(StringOffset) : builder.CreateString(_o.HullProf);
    var _propType = _o.PropType == null ? default(StringOffset) : builder.CreateString(_o.PropType);
    var _sternType = _o.SternType == null ? default(StringOffset) : builder.CreateString(_o.SternType);
    var _arrTime = _o.ArrTime == null ? default(StringOffset) : builder.CreateString(_o.ArrTime);
    var _arrFlag = _o.ArrFlag == null ? default(StringOffset) : builder.CreateString(_o.ArrFlag);
    var _arrCargo = _o.ArrCargo == null ? default(StringOffset) : builder.CreateString(_o.ArrCargo);
    var _arrPort = _o.ArrPort == null ? default(StringOffset) : builder.CreateString(_o.ArrPort);
    var _depPort = _o.DepPort == null ? default(StringOffset) : builder.CreateString(_o.DepPort);
    var _depFlag = _o.DepFlag == null ? default(StringOffset) : builder.CreateString(_o.DepFlag);
    var _depCargo = _o.DepCargo == null ? default(StringOffset) : builder.CreateString(_o.DepCargo);
    var _desFlag = _o.DesFlag == null ? default(StringOffset) : builder.CreateString(_o.DesFlag);
    var _desCargo = _o.DesCargo == null ? default(StringOffset) : builder.CreateString(_o.DesCargo);
    var _destination = _o.Destination == null ? default(StringOffset) : builder.CreateString(_o.Destination);
    var _eta = _o.Eta == null ? default(StringOffset) : builder.CreateString(_o.Eta);
    var _etd = _o.Etd == null ? default(StringOffset) : builder.CreateString(_o.Etd);
    var _iff = _o.Iff == null ? default(StringOffset) : builder.CreateString(_o.Iff);
    var _staffCmts = _o.StaffCmts == null ? default(StringOffset) : builder.CreateString(_o.StaffCmts);
    var _addInfo = _o.AddInfo == null ? default(StringOffset) : builder.CreateString(_o.AddInfo);
    var _evalRating = _o.EvalRating == null ? default(StringOffset) : builder.CreateString(_o.EvalRating);
    var _createdAt = _o.CreatedAt == null ? default(StringOffset) : builder.CreateString(_o.CreatedAt);
    var _createdBy = _o.CreatedBy == null ? default(StringOffset) : builder.CreateString(_o.CreatedBy);
    var _source = _o.Source == null ? default(StringOffset) : builder.CreateString(_o.Source);
    var _origin = _o.Origin == null ? default(StringOffset) : builder.CreateString(_o.Origin);
    var _origNetwork = _o.OrigNetwork == null ? default(StringOffset) : builder.CreateString(_o.OrigNetwork);
    StartTrackDetails_Ingest(builder);
    AddId(builder, _id);
    AddClassificationMarking(builder, _classificationMarking);
    AddEnv(builder, _o.Env);
    AddMsgType(builder, _msgType);
    AddHullNum(builder, _hullNum);
    AddPif(builder, _pif);
    AddSconum(builder, _sconum);
    AddNtds(builder, _ntds);
    AddDisId(builder, _disId);
    AddMidbCat(builder, _midbCat);
    AddBeNumber(builder, _beNumber);
    AddOSuffix(builder, _oSuffix);
    AddPin(builder, _pin);
    AddLostTrkInd(builder, _o.LostTrkInd);
    AddMuidSrcTrk(builder, _muidSrcTrk);
    AddMuidSrc(builder, _muidSrc);
    AddMslStatus(builder, _mslStatus);
    AddTrkConf(builder, _o.TrkConf);
    AddTrkQual(builder, _o.TrkQual);
    AddAlert(builder, _alert);
    AddOrigXref(builder, _origXref);
    AddElnot1(builder, _elnot1);
    AddElnot2(builder, _elnot2);
    AddObjIdent(builder, _o.ObjIdent);
    AddObjType(builder, _objType);
    AddObjPlat(builder, _objPlat);
    AddObjAct(builder, _objAct);
    AddObjNat(builder, _objNat);
    AddName(builder, _name);
    AddShortName(builder, _shortName);
    AddTrkId(builder, _trkId);
    AddTrkNum(builder, _trkNum);
    AddTrkScope(builder, _trkScope);
    AddSourceUid(builder, _sourceUid);
    AddCallSign(builder, _callSign);
    AddIdentAmp(builder, _identAmp);
    AddSpaceAmp(builder, _spaceAmp);
    AddSpaceAmpConf(builder, _o.SpaceAmpConf);
    AddSpaceSpecType(builder, _spaceSpecType);
    AddAcftSubType(builder, _acftSubType);
    AddTs(builder, _ts);
    AddLaunchTime(builder, _launchTime);
    AddImpactTime(builder, _impactTime);
    AddFtnMsgTs(builder, _ftnMsgTs);
    AddFtn(builder, _ftn);
    AddFtnCmd(builder, _ftnCmd);
    AddRtnMsgTs(builder, _rtnMsgTs);
    AddRtn(builder, _rtn);
    AddRtnTrkState(builder, _rtnTrkState);
    AddRtnCmd(builder, _rtnCmd);
    AddSen(builder, _sen);
    AddRptChxref(builder, _rptChxref);
    AddRptArchived(builder, _o.RptArchived);
    AddSelfReport(builder, _o.SelfReport);
    AddMil2525Bstr(builder, _mil2525Bstr);
    AddTrnspdrId(builder, _trnspdrId);
    AddTrnspdrType(builder, _trnspdrType);
    AddEmitterName(builder, _emitterName);
    AddInfoSource(builder, _infoSource);
    AddBoosting(builder, _o.Boosting);
    AddFreq(builder, _o.Freq);
    AddMaxFreq(builder, _o.MaxFreq);
    AddHarmonics(builder, _harmonics);
    AddPri(builder, _o.Pri);
    AddPrf(builder, _o.Prf);
    AddPw(builder, _o.Pw);
    AddScanType(builder, _scanType);
    AddScanRate(builder, _o.ScanRate);
    AddScn(builder, _o.Scn);
    AddCI(builder, _cI);
    AddAngElev(builder, _o.AngElev);
    AddLat(builder, _o.Lat);
    AddLon(builder, _o.Lon);
    AddLaunchLat(builder, _o.LaunchLat);
    AddLaunchLon(builder, _o.LaunchLon);
    AddImpactLat(builder, _o.ImpactLat);
    AddImpactLon(builder, _o.ImpactLon);
    AddPolarSingLocLat(builder, _o.PolarSingLocLat);
    AddPolarSingLocLon(builder, _o.PolarSingLocLon);
    AddAzCorrCenterLine(builder, _o.AzCorrCenterLine);
    AddAzCorrArcWidth(builder, _o.AzCorrArcWidth);
    AddErrSemiIntAxis(builder, _o.ErrSemiIntAxis);
    AddErrAreaOrient(builder, _o.ErrAreaOrient);
    AddErrSemiMajElev(builder, _o.ErrSemiMajElev);
    AddErrGeoAreaSwitch(builder, _errGeoAreaSwitch);
    AddBurnoutAlt(builder, _o.BurnoutAlt);
    AddTesEventId(builder, _tesEventId);
    AddSpd(builder, _o.Spd);
    AddAvgSpd(builder, _o.AvgSpd);
    AddTol(builder, _o.Tol);
    AddAlt(builder, _o.Alt);
    AddHdng(builder, _o.Hdng);
    AddCourse(builder, _o.Course);
    AddPropRPM(builder, _o.PropRPM);
    AddTpk(builder, _o.Tpk);
    AddCoopLocInd(builder, _coopLocInd);
    AddManeuverInd(builder, _maneuverInd);
    AddLaunchAouType(builder, _launchAouType);
    AddLaunchAouData(builder, _launchAouData);
    AddImpactAouType(builder, _impactAouType);
    AddImpactAouData(builder, _impactAouData);
    AddAouRptType(builder, _aouRptType);
    AddAouRptData(builder, _aouRptData);
    AddEcefPos(builder, _ecefPos);
    AddEcefVel(builder, _ecefVel);
    AddContainment(builder, _o.Containment);
    AddCpa(builder, _o.Cpa);
    AddTcpa(builder, _tcpa);
    AddNavStatus(builder, _navStatus);
    AddPosDeviceType(builder, _posDeviceType);
    AddAton(builder, _aton);
    AddOffPosInd(builder, _offPosInd);
    AddAntennaRefDimensions(builder, _antennaRefDimensions);
    AddShipClass(builder, _shipClass);
    AddImon(builder, _o.Imon);
    AddMmsi(builder, _o.Mmsi);
    AddDraught(builder, _o.Draught);
    AddLength(builder, _o.Length);
    AddWidth(builder, _o.Width);
    AddCargoType(builder, _cargoType);
    AddAppGrp(builder, _appGrp);
    AddHullProf(builder, _hullProf);
    AddPropType(builder, _propType);
    AddNumBlades(builder, _o.NumBlades);
    AddNumShafts(builder, _o.NumShafts);
    AddSternType(builder, _sternType);
    AddVslWt(builder, _o.VslWt);
    AddArrTime(builder, _arrTime);
    AddArrFlag(builder, _arrFlag);
    AddArrCargo(builder, _arrCargo);
    AddArrPort(builder, _arrPort);
    AddDepPort(builder, _depPort);
    AddDepFlag(builder, _depFlag);
    AddDepCargo(builder, _depCargo);
    AddDesFlag(builder, _desFlag);
    AddDesCargo(builder, _desCargo);
    AddDestination(builder, _destination);
    AddEta(builder, _eta);
    AddEtd(builder, _etd);
    AddIff(builder, _iff);
    AddEmgInd(builder, _o.EmgInd);
    AddDropPtInd(builder, _o.DropPtInd);
    AddReinforced(builder, _o.Reinforced);
    AddReduced(builder, _o.Reduced);
    AddHq(builder, _o.Hq);
    AddDummy(builder, _o.Dummy);
    AddTaskForce(builder, _o.TaskForce);
    AddFeint(builder, _o.Feint);
    AddInstallation(builder, _o.Installation);
    AddStaffCmts(builder, _staffCmts);
    AddAddInfo(builder, _addInfo);
    AddEvalRating(builder, _evalRating);
    AddCreatedAt(builder, _createdAt);
    AddCreatedBy(builder, _createdBy);
    AddSource(builder, _source);
    AddOrigin(builder, _origin);
    AddDataMode(builder, _o.DataMode);
    AddOrigNetwork(builder, _origNetwork);
    return EndTrackDetails_Ingest(builder);
  }
}

public class TrackDetails_IngestT
{
  public string Id { get; set; }
  public string ClassificationMarking { get; set; }
  public TrackDetails_Ingest_env_Enum Env { get; set; }
  public string MsgType { get; set; }
  public string HullNum { get; set; }
  public string Pif { get; set; }
  public string Sconum { get; set; }
  public string Ntds { get; set; }
  public string DisId { get; set; }
  public string MidbCat { get; set; }
  public string BeNumber { get; set; }
  public string OSuffix { get; set; }
  public string Pin { get; set; }
  public bool LostTrkInd { get; set; }
  public string MuidSrcTrk { get; set; }
  public string MuidSrc { get; set; }
  public string MslStatus { get; set; }
  public double TrkConf { get; set; }
  public int TrkQual { get; set; }
  public string Alert { get; set; }
  public string OrigXref { get; set; }
  public string Elnot1 { get; set; }
  public string Elnot2 { get; set; }
  public TrackDetails_Ingest_objIdent_Enum ObjIdent { get; set; }
  public string ObjType { get; set; }
  public string ObjPlat { get; set; }
  public string ObjAct { get; set; }
  public string ObjNat { get; set; }
  public string Name { get; set; }
  public string ShortName { get; set; }
  public string TrkId { get; set; }
  public string TrkNum { get; set; }
  public string TrkScope { get; set; }
  public string SourceUid { get; set; }
  public string CallSign { get; set; }
  public string IdentAmp { get; set; }
  public string SpaceAmp { get; set; }
  public int SpaceAmpConf { get; set; }
  public string SpaceSpecType { get; set; }
  public string AcftSubType { get; set; }
  public string Ts { get; set; }
  public string LaunchTime { get; set; }
  public string ImpactTime { get; set; }
  public string FtnMsgTs { get; set; }
  public string Ftn { get; set; }
  public string FtnCmd { get; set; }
  public List<string> RtnMsgTs { get; set; }
  public List<string> Rtn { get; set; }
  public string RtnTrkState { get; set; }
  public string RtnCmd { get; set; }
  public string Sen { get; set; }
  public string RptChxref { get; set; }
  public bool RptArchived { get; set; }
  public bool SelfReport { get; set; }
  public string Mil2525Bstr { get; set; }
  public string TrnspdrId { get; set; }
  public string TrnspdrType { get; set; }
  public string EmitterName { get; set; }
  public string InfoSource { get; set; }
  public bool Boosting { get; set; }
  public double Freq { get; set; }
  public double MaxFreq { get; set; }
  public string Harmonics { get; set; }
  public double Pri { get; set; }
  public double Prf { get; set; }
  public double Pw { get; set; }
  public string ScanType { get; set; }
  public double ScanRate { get; set; }
  public int Scn { get; set; }
  public string CI { get; set; }
  public double AngElev { get; set; }
  public double Lat { get; set; }
  public double Lon { get; set; }
  public double LaunchLat { get; set; }
  public double LaunchLon { get; set; }
  public double ImpactLat { get; set; }
  public double ImpactLon { get; set; }
  public double PolarSingLocLat { get; set; }
  public double PolarSingLocLon { get; set; }
  public double AzCorrCenterLine { get; set; }
  public double AzCorrArcWidth { get; set; }
  public double ErrSemiIntAxis { get; set; }
  public double ErrAreaOrient { get; set; }
  public double ErrSemiMajElev { get; set; }
  public string ErrGeoAreaSwitch { get; set; }
  public double BurnoutAlt { get; set; }
  public string TesEventId { get; set; }
  public double Spd { get; set; }
  public double AvgSpd { get; set; }
  public double Tol { get; set; }
  public double Alt { get; set; }
  public double Hdng { get; set; }
  public double Course { get; set; }
  public double PropRPM { get; set; }
  public double Tpk { get; set; }
  public string CoopLocInd { get; set; }
  public string ManeuverInd { get; set; }
  public string LaunchAouType { get; set; }
  public List<string> LaunchAouData { get; set; }
  public string ImpactAouType { get; set; }
  public List<string> ImpactAouData { get; set; }
  public string AouRptType { get; set; }
  public List<string> AouRptData { get; set; }
  public List<string> EcefPos { get; set; }
  public List<string> EcefVel { get; set; }
  public double Containment { get; set; }
  public double Cpa { get; set; }
  public string Tcpa { get; set; }
  public string NavStatus { get; set; }
  public string PosDeviceType { get; set; }
  public string Aton { get; set; }
  public string OffPosInd { get; set; }
  public List<string> AntennaRefDimensions { get; set; }
  public string ShipClass { get; set; }
  public int Imon { get; set; }
  public int Mmsi { get; set; }
  public double Draught { get; set; }
  public double Length { get; set; }
  public double Width { get; set; }
  public string CargoType { get; set; }
  public string AppGrp { get; set; }
  public string HullProf { get; set; }
  public string PropType { get; set; }
  public int NumBlades { get; set; }
  public int NumShafts { get; set; }
  public string SternType { get; set; }
  public double VslWt { get; set; }
  public string ArrTime { get; set; }
  public string ArrFlag { get; set; }
  public string ArrCargo { get; set; }
  public string ArrPort { get; set; }
  public string DepPort { get; set; }
  public string DepFlag { get; set; }
  public string DepCargo { get; set; }
  public string DesFlag { get; set; }
  public string DesCargo { get; set; }
  public string Destination { get; set; }
  public string Eta { get; set; }
  public string Etd { get; set; }
  public string Iff { get; set; }
  public bool EmgInd { get; set; }
  public bool DropPtInd { get; set; }
  public bool Reinforced { get; set; }
  public bool Reduced { get; set; }
  public bool Hq { get; set; }
  public bool Dummy { get; set; }
  public bool TaskForce { get; set; }
  public bool Feint { get; set; }
  public bool Installation { get; set; }
  public string StaffCmts { get; set; }
  public string AddInfo { get; set; }
  public string EvalRating { get; set; }
  public string CreatedAt { get; set; }
  public string CreatedBy { get; set; }
  public string Source { get; set; }
  public string Origin { get; set; }
  public TrackDetails_Ingest_dataMode_Enum DataMode { get; set; }
  public string OrigNetwork { get; set; }

  public TrackDetails_IngestT() {
    this.Id = null;
    this.ClassificationMarking = null;
    this.Env = TrackDetails_Ingest_env_Enum.AIR;
    this.MsgType = null;
    this.HullNum = null;
    this.Pif = null;
    this.Sconum = null;
    this.Ntds = null;
    this.DisId = null;
    this.MidbCat = null;
    this.BeNumber = null;
    this.OSuffix = null;
    this.Pin = null;
    this.LostTrkInd = false;
    this.MuidSrcTrk = null;
    this.MuidSrc = null;
    this.MslStatus = null;
    this.TrkConf = 0.0;
    this.TrkQual = 0;
    this.Alert = null;
    this.OrigXref = null;
    this.Elnot1 = null;
    this.Elnot2 = null;
    this.ObjIdent = TrackDetails_Ingest_objIdent_Enum.ASSUMED_FRIEND;
    this.ObjType = null;
    this.ObjPlat = null;
    this.ObjAct = null;
    this.ObjNat = null;
    this.Name = null;
    this.ShortName = null;
    this.TrkId = null;
    this.TrkNum = null;
    this.TrkScope = null;
    this.SourceUid = null;
    this.CallSign = null;
    this.IdentAmp = null;
    this.SpaceAmp = null;
    this.SpaceAmpConf = 0;
    this.SpaceSpecType = null;
    this.AcftSubType = null;
    this.Ts = null;
    this.LaunchTime = null;
    this.ImpactTime = null;
    this.FtnMsgTs = null;
    this.Ftn = null;
    this.FtnCmd = null;
    this.RtnMsgTs = null;
    this.Rtn = null;
    this.RtnTrkState = null;
    this.RtnCmd = null;
    this.Sen = null;
    this.RptChxref = null;
    this.RptArchived = false;
    this.SelfReport = false;
    this.Mil2525Bstr = null;
    this.TrnspdrId = null;
    this.TrnspdrType = null;
    this.EmitterName = null;
    this.InfoSource = null;
    this.Boosting = false;
    this.Freq = 0.0;
    this.MaxFreq = 0.0;
    this.Harmonics = null;
    this.Pri = 0.0;
    this.Prf = 0.0;
    this.Pw = 0.0;
    this.ScanType = null;
    this.ScanRate = 0.0;
    this.Scn = 0;
    this.CI = null;
    this.AngElev = 0.0;
    this.Lat = 0.0;
    this.Lon = 0.0;
    this.LaunchLat = 0.0;
    this.LaunchLon = 0.0;
    this.ImpactLat = 0.0;
    this.ImpactLon = 0.0;
    this.PolarSingLocLat = 0.0;
    this.PolarSingLocLon = 0.0;
    this.AzCorrCenterLine = 0.0;
    this.AzCorrArcWidth = 0.0;
    this.ErrSemiIntAxis = 0.0;
    this.ErrAreaOrient = 0.0;
    this.ErrSemiMajElev = 0.0;
    this.ErrGeoAreaSwitch = null;
    this.BurnoutAlt = 0.0;
    this.TesEventId = null;
    this.Spd = 0.0;
    this.AvgSpd = 0.0;
    this.Tol = 0.0;
    this.Alt = 0.0;
    this.Hdng = 0.0;
    this.Course = 0.0;
    this.PropRPM = 0.0;
    this.Tpk = 0.0;
    this.CoopLocInd = null;
    this.ManeuverInd = null;
    this.LaunchAouType = null;
    this.LaunchAouData = null;
    this.ImpactAouType = null;
    this.ImpactAouData = null;
    this.AouRptType = null;
    this.AouRptData = null;
    this.EcefPos = null;
    this.EcefVel = null;
    this.Containment = 0.0;
    this.Cpa = 0.0;
    this.Tcpa = null;
    this.NavStatus = null;
    this.PosDeviceType = null;
    this.Aton = null;
    this.OffPosInd = null;
    this.AntennaRefDimensions = null;
    this.ShipClass = null;
    this.Imon = 0;
    this.Mmsi = 0;
    this.Draught = 0.0;
    this.Length = 0.0;
    this.Width = 0.0;
    this.CargoType = null;
    this.AppGrp = null;
    this.HullProf = null;
    this.PropType = null;
    this.NumBlades = 0;
    this.NumShafts = 0;
    this.SternType = null;
    this.VslWt = 0.0;
    this.ArrTime = null;
    this.ArrFlag = null;
    this.ArrCargo = null;
    this.ArrPort = null;
    this.DepPort = null;
    this.DepFlag = null;
    this.DepCargo = null;
    this.DesFlag = null;
    this.DesCargo = null;
    this.Destination = null;
    this.Eta = null;
    this.Etd = null;
    this.Iff = null;
    this.EmgInd = false;
    this.DropPtInd = false;
    this.Reinforced = false;
    this.Reduced = false;
    this.Hq = false;
    this.Dummy = false;
    this.TaskForce = false;
    this.Feint = false;
    this.Installation = false;
    this.StaffCmts = null;
    this.AddInfo = null;
    this.EvalRating = null;
    this.CreatedAt = null;
    this.CreatedBy = null;
    this.Source = null;
    this.Origin = null;
    this.DataMode = TrackDetails_Ingest_dataMode_Enum.REAL;
    this.OrigNetwork = null;
  }
  public static TrackDetails_IngestT DeserializeFromBinary(byte[] fbBuffer) {
    return TrackDetails_Ingest.GetRootAsTrackDetails_Ingest(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    TrackDetails_Ingest.FinishTrackDetails_IngestBuffer(fbb, TrackDetails_Ingest.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class TrackDetails_IngestVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Id*/, false)
      && verifier.VerifyString(tablePos, 6 /*ClassificationMarking*/, false)
      && verifier.VerifyField(tablePos, 8 /*Env*/, 1 /*TrackDetails_Ingest_env_Enum*/, 1, false)
      && verifier.VerifyString(tablePos, 10 /*MsgType*/, false)
      && verifier.VerifyString(tablePos, 12 /*HullNum*/, false)
      && verifier.VerifyString(tablePos, 14 /*Pif*/, false)
      && verifier.VerifyString(tablePos, 16 /*Sconum*/, false)
      && verifier.VerifyString(tablePos, 18 /*Ntds*/, false)
      && verifier.VerifyString(tablePos, 20 /*DisId*/, false)
      && verifier.VerifyString(tablePos, 22 /*MidbCat*/, false)
      && verifier.VerifyString(tablePos, 24 /*BeNumber*/, false)
      && verifier.VerifyString(tablePos, 26 /*OSuffix*/, false)
      && verifier.VerifyString(tablePos, 28 /*Pin*/, false)
      && verifier.VerifyField(tablePos, 30 /*LostTrkInd*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 32 /*MuidSrcTrk*/, false)
      && verifier.VerifyString(tablePos, 34 /*MuidSrc*/, false)
      && verifier.VerifyString(tablePos, 36 /*MslStatus*/, false)
      && verifier.VerifyField(tablePos, 38 /*TrkConf*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 40 /*TrkQual*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 42 /*Alert*/, false)
      && verifier.VerifyString(tablePos, 44 /*OrigXref*/, false)
      && verifier.VerifyString(tablePos, 46 /*Elnot1*/, false)
      && verifier.VerifyString(tablePos, 48 /*Elnot2*/, false)
      && verifier.VerifyField(tablePos, 50 /*ObjIdent*/, 1 /*TrackDetails_Ingest_objIdent_Enum*/, 1, false)
      && verifier.VerifyString(tablePos, 52 /*ObjType*/, false)
      && verifier.VerifyString(tablePos, 54 /*ObjPlat*/, false)
      && verifier.VerifyString(tablePos, 56 /*ObjAct*/, false)
      && verifier.VerifyString(tablePos, 58 /*ObjNat*/, false)
      && verifier.VerifyString(tablePos, 60 /*Name*/, false)
      && verifier.VerifyString(tablePos, 62 /*ShortName*/, false)
      && verifier.VerifyString(tablePos, 64 /*TrkId*/, false)
      && verifier.VerifyString(tablePos, 66 /*TrkNum*/, false)
      && verifier.VerifyString(tablePos, 68 /*TrkScope*/, false)
      && verifier.VerifyString(tablePos, 70 /*SourceUid*/, false)
      && verifier.VerifyString(tablePos, 72 /*CallSign*/, false)
      && verifier.VerifyString(tablePos, 74 /*IdentAmp*/, false)
      && verifier.VerifyString(tablePos, 76 /*SpaceAmp*/, false)
      && verifier.VerifyField(tablePos, 78 /*SpaceAmpConf*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 80 /*SpaceSpecType*/, false)
      && verifier.VerifyString(tablePos, 82 /*AcftSubType*/, false)
      && verifier.VerifyString(tablePos, 84 /*Ts*/, false)
      && verifier.VerifyString(tablePos, 86 /*LaunchTime*/, false)
      && verifier.VerifyString(tablePos, 88 /*ImpactTime*/, false)
      && verifier.VerifyString(tablePos, 90 /*FtnMsgTs*/, false)
      && verifier.VerifyString(tablePos, 92 /*Ftn*/, false)
      && verifier.VerifyString(tablePos, 94 /*FtnCmd*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 96 /*RtnMsgTs*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 98 /*Rtn*/, false)
      && verifier.VerifyString(tablePos, 100 /*RtnTrkState*/, false)
      && verifier.VerifyString(tablePos, 102 /*RtnCmd*/, false)
      && verifier.VerifyString(tablePos, 104 /*Sen*/, false)
      && verifier.VerifyString(tablePos, 106 /*RptChxref*/, false)
      && verifier.VerifyField(tablePos, 108 /*RptArchived*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 110 /*SelfReport*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 112 /*Mil2525Bstr*/, false)
      && verifier.VerifyString(tablePos, 114 /*TrnspdrId*/, false)
      && verifier.VerifyString(tablePos, 116 /*TrnspdrType*/, false)
      && verifier.VerifyString(tablePos, 118 /*EmitterName*/, false)
      && verifier.VerifyString(tablePos, 120 /*InfoSource*/, false)
      && verifier.VerifyField(tablePos, 122 /*Boosting*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 124 /*Freq*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 126 /*MaxFreq*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 128 /*Harmonics*/, false)
      && verifier.VerifyField(tablePos, 130 /*Pri*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 132 /*Prf*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 134 /*Pw*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 136 /*ScanType*/, false)
      && verifier.VerifyField(tablePos, 138 /*ScanRate*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 140 /*Scn*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 142 /*CI*/, false)
      && verifier.VerifyField(tablePos, 144 /*AngElev*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 146 /*Lat*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 148 /*Lon*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 150 /*LaunchLat*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 152 /*LaunchLon*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 154 /*ImpactLat*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 156 /*ImpactLon*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 158 /*PolarSingLocLat*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 160 /*PolarSingLocLon*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 162 /*AzCorrCenterLine*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 164 /*AzCorrArcWidth*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 166 /*ErrSemiIntAxis*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 168 /*ErrAreaOrient*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 170 /*ErrSemiMajElev*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 172 /*ErrGeoAreaSwitch*/, false)
      && verifier.VerifyField(tablePos, 174 /*BurnoutAlt*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 176 /*TesEventId*/, false)
      && verifier.VerifyField(tablePos, 178 /*Spd*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 180 /*AvgSpd*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 182 /*Tol*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 184 /*Alt*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 186 /*Hdng*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 188 /*Course*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 190 /*PropRPM*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 192 /*Tpk*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 194 /*CoopLocInd*/, false)
      && verifier.VerifyString(tablePos, 196 /*ManeuverInd*/, false)
      && verifier.VerifyString(tablePos, 198 /*LaunchAouType*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 200 /*LaunchAouData*/, false)
      && verifier.VerifyString(tablePos, 202 /*ImpactAouType*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 204 /*ImpactAouData*/, false)
      && verifier.VerifyString(tablePos, 206 /*AouRptType*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 208 /*AouRptData*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 210 /*EcefPos*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 212 /*EcefVel*/, false)
      && verifier.VerifyField(tablePos, 214 /*Containment*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 216 /*Cpa*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 218 /*Tcpa*/, false)
      && verifier.VerifyString(tablePos, 220 /*NavStatus*/, false)
      && verifier.VerifyString(tablePos, 222 /*PosDeviceType*/, false)
      && verifier.VerifyString(tablePos, 224 /*Aton*/, false)
      && verifier.VerifyString(tablePos, 226 /*OffPosInd*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 228 /*AntennaRefDimensions*/, false)
      && verifier.VerifyString(tablePos, 230 /*ShipClass*/, false)
      && verifier.VerifyField(tablePos, 232 /*Imon*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 234 /*Mmsi*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 236 /*Draught*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 238 /*Length*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 240 /*Width*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 242 /*CargoType*/, false)
      && verifier.VerifyString(tablePos, 244 /*AppGrp*/, false)
      && verifier.VerifyString(tablePos, 246 /*HullProf*/, false)
      && verifier.VerifyString(tablePos, 248 /*PropType*/, false)
      && verifier.VerifyField(tablePos, 250 /*NumBlades*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 252 /*NumShafts*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 254 /*SternType*/, false)
      && verifier.VerifyField(tablePos, 256 /*VslWt*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 258 /*ArrTime*/, false)
      && verifier.VerifyString(tablePos, 260 /*ArrFlag*/, false)
      && verifier.VerifyString(tablePos, 262 /*ArrCargo*/, false)
      && verifier.VerifyString(tablePos, 264 /*ArrPort*/, false)
      && verifier.VerifyString(tablePos, 266 /*DepPort*/, false)
      && verifier.VerifyString(tablePos, 268 /*DepFlag*/, false)
      && verifier.VerifyString(tablePos, 270 /*DepCargo*/, false)
      && verifier.VerifyString(tablePos, 272 /*DesFlag*/, false)
      && verifier.VerifyString(tablePos, 274 /*DesCargo*/, false)
      && verifier.VerifyString(tablePos, 276 /*Destination*/, false)
      && verifier.VerifyString(tablePos, 278 /*Eta*/, false)
      && verifier.VerifyString(tablePos, 280 /*Etd*/, false)
      && verifier.VerifyString(tablePos, 282 /*Iff*/, false)
      && verifier.VerifyField(tablePos, 284 /*EmgInd*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 286 /*DropPtInd*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 288 /*Reinforced*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 290 /*Reduced*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 292 /*Hq*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 294 /*Dummy*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 296 /*TaskForce*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 298 /*Feint*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 300 /*Installation*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 302 /*StaffCmts*/, false)
      && verifier.VerifyString(tablePos, 304 /*AddInfo*/, false)
      && verifier.VerifyString(tablePos, 306 /*EvalRating*/, false)
      && verifier.VerifyString(tablePos, 308 /*CreatedAt*/, false)
      && verifier.VerifyString(tablePos, 310 /*CreatedBy*/, false)
      && verifier.VerifyString(tablePos, 312 /*Source*/, false)
      && verifier.VerifyString(tablePos, 314 /*Origin*/, false)
      && verifier.VerifyField(tablePos, 316 /*DataMode*/, 1 /*TrackDetails_Ingest_dataMode_Enum*/, 1, false)
      && verifier.VerifyString(tablePos, 318 /*OrigNetwork*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
