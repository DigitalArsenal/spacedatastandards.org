// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Discover' tab in the storefront to confirm coordinate frames by data provider.
public struct StateVector_Ingest : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static StateVector_Ingest GetRootAsStateVector_Ingest(ByteBuffer _bb) { return GetRootAsStateVector_Ingest(_bb, new StateVector_Ingest()); }
  public static StateVector_Ingest GetRootAsStateVector_Ingest(ByteBuffer _bb, StateVector_Ingest obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool StateVector_IngestBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "STAT"); }
  public static bool VerifyStateVector_Ingest(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("STAT", false, StateVector_IngestVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StateVector_Ingest __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: STATEVECTOR-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string IdStateVector { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdStateVectorBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetIdStateVectorBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetIdStateVectorArray() { return __p.__vector_as_array<byte>(4); }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  public string ClassificationMarking { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetClassificationMarkingBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetClassificationMarkingBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetClassificationMarkingArray() { return __p.__vector_as_array<byte>(6); }
  /// Time of validity for state vector in ISO 8601 UTC datetime format, with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  public string Epoch { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEpochBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetEpochBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetEpochArray() { return __p.__vector_as_array<byte>(8); }
  /// The pedigree of state vector, or methods used for its generation to include state update/orbit determination, propagation from another state, or a state from a calibration satellite (e.g. ORBIT_UPDATE, PROPAGATION, CALIBRATION, CONJUNCTION, FLIGHT_PLAN).
  /// Example: /// Example: CONJUNCTION
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string Pedigree { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPedigreeBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetPedigreeBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetPedigreeArray() { return __p.__vector_as_array<byte>(10); }
  /// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string IdOnOrbit { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdOnOrbitBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetIdOnOrbitBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetIdOnOrbitArray() { return __p.__vector_as_array<byte>(12); }
  /// Satellite/Catalog number of the target OnOrbit object.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  public int SatNo { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Optional identifier provided by state vector source to indicate the target onorbit object of this state vector. This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string OrigObjectId { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOrigObjectIdBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetOrigObjectIdBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetOrigObjectIdArray() { return __p.__vector_as_array<byte>(16); }
  /// Unique identifier of the OD solution record that produced this state vector. This ID can be used to obtain additional information on an OrbitDetermination object using the 'get by ID' operation (e.g. /udl/orbitdetermination/{id}). For example, the OrbitDetermination with idOrbitDetermination = abc would be queries as /udl/orbitdetermination/abc.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string IdOrbitDetermination { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdOrbitDeterminationBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetIdOrbitDeterminationBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetIdOrbitDeterminationArray() { return __p.__vector_as_array<byte>(18); }
  /// Boolean indicating this state vector was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool Uct { get { int o = __p.__offset(20); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Cartesian X position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: -1118.577381
  /// Constraints: No constraints specified.
  public double Xpos { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Y position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 3026.231084
  /// Constraints: No constraints specified.
  public double Ypos { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Z position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 6167.831808
  /// Constraints: No constraints specified.
  public double Zpos { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian X velocity of target, in kilometers/second, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: -4.25242784
  /// Constraints: No constraints specified.
  public double Xvel { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Y velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 5.291107434
  /// Constraints: No constraints specified.
  public double Yvel { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Z velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: -3.356493869
  /// Constraints: No constraints specified.
  public double Zvel { get { int o = __p.__offset(32); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  public StateVector_Ingest_referenceFrame_Enum ReferenceFrame { get { int o = __p.__offset(34); return o != 0 ? (StateVector_Ingest_referenceFrame_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : StateVector_Ingest_referenceFrame_Enum.J2000; } }
  /// Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.  If the covReferenceFrame is null it is assumed to be J2000.
  /// The array values (1-21) represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR&nbsp;&nbsp;
  /// x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
  /// y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3
  /// z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6
  /// x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;10
  /// y'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
  /// z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;
  /// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
  /// If additional covariance terms are included for DRAG, SRP, and/or THRUST, the matrix can be extended with the following order of elements:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR
  /// DRG&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;23&nbsp;&nbsp;24&nbsp;&nbsp;25&nbsp;&nbsp;26&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;
  /// SRP&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;30&nbsp;&nbsp;31&nbsp;&nbsp;32&nbsp;&nbsp;33&nbsp;&nbsp;&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;
  /// THR&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;38&nbsp;&nbsp;39&nbsp;&nbsp;40&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45&nbsp;
  /// Example: /// Example: [1.1, 2.2]
  /// Constraints: No constraints specified.
  public string Cov(int j) { int o = __p.__offset(36); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int CovLength { get { int o = __p.__offset(36); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  public StateVector_Ingest_covReferenceFrame_Enum CovReferenceFrame { get { int o = __p.__offset(38); return o != 0 ? (StateVector_Ingest_covReferenceFrame_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : StateVector_Ingest_covReferenceFrame_Enum.J2000; } }
  /// The method used to generate the covariance during the orbit determination (OD) that produced the state vector, or whether an arbitrary, non-calculated default value was used (CALCULATED, DEFAULT).
  /// Example: /// Example: CALCULATED
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string CovMethod { get { int o = __p.__offset(40); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCovMethodBytes() { return __p.__vector_as_span<byte>(40, 1); }
#else
  public ArraySegment<byte>? GetCovMethodBytes() { return __p.__vector_as_arraysegment(40); }
#endif
  public byte[] GetCovMethodArray() { return __p.__vector_as_array<byte>(40); }
  /// The covariance matrix values represent the lower triangular half of the covariance matrix in terms of equinoctial elements.&nbsp; The size of the covariance matrix is dynamic.&nbsp; The values are outputted in order across each row, i.e.:
  /// 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5
  /// 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp; 10
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// 51&nbsp; 52&nbsp; 53&nbsp; 54&nbsp; 55
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// The ordering of values is as follows:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Af&nbsp;&nbsp; Ag&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp; N&nbsp;&nbsp; Chi&nbsp; Psi&nbsp;&nbsp; B&nbsp;&nbsp; BDOT AGOM&nbsp; T&nbsp;&nbsp; C1&nbsp;&nbsp; C2&nbsp; ...
  /// Af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
  /// Ag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3
  /// L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 6
  /// N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 10
  /// Chi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; 12&nbsp;&nbsp; 13&nbsp;&nbsp; 14&nbsp;&nbsp; 15
  /// Psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 17&nbsp;&nbsp; 18&nbsp;&nbsp; 19&nbsp;&nbsp; 20&nbsp;&nbsp; 21
  /// B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 23&nbsp;&nbsp; 24 &nbsp;&nbsp;25&nbsp;&nbsp; 26&nbsp;&nbsp; 27&nbsp;&nbsp; 28
  /// BDOT&nbsp;&nbsp; 29&nbsp;&nbsp; 30&nbsp;&nbsp; 31&nbsp;&nbsp; 32&nbsp;&nbsp; 33&nbsp;&nbsp; 34&nbsp;&nbsp; 35&nbsp;&nbsp; 36
  /// AGOM&nbsp; 37&nbsp;&nbsp; 38&nbsp;&nbsp; 39&nbsp;&nbsp; 40&nbsp;&nbsp; 41&nbsp;&nbsp; 42&nbsp;&nbsp; 43&nbsp;&nbsp; 44&nbsp;&nbsp; 45
  /// T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;&nbsp; 47&nbsp;&nbsp; 48&nbsp;&nbsp; 49&nbsp;&nbsp; 50&nbsp;&nbsp; 51&nbsp;&nbsp; 52&nbsp;&nbsp; 53&nbsp;&nbsp; 54&nbsp;&nbsp; 55
  /// C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 56&nbsp;&nbsp; 57&nbsp;&nbsp; 58&nbsp;&nbsp; 59&nbsp;&nbsp; 60&nbsp;&nbsp; 61&nbsp;&nbsp; 62&nbsp;&nbsp; 63&nbsp;&nbsp; 64&nbsp;&nbsp; 65&nbsp;&nbsp; 66
  /// C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67&nbsp;&nbsp; 68&nbsp;&nbsp; 69&nbsp;&nbsp; 70&nbsp;&nbsp; 71&nbsp; &nbsp;72&nbsp;&nbsp; 73&nbsp;&nbsp; 74&nbsp;&nbsp; 75&nbsp;&nbsp; 76&nbsp;&nbsp; 77&nbsp;&nbsp; 78
  /// :
  /// :
  /// where C1, C2, etc, are the "consider parameters" that may be added to the covariance matrix.&nbsp; The covariance matrix will be as large as the last element/model parameter needed.&nbsp; In other words, if the DC solved for all 6 elements plus AGOM, the covariance matrix will be 9x9 (and the rows for B and BDOT will be all zeros).&nbsp; If the covariance matrix is unavailable, the size will be set to 0x0, and no data will follow.&nbsp; The cov field should contain only the lower left triangle values from top left down to bottom right, in order.
  /// Example: /// Example: [1.1, 2.2]
  /// Constraints: No constraints specified.
  public string EqCov(int j) { int o = __p.__offset(42); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int EqCovLength { get { int o = __p.__offset(42); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Cartesian X position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -1145.688502
  /// Constraints: No constraints specified.
  public double XposAlt1 { get { int o = __p.__offset(44); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Y position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 3020.729572
  /// Constraints: No constraints specified.
  public double YposAlt1 { get { int o = __p.__offset(46); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Z position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 6165.55187
  /// Constraints: No constraints specified.
  public double ZposAlt1 { get { int o = __p.__offset(48); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian X velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -4.270832252
  /// Constraints: No constraints specified.
  public double XvelAlt1 { get { int o = __p.__offset(50); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Y velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 5.27074276
  /// Constraints: No constraints specified.
  public double YvelAlt1 { get { int o = __p.__offset(52); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Z velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -3.365155181
  /// Constraints: No constraints specified.
  public double ZvelAlt1 { get { int o = __p.__offset(54); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The reference frame of the alternate1 (Alt1) cartesian orbital state.
  /// Example: /// Example: TEME
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string Alt1ReferenceFrame { get { int o = __p.__offset(56); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAlt1ReferenceFrameBytes() { return __p.__vector_as_span<byte>(56, 1); }
#else
  public ArraySegment<byte>? GetAlt1ReferenceFrameBytes() { return __p.__vector_as_arraysegment(56); }
#endif
  public byte[] GetAlt1ReferenceFrameArray() { return __p.__vector_as_array<byte>(56); }
  /// Cartesian X position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -1456.915926
  /// Constraints: No constraints specified.
  public double XposAlt2 { get { int o = __p.__offset(58); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Y position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -2883.540406
  /// Constraints: No constraints specified.
  public double YposAlt2 { get { int o = __p.__offset(60); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Z position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 6165.55187
  /// Constraints: No constraints specified.
  public double ZposAlt2 { get { int o = __p.__offset(62); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian X velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -1.219814294
  /// Constraints: No constraints specified.
  public double XvelAlt2 { get { int o = __p.__offset(64); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Y velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -6.602080212
  /// Constraints: No constraints specified.
  public double YvelAlt2 { get { int o = __p.__offset(66); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Cartesian Z velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -3.365155181
  /// Constraints: No constraints specified.
  public double ZvelAlt2 { get { int o = __p.__offset(68); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The reference frame of the alternate2 (Alt2) cartesian orbital state.
  /// Example: /// Example: EFG/TDR
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string Alt2ReferenceFrame { get { int o = __p.__offset(70); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAlt2ReferenceFrameBytes() { return __p.__vector_as_span<byte>(70, 1); }
#else
  public ArraySegment<byte>? GetAlt2ReferenceFrameBytes() { return __p.__vector_as_arraysegment(70); }
#endif
  public byte[] GetAlt2ReferenceFrameArray() { return __p.__vector_as_array<byte>(70); }
  /// One sigma position uncertainty, in kilometers.
  /// Example: /// Example: 0.333399744452
  /// Constraints: No constraints specified.
  public double PosUnc { get { int o = __p.__offset(72); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// One sigma velocity uncertainty, in kilometers/second.
  /// Example: /// Example: 4e-06
  /// Constraints: No constraints specified.
  public double VelUnc { get { int o = __p.__offset(74); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The mass of the object, in kilograms.
  /// Example: /// Example: 164.5
  /// Constraints: No constraints specified.
  public double Mass { get { int o = __p.__offset(76); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The actual area of the object at it's largest cross-section, expressed in meters^2.
  /// Example: /// Example: 5.065
  /// Constraints: No constraints specified.
  public double Area { get { int o = __p.__offset(78); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Area-to-mass ratio coefficient for solar radiation pressure.
  /// Example: /// Example: 0.0244394
  /// Constraints: No constraints specified.
  public double SolarRadPressCoeff { get { int o = __p.__offset(80); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Area-to-mass ratio coefficient for atmospheric ballistic drag (m2/kg).
  /// Example: /// Example: 0.0224391269775
  /// Constraints: No constraints specified.
  public double DragCoeff { get { int o = __p.__offset(82); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The effective area of the object exposed to atmospheric drag, expressed in meters^2.
  /// Example: /// Example: 4.739
  /// Constraints: No constraints specified.
  public double DragArea { get { int o = __p.__offset(84); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Epoch revolution number.
  /// Example: /// Example: 7205
  /// Constraints: No constraints specified.
  public int RevNo { get { int o = __p.__offset(86); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Geopotential model used for this vector (e.g. EGM-96, WGS-84, WGS-72, JGM-2, or GEM-T3), including mm degree zonals, nn degree/order tesserals. E.g. EGM-96 24Z,24T.
  /// Example: /// Example: EGM-96
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string GeopotentialModel { get { int o = __p.__offset(88); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetGeopotentialModelBytes() { return __p.__vector_as_span<byte>(88, 1); }
#else
  public ArraySegment<byte>? GetGeopotentialModelBytes() { return __p.__vector_as_arraysegment(88); }
#endif
  public byte[] GetGeopotentialModelArray() { return __p.__vector_as_array<byte>(88); }
  /// The Drag Model used for this vector (e.g. HARRIS-PRIESTER, JAC70, JBH09, MSIS90, NONE, etc.).
  /// Example: /// Example: JAC70
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string DragModel { get { int o = __p.__offset(90); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDragModelBytes() { return __p.__vector_as_span<byte>(90, 1); }
#else
  public ArraySegment<byte>? GetDragModelBytes() { return __p.__vector_as_arraysegment(90); }
#endif
  public byte[] GetDragModelArray() { return __p.__vector_as_array<byte>(90); }
  /// Boolean indicating use of lunar/solar perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool LunarSolar { get { int o = __p.__offset(92); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Boolean indicating use of solar radiation pressure perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool SolarRadPress { get { int o = __p.__offset(94); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The effective area of the object exposed to solar radiation pressure, expressed in meters^2.
  /// Example: /// Example: 4.311
  /// Constraints: No constraints specified.
  public double SrpArea { get { int o = __p.__offset(96); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Boolean indicating use of solid earth tide perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool SolidEarthTides { get { int o = __p.__offset(98); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Boolean indicating use of in-track thrust perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool InTrackThrust { get { int o = __p.__offset(100); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// First derivative of drag/ballistic coefficient (m2/kg-s).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double BDot { get { int o = __p.__offset(102); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Model parameter value for energy dissipation rate (EDR) (w/kg).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double Edr { get { int o = __p.__offset(104); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Model parameter value for thrust acceleration (m/s2).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double ThrustAccel { get { int o = __p.__offset(106); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Model parameter value for center of mass offset (m).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double CmOffset { get { int o = __p.__offset(108); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The start of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
  /// Example: /// Example: 2022-11-09T11:20:21.247192Z
  /// Constraints: No constraints specified.
  public string LastObStart { get { int o = __p.__offset(110); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLastObStartBytes() { return __p.__vector_as_span<byte>(110, 1); }
#else
  public ArraySegment<byte>? GetLastObStartBytes() { return __p.__vector_as_arraysegment(110); }
#endif
  public byte[] GetLastObStartArray() { return __p.__vector_as_array<byte>(110); }
  /// The end of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
  /// Example: /// Example: 2022-11-09T11:20:21.247192Z
  /// Constraints: No constraints specified.
  public string LastObEnd { get { int o = __p.__offset(112); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLastObEndBytes() { return __p.__vector_as_span<byte>(112, 1); }
#else
  public ArraySegment<byte>? GetLastObEndBytes() { return __p.__vector_as_arraysegment(112); }
#endif
  public byte[] GetLastObEndArray() { return __p.__vector_as_array<byte>(112); }
  /// The number of observations available for the OD of the object.
  /// Example: /// Example: 376
  /// Constraints: No constraints specified.
  public int ObsAvailable { get { int o = __p.__offset(114); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The number of observations accepted for the OD of the object.
  /// Example: /// Example: 374
  /// Constraints: No constraints specified.
  public int ObsUsed { get { int o = __p.__offset(116); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The number of sensor tracks available for the OD of the object.
  /// Example: /// Example: 163
  /// Constraints: No constraints specified.
  public int TracksAvail { get { int o = __p.__offset(118); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The number of sensor tracks accepted for the OD of the object.
  /// Example: /// Example: 163
  /// Constraints: No constraints specified.
  public int TracksUsed { get { int o = __p.__offset(120); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The recommended OD time span calculated for the object, expressed in days.
  /// Example: /// Example: 3.5
  /// Constraints: No constraints specified.
  public double RecODSpan { get { int o = __p.__offset(122); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The actual time span used for the OD of the object, expressed in days.
  /// Example: /// Example: 3.5
  /// Constraints: No constraints specified.
  public double ActualODSpan { get { int o = __p.__offset(124); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The percentage of residuals accepted in the OD of the object.
  /// Example: /// Example: 99.5
  /// Constraints: No constraints specified.
  public double ResidualsAcc { get { int o = __p.__offset(126); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// F10 (10.7 cm) solar flux value.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double SolarFluxF10 { get { int o = __p.__offset(128); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// F10 (10.7 cm) solar flux 81-day average value.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double SolarFluxF10Avg { get { int o = __p.__offset(130); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Average solar flux geomagnetic index.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double SolarFluxAPAvg { get { int o = __p.__offset(132); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// TAI (Temps Atomique International) minus UTC (Universal Time Coordinates) offset in seconds.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double TaiUtc { get { int o = __p.__offset(134); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Universal Time-1 (UT1) minus UTC offset, in seconds.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double Ut1Utc { get { int o = __p.__offset(136); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Rate of change of UT1 (milliseconds/day) - first derivative of ut1Utc.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double Ut1Rate { get { int o = __p.__offset(138); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Polar Wander Motion X (arc seconds).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double PolarMotionX { get { int o = __p.__offset(140); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Polar Wander Motion Y (arc seconds).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double PolarMotionY { get { int o = __p.__offset(142); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Number of terms used in the IAU 1980 nutation model (4, 50, or 106).
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  public int Iau1980Terms { get { int o = __p.__offset(144); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Time of the next leap second after epoch in ISO 8601 UTC time. If the next leap second is not known, the time of the previous leap second is used.
  /// Example: /// Example: 2021-01-01T01:01:01.123Z
  /// Constraints: No constraints specified.
  public string LeapSecondTime { get { int o = __p.__offset(146); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLeapSecondTimeBytes() { return __p.__vector_as_span<byte>(146, 1); }
#else
  public ArraySegment<byte>? GetLeapSecondTimeBytes() { return __p.__vector_as_arraysegment(146); }
#endif
  public byte[] GetLeapSecondTimeArray() { return __p.__vector_as_array<byte>(146); }
  /// Integrator Mode.
  /// Example: /// Example: integratorMode
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string IntegratorMode { get { int o = __p.__offset(148); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIntegratorModeBytes() { return __p.__vector_as_span<byte>(148, 1); }
#else
  public ArraySegment<byte>? GetIntegratorModeBytes() { return __p.__vector_as_arraysegment(148); }
#endif
  public byte[] GetIntegratorModeArray() { return __p.__vector_as_array<byte>(148); }
  /// Type of partial derivatives used (ANALYTIC, FULL NUM, or FAST NUM).
  /// Example: /// Example: ANALYTIC
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string Partials { get { int o = __p.__offset(150); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPartialsBytes() { return __p.__vector_as_span<byte>(150, 1); }
#else
  public ArraySegment<byte>? GetPartialsBytes() { return __p.__vector_as_arraysegment(150); }
#endif
  public byte[] GetPartialsArray() { return __p.__vector_as_array<byte>(150); }
  /// Integrator step mode (AUTO, TIME, or S).
  /// Example: /// Example: AUTO
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string StepMode { get { int o = __p.__offset(152); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetStepModeBytes() { return __p.__vector_as_span<byte>(152, 1); }
#else
  public ArraySegment<byte>? GetStepModeBytes() { return __p.__vector_as_arraysegment(152); }
#endif
  public byte[] GetStepModeArray() { return __p.__vector_as_array<byte>(152); }
  /// Boolean indicating use of fixed step size for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool FixedStep { get { int o = __p.__offset(154); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Initial step size selection (AUTO or MANUAL).
  /// Example: /// Example: AUTO
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string StepSizeSelection { get { int o = __p.__offset(156); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetStepSizeSelectionBytes() { return __p.__vector_as_span<byte>(156, 1); }
#else
  public ArraySegment<byte>? GetStepSizeSelectionBytes() { return __p.__vector_as_arraysegment(156); }
#endif
  public byte[] GetStepSizeSelectionArray() { return __p.__vector_as_array<byte>(156); }
  /// Initial integration step size (seconds).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double StepSize { get { int o = __p.__offset(158); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Integrator error control.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double ErrorControl { get { int o = __p.__offset(160); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Array containing the standard deviation of error in target object position, U, V and W direction respectively (km).
  /// Example: /// Example: [1.23, 4.56]
  /// Constraints: No constraints specified.
  public string SigmaPosUVW(int j) { int o = __p.__offset(162); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int SigmaPosUVWLength { get { int o = __p.__offset(162); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Array containing the standard deviation of error in target object velocity, U, V and W direction respectively (km/sec).
  /// Example: /// Example: [1.23, 4.56]
  /// Constraints: No constraints specified.
  public string SigmaVelUVW(int j) { int o = __p.__offset(164); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int SigmaVelUVWLength { get { int o = __p.__offset(164); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The Weighted Root Mean Squared (RMS) of the differential correction on the target object that produced this vector.  WRMS is a quality indicator of the state vector update, with a value of 1.00 being optimal.  WRMS applies to Batch Least Squares (BLS) processes.
  /// Example: /// Example: 0.991
  /// Constraints: No constraints specified.
  public double Rms { get { int o = __p.__offset(166); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  /// Example: /// Example: rawFileURI
  /// Constraints: Minimum length = 0, Maximum length = 256
  public string RawFileURI { get { int o = __p.__offset(168); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRawFileURIBytes() { return __p.__vector_as_span<byte>(168, 1); }
#else
  public ArraySegment<byte>? GetRawFileURIBytes() { return __p.__vector_as_arraysegment(168); }
#endif
  public byte[] GetRawFileURIArray() { return __p.__vector_as_array<byte>(168); }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string Source { get { int o = __p.__offset(170); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceBytes() { return __p.__vector_as_span<byte>(170, 1); }
#else
  public ArraySegment<byte>? GetSourceBytes() { return __p.__vector_as_arraysegment(170); }
#endif
  public byte[] GetSourceArray() { return __p.__vector_as_array<byte>(170); }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Origin { get { int o = __p.__offset(172); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOriginBytes() { return __p.__vector_as_span<byte>(172, 1); }
#else
  public ArraySegment<byte>? GetOriginBytes() { return __p.__vector_as_arraysegment(172); }
#endif
  public byte[] GetOriginArray() { return __p.__vector_as_array<byte>(172); }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  public StateVector_Ingest_dataMode_Enum DataMode { get { int o = __p.__offset(174); return o != 0 ? (StateVector_Ingest_dataMode_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : StateVector_Ingest_dataMode_Enum.REAL; } }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['TAG1', 'TAG2']
  /// Constraints: No constraints specified.
  public string Tags(int j) { int o = __p.__offset(176); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int TagsLength { get { int o = __p.__offset(176); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Optional algorithm used to produce this record.
  /// Example: /// Example: SAMPLE_ALGORITHM
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Algorithm { get { int o = __p.__offset(178); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAlgorithmBytes() { return __p.__vector_as_span<byte>(178, 1); }
#else
  public ArraySegment<byte>? GetAlgorithmBytes() { return __p.__vector_as_arraysegment(178); }
#endif
  public byte[] GetAlgorithmArray() { return __p.__vector_as_array<byte>(178); }
  /// Optional array of UDL data (observation) UUIDs used to build this state vector. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
  /// Example: /// Example: ['DATA1', 'DATA2']
  /// Constraints: No constraints specified.
  public string SourcedData(int j) { int o = __p.__offset(180); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int SourcedDataLength { get { int o = __p.__offset(180); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Optional array of UDL observation data types used to build this state vector (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
  /// Example: /// Example: ['RADAR']
  /// Constraints: No constraints specified.
  public StateVector_Ingest_sourcedDataTypes_Enum SourcedDataTypes { get { int o = __p.__offset(182); return o != 0 ? (StateVector_Ingest_sourcedDataTypes_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : StateVector_Ingest_sourcedDataTypes_Enum.EO; } }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string CreatedAt { get { int o = __p.__offset(184); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedAtBytes() { return __p.__vector_as_span<byte>(184, 1); }
#else
  public ArraySegment<byte>? GetCreatedAtBytes() { return __p.__vector_as_arraysegment(184); }
#endif
  public byte[] GetCreatedAtArray() { return __p.__vector_as_array<byte>(184); }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string CreatedBy { get { int o = __p.__offset(186); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedByBytes() { return __p.__vector_as_span<byte>(186, 1); }
#else
  public ArraySegment<byte>? GetCreatedByBytes() { return __p.__vector_as_arraysegment(186); }
#endif
  public byte[] GetCreatedByArray() { return __p.__vector_as_array<byte>(186); }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: descriptor
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Descriptor { get { int o = __p.__offset(188); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDescriptorBytes() { return __p.__vector_as_span<byte>(188, 1); }
#else
  public ArraySegment<byte>? GetDescriptorBytes() { return __p.__vector_as_arraysegment(188); }
#endif
  public byte[] GetDescriptorArray() { return __p.__vector_as_array<byte>(188); }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: transactionId
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string TransactionId { get { int o = __p.__offset(190); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTransactionIdBytes() { return __p.__vector_as_span<byte>(190, 1); }
#else
  public ArraySegment<byte>? GetTransactionIdBytes() { return __p.__vector_as_arraysegment(190); }
#endif
  public byte[] GetTransactionIdArray() { return __p.__vector_as_array<byte>(190); }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  public string OrigNetwork { get { int o = __p.__offset(192); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOrigNetworkBytes() { return __p.__vector_as_span<byte>(192, 1); }
#else
  public ArraySegment<byte>? GetOrigNetworkBytes() { return __p.__vector_as_arraysegment(192); }
#endif
  public byte[] GetOrigNetworkArray() { return __p.__vector_as_array<byte>(192); }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string SourceDL { get { int o = __p.__offset(194); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceDLBytes() { return __p.__vector_as_span<byte>(194, 1); }
#else
  public ArraySegment<byte>? GetSourceDLBytes() { return __p.__vector_as_arraysegment(194); }
#endif
  public byte[] GetSourceDLArray() { return __p.__vector_as_array<byte>(194); }

  public static Offset<StateVector_Ingest> CreateStateVector_Ingest(FlatBufferBuilder builder,
      StringOffset idStateVectorOffset = default(StringOffset),
      StringOffset classificationMarkingOffset = default(StringOffset),
      StringOffset epochOffset = default(StringOffset),
      StringOffset pedigreeOffset = default(StringOffset),
      StringOffset idOnOrbitOffset = default(StringOffset),
      int satNo = 0,
      StringOffset origObjectIdOffset = default(StringOffset),
      StringOffset idOrbitDeterminationOffset = default(StringOffset),
      bool uct = false,
      double xpos = 0.0,
      double ypos = 0.0,
      double zpos = 0.0,
      double xvel = 0.0,
      double yvel = 0.0,
      double zvel = 0.0,
      StateVector_Ingest_referenceFrame_Enum referenceFrame = StateVector_Ingest_referenceFrame_Enum.J2000,
      VectorOffset covOffset = default(VectorOffset),
      StateVector_Ingest_covReferenceFrame_Enum covReferenceFrame = StateVector_Ingest_covReferenceFrame_Enum.J2000,
      StringOffset covMethodOffset = default(StringOffset),
      VectorOffset eqCovOffset = default(VectorOffset),
      double xposAlt1 = 0.0,
      double yposAlt1 = 0.0,
      double zposAlt1 = 0.0,
      double xvelAlt1 = 0.0,
      double yvelAlt1 = 0.0,
      double zvelAlt1 = 0.0,
      StringOffset alt1ReferenceFrameOffset = default(StringOffset),
      double xposAlt2 = 0.0,
      double yposAlt2 = 0.0,
      double zposAlt2 = 0.0,
      double xvelAlt2 = 0.0,
      double yvelAlt2 = 0.0,
      double zvelAlt2 = 0.0,
      StringOffset alt2ReferenceFrameOffset = default(StringOffset),
      double posUnc = 0.0,
      double velUnc = 0.0,
      double mass = 0.0,
      double area = 0.0,
      double solarRadPressCoeff = 0.0,
      double dragCoeff = 0.0,
      double dragArea = 0.0,
      int revNo = 0,
      StringOffset geopotentialModelOffset = default(StringOffset),
      StringOffset dragModelOffset = default(StringOffset),
      bool lunarSolar = false,
      bool solarRadPress = false,
      double srpArea = 0.0,
      bool solidEarthTides = false,
      bool inTrackThrust = false,
      double bDot = 0.0,
      double edr = 0.0,
      double thrustAccel = 0.0,
      double cmOffset = 0.0,
      StringOffset lastObStartOffset = default(StringOffset),
      StringOffset lastObEndOffset = default(StringOffset),
      int obsAvailable = 0,
      int obsUsed = 0,
      int tracksAvail = 0,
      int tracksUsed = 0,
      double recODSpan = 0.0,
      double actualODSpan = 0.0,
      double residualsAcc = 0.0,
      double solarFluxF10 = 0.0,
      double solarFluxF10Avg = 0.0,
      double solarFluxAPAvg = 0.0,
      double taiUtc = 0.0,
      double ut1Utc = 0.0,
      double ut1Rate = 0.0,
      double polarMotionX = 0.0,
      double polarMotionY = 0.0,
      int iau1980Terms = 0,
      StringOffset leapSecondTimeOffset = default(StringOffset),
      StringOffset integratorModeOffset = default(StringOffset),
      StringOffset partialsOffset = default(StringOffset),
      StringOffset stepModeOffset = default(StringOffset),
      bool fixedStep = false,
      StringOffset stepSizeSelectionOffset = default(StringOffset),
      double stepSize = 0.0,
      double errorControl = 0.0,
      VectorOffset sigmaPosUVWOffset = default(VectorOffset),
      VectorOffset sigmaVelUVWOffset = default(VectorOffset),
      double rms = 0.0,
      StringOffset rawFileURIOffset = default(StringOffset),
      StringOffset sourceOffset = default(StringOffset),
      StringOffset originOffset = default(StringOffset),
      StateVector_Ingest_dataMode_Enum dataMode = StateVector_Ingest_dataMode_Enum.REAL,
      VectorOffset tagsOffset = default(VectorOffset),
      StringOffset algorithmOffset = default(StringOffset),
      VectorOffset sourcedDataOffset = default(VectorOffset),
      StateVector_Ingest_sourcedDataTypes_Enum sourcedDataTypes = StateVector_Ingest_sourcedDataTypes_Enum.EO,
      StringOffset createdAtOffset = default(StringOffset),
      StringOffset createdByOffset = default(StringOffset),
      StringOffset descriptorOffset = default(StringOffset),
      StringOffset transactionIdOffset = default(StringOffset),
      StringOffset origNetworkOffset = default(StringOffset),
      StringOffset sourceDLOffset = default(StringOffset)) {
    builder.StartTable(96);
    StateVector_Ingest.AddRms(builder, rms);
    StateVector_Ingest.AddErrorControl(builder, errorControl);
    StateVector_Ingest.AddStepSize(builder, stepSize);
    StateVector_Ingest.AddPolarMotionY(builder, polarMotionY);
    StateVector_Ingest.AddPolarMotionX(builder, polarMotionX);
    StateVector_Ingest.AddUt1Rate(builder, ut1Rate);
    StateVector_Ingest.AddUt1Utc(builder, ut1Utc);
    StateVector_Ingest.AddTaiUtc(builder, taiUtc);
    StateVector_Ingest.AddSolarFluxAPAvg(builder, solarFluxAPAvg);
    StateVector_Ingest.AddSolarFluxF10Avg(builder, solarFluxF10Avg);
    StateVector_Ingest.AddSolarFluxF10(builder, solarFluxF10);
    StateVector_Ingest.AddResidualsAcc(builder, residualsAcc);
    StateVector_Ingest.AddActualODSpan(builder, actualODSpan);
    StateVector_Ingest.AddRecODSpan(builder, recODSpan);
    StateVector_Ingest.AddCmOffset(builder, cmOffset);
    StateVector_Ingest.AddThrustAccel(builder, thrustAccel);
    StateVector_Ingest.AddEdr(builder, edr);
    StateVector_Ingest.AddBDot(builder, bDot);
    StateVector_Ingest.AddSrpArea(builder, srpArea);
    StateVector_Ingest.AddDragArea(builder, dragArea);
    StateVector_Ingest.AddDragCoeff(builder, dragCoeff);
    StateVector_Ingest.AddSolarRadPressCoeff(builder, solarRadPressCoeff);
    StateVector_Ingest.AddArea(builder, area);
    StateVector_Ingest.AddMass(builder, mass);
    StateVector_Ingest.AddVelUnc(builder, velUnc);
    StateVector_Ingest.AddPosUnc(builder, posUnc);
    StateVector_Ingest.AddZvelAlt2(builder, zvelAlt2);
    StateVector_Ingest.AddYvelAlt2(builder, yvelAlt2);
    StateVector_Ingest.AddXvelAlt2(builder, xvelAlt2);
    StateVector_Ingest.AddZposAlt2(builder, zposAlt2);
    StateVector_Ingest.AddYposAlt2(builder, yposAlt2);
    StateVector_Ingest.AddXposAlt2(builder, xposAlt2);
    StateVector_Ingest.AddZvelAlt1(builder, zvelAlt1);
    StateVector_Ingest.AddYvelAlt1(builder, yvelAlt1);
    StateVector_Ingest.AddXvelAlt1(builder, xvelAlt1);
    StateVector_Ingest.AddZposAlt1(builder, zposAlt1);
    StateVector_Ingest.AddYposAlt1(builder, yposAlt1);
    StateVector_Ingest.AddXposAlt1(builder, xposAlt1);
    StateVector_Ingest.AddZvel(builder, zvel);
    StateVector_Ingest.AddYvel(builder, yvel);
    StateVector_Ingest.AddXvel(builder, xvel);
    StateVector_Ingest.AddZpos(builder, zpos);
    StateVector_Ingest.AddYpos(builder, ypos);
    StateVector_Ingest.AddXpos(builder, xpos);
    StateVector_Ingest.AddSourceDL(builder, sourceDLOffset);
    StateVector_Ingest.AddOrigNetwork(builder, origNetworkOffset);
    StateVector_Ingest.AddTransactionId(builder, transactionIdOffset);
    StateVector_Ingest.AddDescriptor(builder, descriptorOffset);
    StateVector_Ingest.AddCreatedBy(builder, createdByOffset);
    StateVector_Ingest.AddCreatedAt(builder, createdAtOffset);
    StateVector_Ingest.AddSourcedData(builder, sourcedDataOffset);
    StateVector_Ingest.AddAlgorithm(builder, algorithmOffset);
    StateVector_Ingest.AddTags(builder, tagsOffset);
    StateVector_Ingest.AddOrigin(builder, originOffset);
    StateVector_Ingest.AddSource(builder, sourceOffset);
    StateVector_Ingest.AddRawFileURI(builder, rawFileURIOffset);
    StateVector_Ingest.AddSigmaVelUVW(builder, sigmaVelUVWOffset);
    StateVector_Ingest.AddSigmaPosUVW(builder, sigmaPosUVWOffset);
    StateVector_Ingest.AddStepSizeSelection(builder, stepSizeSelectionOffset);
    StateVector_Ingest.AddStepMode(builder, stepModeOffset);
    StateVector_Ingest.AddPartials(builder, partialsOffset);
    StateVector_Ingest.AddIntegratorMode(builder, integratorModeOffset);
    StateVector_Ingest.AddLeapSecondTime(builder, leapSecondTimeOffset);
    StateVector_Ingest.AddIau1980Terms(builder, iau1980Terms);
    StateVector_Ingest.AddTracksUsed(builder, tracksUsed);
    StateVector_Ingest.AddTracksAvail(builder, tracksAvail);
    StateVector_Ingest.AddObsUsed(builder, obsUsed);
    StateVector_Ingest.AddObsAvailable(builder, obsAvailable);
    StateVector_Ingest.AddLastObEnd(builder, lastObEndOffset);
    StateVector_Ingest.AddLastObStart(builder, lastObStartOffset);
    StateVector_Ingest.AddDragModel(builder, dragModelOffset);
    StateVector_Ingest.AddGeopotentialModel(builder, geopotentialModelOffset);
    StateVector_Ingest.AddRevNo(builder, revNo);
    StateVector_Ingest.AddAlt2ReferenceFrame(builder, alt2ReferenceFrameOffset);
    StateVector_Ingest.AddAlt1ReferenceFrame(builder, alt1ReferenceFrameOffset);
    StateVector_Ingest.AddEqCov(builder, eqCovOffset);
    StateVector_Ingest.AddCovMethod(builder, covMethodOffset);
    StateVector_Ingest.AddCov(builder, covOffset);
    StateVector_Ingest.AddIdOrbitDetermination(builder, idOrbitDeterminationOffset);
    StateVector_Ingest.AddOrigObjectId(builder, origObjectIdOffset);
    StateVector_Ingest.AddSatNo(builder, satNo);
    StateVector_Ingest.AddIdOnOrbit(builder, idOnOrbitOffset);
    StateVector_Ingest.AddPedigree(builder, pedigreeOffset);
    StateVector_Ingest.AddEpoch(builder, epochOffset);
    StateVector_Ingest.AddClassificationMarking(builder, classificationMarkingOffset);
    StateVector_Ingest.AddIdStateVector(builder, idStateVectorOffset);
    StateVector_Ingest.AddSourcedDataTypes(builder, sourcedDataTypes);
    StateVector_Ingest.AddDataMode(builder, dataMode);
    StateVector_Ingest.AddFixedStep(builder, fixedStep);
    StateVector_Ingest.AddInTrackThrust(builder, inTrackThrust);
    StateVector_Ingest.AddSolidEarthTides(builder, solidEarthTides);
    StateVector_Ingest.AddSolarRadPress(builder, solarRadPress);
    StateVector_Ingest.AddLunarSolar(builder, lunarSolar);
    StateVector_Ingest.AddCovReferenceFrame(builder, covReferenceFrame);
    StateVector_Ingest.AddReferenceFrame(builder, referenceFrame);
    StateVector_Ingest.AddUct(builder, uct);
    return StateVector_Ingest.EndStateVector_Ingest(builder);
  }

  public static void StartStateVector_Ingest(FlatBufferBuilder builder) { builder.StartTable(96); }
  public static void AddIdStateVector(FlatBufferBuilder builder, StringOffset idStateVectorOffset) { builder.AddOffset(0, idStateVectorOffset.Value, 0); }
  public static void AddClassificationMarking(FlatBufferBuilder builder, StringOffset classificationMarkingOffset) { builder.AddOffset(1, classificationMarkingOffset.Value, 0); }
  public static void AddEpoch(FlatBufferBuilder builder, StringOffset epochOffset) { builder.AddOffset(2, epochOffset.Value, 0); }
  public static void AddPedigree(FlatBufferBuilder builder, StringOffset pedigreeOffset) { builder.AddOffset(3, pedigreeOffset.Value, 0); }
  public static void AddIdOnOrbit(FlatBufferBuilder builder, StringOffset idOnOrbitOffset) { builder.AddOffset(4, idOnOrbitOffset.Value, 0); }
  public static void AddSatNo(FlatBufferBuilder builder, int satNo) { builder.AddInt(5, satNo, 0); }
  public static void AddOrigObjectId(FlatBufferBuilder builder, StringOffset origObjectIdOffset) { builder.AddOffset(6, origObjectIdOffset.Value, 0); }
  public static void AddIdOrbitDetermination(FlatBufferBuilder builder, StringOffset idOrbitDeterminationOffset) { builder.AddOffset(7, idOrbitDeterminationOffset.Value, 0); }
  public static void AddUct(FlatBufferBuilder builder, bool uct) { builder.AddBool(8, uct, false); }
  public static void AddXpos(FlatBufferBuilder builder, double xpos) { builder.AddDouble(9, xpos, 0.0); }
  public static void AddYpos(FlatBufferBuilder builder, double ypos) { builder.AddDouble(10, ypos, 0.0); }
  public static void AddZpos(FlatBufferBuilder builder, double zpos) { builder.AddDouble(11, zpos, 0.0); }
  public static void AddXvel(FlatBufferBuilder builder, double xvel) { builder.AddDouble(12, xvel, 0.0); }
  public static void AddYvel(FlatBufferBuilder builder, double yvel) { builder.AddDouble(13, yvel, 0.0); }
  public static void AddZvel(FlatBufferBuilder builder, double zvel) { builder.AddDouble(14, zvel, 0.0); }
  public static void AddReferenceFrame(FlatBufferBuilder builder, StateVector_Ingest_referenceFrame_Enum referenceFrame) { builder.AddSbyte(15, (sbyte)referenceFrame, 0); }
  public static void AddCov(FlatBufferBuilder builder, VectorOffset covOffset) { builder.AddOffset(16, covOffset.Value, 0); }
  public static VectorOffset CreateCovVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCovVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCovVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCovVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCovVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCovReferenceFrame(FlatBufferBuilder builder, StateVector_Ingest_covReferenceFrame_Enum covReferenceFrame) { builder.AddSbyte(17, (sbyte)covReferenceFrame, 0); }
  public static void AddCovMethod(FlatBufferBuilder builder, StringOffset covMethodOffset) { builder.AddOffset(18, covMethodOffset.Value, 0); }
  public static void AddEqCov(FlatBufferBuilder builder, VectorOffset eqCovOffset) { builder.AddOffset(19, eqCovOffset.Value, 0); }
  public static VectorOffset CreateEqCovVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateEqCovVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEqCovVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEqCovVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartEqCovVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddXposAlt1(FlatBufferBuilder builder, double xposAlt1) { builder.AddDouble(20, xposAlt1, 0.0); }
  public static void AddYposAlt1(FlatBufferBuilder builder, double yposAlt1) { builder.AddDouble(21, yposAlt1, 0.0); }
  public static void AddZposAlt1(FlatBufferBuilder builder, double zposAlt1) { builder.AddDouble(22, zposAlt1, 0.0); }
  public static void AddXvelAlt1(FlatBufferBuilder builder, double xvelAlt1) { builder.AddDouble(23, xvelAlt1, 0.0); }
  public static void AddYvelAlt1(FlatBufferBuilder builder, double yvelAlt1) { builder.AddDouble(24, yvelAlt1, 0.0); }
  public static void AddZvelAlt1(FlatBufferBuilder builder, double zvelAlt1) { builder.AddDouble(25, zvelAlt1, 0.0); }
  public static void AddAlt1ReferenceFrame(FlatBufferBuilder builder, StringOffset alt1ReferenceFrameOffset) { builder.AddOffset(26, alt1ReferenceFrameOffset.Value, 0); }
  public static void AddXposAlt2(FlatBufferBuilder builder, double xposAlt2) { builder.AddDouble(27, xposAlt2, 0.0); }
  public static void AddYposAlt2(FlatBufferBuilder builder, double yposAlt2) { builder.AddDouble(28, yposAlt2, 0.0); }
  public static void AddZposAlt2(FlatBufferBuilder builder, double zposAlt2) { builder.AddDouble(29, zposAlt2, 0.0); }
  public static void AddXvelAlt2(FlatBufferBuilder builder, double xvelAlt2) { builder.AddDouble(30, xvelAlt2, 0.0); }
  public static void AddYvelAlt2(FlatBufferBuilder builder, double yvelAlt2) { builder.AddDouble(31, yvelAlt2, 0.0); }
  public static void AddZvelAlt2(FlatBufferBuilder builder, double zvelAlt2) { builder.AddDouble(32, zvelAlt2, 0.0); }
  public static void AddAlt2ReferenceFrame(FlatBufferBuilder builder, StringOffset alt2ReferenceFrameOffset) { builder.AddOffset(33, alt2ReferenceFrameOffset.Value, 0); }
  public static void AddPosUnc(FlatBufferBuilder builder, double posUnc) { builder.AddDouble(34, posUnc, 0.0); }
  public static void AddVelUnc(FlatBufferBuilder builder, double velUnc) { builder.AddDouble(35, velUnc, 0.0); }
  public static void AddMass(FlatBufferBuilder builder, double mass) { builder.AddDouble(36, mass, 0.0); }
  public static void AddArea(FlatBufferBuilder builder, double area) { builder.AddDouble(37, area, 0.0); }
  public static void AddSolarRadPressCoeff(FlatBufferBuilder builder, double solarRadPressCoeff) { builder.AddDouble(38, solarRadPressCoeff, 0.0); }
  public static void AddDragCoeff(FlatBufferBuilder builder, double dragCoeff) { builder.AddDouble(39, dragCoeff, 0.0); }
  public static void AddDragArea(FlatBufferBuilder builder, double dragArea) { builder.AddDouble(40, dragArea, 0.0); }
  public static void AddRevNo(FlatBufferBuilder builder, int revNo) { builder.AddInt(41, revNo, 0); }
  public static void AddGeopotentialModel(FlatBufferBuilder builder, StringOffset geopotentialModelOffset) { builder.AddOffset(42, geopotentialModelOffset.Value, 0); }
  public static void AddDragModel(FlatBufferBuilder builder, StringOffset dragModelOffset) { builder.AddOffset(43, dragModelOffset.Value, 0); }
  public static void AddLunarSolar(FlatBufferBuilder builder, bool lunarSolar) { builder.AddBool(44, lunarSolar, false); }
  public static void AddSolarRadPress(FlatBufferBuilder builder, bool solarRadPress) { builder.AddBool(45, solarRadPress, false); }
  public static void AddSrpArea(FlatBufferBuilder builder, double srpArea) { builder.AddDouble(46, srpArea, 0.0); }
  public static void AddSolidEarthTides(FlatBufferBuilder builder, bool solidEarthTides) { builder.AddBool(47, solidEarthTides, false); }
  public static void AddInTrackThrust(FlatBufferBuilder builder, bool inTrackThrust) { builder.AddBool(48, inTrackThrust, false); }
  public static void AddBDot(FlatBufferBuilder builder, double bDot) { builder.AddDouble(49, bDot, 0.0); }
  public static void AddEdr(FlatBufferBuilder builder, double edr) { builder.AddDouble(50, edr, 0.0); }
  public static void AddThrustAccel(FlatBufferBuilder builder, double thrustAccel) { builder.AddDouble(51, thrustAccel, 0.0); }
  public static void AddCmOffset(FlatBufferBuilder builder, double cmOffset) { builder.AddDouble(52, cmOffset, 0.0); }
  public static void AddLastObStart(FlatBufferBuilder builder, StringOffset lastObStartOffset) { builder.AddOffset(53, lastObStartOffset.Value, 0); }
  public static void AddLastObEnd(FlatBufferBuilder builder, StringOffset lastObEndOffset) { builder.AddOffset(54, lastObEndOffset.Value, 0); }
  public static void AddObsAvailable(FlatBufferBuilder builder, int obsAvailable) { builder.AddInt(55, obsAvailable, 0); }
  public static void AddObsUsed(FlatBufferBuilder builder, int obsUsed) { builder.AddInt(56, obsUsed, 0); }
  public static void AddTracksAvail(FlatBufferBuilder builder, int tracksAvail) { builder.AddInt(57, tracksAvail, 0); }
  public static void AddTracksUsed(FlatBufferBuilder builder, int tracksUsed) { builder.AddInt(58, tracksUsed, 0); }
  public static void AddRecODSpan(FlatBufferBuilder builder, double recODSpan) { builder.AddDouble(59, recODSpan, 0.0); }
  public static void AddActualODSpan(FlatBufferBuilder builder, double actualODSpan) { builder.AddDouble(60, actualODSpan, 0.0); }
  public static void AddResidualsAcc(FlatBufferBuilder builder, double residualsAcc) { builder.AddDouble(61, residualsAcc, 0.0); }
  public static void AddSolarFluxF10(FlatBufferBuilder builder, double solarFluxF10) { builder.AddDouble(62, solarFluxF10, 0.0); }
  public static void AddSolarFluxF10Avg(FlatBufferBuilder builder, double solarFluxF10Avg) { builder.AddDouble(63, solarFluxF10Avg, 0.0); }
  public static void AddSolarFluxAPAvg(FlatBufferBuilder builder, double solarFluxAPAvg) { builder.AddDouble(64, solarFluxAPAvg, 0.0); }
  public static void AddTaiUtc(FlatBufferBuilder builder, double taiUtc) { builder.AddDouble(65, taiUtc, 0.0); }
  public static void AddUt1Utc(FlatBufferBuilder builder, double ut1Utc) { builder.AddDouble(66, ut1Utc, 0.0); }
  public static void AddUt1Rate(FlatBufferBuilder builder, double ut1Rate) { builder.AddDouble(67, ut1Rate, 0.0); }
  public static void AddPolarMotionX(FlatBufferBuilder builder, double polarMotionX) { builder.AddDouble(68, polarMotionX, 0.0); }
  public static void AddPolarMotionY(FlatBufferBuilder builder, double polarMotionY) { builder.AddDouble(69, polarMotionY, 0.0); }
  public static void AddIau1980Terms(FlatBufferBuilder builder, int iau1980Terms) { builder.AddInt(70, iau1980Terms, 0); }
  public static void AddLeapSecondTime(FlatBufferBuilder builder, StringOffset leapSecondTimeOffset) { builder.AddOffset(71, leapSecondTimeOffset.Value, 0); }
  public static void AddIntegratorMode(FlatBufferBuilder builder, StringOffset integratorModeOffset) { builder.AddOffset(72, integratorModeOffset.Value, 0); }
  public static void AddPartials(FlatBufferBuilder builder, StringOffset partialsOffset) { builder.AddOffset(73, partialsOffset.Value, 0); }
  public static void AddStepMode(FlatBufferBuilder builder, StringOffset stepModeOffset) { builder.AddOffset(74, stepModeOffset.Value, 0); }
  public static void AddFixedStep(FlatBufferBuilder builder, bool fixedStep) { builder.AddBool(75, fixedStep, false); }
  public static void AddStepSizeSelection(FlatBufferBuilder builder, StringOffset stepSizeSelectionOffset) { builder.AddOffset(76, stepSizeSelectionOffset.Value, 0); }
  public static void AddStepSize(FlatBufferBuilder builder, double stepSize) { builder.AddDouble(77, stepSize, 0.0); }
  public static void AddErrorControl(FlatBufferBuilder builder, double errorControl) { builder.AddDouble(78, errorControl, 0.0); }
  public static void AddSigmaPosUVW(FlatBufferBuilder builder, VectorOffset sigmaPosUVWOffset) { builder.AddOffset(79, sigmaPosUVWOffset.Value, 0); }
  public static VectorOffset CreateSigmaPosUVWVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSigmaPosUVWVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSigmaPosUVWVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSigmaPosUVWVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSigmaPosUVWVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSigmaVelUVW(FlatBufferBuilder builder, VectorOffset sigmaVelUVWOffset) { builder.AddOffset(80, sigmaVelUVWOffset.Value, 0); }
  public static VectorOffset CreateSigmaVelUVWVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSigmaVelUVWVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSigmaVelUVWVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSigmaVelUVWVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSigmaVelUVWVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddRms(FlatBufferBuilder builder, double rms) { builder.AddDouble(81, rms, 0.0); }
  public static void AddRawFileURI(FlatBufferBuilder builder, StringOffset rawFileURIOffset) { builder.AddOffset(82, rawFileURIOffset.Value, 0); }
  public static void AddSource(FlatBufferBuilder builder, StringOffset sourceOffset) { builder.AddOffset(83, sourceOffset.Value, 0); }
  public static void AddOrigin(FlatBufferBuilder builder, StringOffset originOffset) { builder.AddOffset(84, originOffset.Value, 0); }
  public static void AddDataMode(FlatBufferBuilder builder, StateVector_Ingest_dataMode_Enum dataMode) { builder.AddSbyte(85, (sbyte)dataMode, 0); }
  public static void AddTags(FlatBufferBuilder builder, VectorOffset tagsOffset) { builder.AddOffset(86, tagsOffset.Value, 0); }
  public static VectorOffset CreateTagsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTagsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTagsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTagsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTagsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddAlgorithm(FlatBufferBuilder builder, StringOffset algorithmOffset) { builder.AddOffset(87, algorithmOffset.Value, 0); }
  public static void AddSourcedData(FlatBufferBuilder builder, VectorOffset sourcedDataOffset) { builder.AddOffset(88, sourcedDataOffset.Value, 0); }
  public static VectorOffset CreateSourcedDataVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSourcedDataVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSourcedDataVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSourcedDataVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSourcedDataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSourcedDataTypes(FlatBufferBuilder builder, StateVector_Ingest_sourcedDataTypes_Enum sourcedDataTypes) { builder.AddSbyte(89, (sbyte)sourcedDataTypes, 0); }
  public static void AddCreatedAt(FlatBufferBuilder builder, StringOffset createdAtOffset) { builder.AddOffset(90, createdAtOffset.Value, 0); }
  public static void AddCreatedBy(FlatBufferBuilder builder, StringOffset createdByOffset) { builder.AddOffset(91, createdByOffset.Value, 0); }
  public static void AddDescriptor(FlatBufferBuilder builder, StringOffset descriptorOffset) { builder.AddOffset(92, descriptorOffset.Value, 0); }
  public static void AddTransactionId(FlatBufferBuilder builder, StringOffset transactionIdOffset) { builder.AddOffset(93, transactionIdOffset.Value, 0); }
  public static void AddOrigNetwork(FlatBufferBuilder builder, StringOffset origNetworkOffset) { builder.AddOffset(94, origNetworkOffset.Value, 0); }
  public static void AddSourceDL(FlatBufferBuilder builder, StringOffset sourceDLOffset) { builder.AddOffset(95, sourceDLOffset.Value, 0); }
  public static Offset<StateVector_Ingest> EndStateVector_Ingest(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<StateVector_Ingest>(o);
  }
  public static void FinishStateVector_IngestBuffer(FlatBufferBuilder builder, Offset<StateVector_Ingest> offset) { builder.Finish(offset.Value, "STAT"); }
  public static void FinishSizePrefixedStateVector_IngestBuffer(FlatBufferBuilder builder, Offset<StateVector_Ingest> offset) { builder.FinishSizePrefixed(offset.Value, "STAT"); }
  public StateVector_IngestT UnPack() {
    var _o = new StateVector_IngestT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(StateVector_IngestT _o) {
    _o.IdStateVector = this.IdStateVector;
    _o.ClassificationMarking = this.ClassificationMarking;
    _o.Epoch = this.Epoch;
    _o.Pedigree = this.Pedigree;
    _o.IdOnOrbit = this.IdOnOrbit;
    _o.SatNo = this.SatNo;
    _o.OrigObjectId = this.OrigObjectId;
    _o.IdOrbitDetermination = this.IdOrbitDetermination;
    _o.Uct = this.Uct;
    _o.Xpos = this.Xpos;
    _o.Ypos = this.Ypos;
    _o.Zpos = this.Zpos;
    _o.Xvel = this.Xvel;
    _o.Yvel = this.Yvel;
    _o.Zvel = this.Zvel;
    _o.ReferenceFrame = this.ReferenceFrame;
    _o.Cov = new List<string>();
    for (var _j = 0; _j < this.CovLength; ++_j) {_o.Cov.Add(this.Cov(_j));}
    _o.CovReferenceFrame = this.CovReferenceFrame;
    _o.CovMethod = this.CovMethod;
    _o.EqCov = new List<string>();
    for (var _j = 0; _j < this.EqCovLength; ++_j) {_o.EqCov.Add(this.EqCov(_j));}
    _o.XposAlt1 = this.XposAlt1;
    _o.YposAlt1 = this.YposAlt1;
    _o.ZposAlt1 = this.ZposAlt1;
    _o.XvelAlt1 = this.XvelAlt1;
    _o.YvelAlt1 = this.YvelAlt1;
    _o.ZvelAlt1 = this.ZvelAlt1;
    _o.Alt1ReferenceFrame = this.Alt1ReferenceFrame;
    _o.XposAlt2 = this.XposAlt2;
    _o.YposAlt2 = this.YposAlt2;
    _o.ZposAlt2 = this.ZposAlt2;
    _o.XvelAlt2 = this.XvelAlt2;
    _o.YvelAlt2 = this.YvelAlt2;
    _o.ZvelAlt2 = this.ZvelAlt2;
    _o.Alt2ReferenceFrame = this.Alt2ReferenceFrame;
    _o.PosUnc = this.PosUnc;
    _o.VelUnc = this.VelUnc;
    _o.Mass = this.Mass;
    _o.Area = this.Area;
    _o.SolarRadPressCoeff = this.SolarRadPressCoeff;
    _o.DragCoeff = this.DragCoeff;
    _o.DragArea = this.DragArea;
    _o.RevNo = this.RevNo;
    _o.GeopotentialModel = this.GeopotentialModel;
    _o.DragModel = this.DragModel;
    _o.LunarSolar = this.LunarSolar;
    _o.SolarRadPress = this.SolarRadPress;
    _o.SrpArea = this.SrpArea;
    _o.SolidEarthTides = this.SolidEarthTides;
    _o.InTrackThrust = this.InTrackThrust;
    _o.BDot = this.BDot;
    _o.Edr = this.Edr;
    _o.ThrustAccel = this.ThrustAccel;
    _o.CmOffset = this.CmOffset;
    _o.LastObStart = this.LastObStart;
    _o.LastObEnd = this.LastObEnd;
    _o.ObsAvailable = this.ObsAvailable;
    _o.ObsUsed = this.ObsUsed;
    _o.TracksAvail = this.TracksAvail;
    _o.TracksUsed = this.TracksUsed;
    _o.RecODSpan = this.RecODSpan;
    _o.ActualODSpan = this.ActualODSpan;
    _o.ResidualsAcc = this.ResidualsAcc;
    _o.SolarFluxF10 = this.SolarFluxF10;
    _o.SolarFluxF10Avg = this.SolarFluxF10Avg;
    _o.SolarFluxAPAvg = this.SolarFluxAPAvg;
    _o.TaiUtc = this.TaiUtc;
    _o.Ut1Utc = this.Ut1Utc;
    _o.Ut1Rate = this.Ut1Rate;
    _o.PolarMotionX = this.PolarMotionX;
    _o.PolarMotionY = this.PolarMotionY;
    _o.Iau1980Terms = this.Iau1980Terms;
    _o.LeapSecondTime = this.LeapSecondTime;
    _o.IntegratorMode = this.IntegratorMode;
    _o.Partials = this.Partials;
    _o.StepMode = this.StepMode;
    _o.FixedStep = this.FixedStep;
    _o.StepSizeSelection = this.StepSizeSelection;
    _o.StepSize = this.StepSize;
    _o.ErrorControl = this.ErrorControl;
    _o.SigmaPosUVW = new List<string>();
    for (var _j = 0; _j < this.SigmaPosUVWLength; ++_j) {_o.SigmaPosUVW.Add(this.SigmaPosUVW(_j));}
    _o.SigmaVelUVW = new List<string>();
    for (var _j = 0; _j < this.SigmaVelUVWLength; ++_j) {_o.SigmaVelUVW.Add(this.SigmaVelUVW(_j));}
    _o.Rms = this.Rms;
    _o.RawFileURI = this.RawFileURI;
    _o.Source = this.Source;
    _o.Origin = this.Origin;
    _o.DataMode = this.DataMode;
    _o.Tags = new List<string>();
    for (var _j = 0; _j < this.TagsLength; ++_j) {_o.Tags.Add(this.Tags(_j));}
    _o.Algorithm = this.Algorithm;
    _o.SourcedData = new List<string>();
    for (var _j = 0; _j < this.SourcedDataLength; ++_j) {_o.SourcedData.Add(this.SourcedData(_j));}
    _o.SourcedDataTypes = this.SourcedDataTypes;
    _o.CreatedAt = this.CreatedAt;
    _o.CreatedBy = this.CreatedBy;
    _o.Descriptor = this.Descriptor;
    _o.TransactionId = this.TransactionId;
    _o.OrigNetwork = this.OrigNetwork;
    _o.SourceDL = this.SourceDL;
  }
  public static Offset<StateVector_Ingest> Pack(FlatBufferBuilder builder, StateVector_IngestT _o) {
    if (_o == null) return default(Offset<StateVector_Ingest>);
    var _idStateVector = _o.IdStateVector == null ? default(StringOffset) : builder.CreateString(_o.IdStateVector);
    var _classificationMarking = _o.ClassificationMarking == null ? default(StringOffset) : builder.CreateString(_o.ClassificationMarking);
    var _epoch = _o.Epoch == null ? default(StringOffset) : builder.CreateString(_o.Epoch);
    var _pedigree = _o.Pedigree == null ? default(StringOffset) : builder.CreateString(_o.Pedigree);
    var _idOnOrbit = _o.IdOnOrbit == null ? default(StringOffset) : builder.CreateString(_o.IdOnOrbit);
    var _origObjectId = _o.OrigObjectId == null ? default(StringOffset) : builder.CreateString(_o.OrigObjectId);
    var _idOrbitDetermination = _o.IdOrbitDetermination == null ? default(StringOffset) : builder.CreateString(_o.IdOrbitDetermination);
    var _cov = default(VectorOffset);
    if (_o.Cov != null) {
      var __cov = new StringOffset[_o.Cov.Count];
      for (var _j = 0; _j < __cov.Length; ++_j) { __cov[_j] = builder.CreateString(_o.Cov[_j]); }
      _cov = CreateCovVector(builder, __cov);
    }
    var _covMethod = _o.CovMethod == null ? default(StringOffset) : builder.CreateString(_o.CovMethod);
    var _eqCov = default(VectorOffset);
    if (_o.EqCov != null) {
      var __eqCov = new StringOffset[_o.EqCov.Count];
      for (var _j = 0; _j < __eqCov.Length; ++_j) { __eqCov[_j] = builder.CreateString(_o.EqCov[_j]); }
      _eqCov = CreateEqCovVector(builder, __eqCov);
    }
    var _alt1ReferenceFrame = _o.Alt1ReferenceFrame == null ? default(StringOffset) : builder.CreateString(_o.Alt1ReferenceFrame);
    var _alt2ReferenceFrame = _o.Alt2ReferenceFrame == null ? default(StringOffset) : builder.CreateString(_o.Alt2ReferenceFrame);
    var _geopotentialModel = _o.GeopotentialModel == null ? default(StringOffset) : builder.CreateString(_o.GeopotentialModel);
    var _dragModel = _o.DragModel == null ? default(StringOffset) : builder.CreateString(_o.DragModel);
    var _lastObStart = _o.LastObStart == null ? default(StringOffset) : builder.CreateString(_o.LastObStart);
    var _lastObEnd = _o.LastObEnd == null ? default(StringOffset) : builder.CreateString(_o.LastObEnd);
    var _leapSecondTime = _o.LeapSecondTime == null ? default(StringOffset) : builder.CreateString(_o.LeapSecondTime);
    var _integratorMode = _o.IntegratorMode == null ? default(StringOffset) : builder.CreateString(_o.IntegratorMode);
    var _partials = _o.Partials == null ? default(StringOffset) : builder.CreateString(_o.Partials);
    var _stepMode = _o.StepMode == null ? default(StringOffset) : builder.CreateString(_o.StepMode);
    var _stepSizeSelection = _o.StepSizeSelection == null ? default(StringOffset) : builder.CreateString(_o.StepSizeSelection);
    var _sigmaPosUVW = default(VectorOffset);
    if (_o.SigmaPosUVW != null) {
      var __sigmaPosUVW = new StringOffset[_o.SigmaPosUVW.Count];
      for (var _j = 0; _j < __sigmaPosUVW.Length; ++_j) { __sigmaPosUVW[_j] = builder.CreateString(_o.SigmaPosUVW[_j]); }
      _sigmaPosUVW = CreateSigmaPosUVWVector(builder, __sigmaPosUVW);
    }
    var _sigmaVelUVW = default(VectorOffset);
    if (_o.SigmaVelUVW != null) {
      var __sigmaVelUVW = new StringOffset[_o.SigmaVelUVW.Count];
      for (var _j = 0; _j < __sigmaVelUVW.Length; ++_j) { __sigmaVelUVW[_j] = builder.CreateString(_o.SigmaVelUVW[_j]); }
      _sigmaVelUVW = CreateSigmaVelUVWVector(builder, __sigmaVelUVW);
    }
    var _rawFileURI = _o.RawFileURI == null ? default(StringOffset) : builder.CreateString(_o.RawFileURI);
    var _source = _o.Source == null ? default(StringOffset) : builder.CreateString(_o.Source);
    var _origin = _o.Origin == null ? default(StringOffset) : builder.CreateString(_o.Origin);
    var _tags = default(VectorOffset);
    if (_o.Tags != null) {
      var __tags = new StringOffset[_o.Tags.Count];
      for (var _j = 0; _j < __tags.Length; ++_j) { __tags[_j] = builder.CreateString(_o.Tags[_j]); }
      _tags = CreateTagsVector(builder, __tags);
    }
    var _algorithm = _o.Algorithm == null ? default(StringOffset) : builder.CreateString(_o.Algorithm);
    var _sourcedData = default(VectorOffset);
    if (_o.SourcedData != null) {
      var __sourcedData = new StringOffset[_o.SourcedData.Count];
      for (var _j = 0; _j < __sourcedData.Length; ++_j) { __sourcedData[_j] = builder.CreateString(_o.SourcedData[_j]); }
      _sourcedData = CreateSourcedDataVector(builder, __sourcedData);
    }
    var _createdAt = _o.CreatedAt == null ? default(StringOffset) : builder.CreateString(_o.CreatedAt);
    var _createdBy = _o.CreatedBy == null ? default(StringOffset) : builder.CreateString(_o.CreatedBy);
    var _descriptor = _o.Descriptor == null ? default(StringOffset) : builder.CreateString(_o.Descriptor);
    var _transactionId = _o.TransactionId == null ? default(StringOffset) : builder.CreateString(_o.TransactionId);
    var _origNetwork = _o.OrigNetwork == null ? default(StringOffset) : builder.CreateString(_o.OrigNetwork);
    var _sourceDL = _o.SourceDL == null ? default(StringOffset) : builder.CreateString(_o.SourceDL);
    return CreateStateVector_Ingest(
      builder,
      _idStateVector,
      _classificationMarking,
      _epoch,
      _pedigree,
      _idOnOrbit,
      _o.SatNo,
      _origObjectId,
      _idOrbitDetermination,
      _o.Uct,
      _o.Xpos,
      _o.Ypos,
      _o.Zpos,
      _o.Xvel,
      _o.Yvel,
      _o.Zvel,
      _o.ReferenceFrame,
      _cov,
      _o.CovReferenceFrame,
      _covMethod,
      _eqCov,
      _o.XposAlt1,
      _o.YposAlt1,
      _o.ZposAlt1,
      _o.XvelAlt1,
      _o.YvelAlt1,
      _o.ZvelAlt1,
      _alt1ReferenceFrame,
      _o.XposAlt2,
      _o.YposAlt2,
      _o.ZposAlt2,
      _o.XvelAlt2,
      _o.YvelAlt2,
      _o.ZvelAlt2,
      _alt2ReferenceFrame,
      _o.PosUnc,
      _o.VelUnc,
      _o.Mass,
      _o.Area,
      _o.SolarRadPressCoeff,
      _o.DragCoeff,
      _o.DragArea,
      _o.RevNo,
      _geopotentialModel,
      _dragModel,
      _o.LunarSolar,
      _o.SolarRadPress,
      _o.SrpArea,
      _o.SolidEarthTides,
      _o.InTrackThrust,
      _o.BDot,
      _o.Edr,
      _o.ThrustAccel,
      _o.CmOffset,
      _lastObStart,
      _lastObEnd,
      _o.ObsAvailable,
      _o.ObsUsed,
      _o.TracksAvail,
      _o.TracksUsed,
      _o.RecODSpan,
      _o.ActualODSpan,
      _o.ResidualsAcc,
      _o.SolarFluxF10,
      _o.SolarFluxF10Avg,
      _o.SolarFluxAPAvg,
      _o.TaiUtc,
      _o.Ut1Utc,
      _o.Ut1Rate,
      _o.PolarMotionX,
      _o.PolarMotionY,
      _o.Iau1980Terms,
      _leapSecondTime,
      _integratorMode,
      _partials,
      _stepMode,
      _o.FixedStep,
      _stepSizeSelection,
      _o.StepSize,
      _o.ErrorControl,
      _sigmaPosUVW,
      _sigmaVelUVW,
      _o.Rms,
      _rawFileURI,
      _source,
      _origin,
      _o.DataMode,
      _tags,
      _algorithm,
      _sourcedData,
      _o.SourcedDataTypes,
      _createdAt,
      _createdBy,
      _descriptor,
      _transactionId,
      _origNetwork,
      _sourceDL);
  }
}

public class StateVector_IngestT
{
  public string IdStateVector { get; set; }
  public string ClassificationMarking { get; set; }
  public string Epoch { get; set; }
  public string Pedigree { get; set; }
  public string IdOnOrbit { get; set; }
  public int SatNo { get; set; }
  public string OrigObjectId { get; set; }
  public string IdOrbitDetermination { get; set; }
  public bool Uct { get; set; }
  public double Xpos { get; set; }
  public double Ypos { get; set; }
  public double Zpos { get; set; }
  public double Xvel { get; set; }
  public double Yvel { get; set; }
  public double Zvel { get; set; }
  public StateVector_Ingest_referenceFrame_Enum ReferenceFrame { get; set; }
  public List<string> Cov { get; set; }
  public StateVector_Ingest_covReferenceFrame_Enum CovReferenceFrame { get; set; }
  public string CovMethod { get; set; }
  public List<string> EqCov { get; set; }
  public double XposAlt1 { get; set; }
  public double YposAlt1 { get; set; }
  public double ZposAlt1 { get; set; }
  public double XvelAlt1 { get; set; }
  public double YvelAlt1 { get; set; }
  public double ZvelAlt1 { get; set; }
  public string Alt1ReferenceFrame { get; set; }
  public double XposAlt2 { get; set; }
  public double YposAlt2 { get; set; }
  public double ZposAlt2 { get; set; }
  public double XvelAlt2 { get; set; }
  public double YvelAlt2 { get; set; }
  public double ZvelAlt2 { get; set; }
  public string Alt2ReferenceFrame { get; set; }
  public double PosUnc { get; set; }
  public double VelUnc { get; set; }
  public double Mass { get; set; }
  public double Area { get; set; }
  public double SolarRadPressCoeff { get; set; }
  public double DragCoeff { get; set; }
  public double DragArea { get; set; }
  public int RevNo { get; set; }
  public string GeopotentialModel { get; set; }
  public string DragModel { get; set; }
  public bool LunarSolar { get; set; }
  public bool SolarRadPress { get; set; }
  public double SrpArea { get; set; }
  public bool SolidEarthTides { get; set; }
  public bool InTrackThrust { get; set; }
  public double BDot { get; set; }
  public double Edr { get; set; }
  public double ThrustAccel { get; set; }
  public double CmOffset { get; set; }
  public string LastObStart { get; set; }
  public string LastObEnd { get; set; }
  public int ObsAvailable { get; set; }
  public int ObsUsed { get; set; }
  public int TracksAvail { get; set; }
  public int TracksUsed { get; set; }
  public double RecODSpan { get; set; }
  public double ActualODSpan { get; set; }
  public double ResidualsAcc { get; set; }
  public double SolarFluxF10 { get; set; }
  public double SolarFluxF10Avg { get; set; }
  public double SolarFluxAPAvg { get; set; }
  public double TaiUtc { get; set; }
  public double Ut1Utc { get; set; }
  public double Ut1Rate { get; set; }
  public double PolarMotionX { get; set; }
  public double PolarMotionY { get; set; }
  public int Iau1980Terms { get; set; }
  public string LeapSecondTime { get; set; }
  public string IntegratorMode { get; set; }
  public string Partials { get; set; }
  public string StepMode { get; set; }
  public bool FixedStep { get; set; }
  public string StepSizeSelection { get; set; }
  public double StepSize { get; set; }
  public double ErrorControl { get; set; }
  public List<string> SigmaPosUVW { get; set; }
  public List<string> SigmaVelUVW { get; set; }
  public double Rms { get; set; }
  public string RawFileURI { get; set; }
  public string Source { get; set; }
  public string Origin { get; set; }
  public StateVector_Ingest_dataMode_Enum DataMode { get; set; }
  public List<string> Tags { get; set; }
  public string Algorithm { get; set; }
  public List<string> SourcedData { get; set; }
  public StateVector_Ingest_sourcedDataTypes_Enum SourcedDataTypes { get; set; }
  public string CreatedAt { get; set; }
  public string CreatedBy { get; set; }
  public string Descriptor { get; set; }
  public string TransactionId { get; set; }
  public string OrigNetwork { get; set; }
  public string SourceDL { get; set; }

  public StateVector_IngestT() {
    this.IdStateVector = null;
    this.ClassificationMarking = null;
    this.Epoch = null;
    this.Pedigree = null;
    this.IdOnOrbit = null;
    this.SatNo = 0;
    this.OrigObjectId = null;
    this.IdOrbitDetermination = null;
    this.Uct = false;
    this.Xpos = 0.0;
    this.Ypos = 0.0;
    this.Zpos = 0.0;
    this.Xvel = 0.0;
    this.Yvel = 0.0;
    this.Zvel = 0.0;
    this.ReferenceFrame = StateVector_Ingest_referenceFrame_Enum.J2000;
    this.Cov = null;
    this.CovReferenceFrame = StateVector_Ingest_covReferenceFrame_Enum.J2000;
    this.CovMethod = null;
    this.EqCov = null;
    this.XposAlt1 = 0.0;
    this.YposAlt1 = 0.0;
    this.ZposAlt1 = 0.0;
    this.XvelAlt1 = 0.0;
    this.YvelAlt1 = 0.0;
    this.ZvelAlt1 = 0.0;
    this.Alt1ReferenceFrame = null;
    this.XposAlt2 = 0.0;
    this.YposAlt2 = 0.0;
    this.ZposAlt2 = 0.0;
    this.XvelAlt2 = 0.0;
    this.YvelAlt2 = 0.0;
    this.ZvelAlt2 = 0.0;
    this.Alt2ReferenceFrame = null;
    this.PosUnc = 0.0;
    this.VelUnc = 0.0;
    this.Mass = 0.0;
    this.Area = 0.0;
    this.SolarRadPressCoeff = 0.0;
    this.DragCoeff = 0.0;
    this.DragArea = 0.0;
    this.RevNo = 0;
    this.GeopotentialModel = null;
    this.DragModel = null;
    this.LunarSolar = false;
    this.SolarRadPress = false;
    this.SrpArea = 0.0;
    this.SolidEarthTides = false;
    this.InTrackThrust = false;
    this.BDot = 0.0;
    this.Edr = 0.0;
    this.ThrustAccel = 0.0;
    this.CmOffset = 0.0;
    this.LastObStart = null;
    this.LastObEnd = null;
    this.ObsAvailable = 0;
    this.ObsUsed = 0;
    this.TracksAvail = 0;
    this.TracksUsed = 0;
    this.RecODSpan = 0.0;
    this.ActualODSpan = 0.0;
    this.ResidualsAcc = 0.0;
    this.SolarFluxF10 = 0.0;
    this.SolarFluxF10Avg = 0.0;
    this.SolarFluxAPAvg = 0.0;
    this.TaiUtc = 0.0;
    this.Ut1Utc = 0.0;
    this.Ut1Rate = 0.0;
    this.PolarMotionX = 0.0;
    this.PolarMotionY = 0.0;
    this.Iau1980Terms = 0;
    this.LeapSecondTime = null;
    this.IntegratorMode = null;
    this.Partials = null;
    this.StepMode = null;
    this.FixedStep = false;
    this.StepSizeSelection = null;
    this.StepSize = 0.0;
    this.ErrorControl = 0.0;
    this.SigmaPosUVW = null;
    this.SigmaVelUVW = null;
    this.Rms = 0.0;
    this.RawFileURI = null;
    this.Source = null;
    this.Origin = null;
    this.DataMode = StateVector_Ingest_dataMode_Enum.REAL;
    this.Tags = null;
    this.Algorithm = null;
    this.SourcedData = null;
    this.SourcedDataTypes = StateVector_Ingest_sourcedDataTypes_Enum.EO;
    this.CreatedAt = null;
    this.CreatedBy = null;
    this.Descriptor = null;
    this.TransactionId = null;
    this.OrigNetwork = null;
    this.SourceDL = null;
  }
  public static StateVector_IngestT DeserializeFromBinary(byte[] fbBuffer) {
    return StateVector_Ingest.GetRootAsStateVector_Ingest(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    StateVector_Ingest.FinishStateVector_IngestBuffer(fbb, StateVector_Ingest.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class StateVector_IngestVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*IdStateVector*/, false)
      && verifier.VerifyString(tablePos, 6 /*ClassificationMarking*/, false)
      && verifier.VerifyString(tablePos, 8 /*Epoch*/, false)
      && verifier.VerifyString(tablePos, 10 /*Pedigree*/, false)
      && verifier.VerifyString(tablePos, 12 /*IdOnOrbit*/, false)
      && verifier.VerifyField(tablePos, 14 /*SatNo*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 16 /*OrigObjectId*/, false)
      && verifier.VerifyString(tablePos, 18 /*IdOrbitDetermination*/, false)
      && verifier.VerifyField(tablePos, 20 /*Uct*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 22 /*Xpos*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 24 /*Ypos*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 26 /*Zpos*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 28 /*Xvel*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 30 /*Yvel*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 32 /*Zvel*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 34 /*ReferenceFrame*/, 1 /*StateVector_Ingest_referenceFrame_Enum*/, 1, false)
      && verifier.VerifyVectorOfStrings(tablePos, 36 /*Cov*/, false)
      && verifier.VerifyField(tablePos, 38 /*CovReferenceFrame*/, 1 /*StateVector_Ingest_covReferenceFrame_Enum*/, 1, false)
      && verifier.VerifyString(tablePos, 40 /*CovMethod*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 42 /*EqCov*/, false)
      && verifier.VerifyField(tablePos, 44 /*XposAlt1*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 46 /*YposAlt1*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 48 /*ZposAlt1*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 50 /*XvelAlt1*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 52 /*YvelAlt1*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 54 /*ZvelAlt1*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 56 /*Alt1ReferenceFrame*/, false)
      && verifier.VerifyField(tablePos, 58 /*XposAlt2*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 60 /*YposAlt2*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 62 /*ZposAlt2*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 64 /*XvelAlt2*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 66 /*YvelAlt2*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 68 /*ZvelAlt2*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 70 /*Alt2ReferenceFrame*/, false)
      && verifier.VerifyField(tablePos, 72 /*PosUnc*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 74 /*VelUnc*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 76 /*Mass*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 78 /*Area*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 80 /*SolarRadPressCoeff*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 82 /*DragCoeff*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 84 /*DragArea*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 86 /*RevNo*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 88 /*GeopotentialModel*/, false)
      && verifier.VerifyString(tablePos, 90 /*DragModel*/, false)
      && verifier.VerifyField(tablePos, 92 /*LunarSolar*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 94 /*SolarRadPress*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 96 /*SrpArea*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 98 /*SolidEarthTides*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 100 /*InTrackThrust*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 102 /*BDot*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 104 /*Edr*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 106 /*ThrustAccel*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 108 /*CmOffset*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 110 /*LastObStart*/, false)
      && verifier.VerifyString(tablePos, 112 /*LastObEnd*/, false)
      && verifier.VerifyField(tablePos, 114 /*ObsAvailable*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 116 /*ObsUsed*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 118 /*TracksAvail*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 120 /*TracksUsed*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 122 /*RecODSpan*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 124 /*ActualODSpan*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 126 /*ResidualsAcc*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 128 /*SolarFluxF10*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 130 /*SolarFluxF10Avg*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 132 /*SolarFluxAPAvg*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 134 /*TaiUtc*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 136 /*Ut1Utc*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 138 /*Ut1Rate*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 140 /*PolarMotionX*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 142 /*PolarMotionY*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 144 /*Iau1980Terms*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 146 /*LeapSecondTime*/, false)
      && verifier.VerifyString(tablePos, 148 /*IntegratorMode*/, false)
      && verifier.VerifyString(tablePos, 150 /*Partials*/, false)
      && verifier.VerifyString(tablePos, 152 /*StepMode*/, false)
      && verifier.VerifyField(tablePos, 154 /*FixedStep*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 156 /*StepSizeSelection*/, false)
      && verifier.VerifyField(tablePos, 158 /*StepSize*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 160 /*ErrorControl*/, 8 /*double*/, 8, false)
      && verifier.VerifyVectorOfStrings(tablePos, 162 /*SigmaPosUVW*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 164 /*SigmaVelUVW*/, false)
      && verifier.VerifyField(tablePos, 166 /*Rms*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 168 /*RawFileURI*/, false)
      && verifier.VerifyString(tablePos, 170 /*Source*/, false)
      && verifier.VerifyString(tablePos, 172 /*Origin*/, false)
      && verifier.VerifyField(tablePos, 174 /*DataMode*/, 1 /*StateVector_Ingest_dataMode_Enum*/, 1, false)
      && verifier.VerifyVectorOfStrings(tablePos, 176 /*Tags*/, false)
      && verifier.VerifyString(tablePos, 178 /*Algorithm*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 180 /*SourcedData*/, false)
      && verifier.VerifyField(tablePos, 182 /*SourcedDataTypes*/, 1 /*StateVector_Ingest_sourcedDataTypes_Enum*/, 1, false)
      && verifier.VerifyString(tablePos, 184 /*CreatedAt*/, false)
      && verifier.VerifyString(tablePos, 186 /*CreatedBy*/, false)
      && verifier.VerifyString(tablePos, 188 /*Descriptor*/, false)
      && verifier.VerifyString(tablePos, 190 /*TransactionId*/, false)
      && verifier.VerifyString(tablePos, 192 /*OrigNetwork*/, false)
      && verifier.VerifyString(tablePos, 194 /*SourceDL*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
