// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// A conditional nested segment to report multiple airspace control means within a particular airspace control means status.
public struct AirspaceControlMeans_Full : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static AirspaceControlMeans_Full GetRootAsAirspaceControlMeans_Full(ByteBuffer _bb) { return GetRootAsAirspaceControlMeans_Full(_bb, new AirspaceControlMeans_Full()); }
  public static AirspaceControlMeans_Full GetRootAsAirspaceControlMeans_Full(ByteBuffer _bb, AirspaceControlMeans_Full obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool AirspaceControlMeans_FullBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "AIRS"); }
  public static bool VerifyAirspaceControlMeans_Full(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("AIRS", false, AirspaceControlMeans_FullVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public AirspaceControlMeans_Full __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The code for the type of airspace control means.
  /// Example: /// Example: ACM:ADAREA
  /// Constraints: Minimum length = 0, Maximum length = 8
  public string CmType { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCmTypeBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetCmTypeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetCmTypeArray() { return __p.__vector_as_array<byte>(4); }
  /// Airspace control means name or designator.
  /// Example: /// Example: DESIG:C34
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string CmId { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCmIdBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetCmIdBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetCmIdArray() { return __p.__vector_as_array<byte>(6); }
  /// Designates the geometric type that defines the airspace shape. One of CIRCLE, CORRIDOR, LINE, ORBIT, etc.
  /// Example: /// Example: POLYARC
  /// Constraints: Minimum length = 0, Maximum length = 8
  public AirspaceControlMeans_Full_cmShape_Enum CmShape { get { int o = __p.__offset(8); return o != 0 ? (AirspaceControlMeans_Full_cmShape_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : AirspaceControlMeans_Full_cmShape_Enum.POLYARC; } }
  /// Designates the means by which a defined airspace control means is to be used.
  /// Example: /// Example: USE:AIRCOR
  /// Constraints: Minimum length = 0, Maximum length = 8
  public string Usage { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetUsageBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetUsageBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetUsageArray() { return __p.__vector_as_array<byte>(10); }
  /// Unique Link 16 identifier assigned to the airspace control means.
  /// Example: /// Example: F3356
  /// Constraints: Minimum length = 0, Maximum length = 8
  public string Link16Id { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLink16IdBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetLink16IdBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetLink16IdArray() { return __p.__vector_as_array<byte>(12); }
  /// The altitude at or below which the vertical position of an aircraft is controlled by reference to true altitude.
  /// Example: /// Example: 18000FT
  /// Constraints: Minimum length = 0, Maximum length = 8
  public string TransAltitude { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTransAltitudeBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetTransAltitudeBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetTransAltitudeArray() { return __p.__vector_as_array<byte>(14); }
  /// Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated, if different from the top level ACO datum.
  /// Example: /// Example: NAR
  /// Constraints: Minimum length = 0, Maximum length = 8
  public string GeoDatumAlt { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetGeoDatumAltBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetGeoDatumAltBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetGeoDatumAltArray() { return __p.__vector_as_array<byte>(16); }
  /// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
  /// Example: /// Example: 152345N0505657E
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string Coord0 { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCoord0Bytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetCoord0Bytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetCoord0Array() { return __p.__vector_as_array<byte>(18); }
  /// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
  /// Example: /// Example: 1523N05057E
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string Coord1 { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCoord1Bytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetCoord1Bytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetCoord1Array() { return __p.__vector_as_array<byte>(20); }
  /// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "beginning" radial bearing parameter.
  /// Example: /// Example: 330
  /// Constraints: No constraints specified.
  public double Bearing0 { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "ending" radial bearing parameter.
  /// Example: /// Example: 160
  /// Constraints: No constraints specified.
  public double Bearing1 { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "inner" radial magnitude arc limit. If provided, the field radMagUnit is required.
  /// Example: /// Example: 30.04
  /// Constraints: No constraints specified.
  public double RadMag0 { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "outer" radial magnitude arc limit. If provided, the field radMagUnit is required.
  /// Example: /// Example: 50.12
  /// Constraints: No constraints specified.
  public double RadMag1 { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Specifies the unit of length in which radial magnitudes are given. Use M for meters, KM for kilometers, or NM for nautical miles.
  /// Example: /// Example: NM
  /// Constraints: Minimum length = 0, Maximum length = 8
  public string RadMagUnit { get { int o = __p.__offset(30); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRadMagUnitBytes() { return __p.__vector_as_span<byte>(30, 1); }
#else
  public ArraySegment<byte>? GetRadMagUnitBytes() { return __p.__vector_as_arraysegment(30); }
#endif
  public byte[] GetRadMagUnitArray() { return __p.__vector_as_array<byte>(30); }
  /// A set of geospatial coordinates specified in DMS (Degrees, Minutes, Seconds) format which determine the vertices of a one or two dimensional geospatial shape. When shape is set to "POLYARC" or "POLYGON," this field is required as applied in the construction of the area boundary. If cmShape is set to "COORIDOR" or "GEOLINE," this field is required and can be interpreted as an ordered set of points along a path in space.
  /// Example: /// Example: ['203632N0594256E', '155000N0594815E', '155000N0591343E']
  /// Constraints: No constraints specified.
  public string PolyCoord(int j) { int o = __p.__offset(32); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int PolyCoordLength { get { int o = __p.__offset(32); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Index of a segment in an airtrack, which is defined by an ordered set of points.
  /// Example: /// Example: 99
  /// Constraints: No constraints specified.
  public int TrackLeg { get { int o = __p.__offset(34); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the LEFT half-plane realtive to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the left of the track segment line. If provided, the field widthUnit is required.
  /// Example: /// Example: 5.2
  /// Constraints: No constraints specified.
  public double WidthLeft { get { int o = __p.__offset(36); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the RIGHT half-plane relative to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the right of the track segment line. If provided, the field widthUnit is required.
  /// Example: /// Example: 10.4
  /// Constraints: No constraints specified.
  public double WidthRight { get { int o = __p.__offset(38); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Used to describe the "side to side" distance of a target, object or area. If cmShape is set to "CORRIDOR" or "AORBIT", this field is required and is mapped to the width parameter. If provided, the field widthUnit is required.
  /// Example: /// Example: 15.6
  /// Constraints: No constraints specified.
  public double Width { get { int o = __p.__offset(40); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Specifies the unit of length for which widths are given. Use M for meters, KM for kilometers, or NM for nautical miles.
  /// Example: /// Example: KM
  /// Constraints: Minimum length = 0, Maximum length = 8
  public string WidthUnit { get { int o = __p.__offset(42); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetWidthUnitBytes() { return __p.__vector_as_span<byte>(42, 1); }
#else
  public ArraySegment<byte>? GetWidthUnitBytes() { return __p.__vector_as_arraysegment(42); }
#endif
  public byte[] GetWidthUnitArray() { return __p.__vector_as_array<byte>(42); }
  /// An array of at least two alphanumeric symbols used to serially identify the corridor waypoints. If cmShape is set to "CORRIDOR," one of either corrWayPoints or polyCoord is required to specify the centerline of the corridor path.
  /// Example: /// Example: ['POB', 'RDU', 'IAD']
  /// Constraints: No constraints specified.
  public string CorrWayPoints(int j) { int o = __p.__offset(44); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int CorrWayPointsLength { get { int o = __p.__offset(44); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Orbit alignment look-up code. Can be C=Center, L=Left, R=Right.
  /// Example: /// Example: C
  /// Constraints: Minimum length = 0, Maximum length = 1
  public string OrbitAlignment { get { int o = __p.__offset(46); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOrbitAlignmentBytes() { return __p.__vector_as_span<byte>(46, 1); }
#else
  public ArraySegment<byte>? GetOrbitAlignmentBytes() { return __p.__vector_as_arraysegment(46); }
#endif
  public byte[] GetOrbitAlignmentArray() { return __p.__vector_as_array<byte>(46); }
  /// Description of the airspace vertical dimension.
  /// Example: /// Example: BRRA:GL-100AGL
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string EffVDim { get { int o = __p.__offset(48); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEffVDimBytes() { return __p.__vector_as_span<byte>(48, 1); }
#else
  public ArraySegment<byte>? GetEffVDimBytes() { return __p.__vector_as_arraysegment(48); }
#endif
  public byte[] GetEffVDimArray() { return __p.__vector_as_array<byte>(48); }
  /// The timePeriod set describes the effective datetime for a given airspace control means.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  public string AirspaceTimePeriod(int j) { int o = __p.__offset(50); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int AirspaceTimePeriodLength { get { int o = __p.__offset(50); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The controlPoint set describes any reference/controlling/rendevous point for a given airspace control means.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  public string AirspaceControlPoint(int j) { int o = __p.__offset(52); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int AirspaceControlPointLength { get { int o = __p.__offset(52); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The commander responsible within a specified geographical area for the airspace control operation assigned to him.
  /// Example: /// Example: RHEIN MAIN CP
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string CtrlAuth { get { int o = __p.__offset(54); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCtrlAuthBytes() { return __p.__vector_as_span<byte>(54, 1); }
#else
  public ArraySegment<byte>? GetCtrlAuthBytes() { return __p.__vector_as_arraysegment(54); }
#endif
  public byte[] GetCtrlAuthArray() { return __p.__vector_as_array<byte>(54); }
  /// The frequency for the airspace control authority. Can specify HZ, KHZ, MHZ, GHZ or a DESIG frequency designator code.
  /// Example: /// Example: ['125.25MHZ']
  /// Constraints: No constraints specified.
  public string CtrlAuthFreqs(int j) { int o = __p.__offset(56); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int CtrlAuthFreqsLength { get { int o = __p.__offset(56); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Used to provide transit intstructions for the airspace control means.
  /// Example: /// Example: SITUATION
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string GenTextInd { get { int o = __p.__offset(58); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetGenTextIndBytes() { return __p.__vector_as_span<byte>(58, 1); }
#else
  public ArraySegment<byte>? GetGenTextIndBytes() { return __p.__vector_as_arraysegment(58); }
#endif
  public byte[] GetGenTextIndArray() { return __p.__vector_as_array<byte>(58); }
  /// General informat detailing the transit instruction for the airspace control means.
  /// Example: /// Example: 1. CAPACITY: MDM TK, 50 VEHICLE CONVOY. 2. CHOKE POINTS: EXIT 5
  /// Constraints: Minimum length = 0, Maximum length = 128
  public string FreeText { get { int o = __p.__offset(60); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetFreeTextBytes() { return __p.__vector_as_span<byte>(60, 1); }
#else
  public ArraySegment<byte>? GetFreeTextBytes() { return __p.__vector_as_arraysegment(60); }
#endif
  public byte[] GetFreeTextArray() { return __p.__vector_as_array<byte>(60); }

  public static Offset<AirspaceControlMeans_Full> CreateAirspaceControlMeans_Full(FlatBufferBuilder builder,
      StringOffset cmTypeOffset = default(StringOffset),
      StringOffset cmIdOffset = default(StringOffset),
      AirspaceControlMeans_Full_cmShape_Enum cmShape = AirspaceControlMeans_Full_cmShape_Enum.POLYARC,
      StringOffset usageOffset = default(StringOffset),
      StringOffset link16IdOffset = default(StringOffset),
      StringOffset transAltitudeOffset = default(StringOffset),
      StringOffset geoDatumAltOffset = default(StringOffset),
      StringOffset coord0Offset = default(StringOffset),
      StringOffset coord1Offset = default(StringOffset),
      double bearing0 = 0.0,
      double bearing1 = 0.0,
      double radMag0 = 0.0,
      double radMag1 = 0.0,
      StringOffset radMagUnitOffset = default(StringOffset),
      VectorOffset polyCoordOffset = default(VectorOffset),
      int trackLeg = 0,
      double widthLeft = 0.0,
      double widthRight = 0.0,
      double width = 0.0,
      StringOffset widthUnitOffset = default(StringOffset),
      VectorOffset corrWayPointsOffset = default(VectorOffset),
      StringOffset orbitAlignmentOffset = default(StringOffset),
      StringOffset effVDimOffset = default(StringOffset),
      VectorOffset airspaceTimePeriodOffset = default(VectorOffset),
      VectorOffset airspaceControlPointOffset = default(VectorOffset),
      StringOffset ctrlAuthOffset = default(StringOffset),
      VectorOffset ctrlAuthFreqsOffset = default(VectorOffset),
      StringOffset genTextIndOffset = default(StringOffset),
      StringOffset freeTextOffset = default(StringOffset)) {
    builder.StartTable(29);
    AirspaceControlMeans_Full.AddWidth(builder, width);
    AirspaceControlMeans_Full.AddWidthRight(builder, widthRight);
    AirspaceControlMeans_Full.AddWidthLeft(builder, widthLeft);
    AirspaceControlMeans_Full.AddRadMag1(builder, radMag1);
    AirspaceControlMeans_Full.AddRadMag0(builder, radMag0);
    AirspaceControlMeans_Full.AddBearing1(builder, bearing1);
    AirspaceControlMeans_Full.AddBearing0(builder, bearing0);
    AirspaceControlMeans_Full.AddFreeText(builder, freeTextOffset);
    AirspaceControlMeans_Full.AddGenTextInd(builder, genTextIndOffset);
    AirspaceControlMeans_Full.AddCtrlAuthFreqs(builder, ctrlAuthFreqsOffset);
    AirspaceControlMeans_Full.AddCtrlAuth(builder, ctrlAuthOffset);
    AirspaceControlMeans_Full.AddAirspaceControlPoint(builder, airspaceControlPointOffset);
    AirspaceControlMeans_Full.AddAirspaceTimePeriod(builder, airspaceTimePeriodOffset);
    AirspaceControlMeans_Full.AddEffVDim(builder, effVDimOffset);
    AirspaceControlMeans_Full.AddOrbitAlignment(builder, orbitAlignmentOffset);
    AirspaceControlMeans_Full.AddCorrWayPoints(builder, corrWayPointsOffset);
    AirspaceControlMeans_Full.AddWidthUnit(builder, widthUnitOffset);
    AirspaceControlMeans_Full.AddTrackLeg(builder, trackLeg);
    AirspaceControlMeans_Full.AddPolyCoord(builder, polyCoordOffset);
    AirspaceControlMeans_Full.AddRadMagUnit(builder, radMagUnitOffset);
    AirspaceControlMeans_Full.AddCoord1(builder, coord1Offset);
    AirspaceControlMeans_Full.AddCoord0(builder, coord0Offset);
    AirspaceControlMeans_Full.AddGeoDatumAlt(builder, geoDatumAltOffset);
    AirspaceControlMeans_Full.AddTransAltitude(builder, transAltitudeOffset);
    AirspaceControlMeans_Full.AddLink16Id(builder, link16IdOffset);
    AirspaceControlMeans_Full.AddUsage(builder, usageOffset);
    AirspaceControlMeans_Full.AddCmId(builder, cmIdOffset);
    AirspaceControlMeans_Full.AddCmType(builder, cmTypeOffset);
    AirspaceControlMeans_Full.AddCmShape(builder, cmShape);
    return AirspaceControlMeans_Full.EndAirspaceControlMeans_Full(builder);
  }

  public static void StartAirspaceControlMeans_Full(FlatBufferBuilder builder) { builder.StartTable(29); }
  public static void AddCmType(FlatBufferBuilder builder, StringOffset cmTypeOffset) { builder.AddOffset(0, cmTypeOffset.Value, 0); }
  public static void AddCmId(FlatBufferBuilder builder, StringOffset cmIdOffset) { builder.AddOffset(1, cmIdOffset.Value, 0); }
  public static void AddCmShape(FlatBufferBuilder builder, AirspaceControlMeans_Full_cmShape_Enum cmShape) { builder.AddSbyte(2, (sbyte)cmShape, 0); }
  public static void AddUsage(FlatBufferBuilder builder, StringOffset usageOffset) { builder.AddOffset(3, usageOffset.Value, 0); }
  public static void AddLink16Id(FlatBufferBuilder builder, StringOffset link16IdOffset) { builder.AddOffset(4, link16IdOffset.Value, 0); }
  public static void AddTransAltitude(FlatBufferBuilder builder, StringOffset transAltitudeOffset) { builder.AddOffset(5, transAltitudeOffset.Value, 0); }
  public static void AddGeoDatumAlt(FlatBufferBuilder builder, StringOffset geoDatumAltOffset) { builder.AddOffset(6, geoDatumAltOffset.Value, 0); }
  public static void AddCoord0(FlatBufferBuilder builder, StringOffset coord0Offset) { builder.AddOffset(7, coord0Offset.Value, 0); }
  public static void AddCoord1(FlatBufferBuilder builder, StringOffset coord1Offset) { builder.AddOffset(8, coord1Offset.Value, 0); }
  public static void AddBearing0(FlatBufferBuilder builder, double bearing0) { builder.AddDouble(9, bearing0, 0.0); }
  public static void AddBearing1(FlatBufferBuilder builder, double bearing1) { builder.AddDouble(10, bearing1, 0.0); }
  public static void AddRadMag0(FlatBufferBuilder builder, double radMag0) { builder.AddDouble(11, radMag0, 0.0); }
  public static void AddRadMag1(FlatBufferBuilder builder, double radMag1) { builder.AddDouble(12, radMag1, 0.0); }
  public static void AddRadMagUnit(FlatBufferBuilder builder, StringOffset radMagUnitOffset) { builder.AddOffset(13, radMagUnitOffset.Value, 0); }
  public static void AddPolyCoord(FlatBufferBuilder builder, VectorOffset polyCoordOffset) { builder.AddOffset(14, polyCoordOffset.Value, 0); }
  public static VectorOffset CreatePolyCoordVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePolyCoordVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePolyCoordVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePolyCoordVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPolyCoordVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTrackLeg(FlatBufferBuilder builder, int trackLeg) { builder.AddInt(15, trackLeg, 0); }
  public static void AddWidthLeft(FlatBufferBuilder builder, double widthLeft) { builder.AddDouble(16, widthLeft, 0.0); }
  public static void AddWidthRight(FlatBufferBuilder builder, double widthRight) { builder.AddDouble(17, widthRight, 0.0); }
  public static void AddWidth(FlatBufferBuilder builder, double width) { builder.AddDouble(18, width, 0.0); }
  public static void AddWidthUnit(FlatBufferBuilder builder, StringOffset widthUnitOffset) { builder.AddOffset(19, widthUnitOffset.Value, 0); }
  public static void AddCorrWayPoints(FlatBufferBuilder builder, VectorOffset corrWayPointsOffset) { builder.AddOffset(20, corrWayPointsOffset.Value, 0); }
  public static VectorOffset CreateCorrWayPointsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCorrWayPointsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCorrWayPointsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCorrWayPointsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCorrWayPointsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddOrbitAlignment(FlatBufferBuilder builder, StringOffset orbitAlignmentOffset) { builder.AddOffset(21, orbitAlignmentOffset.Value, 0); }
  public static void AddEffVDim(FlatBufferBuilder builder, StringOffset effVDimOffset) { builder.AddOffset(22, effVDimOffset.Value, 0); }
  public static void AddAirspaceTimePeriod(FlatBufferBuilder builder, VectorOffset airspaceTimePeriodOffset) { builder.AddOffset(23, airspaceTimePeriodOffset.Value, 0); }
  public static VectorOffset CreateAirspaceTimePeriodVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAirspaceTimePeriodVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAirspaceTimePeriodVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAirspaceTimePeriodVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAirspaceTimePeriodVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddAirspaceControlPoint(FlatBufferBuilder builder, VectorOffset airspaceControlPointOffset) { builder.AddOffset(24, airspaceControlPointOffset.Value, 0); }
  public static VectorOffset CreateAirspaceControlPointVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAirspaceControlPointVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAirspaceControlPointVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAirspaceControlPointVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAirspaceControlPointVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCtrlAuth(FlatBufferBuilder builder, StringOffset ctrlAuthOffset) { builder.AddOffset(25, ctrlAuthOffset.Value, 0); }
  public static void AddCtrlAuthFreqs(FlatBufferBuilder builder, VectorOffset ctrlAuthFreqsOffset) { builder.AddOffset(26, ctrlAuthFreqsOffset.Value, 0); }
  public static VectorOffset CreateCtrlAuthFreqsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCtrlAuthFreqsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCtrlAuthFreqsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCtrlAuthFreqsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCtrlAuthFreqsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGenTextInd(FlatBufferBuilder builder, StringOffset genTextIndOffset) { builder.AddOffset(27, genTextIndOffset.Value, 0); }
  public static void AddFreeText(FlatBufferBuilder builder, StringOffset freeTextOffset) { builder.AddOffset(28, freeTextOffset.Value, 0); }
  public static Offset<AirspaceControlMeans_Full> EndAirspaceControlMeans_Full(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<AirspaceControlMeans_Full>(o);
  }
  public static void FinishAirspaceControlMeans_FullBuffer(FlatBufferBuilder builder, Offset<AirspaceControlMeans_Full> offset) { builder.Finish(offset.Value, "AIRS"); }
  public static void FinishSizePrefixedAirspaceControlMeans_FullBuffer(FlatBufferBuilder builder, Offset<AirspaceControlMeans_Full> offset) { builder.FinishSizePrefixed(offset.Value, "AIRS"); }
  public AirspaceControlMeans_FullT UnPack() {
    var _o = new AirspaceControlMeans_FullT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(AirspaceControlMeans_FullT _o) {
    _o.CmType = this.CmType;
    _o.CmId = this.CmId;
    _o.CmShape = this.CmShape;
    _o.Usage = this.Usage;
    _o.Link16Id = this.Link16Id;
    _o.TransAltitude = this.TransAltitude;
    _o.GeoDatumAlt = this.GeoDatumAlt;
    _o.Coord0 = this.Coord0;
    _o.Coord1 = this.Coord1;
    _o.Bearing0 = this.Bearing0;
    _o.Bearing1 = this.Bearing1;
    _o.RadMag0 = this.RadMag0;
    _o.RadMag1 = this.RadMag1;
    _o.RadMagUnit = this.RadMagUnit;
    _o.PolyCoord = new List<string>();
    for (var _j = 0; _j < this.PolyCoordLength; ++_j) {_o.PolyCoord.Add(this.PolyCoord(_j));}
    _o.TrackLeg = this.TrackLeg;
    _o.WidthLeft = this.WidthLeft;
    _o.WidthRight = this.WidthRight;
    _o.Width = this.Width;
    _o.WidthUnit = this.WidthUnit;
    _o.CorrWayPoints = new List<string>();
    for (var _j = 0; _j < this.CorrWayPointsLength; ++_j) {_o.CorrWayPoints.Add(this.CorrWayPoints(_j));}
    _o.OrbitAlignment = this.OrbitAlignment;
    _o.EffVDim = this.EffVDim;
    _o.AirspaceTimePeriod = new List<string>();
    for (var _j = 0; _j < this.AirspaceTimePeriodLength; ++_j) {_o.AirspaceTimePeriod.Add(this.AirspaceTimePeriod(_j));}
    _o.AirspaceControlPoint = new List<string>();
    for (var _j = 0; _j < this.AirspaceControlPointLength; ++_j) {_o.AirspaceControlPoint.Add(this.AirspaceControlPoint(_j));}
    _o.CtrlAuth = this.CtrlAuth;
    _o.CtrlAuthFreqs = new List<string>();
    for (var _j = 0; _j < this.CtrlAuthFreqsLength; ++_j) {_o.CtrlAuthFreqs.Add(this.CtrlAuthFreqs(_j));}
    _o.GenTextInd = this.GenTextInd;
    _o.FreeText = this.FreeText;
  }
  public static Offset<AirspaceControlMeans_Full> Pack(FlatBufferBuilder builder, AirspaceControlMeans_FullT _o) {
    if (_o == null) return default(Offset<AirspaceControlMeans_Full>);
    var _cmType = _o.CmType == null ? default(StringOffset) : builder.CreateString(_o.CmType);
    var _cmId = _o.CmId == null ? default(StringOffset) : builder.CreateString(_o.CmId);
    var _usage = _o.Usage == null ? default(StringOffset) : builder.CreateString(_o.Usage);
    var _link16Id = _o.Link16Id == null ? default(StringOffset) : builder.CreateString(_o.Link16Id);
    var _transAltitude = _o.TransAltitude == null ? default(StringOffset) : builder.CreateString(_o.TransAltitude);
    var _geoDatumAlt = _o.GeoDatumAlt == null ? default(StringOffset) : builder.CreateString(_o.GeoDatumAlt);
    var _coord0 = _o.Coord0 == null ? default(StringOffset) : builder.CreateString(_o.Coord0);
    var _coord1 = _o.Coord1 == null ? default(StringOffset) : builder.CreateString(_o.Coord1);
    var _radMagUnit = _o.RadMagUnit == null ? default(StringOffset) : builder.CreateString(_o.RadMagUnit);
    var _polyCoord = default(VectorOffset);
    if (_o.PolyCoord != null) {
      var __polyCoord = new StringOffset[_o.PolyCoord.Count];
      for (var _j = 0; _j < __polyCoord.Length; ++_j) { __polyCoord[_j] = builder.CreateString(_o.PolyCoord[_j]); }
      _polyCoord = CreatePolyCoordVector(builder, __polyCoord);
    }
    var _widthUnit = _o.WidthUnit == null ? default(StringOffset) : builder.CreateString(_o.WidthUnit);
    var _corrWayPoints = default(VectorOffset);
    if (_o.CorrWayPoints != null) {
      var __corrWayPoints = new StringOffset[_o.CorrWayPoints.Count];
      for (var _j = 0; _j < __corrWayPoints.Length; ++_j) { __corrWayPoints[_j] = builder.CreateString(_o.CorrWayPoints[_j]); }
      _corrWayPoints = CreateCorrWayPointsVector(builder, __corrWayPoints);
    }
    var _orbitAlignment = _o.OrbitAlignment == null ? default(StringOffset) : builder.CreateString(_o.OrbitAlignment);
    var _effVDim = _o.EffVDim == null ? default(StringOffset) : builder.CreateString(_o.EffVDim);
    var _airspaceTimePeriod = default(VectorOffset);
    if (_o.AirspaceTimePeriod != null) {
      var __airspaceTimePeriod = new StringOffset[_o.AirspaceTimePeriod.Count];
      for (var _j = 0; _j < __airspaceTimePeriod.Length; ++_j) { __airspaceTimePeriod[_j] = builder.CreateString(_o.AirspaceTimePeriod[_j]); }
      _airspaceTimePeriod = CreateAirspaceTimePeriodVector(builder, __airspaceTimePeriod);
    }
    var _airspaceControlPoint = default(VectorOffset);
    if (_o.AirspaceControlPoint != null) {
      var __airspaceControlPoint = new StringOffset[_o.AirspaceControlPoint.Count];
      for (var _j = 0; _j < __airspaceControlPoint.Length; ++_j) { __airspaceControlPoint[_j] = builder.CreateString(_o.AirspaceControlPoint[_j]); }
      _airspaceControlPoint = CreateAirspaceControlPointVector(builder, __airspaceControlPoint);
    }
    var _ctrlAuth = _o.CtrlAuth == null ? default(StringOffset) : builder.CreateString(_o.CtrlAuth);
    var _ctrlAuthFreqs = default(VectorOffset);
    if (_o.CtrlAuthFreqs != null) {
      var __ctrlAuthFreqs = new StringOffset[_o.CtrlAuthFreqs.Count];
      for (var _j = 0; _j < __ctrlAuthFreqs.Length; ++_j) { __ctrlAuthFreqs[_j] = builder.CreateString(_o.CtrlAuthFreqs[_j]); }
      _ctrlAuthFreqs = CreateCtrlAuthFreqsVector(builder, __ctrlAuthFreqs);
    }
    var _genTextInd = _o.GenTextInd == null ? default(StringOffset) : builder.CreateString(_o.GenTextInd);
    var _freeText = _o.FreeText == null ? default(StringOffset) : builder.CreateString(_o.FreeText);
    return CreateAirspaceControlMeans_Full(
      builder,
      _cmType,
      _cmId,
      _o.CmShape,
      _usage,
      _link16Id,
      _transAltitude,
      _geoDatumAlt,
      _coord0,
      _coord1,
      _o.Bearing0,
      _o.Bearing1,
      _o.RadMag0,
      _o.RadMag1,
      _radMagUnit,
      _polyCoord,
      _o.TrackLeg,
      _o.WidthLeft,
      _o.WidthRight,
      _o.Width,
      _widthUnit,
      _corrWayPoints,
      _orbitAlignment,
      _effVDim,
      _airspaceTimePeriod,
      _airspaceControlPoint,
      _ctrlAuth,
      _ctrlAuthFreqs,
      _genTextInd,
      _freeText);
  }
}

public class AirspaceControlMeans_FullT
{
  public string CmType { get; set; }
  public string CmId { get; set; }
  public AirspaceControlMeans_Full_cmShape_Enum CmShape { get; set; }
  public string Usage { get; set; }
  public string Link16Id { get; set; }
  public string TransAltitude { get; set; }
  public string GeoDatumAlt { get; set; }
  public string Coord0 { get; set; }
  public string Coord1 { get; set; }
  public double Bearing0 { get; set; }
  public double Bearing1 { get; set; }
  public double RadMag0 { get; set; }
  public double RadMag1 { get; set; }
  public string RadMagUnit { get; set; }
  public List<string> PolyCoord { get; set; }
  public int TrackLeg { get; set; }
  public double WidthLeft { get; set; }
  public double WidthRight { get; set; }
  public double Width { get; set; }
  public string WidthUnit { get; set; }
  public List<string> CorrWayPoints { get; set; }
  public string OrbitAlignment { get; set; }
  public string EffVDim { get; set; }
  public List<string> AirspaceTimePeriod { get; set; }
  public List<string> AirspaceControlPoint { get; set; }
  public string CtrlAuth { get; set; }
  public List<string> CtrlAuthFreqs { get; set; }
  public string GenTextInd { get; set; }
  public string FreeText { get; set; }

  public AirspaceControlMeans_FullT() {
    this.CmType = null;
    this.CmId = null;
    this.CmShape = AirspaceControlMeans_Full_cmShape_Enum.POLYARC;
    this.Usage = null;
    this.Link16Id = null;
    this.TransAltitude = null;
    this.GeoDatumAlt = null;
    this.Coord0 = null;
    this.Coord1 = null;
    this.Bearing0 = 0.0;
    this.Bearing1 = 0.0;
    this.RadMag0 = 0.0;
    this.RadMag1 = 0.0;
    this.RadMagUnit = null;
    this.PolyCoord = null;
    this.TrackLeg = 0;
    this.WidthLeft = 0.0;
    this.WidthRight = 0.0;
    this.Width = 0.0;
    this.WidthUnit = null;
    this.CorrWayPoints = null;
    this.OrbitAlignment = null;
    this.EffVDim = null;
    this.AirspaceTimePeriod = null;
    this.AirspaceControlPoint = null;
    this.CtrlAuth = null;
    this.CtrlAuthFreqs = null;
    this.GenTextInd = null;
    this.FreeText = null;
  }
  public static AirspaceControlMeans_FullT DeserializeFromBinary(byte[] fbBuffer) {
    return AirspaceControlMeans_Full.GetRootAsAirspaceControlMeans_Full(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    AirspaceControlMeans_Full.FinishAirspaceControlMeans_FullBuffer(fbb, AirspaceControlMeans_Full.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class AirspaceControlMeans_FullVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*CmType*/, false)
      && verifier.VerifyString(tablePos, 6 /*CmId*/, false)
      && verifier.VerifyField(tablePos, 8 /*CmShape*/, 1 /*AirspaceControlMeans_Full_cmShape_Enum*/, 1, false)
      && verifier.VerifyString(tablePos, 10 /*Usage*/, false)
      && verifier.VerifyString(tablePos, 12 /*Link16Id*/, false)
      && verifier.VerifyString(tablePos, 14 /*TransAltitude*/, false)
      && verifier.VerifyString(tablePos, 16 /*GeoDatumAlt*/, false)
      && verifier.VerifyString(tablePos, 18 /*Coord0*/, false)
      && verifier.VerifyString(tablePos, 20 /*Coord1*/, false)
      && verifier.VerifyField(tablePos, 22 /*Bearing0*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 24 /*Bearing1*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 26 /*RadMag0*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 28 /*RadMag1*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 30 /*RadMagUnit*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 32 /*PolyCoord*/, false)
      && verifier.VerifyField(tablePos, 34 /*TrackLeg*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 36 /*WidthLeft*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 38 /*WidthRight*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 40 /*Width*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 42 /*WidthUnit*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 44 /*CorrWayPoints*/, false)
      && verifier.VerifyString(tablePos, 46 /*OrbitAlignment*/, false)
      && verifier.VerifyString(tablePos, 48 /*EffVDim*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 50 /*AirspaceTimePeriod*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 52 /*AirspaceControlPoint*/, false)
      && verifier.VerifyString(tablePos, 54 /*CtrlAuth*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 56 /*CtrlAuthFreqs*/, false)
      && verifier.VerifyString(tablePos, 58 /*GenTextInd*/, false)
      && verifier.VerifyString(tablePos, 60 /*FreeText*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
