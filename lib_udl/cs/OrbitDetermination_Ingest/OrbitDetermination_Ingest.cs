// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// Model representation of orbit determination algorithm results describing General Perturbations or Special Perturbations orbital updates.
public struct OrbitDetermination_Ingest : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static OrbitDetermination_Ingest GetRootAsOrbitDetermination_Ingest(ByteBuffer _bb) { return GetRootAsOrbitDetermination_Ingest(_bb, new OrbitDetermination_Ingest()); }
  public static OrbitDetermination_Ingest GetRootAsOrbitDetermination_Ingest(ByteBuffer _bb, OrbitDetermination_Ingest obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool OrbitDetermination_IngestBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "ORBI"); }
  public static bool VerifyOrbitDetermination_Ingest(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("ORBI", false, OrbitDetermination_IngestVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public OrbitDetermination_Ingest __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string Id { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetIdBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetIdArray() { return __p.__vector_as_array<byte>(4); }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  public string ClassificationMarking { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetClassificationMarkingBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetClassificationMarkingBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetClassificationMarkingArray() { return __p.__vector_as_array<byte>(6); }
  /// Start time for OD solution in ISO 8601 UTC datetime format, with microsecond precision.
  /// Example: /// Example: 2023-08-28T11:20:21.247192Z
  /// Constraints: No constraints specified.
  public string StartTime { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetStartTimeBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetStartTimeBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetStartTimeArray() { return __p.__vector_as_array<byte>(8); }
  /// End time for OD solution in ISO 8601 UTC datetime format, with microsecond precision.
  /// Example: /// Example: 2023-08-28T15:20:21.247192Z
  /// Constraints: No constraints specified.
  public string EndTime { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEndTimeBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetEndTimeBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetEndTimeArray() { return __p.__vector_as_array<byte>(10); }
  /// Unique identifier of the target satellite on-orbit object. This ID can be used to obtain additional information on an OnOrbit object using the 'get by ID' operation (e.g. /udl/onorbit/{id}). For example, the OnOrbit with idOnOrbit = 25544 would be queried as /udl/onorbit/25544.
  /// Example: /// Example: 54741
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string IdOnOrbit { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdOnOrbitBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetIdOnOrbitBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetIdOnOrbitArray() { return __p.__vector_as_array<byte>(12); }
  /// Optional identifier provided by the OD source to indicate the target on-orbit object of this OD solution. This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string OrigObjectId { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOrigObjectIdBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetOrigObjectIdBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetOrigObjectIdArray() { return __p.__vector_as_array<byte>(14); }
  /// Satellite/Catalog number of the target on-orbit object.
  /// Example: /// Example: 54741
  /// Constraints: No constraints specified.
  public int SatNo { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Identifier of the element set used to seed this OD solution. This ID can be used to obtain additional information on an Elset object using the 'get by ID' operation (e.g. /udl/elset/{id}). For example, the Elset with idElset = abc would be queried as /udl/elset/abc.
  /// Example: /// Example: 80e544b7-6a17-4554-8abf-7301e98f8e5d
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string AprioriIdElset { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAprioriIdElsetBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetAprioriIdElsetBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetAprioriIdElsetArray() { return __p.__vector_as_array<byte>(18); }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  public string AprioriElset { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAprioriElsetBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetAprioriElsetBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetAprioriElsetArray() { return __p.__vector_as_array<byte>(20); }
  /// Identifier of the state vector used to seed this OD solution. This ID can be used to obtain additional information on a StateVector object using the 'get by ID' operation (e.g. /udl/statevector/{id}). For example, the StateVector with idStateVector = abc would be queried as /udl/statevector/abc.
  /// Example: /// Example: 6e291992-8ae3-4592-bb0f-055715bf4803
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string AprioriIdStateVector { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAprioriIdStateVectorBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetAprioriIdStateVectorBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetAprioriIdStateVectorArray() { return __p.__vector_as_array<byte>(22); }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  public string AprioriStateVector { get { int o = __p.__offset(24); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAprioriStateVectorBytes() { return __p.__vector_as_span<byte>(24, 1); }
#else
  public ArraySegment<byte>? GetAprioriStateVectorBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public byte[] GetAprioriStateVectorArray() { return __p.__vector_as_array<byte>(24); }
  /// Flag indicating whether this is an initial orbit determination.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool InitialOD { get { int o = __p.__offset(26); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The start of the time interval containing the time of the last accepted observation, in ISO 8601 UTC datetime format with microsecond precision. For an exact observation time, the lastObStart and lastObEnd are the same.
  /// Example: /// Example: 2023-08-28T11:20:21.247192Z
  /// Constraints: No constraints specified.
  public string LastObStart { get { int o = __p.__offset(28); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLastObStartBytes() { return __p.__vector_as_span<byte>(28, 1); }
#else
  public ArraySegment<byte>? GetLastObStartBytes() { return __p.__vector_as_arraysegment(28); }
#endif
  public byte[] GetLastObStartArray() { return __p.__vector_as_array<byte>(28); }
  /// The end of the time interval containing the time of the last accepted observation, in ISO 8601 UTC datetime format with microsecond precision. For an exact observation time, the lastObStart and lastObEnd are the same.
  /// Example: /// Example: 2023-08-28T11:20:21.247192Z
  /// Constraints: No constraints specified.
  public string LastObEnd { get { int o = __p.__offset(30); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLastObEndBytes() { return __p.__vector_as_span<byte>(30, 1); }
#else
  public ArraySegment<byte>? GetLastObEndBytes() { return __p.__vector_as_arraysegment(30); }
#endif
  public byte[] GetLastObEndArray() { return __p.__vector_as_array<byte>(30); }
  /// The time span used for the OD of the object, in days.
  /// Example: /// Example: 3.5
  /// Constraints: No constraints specified.
  public double TimeSpan { get { int o = __p.__offset(32); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Optional start time at which this OD solution is accurate, in ISO 8601 UTC datetime format with microsecond precision.
  /// Example: /// Example: 2023-08-28T11:20:21.247192Z
  /// Constraints: No constraints specified.
  public string EffectiveFrom { get { int o = __p.__offset(34); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEffectiveFromBytes() { return __p.__vector_as_span<byte>(34, 1); }
#else
  public ArraySegment<byte>? GetEffectiveFromBytes() { return __p.__vector_as_arraysegment(34); }
#endif
  public byte[] GetEffectiveFromArray() { return __p.__vector_as_array<byte>(34); }
  /// Optional end time at which this OD solution may no longer be accurate, in ISO 8601 UTC datetime format with microsecond precision.
  /// Example: /// Example: 2023-08-30T08:15:00.123456Z
  /// Constraints: No constraints specified.
  public string EffectiveUntil { get { int o = __p.__offset(36); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEffectiveUntilBytes() { return __p.__vector_as_span<byte>(36, 1); }
#else
  public ArraySegment<byte>? GetEffectiveUntilBytes() { return __p.__vector_as_arraysegment(36); }
#endif
  public byte[] GetEffectiveUntilArray() { return __p.__vector_as_array<byte>(36); }
  /// The Weighted Root Mean Squared (RMS) of the differential correction of the target object that produced this OD state. WRMS is a quality indicator of the OD update, with a value of 1.00 being optimal. WRMS applies to batch least squares (BLS) processes.
  /// Example: /// Example: 0.991
  /// Constraints: No constraints specified.
  public double Wrms { get { int o = __p.__offset(38); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The Weighted Root Mean Squared (RMS) of the differential correction from the previous overhead pass of the satellite. Provides a point of comparison for assessing changes in the quality of the OD solution between consecutive passes.
  /// Example: /// Example: 1.02
  /// Constraints: No constraints specified.
  public double PreviousWrms { get { int o = __p.__offset(40); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The Weighted Root Mean Squared (RMS) calculated for the first satellite pass in the observation span. Serves as the initial quality metric for the beginning of the observation period.
  /// Example: /// Example: 0.985
  /// Constraints: No constraints specified.
  public double FirstPassWrms { get { int o = __p.__offset(42); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Lowest Weighted Root Mean Squared (RMS) value achieved for any single satellite pass during the observation span, indicating the pass with the highest quality OD solution.
  /// Example: /// Example: 0.975
  /// Constraints: No constraints specified.
  public double BestPassWrms { get { int o = __p.__offset(44); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Error growth rate of the OD solution in kilometers per day.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double ErrorGrowthRate { get { int o = __p.__offset(46); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Model parameter value for energy dissipation rate (EDR) in watts per kilogram.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  public double Edr { get { int o = __p.__offset(48); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Orbit determination method used to produce this record (e.g. BLS, KF, UKF, etc.).
  /// Example: /// Example: BLS
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string Method { get { int o = __p.__offset(50); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMethodBytes() { return __p.__vector_as_span<byte>(50, 1); }
#else
  public ArraySegment<byte>? GetMethodBytes() { return __p.__vector_as_arraysegment(50); }
#endif
  public byte[] GetMethodArray() { return __p.__vector_as_array<byte>(50); }
  /// Source of orbit determination method used to produce this record (e.g. ASW, ACTRAC, FreeFlyer, GEODYNE, GDTS, etc.).
  /// Example: /// Example: ASW
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string MethodSource { get { int o = __p.__offset(52); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMethodSourceBytes() { return __p.__vector_as_span<byte>(52, 1); }
#else
  public ArraySegment<byte>? GetMethodSourceBytes() { return __p.__vector_as_arraysegment(52); }
#endif
  public byte[] GetMethodSourceArray() { return __p.__vector_as_array<byte>(52); }
  /// The fit span, in days, used in a Batch Least Squares (BLS) OD.
  /// Example: /// Example: 0.6
  /// Constraints: No constraints specified.
  public double FitSpan { get { int o = __p.__offset(54); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Flag indicating whether the ballistic coefficient was estimated during this OD solution.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool BallisticCoeffEst { get { int o = __p.__offset(56); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Model used to estimate the ballistic coefficient.
  /// Example: /// Example: GaussMarkov
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string BallisticCoeffModel { get { int o = __p.__offset(58); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBallisticCoeffModelBytes() { return __p.__vector_as_span<byte>(58, 1); }
#else
  public ArraySegment<byte>? GetBallisticCoeffModelBytes() { return __p.__vector_as_arraysegment(58); }
#endif
  public byte[] GetBallisticCoeffModelArray() { return __p.__vector_as_array<byte>(58); }
  /// Flag indicating whether the AGOM was estimated during this OD solution.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool AgomEst { get { int o = __p.__offset(60); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Model used to estimate the AGOM.
  /// Example: /// Example: RandomWalk
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string AgomModel { get { int o = __p.__offset(62); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAgomModelBytes() { return __p.__vector_as_span<byte>(62, 1); }
#else
  public ArraySegment<byte>? GetAgomModelBytes() { return __p.__vector_as_arraysegment(62); }
#endif
  public byte[] GetAgomModelArray() { return __p.__vector_as_array<byte>(62); }
  /// OD parameter value for the Root Mean Square (RMS) convergence criteria to successfully close the OD solution.
  /// Example: /// Example: 0.001
  /// Constraints: No constraints specified.
  public double RmsConvergenceCriteria { get { int o = __p.__offset(64); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The number of iterations taken for the algorithm to converge on an OD solution.
  /// Example: /// Example: 8
  /// Constraints: No constraints specified.
  public int NumIterations { get { int o = __p.__offset(66); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Array of UDL observation types (e.g. DOA, EO, RADAR, RF) of the observations that were accepted in this OD solution. See the associated acceptedObIds array for the records UUID(s), positionally corresponding to the record types in this array. The acceptedObTyps and acceptedObIds arrays must match in size.
  /// Example: /// Example: ['EO', 'RADAR']
  /// Constraints: No constraints specified.
  public string AcceptedObTyps(int j) { int o = __p.__offset(68); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int AcceptedObTypsLength { get { int o = __p.__offset(68); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Array of UDL data (observation) UUIDs that were accepted in this OD solution. See the associated acceptedObTyps array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
  /// Example: /// Example: ['EOOBSERVATION-ID1', 'RADAROBSERVATION-ID1']
  /// Constraints: No constraints specified.
  public string AcceptedObIds(int j) { int o = __p.__offset(70); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int AcceptedObIdsLength { get { int o = __p.__offset(70); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Array of UDL observation types (e.g. DOA, EO, RADAR, RF) of the observations that were rejected in this OD solution. See the associated rejectedObIds array for the records UUID(s), positionally corresponding to the record types in this array. The rejectedObTyps and rejectedObIds arrays must match in size.
  /// Example: /// Example: ['DOA', 'RF']
  /// Constraints: No constraints specified.
  public string RejectedObTyps(int j) { int o = __p.__offset(72); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int RejectedObTypsLength { get { int o = __p.__offset(72); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Array of UDL data (observation) UUIDs that were rejected in this OD solution. See the associated rejectedObTyps array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
  /// Example: /// Example: ['DIFFOFARRIVAL-ID2', 'RFOBSERVATION-ID2']
  /// Constraints: No constraints specified.
  public string RejectedObIds(int j) { int o = __p.__offset(74); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int RejectedObIdsLength { get { int o = __p.__offset(74); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Array of UDL UUIDs (idSensor) of the sensors that contributed observations in this OD solution.
  /// Example: /// Example: ['SENSOR-ID1', 'SENSOR-ID2']
  /// Constraints: No constraints specified.
  public string SensorIds(int j) { int o = __p.__offset(76); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int SensorIdsLength { get { int o = __p.__offset(76); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string CreatedAt { get { int o = __p.__offset(78); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedAtBytes() { return __p.__vector_as_span<byte>(78, 1); }
#else
  public ArraySegment<byte>? GetCreatedAtBytes() { return __p.__vector_as_arraysegment(78); }
#endif
  public byte[] GetCreatedAtArray() { return __p.__vector_as_array<byte>(78); }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string CreatedBy { get { int o = __p.__offset(80); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedByBytes() { return __p.__vector_as_span<byte>(80, 1); }
#else
  public ArraySegment<byte>? GetCreatedByBytes() { return __p.__vector_as_arraysegment(80); }
#endif
  public byte[] GetCreatedByArray() { return __p.__vector_as_array<byte>(80); }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string SourceDL { get { int o = __p.__offset(82); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceDLBytes() { return __p.__vector_as_span<byte>(82, 1); }
#else
  public ArraySegment<byte>? GetSourceDLBytes() { return __p.__vector_as_arraysegment(82); }
#endif
  public byte[] GetSourceDLArray() { return __p.__vector_as_array<byte>(82); }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string Source { get { int o = __p.__offset(84); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceBytes() { return __p.__vector_as_span<byte>(84, 1); }
#else
  public ArraySegment<byte>? GetSourceBytes() { return __p.__vector_as_arraysegment(84); }
#endif
  public byte[] GetSourceArray() { return __p.__vector_as_array<byte>(84); }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Origin { get { int o = __p.__offset(86); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOriginBytes() { return __p.__vector_as_span<byte>(86, 1); }
#else
  public ArraySegment<byte>? GetOriginBytes() { return __p.__vector_as_arraysegment(86); }
#endif
  public byte[] GetOriginArray() { return __p.__vector_as_array<byte>(86); }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string OrigNetwork { get { int o = __p.__offset(88); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOrigNetworkBytes() { return __p.__vector_as_span<byte>(88, 1); }
#else
  public ArraySegment<byte>? GetOrigNetworkBytes() { return __p.__vector_as_arraysegment(88); }
#endif
  public byte[] GetOrigNetworkArray() { return __p.__vector_as_array<byte>(88); }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  public OrbitDetermination_Ingest_dataMode_Enum DataMode { get { int o = __p.__offset(90); return o != 0 ? (OrbitDetermination_Ingest_dataMode_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : OrbitDetermination_Ingest_dataMode_Enum.REAL; } }

  public static Offset<OrbitDetermination_Ingest> CreateOrbitDetermination_Ingest(FlatBufferBuilder builder,
      StringOffset idOffset = default(StringOffset),
      StringOffset classificationMarkingOffset = default(StringOffset),
      StringOffset startTimeOffset = default(StringOffset),
      StringOffset endTimeOffset = default(StringOffset),
      StringOffset idOnOrbitOffset = default(StringOffset),
      StringOffset origObjectIdOffset = default(StringOffset),
      int satNo = 0,
      StringOffset aprioriIdElsetOffset = default(StringOffset),
      StringOffset aprioriElsetOffset = default(StringOffset),
      StringOffset aprioriIdStateVectorOffset = default(StringOffset),
      StringOffset aprioriStateVectorOffset = default(StringOffset),
      bool initialOD = false,
      StringOffset lastObStartOffset = default(StringOffset),
      StringOffset lastObEndOffset = default(StringOffset),
      double timeSpan = 0.0,
      StringOffset effectiveFromOffset = default(StringOffset),
      StringOffset effectiveUntilOffset = default(StringOffset),
      double wrms = 0.0,
      double previousWrms = 0.0,
      double firstPassWrms = 0.0,
      double bestPassWrms = 0.0,
      double errorGrowthRate = 0.0,
      double edr = 0.0,
      StringOffset methodOffset = default(StringOffset),
      StringOffset methodSourceOffset = default(StringOffset),
      double fitSpan = 0.0,
      bool ballisticCoeffEst = false,
      StringOffset ballisticCoeffModelOffset = default(StringOffset),
      bool agomEst = false,
      StringOffset agomModelOffset = default(StringOffset),
      double rmsConvergenceCriteria = 0.0,
      int numIterations = 0,
      VectorOffset acceptedObTypsOffset = default(VectorOffset),
      VectorOffset acceptedObIdsOffset = default(VectorOffset),
      VectorOffset rejectedObTypsOffset = default(VectorOffset),
      VectorOffset rejectedObIdsOffset = default(VectorOffset),
      VectorOffset sensorIdsOffset = default(VectorOffset),
      StringOffset createdAtOffset = default(StringOffset),
      StringOffset createdByOffset = default(StringOffset),
      StringOffset sourceDLOffset = default(StringOffset),
      StringOffset sourceOffset = default(StringOffset),
      StringOffset originOffset = default(StringOffset),
      StringOffset origNetworkOffset = default(StringOffset),
      OrbitDetermination_Ingest_dataMode_Enum dataMode = OrbitDetermination_Ingest_dataMode_Enum.REAL) {
    builder.StartTable(44);
    OrbitDetermination_Ingest.AddRmsConvergenceCriteria(builder, rmsConvergenceCriteria);
    OrbitDetermination_Ingest.AddFitSpan(builder, fitSpan);
    OrbitDetermination_Ingest.AddEdr(builder, edr);
    OrbitDetermination_Ingest.AddErrorGrowthRate(builder, errorGrowthRate);
    OrbitDetermination_Ingest.AddBestPassWrms(builder, bestPassWrms);
    OrbitDetermination_Ingest.AddFirstPassWrms(builder, firstPassWrms);
    OrbitDetermination_Ingest.AddPreviousWrms(builder, previousWrms);
    OrbitDetermination_Ingest.AddWrms(builder, wrms);
    OrbitDetermination_Ingest.AddTimeSpan(builder, timeSpan);
    OrbitDetermination_Ingest.AddOrigNetwork(builder, origNetworkOffset);
    OrbitDetermination_Ingest.AddOrigin(builder, originOffset);
    OrbitDetermination_Ingest.AddSource(builder, sourceOffset);
    OrbitDetermination_Ingest.AddSourceDL(builder, sourceDLOffset);
    OrbitDetermination_Ingest.AddCreatedBy(builder, createdByOffset);
    OrbitDetermination_Ingest.AddCreatedAt(builder, createdAtOffset);
    OrbitDetermination_Ingest.AddSensorIds(builder, sensorIdsOffset);
    OrbitDetermination_Ingest.AddRejectedObIds(builder, rejectedObIdsOffset);
    OrbitDetermination_Ingest.AddRejectedObTyps(builder, rejectedObTypsOffset);
    OrbitDetermination_Ingest.AddAcceptedObIds(builder, acceptedObIdsOffset);
    OrbitDetermination_Ingest.AddAcceptedObTyps(builder, acceptedObTypsOffset);
    OrbitDetermination_Ingest.AddNumIterations(builder, numIterations);
    OrbitDetermination_Ingest.AddAgomModel(builder, agomModelOffset);
    OrbitDetermination_Ingest.AddBallisticCoeffModel(builder, ballisticCoeffModelOffset);
    OrbitDetermination_Ingest.AddMethodSource(builder, methodSourceOffset);
    OrbitDetermination_Ingest.AddMethod(builder, methodOffset);
    OrbitDetermination_Ingest.AddEffectiveUntil(builder, effectiveUntilOffset);
    OrbitDetermination_Ingest.AddEffectiveFrom(builder, effectiveFromOffset);
    OrbitDetermination_Ingest.AddLastObEnd(builder, lastObEndOffset);
    OrbitDetermination_Ingest.AddLastObStart(builder, lastObStartOffset);
    OrbitDetermination_Ingest.AddAprioriStateVector(builder, aprioriStateVectorOffset);
    OrbitDetermination_Ingest.AddAprioriIdStateVector(builder, aprioriIdStateVectorOffset);
    OrbitDetermination_Ingest.AddAprioriElset(builder, aprioriElsetOffset);
    OrbitDetermination_Ingest.AddAprioriIdElset(builder, aprioriIdElsetOffset);
    OrbitDetermination_Ingest.AddSatNo(builder, satNo);
    OrbitDetermination_Ingest.AddOrigObjectId(builder, origObjectIdOffset);
    OrbitDetermination_Ingest.AddIdOnOrbit(builder, idOnOrbitOffset);
    OrbitDetermination_Ingest.AddEndTime(builder, endTimeOffset);
    OrbitDetermination_Ingest.AddStartTime(builder, startTimeOffset);
    OrbitDetermination_Ingest.AddClassificationMarking(builder, classificationMarkingOffset);
    OrbitDetermination_Ingest.AddId(builder, idOffset);
    OrbitDetermination_Ingest.AddDataMode(builder, dataMode);
    OrbitDetermination_Ingest.AddAgomEst(builder, agomEst);
    OrbitDetermination_Ingest.AddBallisticCoeffEst(builder, ballisticCoeffEst);
    OrbitDetermination_Ingest.AddInitialOD(builder, initialOD);
    return OrbitDetermination_Ingest.EndOrbitDetermination_Ingest(builder);
  }

  public static void StartOrbitDetermination_Ingest(FlatBufferBuilder builder) { builder.StartTable(44); }
  public static void AddId(FlatBufferBuilder builder, StringOffset idOffset) { builder.AddOffset(0, idOffset.Value, 0); }
  public static void AddClassificationMarking(FlatBufferBuilder builder, StringOffset classificationMarkingOffset) { builder.AddOffset(1, classificationMarkingOffset.Value, 0); }
  public static void AddStartTime(FlatBufferBuilder builder, StringOffset startTimeOffset) { builder.AddOffset(2, startTimeOffset.Value, 0); }
  public static void AddEndTime(FlatBufferBuilder builder, StringOffset endTimeOffset) { builder.AddOffset(3, endTimeOffset.Value, 0); }
  public static void AddIdOnOrbit(FlatBufferBuilder builder, StringOffset idOnOrbitOffset) { builder.AddOffset(4, idOnOrbitOffset.Value, 0); }
  public static void AddOrigObjectId(FlatBufferBuilder builder, StringOffset origObjectIdOffset) { builder.AddOffset(5, origObjectIdOffset.Value, 0); }
  public static void AddSatNo(FlatBufferBuilder builder, int satNo) { builder.AddInt(6, satNo, 0); }
  public static void AddAprioriIdElset(FlatBufferBuilder builder, StringOffset aprioriIdElsetOffset) { builder.AddOffset(7, aprioriIdElsetOffset.Value, 0); }
  public static void AddAprioriElset(FlatBufferBuilder builder, StringOffset aprioriElsetOffset) { builder.AddOffset(8, aprioriElsetOffset.Value, 0); }
  public static void AddAprioriIdStateVector(FlatBufferBuilder builder, StringOffset aprioriIdStateVectorOffset) { builder.AddOffset(9, aprioriIdStateVectorOffset.Value, 0); }
  public static void AddAprioriStateVector(FlatBufferBuilder builder, StringOffset aprioriStateVectorOffset) { builder.AddOffset(10, aprioriStateVectorOffset.Value, 0); }
  public static void AddInitialOD(FlatBufferBuilder builder, bool initialOD) { builder.AddBool(11, initialOD, false); }
  public static void AddLastObStart(FlatBufferBuilder builder, StringOffset lastObStartOffset) { builder.AddOffset(12, lastObStartOffset.Value, 0); }
  public static void AddLastObEnd(FlatBufferBuilder builder, StringOffset lastObEndOffset) { builder.AddOffset(13, lastObEndOffset.Value, 0); }
  public static void AddTimeSpan(FlatBufferBuilder builder, double timeSpan) { builder.AddDouble(14, timeSpan, 0.0); }
  public static void AddEffectiveFrom(FlatBufferBuilder builder, StringOffset effectiveFromOffset) { builder.AddOffset(15, effectiveFromOffset.Value, 0); }
  public static void AddEffectiveUntil(FlatBufferBuilder builder, StringOffset effectiveUntilOffset) { builder.AddOffset(16, effectiveUntilOffset.Value, 0); }
  public static void AddWrms(FlatBufferBuilder builder, double wrms) { builder.AddDouble(17, wrms, 0.0); }
  public static void AddPreviousWrms(FlatBufferBuilder builder, double previousWrms) { builder.AddDouble(18, previousWrms, 0.0); }
  public static void AddFirstPassWrms(FlatBufferBuilder builder, double firstPassWrms) { builder.AddDouble(19, firstPassWrms, 0.0); }
  public static void AddBestPassWrms(FlatBufferBuilder builder, double bestPassWrms) { builder.AddDouble(20, bestPassWrms, 0.0); }
  public static void AddErrorGrowthRate(FlatBufferBuilder builder, double errorGrowthRate) { builder.AddDouble(21, errorGrowthRate, 0.0); }
  public static void AddEdr(FlatBufferBuilder builder, double edr) { builder.AddDouble(22, edr, 0.0); }
  public static void AddMethod(FlatBufferBuilder builder, StringOffset methodOffset) { builder.AddOffset(23, methodOffset.Value, 0); }
  public static void AddMethodSource(FlatBufferBuilder builder, StringOffset methodSourceOffset) { builder.AddOffset(24, methodSourceOffset.Value, 0); }
  public static void AddFitSpan(FlatBufferBuilder builder, double fitSpan) { builder.AddDouble(25, fitSpan, 0.0); }
  public static void AddBallisticCoeffEst(FlatBufferBuilder builder, bool ballisticCoeffEst) { builder.AddBool(26, ballisticCoeffEst, false); }
  public static void AddBallisticCoeffModel(FlatBufferBuilder builder, StringOffset ballisticCoeffModelOffset) { builder.AddOffset(27, ballisticCoeffModelOffset.Value, 0); }
  public static void AddAgomEst(FlatBufferBuilder builder, bool agomEst) { builder.AddBool(28, agomEst, false); }
  public static void AddAgomModel(FlatBufferBuilder builder, StringOffset agomModelOffset) { builder.AddOffset(29, agomModelOffset.Value, 0); }
  public static void AddRmsConvergenceCriteria(FlatBufferBuilder builder, double rmsConvergenceCriteria) { builder.AddDouble(30, rmsConvergenceCriteria, 0.0); }
  public static void AddNumIterations(FlatBufferBuilder builder, int numIterations) { builder.AddInt(31, numIterations, 0); }
  public static void AddAcceptedObTyps(FlatBufferBuilder builder, VectorOffset acceptedObTypsOffset) { builder.AddOffset(32, acceptedObTypsOffset.Value, 0); }
  public static VectorOffset CreateAcceptedObTypsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAcceptedObTypsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAcceptedObTypsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAcceptedObTypsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAcceptedObTypsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddAcceptedObIds(FlatBufferBuilder builder, VectorOffset acceptedObIdsOffset) { builder.AddOffset(33, acceptedObIdsOffset.Value, 0); }
  public static VectorOffset CreateAcceptedObIdsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAcceptedObIdsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAcceptedObIdsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAcceptedObIdsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAcceptedObIdsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddRejectedObTyps(FlatBufferBuilder builder, VectorOffset rejectedObTypsOffset) { builder.AddOffset(34, rejectedObTypsOffset.Value, 0); }
  public static VectorOffset CreateRejectedObTypsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateRejectedObTypsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRejectedObTypsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRejectedObTypsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRejectedObTypsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddRejectedObIds(FlatBufferBuilder builder, VectorOffset rejectedObIdsOffset) { builder.AddOffset(35, rejectedObIdsOffset.Value, 0); }
  public static VectorOffset CreateRejectedObIdsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateRejectedObIdsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRejectedObIdsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRejectedObIdsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRejectedObIdsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSensorIds(FlatBufferBuilder builder, VectorOffset sensorIdsOffset) { builder.AddOffset(36, sensorIdsOffset.Value, 0); }
  public static VectorOffset CreateSensorIdsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSensorIdsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSensorIdsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSensorIdsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSensorIdsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCreatedAt(FlatBufferBuilder builder, StringOffset createdAtOffset) { builder.AddOffset(37, createdAtOffset.Value, 0); }
  public static void AddCreatedBy(FlatBufferBuilder builder, StringOffset createdByOffset) { builder.AddOffset(38, createdByOffset.Value, 0); }
  public static void AddSourceDL(FlatBufferBuilder builder, StringOffset sourceDLOffset) { builder.AddOffset(39, sourceDLOffset.Value, 0); }
  public static void AddSource(FlatBufferBuilder builder, StringOffset sourceOffset) { builder.AddOffset(40, sourceOffset.Value, 0); }
  public static void AddOrigin(FlatBufferBuilder builder, StringOffset originOffset) { builder.AddOffset(41, originOffset.Value, 0); }
  public static void AddOrigNetwork(FlatBufferBuilder builder, StringOffset origNetworkOffset) { builder.AddOffset(42, origNetworkOffset.Value, 0); }
  public static void AddDataMode(FlatBufferBuilder builder, OrbitDetermination_Ingest_dataMode_Enum dataMode) { builder.AddSbyte(43, (sbyte)dataMode, 0); }
  public static Offset<OrbitDetermination_Ingest> EndOrbitDetermination_Ingest(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<OrbitDetermination_Ingest>(o);
  }
  public static void FinishOrbitDetermination_IngestBuffer(FlatBufferBuilder builder, Offset<OrbitDetermination_Ingest> offset) { builder.Finish(offset.Value, "ORBI"); }
  public static void FinishSizePrefixedOrbitDetermination_IngestBuffer(FlatBufferBuilder builder, Offset<OrbitDetermination_Ingest> offset) { builder.FinishSizePrefixed(offset.Value, "ORBI"); }
  public OrbitDetermination_IngestT UnPack() {
    var _o = new OrbitDetermination_IngestT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(OrbitDetermination_IngestT _o) {
    _o.Id = this.Id;
    _o.ClassificationMarking = this.ClassificationMarking;
    _o.StartTime = this.StartTime;
    _o.EndTime = this.EndTime;
    _o.IdOnOrbit = this.IdOnOrbit;
    _o.OrigObjectId = this.OrigObjectId;
    _o.SatNo = this.SatNo;
    _o.AprioriIdElset = this.AprioriIdElset;
    _o.AprioriElset = this.AprioriElset;
    _o.AprioriIdStateVector = this.AprioriIdStateVector;
    _o.AprioriStateVector = this.AprioriStateVector;
    _o.InitialOD = this.InitialOD;
    _o.LastObStart = this.LastObStart;
    _o.LastObEnd = this.LastObEnd;
    _o.TimeSpan = this.TimeSpan;
    _o.EffectiveFrom = this.EffectiveFrom;
    _o.EffectiveUntil = this.EffectiveUntil;
    _o.Wrms = this.Wrms;
    _o.PreviousWrms = this.PreviousWrms;
    _o.FirstPassWrms = this.FirstPassWrms;
    _o.BestPassWrms = this.BestPassWrms;
    _o.ErrorGrowthRate = this.ErrorGrowthRate;
    _o.Edr = this.Edr;
    _o.Method = this.Method;
    _o.MethodSource = this.MethodSource;
    _o.FitSpan = this.FitSpan;
    _o.BallisticCoeffEst = this.BallisticCoeffEst;
    _o.BallisticCoeffModel = this.BallisticCoeffModel;
    _o.AgomEst = this.AgomEst;
    _o.AgomModel = this.AgomModel;
    _o.RmsConvergenceCriteria = this.RmsConvergenceCriteria;
    _o.NumIterations = this.NumIterations;
    _o.AcceptedObTyps = new List<string>();
    for (var _j = 0; _j < this.AcceptedObTypsLength; ++_j) {_o.AcceptedObTyps.Add(this.AcceptedObTyps(_j));}
    _o.AcceptedObIds = new List<string>();
    for (var _j = 0; _j < this.AcceptedObIdsLength; ++_j) {_o.AcceptedObIds.Add(this.AcceptedObIds(_j));}
    _o.RejectedObTyps = new List<string>();
    for (var _j = 0; _j < this.RejectedObTypsLength; ++_j) {_o.RejectedObTyps.Add(this.RejectedObTyps(_j));}
    _o.RejectedObIds = new List<string>();
    for (var _j = 0; _j < this.RejectedObIdsLength; ++_j) {_o.RejectedObIds.Add(this.RejectedObIds(_j));}
    _o.SensorIds = new List<string>();
    for (var _j = 0; _j < this.SensorIdsLength; ++_j) {_o.SensorIds.Add(this.SensorIds(_j));}
    _o.CreatedAt = this.CreatedAt;
    _o.CreatedBy = this.CreatedBy;
    _o.SourceDL = this.SourceDL;
    _o.Source = this.Source;
    _o.Origin = this.Origin;
    _o.OrigNetwork = this.OrigNetwork;
    _o.DataMode = this.DataMode;
  }
  public static Offset<OrbitDetermination_Ingest> Pack(FlatBufferBuilder builder, OrbitDetermination_IngestT _o) {
    if (_o == null) return default(Offset<OrbitDetermination_Ingest>);
    var _id = _o.Id == null ? default(StringOffset) : builder.CreateString(_o.Id);
    var _classificationMarking = _o.ClassificationMarking == null ? default(StringOffset) : builder.CreateString(_o.ClassificationMarking);
    var _startTime = _o.StartTime == null ? default(StringOffset) : builder.CreateString(_o.StartTime);
    var _endTime = _o.EndTime == null ? default(StringOffset) : builder.CreateString(_o.EndTime);
    var _idOnOrbit = _o.IdOnOrbit == null ? default(StringOffset) : builder.CreateString(_o.IdOnOrbit);
    var _origObjectId = _o.OrigObjectId == null ? default(StringOffset) : builder.CreateString(_o.OrigObjectId);
    var _aprioriIdElset = _o.AprioriIdElset == null ? default(StringOffset) : builder.CreateString(_o.AprioriIdElset);
    var _aprioriElset = _o.AprioriElset == null ? default(StringOffset) : builder.CreateString(_o.AprioriElset);
    var _aprioriIdStateVector = _o.AprioriIdStateVector == null ? default(StringOffset) : builder.CreateString(_o.AprioriIdStateVector);
    var _aprioriStateVector = _o.AprioriStateVector == null ? default(StringOffset) : builder.CreateString(_o.AprioriStateVector);
    var _lastObStart = _o.LastObStart == null ? default(StringOffset) : builder.CreateString(_o.LastObStart);
    var _lastObEnd = _o.LastObEnd == null ? default(StringOffset) : builder.CreateString(_o.LastObEnd);
    var _effectiveFrom = _o.EffectiveFrom == null ? default(StringOffset) : builder.CreateString(_o.EffectiveFrom);
    var _effectiveUntil = _o.EffectiveUntil == null ? default(StringOffset) : builder.CreateString(_o.EffectiveUntil);
    var _method = _o.Method == null ? default(StringOffset) : builder.CreateString(_o.Method);
    var _methodSource = _o.MethodSource == null ? default(StringOffset) : builder.CreateString(_o.MethodSource);
    var _ballisticCoeffModel = _o.BallisticCoeffModel == null ? default(StringOffset) : builder.CreateString(_o.BallisticCoeffModel);
    var _agomModel = _o.AgomModel == null ? default(StringOffset) : builder.CreateString(_o.AgomModel);
    var _acceptedObTyps = default(VectorOffset);
    if (_o.AcceptedObTyps != null) {
      var __acceptedObTyps = new StringOffset[_o.AcceptedObTyps.Count];
      for (var _j = 0; _j < __acceptedObTyps.Length; ++_j) { __acceptedObTyps[_j] = builder.CreateString(_o.AcceptedObTyps[_j]); }
      _acceptedObTyps = CreateAcceptedObTypsVector(builder, __acceptedObTyps);
    }
    var _acceptedObIds = default(VectorOffset);
    if (_o.AcceptedObIds != null) {
      var __acceptedObIds = new StringOffset[_o.AcceptedObIds.Count];
      for (var _j = 0; _j < __acceptedObIds.Length; ++_j) { __acceptedObIds[_j] = builder.CreateString(_o.AcceptedObIds[_j]); }
      _acceptedObIds = CreateAcceptedObIdsVector(builder, __acceptedObIds);
    }
    var _rejectedObTyps = default(VectorOffset);
    if (_o.RejectedObTyps != null) {
      var __rejectedObTyps = new StringOffset[_o.RejectedObTyps.Count];
      for (var _j = 0; _j < __rejectedObTyps.Length; ++_j) { __rejectedObTyps[_j] = builder.CreateString(_o.RejectedObTyps[_j]); }
      _rejectedObTyps = CreateRejectedObTypsVector(builder, __rejectedObTyps);
    }
    var _rejectedObIds = default(VectorOffset);
    if (_o.RejectedObIds != null) {
      var __rejectedObIds = new StringOffset[_o.RejectedObIds.Count];
      for (var _j = 0; _j < __rejectedObIds.Length; ++_j) { __rejectedObIds[_j] = builder.CreateString(_o.RejectedObIds[_j]); }
      _rejectedObIds = CreateRejectedObIdsVector(builder, __rejectedObIds);
    }
    var _sensorIds = default(VectorOffset);
    if (_o.SensorIds != null) {
      var __sensorIds = new StringOffset[_o.SensorIds.Count];
      for (var _j = 0; _j < __sensorIds.Length; ++_j) { __sensorIds[_j] = builder.CreateString(_o.SensorIds[_j]); }
      _sensorIds = CreateSensorIdsVector(builder, __sensorIds);
    }
    var _createdAt = _o.CreatedAt == null ? default(StringOffset) : builder.CreateString(_o.CreatedAt);
    var _createdBy = _o.CreatedBy == null ? default(StringOffset) : builder.CreateString(_o.CreatedBy);
    var _sourceDL = _o.SourceDL == null ? default(StringOffset) : builder.CreateString(_o.SourceDL);
    var _source = _o.Source == null ? default(StringOffset) : builder.CreateString(_o.Source);
    var _origin = _o.Origin == null ? default(StringOffset) : builder.CreateString(_o.Origin);
    var _origNetwork = _o.OrigNetwork == null ? default(StringOffset) : builder.CreateString(_o.OrigNetwork);
    return CreateOrbitDetermination_Ingest(
      builder,
      _id,
      _classificationMarking,
      _startTime,
      _endTime,
      _idOnOrbit,
      _origObjectId,
      _o.SatNo,
      _aprioriIdElset,
      _aprioriElset,
      _aprioriIdStateVector,
      _aprioriStateVector,
      _o.InitialOD,
      _lastObStart,
      _lastObEnd,
      _o.TimeSpan,
      _effectiveFrom,
      _effectiveUntil,
      _o.Wrms,
      _o.PreviousWrms,
      _o.FirstPassWrms,
      _o.BestPassWrms,
      _o.ErrorGrowthRate,
      _o.Edr,
      _method,
      _methodSource,
      _o.FitSpan,
      _o.BallisticCoeffEst,
      _ballisticCoeffModel,
      _o.AgomEst,
      _agomModel,
      _o.RmsConvergenceCriteria,
      _o.NumIterations,
      _acceptedObTyps,
      _acceptedObIds,
      _rejectedObTyps,
      _rejectedObIds,
      _sensorIds,
      _createdAt,
      _createdBy,
      _sourceDL,
      _source,
      _origin,
      _origNetwork,
      _o.DataMode);
  }
}

public class OrbitDetermination_IngestT
{
  public string Id { get; set; }
  public string ClassificationMarking { get; set; }
  public string StartTime { get; set; }
  public string EndTime { get; set; }
  public string IdOnOrbit { get; set; }
  public string OrigObjectId { get; set; }
  public int SatNo { get; set; }
  public string AprioriIdElset { get; set; }
  public string AprioriElset { get; set; }
  public string AprioriIdStateVector { get; set; }
  public string AprioriStateVector { get; set; }
  public bool InitialOD { get; set; }
  public string LastObStart { get; set; }
  public string LastObEnd { get; set; }
  public double TimeSpan { get; set; }
  public string EffectiveFrom { get; set; }
  public string EffectiveUntil { get; set; }
  public double Wrms { get; set; }
  public double PreviousWrms { get; set; }
  public double FirstPassWrms { get; set; }
  public double BestPassWrms { get; set; }
  public double ErrorGrowthRate { get; set; }
  public double Edr { get; set; }
  public string Method { get; set; }
  public string MethodSource { get; set; }
  public double FitSpan { get; set; }
  public bool BallisticCoeffEst { get; set; }
  public string BallisticCoeffModel { get; set; }
  public bool AgomEst { get; set; }
  public string AgomModel { get; set; }
  public double RmsConvergenceCriteria { get; set; }
  public int NumIterations { get; set; }
  public List<string> AcceptedObTyps { get; set; }
  public List<string> AcceptedObIds { get; set; }
  public List<string> RejectedObTyps { get; set; }
  public List<string> RejectedObIds { get; set; }
  public List<string> SensorIds { get; set; }
  public string CreatedAt { get; set; }
  public string CreatedBy { get; set; }
  public string SourceDL { get; set; }
  public string Source { get; set; }
  public string Origin { get; set; }
  public string OrigNetwork { get; set; }
  public OrbitDetermination_Ingest_dataMode_Enum DataMode { get; set; }

  public OrbitDetermination_IngestT() {
    this.Id = null;
    this.ClassificationMarking = null;
    this.StartTime = null;
    this.EndTime = null;
    this.IdOnOrbit = null;
    this.OrigObjectId = null;
    this.SatNo = 0;
    this.AprioriIdElset = null;
    this.AprioriElset = null;
    this.AprioriIdStateVector = null;
    this.AprioriStateVector = null;
    this.InitialOD = false;
    this.LastObStart = null;
    this.LastObEnd = null;
    this.TimeSpan = 0.0;
    this.EffectiveFrom = null;
    this.EffectiveUntil = null;
    this.Wrms = 0.0;
    this.PreviousWrms = 0.0;
    this.FirstPassWrms = 0.0;
    this.BestPassWrms = 0.0;
    this.ErrorGrowthRate = 0.0;
    this.Edr = 0.0;
    this.Method = null;
    this.MethodSource = null;
    this.FitSpan = 0.0;
    this.BallisticCoeffEst = false;
    this.BallisticCoeffModel = null;
    this.AgomEst = false;
    this.AgomModel = null;
    this.RmsConvergenceCriteria = 0.0;
    this.NumIterations = 0;
    this.AcceptedObTyps = null;
    this.AcceptedObIds = null;
    this.RejectedObTyps = null;
    this.RejectedObIds = null;
    this.SensorIds = null;
    this.CreatedAt = null;
    this.CreatedBy = null;
    this.SourceDL = null;
    this.Source = null;
    this.Origin = null;
    this.OrigNetwork = null;
    this.DataMode = OrbitDetermination_Ingest_dataMode_Enum.REAL;
  }
  public static OrbitDetermination_IngestT DeserializeFromBinary(byte[] fbBuffer) {
    return OrbitDetermination_Ingest.GetRootAsOrbitDetermination_Ingest(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    OrbitDetermination_Ingest.FinishOrbitDetermination_IngestBuffer(fbb, OrbitDetermination_Ingest.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class OrbitDetermination_IngestVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Id*/, false)
      && verifier.VerifyString(tablePos, 6 /*ClassificationMarking*/, false)
      && verifier.VerifyString(tablePos, 8 /*StartTime*/, false)
      && verifier.VerifyString(tablePos, 10 /*EndTime*/, false)
      && verifier.VerifyString(tablePos, 12 /*IdOnOrbit*/, false)
      && verifier.VerifyString(tablePos, 14 /*OrigObjectId*/, false)
      && verifier.VerifyField(tablePos, 16 /*SatNo*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 18 /*AprioriIdElset*/, false)
      && verifier.VerifyString(tablePos, 20 /*AprioriElset*/, false)
      && verifier.VerifyString(tablePos, 22 /*AprioriIdStateVector*/, false)
      && verifier.VerifyString(tablePos, 24 /*AprioriStateVector*/, false)
      && verifier.VerifyField(tablePos, 26 /*InitialOD*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 28 /*LastObStart*/, false)
      && verifier.VerifyString(tablePos, 30 /*LastObEnd*/, false)
      && verifier.VerifyField(tablePos, 32 /*TimeSpan*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 34 /*EffectiveFrom*/, false)
      && verifier.VerifyString(tablePos, 36 /*EffectiveUntil*/, false)
      && verifier.VerifyField(tablePos, 38 /*Wrms*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 40 /*PreviousWrms*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 42 /*FirstPassWrms*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 44 /*BestPassWrms*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 46 /*ErrorGrowthRate*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 48 /*Edr*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 50 /*Method*/, false)
      && verifier.VerifyString(tablePos, 52 /*MethodSource*/, false)
      && verifier.VerifyField(tablePos, 54 /*FitSpan*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 56 /*BallisticCoeffEst*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 58 /*BallisticCoeffModel*/, false)
      && verifier.VerifyField(tablePos, 60 /*AgomEst*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 62 /*AgomModel*/, false)
      && verifier.VerifyField(tablePos, 64 /*RmsConvergenceCriteria*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 66 /*NumIterations*/, 4 /*int*/, 4, false)
      && verifier.VerifyVectorOfStrings(tablePos, 68 /*AcceptedObTyps*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 70 /*AcceptedObIds*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 72 /*RejectedObTyps*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 74 /*RejectedObIds*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 76 /*SensorIds*/, false)
      && verifier.VerifyString(tablePos, 78 /*CreatedAt*/, false)
      && verifier.VerifyString(tablePos, 80 /*CreatedBy*/, false)
      && verifier.VerifyString(tablePos, 82 /*SourceDL*/, false)
      && verifier.VerifyString(tablePos, 84 /*Source*/, false)
      && verifier.VerifyString(tablePos, 86 /*Origin*/, false)
      && verifier.VerifyString(tablePos, 88 /*OrigNetwork*/, false)
      && verifier.VerifyField(tablePos, 90 /*DataMode*/, 1 /*OrbitDetermination_Ingest_dataMode_Enum*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
