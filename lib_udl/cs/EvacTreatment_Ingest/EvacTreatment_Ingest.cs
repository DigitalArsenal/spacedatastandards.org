// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// Treatment information.
public struct EvacTreatment_Ingest : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static EvacTreatment_Ingest GetRootAsEvacTreatment_Ingest(ByteBuffer _bb) { return GetRootAsEvacTreatment_Ingest(_bb, new EvacTreatment_Ingest()); }
  public static EvacTreatment_Ingest GetRootAsEvacTreatment_Ingest(ByteBuffer _bb, EvacTreatment_Ingest obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool EvacTreatment_IngestBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "EVAC"); }
  public static bool VerifyEvacTreatment_Ingest(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("EVAC", false, EvacTreatment_IngestVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public EvacTreatment_Ingest __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Type of treatment administered or to be administered.  Intended as, but not constrained to, K07.1 Treatment Type Enumeration (e.g. AIRWAY ADJUNCT, AIRWAY ASSISTED VENTILATION, AIRWAY COMBI TUBE USED, AIRWAY ET NT, AIRWAY INTUBATED, AIRWAY NPA OPA APPLIED, AIRWAY PATIENT, AIRWAY POSITIONAL, AIRWAY SURGICAL CRIC, BREATHING CHEST SEAL, BREATHING CHEST TUBE, etc.).
  /// Example: /// Example: BREATHING CHEST TUBE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Type { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTypeBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetTypeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetTypeArray() { return __p.__vector_as_array<byte>(4); }
  /// Body part location or body part treated or to be treated.  Intended as, but not constrained to, K07.1 Body Location Enumeration (e.g. ANKLE LEFT BACK, ANKLE LEFT FRONT, ANKLE RIGHT BACK, ANKLE RIGHT FRONT, ARM LEFT BACK, ARM LEFT ELBOW BACK, ARM LEFT ELBOW FRONT, ARM LEFT FRONT, ARM LEFT LOWER BACK, etc.).
  /// Example: /// Example: CHEST
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string BodyPart { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBodyPartBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetBodyPartBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetBodyPartArray() { return __p.__vector_as_array<byte>(6); }
  /// Datetime of the treatment in ISO 8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string Time { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTimeBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetTimeBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetTimeArray() { return __p.__vector_as_array<byte>(8); }
  /// Additional comments on the patient's treatment information.
  /// Example: /// Example: Comments on the treatment info.
  /// Constraints: Minimum length = 0, Maximum length = 1024
  public string Comments { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCommentsBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetCommentsBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetCommentsArray() { return __p.__vector_as_array<byte>(10); }

  public static Offset<EvacTreatment_Ingest> CreateEvacTreatment_Ingest(FlatBufferBuilder builder,
      StringOffset typeOffset = default(StringOffset),
      StringOffset bodyPartOffset = default(StringOffset),
      StringOffset timeOffset = default(StringOffset),
      StringOffset commentsOffset = default(StringOffset)) {
    builder.StartTable(4);
    EvacTreatment_Ingest.AddComments(builder, commentsOffset);
    EvacTreatment_Ingest.AddTime(builder, timeOffset);
    EvacTreatment_Ingest.AddBodyPart(builder, bodyPartOffset);
    EvacTreatment_Ingest.AddType(builder, typeOffset);
    return EvacTreatment_Ingest.EndEvacTreatment_Ingest(builder);
  }

  public static void StartEvacTreatment_Ingest(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddType(FlatBufferBuilder builder, StringOffset typeOffset) { builder.AddOffset(0, typeOffset.Value, 0); }
  public static void AddBodyPart(FlatBufferBuilder builder, StringOffset bodyPartOffset) { builder.AddOffset(1, bodyPartOffset.Value, 0); }
  public static void AddTime(FlatBufferBuilder builder, StringOffset timeOffset) { builder.AddOffset(2, timeOffset.Value, 0); }
  public static void AddComments(FlatBufferBuilder builder, StringOffset commentsOffset) { builder.AddOffset(3, commentsOffset.Value, 0); }
  public static Offset<EvacTreatment_Ingest> EndEvacTreatment_Ingest(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<EvacTreatment_Ingest>(o);
  }
  public static void FinishEvacTreatment_IngestBuffer(FlatBufferBuilder builder, Offset<EvacTreatment_Ingest> offset) { builder.Finish(offset.Value, "EVAC"); }
  public static void FinishSizePrefixedEvacTreatment_IngestBuffer(FlatBufferBuilder builder, Offset<EvacTreatment_Ingest> offset) { builder.FinishSizePrefixed(offset.Value, "EVAC"); }
  public EvacTreatment_IngestT UnPack() {
    var _o = new EvacTreatment_IngestT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(EvacTreatment_IngestT _o) {
    _o.Type = this.Type;
    _o.BodyPart = this.BodyPart;
    _o.Time = this.Time;
    _o.Comments = this.Comments;
  }
  public static Offset<EvacTreatment_Ingest> Pack(FlatBufferBuilder builder, EvacTreatment_IngestT _o) {
    if (_o == null) return default(Offset<EvacTreatment_Ingest>);
    var _type = _o.Type == null ? default(StringOffset) : builder.CreateString(_o.Type);
    var _bodyPart = _o.BodyPart == null ? default(StringOffset) : builder.CreateString(_o.BodyPart);
    var _time = _o.Time == null ? default(StringOffset) : builder.CreateString(_o.Time);
    var _comments = _o.Comments == null ? default(StringOffset) : builder.CreateString(_o.Comments);
    return CreateEvacTreatment_Ingest(
      builder,
      _type,
      _bodyPart,
      _time,
      _comments);
  }
}

public class EvacTreatment_IngestT
{
  public string Type { get; set; }
  public string BodyPart { get; set; }
  public string Time { get; set; }
  public string Comments { get; set; }

  public EvacTreatment_IngestT() {
    this.Type = null;
    this.BodyPart = null;
    this.Time = null;
    this.Comments = null;
  }
  public static EvacTreatment_IngestT DeserializeFromBinary(byte[] fbBuffer) {
    return EvacTreatment_Ingest.GetRootAsEvacTreatment_Ingest(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    EvacTreatment_Ingest.FinishEvacTreatment_IngestBuffer(fbb, EvacTreatment_Ingest.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class EvacTreatment_IngestVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Type*/, false)
      && verifier.VerifyString(tablePos, 6 /*BodyPart*/, false)
      && verifier.VerifyString(tablePos, 8 /*Time*/, false)
      && verifier.VerifyString(tablePos, 10 /*Comments*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
