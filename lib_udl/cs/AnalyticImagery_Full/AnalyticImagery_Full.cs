// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// The analytic imagery schema supports data plots and graphics of various types. The records contain general file information, allows for annotations to user-defined areas of interest on the graphics, and supports keyword searching.
public struct AnalyticImagery_Full : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static AnalyticImagery_Full GetRootAsAnalyticImagery_Full(ByteBuffer _bb) { return GetRootAsAnalyticImagery_Full(_bb, new AnalyticImagery_Full()); }
  public static AnalyticImagery_Full GetRootAsAnalyticImagery_Full(ByteBuffer _bb, AnalyticImagery_Full obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool AnalyticImagery_FullBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "ANAL"); }
  public static bool VerifyAnalyticImagery_Full(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("ANAL", false, AnalyticImagery_FullVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public AnalyticImagery_Full __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: ANALYTIC-IMAGERY-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string Id { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetIdBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetIdArray() { return __p.__vector_as_array<byte>(4); }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  public string ClassificationMarking { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetClassificationMarkingBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetClassificationMarkingBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetClassificationMarkingArray() { return __p.__vector_as_array<byte>(6); }
  /// General type of content of this image (CONTOUR, DIAGRAM, HEATMAP, HISTOGRAM, PLOT, SCREENSHOT).
  /// Example: /// Example: CONTOUR
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string Content { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetContentBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetContentBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetContentArray() { return __p.__vector_as_array<byte>(8); }
  /// The message time of this image record, in ISO8601 UTC format with millisecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string MsgTime { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMsgTimeBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetMsgTimeBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetMsgTimeArray() { return __p.__vector_as_array<byte>(10); }
  /// The type of image associated with this record (GIF, JPG, PNG, TIF).
  /// Example: /// Example: JPG
  /// Constraints: Minimum length = 1, Maximum length = 16
  public string ImageType { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetImageTypeBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetImageTypeBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetImageTypeArray() { return __p.__vector_as_array<byte>(12); }
  /// The image file name.
  /// Example: /// Example: IMAGE-NAME
  /// Constraints: Minimum length = 1, Maximum length = 128
  public string Filename { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetFilenameBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetFilenameBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetFilenameArray() { return __p.__vector_as_array<byte>(14); }
  /// The image file size, in bytes.  The maximum file size for this service is 40,000,000 bytes (40MB). Files exceeding the maximum size will be rejected.
  /// Example: /// Example: 7654321
  /// Constraints: No constraints specified.
  public long Filesize { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  /// The image width (horizontal), in pixels.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  public int ImgWidth { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The image height (vertical), in pixels.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  public int ImgHeight { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Optional field indicating the units that apply to the x-axis of the attached image, when applicable.
  /// Example: /// Example: pixels
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string XUnits { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetXUnitsBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetXUnitsBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetXUnitsArray() { return __p.__vector_as_array<byte>(22); }
  /// Optional field indicating the units that apply to the y-axis of the attached image, when applicable.
  /// Example: /// Example: pixels
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string YUnits { get { int o = __p.__offset(24); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetYUnitsBytes() { return __p.__vector_as_span<byte>(24, 1); }
#else
  public ArraySegment<byte>? GetYUnitsBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public byte[] GetYUnitsArray() { return __p.__vector_as_array<byte>(24); }
  /// Optional field indicating the units that apply to the z-axis of the attached image, when applicable.
  /// Example: /// Example: pixels
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string ZUnits { get { int o = __p.__offset(26); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetZUnitsBytes() { return __p.__vector_as_span<byte>(26, 1); }
#else
  public ArraySegment<byte>? GetZUnitsBytes() { return __p.__vector_as_arraysegment(26); }
#endif
  public byte[] GetZUnitsArray() { return __p.__vector_as_array<byte>(26); }
  /// User-defined set ID of a sequence of images.  Used to associate related analytic image records.
  /// Example: /// Example: IMAGE-IDS
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string ImageSetId { get { int o = __p.__offset(28); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetImageSetIdBytes() { return __p.__vector_as_span<byte>(28, 1); }
#else
  public ArraySegment<byte>? GetImageSetIdBytes() { return __p.__vector_as_arraysegment(28); }
#endif
  public byte[] GetImageSetIdArray() { return __p.__vector_as_array<byte>(28); }
  /// The number of images in an image set.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  public int ImageSetLength { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The sequence number of an image within an image set.  If null, then it is assumed that the order of images in an imageSet is not relevant.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  public int SequenceId { get { int o = __p.__offset(32); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Description of the image content and utility.
  /// Example: /// Example: Image description
  /// Constraints: Minimum length = 1, Maximum length = 512
  public string Description { get { int o = __p.__offset(34); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDescriptionBytes() { return __p.__vector_as_span<byte>(34, 1); }
#else
  public ArraySegment<byte>? GetDescriptionBytes() { return __p.__vector_as_arraysegment(34); }
#endif
  public byte[] GetDescriptionArray() { return __p.__vector_as_array<byte>(34); }
  /// The start time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string DataStart { get { int o = __p.__offset(36); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDataStartBytes() { return __p.__vector_as_span<byte>(36, 1); }
#else
  public ArraySegment<byte>? GetDataStartBytes() { return __p.__vector_as_arraysegment(36); }
#endif
  public byte[] GetDataStartArray() { return __p.__vector_as_array<byte>(36); }
  /// The stop time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string DataStop { get { int o = __p.__offset(38); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDataStopBytes() { return __p.__vector_as_span<byte>(38, 1); }
#else
  public ArraySegment<byte>? GetDataStopBytes() { return __p.__vector_as_arraysegment(38); }
#endif
  public byte[] GetDataStopArray() { return __p.__vector_as_array<byte>(38); }
  /// Rectangular annotation limits, specified in pixels, as an array of arrays of the coordinates [ [UL1x, UL1y], [UR1x, UR1y], [LR1x, LR1y], [LL1x, LL1y] ], indicating the corners of a rectangle beginning with the Upper Left (UL) and moving clockwise. Allows the image provider to highlight one or more rectangular area(s) of interest. The array must contain Nx4 two-element arrays, where N is the number of rectangles of interest.  The associated annotation(s) should be included in the annText array.
  /// Example: /// Example: [[1, 1], [1, 2], [1, 3], [1, 4]]
  /// Constraints: No constraints specified.
  public string AnnLims(int j) { int o = __p.__offset(40); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int AnnLimsLength { get { int o = __p.__offset(40); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Annotation text, a string array of annotation(s) corresponding to the rectangular areas specified in annLims.  This array contains the annotation text associated with the areas of interest indicated in annLims, in order.  This array should contain one annotation per four values of the area (annLims) array.
  /// Example: /// Example: ['rec1', 'rec2']
  /// Constraints: No constraints specified.
  public string AnnText(int j) { int o = __p.__offset(42); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int AnnTextLength { get { int o = __p.__offset(42); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Array of searchable keywords for this analytic imagery record.
  /// Example: /// Example: ['Key1', 'Key2']
  /// Constraints: No constraints specified.
  public string Keywords(int j) { int o = __p.__offset(44); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int KeywordsLength { get { int o = __p.__offset(44); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
  /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  /// Constraints: No constraints specified.
  public string Area { get { int o = __p.__offset(46); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAreaBytes() { return __p.__vector_as_span<byte>(46, 1); }
#else
  public ArraySegment<byte>? GetAreaBytes() { return __p.__vector_as_arraysegment(46); }
#endif
  public byte[] GetAreaArray() { return __p.__vector_as_array<byte>(46); }
  /// Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
  /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  /// Constraints: No constraints specified.
  public string Atext { get { int o = __p.__offset(48); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAtextBytes() { return __p.__vector_as_span<byte>(48, 1); }
#else
  public ArraySegment<byte>? GetAtextBytes() { return __p.__vector_as_arraysegment(48); }
#endif
  public byte[] GetAtextArray() { return __p.__vector_as_array<byte>(48); }
  /// Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
  /// Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
  /// Constraints: No constraints specified.
  public string Agjson { get { int o = __p.__offset(50); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAgjsonBytes() { return __p.__vector_as_span<byte>(50, 1); }
#else
  public ArraySegment<byte>? GetAgjsonBytes() { return __p.__vector_as_arraysegment(50); }
#endif
  public byte[] GetAgjsonArray() { return __p.__vector_as_array<byte>(50); }
  /// Type of region as projected on the ground.
  /// Example: /// Example: POLYGON
  /// Constraints: Minimum length = 0, Maximum length = 128
  public string Atype { get { int o = __p.__offset(52); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAtypeBytes() { return __p.__vector_as_span<byte>(52, 1); }
#else
  public ArraySegment<byte>? GetAtypeBytes() { return __p.__vector_as_arraysegment(52); }
#endif
  public byte[] GetAtypeArray() { return __p.__vector_as_array<byte>(52); }
  /// Number of dimensions of the geometry depicted by region.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  public int Andims { get { int o = __p.__offset(54); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Geographical spatial_ref_sys for region.
  /// Example: /// Example: 4326
  /// Constraints: No constraints specified.
  public int Asrid { get { int o = __p.__offset(56); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Assessed satellite ID (NORAD RSO object number).  The 'satId' and 'satIdConf' arrays must match in size.
  /// Example: /// Example: [12004, 12005]
  /// Constraints: No constraints specified.
  public string SatId(int j) { int o = __p.__offset(58); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int SatIdLength { get { int o = __p.__offset(58); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Assessed satellite confidence corresponding to an assessment ID.  Values are between 0.0 and 1.0.  The 'satId' and 'satIdConf' arrays must match in size.
  /// Example: /// Example: [0.98, 0.22]
  /// Constraints: No constraints specified.
  public string SatIdConf(int j) { int o = __p.__offset(60); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int SatIdConfLength { get { int o = __p.__offset(60); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this image. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
  /// Example: /// Example: ['MTI', 'POI']
  /// Constraints: No constraints specified.
  public string SrcTyps(int j) { int o = __p.__offset(62); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int SrcTypsLength { get { int o = __p.__offset(62); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Array of UUIDs of the UDL data records that are related to this image. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
  /// Example: /// Example: ['DOA_ID', 'DWELL_ID']
  /// Constraints: No constraints specified.
  public string SrcIds(int j) { int o = __p.__offset(64); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int SrcIdsLength { get { int o = __p.__offset(64); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['TAG1', 'TAG2']
  /// Constraints: No constraints specified.
  public string Tags(int j) { int o = __p.__offset(66); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int TagsLength { get { int o = __p.__offset(66); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// MD5 checksum value of the file. The ingest/create operation will automatically generate the value.
  /// Example: /// Example: 123
  /// Constraints: Minimum length = 0, Maximum length = 256
  public string ChecksumValue { get { int o = __p.__offset(68); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetChecksumValueBytes() { return __p.__vector_as_span<byte>(68, 1); }
#else
  public ArraySegment<byte>? GetChecksumValueBytes() { return __p.__vector_as_arraysegment(68); }
#endif
  public byte[] GetChecksumValueArray() { return __p.__vector_as_array<byte>(68); }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: a7bdef1f-5a4f-4716-bee4-7a1e0ec7d35a
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string TransactionId { get { int o = __p.__offset(70); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTransactionIdBytes() { return __p.__vector_as_span<byte>(70, 1); }
#else
  public ArraySegment<byte>? GetTransactionIdBytes() { return __p.__vector_as_arraysegment(70); }
#endif
  public byte[] GetTransactionIdArray() { return __p.__vector_as_array<byte>(70); }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string CreatedAt { get { int o = __p.__offset(72); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedAtBytes() { return __p.__vector_as_span<byte>(72, 1); }
#else
  public ArraySegment<byte>? GetCreatedAtBytes() { return __p.__vector_as_arraysegment(72); }
#endif
  public byte[] GetCreatedAtArray() { return __p.__vector_as_array<byte>(72); }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string CreatedBy { get { int o = __p.__offset(74); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedByBytes() { return __p.__vector_as_span<byte>(74, 1); }
#else
  public ArraySegment<byte>? GetCreatedByBytes() { return __p.__vector_as_arraysegment(74); }
#endif
  public byte[] GetCreatedByArray() { return __p.__vector_as_array<byte>(74); }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string Source { get { int o = __p.__offset(76); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceBytes() { return __p.__vector_as_span<byte>(76, 1); }
#else
  public ArraySegment<byte>? GetSourceBytes() { return __p.__vector_as_arraysegment(76); }
#endif
  public byte[] GetSourceArray() { return __p.__vector_as_array<byte>(76); }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: ORIGIN
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Origin { get { int o = __p.__offset(78); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOriginBytes() { return __p.__vector_as_span<byte>(78, 1); }
#else
  public ArraySegment<byte>? GetOriginBytes() { return __p.__vector_as_arraysegment(78); }
#endif
  public byte[] GetOriginArray() { return __p.__vector_as_array<byte>(78); }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: TST1
  /// Constraints: Minimum length = 1, Maximum length = 32
  public string OrigNetwork { get { int o = __p.__offset(80); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOrigNetworkBytes() { return __p.__vector_as_span<byte>(80, 1); }
#else
  public ArraySegment<byte>? GetOrigNetworkBytes() { return __p.__vector_as_arraysegment(80); }
#endif
  public byte[] GetOrigNetworkArray() { return __p.__vector_as_array<byte>(80); }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string SourceDL { get { int o = __p.__offset(82); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceDLBytes() { return __p.__vector_as_span<byte>(82, 1); }
#else
  public ArraySegment<byte>? GetSourceDLBytes() { return __p.__vector_as_arraysegment(82); }
#endif
  public byte[] GetSourceDLArray() { return __p.__vector_as_array<byte>(82); }
  /// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  public AnalyticImagery_Full_dataMode_Enum DataMode { get { int o = __p.__offset(84); return o != 0 ? (AnalyticImagery_Full_dataMode_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : AnalyticImagery_Full_dataMode_Enum.REAL; } }

  public static Offset<AnalyticImagery_Full> CreateAnalyticImagery_Full(FlatBufferBuilder builder,
      StringOffset idOffset = default(StringOffset),
      StringOffset classificationMarkingOffset = default(StringOffset),
      StringOffset contentOffset = default(StringOffset),
      StringOffset msgTimeOffset = default(StringOffset),
      StringOffset imageTypeOffset = default(StringOffset),
      StringOffset filenameOffset = default(StringOffset),
      long filesize = 0,
      int imgWidth = 0,
      int imgHeight = 0,
      StringOffset xUnitsOffset = default(StringOffset),
      StringOffset yUnitsOffset = default(StringOffset),
      StringOffset zUnitsOffset = default(StringOffset),
      StringOffset imageSetIdOffset = default(StringOffset),
      int imageSetLength = 0,
      int sequenceId = 0,
      StringOffset descriptionOffset = default(StringOffset),
      StringOffset dataStartOffset = default(StringOffset),
      StringOffset dataStopOffset = default(StringOffset),
      VectorOffset annLimsOffset = default(VectorOffset),
      VectorOffset annTextOffset = default(VectorOffset),
      VectorOffset keywordsOffset = default(VectorOffset),
      StringOffset areaOffset = default(StringOffset),
      StringOffset atextOffset = default(StringOffset),
      StringOffset agjsonOffset = default(StringOffset),
      StringOffset atypeOffset = default(StringOffset),
      int andims = 0,
      int asrid = 0,
      VectorOffset satIdOffset = default(VectorOffset),
      VectorOffset satIdConfOffset = default(VectorOffset),
      VectorOffset srcTypsOffset = default(VectorOffset),
      VectorOffset srcIdsOffset = default(VectorOffset),
      VectorOffset tagsOffset = default(VectorOffset),
      StringOffset checksumValueOffset = default(StringOffset),
      StringOffset transactionIdOffset = default(StringOffset),
      StringOffset createdAtOffset = default(StringOffset),
      StringOffset createdByOffset = default(StringOffset),
      StringOffset sourceOffset = default(StringOffset),
      StringOffset originOffset = default(StringOffset),
      StringOffset origNetworkOffset = default(StringOffset),
      StringOffset sourceDLOffset = default(StringOffset),
      AnalyticImagery_Full_dataMode_Enum dataMode = AnalyticImagery_Full_dataMode_Enum.REAL) {
    builder.StartTable(41);
    AnalyticImagery_Full.AddFilesize(builder, filesize);
    AnalyticImagery_Full.AddSourceDL(builder, sourceDLOffset);
    AnalyticImagery_Full.AddOrigNetwork(builder, origNetworkOffset);
    AnalyticImagery_Full.AddOrigin(builder, originOffset);
    AnalyticImagery_Full.AddSource(builder, sourceOffset);
    AnalyticImagery_Full.AddCreatedBy(builder, createdByOffset);
    AnalyticImagery_Full.AddCreatedAt(builder, createdAtOffset);
    AnalyticImagery_Full.AddTransactionId(builder, transactionIdOffset);
    AnalyticImagery_Full.AddChecksumValue(builder, checksumValueOffset);
    AnalyticImagery_Full.AddTags(builder, tagsOffset);
    AnalyticImagery_Full.AddSrcIds(builder, srcIdsOffset);
    AnalyticImagery_Full.AddSrcTyps(builder, srcTypsOffset);
    AnalyticImagery_Full.AddSatIdConf(builder, satIdConfOffset);
    AnalyticImagery_Full.AddSatId(builder, satIdOffset);
    AnalyticImagery_Full.AddAsrid(builder, asrid);
    AnalyticImagery_Full.AddAndims(builder, andims);
    AnalyticImagery_Full.AddAtype(builder, atypeOffset);
    AnalyticImagery_Full.AddAgjson(builder, agjsonOffset);
    AnalyticImagery_Full.AddAtext(builder, atextOffset);
    AnalyticImagery_Full.AddArea(builder, areaOffset);
    AnalyticImagery_Full.AddKeywords(builder, keywordsOffset);
    AnalyticImagery_Full.AddAnnText(builder, annTextOffset);
    AnalyticImagery_Full.AddAnnLims(builder, annLimsOffset);
    AnalyticImagery_Full.AddDataStop(builder, dataStopOffset);
    AnalyticImagery_Full.AddDataStart(builder, dataStartOffset);
    AnalyticImagery_Full.AddDescription(builder, descriptionOffset);
    AnalyticImagery_Full.AddSequenceId(builder, sequenceId);
    AnalyticImagery_Full.AddImageSetLength(builder, imageSetLength);
    AnalyticImagery_Full.AddImageSetId(builder, imageSetIdOffset);
    AnalyticImagery_Full.AddZUnits(builder, zUnitsOffset);
    AnalyticImagery_Full.AddYUnits(builder, yUnitsOffset);
    AnalyticImagery_Full.AddXUnits(builder, xUnitsOffset);
    AnalyticImagery_Full.AddImgHeight(builder, imgHeight);
    AnalyticImagery_Full.AddImgWidth(builder, imgWidth);
    AnalyticImagery_Full.AddFilename(builder, filenameOffset);
    AnalyticImagery_Full.AddImageType(builder, imageTypeOffset);
    AnalyticImagery_Full.AddMsgTime(builder, msgTimeOffset);
    AnalyticImagery_Full.AddContent(builder, contentOffset);
    AnalyticImagery_Full.AddClassificationMarking(builder, classificationMarkingOffset);
    AnalyticImagery_Full.AddId(builder, idOffset);
    AnalyticImagery_Full.AddDataMode(builder, dataMode);
    return AnalyticImagery_Full.EndAnalyticImagery_Full(builder);
  }

  public static void StartAnalyticImagery_Full(FlatBufferBuilder builder) { builder.StartTable(41); }
  public static void AddId(FlatBufferBuilder builder, StringOffset idOffset) { builder.AddOffset(0, idOffset.Value, 0); }
  public static void AddClassificationMarking(FlatBufferBuilder builder, StringOffset classificationMarkingOffset) { builder.AddOffset(1, classificationMarkingOffset.Value, 0); }
  public static void AddContent(FlatBufferBuilder builder, StringOffset contentOffset) { builder.AddOffset(2, contentOffset.Value, 0); }
  public static void AddMsgTime(FlatBufferBuilder builder, StringOffset msgTimeOffset) { builder.AddOffset(3, msgTimeOffset.Value, 0); }
  public static void AddImageType(FlatBufferBuilder builder, StringOffset imageTypeOffset) { builder.AddOffset(4, imageTypeOffset.Value, 0); }
  public static void AddFilename(FlatBufferBuilder builder, StringOffset filenameOffset) { builder.AddOffset(5, filenameOffset.Value, 0); }
  public static void AddFilesize(FlatBufferBuilder builder, long filesize) { builder.AddLong(6, filesize, 0); }
  public static void AddImgWidth(FlatBufferBuilder builder, int imgWidth) { builder.AddInt(7, imgWidth, 0); }
  public static void AddImgHeight(FlatBufferBuilder builder, int imgHeight) { builder.AddInt(8, imgHeight, 0); }
  public static void AddXUnits(FlatBufferBuilder builder, StringOffset xUnitsOffset) { builder.AddOffset(9, xUnitsOffset.Value, 0); }
  public static void AddYUnits(FlatBufferBuilder builder, StringOffset yUnitsOffset) { builder.AddOffset(10, yUnitsOffset.Value, 0); }
  public static void AddZUnits(FlatBufferBuilder builder, StringOffset zUnitsOffset) { builder.AddOffset(11, zUnitsOffset.Value, 0); }
  public static void AddImageSetId(FlatBufferBuilder builder, StringOffset imageSetIdOffset) { builder.AddOffset(12, imageSetIdOffset.Value, 0); }
  public static void AddImageSetLength(FlatBufferBuilder builder, int imageSetLength) { builder.AddInt(13, imageSetLength, 0); }
  public static void AddSequenceId(FlatBufferBuilder builder, int sequenceId) { builder.AddInt(14, sequenceId, 0); }
  public static void AddDescription(FlatBufferBuilder builder, StringOffset descriptionOffset) { builder.AddOffset(15, descriptionOffset.Value, 0); }
  public static void AddDataStart(FlatBufferBuilder builder, StringOffset dataStartOffset) { builder.AddOffset(16, dataStartOffset.Value, 0); }
  public static void AddDataStop(FlatBufferBuilder builder, StringOffset dataStopOffset) { builder.AddOffset(17, dataStopOffset.Value, 0); }
  public static void AddAnnLims(FlatBufferBuilder builder, VectorOffset annLimsOffset) { builder.AddOffset(18, annLimsOffset.Value, 0); }
  public static VectorOffset CreateAnnLimsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAnnLimsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAnnLimsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAnnLimsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAnnLimsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddAnnText(FlatBufferBuilder builder, VectorOffset annTextOffset) { builder.AddOffset(19, annTextOffset.Value, 0); }
  public static VectorOffset CreateAnnTextVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAnnTextVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAnnTextVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAnnTextVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAnnTextVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddKeywords(FlatBufferBuilder builder, VectorOffset keywordsOffset) { builder.AddOffset(20, keywordsOffset.Value, 0); }
  public static VectorOffset CreateKeywordsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateKeywordsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateKeywordsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateKeywordsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartKeywordsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddArea(FlatBufferBuilder builder, StringOffset areaOffset) { builder.AddOffset(21, areaOffset.Value, 0); }
  public static void AddAtext(FlatBufferBuilder builder, StringOffset atextOffset) { builder.AddOffset(22, atextOffset.Value, 0); }
  public static void AddAgjson(FlatBufferBuilder builder, StringOffset agjsonOffset) { builder.AddOffset(23, agjsonOffset.Value, 0); }
  public static void AddAtype(FlatBufferBuilder builder, StringOffset atypeOffset) { builder.AddOffset(24, atypeOffset.Value, 0); }
  public static void AddAndims(FlatBufferBuilder builder, int andims) { builder.AddInt(25, andims, 0); }
  public static void AddAsrid(FlatBufferBuilder builder, int asrid) { builder.AddInt(26, asrid, 0); }
  public static void AddSatId(FlatBufferBuilder builder, VectorOffset satIdOffset) { builder.AddOffset(27, satIdOffset.Value, 0); }
  public static VectorOffset CreateSatIdVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSatIdVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSatIdVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSatIdVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSatIdVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSatIdConf(FlatBufferBuilder builder, VectorOffset satIdConfOffset) { builder.AddOffset(28, satIdConfOffset.Value, 0); }
  public static VectorOffset CreateSatIdConfVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSatIdConfVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSatIdConfVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSatIdConfVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSatIdConfVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSrcTyps(FlatBufferBuilder builder, VectorOffset srcTypsOffset) { builder.AddOffset(29, srcTypsOffset.Value, 0); }
  public static VectorOffset CreateSrcTypsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSrcTypsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSrcTypsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSrcTypsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSrcTypsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSrcIds(FlatBufferBuilder builder, VectorOffset srcIdsOffset) { builder.AddOffset(30, srcIdsOffset.Value, 0); }
  public static VectorOffset CreateSrcIdsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSrcIdsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSrcIdsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSrcIdsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSrcIdsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTags(FlatBufferBuilder builder, VectorOffset tagsOffset) { builder.AddOffset(31, tagsOffset.Value, 0); }
  public static VectorOffset CreateTagsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTagsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTagsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTagsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTagsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddChecksumValue(FlatBufferBuilder builder, StringOffset checksumValueOffset) { builder.AddOffset(32, checksumValueOffset.Value, 0); }
  public static void AddTransactionId(FlatBufferBuilder builder, StringOffset transactionIdOffset) { builder.AddOffset(33, transactionIdOffset.Value, 0); }
  public static void AddCreatedAt(FlatBufferBuilder builder, StringOffset createdAtOffset) { builder.AddOffset(34, createdAtOffset.Value, 0); }
  public static void AddCreatedBy(FlatBufferBuilder builder, StringOffset createdByOffset) { builder.AddOffset(35, createdByOffset.Value, 0); }
  public static void AddSource(FlatBufferBuilder builder, StringOffset sourceOffset) { builder.AddOffset(36, sourceOffset.Value, 0); }
  public static void AddOrigin(FlatBufferBuilder builder, StringOffset originOffset) { builder.AddOffset(37, originOffset.Value, 0); }
  public static void AddOrigNetwork(FlatBufferBuilder builder, StringOffset origNetworkOffset) { builder.AddOffset(38, origNetworkOffset.Value, 0); }
  public static void AddSourceDL(FlatBufferBuilder builder, StringOffset sourceDLOffset) { builder.AddOffset(39, sourceDLOffset.Value, 0); }
  public static void AddDataMode(FlatBufferBuilder builder, AnalyticImagery_Full_dataMode_Enum dataMode) { builder.AddSbyte(40, (sbyte)dataMode, 0); }
  public static Offset<AnalyticImagery_Full> EndAnalyticImagery_Full(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<AnalyticImagery_Full>(o);
  }
  public static void FinishAnalyticImagery_FullBuffer(FlatBufferBuilder builder, Offset<AnalyticImagery_Full> offset) { builder.Finish(offset.Value, "ANAL"); }
  public static void FinishSizePrefixedAnalyticImagery_FullBuffer(FlatBufferBuilder builder, Offset<AnalyticImagery_Full> offset) { builder.FinishSizePrefixed(offset.Value, "ANAL"); }
  public AnalyticImagery_FullT UnPack() {
    var _o = new AnalyticImagery_FullT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(AnalyticImagery_FullT _o) {
    _o.Id = this.Id;
    _o.ClassificationMarking = this.ClassificationMarking;
    _o.Content = this.Content;
    _o.MsgTime = this.MsgTime;
    _o.ImageType = this.ImageType;
    _o.Filename = this.Filename;
    _o.Filesize = this.Filesize;
    _o.ImgWidth = this.ImgWidth;
    _o.ImgHeight = this.ImgHeight;
    _o.XUnits = this.XUnits;
    _o.YUnits = this.YUnits;
    _o.ZUnits = this.ZUnits;
    _o.ImageSetId = this.ImageSetId;
    _o.ImageSetLength = this.ImageSetLength;
    _o.SequenceId = this.SequenceId;
    _o.Description = this.Description;
    _o.DataStart = this.DataStart;
    _o.DataStop = this.DataStop;
    _o.AnnLims = new List<string>();
    for (var _j = 0; _j < this.AnnLimsLength; ++_j) {_o.AnnLims.Add(this.AnnLims(_j));}
    _o.AnnText = new List<string>();
    for (var _j = 0; _j < this.AnnTextLength; ++_j) {_o.AnnText.Add(this.AnnText(_j));}
    _o.Keywords = new List<string>();
    for (var _j = 0; _j < this.KeywordsLength; ++_j) {_o.Keywords.Add(this.Keywords(_j));}
    _o.Area = this.Area;
    _o.Atext = this.Atext;
    _o.Agjson = this.Agjson;
    _o.Atype = this.Atype;
    _o.Andims = this.Andims;
    _o.Asrid = this.Asrid;
    _o.SatId = new List<string>();
    for (var _j = 0; _j < this.SatIdLength; ++_j) {_o.SatId.Add(this.SatId(_j));}
    _o.SatIdConf = new List<string>();
    for (var _j = 0; _j < this.SatIdConfLength; ++_j) {_o.SatIdConf.Add(this.SatIdConf(_j));}
    _o.SrcTyps = new List<string>();
    for (var _j = 0; _j < this.SrcTypsLength; ++_j) {_o.SrcTyps.Add(this.SrcTyps(_j));}
    _o.SrcIds = new List<string>();
    for (var _j = 0; _j < this.SrcIdsLength; ++_j) {_o.SrcIds.Add(this.SrcIds(_j));}
    _o.Tags = new List<string>();
    for (var _j = 0; _j < this.TagsLength; ++_j) {_o.Tags.Add(this.Tags(_j));}
    _o.ChecksumValue = this.ChecksumValue;
    _o.TransactionId = this.TransactionId;
    _o.CreatedAt = this.CreatedAt;
    _o.CreatedBy = this.CreatedBy;
    _o.Source = this.Source;
    _o.Origin = this.Origin;
    _o.OrigNetwork = this.OrigNetwork;
    _o.SourceDL = this.SourceDL;
    _o.DataMode = this.DataMode;
  }
  public static Offset<AnalyticImagery_Full> Pack(FlatBufferBuilder builder, AnalyticImagery_FullT _o) {
    if (_o == null) return default(Offset<AnalyticImagery_Full>);
    var _id = _o.Id == null ? default(StringOffset) : builder.CreateString(_o.Id);
    var _classificationMarking = _o.ClassificationMarking == null ? default(StringOffset) : builder.CreateString(_o.ClassificationMarking);
    var _content = _o.Content == null ? default(StringOffset) : builder.CreateString(_o.Content);
    var _msgTime = _o.MsgTime == null ? default(StringOffset) : builder.CreateString(_o.MsgTime);
    var _imageType = _o.ImageType == null ? default(StringOffset) : builder.CreateString(_o.ImageType);
    var _filename = _o.Filename == null ? default(StringOffset) : builder.CreateString(_o.Filename);
    var _xUnits = _o.XUnits == null ? default(StringOffset) : builder.CreateString(_o.XUnits);
    var _yUnits = _o.YUnits == null ? default(StringOffset) : builder.CreateString(_o.YUnits);
    var _zUnits = _o.ZUnits == null ? default(StringOffset) : builder.CreateString(_o.ZUnits);
    var _imageSetId = _o.ImageSetId == null ? default(StringOffset) : builder.CreateString(_o.ImageSetId);
    var _description = _o.Description == null ? default(StringOffset) : builder.CreateString(_o.Description);
    var _dataStart = _o.DataStart == null ? default(StringOffset) : builder.CreateString(_o.DataStart);
    var _dataStop = _o.DataStop == null ? default(StringOffset) : builder.CreateString(_o.DataStop);
    var _annLims = default(VectorOffset);
    if (_o.AnnLims != null) {
      var __annLims = new StringOffset[_o.AnnLims.Count];
      for (var _j = 0; _j < __annLims.Length; ++_j) { __annLims[_j] = builder.CreateString(_o.AnnLims[_j]); }
      _annLims = CreateAnnLimsVector(builder, __annLims);
    }
    var _annText = default(VectorOffset);
    if (_o.AnnText != null) {
      var __annText = new StringOffset[_o.AnnText.Count];
      for (var _j = 0; _j < __annText.Length; ++_j) { __annText[_j] = builder.CreateString(_o.AnnText[_j]); }
      _annText = CreateAnnTextVector(builder, __annText);
    }
    var _keywords = default(VectorOffset);
    if (_o.Keywords != null) {
      var __keywords = new StringOffset[_o.Keywords.Count];
      for (var _j = 0; _j < __keywords.Length; ++_j) { __keywords[_j] = builder.CreateString(_o.Keywords[_j]); }
      _keywords = CreateKeywordsVector(builder, __keywords);
    }
    var _area = _o.Area == null ? default(StringOffset) : builder.CreateString(_o.Area);
    var _atext = _o.Atext == null ? default(StringOffset) : builder.CreateString(_o.Atext);
    var _agjson = _o.Agjson == null ? default(StringOffset) : builder.CreateString(_o.Agjson);
    var _atype = _o.Atype == null ? default(StringOffset) : builder.CreateString(_o.Atype);
    var _satId = default(VectorOffset);
    if (_o.SatId != null) {
      var __satId = new StringOffset[_o.SatId.Count];
      for (var _j = 0; _j < __satId.Length; ++_j) { __satId[_j] = builder.CreateString(_o.SatId[_j]); }
      _satId = CreateSatIdVector(builder, __satId);
    }
    var _satIdConf = default(VectorOffset);
    if (_o.SatIdConf != null) {
      var __satIdConf = new StringOffset[_o.SatIdConf.Count];
      for (var _j = 0; _j < __satIdConf.Length; ++_j) { __satIdConf[_j] = builder.CreateString(_o.SatIdConf[_j]); }
      _satIdConf = CreateSatIdConfVector(builder, __satIdConf);
    }
    var _srcTyps = default(VectorOffset);
    if (_o.SrcTyps != null) {
      var __srcTyps = new StringOffset[_o.SrcTyps.Count];
      for (var _j = 0; _j < __srcTyps.Length; ++_j) { __srcTyps[_j] = builder.CreateString(_o.SrcTyps[_j]); }
      _srcTyps = CreateSrcTypsVector(builder, __srcTyps);
    }
    var _srcIds = default(VectorOffset);
    if (_o.SrcIds != null) {
      var __srcIds = new StringOffset[_o.SrcIds.Count];
      for (var _j = 0; _j < __srcIds.Length; ++_j) { __srcIds[_j] = builder.CreateString(_o.SrcIds[_j]); }
      _srcIds = CreateSrcIdsVector(builder, __srcIds);
    }
    var _tags = default(VectorOffset);
    if (_o.Tags != null) {
      var __tags = new StringOffset[_o.Tags.Count];
      for (var _j = 0; _j < __tags.Length; ++_j) { __tags[_j] = builder.CreateString(_o.Tags[_j]); }
      _tags = CreateTagsVector(builder, __tags);
    }
    var _checksumValue = _o.ChecksumValue == null ? default(StringOffset) : builder.CreateString(_o.ChecksumValue);
    var _transactionId = _o.TransactionId == null ? default(StringOffset) : builder.CreateString(_o.TransactionId);
    var _createdAt = _o.CreatedAt == null ? default(StringOffset) : builder.CreateString(_o.CreatedAt);
    var _createdBy = _o.CreatedBy == null ? default(StringOffset) : builder.CreateString(_o.CreatedBy);
    var _source = _o.Source == null ? default(StringOffset) : builder.CreateString(_o.Source);
    var _origin = _o.Origin == null ? default(StringOffset) : builder.CreateString(_o.Origin);
    var _origNetwork = _o.OrigNetwork == null ? default(StringOffset) : builder.CreateString(_o.OrigNetwork);
    var _sourceDL = _o.SourceDL == null ? default(StringOffset) : builder.CreateString(_o.SourceDL);
    return CreateAnalyticImagery_Full(
      builder,
      _id,
      _classificationMarking,
      _content,
      _msgTime,
      _imageType,
      _filename,
      _o.Filesize,
      _o.ImgWidth,
      _o.ImgHeight,
      _xUnits,
      _yUnits,
      _zUnits,
      _imageSetId,
      _o.ImageSetLength,
      _o.SequenceId,
      _description,
      _dataStart,
      _dataStop,
      _annLims,
      _annText,
      _keywords,
      _area,
      _atext,
      _agjson,
      _atype,
      _o.Andims,
      _o.Asrid,
      _satId,
      _satIdConf,
      _srcTyps,
      _srcIds,
      _tags,
      _checksumValue,
      _transactionId,
      _createdAt,
      _createdBy,
      _source,
      _origin,
      _origNetwork,
      _sourceDL,
      _o.DataMode);
  }
}

public class AnalyticImagery_FullT
{
  public string Id { get; set; }
  public string ClassificationMarking { get; set; }
  public string Content { get; set; }
  public string MsgTime { get; set; }
  public string ImageType { get; set; }
  public string Filename { get; set; }
  public long Filesize { get; set; }
  public int ImgWidth { get; set; }
  public int ImgHeight { get; set; }
  public string XUnits { get; set; }
  public string YUnits { get; set; }
  public string ZUnits { get; set; }
  public string ImageSetId { get; set; }
  public int ImageSetLength { get; set; }
  public int SequenceId { get; set; }
  public string Description { get; set; }
  public string DataStart { get; set; }
  public string DataStop { get; set; }
  public List<string> AnnLims { get; set; }
  public List<string> AnnText { get; set; }
  public List<string> Keywords { get; set; }
  public string Area { get; set; }
  public string Atext { get; set; }
  public string Agjson { get; set; }
  public string Atype { get; set; }
  public int Andims { get; set; }
  public int Asrid { get; set; }
  public List<string> SatId { get; set; }
  public List<string> SatIdConf { get; set; }
  public List<string> SrcTyps { get; set; }
  public List<string> SrcIds { get; set; }
  public List<string> Tags { get; set; }
  public string ChecksumValue { get; set; }
  public string TransactionId { get; set; }
  public string CreatedAt { get; set; }
  public string CreatedBy { get; set; }
  public string Source { get; set; }
  public string Origin { get; set; }
  public string OrigNetwork { get; set; }
  public string SourceDL { get; set; }
  public AnalyticImagery_Full_dataMode_Enum DataMode { get; set; }

  public AnalyticImagery_FullT() {
    this.Id = null;
    this.ClassificationMarking = null;
    this.Content = null;
    this.MsgTime = null;
    this.ImageType = null;
    this.Filename = null;
    this.Filesize = 0;
    this.ImgWidth = 0;
    this.ImgHeight = 0;
    this.XUnits = null;
    this.YUnits = null;
    this.ZUnits = null;
    this.ImageSetId = null;
    this.ImageSetLength = 0;
    this.SequenceId = 0;
    this.Description = null;
    this.DataStart = null;
    this.DataStop = null;
    this.AnnLims = null;
    this.AnnText = null;
    this.Keywords = null;
    this.Area = null;
    this.Atext = null;
    this.Agjson = null;
    this.Atype = null;
    this.Andims = 0;
    this.Asrid = 0;
    this.SatId = null;
    this.SatIdConf = null;
    this.SrcTyps = null;
    this.SrcIds = null;
    this.Tags = null;
    this.ChecksumValue = null;
    this.TransactionId = null;
    this.CreatedAt = null;
    this.CreatedBy = null;
    this.Source = null;
    this.Origin = null;
    this.OrigNetwork = null;
    this.SourceDL = null;
    this.DataMode = AnalyticImagery_Full_dataMode_Enum.REAL;
  }
  public static AnalyticImagery_FullT DeserializeFromBinary(byte[] fbBuffer) {
    return AnalyticImagery_Full.GetRootAsAnalyticImagery_Full(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    AnalyticImagery_Full.FinishAnalyticImagery_FullBuffer(fbb, AnalyticImagery_Full.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class AnalyticImagery_FullVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Id*/, false)
      && verifier.VerifyString(tablePos, 6 /*ClassificationMarking*/, false)
      && verifier.VerifyString(tablePos, 8 /*Content*/, false)
      && verifier.VerifyString(tablePos, 10 /*MsgTime*/, false)
      && verifier.VerifyString(tablePos, 12 /*ImageType*/, false)
      && verifier.VerifyString(tablePos, 14 /*Filename*/, false)
      && verifier.VerifyField(tablePos, 16 /*Filesize*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 18 /*ImgWidth*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 20 /*ImgHeight*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 22 /*XUnits*/, false)
      && verifier.VerifyString(tablePos, 24 /*YUnits*/, false)
      && verifier.VerifyString(tablePos, 26 /*ZUnits*/, false)
      && verifier.VerifyString(tablePos, 28 /*ImageSetId*/, false)
      && verifier.VerifyField(tablePos, 30 /*ImageSetLength*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 32 /*SequenceId*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 34 /*Description*/, false)
      && verifier.VerifyString(tablePos, 36 /*DataStart*/, false)
      && verifier.VerifyString(tablePos, 38 /*DataStop*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 40 /*AnnLims*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 42 /*AnnText*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 44 /*Keywords*/, false)
      && verifier.VerifyString(tablePos, 46 /*Area*/, false)
      && verifier.VerifyString(tablePos, 48 /*Atext*/, false)
      && verifier.VerifyString(tablePos, 50 /*Agjson*/, false)
      && verifier.VerifyString(tablePos, 52 /*Atype*/, false)
      && verifier.VerifyField(tablePos, 54 /*Andims*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 56 /*Asrid*/, 4 /*int*/, 4, false)
      && verifier.VerifyVectorOfStrings(tablePos, 58 /*SatId*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 60 /*SatIdConf*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 62 /*SrcTyps*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 64 /*SrcIds*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 66 /*Tags*/, false)
      && verifier.VerifyString(tablePos, 68 /*ChecksumValue*/, false)
      && verifier.VerifyString(tablePos, 70 /*TransactionId*/, false)
      && verifier.VerifyString(tablePos, 72 /*CreatedAt*/, false)
      && verifier.VerifyString(tablePos, 74 /*CreatedBy*/, false)
      && verifier.VerifyString(tablePos, 76 /*Source*/, false)
      && verifier.VerifyString(tablePos, 78 /*Origin*/, false)
      && verifier.VerifyString(tablePos, 80 /*OrigNetwork*/, false)
      && verifier.VerifyString(tablePos, 82 /*SourceDL*/, false)
      && verifier.VerifyField(tablePos, 84 /*DataMode*/, 1 /*AnalyticImagery_Full_dataMode_Enum*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
