// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// Properties and characteristics of a maritime port, which includes location, port identifiers, and remarks.
public struct Port_Full : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static Port_Full GetRootAsPort_Full(ByteBuffer _bb) { return GetRootAsPort_Full(_bb, new Port_Full()); }
  public static Port_Full GetRootAsPort_Full(ByteBuffer _bb, Port_Full obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool Port_FullBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "PORT"); }
  public static bool VerifyPort_Full(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("PORT", false, Port_FullVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Port_Full __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Unique identifier of the record, auto-generated by the system if not provided on create operations.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string Id { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetIdBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetIdArray() { return __p.__vector_as_array<byte>(4); }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  public string ClassificationMarking { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetClassificationMarkingBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetClassificationMarkingBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetClassificationMarkingArray() { return __p.__vector_as_array<byte>(6); }
  /// Unique identifier of the Site Entity associated with the Port record.
  /// Example: /// Example: a150b3ee-884b-b9ac-60a0-6408b4b16088
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string IdSite { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdSiteBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetIdSiteBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetIdSiteArray() { return __p.__vector_as_array<byte>(8); }
  /// Optional ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: fe4ad5dc-0128-4ce8-b09c-0b404322025e
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string ExternalId { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetExternalIdBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetExternalIdBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetExternalIdArray() { return __p.__vector_as_array<byte>(10); }
  /// The five-character United Nations Code for Trade and Transport Locations (UN/LOCODE) of this port.  The first two letters of the code contains the ISO 3166-1 alpha-2 country designation of the port country. The three remaining characters identify a location within that country.  Letters are preferred, but if necessary digits 2 through 9 may be used, excluding "0" and "1" to avoid confusion with the letters "O" and "I" respectively.
  /// Example: /// Example: CAVAN
  /// Constraints: Minimum length = 0, Maximum length = 5
  public string Locode { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLocodeBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetLocodeBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetLocodeArray() { return __p.__vector_as_array<byte>(12); }
  /// The name of this port.
  /// Example: /// Example: Vancouver
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string PortName { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPortNameBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetPortNameBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetPortNameArray() { return __p.__vector_as_array<byte>(14); }
  /// The type of harbor for this port. The harbor type refers to how a port is physically positioned.
  /// COASTAL BREAKWATER (CB)
  /// COASTAL NATURAL (CN)
  /// COASTAL TIDE GATE  (CT)
  /// LAKE OR CANAL (LC)
  /// OPEN ROADSTEAD (OR)
  /// RIVER BASIN (RB)
  /// RIVER NATURAL (RN)
  /// RIVER TIDE GATE (RT)
  /// TYPHOON HARBOR  (TH).
  /// Example: /// Example: COASTAL NATURAL
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string HarborType { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetHarborTypeBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetHarborTypeBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetHarborTypeArray() { return __p.__vector_as_array<byte>(16); }
  /// The size of the harbor for this port measured in square kilometers.
  /// Example: /// Example: 160.1
  /// Constraints: No constraints specified.
  public double HarborSize { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Maximum allowed vessel draught. Draught is the principal dimensions of any waterborne vessel defined as the distance between the shipâ€™s keel and the waterline of the vessel measured in meters.
  /// Example: /// Example: 18.1
  /// Constraints: No constraints specified.
  public double MaxDraught { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Average time for a vessel at this port in hours.
  /// Example: /// Example: 41.1
  /// Constraints: No constraints specified.
  public double AvgDuration { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The tide range of this port in meters.
  /// Example: /// Example: 4.1
  /// Constraints: No constraints specified.
  public double TideRange { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The shelter afforded from wind, sea, and swell refers to the area where normal port operations are conducted, usually the wharf area. Shelter afforded by the anchorage area may be given for ports where cargo is handled by lighters. Values given are EXCELLENT, FAIR, GOOD, POOR, or NONE.
  /// Example: /// Example: EXCELLENT
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string Shelter { get { int o = __p.__offset(26); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetShelterBytes() { return __p.__vector_as_span<byte>(26, 1); }
#else
  public ArraySegment<byte>? GetShelterBytes() { return __p.__vector_as_arraysegment(26); }
#endif
  public byte[] GetShelterArray() { return __p.__vector_as_array<byte>(26); }
  /// Flag indicating whether a pilot is required at this port.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool PilotReqd { get { int o = __p.__offset(28); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  public double Lat { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  public double Lon { get { int o = __p.__offset(32); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The country where this port is located.
  /// Example: /// Example: US
  /// Constraints: Minimum length = 0, Maximum length = 4
  public string CountryCode { get { int o = __p.__offset(34); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCountryCodeBytes() { return __p.__vector_as_span<byte>(34, 1); }
#else
  public ArraySegment<byte>? GetCountryCodeBytes() { return __p.__vector_as_arraysegment(34); }
#endif
  public byte[] GetCountryCodeArray() { return __p.__vector_as_array<byte>(34); }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string CreatedAt { get { int o = __p.__offset(36); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedAtBytes() { return __p.__vector_as_span<byte>(36, 1); }
#else
  public ArraySegment<byte>? GetCreatedAtBytes() { return __p.__vector_as_arraysegment(36); }
#endif
  public byte[] GetCreatedAtArray() { return __p.__vector_as_array<byte>(36); }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string CreatedBy { get { int o = __p.__offset(38); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedByBytes() { return __p.__vector_as_span<byte>(38, 1); }
#else
  public ArraySegment<byte>? GetCreatedByBytes() { return __p.__vector_as_arraysegment(38); }
#endif
  public byte[] GetCreatedByArray() { return __p.__vector_as_array<byte>(38); }
  /// Time the row was updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string UpdatedAt { get { int o = __p.__offset(40); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetUpdatedAtBytes() { return __p.__vector_as_span<byte>(40, 1); }
#else
  public ArraySegment<byte>? GetUpdatedAtBytes() { return __p.__vector_as_arraysegment(40); }
#endif
  public byte[] GetUpdatedAtArray() { return __p.__vector_as_array<byte>(40); }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string UpdatedBy { get { int o = __p.__offset(42); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetUpdatedByBytes() { return __p.__vector_as_span<byte>(42, 1); }
#else
  public ArraySegment<byte>? GetUpdatedByBytes() { return __p.__vector_as_arraysegment(42); }
#endif
  public byte[] GetUpdatedByArray() { return __p.__vector_as_array<byte>(42); }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string Source { get { int o = __p.__offset(44); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceBytes() { return __p.__vector_as_span<byte>(44, 1); }
#else
  public ArraySegment<byte>? GetSourceBytes() { return __p.__vector_as_arraysegment(44); }
#endif
  public byte[] GetSourceArray() { return __p.__vector_as_array<byte>(44); }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string SourceDL { get { int o = __p.__offset(46); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceDLBytes() { return __p.__vector_as_span<byte>(46, 1); }
#else
  public ArraySegment<byte>? GetSourceDLBytes() { return __p.__vector_as_arraysegment(46); }
#endif
  public byte[] GetSourceDLArray() { return __p.__vector_as_array<byte>(46); }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Origin { get { int o = __p.__offset(48); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOriginBytes() { return __p.__vector_as_span<byte>(48, 1); }
#else
  public ArraySegment<byte>? GetOriginBytes() { return __p.__vector_as_arraysegment(48); }
#endif
  public byte[] GetOriginArray() { return __p.__vector_as_array<byte>(48); }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 64
  public Port_Full_dataMode_Enum DataMode { get { int o = __p.__offset(50); return o != 0 ? (Port_Full_dataMode_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : Port_Full_dataMode_Enum.REAL; } }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  public string OrigNetwork { get { int o = __p.__offset(52); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOrigNetworkBytes() { return __p.__vector_as_span<byte>(52, 1); }
#else
  public ArraySegment<byte>? GetOrigNetworkBytes() { return __p.__vector_as_arraysegment(52); }
#endif
  public byte[] GetOrigNetworkArray() { return __p.__vector_as_array<byte>(52); }

  public static Offset<Port_Full> CreatePort_Full(FlatBufferBuilder builder,
      StringOffset idOffset = default(StringOffset),
      StringOffset classificationMarkingOffset = default(StringOffset),
      StringOffset idSiteOffset = default(StringOffset),
      StringOffset externalIdOffset = default(StringOffset),
      StringOffset locodeOffset = default(StringOffset),
      StringOffset portNameOffset = default(StringOffset),
      StringOffset harborTypeOffset = default(StringOffset),
      double harborSize = 0.0,
      double maxDraught = 0.0,
      double avgDuration = 0.0,
      double tideRange = 0.0,
      StringOffset shelterOffset = default(StringOffset),
      bool pilotReqd = false,
      double lat = 0.0,
      double lon = 0.0,
      StringOffset countryCodeOffset = default(StringOffset),
      StringOffset createdAtOffset = default(StringOffset),
      StringOffset createdByOffset = default(StringOffset),
      StringOffset updatedAtOffset = default(StringOffset),
      StringOffset updatedByOffset = default(StringOffset),
      StringOffset sourceOffset = default(StringOffset),
      StringOffset sourceDLOffset = default(StringOffset),
      StringOffset originOffset = default(StringOffset),
      Port_Full_dataMode_Enum dataMode = Port_Full_dataMode_Enum.REAL,
      StringOffset origNetworkOffset = default(StringOffset)) {
    builder.StartTable(25);
    Port_Full.AddLon(builder, lon);
    Port_Full.AddLat(builder, lat);
    Port_Full.AddTideRange(builder, tideRange);
    Port_Full.AddAvgDuration(builder, avgDuration);
    Port_Full.AddMaxDraught(builder, maxDraught);
    Port_Full.AddHarborSize(builder, harborSize);
    Port_Full.AddOrigNetwork(builder, origNetworkOffset);
    Port_Full.AddOrigin(builder, originOffset);
    Port_Full.AddSourceDL(builder, sourceDLOffset);
    Port_Full.AddSource(builder, sourceOffset);
    Port_Full.AddUpdatedBy(builder, updatedByOffset);
    Port_Full.AddUpdatedAt(builder, updatedAtOffset);
    Port_Full.AddCreatedBy(builder, createdByOffset);
    Port_Full.AddCreatedAt(builder, createdAtOffset);
    Port_Full.AddCountryCode(builder, countryCodeOffset);
    Port_Full.AddShelter(builder, shelterOffset);
    Port_Full.AddHarborType(builder, harborTypeOffset);
    Port_Full.AddPortName(builder, portNameOffset);
    Port_Full.AddLocode(builder, locodeOffset);
    Port_Full.AddExternalId(builder, externalIdOffset);
    Port_Full.AddIdSite(builder, idSiteOffset);
    Port_Full.AddClassificationMarking(builder, classificationMarkingOffset);
    Port_Full.AddId(builder, idOffset);
    Port_Full.AddDataMode(builder, dataMode);
    Port_Full.AddPilotReqd(builder, pilotReqd);
    return Port_Full.EndPort_Full(builder);
  }

  public static void StartPort_Full(FlatBufferBuilder builder) { builder.StartTable(25); }
  public static void AddId(FlatBufferBuilder builder, StringOffset idOffset) { builder.AddOffset(0, idOffset.Value, 0); }
  public static void AddClassificationMarking(FlatBufferBuilder builder, StringOffset classificationMarkingOffset) { builder.AddOffset(1, classificationMarkingOffset.Value, 0); }
  public static void AddIdSite(FlatBufferBuilder builder, StringOffset idSiteOffset) { builder.AddOffset(2, idSiteOffset.Value, 0); }
  public static void AddExternalId(FlatBufferBuilder builder, StringOffset externalIdOffset) { builder.AddOffset(3, externalIdOffset.Value, 0); }
  public static void AddLocode(FlatBufferBuilder builder, StringOffset locodeOffset) { builder.AddOffset(4, locodeOffset.Value, 0); }
  public static void AddPortName(FlatBufferBuilder builder, StringOffset portNameOffset) { builder.AddOffset(5, portNameOffset.Value, 0); }
  public static void AddHarborType(FlatBufferBuilder builder, StringOffset harborTypeOffset) { builder.AddOffset(6, harborTypeOffset.Value, 0); }
  public static void AddHarborSize(FlatBufferBuilder builder, double harborSize) { builder.AddDouble(7, harborSize, 0.0); }
  public static void AddMaxDraught(FlatBufferBuilder builder, double maxDraught) { builder.AddDouble(8, maxDraught, 0.0); }
  public static void AddAvgDuration(FlatBufferBuilder builder, double avgDuration) { builder.AddDouble(9, avgDuration, 0.0); }
  public static void AddTideRange(FlatBufferBuilder builder, double tideRange) { builder.AddDouble(10, tideRange, 0.0); }
  public static void AddShelter(FlatBufferBuilder builder, StringOffset shelterOffset) { builder.AddOffset(11, shelterOffset.Value, 0); }
  public static void AddPilotReqd(FlatBufferBuilder builder, bool pilotReqd) { builder.AddBool(12, pilotReqd, false); }
  public static void AddLat(FlatBufferBuilder builder, double lat) { builder.AddDouble(13, lat, 0.0); }
  public static void AddLon(FlatBufferBuilder builder, double lon) { builder.AddDouble(14, lon, 0.0); }
  public static void AddCountryCode(FlatBufferBuilder builder, StringOffset countryCodeOffset) { builder.AddOffset(15, countryCodeOffset.Value, 0); }
  public static void AddCreatedAt(FlatBufferBuilder builder, StringOffset createdAtOffset) { builder.AddOffset(16, createdAtOffset.Value, 0); }
  public static void AddCreatedBy(FlatBufferBuilder builder, StringOffset createdByOffset) { builder.AddOffset(17, createdByOffset.Value, 0); }
  public static void AddUpdatedAt(FlatBufferBuilder builder, StringOffset updatedAtOffset) { builder.AddOffset(18, updatedAtOffset.Value, 0); }
  public static void AddUpdatedBy(FlatBufferBuilder builder, StringOffset updatedByOffset) { builder.AddOffset(19, updatedByOffset.Value, 0); }
  public static void AddSource(FlatBufferBuilder builder, StringOffset sourceOffset) { builder.AddOffset(20, sourceOffset.Value, 0); }
  public static void AddSourceDL(FlatBufferBuilder builder, StringOffset sourceDLOffset) { builder.AddOffset(21, sourceDLOffset.Value, 0); }
  public static void AddOrigin(FlatBufferBuilder builder, StringOffset originOffset) { builder.AddOffset(22, originOffset.Value, 0); }
  public static void AddDataMode(FlatBufferBuilder builder, Port_Full_dataMode_Enum dataMode) { builder.AddSbyte(23, (sbyte)dataMode, 0); }
  public static void AddOrigNetwork(FlatBufferBuilder builder, StringOffset origNetworkOffset) { builder.AddOffset(24, origNetworkOffset.Value, 0); }
  public static Offset<Port_Full> EndPort_Full(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Port_Full>(o);
  }
  public static void FinishPort_FullBuffer(FlatBufferBuilder builder, Offset<Port_Full> offset) { builder.Finish(offset.Value, "PORT"); }
  public static void FinishSizePrefixedPort_FullBuffer(FlatBufferBuilder builder, Offset<Port_Full> offset) { builder.FinishSizePrefixed(offset.Value, "PORT"); }
  public Port_FullT UnPack() {
    var _o = new Port_FullT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Port_FullT _o) {
    _o.Id = this.Id;
    _o.ClassificationMarking = this.ClassificationMarking;
    _o.IdSite = this.IdSite;
    _o.ExternalId = this.ExternalId;
    _o.Locode = this.Locode;
    _o.PortName = this.PortName;
    _o.HarborType = this.HarborType;
    _o.HarborSize = this.HarborSize;
    _o.MaxDraught = this.MaxDraught;
    _o.AvgDuration = this.AvgDuration;
    _o.TideRange = this.TideRange;
    _o.Shelter = this.Shelter;
    _o.PilotReqd = this.PilotReqd;
    _o.Lat = this.Lat;
    _o.Lon = this.Lon;
    _o.CountryCode = this.CountryCode;
    _o.CreatedAt = this.CreatedAt;
    _o.CreatedBy = this.CreatedBy;
    _o.UpdatedAt = this.UpdatedAt;
    _o.UpdatedBy = this.UpdatedBy;
    _o.Source = this.Source;
    _o.SourceDL = this.SourceDL;
    _o.Origin = this.Origin;
    _o.DataMode = this.DataMode;
    _o.OrigNetwork = this.OrigNetwork;
  }
  public static Offset<Port_Full> Pack(FlatBufferBuilder builder, Port_FullT _o) {
    if (_o == null) return default(Offset<Port_Full>);
    var _id = _o.Id == null ? default(StringOffset) : builder.CreateString(_o.Id);
    var _classificationMarking = _o.ClassificationMarking == null ? default(StringOffset) : builder.CreateString(_o.ClassificationMarking);
    var _idSite = _o.IdSite == null ? default(StringOffset) : builder.CreateString(_o.IdSite);
    var _externalId = _o.ExternalId == null ? default(StringOffset) : builder.CreateString(_o.ExternalId);
    var _locode = _o.Locode == null ? default(StringOffset) : builder.CreateString(_o.Locode);
    var _portName = _o.PortName == null ? default(StringOffset) : builder.CreateString(_o.PortName);
    var _harborType = _o.HarborType == null ? default(StringOffset) : builder.CreateString(_o.HarborType);
    var _shelter = _o.Shelter == null ? default(StringOffset) : builder.CreateString(_o.Shelter);
    var _countryCode = _o.CountryCode == null ? default(StringOffset) : builder.CreateString(_o.CountryCode);
    var _createdAt = _o.CreatedAt == null ? default(StringOffset) : builder.CreateString(_o.CreatedAt);
    var _createdBy = _o.CreatedBy == null ? default(StringOffset) : builder.CreateString(_o.CreatedBy);
    var _updatedAt = _o.UpdatedAt == null ? default(StringOffset) : builder.CreateString(_o.UpdatedAt);
    var _updatedBy = _o.UpdatedBy == null ? default(StringOffset) : builder.CreateString(_o.UpdatedBy);
    var _source = _o.Source == null ? default(StringOffset) : builder.CreateString(_o.Source);
    var _sourceDL = _o.SourceDL == null ? default(StringOffset) : builder.CreateString(_o.SourceDL);
    var _origin = _o.Origin == null ? default(StringOffset) : builder.CreateString(_o.Origin);
    var _origNetwork = _o.OrigNetwork == null ? default(StringOffset) : builder.CreateString(_o.OrigNetwork);
    return CreatePort_Full(
      builder,
      _id,
      _classificationMarking,
      _idSite,
      _externalId,
      _locode,
      _portName,
      _harborType,
      _o.HarborSize,
      _o.MaxDraught,
      _o.AvgDuration,
      _o.TideRange,
      _shelter,
      _o.PilotReqd,
      _o.Lat,
      _o.Lon,
      _countryCode,
      _createdAt,
      _createdBy,
      _updatedAt,
      _updatedBy,
      _source,
      _sourceDL,
      _origin,
      _o.DataMode,
      _origNetwork);
  }
}

public class Port_FullT
{
  public string Id { get; set; }
  public string ClassificationMarking { get; set; }
  public string IdSite { get; set; }
  public string ExternalId { get; set; }
  public string Locode { get; set; }
  public string PortName { get; set; }
  public string HarborType { get; set; }
  public double HarborSize { get; set; }
  public double MaxDraught { get; set; }
  public double AvgDuration { get; set; }
  public double TideRange { get; set; }
  public string Shelter { get; set; }
  public bool PilotReqd { get; set; }
  public double Lat { get; set; }
  public double Lon { get; set; }
  public string CountryCode { get; set; }
  public string CreatedAt { get; set; }
  public string CreatedBy { get; set; }
  public string UpdatedAt { get; set; }
  public string UpdatedBy { get; set; }
  public string Source { get; set; }
  public string SourceDL { get; set; }
  public string Origin { get; set; }
  public Port_Full_dataMode_Enum DataMode { get; set; }
  public string OrigNetwork { get; set; }

  public Port_FullT() {
    this.Id = null;
    this.ClassificationMarking = null;
    this.IdSite = null;
    this.ExternalId = null;
    this.Locode = null;
    this.PortName = null;
    this.HarborType = null;
    this.HarborSize = 0.0;
    this.MaxDraught = 0.0;
    this.AvgDuration = 0.0;
    this.TideRange = 0.0;
    this.Shelter = null;
    this.PilotReqd = false;
    this.Lat = 0.0;
    this.Lon = 0.0;
    this.CountryCode = null;
    this.CreatedAt = null;
    this.CreatedBy = null;
    this.UpdatedAt = null;
    this.UpdatedBy = null;
    this.Source = null;
    this.SourceDL = null;
    this.Origin = null;
    this.DataMode = Port_Full_dataMode_Enum.REAL;
    this.OrigNetwork = null;
  }
  public static Port_FullT DeserializeFromBinary(byte[] fbBuffer) {
    return Port_Full.GetRootAsPort_Full(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    Port_Full.FinishPort_FullBuffer(fbb, Port_Full.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class Port_FullVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Id*/, false)
      && verifier.VerifyString(tablePos, 6 /*ClassificationMarking*/, false)
      && verifier.VerifyString(tablePos, 8 /*IdSite*/, false)
      && verifier.VerifyString(tablePos, 10 /*ExternalId*/, false)
      && verifier.VerifyString(tablePos, 12 /*Locode*/, false)
      && verifier.VerifyString(tablePos, 14 /*PortName*/, false)
      && verifier.VerifyString(tablePos, 16 /*HarborType*/, false)
      && verifier.VerifyField(tablePos, 18 /*HarborSize*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 20 /*MaxDraught*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 22 /*AvgDuration*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 24 /*TideRange*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 26 /*Shelter*/, false)
      && verifier.VerifyField(tablePos, 28 /*PilotReqd*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 30 /*Lat*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 32 /*Lon*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 34 /*CountryCode*/, false)
      && verifier.VerifyString(tablePos, 36 /*CreatedAt*/, false)
      && verifier.VerifyString(tablePos, 38 /*CreatedBy*/, false)
      && verifier.VerifyString(tablePos, 40 /*UpdatedAt*/, false)
      && verifier.VerifyString(tablePos, 42 /*UpdatedBy*/, false)
      && verifier.VerifyString(tablePos, 44 /*Source*/, false)
      && verifier.VerifyString(tablePos, 46 /*SourceDL*/, false)
      && verifier.VerifyString(tablePos, 48 /*Origin*/, false)
      && verifier.VerifyField(tablePos, 50 /*DataMode*/, 1 /*Port_Full_dataMode_Enum*/, 1, false)
      && verifier.VerifyString(tablePos, 52 /*OrigNetwork*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
