// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// These services provide operations for querying of all available missile track details and amplifying missile data. A missile track is a position and optionally a heading/velocity of an object across all environments at a particular timestamp. It also includes optional information regarding the identity/type of missile, impact location, launch location and other amplifying object data, if known.
public struct MissileTrack_Ingest : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static MissileTrack_Ingest GetRootAsMissileTrack_Ingest(ByteBuffer _bb) { return GetRootAsMissileTrack_Ingest(_bb, new MissileTrack_Ingest()); }
  public static MissileTrack_Ingest GetRootAsMissileTrack_Ingest(ByteBuffer _bb, MissileTrack_Ingest obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool MissileTrack_IngestBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "MISS"); }
  public static bool VerifyMissileTrack_Ingest(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("MISS", false, MissileTrack_IngestVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MissileTrack_Ingest __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Unique identifier of the record, auto-generated by the system if not provided on create operations.
  /// Example: /// Example: MissileTrack_ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string Id { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetIdBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetIdArray() { return __p.__vector_as_array<byte>(4); }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  public string ClassificationMarking { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetClassificationMarkingBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetClassificationMarkingBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetClassificationMarkingArray() { return __p.__vector_as_array<byte>(6); }
  /// The type of external message from which this request originated.
  /// Example: /// Example: MSG-TYPE
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string MsgType { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMsgTypeBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetMsgTypeBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetMsgTypeArray() { return __p.__vector_as_array<byte>(8); }
  /// The message subtype is a finer grain categorization of message types as many messages can contain a variety of data content within the same structure.  Examples include but are not limited to Initial, Final, Launch, Update, etc.  Users should consult the appropriate documentation, based on the message type, for the definitions of the subtypes that apply to that message.
  /// Example: /// Example: Update
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string MsgSubType { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMsgSubTypeBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetMsgSubTypeBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetMsgSubTypeArray() { return __p.__vector_as_array<byte>(10); }
  /// The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-04-25T08:17:01.346Z
  /// Constraints: No constraints specified.
  public string MsgCreateDate { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMsgCreateDateBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetMsgCreateDateBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetMsgCreateDateArray() { return __p.__vector_as_array<byte>(12); }
  /// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
  ///  AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///  LAND: On the surface of dry land.
  ///  SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///  SURFACE: On the surface of a body of water.
  ///  SUBSURFACE: Below the surface of a body of water.
  ///  UNKNOWN: Environment is not known.
  /// Example: /// Example: AIR
  /// Constraints: Minimum length = 0, Maximum length = 16
  public MissileTrack_Ingest_env_Enum Env { get { int o = __p.__offset(14); return o != 0 ? (MissileTrack_Ingest_env_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : MissileTrack_Ingest_env_Enum.AIR; } }
  /// The type of object to which this record refers. The object type may be updated in later records based on assessment of additional data.
  /// Example: /// Example: Ballistic
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string ObjType { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetObjTypeBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetObjTypeBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetObjTypeArray() { return __p.__vector_as_array<byte>(16); }
  /// Confidence of the object type, 0-100.
  /// Example: /// Example: 90
  /// Constraints: No constraints specified.
  public int ObjTypeConf { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Space Platform field along with the Space Activity field further defines the identity of a Space track (examples: SATELLITE, WEAPON, PATROL). The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
  /// Example: /// Example: WEAPON
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string ObjPlat { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetObjPlatBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetObjPlatBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetObjPlatArray() { return __p.__vector_as_array<byte>(20); }
  /// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
  ///  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  ///  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  ///  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  ///  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  ///  PENDING: Track object which has not been evaluated.
  ///  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  ///  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
  /// Example: /// Example: FRIEND
  /// Constraints: Minimum length = 0, Maximum length = 32
  public MissileTrack_Ingest_objIdent_Enum ObjIdent { get { int o = __p.__offset(22); return o != 0 ? (MissileTrack_Ingest_objIdent_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : MissileTrack_Ingest_objIdent_Enum.ASSUMED_FRIEND; } }
  /// Space amplification indicates additional information on the space environment being reported (examples: NUCLEAR WARHEAD, FUEL-AIR EXPLOSIVE WARHEAD, DEBRIS).
  /// Example: /// Example: NUCLEAR WARHEAD
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string SpaceAmp { get { int o = __p.__offset(24); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSpaceAmpBytes() { return __p.__vector_as_span<byte>(24, 1); }
#else
  public ArraySegment<byte>? GetSpaceAmpBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public byte[] GetSpaceAmpArray() { return __p.__vector_as_array<byte>(24); }
  /// Space activity (examples: RECONNAISSANCE, ANTISPACE WARFARE, TELEVISION). The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.
  /// Example: /// Example: HOLDING
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string ObjAct { get { int o = __p.__offset(26); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetObjActBytes() { return __p.__vector_as_span<byte>(26, 1); }
#else
  public ArraySegment<byte>? GetObjActBytes() { return __p.__vector_as_arraysegment(26); }
#endif
  public byte[] GetObjActArray() { return __p.__vector_as_array<byte>(26); }
  /// Specific type of point or track with an environment of space.
  /// Example: /// Example: SS-21_MOD_2_CRBM
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string SpaceSpecType { get { int o = __p.__offset(28); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSpaceSpecTypeBytes() { return __p.__vector_as_span<byte>(28, 1); }
#else
  public ArraySegment<byte>? GetSpaceSpecTypeBytes() { return __p.__vector_as_arraysegment(28); }
#endif
  public byte[] GetSpaceSpecTypeArray() { return __p.__vector_as_array<byte>(28); }
  /// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM. 
  /// &nbsp;SRBM - Short-Range Ballistic Missile
  /// &nbsp;MRBM - Medium-Range Ballistic Missile
  /// &nbsp;IRBM - Intermediate-Range Ballistic Missile
  /// &nbsp;LRBM - Long-Range Ballistic Missile
  /// &nbsp;ICBM - Intercontinental Ballistic Missile
  /// &nbsp;SLBM - Submarine-Launched Ballistic Missile.
  /// Example: /// Example: SLBM
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string AcftSubType { get { int o = __p.__offset(30); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAcftSubTypeBytes() { return __p.__vector_as_span<byte>(30, 1); }
#else
  public ArraySegment<byte>? GetAcftSubTypeBytes() { return __p.__vector_as_arraysegment(30); }
#endif
  public byte[] GetAcftSubTypeArray() { return __p.__vector_as_array<byte>(30); }
  /// Track name.
  /// Example: /// Example: TRACK-NAME
  /// Constraints: Minimum length = 0, Maximum length = 48
  public string Name { get { int o = __p.__offset(32); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(32, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(32); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(32); }
  /// The call sign currently assigned to the track object.
  /// Example: /// Example: Charlie
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string CallSign { get { int o = __p.__offset(34); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCallSignBytes() { return __p.__vector_as_span<byte>(34, 1); }
#else
  public ArraySegment<byte>? GetCallSignBytes() { return __p.__vector_as_arraysegment(34); }
#endif
  public byte[] GetCallSignArray() { return __p.__vector_as_array<byte>(34); }
  /// Indicates whether or not the missile is considered lost.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool LostTrkInd { get { int o = __p.__offset(36); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Track ID within the originating system.
  /// Example: /// Example: 102288
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string TrackId { get { int o = __p.__offset(38); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTrackIdBytes() { return __p.__vector_as_span<byte>(38, 1); }
#else
  public ArraySegment<byte>? GetTrackIdBytes() { return __p.__vector_as_arraysegment(38); }
#endif
  public byte[] GetTrackIdArray() { return __p.__vector_as_array<byte>(38); }
  /// Track ID of the parent track, within the originating system, from which the track was developed.
  /// Example: /// Example: 102288
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string ParentTrackId { get { int o = __p.__offset(40); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetParentTrackIdBytes() { return __p.__vector_as_span<byte>(40, 1); }
#else
  public ArraySegment<byte>? GetParentTrackIdBytes() { return __p.__vector_as_arraysegment(40); }
#endif
  public byte[] GetParentTrackIdArray() { return __p.__vector_as_array<byte>(40); }
  /// Track ID for the source of the missile-unique identifier.
  /// Example: /// Example: MUID-SRC-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string MuidSrcTrk { get { int o = __p.__offset(42); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMuidSrcTrkBytes() { return __p.__vector_as_span<byte>(42, 1); }
#else
  public ArraySegment<byte>? GetMuidSrcTrkBytes() { return __p.__vector_as_arraysegment(42); }
#endif
  public byte[] GetMuidSrcTrkArray() { return __p.__vector_as_array<byte>(42); }
  /// Source of the missile-unique identifier (MUID).
  /// Example: /// Example: MUID-SRC
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string MuidSrc { get { int o = __p.__offset(44); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMuidSrcBytes() { return __p.__vector_as_span<byte>(44, 1); }
#else
  public ArraySegment<byte>? GetMuidSrcBytes() { return __p.__vector_as_arraysegment(44); }
#endif
  public byte[] GetMuidSrcArray() { return __p.__vector_as_array<byte>(44); }
  /// A track may be designated as a non-alert track or an alert track.
  /// Examples include but are not limited to:
  /// &nbsp;Non-alert tracks – choose None (Blank).
  /// &nbsp;Alert tracks – enter the proper alert classification:
  /// &nbsp;HIT - High Interest Track
  /// &nbsp;TGT - Target
  /// &nbsp;SUS - Suspect Carrier
  /// &nbsp;NSP - Cleared Suspect.
  /// Example: /// Example: HIT
  /// Constraints: Minimum length = 0, Maximum length = 4
  public string Alert { get { int o = __p.__offset(46); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAlertBytes() { return __p.__vector_as_span<byte>(46, 1); }
#else
  public ArraySegment<byte>? GetAlertBytes() { return __p.__vector_as_arraysegment(46); }
#endif
  public byte[] GetAlertArray() { return __p.__vector_as_array<byte>(46); }
  /// Missile status enumeration examples include but are not limited to:
  /// &nbsp;AT LAUNCH 
  /// &nbsp;AT OBSERVATION 
  /// &nbsp;FLYING 
  /// &nbsp;IMPACTED 
  /// &nbsp;LOST 
  /// &nbsp;STALE
  /// &nbsp;DEBRIS.
  /// Example: /// Example: AT LAUNCH
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string MslStatus { get { int o = __p.__offset(48); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMslStatusBytes() { return __p.__vector_as_span<byte>(48, 1); }
#else
  public ArraySegment<byte>? GetMslStatusBytes() { return __p.__vector_as_arraysegment(48); }
#endif
  public byte[] GetMslStatusArray() { return __p.__vector_as_array<byte>(48); }
  /// The receipt time of the data by the processing system, in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string Ts { get { int o = __p.__offset(50); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTsBytes() { return __p.__vector_as_span<byte>(50, 1); }
#else
  public ArraySegment<byte>? GetTsBytes() { return __p.__vector_as_arraysegment(50); }
#endif
  public byte[] GetTsArray() { return __p.__vector_as_array<byte>(50); }
  /// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 40
  public string AouRptType { get { int o = __p.__offset(52); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAouRptTypeBytes() { return __p.__vector_as_span<byte>(52, 1); }
#else
  public ArraySegment<byte>? GetAouRptTypeBytes() { return __p.__vector_as_arraysegment(52); }
#endif
  public byte[] GetAouRptTypeArray() { return __p.__vector_as_array<byte>(52); }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
  /// &nbsp;ELLIPSE:
  /// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
  /// &nbsp;&nbsp;a1 - semi-major axis in kilometers
  /// &nbsp;&nbsp;a2 - semi-minor axis in kilometers
  /// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
  /// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
  /// &nbsp;&nbsp;a1 - length of bearing box in kilometers
  /// &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
  /// &nbsp;OTHER (All other type values):
  /// &nbsp;&nbsp;brg - line of bearing in degrees true
  /// &nbsp;&nbsp;a1 - bearing error in degrees
  /// &nbsp;&nbsp;a2 - estimated range in kilometers.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  public string AouRptData(int j) { int o = __p.__offset(54); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int AouRptDataLength { get { int o = __p.__offset(54); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The percentage of time that the estimated AoU will "cover" the true position of the track.
  /// Example: /// Example: 90.64
  /// Constraints: No constraints specified.
  public double Containment { get { int o = __p.__offset(56); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
  /// Example: /// Example: 0.95
  /// Constraints: No constraints specified.
  public double TrkConf { get { int o = __p.__offset(58); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track, with higher values indicating higher track quality; i.e., lower errors in reported position.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  public int TrkQual { get { int o = __p.__offset(60); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Angle of elevation/depression between observer and missile in degrees.
  /// Example: /// Example: 15.2
  /// Constraints: No constraints specified.
  public double AngElev { get { int o = __p.__offset(62); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Last report type received from the sensor (for example, OBSBO = observation burnout).
  /// Example: /// Example: OBSBO
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string SenMode { get { int o = __p.__offset(64); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSenModeBytes() { return __p.__vector_as_span<byte>(64, 1); }
#else
  public ArraySegment<byte>? GetSenModeBytes() { return __p.__vector_as_arraysegment(64); }
#endif
  public byte[] GetSenModeArray() { return __p.__vector_as_array<byte>(64); }
  /// Source code for source of information used to detect track.
  /// Example: /// Example: S1
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string InfoSource { get { int o = __p.__offset(66); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetInfoSourceBytes() { return __p.__vector_as_span<byte>(66, 1); }
#else
  public ArraySegment<byte>? GetInfoSourceBytes() { return __p.__vector_as_arraysegment(66); }
#endif
  public byte[] GetInfoSourceArray() { return __p.__vector_as_array<byte>(66); }
  /// Indicates whether or not the missile is currently in a state of boosting.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool Boosting { get { int o = __p.__offset(68); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Azimuth corridor reference point latitude.
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  public double PolarSingLocLat { get { int o = __p.__offset(70); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Azimuth corridor reference point longitude.
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  public double PolarSingLocLon { get { int o = __p.__offset(72); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Indicates whether or not a track has an emergency.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool EmgInd { get { int o = __p.__offset(74); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The drop-point indicator setting.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool DropPtInd { get { int o = __p.__offset(76); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Confidence level of the amplifying characteristics. Values range from 0 to 6.
  /// Example: /// Example: 6
  /// Constraints: No constraints specified.
  public int SpaceAmpConf { get { int o = __p.__offset(78); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string LaunchTime { get { int o = __p.__offset(80); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLaunchTimeBytes() { return __p.__vector_as_span<byte>(80, 1); }
#else
  public ArraySegment<byte>? GetLaunchTimeBytes() { return __p.__vector_as_arraysegment(80); }
#endif
  public byte[] GetLaunchTimeArray() { return __p.__vector_as_array<byte>(80); }
  /// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  public double LaunchLat { get { int o = __p.__offset(82); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  public double LaunchLon { get { int o = __p.__offset(84); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Missile azimuth corridor data.
  /// Example: /// Example: 12.876
  /// Constraints: No constraints specified.
  public double AzCorr { get { int o = __p.__offset(86); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Track point burnout altitude relative to WGS-84 ellipsoid, in kilometers.
  /// Example: /// Example: 30567.452
  /// Constraints: No constraints specified.
  public double BurnoutAlt { get { int o = __p.__offset(88); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 40
  public string LaunchAouType { get { int o = __p.__offset(90); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLaunchAouTypeBytes() { return __p.__vector_as_span<byte>(90, 1); }
#else
  public ArraySegment<byte>? GetLaunchAouTypeBytes() { return __p.__vector_as_arraysegment(90); }
#endif
  public byte[] GetLaunchAouTypeArray() { return __p.__vector_as_array<byte>(90); }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
  /// &nbsp;ELLIPSE:
  /// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
  /// &nbsp;&nbsp;a1 - semi-major axis in kilometers
  /// &nbsp;&nbsp;a2 - semi-minor axis in kilometers
  /// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
  /// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
  /// &nbsp;&nbsp;a1 - length of bearing box in kilometers
  /// &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
  /// &nbsp;OTHER (All other type values):
  /// &nbsp;&nbsp;brg - line of bearing in degrees true
  /// &nbsp;&nbsp;a1 - bearing error in degrees
  /// &nbsp;&nbsp;a2 - estimated range in kilometers.
  /// Example: /// Example: [1.23, 2.34, 3.45]
  /// Constraints: No constraints specified.
  public string LaunchAouData(int j) { int o = __p.__offset(92); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int LaunchAouDataLength { get { int o = __p.__offset(92); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Estimated time of impact timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string ImpactTime { get { int o = __p.__offset(94); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetImpactTimeBytes() { return __p.__vector_as_span<byte>(94, 1); }
#else
  public ArraySegment<byte>? GetImpactTimeBytes() { return __p.__vector_as_arraysegment(94); }
#endif
  public byte[] GetImpactTimeArray() { return __p.__vector_as_array<byte>(94); }
  /// WGS-84 latitude of the missile object impact point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  public double ImpactLat { get { int o = __p.__offset(96); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS-84 longitude of the missile object impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  public double ImpactLon { get { int o = __p.__offset(98); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 40
  public string ImpactAouType { get { int o = __p.__offset(100); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetImpactAouTypeBytes() { return __p.__vector_as_span<byte>(100, 1); }
#else
  public ArraySegment<byte>? GetImpactAouTypeBytes() { return __p.__vector_as_arraysegment(100); }
#endif
  public byte[] GetImpactAouTypeArray() { return __p.__vector_as_array<byte>(100); }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
  /// &nbsp;ELLIPSE:
  /// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
  /// &nbsp;&nbsp;a1 - semi-major axis in kilometers
  /// &nbsp;&nbsp;a2 - semi-minor axis in kilometers
  /// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
  /// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
  /// &nbsp;&nbsp;a1 - length of bearing box in kilometers
  /// &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
  /// &nbsp;OTHER (All other type values):
  /// &nbsp;&nbsp;brg - line of bearing in degrees true
  /// &nbsp;&nbsp;a1 - bearing error in degrees
  /// &nbsp;&nbsp;a2 - estimated range in kilometers.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  public string ImpactAouData(int j) { int o = __p.__offset(102); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int ImpactAouDataLength { get { int o = __p.__offset(102); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Array of MissileTrackVector objects. Missile track vectors are cartesian vectors of position, velocity, and acceleration that, together with their time, 'epoch', uniquely determine the trajectory of the missile. ECEF is the preferred coordinate frame but in some cases data may be in another frame as specified by 'referenceFrame', depending on the provider.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  public string Vectors(int j) { int o = __p.__offset(104); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int VectorsLength { get { int o = __p.__offset(104); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string OrigNetwork { get { int o = __p.__offset(106); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOrigNetworkBytes() { return __p.__vector_as_span<byte>(106, 1); }
#else
  public ArraySegment<byte>? GetOrigNetworkBytes() { return __p.__vector_as_arraysegment(106); }
#endif
  public byte[] GetOrigNetworkArray() { return __p.__vector_as_array<byte>(106); }
  /// Time the row was created in the database.
  /// Example: /// Example: 2021-02-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  public string CreatedAt { get { int o = __p.__offset(108); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedAtBytes() { return __p.__vector_as_span<byte>(108, 1); }
#else
  public ArraySegment<byte>? GetCreatedAtBytes() { return __p.__vector_as_arraysegment(108); }
#endif
  public byte[] GetCreatedAtArray() { return __p.__vector_as_array<byte>(108); }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string CreatedBy { get { int o = __p.__offset(110); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedByBytes() { return __p.__vector_as_span<byte>(110, 1); }
#else
  public ArraySegment<byte>? GetCreatedByBytes() { return __p.__vector_as_arraysegment(110); }
#endif
  public byte[] GetCreatedByArray() { return __p.__vector_as_array<byte>(110); }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string Source { get { int o = __p.__offset(112); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceBytes() { return __p.__vector_as_span<byte>(112, 1); }
#else
  public ArraySegment<byte>? GetSourceBytes() { return __p.__vector_as_arraysegment(112); }
#endif
  public byte[] GetSourceArray() { return __p.__vector_as_array<byte>(112); }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Origin { get { int o = __p.__offset(114); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOriginBytes() { return __p.__vector_as_span<byte>(114, 1); }
#else
  public ArraySegment<byte>? GetOriginBytes() { return __p.__vector_as_arraysegment(114); }
#endif
  public byte[] GetOriginArray() { return __p.__vector_as_array<byte>(114); }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  public MissileTrack_Ingest_dataMode_Enum DataMode { get { int o = __p.__offset(116); return o != 0 ? (MissileTrack_Ingest_dataMode_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : MissileTrack_Ingest_dataMode_Enum.REAL; } }

  public static Offset<MissileTrack_Ingest> CreateMissileTrack_Ingest(FlatBufferBuilder builder,
      StringOffset idOffset = default(StringOffset),
      StringOffset classificationMarkingOffset = default(StringOffset),
      StringOffset msgTypeOffset = default(StringOffset),
      StringOffset msgSubTypeOffset = default(StringOffset),
      StringOffset msgCreateDateOffset = default(StringOffset),
      MissileTrack_Ingest_env_Enum env = MissileTrack_Ingest_env_Enum.AIR,
      StringOffset objTypeOffset = default(StringOffset),
      int objTypeConf = 0,
      StringOffset objPlatOffset = default(StringOffset),
      MissileTrack_Ingest_objIdent_Enum objIdent = MissileTrack_Ingest_objIdent_Enum.ASSUMED_FRIEND,
      StringOffset spaceAmpOffset = default(StringOffset),
      StringOffset objActOffset = default(StringOffset),
      StringOffset spaceSpecTypeOffset = default(StringOffset),
      StringOffset acftSubTypeOffset = default(StringOffset),
      StringOffset nameOffset = default(StringOffset),
      StringOffset callSignOffset = default(StringOffset),
      bool lostTrkInd = false,
      StringOffset trackIdOffset = default(StringOffset),
      StringOffset parentTrackIdOffset = default(StringOffset),
      StringOffset muidSrcTrkOffset = default(StringOffset),
      StringOffset muidSrcOffset = default(StringOffset),
      StringOffset alertOffset = default(StringOffset),
      StringOffset mslStatusOffset = default(StringOffset),
      StringOffset tsOffset = default(StringOffset),
      StringOffset aouRptTypeOffset = default(StringOffset),
      VectorOffset aouRptDataOffset = default(VectorOffset),
      double containment = 0.0,
      double trkConf = 0.0,
      int trkQual = 0,
      double angElev = 0.0,
      StringOffset senModeOffset = default(StringOffset),
      StringOffset infoSourceOffset = default(StringOffset),
      bool boosting = false,
      double polarSingLocLat = 0.0,
      double polarSingLocLon = 0.0,
      bool emgInd = false,
      bool dropPtInd = false,
      int spaceAmpConf = 0,
      StringOffset launchTimeOffset = default(StringOffset),
      double launchLat = 0.0,
      double launchLon = 0.0,
      double azCorr = 0.0,
      double burnoutAlt = 0.0,
      StringOffset launchAouTypeOffset = default(StringOffset),
      VectorOffset launchAouDataOffset = default(VectorOffset),
      StringOffset impactTimeOffset = default(StringOffset),
      double impactLat = 0.0,
      double impactLon = 0.0,
      StringOffset impactAouTypeOffset = default(StringOffset),
      VectorOffset impactAouDataOffset = default(VectorOffset),
      VectorOffset vectorsOffset = default(VectorOffset),
      StringOffset origNetworkOffset = default(StringOffset),
      StringOffset createdAtOffset = default(StringOffset),
      StringOffset createdByOffset = default(StringOffset),
      StringOffset sourceOffset = default(StringOffset),
      StringOffset originOffset = default(StringOffset),
      MissileTrack_Ingest_dataMode_Enum dataMode = MissileTrack_Ingest_dataMode_Enum.REAL) {
    builder.StartTable(57);
    MissileTrack_Ingest.AddImpactLon(builder, impactLon);
    MissileTrack_Ingest.AddImpactLat(builder, impactLat);
    MissileTrack_Ingest.AddBurnoutAlt(builder, burnoutAlt);
    MissileTrack_Ingest.AddAzCorr(builder, azCorr);
    MissileTrack_Ingest.AddLaunchLon(builder, launchLon);
    MissileTrack_Ingest.AddLaunchLat(builder, launchLat);
    MissileTrack_Ingest.AddPolarSingLocLon(builder, polarSingLocLon);
    MissileTrack_Ingest.AddPolarSingLocLat(builder, polarSingLocLat);
    MissileTrack_Ingest.AddAngElev(builder, angElev);
    MissileTrack_Ingest.AddTrkConf(builder, trkConf);
    MissileTrack_Ingest.AddContainment(builder, containment);
    MissileTrack_Ingest.AddOrigin(builder, originOffset);
    MissileTrack_Ingest.AddSource(builder, sourceOffset);
    MissileTrack_Ingest.AddCreatedBy(builder, createdByOffset);
    MissileTrack_Ingest.AddCreatedAt(builder, createdAtOffset);
    MissileTrack_Ingest.AddOrigNetwork(builder, origNetworkOffset);
    MissileTrack_Ingest.AddVectors(builder, vectorsOffset);
    MissileTrack_Ingest.AddImpactAouData(builder, impactAouDataOffset);
    MissileTrack_Ingest.AddImpactAouType(builder, impactAouTypeOffset);
    MissileTrack_Ingest.AddImpactTime(builder, impactTimeOffset);
    MissileTrack_Ingest.AddLaunchAouData(builder, launchAouDataOffset);
    MissileTrack_Ingest.AddLaunchAouType(builder, launchAouTypeOffset);
    MissileTrack_Ingest.AddLaunchTime(builder, launchTimeOffset);
    MissileTrack_Ingest.AddSpaceAmpConf(builder, spaceAmpConf);
    MissileTrack_Ingest.AddInfoSource(builder, infoSourceOffset);
    MissileTrack_Ingest.AddSenMode(builder, senModeOffset);
    MissileTrack_Ingest.AddTrkQual(builder, trkQual);
    MissileTrack_Ingest.AddAouRptData(builder, aouRptDataOffset);
    MissileTrack_Ingest.AddAouRptType(builder, aouRptTypeOffset);
    MissileTrack_Ingest.AddTs(builder, tsOffset);
    MissileTrack_Ingest.AddMslStatus(builder, mslStatusOffset);
    MissileTrack_Ingest.AddAlert(builder, alertOffset);
    MissileTrack_Ingest.AddMuidSrc(builder, muidSrcOffset);
    MissileTrack_Ingest.AddMuidSrcTrk(builder, muidSrcTrkOffset);
    MissileTrack_Ingest.AddParentTrackId(builder, parentTrackIdOffset);
    MissileTrack_Ingest.AddTrackId(builder, trackIdOffset);
    MissileTrack_Ingest.AddCallSign(builder, callSignOffset);
    MissileTrack_Ingest.AddName(builder, nameOffset);
    MissileTrack_Ingest.AddAcftSubType(builder, acftSubTypeOffset);
    MissileTrack_Ingest.AddSpaceSpecType(builder, spaceSpecTypeOffset);
    MissileTrack_Ingest.AddObjAct(builder, objActOffset);
    MissileTrack_Ingest.AddSpaceAmp(builder, spaceAmpOffset);
    MissileTrack_Ingest.AddObjPlat(builder, objPlatOffset);
    MissileTrack_Ingest.AddObjTypeConf(builder, objTypeConf);
    MissileTrack_Ingest.AddObjType(builder, objTypeOffset);
    MissileTrack_Ingest.AddMsgCreateDate(builder, msgCreateDateOffset);
    MissileTrack_Ingest.AddMsgSubType(builder, msgSubTypeOffset);
    MissileTrack_Ingest.AddMsgType(builder, msgTypeOffset);
    MissileTrack_Ingest.AddClassificationMarking(builder, classificationMarkingOffset);
    MissileTrack_Ingest.AddId(builder, idOffset);
    MissileTrack_Ingest.AddDataMode(builder, dataMode);
    MissileTrack_Ingest.AddDropPtInd(builder, dropPtInd);
    MissileTrack_Ingest.AddEmgInd(builder, emgInd);
    MissileTrack_Ingest.AddBoosting(builder, boosting);
    MissileTrack_Ingest.AddLostTrkInd(builder, lostTrkInd);
    MissileTrack_Ingest.AddObjIdent(builder, objIdent);
    MissileTrack_Ingest.AddEnv(builder, env);
    return MissileTrack_Ingest.EndMissileTrack_Ingest(builder);
  }

  public static void StartMissileTrack_Ingest(FlatBufferBuilder builder) { builder.StartTable(57); }
  public static void AddId(FlatBufferBuilder builder, StringOffset idOffset) { builder.AddOffset(0, idOffset.Value, 0); }
  public static void AddClassificationMarking(FlatBufferBuilder builder, StringOffset classificationMarkingOffset) { builder.AddOffset(1, classificationMarkingOffset.Value, 0); }
  public static void AddMsgType(FlatBufferBuilder builder, StringOffset msgTypeOffset) { builder.AddOffset(2, msgTypeOffset.Value, 0); }
  public static void AddMsgSubType(FlatBufferBuilder builder, StringOffset msgSubTypeOffset) { builder.AddOffset(3, msgSubTypeOffset.Value, 0); }
  public static void AddMsgCreateDate(FlatBufferBuilder builder, StringOffset msgCreateDateOffset) { builder.AddOffset(4, msgCreateDateOffset.Value, 0); }
  public static void AddEnv(FlatBufferBuilder builder, MissileTrack_Ingest_env_Enum env) { builder.AddSbyte(5, (sbyte)env, 0); }
  public static void AddObjType(FlatBufferBuilder builder, StringOffset objTypeOffset) { builder.AddOffset(6, objTypeOffset.Value, 0); }
  public static void AddObjTypeConf(FlatBufferBuilder builder, int objTypeConf) { builder.AddInt(7, objTypeConf, 0); }
  public static void AddObjPlat(FlatBufferBuilder builder, StringOffset objPlatOffset) { builder.AddOffset(8, objPlatOffset.Value, 0); }
  public static void AddObjIdent(FlatBufferBuilder builder, MissileTrack_Ingest_objIdent_Enum objIdent) { builder.AddSbyte(9, (sbyte)objIdent, 0); }
  public static void AddSpaceAmp(FlatBufferBuilder builder, StringOffset spaceAmpOffset) { builder.AddOffset(10, spaceAmpOffset.Value, 0); }
  public static void AddObjAct(FlatBufferBuilder builder, StringOffset objActOffset) { builder.AddOffset(11, objActOffset.Value, 0); }
  public static void AddSpaceSpecType(FlatBufferBuilder builder, StringOffset spaceSpecTypeOffset) { builder.AddOffset(12, spaceSpecTypeOffset.Value, 0); }
  public static void AddAcftSubType(FlatBufferBuilder builder, StringOffset acftSubTypeOffset) { builder.AddOffset(13, acftSubTypeOffset.Value, 0); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(14, nameOffset.Value, 0); }
  public static void AddCallSign(FlatBufferBuilder builder, StringOffset callSignOffset) { builder.AddOffset(15, callSignOffset.Value, 0); }
  public static void AddLostTrkInd(FlatBufferBuilder builder, bool lostTrkInd) { builder.AddBool(16, lostTrkInd, false); }
  public static void AddTrackId(FlatBufferBuilder builder, StringOffset trackIdOffset) { builder.AddOffset(17, trackIdOffset.Value, 0); }
  public static void AddParentTrackId(FlatBufferBuilder builder, StringOffset parentTrackIdOffset) { builder.AddOffset(18, parentTrackIdOffset.Value, 0); }
  public static void AddMuidSrcTrk(FlatBufferBuilder builder, StringOffset muidSrcTrkOffset) { builder.AddOffset(19, muidSrcTrkOffset.Value, 0); }
  public static void AddMuidSrc(FlatBufferBuilder builder, StringOffset muidSrcOffset) { builder.AddOffset(20, muidSrcOffset.Value, 0); }
  public static void AddAlert(FlatBufferBuilder builder, StringOffset alertOffset) { builder.AddOffset(21, alertOffset.Value, 0); }
  public static void AddMslStatus(FlatBufferBuilder builder, StringOffset mslStatusOffset) { builder.AddOffset(22, mslStatusOffset.Value, 0); }
  public static void AddTs(FlatBufferBuilder builder, StringOffset tsOffset) { builder.AddOffset(23, tsOffset.Value, 0); }
  public static void AddAouRptType(FlatBufferBuilder builder, StringOffset aouRptTypeOffset) { builder.AddOffset(24, aouRptTypeOffset.Value, 0); }
  public static void AddAouRptData(FlatBufferBuilder builder, VectorOffset aouRptDataOffset) { builder.AddOffset(25, aouRptDataOffset.Value, 0); }
  public static VectorOffset CreateAouRptDataVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAouRptDataVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAouRptDataVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAouRptDataVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAouRptDataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddContainment(FlatBufferBuilder builder, double containment) { builder.AddDouble(26, containment, 0.0); }
  public static void AddTrkConf(FlatBufferBuilder builder, double trkConf) { builder.AddDouble(27, trkConf, 0.0); }
  public static void AddTrkQual(FlatBufferBuilder builder, int trkQual) { builder.AddInt(28, trkQual, 0); }
  public static void AddAngElev(FlatBufferBuilder builder, double angElev) { builder.AddDouble(29, angElev, 0.0); }
  public static void AddSenMode(FlatBufferBuilder builder, StringOffset senModeOffset) { builder.AddOffset(30, senModeOffset.Value, 0); }
  public static void AddInfoSource(FlatBufferBuilder builder, StringOffset infoSourceOffset) { builder.AddOffset(31, infoSourceOffset.Value, 0); }
  public static void AddBoosting(FlatBufferBuilder builder, bool boosting) { builder.AddBool(32, boosting, false); }
  public static void AddPolarSingLocLat(FlatBufferBuilder builder, double polarSingLocLat) { builder.AddDouble(33, polarSingLocLat, 0.0); }
  public static void AddPolarSingLocLon(FlatBufferBuilder builder, double polarSingLocLon) { builder.AddDouble(34, polarSingLocLon, 0.0); }
  public static void AddEmgInd(FlatBufferBuilder builder, bool emgInd) { builder.AddBool(35, emgInd, false); }
  public static void AddDropPtInd(FlatBufferBuilder builder, bool dropPtInd) { builder.AddBool(36, dropPtInd, false); }
  public static void AddSpaceAmpConf(FlatBufferBuilder builder, int spaceAmpConf) { builder.AddInt(37, spaceAmpConf, 0); }
  public static void AddLaunchTime(FlatBufferBuilder builder, StringOffset launchTimeOffset) { builder.AddOffset(38, launchTimeOffset.Value, 0); }
  public static void AddLaunchLat(FlatBufferBuilder builder, double launchLat) { builder.AddDouble(39, launchLat, 0.0); }
  public static void AddLaunchLon(FlatBufferBuilder builder, double launchLon) { builder.AddDouble(40, launchLon, 0.0); }
  public static void AddAzCorr(FlatBufferBuilder builder, double azCorr) { builder.AddDouble(41, azCorr, 0.0); }
  public static void AddBurnoutAlt(FlatBufferBuilder builder, double burnoutAlt) { builder.AddDouble(42, burnoutAlt, 0.0); }
  public static void AddLaunchAouType(FlatBufferBuilder builder, StringOffset launchAouTypeOffset) { builder.AddOffset(43, launchAouTypeOffset.Value, 0); }
  public static void AddLaunchAouData(FlatBufferBuilder builder, VectorOffset launchAouDataOffset) { builder.AddOffset(44, launchAouDataOffset.Value, 0); }
  public static VectorOffset CreateLaunchAouDataVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateLaunchAouDataVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLaunchAouDataVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLaunchAouDataVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartLaunchAouDataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddImpactTime(FlatBufferBuilder builder, StringOffset impactTimeOffset) { builder.AddOffset(45, impactTimeOffset.Value, 0); }
  public static void AddImpactLat(FlatBufferBuilder builder, double impactLat) { builder.AddDouble(46, impactLat, 0.0); }
  public static void AddImpactLon(FlatBufferBuilder builder, double impactLon) { builder.AddDouble(47, impactLon, 0.0); }
  public static void AddImpactAouType(FlatBufferBuilder builder, StringOffset impactAouTypeOffset) { builder.AddOffset(48, impactAouTypeOffset.Value, 0); }
  public static void AddImpactAouData(FlatBufferBuilder builder, VectorOffset impactAouDataOffset) { builder.AddOffset(49, impactAouDataOffset.Value, 0); }
  public static VectorOffset CreateImpactAouDataVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateImpactAouDataVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateImpactAouDataVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateImpactAouDataVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartImpactAouDataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddVectors(FlatBufferBuilder builder, VectorOffset vectorsOffset) { builder.AddOffset(50, vectorsOffset.Value, 0); }
  public static VectorOffset CreateVectorsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateVectorsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartVectorsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddOrigNetwork(FlatBufferBuilder builder, StringOffset origNetworkOffset) { builder.AddOffset(51, origNetworkOffset.Value, 0); }
  public static void AddCreatedAt(FlatBufferBuilder builder, StringOffset createdAtOffset) { builder.AddOffset(52, createdAtOffset.Value, 0); }
  public static void AddCreatedBy(FlatBufferBuilder builder, StringOffset createdByOffset) { builder.AddOffset(53, createdByOffset.Value, 0); }
  public static void AddSource(FlatBufferBuilder builder, StringOffset sourceOffset) { builder.AddOffset(54, sourceOffset.Value, 0); }
  public static void AddOrigin(FlatBufferBuilder builder, StringOffset originOffset) { builder.AddOffset(55, originOffset.Value, 0); }
  public static void AddDataMode(FlatBufferBuilder builder, MissileTrack_Ingest_dataMode_Enum dataMode) { builder.AddSbyte(56, (sbyte)dataMode, 0); }
  public static Offset<MissileTrack_Ingest> EndMissileTrack_Ingest(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<MissileTrack_Ingest>(o);
  }
  public static void FinishMissileTrack_IngestBuffer(FlatBufferBuilder builder, Offset<MissileTrack_Ingest> offset) { builder.Finish(offset.Value, "MISS"); }
  public static void FinishSizePrefixedMissileTrack_IngestBuffer(FlatBufferBuilder builder, Offset<MissileTrack_Ingest> offset) { builder.FinishSizePrefixed(offset.Value, "MISS"); }
  public MissileTrack_IngestT UnPack() {
    var _o = new MissileTrack_IngestT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MissileTrack_IngestT _o) {
    _o.Id = this.Id;
    _o.ClassificationMarking = this.ClassificationMarking;
    _o.MsgType = this.MsgType;
    _o.MsgSubType = this.MsgSubType;
    _o.MsgCreateDate = this.MsgCreateDate;
    _o.Env = this.Env;
    _o.ObjType = this.ObjType;
    _o.ObjTypeConf = this.ObjTypeConf;
    _o.ObjPlat = this.ObjPlat;
    _o.ObjIdent = this.ObjIdent;
    _o.SpaceAmp = this.SpaceAmp;
    _o.ObjAct = this.ObjAct;
    _o.SpaceSpecType = this.SpaceSpecType;
    _o.AcftSubType = this.AcftSubType;
    _o.Name = this.Name;
    _o.CallSign = this.CallSign;
    _o.LostTrkInd = this.LostTrkInd;
    _o.TrackId = this.TrackId;
    _o.ParentTrackId = this.ParentTrackId;
    _o.MuidSrcTrk = this.MuidSrcTrk;
    _o.MuidSrc = this.MuidSrc;
    _o.Alert = this.Alert;
    _o.MslStatus = this.MslStatus;
    _o.Ts = this.Ts;
    _o.AouRptType = this.AouRptType;
    _o.AouRptData = new List<string>();
    for (var _j = 0; _j < this.AouRptDataLength; ++_j) {_o.AouRptData.Add(this.AouRptData(_j));}
    _o.Containment = this.Containment;
    _o.TrkConf = this.TrkConf;
    _o.TrkQual = this.TrkQual;
    _o.AngElev = this.AngElev;
    _o.SenMode = this.SenMode;
    _o.InfoSource = this.InfoSource;
    _o.Boosting = this.Boosting;
    _o.PolarSingLocLat = this.PolarSingLocLat;
    _o.PolarSingLocLon = this.PolarSingLocLon;
    _o.EmgInd = this.EmgInd;
    _o.DropPtInd = this.DropPtInd;
    _o.SpaceAmpConf = this.SpaceAmpConf;
    _o.LaunchTime = this.LaunchTime;
    _o.LaunchLat = this.LaunchLat;
    _o.LaunchLon = this.LaunchLon;
    _o.AzCorr = this.AzCorr;
    _o.BurnoutAlt = this.BurnoutAlt;
    _o.LaunchAouType = this.LaunchAouType;
    _o.LaunchAouData = new List<string>();
    for (var _j = 0; _j < this.LaunchAouDataLength; ++_j) {_o.LaunchAouData.Add(this.LaunchAouData(_j));}
    _o.ImpactTime = this.ImpactTime;
    _o.ImpactLat = this.ImpactLat;
    _o.ImpactLon = this.ImpactLon;
    _o.ImpactAouType = this.ImpactAouType;
    _o.ImpactAouData = new List<string>();
    for (var _j = 0; _j < this.ImpactAouDataLength; ++_j) {_o.ImpactAouData.Add(this.ImpactAouData(_j));}
    _o.Vectors = new List<string>();
    for (var _j = 0; _j < this.VectorsLength; ++_j) {_o.Vectors.Add(this.Vectors(_j));}
    _o.OrigNetwork = this.OrigNetwork;
    _o.CreatedAt = this.CreatedAt;
    _o.CreatedBy = this.CreatedBy;
    _o.Source = this.Source;
    _o.Origin = this.Origin;
    _o.DataMode = this.DataMode;
  }
  public static Offset<MissileTrack_Ingest> Pack(FlatBufferBuilder builder, MissileTrack_IngestT _o) {
    if (_o == null) return default(Offset<MissileTrack_Ingest>);
    var _id = _o.Id == null ? default(StringOffset) : builder.CreateString(_o.Id);
    var _classificationMarking = _o.ClassificationMarking == null ? default(StringOffset) : builder.CreateString(_o.ClassificationMarking);
    var _msgType = _o.MsgType == null ? default(StringOffset) : builder.CreateString(_o.MsgType);
    var _msgSubType = _o.MsgSubType == null ? default(StringOffset) : builder.CreateString(_o.MsgSubType);
    var _msgCreateDate = _o.MsgCreateDate == null ? default(StringOffset) : builder.CreateString(_o.MsgCreateDate);
    var _objType = _o.ObjType == null ? default(StringOffset) : builder.CreateString(_o.ObjType);
    var _objPlat = _o.ObjPlat == null ? default(StringOffset) : builder.CreateString(_o.ObjPlat);
    var _spaceAmp = _o.SpaceAmp == null ? default(StringOffset) : builder.CreateString(_o.SpaceAmp);
    var _objAct = _o.ObjAct == null ? default(StringOffset) : builder.CreateString(_o.ObjAct);
    var _spaceSpecType = _o.SpaceSpecType == null ? default(StringOffset) : builder.CreateString(_o.SpaceSpecType);
    var _acftSubType = _o.AcftSubType == null ? default(StringOffset) : builder.CreateString(_o.AcftSubType);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _callSign = _o.CallSign == null ? default(StringOffset) : builder.CreateString(_o.CallSign);
    var _trackId = _o.TrackId == null ? default(StringOffset) : builder.CreateString(_o.TrackId);
    var _parentTrackId = _o.ParentTrackId == null ? default(StringOffset) : builder.CreateString(_o.ParentTrackId);
    var _muidSrcTrk = _o.MuidSrcTrk == null ? default(StringOffset) : builder.CreateString(_o.MuidSrcTrk);
    var _muidSrc = _o.MuidSrc == null ? default(StringOffset) : builder.CreateString(_o.MuidSrc);
    var _alert = _o.Alert == null ? default(StringOffset) : builder.CreateString(_o.Alert);
    var _mslStatus = _o.MslStatus == null ? default(StringOffset) : builder.CreateString(_o.MslStatus);
    var _ts = _o.Ts == null ? default(StringOffset) : builder.CreateString(_o.Ts);
    var _aouRptType = _o.AouRptType == null ? default(StringOffset) : builder.CreateString(_o.AouRptType);
    var _aouRptData = default(VectorOffset);
    if (_o.AouRptData != null) {
      var __aouRptData = new StringOffset[_o.AouRptData.Count];
      for (var _j = 0; _j < __aouRptData.Length; ++_j) { __aouRptData[_j] = builder.CreateString(_o.AouRptData[_j]); }
      _aouRptData = CreateAouRptDataVector(builder, __aouRptData);
    }
    var _senMode = _o.SenMode == null ? default(StringOffset) : builder.CreateString(_o.SenMode);
    var _infoSource = _o.InfoSource == null ? default(StringOffset) : builder.CreateString(_o.InfoSource);
    var _launchTime = _o.LaunchTime == null ? default(StringOffset) : builder.CreateString(_o.LaunchTime);
    var _launchAouType = _o.LaunchAouType == null ? default(StringOffset) : builder.CreateString(_o.LaunchAouType);
    var _launchAouData = default(VectorOffset);
    if (_o.LaunchAouData != null) {
      var __launchAouData = new StringOffset[_o.LaunchAouData.Count];
      for (var _j = 0; _j < __launchAouData.Length; ++_j) { __launchAouData[_j] = builder.CreateString(_o.LaunchAouData[_j]); }
      _launchAouData = CreateLaunchAouDataVector(builder, __launchAouData);
    }
    var _impactTime = _o.ImpactTime == null ? default(StringOffset) : builder.CreateString(_o.ImpactTime);
    var _impactAouType = _o.ImpactAouType == null ? default(StringOffset) : builder.CreateString(_o.ImpactAouType);
    var _impactAouData = default(VectorOffset);
    if (_o.ImpactAouData != null) {
      var __impactAouData = new StringOffset[_o.ImpactAouData.Count];
      for (var _j = 0; _j < __impactAouData.Length; ++_j) { __impactAouData[_j] = builder.CreateString(_o.ImpactAouData[_j]); }
      _impactAouData = CreateImpactAouDataVector(builder, __impactAouData);
    }
    var _vectors = default(VectorOffset);
    if (_o.Vectors != null) {
      var __vectors = new StringOffset[_o.Vectors.Count];
      for (var _j = 0; _j < __vectors.Length; ++_j) { __vectors[_j] = builder.CreateString(_o.Vectors[_j]); }
      _vectors = CreateVectorsVector(builder, __vectors);
    }
    var _origNetwork = _o.OrigNetwork == null ? default(StringOffset) : builder.CreateString(_o.OrigNetwork);
    var _createdAt = _o.CreatedAt == null ? default(StringOffset) : builder.CreateString(_o.CreatedAt);
    var _createdBy = _o.CreatedBy == null ? default(StringOffset) : builder.CreateString(_o.CreatedBy);
    var _source = _o.Source == null ? default(StringOffset) : builder.CreateString(_o.Source);
    var _origin = _o.Origin == null ? default(StringOffset) : builder.CreateString(_o.Origin);
    return CreateMissileTrack_Ingest(
      builder,
      _id,
      _classificationMarking,
      _msgType,
      _msgSubType,
      _msgCreateDate,
      _o.Env,
      _objType,
      _o.ObjTypeConf,
      _objPlat,
      _o.ObjIdent,
      _spaceAmp,
      _objAct,
      _spaceSpecType,
      _acftSubType,
      _name,
      _callSign,
      _o.LostTrkInd,
      _trackId,
      _parentTrackId,
      _muidSrcTrk,
      _muidSrc,
      _alert,
      _mslStatus,
      _ts,
      _aouRptType,
      _aouRptData,
      _o.Containment,
      _o.TrkConf,
      _o.TrkQual,
      _o.AngElev,
      _senMode,
      _infoSource,
      _o.Boosting,
      _o.PolarSingLocLat,
      _o.PolarSingLocLon,
      _o.EmgInd,
      _o.DropPtInd,
      _o.SpaceAmpConf,
      _launchTime,
      _o.LaunchLat,
      _o.LaunchLon,
      _o.AzCorr,
      _o.BurnoutAlt,
      _launchAouType,
      _launchAouData,
      _impactTime,
      _o.ImpactLat,
      _o.ImpactLon,
      _impactAouType,
      _impactAouData,
      _vectors,
      _origNetwork,
      _createdAt,
      _createdBy,
      _source,
      _origin,
      _o.DataMode);
  }
}

public class MissileTrack_IngestT
{
  public string Id { get; set; }
  public string ClassificationMarking { get; set; }
  public string MsgType { get; set; }
  public string MsgSubType { get; set; }
  public string MsgCreateDate { get; set; }
  public MissileTrack_Ingest_env_Enum Env { get; set; }
  public string ObjType { get; set; }
  public int ObjTypeConf { get; set; }
  public string ObjPlat { get; set; }
  public MissileTrack_Ingest_objIdent_Enum ObjIdent { get; set; }
  public string SpaceAmp { get; set; }
  public string ObjAct { get; set; }
  public string SpaceSpecType { get; set; }
  public string AcftSubType { get; set; }
  public string Name { get; set; }
  public string CallSign { get; set; }
  public bool LostTrkInd { get; set; }
  public string TrackId { get; set; }
  public string ParentTrackId { get; set; }
  public string MuidSrcTrk { get; set; }
  public string MuidSrc { get; set; }
  public string Alert { get; set; }
  public string MslStatus { get; set; }
  public string Ts { get; set; }
  public string AouRptType { get; set; }
  public List<string> AouRptData { get; set; }
  public double Containment { get; set; }
  public double TrkConf { get; set; }
  public int TrkQual { get; set; }
  public double AngElev { get; set; }
  public string SenMode { get; set; }
  public string InfoSource { get; set; }
  public bool Boosting { get; set; }
  public double PolarSingLocLat { get; set; }
  public double PolarSingLocLon { get; set; }
  public bool EmgInd { get; set; }
  public bool DropPtInd { get; set; }
  public int SpaceAmpConf { get; set; }
  public string LaunchTime { get; set; }
  public double LaunchLat { get; set; }
  public double LaunchLon { get; set; }
  public double AzCorr { get; set; }
  public double BurnoutAlt { get; set; }
  public string LaunchAouType { get; set; }
  public List<string> LaunchAouData { get; set; }
  public string ImpactTime { get; set; }
  public double ImpactLat { get; set; }
  public double ImpactLon { get; set; }
  public string ImpactAouType { get; set; }
  public List<string> ImpactAouData { get; set; }
  public List<string> Vectors { get; set; }
  public string OrigNetwork { get; set; }
  public string CreatedAt { get; set; }
  public string CreatedBy { get; set; }
  public string Source { get; set; }
  public string Origin { get; set; }
  public MissileTrack_Ingest_dataMode_Enum DataMode { get; set; }

  public MissileTrack_IngestT() {
    this.Id = null;
    this.ClassificationMarking = null;
    this.MsgType = null;
    this.MsgSubType = null;
    this.MsgCreateDate = null;
    this.Env = MissileTrack_Ingest_env_Enum.AIR;
    this.ObjType = null;
    this.ObjTypeConf = 0;
    this.ObjPlat = null;
    this.ObjIdent = MissileTrack_Ingest_objIdent_Enum.ASSUMED_FRIEND;
    this.SpaceAmp = null;
    this.ObjAct = null;
    this.SpaceSpecType = null;
    this.AcftSubType = null;
    this.Name = null;
    this.CallSign = null;
    this.LostTrkInd = false;
    this.TrackId = null;
    this.ParentTrackId = null;
    this.MuidSrcTrk = null;
    this.MuidSrc = null;
    this.Alert = null;
    this.MslStatus = null;
    this.Ts = null;
    this.AouRptType = null;
    this.AouRptData = null;
    this.Containment = 0.0;
    this.TrkConf = 0.0;
    this.TrkQual = 0;
    this.AngElev = 0.0;
    this.SenMode = null;
    this.InfoSource = null;
    this.Boosting = false;
    this.PolarSingLocLat = 0.0;
    this.PolarSingLocLon = 0.0;
    this.EmgInd = false;
    this.DropPtInd = false;
    this.SpaceAmpConf = 0;
    this.LaunchTime = null;
    this.LaunchLat = 0.0;
    this.LaunchLon = 0.0;
    this.AzCorr = 0.0;
    this.BurnoutAlt = 0.0;
    this.LaunchAouType = null;
    this.LaunchAouData = null;
    this.ImpactTime = null;
    this.ImpactLat = 0.0;
    this.ImpactLon = 0.0;
    this.ImpactAouType = null;
    this.ImpactAouData = null;
    this.Vectors = null;
    this.OrigNetwork = null;
    this.CreatedAt = null;
    this.CreatedBy = null;
    this.Source = null;
    this.Origin = null;
    this.DataMode = MissileTrack_Ingest_dataMode_Enum.REAL;
  }
  public static MissileTrack_IngestT DeserializeFromBinary(byte[] fbBuffer) {
    return MissileTrack_Ingest.GetRootAsMissileTrack_Ingest(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    MissileTrack_Ingest.FinishMissileTrack_IngestBuffer(fbb, MissileTrack_Ingest.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class MissileTrack_IngestVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Id*/, false)
      && verifier.VerifyString(tablePos, 6 /*ClassificationMarking*/, false)
      && verifier.VerifyString(tablePos, 8 /*MsgType*/, false)
      && verifier.VerifyString(tablePos, 10 /*MsgSubType*/, false)
      && verifier.VerifyString(tablePos, 12 /*MsgCreateDate*/, false)
      && verifier.VerifyField(tablePos, 14 /*Env*/, 1 /*MissileTrack_Ingest_env_Enum*/, 1, false)
      && verifier.VerifyString(tablePos, 16 /*ObjType*/, false)
      && verifier.VerifyField(tablePos, 18 /*ObjTypeConf*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 20 /*ObjPlat*/, false)
      && verifier.VerifyField(tablePos, 22 /*ObjIdent*/, 1 /*MissileTrack_Ingest_objIdent_Enum*/, 1, false)
      && verifier.VerifyString(tablePos, 24 /*SpaceAmp*/, false)
      && verifier.VerifyString(tablePos, 26 /*ObjAct*/, false)
      && verifier.VerifyString(tablePos, 28 /*SpaceSpecType*/, false)
      && verifier.VerifyString(tablePos, 30 /*AcftSubType*/, false)
      && verifier.VerifyString(tablePos, 32 /*Name*/, false)
      && verifier.VerifyString(tablePos, 34 /*CallSign*/, false)
      && verifier.VerifyField(tablePos, 36 /*LostTrkInd*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 38 /*TrackId*/, false)
      && verifier.VerifyString(tablePos, 40 /*ParentTrackId*/, false)
      && verifier.VerifyString(tablePos, 42 /*MuidSrcTrk*/, false)
      && verifier.VerifyString(tablePos, 44 /*MuidSrc*/, false)
      && verifier.VerifyString(tablePos, 46 /*Alert*/, false)
      && verifier.VerifyString(tablePos, 48 /*MslStatus*/, false)
      && verifier.VerifyString(tablePos, 50 /*Ts*/, false)
      && verifier.VerifyString(tablePos, 52 /*AouRptType*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 54 /*AouRptData*/, false)
      && verifier.VerifyField(tablePos, 56 /*Containment*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 58 /*TrkConf*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 60 /*TrkQual*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 62 /*AngElev*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 64 /*SenMode*/, false)
      && verifier.VerifyString(tablePos, 66 /*InfoSource*/, false)
      && verifier.VerifyField(tablePos, 68 /*Boosting*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 70 /*PolarSingLocLat*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 72 /*PolarSingLocLon*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 74 /*EmgInd*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 76 /*DropPtInd*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 78 /*SpaceAmpConf*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 80 /*LaunchTime*/, false)
      && verifier.VerifyField(tablePos, 82 /*LaunchLat*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 84 /*LaunchLon*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 86 /*AzCorr*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 88 /*BurnoutAlt*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 90 /*LaunchAouType*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 92 /*LaunchAouData*/, false)
      && verifier.VerifyString(tablePos, 94 /*ImpactTime*/, false)
      && verifier.VerifyField(tablePos, 96 /*ImpactLat*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 98 /*ImpactLon*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 100 /*ImpactAouType*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 102 /*ImpactAouData*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 104 /*Vectors*/, false)
      && verifier.VerifyString(tablePos, 106 /*OrigNetwork*/, false)
      && verifier.VerifyString(tablePos, 108 /*CreatedAt*/, false)
      && verifier.VerifyString(tablePos, 110 /*CreatedBy*/, false)
      && verifier.VerifyString(tablePos, 112 /*Source*/, false)
      && verifier.VerifyString(tablePos, 114 /*Origin*/, false)
      && verifier.VerifyField(tablePos, 116 /*DataMode*/, 1 /*MissileTrack_Ingest_dataMode_Enum*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
