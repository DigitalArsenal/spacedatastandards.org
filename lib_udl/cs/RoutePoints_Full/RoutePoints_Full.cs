// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// Points identified within the route.
public struct RoutePoints_Full : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static RoutePoints_Full GetRootAsRoutePoints_Full(ByteBuffer _bb) { return GetRootAsRoutePoints_Full(_bb, new RoutePoints_Full()); }
  public static RoutePoints_Full GetRootAsRoutePoints_Full(ByteBuffer _bb, RoutePoints_Full obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool RoutePoints_FullBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "ROUT"); }
  public static bool VerifyRoutePoints_Full(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("ROUT", false, RoutePoints_FullVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RoutePoints_Full __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Sequencing field for the track route. This is the identifier representing the sequence of waypoints associated to the track route.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  public int PtSequenceId { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Code representation of the point within the track route (ex. EP, EX, CP, IP, etc.).
  /// Example: /// Example: EP
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string PtTypeCode { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPtTypeCodeBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetPtTypeCodeBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetPtTypeCodeArray() { return __p.__vector_as_array<byte>(6); }
  /// The name that represents the point within the track route (ex. ENTRY POINT, EXIT POINT, CONTROL POINT, INITIAL POINT, etc.).
  /// Example: /// Example: ENTRY POINT
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string PtTypeName { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPtTypeNameBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetPtTypeNameBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetPtTypeNameArray() { return __p.__vector_as_array<byte>(8); }
  /// Name of a waypoint which identifies the location of the point.
  /// Example: /// Example: KCHS
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string WaypointName { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetWaypointNameBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetWaypointNameBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetWaypointNameArray() { return __p.__vector_as_array<byte>(10); }
  /// Flag indicating this is a Digital Aeronautical Flight Information File (DAFIF) point.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool DafifPt { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// WGS84 latitude of the point location, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  public double PtLat { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS84 longitude of the point location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  public double PtLon { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The magnetic declination/variation of the route point location from true north, in degrees. Positive values east of true north and negative values west of true north.
  /// Example: /// Example: 7.35
  /// Constraints: No constraints specified.
  public double MagDec { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The length of the course from the Navigational Aid (NAVAID) in nautical miles.
  /// Example: /// Example: 100.2
  /// Constraints: No constraints specified.
  public double NavaidLength { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Navigational Aid (NAVAID) identification code.
  /// Example: /// Example: HTO
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string Navaid { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNavaidBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetNavaidBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetNavaidArray() { return __p.__vector_as_array<byte>(22); }
  /// The DoD Standard Country Code designator for the country where the route point resides. This field should be set to "OTHR" if the source value does not match a UDL country code value (ISO-3166-ALPHA-2).
  /// Example: /// Example: NL
  /// Constraints: Minimum length = 0, Maximum length = 4
  public string CountryCode { get { int o = __p.__offset(24); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCountryCodeBytes() { return __p.__vector_as_span<byte>(24, 1); }
#else
  public ArraySegment<byte>? GetCountryCodeBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public byte[] GetCountryCodeArray() { return __p.__vector_as_array<byte>(24); }
  /// Specifies an alternate country code if the data provider code is not part of an official NAVAID Country Code standard such as ISO-3166 or FIPS. This field will be set to the value provided by the source and should be used for all Queries specifying a Country Code.
  /// Example: /// Example: IZ
  /// Constraints: Minimum length = 0, Maximum length = 16
  public string AltCountryCode { get { int o = __p.__offset(26); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAltCountryCodeBytes() { return __p.__vector_as_span<byte>(26, 1); }
#else
  public ArraySegment<byte>? GetAltCountryCodeBytes() { return __p.__vector_as_arraysegment(26); }
#endif
  public byte[] GetAltCountryCodeArray() { return __p.__vector_as_array<byte>(26); }
  /// The NAVAID type of this route point (ex. VOR, VORTAC, TACAN, etc.).
  /// Example: /// Example: VORTAC
  /// Constraints: Minimum length = 0, Maximum length = 12
  public string NavaidType { get { int o = __p.__offset(28); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNavaidTypeBytes() { return __p.__vector_as_span<byte>(28, 1); }
#else
  public ArraySegment<byte>? GetNavaidTypeBytes() { return __p.__vector_as_arraysegment(28); }
#endif
  public byte[] GetNavaidTypeArray() { return __p.__vector_as_array<byte>(28); }

  public static Offset<RoutePoints_Full> CreateRoutePoints_Full(FlatBufferBuilder builder,
      int ptSequenceId = 0,
      StringOffset ptTypeCodeOffset = default(StringOffset),
      StringOffset ptTypeNameOffset = default(StringOffset),
      StringOffset waypointNameOffset = default(StringOffset),
      bool dafifPt = false,
      double ptLat = 0.0,
      double ptLon = 0.0,
      double magDec = 0.0,
      double navaidLength = 0.0,
      StringOffset navaidOffset = default(StringOffset),
      StringOffset countryCodeOffset = default(StringOffset),
      StringOffset altCountryCodeOffset = default(StringOffset),
      StringOffset navaidTypeOffset = default(StringOffset)) {
    builder.StartTable(13);
    RoutePoints_Full.AddNavaidLength(builder, navaidLength);
    RoutePoints_Full.AddMagDec(builder, magDec);
    RoutePoints_Full.AddPtLon(builder, ptLon);
    RoutePoints_Full.AddPtLat(builder, ptLat);
    RoutePoints_Full.AddNavaidType(builder, navaidTypeOffset);
    RoutePoints_Full.AddAltCountryCode(builder, altCountryCodeOffset);
    RoutePoints_Full.AddCountryCode(builder, countryCodeOffset);
    RoutePoints_Full.AddNavaid(builder, navaidOffset);
    RoutePoints_Full.AddWaypointName(builder, waypointNameOffset);
    RoutePoints_Full.AddPtTypeName(builder, ptTypeNameOffset);
    RoutePoints_Full.AddPtTypeCode(builder, ptTypeCodeOffset);
    RoutePoints_Full.AddPtSequenceId(builder, ptSequenceId);
    RoutePoints_Full.AddDafifPt(builder, dafifPt);
    return RoutePoints_Full.EndRoutePoints_Full(builder);
  }

  public static void StartRoutePoints_Full(FlatBufferBuilder builder) { builder.StartTable(13); }
  public static void AddPtSequenceId(FlatBufferBuilder builder, int ptSequenceId) { builder.AddInt(0, ptSequenceId, 0); }
  public static void AddPtTypeCode(FlatBufferBuilder builder, StringOffset ptTypeCodeOffset) { builder.AddOffset(1, ptTypeCodeOffset.Value, 0); }
  public static void AddPtTypeName(FlatBufferBuilder builder, StringOffset ptTypeNameOffset) { builder.AddOffset(2, ptTypeNameOffset.Value, 0); }
  public static void AddWaypointName(FlatBufferBuilder builder, StringOffset waypointNameOffset) { builder.AddOffset(3, waypointNameOffset.Value, 0); }
  public static void AddDafifPt(FlatBufferBuilder builder, bool dafifPt) { builder.AddBool(4, dafifPt, false); }
  public static void AddPtLat(FlatBufferBuilder builder, double ptLat) { builder.AddDouble(5, ptLat, 0.0); }
  public static void AddPtLon(FlatBufferBuilder builder, double ptLon) { builder.AddDouble(6, ptLon, 0.0); }
  public static void AddMagDec(FlatBufferBuilder builder, double magDec) { builder.AddDouble(7, magDec, 0.0); }
  public static void AddNavaidLength(FlatBufferBuilder builder, double navaidLength) { builder.AddDouble(8, navaidLength, 0.0); }
  public static void AddNavaid(FlatBufferBuilder builder, StringOffset navaidOffset) { builder.AddOffset(9, navaidOffset.Value, 0); }
  public static void AddCountryCode(FlatBufferBuilder builder, StringOffset countryCodeOffset) { builder.AddOffset(10, countryCodeOffset.Value, 0); }
  public static void AddAltCountryCode(FlatBufferBuilder builder, StringOffset altCountryCodeOffset) { builder.AddOffset(11, altCountryCodeOffset.Value, 0); }
  public static void AddNavaidType(FlatBufferBuilder builder, StringOffset navaidTypeOffset) { builder.AddOffset(12, navaidTypeOffset.Value, 0); }
  public static Offset<RoutePoints_Full> EndRoutePoints_Full(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<RoutePoints_Full>(o);
  }
  public static void FinishRoutePoints_FullBuffer(FlatBufferBuilder builder, Offset<RoutePoints_Full> offset) { builder.Finish(offset.Value, "ROUT"); }
  public static void FinishSizePrefixedRoutePoints_FullBuffer(FlatBufferBuilder builder, Offset<RoutePoints_Full> offset) { builder.FinishSizePrefixed(offset.Value, "ROUT"); }
  public RoutePoints_FullT UnPack() {
    var _o = new RoutePoints_FullT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RoutePoints_FullT _o) {
    _o.PtSequenceId = this.PtSequenceId;
    _o.PtTypeCode = this.PtTypeCode;
    _o.PtTypeName = this.PtTypeName;
    _o.WaypointName = this.WaypointName;
    _o.DafifPt = this.DafifPt;
    _o.PtLat = this.PtLat;
    _o.PtLon = this.PtLon;
    _o.MagDec = this.MagDec;
    _o.NavaidLength = this.NavaidLength;
    _o.Navaid = this.Navaid;
    _o.CountryCode = this.CountryCode;
    _o.AltCountryCode = this.AltCountryCode;
    _o.NavaidType = this.NavaidType;
  }
  public static Offset<RoutePoints_Full> Pack(FlatBufferBuilder builder, RoutePoints_FullT _o) {
    if (_o == null) return default(Offset<RoutePoints_Full>);
    var _ptTypeCode = _o.PtTypeCode == null ? default(StringOffset) : builder.CreateString(_o.PtTypeCode);
    var _ptTypeName = _o.PtTypeName == null ? default(StringOffset) : builder.CreateString(_o.PtTypeName);
    var _waypointName = _o.WaypointName == null ? default(StringOffset) : builder.CreateString(_o.WaypointName);
    var _navaid = _o.Navaid == null ? default(StringOffset) : builder.CreateString(_o.Navaid);
    var _countryCode = _o.CountryCode == null ? default(StringOffset) : builder.CreateString(_o.CountryCode);
    var _altCountryCode = _o.AltCountryCode == null ? default(StringOffset) : builder.CreateString(_o.AltCountryCode);
    var _navaidType = _o.NavaidType == null ? default(StringOffset) : builder.CreateString(_o.NavaidType);
    return CreateRoutePoints_Full(
      builder,
      _o.PtSequenceId,
      _ptTypeCode,
      _ptTypeName,
      _waypointName,
      _o.DafifPt,
      _o.PtLat,
      _o.PtLon,
      _o.MagDec,
      _o.NavaidLength,
      _navaid,
      _countryCode,
      _altCountryCode,
      _navaidType);
  }
}

public class RoutePoints_FullT
{
  public int PtSequenceId { get; set; }
  public string PtTypeCode { get; set; }
  public string PtTypeName { get; set; }
  public string WaypointName { get; set; }
  public bool DafifPt { get; set; }
  public double PtLat { get; set; }
  public double PtLon { get; set; }
  public double MagDec { get; set; }
  public double NavaidLength { get; set; }
  public string Navaid { get; set; }
  public string CountryCode { get; set; }
  public string AltCountryCode { get; set; }
  public string NavaidType { get; set; }

  public RoutePoints_FullT() {
    this.PtSequenceId = 0;
    this.PtTypeCode = null;
    this.PtTypeName = null;
    this.WaypointName = null;
    this.DafifPt = false;
    this.PtLat = 0.0;
    this.PtLon = 0.0;
    this.MagDec = 0.0;
    this.NavaidLength = 0.0;
    this.Navaid = null;
    this.CountryCode = null;
    this.AltCountryCode = null;
    this.NavaidType = null;
  }
  public static RoutePoints_FullT DeserializeFromBinary(byte[] fbBuffer) {
    return RoutePoints_Full.GetRootAsRoutePoints_Full(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    RoutePoints_Full.FinishRoutePoints_FullBuffer(fbb, RoutePoints_Full.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class RoutePoints_FullVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*PtSequenceId*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 6 /*PtTypeCode*/, false)
      && verifier.VerifyString(tablePos, 8 /*PtTypeName*/, false)
      && verifier.VerifyString(tablePos, 10 /*WaypointName*/, false)
      && verifier.VerifyField(tablePos, 12 /*DafifPt*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*PtLat*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 16 /*PtLon*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 18 /*MagDec*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 20 /*NavaidLength*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 22 /*Navaid*/, false)
      && verifier.VerifyString(tablePos, 24 /*CountryCode*/, false)
      && verifier.VerifyString(tablePos, 26 /*AltCountryCode*/, false)
      && verifier.VerifyString(tablePos, 28 /*NavaidType*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
