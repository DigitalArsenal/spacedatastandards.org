// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// Injury specifics.
public struct EvacInjury_Ingest : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static EvacInjury_Ingest GetRootAsEvacInjury_Ingest(ByteBuffer _bb) { return GetRootAsEvacInjury_Ingest(_bb, new EvacInjury_Ingest()); }
  public static EvacInjury_Ingest GetRootAsEvacInjury_Ingest(ByteBuffer _bb, EvacInjury_Ingest obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool EvacInjury_IngestBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "EVAC"); }
  public static bool VerifyEvacInjury_Ingest(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("EVAC", false, EvacInjury_IngestVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public EvacInjury_Ingest __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Classification of the injury type (ABRASION, AMPUTATION IT, AVULATION, BALLISTIC, BLAST WAVE, BURN 1ST DEGREE, BURN 2ND DEGREE, BURN 3RD DEGREE, BURN INHALATION, BURN LOWER AIRWAY, CHEST FLAIL, CHEST OPEN, DEGLOVING, ECCHYMOSIS, FRACTURE CLOSED, FRACTURE CREPITUS, FRACTURE IT, FRACTURE OPEN, HEMATOMA, IRREGULAR CONSISTENCY, IRREGULAR CONSISTENCY RIDGED, IRREGULAR CONSISTENCY SWOLLEN, IRREGULAR CONSISTENCY SWOLLEN DISTENDED, IRREGULAR CONSISTENCY TENDER, IRREGULAR POSITION, IRREGULAR SHAPE, IRREGULAR SHAPE MISSHAPED, IRREGULAR SHAPE NON SYMMETRICAL, LACERATION, NEUROVASCULAR COMPROMISE, NEUROVASCULAR INTACT, PUNCTURE, SEAT BELT SIGN, STAB, TIC TIM).
  /// Example: /// Example: ABRASION
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Type { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTypeBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetTypeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetTypeArray() { return __p.__vector_as_array<byte>(4); }
  /// Body part location of the injury.  Intended as, but not constrained to, K07.1 Body Location Enumeration (e.g. ANKLE LEFT BACK, ANKLE LEFT FRONT, ANKLE RIGHT BACK, ANKLE RIGHT FRONT, ARM LEFT BACK, ARM LEFT ELBOW BACK, ARM LEFT ELBOW FRONT, ARM LEFT FRONT, ARM LEFT LOWER BACK, etc.).
  /// Example: /// Example: ARM LEFT FRONT
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string BodyPart { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBodyPartBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetBodyPartBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetBodyPartArray() { return __p.__vector_as_array<byte>(6); }
  /// The time of the injury, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-10-15T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string Time { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTimeBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetTimeBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetTimeArray() { return __p.__vector_as_array<byte>(8); }
  /// Additional comments on the patient's injury information.
  /// Example: /// Example: Comments on the patient's injury.
  /// Constraints: Minimum length = 0, Maximum length = 1024
  public string Comments { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCommentsBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetCommentsBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetCommentsArray() { return __p.__vector_as_array<byte>(10); }

  public static Offset<EvacInjury_Ingest> CreateEvacInjury_Ingest(FlatBufferBuilder builder,
      StringOffset typeOffset = default(StringOffset),
      StringOffset bodyPartOffset = default(StringOffset),
      StringOffset timeOffset = default(StringOffset),
      StringOffset commentsOffset = default(StringOffset)) {
    builder.StartTable(4);
    EvacInjury_Ingest.AddComments(builder, commentsOffset);
    EvacInjury_Ingest.AddTime(builder, timeOffset);
    EvacInjury_Ingest.AddBodyPart(builder, bodyPartOffset);
    EvacInjury_Ingest.AddType(builder, typeOffset);
    return EvacInjury_Ingest.EndEvacInjury_Ingest(builder);
  }

  public static void StartEvacInjury_Ingest(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddType(FlatBufferBuilder builder, StringOffset typeOffset) { builder.AddOffset(0, typeOffset.Value, 0); }
  public static void AddBodyPart(FlatBufferBuilder builder, StringOffset bodyPartOffset) { builder.AddOffset(1, bodyPartOffset.Value, 0); }
  public static void AddTime(FlatBufferBuilder builder, StringOffset timeOffset) { builder.AddOffset(2, timeOffset.Value, 0); }
  public static void AddComments(FlatBufferBuilder builder, StringOffset commentsOffset) { builder.AddOffset(3, commentsOffset.Value, 0); }
  public static Offset<EvacInjury_Ingest> EndEvacInjury_Ingest(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<EvacInjury_Ingest>(o);
  }
  public static void FinishEvacInjury_IngestBuffer(FlatBufferBuilder builder, Offset<EvacInjury_Ingest> offset) { builder.Finish(offset.Value, "EVAC"); }
  public static void FinishSizePrefixedEvacInjury_IngestBuffer(FlatBufferBuilder builder, Offset<EvacInjury_Ingest> offset) { builder.FinishSizePrefixed(offset.Value, "EVAC"); }
  public EvacInjury_IngestT UnPack() {
    var _o = new EvacInjury_IngestT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(EvacInjury_IngestT _o) {
    _o.Type = this.Type;
    _o.BodyPart = this.BodyPart;
    _o.Time = this.Time;
    _o.Comments = this.Comments;
  }
  public static Offset<EvacInjury_Ingest> Pack(FlatBufferBuilder builder, EvacInjury_IngestT _o) {
    if (_o == null) return default(Offset<EvacInjury_Ingest>);
    var _type = _o.Type == null ? default(StringOffset) : builder.CreateString(_o.Type);
    var _bodyPart = _o.BodyPart == null ? default(StringOffset) : builder.CreateString(_o.BodyPart);
    var _time = _o.Time == null ? default(StringOffset) : builder.CreateString(_o.Time);
    var _comments = _o.Comments == null ? default(StringOffset) : builder.CreateString(_o.Comments);
    return CreateEvacInjury_Ingest(
      builder,
      _type,
      _bodyPart,
      _time,
      _comments);
  }
}

public class EvacInjury_IngestT
{
  public string Type { get; set; }
  public string BodyPart { get; set; }
  public string Time { get; set; }
  public string Comments { get; set; }

  public EvacInjury_IngestT() {
    this.Type = null;
    this.BodyPart = null;
    this.Time = null;
    this.Comments = null;
  }
  public static EvacInjury_IngestT DeserializeFromBinary(byte[] fbBuffer) {
    return EvacInjury_Ingest.GetRootAsEvacInjury_Ingest(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    EvacInjury_Ingest.FinishEvacInjury_IngestBuffer(fbb, EvacInjury_Ingest.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class EvacInjury_IngestVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Type*/, false)
      && verifier.VerifyString(tablePos, 6 /*BodyPart*/, false)
      && verifier.VerifyString(tablePos, 8 /*Time*/, false)
      && verifier.VerifyString(tablePos, 10 /*Comments*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
