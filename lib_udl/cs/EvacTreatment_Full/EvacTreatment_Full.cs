// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// Treatment information.
public struct EvacTreatment_Full : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static EvacTreatment_Full GetRootAsEvacTreatment_Full(ByteBuffer _bb) { return GetRootAsEvacTreatment_Full(_bb, new EvacTreatment_Full()); }
  public static EvacTreatment_Full GetRootAsEvacTreatment_Full(ByteBuffer _bb, EvacTreatment_Full obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool EvacTreatment_FullBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "EVAC"); }
  public static bool VerifyEvacTreatment_Full(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("EVAC", false, EvacTreatment_FullVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public EvacTreatment_Full __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Type of treatment administered or to be administered.  Intended as, but not constrained to, K07.1 Treatment Type Enumeration (e.g. AIRWAY ADJUNCT, AIRWAY ASSISTED VENTILATION, AIRWAY COMBI TUBE USED, AIRWAY ET NT, AIRWAY INTUBATED, AIRWAY NPA OPA APPLIED, AIRWAY PATIENT, AIRWAY POSITIONAL, AIRWAY SURGICAL CRIC, BREATHING CHEST SEAL, BREATHING CHEST TUBE, etc.).
  /// Example: /// Example: BREATHING CHEST TUBE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Type { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTypeBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetTypeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetTypeArray() { return __p.__vector_as_array<byte>(4); }
  /// Body part location or body part treated or to be treated.  Intended as, but not constrained to, K07.1 Body Location Enumeration (e.g. ANKLE LEFT BACK, ANKLE LEFT FRONT, ANKLE RIGHT BACK, ANKLE RIGHT FRONT, ARM LEFT BACK, ARM LEFT ELBOW BACK, ARM LEFT ELBOW FRONT, ARM LEFT FRONT, ARM LEFT LOWER BACK, etc.).
  /// Example: /// Example: CHEST
  /// Constraints: Minimum length = 0, Maximum length = 32
  public string BodyPart { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBodyPartBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetBodyPartBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetBodyPartArray() { return __p.__vector_as_array<byte>(6); }
  /// Datetime of the treatment in ISO 8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string Time { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTimeBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetTimeBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetTimeArray() { return __p.__vector_as_array<byte>(8); }
  /// Additional comments on the patient's treatment information.
  /// Example: /// Example: Comments on the treatment info.
  /// Constraints: Minimum length = 0, Maximum length = 1024
  public string Comments { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCommentsBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetCommentsBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetCommentsArray() { return __p.__vector_as_array<byte>(10); }

  public static Offset<EvacTreatment_Full> CreateEvacTreatment_Full(FlatBufferBuilder builder,
      StringOffset typeOffset = default(StringOffset),
      StringOffset bodyPartOffset = default(StringOffset),
      StringOffset timeOffset = default(StringOffset),
      StringOffset commentsOffset = default(StringOffset)) {
    builder.StartTable(4);
    EvacTreatment_Full.AddComments(builder, commentsOffset);
    EvacTreatment_Full.AddTime(builder, timeOffset);
    EvacTreatment_Full.AddBodyPart(builder, bodyPartOffset);
    EvacTreatment_Full.AddType(builder, typeOffset);
    return EvacTreatment_Full.EndEvacTreatment_Full(builder);
  }

  public static void StartEvacTreatment_Full(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddType(FlatBufferBuilder builder, StringOffset typeOffset) { builder.AddOffset(0, typeOffset.Value, 0); }
  public static void AddBodyPart(FlatBufferBuilder builder, StringOffset bodyPartOffset) { builder.AddOffset(1, bodyPartOffset.Value, 0); }
  public static void AddTime(FlatBufferBuilder builder, StringOffset timeOffset) { builder.AddOffset(2, timeOffset.Value, 0); }
  public static void AddComments(FlatBufferBuilder builder, StringOffset commentsOffset) { builder.AddOffset(3, commentsOffset.Value, 0); }
  public static Offset<EvacTreatment_Full> EndEvacTreatment_Full(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<EvacTreatment_Full>(o);
  }
  public static void FinishEvacTreatment_FullBuffer(FlatBufferBuilder builder, Offset<EvacTreatment_Full> offset) { builder.Finish(offset.Value, "EVAC"); }
  public static void FinishSizePrefixedEvacTreatment_FullBuffer(FlatBufferBuilder builder, Offset<EvacTreatment_Full> offset) { builder.FinishSizePrefixed(offset.Value, "EVAC"); }
  public EvacTreatment_FullT UnPack() {
    var _o = new EvacTreatment_FullT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(EvacTreatment_FullT _o) {
    _o.Type = this.Type;
    _o.BodyPart = this.BodyPart;
    _o.Time = this.Time;
    _o.Comments = this.Comments;
  }
  public static Offset<EvacTreatment_Full> Pack(FlatBufferBuilder builder, EvacTreatment_FullT _o) {
    if (_o == null) return default(Offset<EvacTreatment_Full>);
    var _type = _o.Type == null ? default(StringOffset) : builder.CreateString(_o.Type);
    var _bodyPart = _o.BodyPart == null ? default(StringOffset) : builder.CreateString(_o.BodyPart);
    var _time = _o.Time == null ? default(StringOffset) : builder.CreateString(_o.Time);
    var _comments = _o.Comments == null ? default(StringOffset) : builder.CreateString(_o.Comments);
    return CreateEvacTreatment_Full(
      builder,
      _type,
      _bodyPart,
      _time,
      _comments);
  }
}

public class EvacTreatment_FullT
{
  public string Type { get; set; }
  public string BodyPart { get; set; }
  public string Time { get; set; }
  public string Comments { get; set; }

  public EvacTreatment_FullT() {
    this.Type = null;
    this.BodyPart = null;
    this.Time = null;
    this.Comments = null;
  }
  public static EvacTreatment_FullT DeserializeFromBinary(byte[] fbBuffer) {
    return EvacTreatment_Full.GetRootAsEvacTreatment_Full(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    EvacTreatment_Full.FinishEvacTreatment_FullBuffer(fbb, EvacTreatment_Full.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class EvacTreatment_FullVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Type*/, false)
      && verifier.VerifyString(tablePos, 6 /*BodyPart*/, false)
      && verifier.VerifyString(tablePos, 8 /*Time*/, false)
      && verifier.VerifyString(tablePos, 10 /*Comments*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
