// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// /// Self-reported information obtained from Automatic Identification System (AIS) equipment. This contains information such as unique identification, status, position, course, and speed. The AIS is an automatic tracking system that uses transceivers on ships and is used by vessel traffic services. Although technically and operationally distinct, the AIS system is analogous to ADS-B that performs a similar function for aircraft. AIS is intended to assist a vessel's watchstanding officers and allow maritime authorities to track and monitor vessel movements. AIS integrates a standardized VHF transceiver with a positioning system such as Global Positioning System receiver, with other electronic navigation sensors, such as gyrocompass or rate of turn indicator. Vessels fitted with AIS transceivers can be tracked by AIS base stations located along coast lines or, when out of range of terrestrial networks, through a growing number of satellites that are fitted with special AIS receivers which are capable of deconflicting a large number of signatures.
public struct AIS_Abridged : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static AIS_Abridged GetRootAsAIS_Abridged(ByteBuffer _bb) { return GetRootAsAIS_Abridged(_bb, new AIS_Abridged()); }
  public static AIS_Abridged GetRootAsAIS_Abridged(ByteBuffer _bb, AIS_Abridged obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool AIS_AbridgedBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "AISA"); }
  public static bool VerifyAIS_Abridged(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("AISA", false, AIS_AbridgedVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public AIS_Abridged __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: AIS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string Id { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetIdBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetIdArray() { return __p.__vector_as_array<byte>(4); }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  public string ClassificationMarking { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetClassificationMarkingBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetClassificationMarkingBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetClassificationMarkingArray() { return __p.__vector_as_array<byte>(6); }
  /// Unique identifier of the Track.
  /// Example: /// Example: TRACK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string IdTrack { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdTrackBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetIdTrackBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetIdTrackArray() { return __p.__vector_as_array<byte>(8); }
  /// Unique identifier of the vessel.
  /// Example: /// Example: VESSEL-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string IdVessel { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIdVesselBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetIdVesselBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetIdVesselArray() { return __p.__vector_as_array<byte>(10); }
  /// The Maritime Mobile Service Identity of the vessel.  MMSI is a nine-digit number that identifies the transmitter station of the vessel.
  /// Example: /// Example: 304010417
  /// Constraints: No constraints specified.
  public long Mmsi { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  /// The International Maritime Organization Number of the vessel.  IMON is a seven-digit number that uniquely identifies the vessel.
  /// Example: /// Example: 9015462
  /// Constraints: No constraints specified.
  public long Imon { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  /// The timestamp that the vessel position was recorded, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string Ts { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTsBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetTsBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetTsArray() { return __p.__vector_as_array<byte>(16); }
  /// The name of the vessel.  Vessel names that exceed the AIS 20 character are shortened (not truncated) to 15 character-spaces, followed by an underscore and the last 4 characters-spaces of the vessel full name.
  /// Example: /// Example: DORNUM
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string ShipName { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetShipNameBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetShipNameBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetShipNameArray() { return __p.__vector_as_array<byte>(18); }
  /// The reported ship type (e.g. Passenger, Tanker, Cargo, Other, etc.).  See the engagedIn and specialCraft entries for additional information on certain types of vessels.
  /// Example: /// Example: Passenger
  /// Constraints: Minimum length = 0, Maximum length = 48
  public string ShipType { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetShipTypeBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetShipTypeBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetShipTypeArray() { return __p.__vector_as_array<byte>(20); }
  /// The activity that the vessel is engaged in.  This entry applies only when the shipType = Other.
  /// Example: /// Example: Cargo
  /// Constraints: Minimum length = 0, Maximum length = 48
  public string EngagedIn { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEngagedInBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetEngagedInBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetEngagedInArray() { return __p.__vector_as_array<byte>(22); }
  /// The type of special craft designation of the vessel.  This entry applies only when the shipType = Special Craft.
  /// Example: /// Example: Tug
  /// Constraints: Minimum length = 0, Maximum length = 48
  public string SpecialCraft { get { int o = __p.__offset(24); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSpecialCraftBytes() { return __p.__vector_as_span<byte>(24, 1); }
#else
  public ArraySegment<byte>? GetSpecialCraftBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public byte[] GetSpecialCraftArray() { return __p.__vector_as_array<byte>(24); }
  /// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  public string CargoType { get { int o = __p.__offset(26); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCargoTypeBytes() { return __p.__vector_as_span<byte>(26, 1); }
#else
  public ArraySegment<byte>? GetCargoTypeBytes() { return __p.__vector_as_arraysegment(26); }
#endif
  public byte[] GetCargoTypeArray() { return __p.__vector_as_array<byte>(26); }
  /// A uniquely designated identifier for the vessel's transmitter station.
  /// Example: /// Example: V2OZ
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string CallSign { get { int o = __p.__offset(28); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCallSignBytes() { return __p.__vector_as_span<byte>(28, 1); }
#else
  public ArraySegment<byte>? GetCallSignBytes() { return __p.__vector_as_arraysegment(28); }
#endif
  public byte[] GetCallSignArray() { return __p.__vector_as_array<byte>(28); }
  /// The flag of the subject vessel according to AIS transmission.
  /// Example: /// Example: United States
  /// Constraints: Minimum length = 0, Maximum length = 36
  public string VesselFlag { get { int o = __p.__offset(30); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetVesselFlagBytes() { return __p.__vector_as_span<byte>(30, 1); }
#else
  public ArraySegment<byte>? GetVesselFlagBytes() { return __p.__vector_as_arraysegment(30); }
#endif
  public byte[] GetVesselFlagArray() { return __p.__vector_as_array<byte>(30); }
  /// WGS-84 latitude of the vessel position, in degrees.  -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 47.758499
  /// Constraints: No constraints specified.
  public double Lat { get { int o = __p.__offset(32); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// WGS-84 longitude of the vessel position, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: -5.154223
  /// Constraints: No constraints specified.
  public double Lon { get { int o = __p.__offset(34); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Flag indicating high reported position accuracy (less than or equal to 10 meters).  A value of 0/false indicates low accuracy (greater than 10 meters).
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool PosHiAccuracy { get { int o = __p.__offset(36); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Flag indicating high reported position latency (greater than 5 seconds).  A value of 0/false indicates low latency (less than 5 seconds).
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  public bool PosHiLatency { get { int o = __p.__offset(38); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The speed-over-ground reported by the vessel, in kilometers/hour.
  /// Example: /// Example: 10.5
  /// Constraints: No constraints specified.
  public double Speed { get { int o = __p.__offset(40); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The true heading reported by the vessel, in degrees.
  /// Example: /// Example: 329.1
  /// Constraints: No constraints specified.
  public double TrueHeading { get { int o = __p.__offset(42); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The course-over-ground reported by the vessel, in degrees.
  /// Example: /// Example: 157.1
  /// Constraints: No constraints specified.
  public double Course { get { int o = __p.__offset(44); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The Rate-of-Turn for the vessel, in degrees/minute.  Positive value indicates that the vessel is turning right.
  /// Example: /// Example: 22.1
  /// Constraints: No constraints specified.
  public double RateOfTurn { get { int o = __p.__offset(46); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Flag indicating that the vessel is engaged in a special maneuver (e.g. Waterway Navigation).
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  public bool SpecialManeuver { get { int o = __p.__offset(48); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Underway Using Engine
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string NavStatus { get { int o = __p.__offset(50); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNavStatusBytes() { return __p.__vector_as_span<byte>(50, 1); }
#else
  public ArraySegment<byte>? GetNavStatusBytes() { return __p.__vector_as_arraysegment(50); }
#endif
  public byte[] GetNavStatusArray() { return __p.__vector_as_array<byte>(50); }
  /// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: GPS
  /// Constraints: Minimum length = 0, Maximum length = 24
  public string PosDeviceType { get { int o = __p.__offset(52); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPosDeviceTypeBytes() { return __p.__vector_as_span<byte>(52, 1); }
#else
  public ArraySegment<byte>? GetPosDeviceTypeBytes() { return __p.__vector_as_arraysegment(52); }
#endif
  public byte[] GetPosDeviceTypeArray() { return __p.__vector_as_array<byte>(52); }
  /// The reference dimensions of the vessel, reported as [A, B, C, D], in meters.  Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna.  Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
  /// Example: /// Example: [50.1, 50.1, 20.1, 20.1]
  /// Constraints: No constraints specified.
  public string AntennaRefDimensions(int j) { int o = __p.__offset(54); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int AntennaRefDimensionsLength { get { int o = __p.__offset(54); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The overall length of the vessel, in meters.  A value of 511 indicates a vessel length of 511 meters or greater.
  /// Example: /// Example: 511.1
  /// Constraints: No constraints specified.
  public double Length { get { int o = __p.__offset(56); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The breadth of the vessel, in meters.  A value of 63 indicates a vessel breadth of 63 meters or greater.
  /// Example: /// Example: 24.1
  /// Constraints: No constraints specified.
  public double Width { get { int o = __p.__offset(58); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The maximum static draught, in meters, of the vessel according to the AIS transmission.
  /// Example: /// Example: 21.1
  /// Constraints: No constraints specified.
  public double Draught { get { int o = __p.__offset(60); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Further description or explanation of the vessel or type.
  /// Example: /// Example: Search and rescue vessels
  /// Constraints: Minimum length = 0, Maximum length = 100
  public string ShipDescription { get { int o = __p.__offset(62); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetShipDescriptionBytes() { return __p.__vector_as_span<byte>(62, 1); }
#else
  public ArraySegment<byte>? GetShipDescriptionBytes() { return __p.__vector_as_arraysegment(62); }
#endif
  public byte[] GetShipDescriptionArray() { return __p.__vector_as_array<byte>(62); }
  /// The destination of the vessel according to the AIS transmission.
  /// Example: /// Example: USCLE
  /// Constraints: Minimum length = 0, Maximum length = 20
  public string Destination { get { int o = __p.__offset(64); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDestinationBytes() { return __p.__vector_as_span<byte>(64, 1); }
#else
  public ArraySegment<byte>? GetDestinationBytes() { return __p.__vector_as_arraysegment(64); }
#endif
  public byte[] GetDestinationArray() { return __p.__vector_as_array<byte>(64); }
  /// The Estimated Time of Arrival of the vessel at the destination, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string DestinationETA { get { int o = __p.__offset(66); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDestinationETABytes() { return __p.__vector_as_span<byte>(66, 1); }
#else
  public ArraySegment<byte>? GetDestinationETABytes() { return __p.__vector_as_arraysegment(66); }
#endif
  public byte[] GetDestinationETAArray() { return __p.__vector_as_array<byte>(66); }
  /// The US Geographic Unique Identifier of the current port hosting the vessel.
  /// Example: /// Example: 0ABC
  /// Constraints: Minimum length = 0, Maximum length = 4
  public string CurrentPortGUID { get { int o = __p.__offset(68); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCurrentPortGUIDBytes() { return __p.__vector_as_span<byte>(68, 1); }
#else
  public ArraySegment<byte>? GetCurrentPortGUIDBytes() { return __p.__vector_as_arraysegment(68); }
#endif
  public byte[] GetCurrentPortGUIDArray() { return __p.__vector_as_array<byte>(68); }
  /// The UN Location Code of the current port hosting the vessel.
  /// Example: /// Example: XF013
  /// Constraints: Minimum length = 0, Maximum length = 5
  public string CurrentPortLOCODE { get { int o = __p.__offset(70); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCurrentPortLOCODEBytes() { return __p.__vector_as_span<byte>(70, 1); }
#else
  public ArraySegment<byte>? GetCurrentPortLOCODEBytes() { return __p.__vector_as_arraysegment(70); }
#endif
  public byte[] GetCurrentPortLOCODEArray() { return __p.__vector_as_array<byte>(70); }
  /// The US Geographic Unique Identifier of the last port visited by the vessel.
  /// Example: /// Example: 0VAX
  /// Constraints: Minimum length = 0, Maximum length = 4
  public string LastPortGUID { get { int o = __p.__offset(72); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLastPortGUIDBytes() { return __p.__vector_as_span<byte>(72, 1); }
#else
  public ArraySegment<byte>? GetLastPortGUIDBytes() { return __p.__vector_as_arraysegment(72); }
#endif
  public byte[] GetLastPortGUIDArray() { return __p.__vector_as_array<byte>(72); }
  /// The UN Location Code of the last port visited by the vessel.
  /// Example: /// Example: USSKY
  /// Constraints: Minimum length = 0, Maximum length = 5
  public string LastPortLOCODE { get { int o = __p.__offset(74); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLastPortLOCODEBytes() { return __p.__vector_as_span<byte>(74, 1); }
#else
  public ArraySegment<byte>? GetLastPortLOCODEBytes() { return __p.__vector_as_arraysegment(74); }
#endif
  public byte[] GetLastPortLOCODEArray() { return __p.__vector_as_array<byte>(74); }
  /// The US Geographic Unique Identifier of the next destination port of the vessel.
  /// Example: /// Example: 0Z8Q
  /// Constraints: Minimum length = 0, Maximum length = 4
  public string NextPortGUID { get { int o = __p.__offset(76); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNextPortGUIDBytes() { return __p.__vector_as_span<byte>(76, 1); }
#else
  public ArraySegment<byte>? GetNextPortGUIDBytes() { return __p.__vector_as_arraysegment(76); }
#endif
  public byte[] GetNextPortGUIDArray() { return __p.__vector_as_array<byte>(76); }
  /// The UN  Location Code of the next destination port of the vessel.
  /// Example: /// Example: USCLE
  /// Constraints: Minimum length = 0, Maximum length = 5
  public string NextPortLOCODE { get { int o = __p.__offset(78); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNextPortLOCODEBytes() { return __p.__vector_as_span<byte>(78, 1); }
#else
  public ArraySegment<byte>? GetNextPortLOCODEBytes() { return __p.__vector_as_arraysegment(78); }
#endif
  public byte[] GetNextPortLOCODEArray() { return __p.__vector_as_array<byte>(78); }
  /// The Estimated Time of Arrival of the vessel at the destination port, according to MarineTraffic calculations, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string EtaCalculated { get { int o = __p.__offset(80); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEtaCalculatedBytes() { return __p.__vector_as_span<byte>(80, 1); }
#else
  public ArraySegment<byte>? GetEtaCalculatedBytes() { return __p.__vector_as_arraysegment(80); }
#endif
  public byte[] GetEtaCalculatedArray() { return __p.__vector_as_array<byte>(80); }
  /// The date and time that the ETA was calculated by MarineTraffic, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  public string EtaUpdated { get { int o = __p.__offset(82); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEtaUpdatedBytes() { return __p.__vector_as_span<byte>(82, 1); }
#else
  public ArraySegment<byte>? GetEtaUpdatedBytes() { return __p.__vector_as_arraysegment(82); }
#endif
  public byte[] GetEtaUpdatedArray() { return __p.__vector_as_array<byte>(82); }
  /// The remaining distance, in kilometers, for the vessel to reach the reported destination.
  /// Example: /// Example: 150.5
  /// Constraints: No constraints specified.
  public double DistanceToGo { get { int o = __p.__offset(84); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The distance, in kilometers, that the vessel has travelled since departing the last port.
  /// Example: /// Example: 200.3
  /// Constraints: No constraints specified.
  public double DistanceTravelled { get { int o = __p.__offset(86); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The average speed, in kilometers/hour, calculated for the subject vessel during the latest voyage (port to port).
  /// Example: /// Example: 12.1
  /// Constraints: No constraints specified.
  public double AvgSpeed { get { int o = __p.__offset(88); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// The maximum speed, in kilometers/hour, reported by the subject vessel during the latest voyage (port to port).
  /// Example: /// Example: 13.3
  /// Constraints: No constraints specified.
  public double MaxSpeed { get { int o = __p.__offset(90); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  public string CreatedAt { get { int o = __p.__offset(92); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedAtBytes() { return __p.__vector_as_span<byte>(92, 1); }
#else
  public ArraySegment<byte>? GetCreatedAtBytes() { return __p.__vector_as_arraysegment(92); }
#endif
  public byte[] GetCreatedAtArray() { return __p.__vector_as_array<byte>(92); }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  public string CreatedBy { get { int o = __p.__offset(94); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCreatedByBytes() { return __p.__vector_as_span<byte>(94, 1); }
#else
  public ArraySegment<byte>? GetCreatedByBytes() { return __p.__vector_as_arraysegment(94); }
#endif
  public byte[] GetCreatedByArray() { return __p.__vector_as_array<byte>(94); }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  public string Source { get { int o = __p.__offset(96); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceBytes() { return __p.__vector_as_span<byte>(96, 1); }
#else
  public ArraySegment<byte>? GetSourceBytes() { return __p.__vector_as_arraysegment(96); }
#endif
  public byte[] GetSourceArray() { return __p.__vector_as_array<byte>(96); }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string SourceDL { get { int o = __p.__offset(98); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceDLBytes() { return __p.__vector_as_span<byte>(98, 1); }
#else
  public ArraySegment<byte>? GetSourceDLBytes() { return __p.__vector_as_arraysegment(98); }
#endif
  public byte[] GetSourceDLArray() { return __p.__vector_as_array<byte>(98); }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  public string Origin { get { int o = __p.__offset(100); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOriginBytes() { return __p.__vector_as_span<byte>(100, 1); }
#else
  public ArraySegment<byte>? GetOriginBytes() { return __p.__vector_as_arraysegment(100); }
#endif
  public byte[] GetOriginArray() { return __p.__vector_as_array<byte>(100); }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  public AIS_Abridged_dataMode_Enum DataMode { get { int o = __p.__offset(102); return o != 0 ? (AIS_Abridged_dataMode_Enum)__p.bb.GetSbyte(o + __p.bb_pos) : AIS_Abridged_dataMode_Enum.REAL; } }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  public string OrigNetwork { get { int o = __p.__offset(104); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOrigNetworkBytes() { return __p.__vector_as_span<byte>(104, 1); }
#else
  public ArraySegment<byte>? GetOrigNetworkBytes() { return __p.__vector_as_arraysegment(104); }
#endif
  public byte[] GetOrigNetworkArray() { return __p.__vector_as_array<byte>(104); }

  public static Offset<AIS_Abridged> CreateAIS_Abridged(FlatBufferBuilder builder,
      StringOffset idOffset = default(StringOffset),
      StringOffset classificationMarkingOffset = default(StringOffset),
      StringOffset idTrackOffset = default(StringOffset),
      StringOffset idVesselOffset = default(StringOffset),
      long mmsi = 0,
      long imon = 0,
      StringOffset tsOffset = default(StringOffset),
      StringOffset shipNameOffset = default(StringOffset),
      StringOffset shipTypeOffset = default(StringOffset),
      StringOffset engagedInOffset = default(StringOffset),
      StringOffset specialCraftOffset = default(StringOffset),
      StringOffset cargoTypeOffset = default(StringOffset),
      StringOffset callSignOffset = default(StringOffset),
      StringOffset vesselFlagOffset = default(StringOffset),
      double lat = 0.0,
      double lon = 0.0,
      bool posHiAccuracy = false,
      bool posHiLatency = false,
      double speed = 0.0,
      double trueHeading = 0.0,
      double course = 0.0,
      double rateOfTurn = 0.0,
      bool specialManeuver = false,
      StringOffset navStatusOffset = default(StringOffset),
      StringOffset posDeviceTypeOffset = default(StringOffset),
      VectorOffset antennaRefDimensionsOffset = default(VectorOffset),
      double length = 0.0,
      double width = 0.0,
      double draught = 0.0,
      StringOffset shipDescriptionOffset = default(StringOffset),
      StringOffset destinationOffset = default(StringOffset),
      StringOffset destinationETAOffset = default(StringOffset),
      StringOffset currentPortGUIDOffset = default(StringOffset),
      StringOffset currentPortLOCODEOffset = default(StringOffset),
      StringOffset lastPortGUIDOffset = default(StringOffset),
      StringOffset lastPortLOCODEOffset = default(StringOffset),
      StringOffset nextPortGUIDOffset = default(StringOffset),
      StringOffset nextPortLOCODEOffset = default(StringOffset),
      StringOffset etaCalculatedOffset = default(StringOffset),
      StringOffset etaUpdatedOffset = default(StringOffset),
      double distanceToGo = 0.0,
      double distanceTravelled = 0.0,
      double avgSpeed = 0.0,
      double maxSpeed = 0.0,
      StringOffset createdAtOffset = default(StringOffset),
      StringOffset createdByOffset = default(StringOffset),
      StringOffset sourceOffset = default(StringOffset),
      StringOffset sourceDLOffset = default(StringOffset),
      StringOffset originOffset = default(StringOffset),
      AIS_Abridged_dataMode_Enum dataMode = AIS_Abridged_dataMode_Enum.REAL,
      StringOffset origNetworkOffset = default(StringOffset)) {
    builder.StartTable(51);
    AIS_Abridged.AddMaxSpeed(builder, maxSpeed);
    AIS_Abridged.AddAvgSpeed(builder, avgSpeed);
    AIS_Abridged.AddDistanceTravelled(builder, distanceTravelled);
    AIS_Abridged.AddDistanceToGo(builder, distanceToGo);
    AIS_Abridged.AddDraught(builder, draught);
    AIS_Abridged.AddWidth(builder, width);
    AIS_Abridged.AddLength(builder, length);
    AIS_Abridged.AddRateOfTurn(builder, rateOfTurn);
    AIS_Abridged.AddCourse(builder, course);
    AIS_Abridged.AddTrueHeading(builder, trueHeading);
    AIS_Abridged.AddSpeed(builder, speed);
    AIS_Abridged.AddLon(builder, lon);
    AIS_Abridged.AddLat(builder, lat);
    AIS_Abridged.AddImon(builder, imon);
    AIS_Abridged.AddMmsi(builder, mmsi);
    AIS_Abridged.AddOrigNetwork(builder, origNetworkOffset);
    AIS_Abridged.AddOrigin(builder, originOffset);
    AIS_Abridged.AddSourceDL(builder, sourceDLOffset);
    AIS_Abridged.AddSource(builder, sourceOffset);
    AIS_Abridged.AddCreatedBy(builder, createdByOffset);
    AIS_Abridged.AddCreatedAt(builder, createdAtOffset);
    AIS_Abridged.AddEtaUpdated(builder, etaUpdatedOffset);
    AIS_Abridged.AddEtaCalculated(builder, etaCalculatedOffset);
    AIS_Abridged.AddNextPortLOCODE(builder, nextPortLOCODEOffset);
    AIS_Abridged.AddNextPortGUID(builder, nextPortGUIDOffset);
    AIS_Abridged.AddLastPortLOCODE(builder, lastPortLOCODEOffset);
    AIS_Abridged.AddLastPortGUID(builder, lastPortGUIDOffset);
    AIS_Abridged.AddCurrentPortLOCODE(builder, currentPortLOCODEOffset);
    AIS_Abridged.AddCurrentPortGUID(builder, currentPortGUIDOffset);
    AIS_Abridged.AddDestinationETA(builder, destinationETAOffset);
    AIS_Abridged.AddDestination(builder, destinationOffset);
    AIS_Abridged.AddShipDescription(builder, shipDescriptionOffset);
    AIS_Abridged.AddAntennaRefDimensions(builder, antennaRefDimensionsOffset);
    AIS_Abridged.AddPosDeviceType(builder, posDeviceTypeOffset);
    AIS_Abridged.AddNavStatus(builder, navStatusOffset);
    AIS_Abridged.AddVesselFlag(builder, vesselFlagOffset);
    AIS_Abridged.AddCallSign(builder, callSignOffset);
    AIS_Abridged.AddCargoType(builder, cargoTypeOffset);
    AIS_Abridged.AddSpecialCraft(builder, specialCraftOffset);
    AIS_Abridged.AddEngagedIn(builder, engagedInOffset);
    AIS_Abridged.AddShipType(builder, shipTypeOffset);
    AIS_Abridged.AddShipName(builder, shipNameOffset);
    AIS_Abridged.AddTs(builder, tsOffset);
    AIS_Abridged.AddIdVessel(builder, idVesselOffset);
    AIS_Abridged.AddIdTrack(builder, idTrackOffset);
    AIS_Abridged.AddClassificationMarking(builder, classificationMarkingOffset);
    AIS_Abridged.AddId(builder, idOffset);
    AIS_Abridged.AddDataMode(builder, dataMode);
    AIS_Abridged.AddSpecialManeuver(builder, specialManeuver);
    AIS_Abridged.AddPosHiLatency(builder, posHiLatency);
    AIS_Abridged.AddPosHiAccuracy(builder, posHiAccuracy);
    return AIS_Abridged.EndAIS_Abridged(builder);
  }

  public static void StartAIS_Abridged(FlatBufferBuilder builder) { builder.StartTable(51); }
  public static void AddId(FlatBufferBuilder builder, StringOffset idOffset) { builder.AddOffset(0, idOffset.Value, 0); }
  public static void AddClassificationMarking(FlatBufferBuilder builder, StringOffset classificationMarkingOffset) { builder.AddOffset(1, classificationMarkingOffset.Value, 0); }
  public static void AddIdTrack(FlatBufferBuilder builder, StringOffset idTrackOffset) { builder.AddOffset(2, idTrackOffset.Value, 0); }
  public static void AddIdVessel(FlatBufferBuilder builder, StringOffset idVesselOffset) { builder.AddOffset(3, idVesselOffset.Value, 0); }
  public static void AddMmsi(FlatBufferBuilder builder, long mmsi) { builder.AddLong(4, mmsi, 0); }
  public static void AddImon(FlatBufferBuilder builder, long imon) { builder.AddLong(5, imon, 0); }
  public static void AddTs(FlatBufferBuilder builder, StringOffset tsOffset) { builder.AddOffset(6, tsOffset.Value, 0); }
  public static void AddShipName(FlatBufferBuilder builder, StringOffset shipNameOffset) { builder.AddOffset(7, shipNameOffset.Value, 0); }
  public static void AddShipType(FlatBufferBuilder builder, StringOffset shipTypeOffset) { builder.AddOffset(8, shipTypeOffset.Value, 0); }
  public static void AddEngagedIn(FlatBufferBuilder builder, StringOffset engagedInOffset) { builder.AddOffset(9, engagedInOffset.Value, 0); }
  public static void AddSpecialCraft(FlatBufferBuilder builder, StringOffset specialCraftOffset) { builder.AddOffset(10, specialCraftOffset.Value, 0); }
  public static void AddCargoType(FlatBufferBuilder builder, StringOffset cargoTypeOffset) { builder.AddOffset(11, cargoTypeOffset.Value, 0); }
  public static void AddCallSign(FlatBufferBuilder builder, StringOffset callSignOffset) { builder.AddOffset(12, callSignOffset.Value, 0); }
  public static void AddVesselFlag(FlatBufferBuilder builder, StringOffset vesselFlagOffset) { builder.AddOffset(13, vesselFlagOffset.Value, 0); }
  public static void AddLat(FlatBufferBuilder builder, double lat) { builder.AddDouble(14, lat, 0.0); }
  public static void AddLon(FlatBufferBuilder builder, double lon) { builder.AddDouble(15, lon, 0.0); }
  public static void AddPosHiAccuracy(FlatBufferBuilder builder, bool posHiAccuracy) { builder.AddBool(16, posHiAccuracy, false); }
  public static void AddPosHiLatency(FlatBufferBuilder builder, bool posHiLatency) { builder.AddBool(17, posHiLatency, false); }
  public static void AddSpeed(FlatBufferBuilder builder, double speed) { builder.AddDouble(18, speed, 0.0); }
  public static void AddTrueHeading(FlatBufferBuilder builder, double trueHeading) { builder.AddDouble(19, trueHeading, 0.0); }
  public static void AddCourse(FlatBufferBuilder builder, double course) { builder.AddDouble(20, course, 0.0); }
  public static void AddRateOfTurn(FlatBufferBuilder builder, double rateOfTurn) { builder.AddDouble(21, rateOfTurn, 0.0); }
  public static void AddSpecialManeuver(FlatBufferBuilder builder, bool specialManeuver) { builder.AddBool(22, specialManeuver, false); }
  public static void AddNavStatus(FlatBufferBuilder builder, StringOffset navStatusOffset) { builder.AddOffset(23, navStatusOffset.Value, 0); }
  public static void AddPosDeviceType(FlatBufferBuilder builder, StringOffset posDeviceTypeOffset) { builder.AddOffset(24, posDeviceTypeOffset.Value, 0); }
  public static void AddAntennaRefDimensions(FlatBufferBuilder builder, VectorOffset antennaRefDimensionsOffset) { builder.AddOffset(25, antennaRefDimensionsOffset.Value, 0); }
  public static VectorOffset CreateAntennaRefDimensionsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAntennaRefDimensionsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAntennaRefDimensionsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAntennaRefDimensionsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAntennaRefDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddLength(FlatBufferBuilder builder, double length) { builder.AddDouble(26, length, 0.0); }
  public static void AddWidth(FlatBufferBuilder builder, double width) { builder.AddDouble(27, width, 0.0); }
  public static void AddDraught(FlatBufferBuilder builder, double draught) { builder.AddDouble(28, draught, 0.0); }
  public static void AddShipDescription(FlatBufferBuilder builder, StringOffset shipDescriptionOffset) { builder.AddOffset(29, shipDescriptionOffset.Value, 0); }
  public static void AddDestination(FlatBufferBuilder builder, StringOffset destinationOffset) { builder.AddOffset(30, destinationOffset.Value, 0); }
  public static void AddDestinationETA(FlatBufferBuilder builder, StringOffset destinationETAOffset) { builder.AddOffset(31, destinationETAOffset.Value, 0); }
  public static void AddCurrentPortGUID(FlatBufferBuilder builder, StringOffset currentPortGUIDOffset) { builder.AddOffset(32, currentPortGUIDOffset.Value, 0); }
  public static void AddCurrentPortLOCODE(FlatBufferBuilder builder, StringOffset currentPortLOCODEOffset) { builder.AddOffset(33, currentPortLOCODEOffset.Value, 0); }
  public static void AddLastPortGUID(FlatBufferBuilder builder, StringOffset lastPortGUIDOffset) { builder.AddOffset(34, lastPortGUIDOffset.Value, 0); }
  public static void AddLastPortLOCODE(FlatBufferBuilder builder, StringOffset lastPortLOCODEOffset) { builder.AddOffset(35, lastPortLOCODEOffset.Value, 0); }
  public static void AddNextPortGUID(FlatBufferBuilder builder, StringOffset nextPortGUIDOffset) { builder.AddOffset(36, nextPortGUIDOffset.Value, 0); }
  public static void AddNextPortLOCODE(FlatBufferBuilder builder, StringOffset nextPortLOCODEOffset) { builder.AddOffset(37, nextPortLOCODEOffset.Value, 0); }
  public static void AddEtaCalculated(FlatBufferBuilder builder, StringOffset etaCalculatedOffset) { builder.AddOffset(38, etaCalculatedOffset.Value, 0); }
  public static void AddEtaUpdated(FlatBufferBuilder builder, StringOffset etaUpdatedOffset) { builder.AddOffset(39, etaUpdatedOffset.Value, 0); }
  public static void AddDistanceToGo(FlatBufferBuilder builder, double distanceToGo) { builder.AddDouble(40, distanceToGo, 0.0); }
  public static void AddDistanceTravelled(FlatBufferBuilder builder, double distanceTravelled) { builder.AddDouble(41, distanceTravelled, 0.0); }
  public static void AddAvgSpeed(FlatBufferBuilder builder, double avgSpeed) { builder.AddDouble(42, avgSpeed, 0.0); }
  public static void AddMaxSpeed(FlatBufferBuilder builder, double maxSpeed) { builder.AddDouble(43, maxSpeed, 0.0); }
  public static void AddCreatedAt(FlatBufferBuilder builder, StringOffset createdAtOffset) { builder.AddOffset(44, createdAtOffset.Value, 0); }
  public static void AddCreatedBy(FlatBufferBuilder builder, StringOffset createdByOffset) { builder.AddOffset(45, createdByOffset.Value, 0); }
  public static void AddSource(FlatBufferBuilder builder, StringOffset sourceOffset) { builder.AddOffset(46, sourceOffset.Value, 0); }
  public static void AddSourceDL(FlatBufferBuilder builder, StringOffset sourceDLOffset) { builder.AddOffset(47, sourceDLOffset.Value, 0); }
  public static void AddOrigin(FlatBufferBuilder builder, StringOffset originOffset) { builder.AddOffset(48, originOffset.Value, 0); }
  public static void AddDataMode(FlatBufferBuilder builder, AIS_Abridged_dataMode_Enum dataMode) { builder.AddSbyte(49, (sbyte)dataMode, 0); }
  public static void AddOrigNetwork(FlatBufferBuilder builder, StringOffset origNetworkOffset) { builder.AddOffset(50, origNetworkOffset.Value, 0); }
  public static Offset<AIS_Abridged> EndAIS_Abridged(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<AIS_Abridged>(o);
  }
  public static void FinishAIS_AbridgedBuffer(FlatBufferBuilder builder, Offset<AIS_Abridged> offset) { builder.Finish(offset.Value, "AISA"); }
  public static void FinishSizePrefixedAIS_AbridgedBuffer(FlatBufferBuilder builder, Offset<AIS_Abridged> offset) { builder.FinishSizePrefixed(offset.Value, "AISA"); }
  public AIS_AbridgedT UnPack() {
    var _o = new AIS_AbridgedT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(AIS_AbridgedT _o) {
    _o.Id = this.Id;
    _o.ClassificationMarking = this.ClassificationMarking;
    _o.IdTrack = this.IdTrack;
    _o.IdVessel = this.IdVessel;
    _o.Mmsi = this.Mmsi;
    _o.Imon = this.Imon;
    _o.Ts = this.Ts;
    _o.ShipName = this.ShipName;
    _o.ShipType = this.ShipType;
    _o.EngagedIn = this.EngagedIn;
    _o.SpecialCraft = this.SpecialCraft;
    _o.CargoType = this.CargoType;
    _o.CallSign = this.CallSign;
    _o.VesselFlag = this.VesselFlag;
    _o.Lat = this.Lat;
    _o.Lon = this.Lon;
    _o.PosHiAccuracy = this.PosHiAccuracy;
    _o.PosHiLatency = this.PosHiLatency;
    _o.Speed = this.Speed;
    _o.TrueHeading = this.TrueHeading;
    _o.Course = this.Course;
    _o.RateOfTurn = this.RateOfTurn;
    _o.SpecialManeuver = this.SpecialManeuver;
    _o.NavStatus = this.NavStatus;
    _o.PosDeviceType = this.PosDeviceType;
    _o.AntennaRefDimensions = new List<string>();
    for (var _j = 0; _j < this.AntennaRefDimensionsLength; ++_j) {_o.AntennaRefDimensions.Add(this.AntennaRefDimensions(_j));}
    _o.Length = this.Length;
    _o.Width = this.Width;
    _o.Draught = this.Draught;
    _o.ShipDescription = this.ShipDescription;
    _o.Destination = this.Destination;
    _o.DestinationETA = this.DestinationETA;
    _o.CurrentPortGUID = this.CurrentPortGUID;
    _o.CurrentPortLOCODE = this.CurrentPortLOCODE;
    _o.LastPortGUID = this.LastPortGUID;
    _o.LastPortLOCODE = this.LastPortLOCODE;
    _o.NextPortGUID = this.NextPortGUID;
    _o.NextPortLOCODE = this.NextPortLOCODE;
    _o.EtaCalculated = this.EtaCalculated;
    _o.EtaUpdated = this.EtaUpdated;
    _o.DistanceToGo = this.DistanceToGo;
    _o.DistanceTravelled = this.DistanceTravelled;
    _o.AvgSpeed = this.AvgSpeed;
    _o.MaxSpeed = this.MaxSpeed;
    _o.CreatedAt = this.CreatedAt;
    _o.CreatedBy = this.CreatedBy;
    _o.Source = this.Source;
    _o.SourceDL = this.SourceDL;
    _o.Origin = this.Origin;
    _o.DataMode = this.DataMode;
    _o.OrigNetwork = this.OrigNetwork;
  }
  public static Offset<AIS_Abridged> Pack(FlatBufferBuilder builder, AIS_AbridgedT _o) {
    if (_o == null) return default(Offset<AIS_Abridged>);
    var _id = _o.Id == null ? default(StringOffset) : builder.CreateString(_o.Id);
    var _classificationMarking = _o.ClassificationMarking == null ? default(StringOffset) : builder.CreateString(_o.ClassificationMarking);
    var _idTrack = _o.IdTrack == null ? default(StringOffset) : builder.CreateString(_o.IdTrack);
    var _idVessel = _o.IdVessel == null ? default(StringOffset) : builder.CreateString(_o.IdVessel);
    var _ts = _o.Ts == null ? default(StringOffset) : builder.CreateString(_o.Ts);
    var _shipName = _o.ShipName == null ? default(StringOffset) : builder.CreateString(_o.ShipName);
    var _shipType = _o.ShipType == null ? default(StringOffset) : builder.CreateString(_o.ShipType);
    var _engagedIn = _o.EngagedIn == null ? default(StringOffset) : builder.CreateString(_o.EngagedIn);
    var _specialCraft = _o.SpecialCraft == null ? default(StringOffset) : builder.CreateString(_o.SpecialCraft);
    var _cargoType = _o.CargoType == null ? default(StringOffset) : builder.CreateString(_o.CargoType);
    var _callSign = _o.CallSign == null ? default(StringOffset) : builder.CreateString(_o.CallSign);
    var _vesselFlag = _o.VesselFlag == null ? default(StringOffset) : builder.CreateString(_o.VesselFlag);
    var _navStatus = _o.NavStatus == null ? default(StringOffset) : builder.CreateString(_o.NavStatus);
    var _posDeviceType = _o.PosDeviceType == null ? default(StringOffset) : builder.CreateString(_o.PosDeviceType);
    var _antennaRefDimensions = default(VectorOffset);
    if (_o.AntennaRefDimensions != null) {
      var __antennaRefDimensions = new StringOffset[_o.AntennaRefDimensions.Count];
      for (var _j = 0; _j < __antennaRefDimensions.Length; ++_j) { __antennaRefDimensions[_j] = builder.CreateString(_o.AntennaRefDimensions[_j]); }
      _antennaRefDimensions = CreateAntennaRefDimensionsVector(builder, __antennaRefDimensions);
    }
    var _shipDescription = _o.ShipDescription == null ? default(StringOffset) : builder.CreateString(_o.ShipDescription);
    var _destination = _o.Destination == null ? default(StringOffset) : builder.CreateString(_o.Destination);
    var _destinationETA = _o.DestinationETA == null ? default(StringOffset) : builder.CreateString(_o.DestinationETA);
    var _currentPortGUID = _o.CurrentPortGUID == null ? default(StringOffset) : builder.CreateString(_o.CurrentPortGUID);
    var _currentPortLOCODE = _o.CurrentPortLOCODE == null ? default(StringOffset) : builder.CreateString(_o.CurrentPortLOCODE);
    var _lastPortGUID = _o.LastPortGUID == null ? default(StringOffset) : builder.CreateString(_o.LastPortGUID);
    var _lastPortLOCODE = _o.LastPortLOCODE == null ? default(StringOffset) : builder.CreateString(_o.LastPortLOCODE);
    var _nextPortGUID = _o.NextPortGUID == null ? default(StringOffset) : builder.CreateString(_o.NextPortGUID);
    var _nextPortLOCODE = _o.NextPortLOCODE == null ? default(StringOffset) : builder.CreateString(_o.NextPortLOCODE);
    var _etaCalculated = _o.EtaCalculated == null ? default(StringOffset) : builder.CreateString(_o.EtaCalculated);
    var _etaUpdated = _o.EtaUpdated == null ? default(StringOffset) : builder.CreateString(_o.EtaUpdated);
    var _createdAt = _o.CreatedAt == null ? default(StringOffset) : builder.CreateString(_o.CreatedAt);
    var _createdBy = _o.CreatedBy == null ? default(StringOffset) : builder.CreateString(_o.CreatedBy);
    var _source = _o.Source == null ? default(StringOffset) : builder.CreateString(_o.Source);
    var _sourceDL = _o.SourceDL == null ? default(StringOffset) : builder.CreateString(_o.SourceDL);
    var _origin = _o.Origin == null ? default(StringOffset) : builder.CreateString(_o.Origin);
    var _origNetwork = _o.OrigNetwork == null ? default(StringOffset) : builder.CreateString(_o.OrigNetwork);
    return CreateAIS_Abridged(
      builder,
      _id,
      _classificationMarking,
      _idTrack,
      _idVessel,
      _o.Mmsi,
      _o.Imon,
      _ts,
      _shipName,
      _shipType,
      _engagedIn,
      _specialCraft,
      _cargoType,
      _callSign,
      _vesselFlag,
      _o.Lat,
      _o.Lon,
      _o.PosHiAccuracy,
      _o.PosHiLatency,
      _o.Speed,
      _o.TrueHeading,
      _o.Course,
      _o.RateOfTurn,
      _o.SpecialManeuver,
      _navStatus,
      _posDeviceType,
      _antennaRefDimensions,
      _o.Length,
      _o.Width,
      _o.Draught,
      _shipDescription,
      _destination,
      _destinationETA,
      _currentPortGUID,
      _currentPortLOCODE,
      _lastPortGUID,
      _lastPortLOCODE,
      _nextPortGUID,
      _nextPortLOCODE,
      _etaCalculated,
      _etaUpdated,
      _o.DistanceToGo,
      _o.DistanceTravelled,
      _o.AvgSpeed,
      _o.MaxSpeed,
      _createdAt,
      _createdBy,
      _source,
      _sourceDL,
      _origin,
      _o.DataMode,
      _origNetwork);
  }
}

public class AIS_AbridgedT
{
  public string Id { get; set; }
  public string ClassificationMarking { get; set; }
  public string IdTrack { get; set; }
  public string IdVessel { get; set; }
  public long Mmsi { get; set; }
  public long Imon { get; set; }
  public string Ts { get; set; }
  public string ShipName { get; set; }
  public string ShipType { get; set; }
  public string EngagedIn { get; set; }
  public string SpecialCraft { get; set; }
  public string CargoType { get; set; }
  public string CallSign { get; set; }
  public string VesselFlag { get; set; }
  public double Lat { get; set; }
  public double Lon { get; set; }
  public bool PosHiAccuracy { get; set; }
  public bool PosHiLatency { get; set; }
  public double Speed { get; set; }
  public double TrueHeading { get; set; }
  public double Course { get; set; }
  public double RateOfTurn { get; set; }
  public bool SpecialManeuver { get; set; }
  public string NavStatus { get; set; }
  public string PosDeviceType { get; set; }
  public List<string> AntennaRefDimensions { get; set; }
  public double Length { get; set; }
  public double Width { get; set; }
  public double Draught { get; set; }
  public string ShipDescription { get; set; }
  public string Destination { get; set; }
  public string DestinationETA { get; set; }
  public string CurrentPortGUID { get; set; }
  public string CurrentPortLOCODE { get; set; }
  public string LastPortGUID { get; set; }
  public string LastPortLOCODE { get; set; }
  public string NextPortGUID { get; set; }
  public string NextPortLOCODE { get; set; }
  public string EtaCalculated { get; set; }
  public string EtaUpdated { get; set; }
  public double DistanceToGo { get; set; }
  public double DistanceTravelled { get; set; }
  public double AvgSpeed { get; set; }
  public double MaxSpeed { get; set; }
  public string CreatedAt { get; set; }
  public string CreatedBy { get; set; }
  public string Source { get; set; }
  public string SourceDL { get; set; }
  public string Origin { get; set; }
  public AIS_Abridged_dataMode_Enum DataMode { get; set; }
  public string OrigNetwork { get; set; }

  public AIS_AbridgedT() {
    this.Id = null;
    this.ClassificationMarking = null;
    this.IdTrack = null;
    this.IdVessel = null;
    this.Mmsi = 0;
    this.Imon = 0;
    this.Ts = null;
    this.ShipName = null;
    this.ShipType = null;
    this.EngagedIn = null;
    this.SpecialCraft = null;
    this.CargoType = null;
    this.CallSign = null;
    this.VesselFlag = null;
    this.Lat = 0.0;
    this.Lon = 0.0;
    this.PosHiAccuracy = false;
    this.PosHiLatency = false;
    this.Speed = 0.0;
    this.TrueHeading = 0.0;
    this.Course = 0.0;
    this.RateOfTurn = 0.0;
    this.SpecialManeuver = false;
    this.NavStatus = null;
    this.PosDeviceType = null;
    this.AntennaRefDimensions = null;
    this.Length = 0.0;
    this.Width = 0.0;
    this.Draught = 0.0;
    this.ShipDescription = null;
    this.Destination = null;
    this.DestinationETA = null;
    this.CurrentPortGUID = null;
    this.CurrentPortLOCODE = null;
    this.LastPortGUID = null;
    this.LastPortLOCODE = null;
    this.NextPortGUID = null;
    this.NextPortLOCODE = null;
    this.EtaCalculated = null;
    this.EtaUpdated = null;
    this.DistanceToGo = 0.0;
    this.DistanceTravelled = 0.0;
    this.AvgSpeed = 0.0;
    this.MaxSpeed = 0.0;
    this.CreatedAt = null;
    this.CreatedBy = null;
    this.Source = null;
    this.SourceDL = null;
    this.Origin = null;
    this.DataMode = AIS_Abridged_dataMode_Enum.REAL;
    this.OrigNetwork = null;
  }
  public static AIS_AbridgedT DeserializeFromBinary(byte[] fbBuffer) {
    return AIS_Abridged.GetRootAsAIS_Abridged(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    AIS_Abridged.FinishAIS_AbridgedBuffer(fbb, AIS_Abridged.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class AIS_AbridgedVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Id*/, false)
      && verifier.VerifyString(tablePos, 6 /*ClassificationMarking*/, false)
      && verifier.VerifyString(tablePos, 8 /*IdTrack*/, false)
      && verifier.VerifyString(tablePos, 10 /*IdVessel*/, false)
      && verifier.VerifyField(tablePos, 12 /*Mmsi*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 14 /*Imon*/, 8 /*long*/, 8, false)
      && verifier.VerifyString(tablePos, 16 /*Ts*/, false)
      && verifier.VerifyString(tablePos, 18 /*ShipName*/, false)
      && verifier.VerifyString(tablePos, 20 /*ShipType*/, false)
      && verifier.VerifyString(tablePos, 22 /*EngagedIn*/, false)
      && verifier.VerifyString(tablePos, 24 /*SpecialCraft*/, false)
      && verifier.VerifyString(tablePos, 26 /*CargoType*/, false)
      && verifier.VerifyString(tablePos, 28 /*CallSign*/, false)
      && verifier.VerifyString(tablePos, 30 /*VesselFlag*/, false)
      && verifier.VerifyField(tablePos, 32 /*Lat*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 34 /*Lon*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 36 /*PosHiAccuracy*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 38 /*PosHiLatency*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 40 /*Speed*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 42 /*TrueHeading*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 44 /*Course*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 46 /*RateOfTurn*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 48 /*SpecialManeuver*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 50 /*NavStatus*/, false)
      && verifier.VerifyString(tablePos, 52 /*PosDeviceType*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 54 /*AntennaRefDimensions*/, false)
      && verifier.VerifyField(tablePos, 56 /*Length*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 58 /*Width*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 60 /*Draught*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 62 /*ShipDescription*/, false)
      && verifier.VerifyString(tablePos, 64 /*Destination*/, false)
      && verifier.VerifyString(tablePos, 66 /*DestinationETA*/, false)
      && verifier.VerifyString(tablePos, 68 /*CurrentPortGUID*/, false)
      && verifier.VerifyString(tablePos, 70 /*CurrentPortLOCODE*/, false)
      && verifier.VerifyString(tablePos, 72 /*LastPortGUID*/, false)
      && verifier.VerifyString(tablePos, 74 /*LastPortLOCODE*/, false)
      && verifier.VerifyString(tablePos, 76 /*NextPortGUID*/, false)
      && verifier.VerifyString(tablePos, 78 /*NextPortLOCODE*/, false)
      && verifier.VerifyString(tablePos, 80 /*EtaCalculated*/, false)
      && verifier.VerifyString(tablePos, 82 /*EtaUpdated*/, false)
      && verifier.VerifyField(tablePos, 84 /*DistanceToGo*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 86 /*DistanceTravelled*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 88 /*AvgSpeed*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 90 /*MaxSpeed*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 92 /*CreatedAt*/, false)
      && verifier.VerifyString(tablePos, 94 /*CreatedBy*/, false)
      && verifier.VerifyString(tablePos, 96 /*Source*/, false)
      && verifier.VerifyString(tablePos, 98 /*SourceDL*/, false)
      && verifier.VerifyString(tablePos, 100 /*Origin*/, false)
      && verifier.VerifyField(tablePos, 102 /*DataMode*/, 1 /*AIS_Abridged_dataMode_Enum*/, 1, false)
      && verifier.VerifyString(tablePos, 104 /*OrigNetwork*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
