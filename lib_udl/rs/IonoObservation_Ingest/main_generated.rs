// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_IONO_OBSERVATION_INGEST_TRANSMIT_SENSOR_TYPE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_IONO_OBSERVATION_INGEST_TRANSMIT_SENSOR_TYPE_ENUM: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_IONO_OBSERVATION_INGEST_TRANSMIT_SENSOR_TYPE_ENUM: [IonoObservation_Ingest_transmitSensorType_Enum; 2] = [
  IonoObservation_Ingest_transmitSensorType_Enum::MOBILE,
  IonoObservation_Ingest_transmitSensorType_Enum::STATIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct IonoObservation_Ingest_transmitSensorType_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl IonoObservation_Ingest_transmitSensorType_Enum {
  /// No description available.
  pub const MOBILE: Self = Self(0);
  /// No description available.
  pub const STATIC: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MOBILE,
    Self::STATIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MOBILE => Some("MOBILE"),
      Self::STATIC => Some("STATIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for IonoObservation_Ingest_transmitSensorType_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for IonoObservation_Ingest_transmitSensorType_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for IonoObservation_Ingest_transmitSensorType_Enum {
    type Output = IonoObservation_Ingest_transmitSensorType_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for IonoObservation_Ingest_transmitSensorType_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for IonoObservation_Ingest_transmitSensorType_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for IonoObservation_Ingest_transmitSensorType_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_IONO_OBSERVATION_INGEST_RECEIVE_SENSOR_TYPE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_IONO_OBSERVATION_INGEST_RECEIVE_SENSOR_TYPE_ENUM: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_IONO_OBSERVATION_INGEST_RECEIVE_SENSOR_TYPE_ENUM: [IonoObservation_Ingest_receiveSensorType_Enum; 2] = [
  IonoObservation_Ingest_receiveSensorType_Enum::MOBILE,
  IonoObservation_Ingest_receiveSensorType_Enum::STATIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct IonoObservation_Ingest_receiveSensorType_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl IonoObservation_Ingest_receiveSensorType_Enum {
  /// No description available.
  pub const MOBILE: Self = Self(0);
  /// No description available.
  pub const STATIC: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MOBILE,
    Self::STATIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MOBILE => Some("MOBILE"),
      Self::STATIC => Some("STATIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for IonoObservation_Ingest_receiveSensorType_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for IonoObservation_Ingest_receiveSensorType_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for IonoObservation_Ingest_receiveSensorType_Enum {
    type Output = IonoObservation_Ingest_receiveSensorType_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for IonoObservation_Ingest_receiveSensorType_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for IonoObservation_Ingest_receiveSensorType_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for IonoObservation_Ingest_receiveSensorType_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_IONO_OBSERVATION_INGEST_ANTENNA_ELEMENT_POSITION_COORDINATE_SYSTEM_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_IONO_OBSERVATION_INGEST_ANTENNA_ELEMENT_POSITION_COORDINATE_SYSTEM_ENUM: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_IONO_OBSERVATION_INGEST_ANTENNA_ELEMENT_POSITION_COORDINATE_SYSTEM_ENUM: [IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum; 6] = [
  IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum::J2000,
  IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum::ECR_ECEF,
  IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum::TEME,
  IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum::GCRF,
  IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum::WGS84__GEODETIC_LAT__LONG__ALT_,
  IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum::GEOCENTRIC__LAT__LONG__RADII_,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum {
  /// No description available.
  pub const J2000: Self = Self(0);
  /// No description available.
  pub const ECR_ECEF: Self = Self(1);
  /// No description available.
  pub const TEME: Self = Self(2);
  /// No description available.
  pub const GCRF: Self = Self(3);
  /// No description available.
  pub const WGS84__GEODETIC_LAT__LONG__ALT_: Self = Self(4);
  /// No description available.
  pub const GEOCENTRIC__LAT__LONG__RADII_: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::J2000,
    Self::ECR_ECEF,
    Self::TEME,
    Self::GCRF,
    Self::WGS84__GEODETIC_LAT__LONG__ALT_,
    Self::GEOCENTRIC__LAT__LONG__RADII_,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::J2000 => Some("J2000"),
      Self::ECR_ECEF => Some("ECR_ECEF"),
      Self::TEME => Some("TEME"),
      Self::GCRF => Some("GCRF"),
      Self::WGS84__GEODETIC_LAT__LONG__ALT_ => Some("WGS84__GEODETIC_LAT__LONG__ALT_"),
      Self::GEOCENTRIC__LAT__LONG__RADII_ => Some("GEOCENTRIC__LAT__LONG__RADII_"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum {
    type Output = IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_IONO_OBSERVATION_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_IONO_OBSERVATION_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_IONO_OBSERVATION_INGEST_DATA_MODE_ENUM: [IonoObservation_Ingest_dataMode_Enum; 4] = [
  IonoObservation_Ingest_dataMode_Enum::REAL,
  IonoObservation_Ingest_dataMode_Enum::TEST,
  IonoObservation_Ingest_dataMode_Enum::SIMULATED,
  IonoObservation_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct IonoObservation_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl IonoObservation_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for IonoObservation_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for IonoObservation_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for IonoObservation_Ingest_dataMode_Enum {
    type Output = IonoObservation_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for IonoObservation_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for IonoObservation_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for IonoObservation_Ingest_dataMode_Enum {}
pub enum IonoObservation_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// These services provide operations for posting and querying ionospheric observation data. Characteristics are defined by the CHARS: URSI IIWG format for archiving monthly ionospheric characteristics, INAG Bulletin No. 62 specification. Qualifying and Descriptive letters are defined by the URSI Handbook for Ionogram Interpretation and reduction, Report UAG, No. 23A specification.
pub struct IonoObservation_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IonoObservation_Ingest<'a> {
  type Inner = IonoObservation_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IonoObservation_Ingest<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDSENSOR: flatbuffers::VOffsetT = 8;
  pub const VT_ORIGSENSORID: flatbuffers::VOffsetT = 10;
  pub const VT_SYSTEM: flatbuffers::VOffsetT = 12;
  pub const VT_NEPROFILENAME: flatbuffers::VOffsetT = 14;
  pub const VT_NEPROFILEVERSION: flatbuffers::VOffsetT = 16;
  pub const VT_SCALERINFO: flatbuffers::VOffsetT = 18;
  pub const VT_DENSITYPROFILE: flatbuffers::VOffsetT = 20;
  pub const VT_STATIONID: flatbuffers::VOffsetT = 22;
  pub const VT_STARTTIMEUTC: flatbuffers::VOffsetT = 24;
  pub const VT_SYSTEMINFO: flatbuffers::VOffsetT = 26;
  pub const VT_SYSTEMNOTES: flatbuffers::VOffsetT = 28;
  pub const VT_TRANSMITCOORDINATES: flatbuffers::VOffsetT = 30;
  pub const VT_TRANSMITSENSORTYPE: flatbuffers::VOffsetT = 32;
  pub const VT_RECEIVECOORDINATES: flatbuffers::VOffsetT = 34;
  pub const VT_RECEIVESENSORTYPE: flatbuffers::VOffsetT = 36;
  pub const VT_ANTENNAELEMENTPOSITION: flatbuffers::VOffsetT = 38;
  pub const VT_ANTENNAELEMENTPOSITIONCOORDINATESYSTEM: flatbuffers::VOffsetT = 40;
  pub const VT_POWER: flatbuffers::VOffsetT = 42;
  pub const VT_RANGE: flatbuffers::VOffsetT = 44;
  pub const VT_FREQUENCY: flatbuffers::VOffsetT = 46;
  pub const VT_POLARIZATION: flatbuffers::VOffsetT = 48;
  pub const VT_AZIMUTH: flatbuffers::VOffsetT = 50;
  pub const VT_ELEVATION: flatbuffers::VOffsetT = 52;
  pub const VT_RESTRICTEDFREQUENCY: flatbuffers::VOffsetT = 54;
  pub const VT_RESTRICTEDFREQUENCYNOTES: flatbuffers::VOffsetT = 56;
  pub const VT_DOPPLER: flatbuffers::VOffsetT = 58;
  pub const VT_TIME: flatbuffers::VOffsetT = 60;
  pub const VT_STOKES: flatbuffers::VOffsetT = 62;
  pub const VT_AMPLITUDE: flatbuffers::VOffsetT = 64;
  pub const VT_PHASE: flatbuffers::VOffsetT = 66;
  pub const VT_FOF2: flatbuffers::VOffsetT = 68;
  pub const VT_FOF1: flatbuffers::VOffsetT = 70;
  pub const VT_FXF2: flatbuffers::VOffsetT = 72;
  pub const VT_FXF1: flatbuffers::VOffsetT = 74;
  pub const VT_MD: flatbuffers::VOffsetT = 76;
  pub const VT_LUF: flatbuffers::VOffsetT = 78;
  pub const VT_MUFD: flatbuffers::VOffsetT = 80;
  pub const VT_FMIN: flatbuffers::VOffsetT = 82;
  pub const VT_FOES: flatbuffers::VOffsetT = 84;
  pub const VT_FMINF: flatbuffers::VOffsetT = 86;
  pub const VT_FMINE: flatbuffers::VOffsetT = 88;
  pub const VT_FOE: flatbuffers::VOffsetT = 90;
  pub const VT_FXE: flatbuffers::VOffsetT = 92;
  pub const VT_FXI: flatbuffers::VOffsetT = 94;
  pub const VT_HPRIMEF: flatbuffers::VOffsetT = 96;
  pub const VT_HPRIMEF2: flatbuffers::VOffsetT = 98;
  pub const VT_HPRIMEF1: flatbuffers::VOffsetT = 100;
  pub const VT_HPRIMEE: flatbuffers::VOffsetT = 102;
  pub const VT_HPRIMEES: flatbuffers::VOffsetT = 104;
  pub const VT_ZME: flatbuffers::VOffsetT = 106;
  pub const VT_YE: flatbuffers::VOffsetT = 108;
  pub const VT_QF: flatbuffers::VOffsetT = 110;
  pub const VT_QE: flatbuffers::VOffsetT = 112;
  pub const VT_DOWNF: flatbuffers::VOffsetT = 114;
  pub const VT_DOWNE: flatbuffers::VOffsetT = 116;
  pub const VT_DOWNES: flatbuffers::VOffsetT = 118;
  pub const VT_FF: flatbuffers::VOffsetT = 120;
  pub const VT_FE: flatbuffers::VOffsetT = 122;
  pub const VT_D: flatbuffers::VOffsetT = 124;
  pub const VT_FMUF: flatbuffers::VOffsetT = 126;
  pub const VT_HPRIMEFMUF: flatbuffers::VOffsetT = 128;
  pub const VT_DELTAFOF2: flatbuffers::VOffsetT = 130;
  pub const VT_FOEP: flatbuffers::VOffsetT = 132;
  pub const VT_FHPRIMEF: flatbuffers::VOffsetT = 134;
  pub const VT_FHPRIMEF2: flatbuffers::VOffsetT = 136;
  pub const VT_FOF1P: flatbuffers::VOffsetT = 138;
  pub const VT_FOF2P: flatbuffers::VOffsetT = 140;
  pub const VT_HMF2: flatbuffers::VOffsetT = 142;
  pub const VT_HMF1: flatbuffers::VOffsetT = 144;
  pub const VT_HME: flatbuffers::VOffsetT = 146;
  pub const VT_ZHALFNM: flatbuffers::VOffsetT = 148;
  pub const VT_FMINES: flatbuffers::VOffsetT = 150;
  pub const VT_YF2: flatbuffers::VOffsetT = 152;
  pub const VT_YF1: flatbuffers::VOffsetT = 154;
  pub const VT_TEC: flatbuffers::VOffsetT = 156;
  pub const VT_SCALEHEIGHTF2PEAK: flatbuffers::VOffsetT = 158;
  pub const VT_B0: flatbuffers::VOffsetT = 160;
  pub const VT_B1: flatbuffers::VOffsetT = 162;
  pub const VT_D1: flatbuffers::VOffsetT = 164;
  pub const VT_FOEA: flatbuffers::VOffsetT = 166;
  pub const VT_HPRIMEEA: flatbuffers::VOffsetT = 168;
  pub const VT_FOP: flatbuffers::VOffsetT = 170;
  pub const VT_HPRIMEP: flatbuffers::VOffsetT = 172;
  pub const VT_FBES: flatbuffers::VOffsetT = 174;
  pub const VT_TYPEES: flatbuffers::VOffsetT = 176;
  pub const VT_CHARATTS: flatbuffers::VOffsetT = 178;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 180;
  pub const VT_PLASMAFREQUENCY: flatbuffers::VOffsetT = 182;
  pub const VT_PLASMAFREQUENCYUNCERTAINTY: flatbuffers::VOffsetT = 184;
  pub const VT_ELECTRONDENSITY: flatbuffers::VOffsetT = 186;
  pub const VT_ELECTRONDENSITYUNCERTAINTY: flatbuffers::VOffsetT = 188;
  pub const VT_ARTISTFLAGS: flatbuffers::VOffsetT = 190;
  pub const VT_TRACEGENERIC: flatbuffers::VOffsetT = 192;
  pub const VT_TIDPHASESPEEDS: flatbuffers::VOffsetT = 194;
  pub const VT_TIDAZIMUTH: flatbuffers::VOffsetT = 196;
  pub const VT_TIDPERIODS: flatbuffers::VOffsetT = 198;
  pub const VT_DATUM: flatbuffers::VOffsetT = 200;
  pub const VT_PLATFORMNAME: flatbuffers::VOffsetT = 202;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 204;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 206;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 208;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 210;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 212;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 214;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 216;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 218;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IonoObservation_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IonoObservation_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<IonoObservation_Ingest<'bldr>> {
    let mut builder = IonoObservation_IngestBuilder::new(_fbb);
    builder.add_fbEs(args.fbEs);
    builder.add_hprimeP(args.hprimeP);
    builder.add_foP(args.foP);
    builder.add_hprimeEa(args.hprimeEa);
    builder.add_foEa(args.foEa);
    builder.add_d1(args.d1);
    builder.add_b1(args.b1);
    builder.add_b0(args.b0);
    builder.add_scaleHeightF2Peak(args.scaleHeightF2Peak);
    builder.add_tec(args.tec);
    builder.add_yF1(args.yF1);
    builder.add_yF2(args.yF2);
    builder.add_fminEs(args.fminEs);
    builder.add_zhalfNm(args.zhalfNm);
    builder.add_hmE(args.hmE);
    builder.add_hmF1(args.hmF1);
    builder.add_hmF2(args.hmF2);
    builder.add_foF2p(args.foF2p);
    builder.add_foF1p(args.foF1p);
    builder.add_fhprimeF2(args.fhprimeF2);
    builder.add_fhprimeF(args.fhprimeF);
    builder.add_foEp(args.foEp);
    builder.add_deltafoF2(args.deltafoF2);
    builder.add_hprimefMUF(args.hprimefMUF);
    builder.add_fmuf(args.fmuf);
    builder.add_d(args.d);
    builder.add_fe(args.fe);
    builder.add_ff(args.ff);
    builder.add_downEs(args.downEs);
    builder.add_downE(args.downE);
    builder.add_downF(args.downF);
    builder.add_qe(args.qe);
    builder.add_qf(args.qf);
    builder.add_yE(args.yE);
    builder.add_zmE(args.zmE);
    builder.add_hprimeEs(args.hprimeEs);
    builder.add_hprimeE(args.hprimeE);
    builder.add_hprimeF1(args.hprimeF1);
    builder.add_hprimeF2(args.hprimeF2);
    builder.add_hprimeF(args.hprimeF);
    builder.add_fxI(args.fxI);
    builder.add_fxE(args.fxE);
    builder.add_foE(args.foE);
    builder.add_fminE(args.fminE);
    builder.add_fminF(args.fminF);
    builder.add_foEs(args.foEs);
    builder.add_fmin(args.fmin);
    builder.add_mufd(args.mufd);
    builder.add_luf(args.luf);
    builder.add_md(args.md);
    builder.add_fxF1(args.fxF1);
    builder.add_fxF2(args.fxF2);
    builder.add_foF1(args.foF1);
    builder.add_foF2(args.foF2);
    builder.add_neProfileVersion(args.neProfileVersion);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.platformName { builder.add_platformName(x); }
    if let Some(x) = args.datum { builder.add_datum(x); }
    if let Some(x) = args.tidPeriods { builder.add_tidPeriods(x); }
    if let Some(x) = args.tidAzimuth { builder.add_tidAzimuth(x); }
    if let Some(x) = args.tidPhaseSpeeds { builder.add_tidPhaseSpeeds(x); }
    if let Some(x) = args.traceGeneric { builder.add_traceGeneric(x); }
    if let Some(x) = args.artistFlags { builder.add_artistFlags(x); }
    if let Some(x) = args.electronDensityUncertainty { builder.add_electronDensityUncertainty(x); }
    if let Some(x) = args.electronDensity { builder.add_electronDensity(x); }
    if let Some(x) = args.plasmaFrequencyUncertainty { builder.add_plasmaFrequencyUncertainty(x); }
    if let Some(x) = args.plasmaFrequency { builder.add_plasmaFrequency(x); }
    if let Some(x) = args.height { builder.add_height(x); }
    if let Some(x) = args.charAtts { builder.add_charAtts(x); }
    if let Some(x) = args.typeEs { builder.add_typeEs(x); }
    if let Some(x) = args.phase { builder.add_phase(x); }
    if let Some(x) = args.amplitude { builder.add_amplitude(x); }
    if let Some(x) = args.stokes { builder.add_stokes(x); }
    if let Some(x) = args.time { builder.add_time(x); }
    if let Some(x) = args.doppler { builder.add_doppler(x); }
    if let Some(x) = args.restrictedFrequencyNotes { builder.add_restrictedFrequencyNotes(x); }
    if let Some(x) = args.restrictedFrequency { builder.add_restrictedFrequency(x); }
    if let Some(x) = args.elevation { builder.add_elevation(x); }
    if let Some(x) = args.azimuth { builder.add_azimuth(x); }
    if let Some(x) = args.polarization { builder.add_polarization(x); }
    if let Some(x) = args.frequency { builder.add_frequency(x); }
    if let Some(x) = args.range { builder.add_range(x); }
    if let Some(x) = args.power { builder.add_power(x); }
    if let Some(x) = args.antennaElementPosition { builder.add_antennaElementPosition(x); }
    if let Some(x) = args.receiveCoordinates { builder.add_receiveCoordinates(x); }
    if let Some(x) = args.transmitCoordinates { builder.add_transmitCoordinates(x); }
    if let Some(x) = args.systemNotes { builder.add_systemNotes(x); }
    if let Some(x) = args.systemInfo { builder.add_systemInfo(x); }
    if let Some(x) = args.startTimeUTC { builder.add_startTimeUTC(x); }
    if let Some(x) = args.stationId { builder.add_stationId(x); }
    if let Some(x) = args.densityProfile { builder.add_densityProfile(x); }
    if let Some(x) = args.scalerInfo { builder.add_scalerInfo(x); }
    if let Some(x) = args.neProfileName { builder.add_neProfileName(x); }
    if let Some(x) = args.system { builder.add_system(x); }
    if let Some(x) = args.origSensorId { builder.add_origSensorId(x); }
    if let Some(x) = args.idSensor { builder.add_idSensor(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_antennaElementPositionCoordinateSystem(args.antennaElementPositionCoordinateSystem);
    builder.add_receiveSensorType(args.receiveSensorType);
    builder.add_transmitSensorType(args.transmitSensorType);
    builder.finish()
  }

  pub fn unpack(&self) -> IonoObservation_IngestT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idSensor = self.idSensor().map(|x| {
      x.to_string()
    });
    let origSensorId = self.origSensorId().map(|x| {
      x.to_string()
    });
    let system = self.system().map(|x| {
      x.to_string()
    });
    let neProfileName = self.neProfileName().map(|x| {
      x.to_string()
    });
    let neProfileVersion = self.neProfileVersion();
    let scalerInfo = self.scalerInfo().map(|x| {
      x.to_string()
    });
    let densityProfile = self.densityProfile().map(|x| {
      x.to_string()
    });
    let stationId = self.stationId().map(|x| {
      x.to_string()
    });
    let startTimeUTC = self.startTimeUTC().map(|x| {
      x.to_string()
    });
    let systemInfo = self.systemInfo().map(|x| {
      x.to_string()
    });
    let systemNotes = self.systemNotes().map(|x| {
      x.to_string()
    });
    let transmitCoordinates = self.transmitCoordinates().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let transmitSensorType = self.transmitSensorType();
    let receiveCoordinates = self.receiveCoordinates().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let receiveSensorType = self.receiveSensorType();
    let antennaElementPosition = self.antennaElementPosition().map(|x| {
      x.to_string()
    });
    let antennaElementPositionCoordinateSystem = self.antennaElementPositionCoordinateSystem();
    let power = self.power().map(|x| {
      x.to_string()
    });
    let range = self.range().map(|x| {
      x.to_string()
    });
    let frequency = self.frequency().map(|x| {
      x.to_string()
    });
    let polarization = self.polarization().map(|x| {
      x.to_string()
    });
    let azimuth = self.azimuth().map(|x| {
      x.to_string()
    });
    let elevation = self.elevation().map(|x| {
      x.to_string()
    });
    let restrictedFrequency = self.restrictedFrequency().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let restrictedFrequencyNotes = self.restrictedFrequencyNotes().map(|x| {
      x.to_string()
    });
    let doppler = self.doppler().map(|x| {
      x.to_string()
    });
    let time = self.time().map(|x| {
      x.to_string()
    });
    let stokes = self.stokes().map(|x| {
      x.to_string()
    });
    let amplitude = self.amplitude().map(|x| {
      x.to_string()
    });
    let phase = self.phase().map(|x| {
      x.to_string()
    });
    let foF2 = self.foF2();
    let foF1 = self.foF1();
    let fxF2 = self.fxF2();
    let fxF1 = self.fxF1();
    let md = self.md();
    let luf = self.luf();
    let mufd = self.mufd();
    let fmin = self.fmin();
    let foEs = self.foEs();
    let fminF = self.fminF();
    let fminE = self.fminE();
    let foE = self.foE();
    let fxE = self.fxE();
    let fxI = self.fxI();
    let hprimeF = self.hprimeF();
    let hprimeF2 = self.hprimeF2();
    let hprimeF1 = self.hprimeF1();
    let hprimeE = self.hprimeE();
    let hprimeEs = self.hprimeEs();
    let zmE = self.zmE();
    let yE = self.yE();
    let qf = self.qf();
    let qe = self.qe();
    let downF = self.downF();
    let downE = self.downE();
    let downEs = self.downEs();
    let ff = self.ff();
    let fe = self.fe();
    let d = self.d();
    let fmuf = self.fmuf();
    let hprimefMUF = self.hprimefMUF();
    let deltafoF2 = self.deltafoF2();
    let foEp = self.foEp();
    let fhprimeF = self.fhprimeF();
    let fhprimeF2 = self.fhprimeF2();
    let foF1p = self.foF1p();
    let foF2p = self.foF2p();
    let hmF2 = self.hmF2();
    let hmF1 = self.hmF1();
    let hmE = self.hmE();
    let zhalfNm = self.zhalfNm();
    let fminEs = self.fminEs();
    let yF2 = self.yF2();
    let yF1 = self.yF1();
    let tec = self.tec();
    let scaleHeightF2Peak = self.scaleHeightF2Peak();
    let b0 = self.b0();
    let b1 = self.b1();
    let d1 = self.d1();
    let foEa = self.foEa();
    let hprimeEa = self.hprimeEa();
    let foP = self.foP();
    let hprimeP = self.hprimeP();
    let fbEs = self.fbEs();
    let typeEs = self.typeEs().map(|x| {
      x.to_string()
    });
    let charAtts = self.charAtts().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let height = self.height().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let plasmaFrequency = self.plasmaFrequency().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let plasmaFrequencyUncertainty = self.plasmaFrequencyUncertainty().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let electronDensity = self.electronDensity().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let electronDensityUncertainty = self.electronDensityUncertainty().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let artistFlags = self.artistFlags().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let traceGeneric = self.traceGeneric().map(|x| {
      x.to_string()
    });
    let tidPhaseSpeeds = self.tidPhaseSpeeds().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let tidAzimuth = self.tidAzimuth().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let tidPeriods = self.tidPeriods().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let datum = self.datum().map(|x| {
      x.to_string()
    });
    let platformName = self.platformName().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    IonoObservation_IngestT {
      id,
      classificationMarking,
      idSensor,
      origSensorId,
      system,
      neProfileName,
      neProfileVersion,
      scalerInfo,
      densityProfile,
      stationId,
      startTimeUTC,
      systemInfo,
      systemNotes,
      transmitCoordinates,
      transmitSensorType,
      receiveCoordinates,
      receiveSensorType,
      antennaElementPosition,
      antennaElementPositionCoordinateSystem,
      power,
      range,
      frequency,
      polarization,
      azimuth,
      elevation,
      restrictedFrequency,
      restrictedFrequencyNotes,
      doppler,
      time,
      stokes,
      amplitude,
      phase,
      foF2,
      foF1,
      fxF2,
      fxF1,
      md,
      luf,
      mufd,
      fmin,
      foEs,
      fminF,
      fminE,
      foE,
      fxE,
      fxI,
      hprimeF,
      hprimeF2,
      hprimeF1,
      hprimeE,
      hprimeEs,
      zmE,
      yE,
      qf,
      qe,
      downF,
      downE,
      downEs,
      ff,
      fe,
      d,
      fmuf,
      hprimefMUF,
      deltafoF2,
      foEp,
      fhprimeF,
      fhprimeF2,
      foF1p,
      foF2p,
      hmF2,
      hmF1,
      hmE,
      zhalfNm,
      fminEs,
      yF2,
      yF1,
      tec,
      scaleHeightF2Peak,
      b0,
      b1,
      d1,
      foEa,
      hprimeEa,
      foP,
      hprimeP,
      fbEs,
      typeEs,
      charAtts,
      height,
      plasmaFrequency,
      plasmaFrequencyUncertainty,
      electronDensity,
      electronDensityUncertainty,
      artistFlags,
      traceGeneric,
      tidPhaseSpeeds,
      tidAzimuth,
      tidPeriods,
      datum,
      platformName,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      dataMode,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: IONOOBSERVATION-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the reporting sensor.
  /// Example: /// Example: SENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_IDSENSOR, None)}
  }
  /// Optional identifier provided by observation source to indicate the sensor identifier which produced this observation. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origSensorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_ORIGSENSORID, None)}
  }
  /// Ionosonde hardware type or data collection type together with possible additional descriptors.
  /// Example: /// Example: Example hardware type
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn system(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_SYSTEM, None)}
  }
  /// Name of the algorithm used for the electron density profile.
  /// Example: /// Example: NH
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn neProfileName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_NEPROFILENAME, None)}
  }
  /// Version of the algorithm used for the electron density profile.
  /// Example: /// Example: 4.32
  /// Constraints: No constraints specified.
  #[inline]
  pub fn neProfileVersion(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_NEPROFILEVERSION, Some(0.0)).unwrap()}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn scalerInfo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_SCALERINFO, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn densityProfile(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_DENSITYPROFILE, None)}
  }
  /// URSI code for station or stations producing the ionosonde.
  /// Example: /// Example: STATION-ID
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn stationId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_STATIONID, None)}
  }
  /// Sounding Start time in ISO8601 UTC format.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn startTimeUTC(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_STARTTIMEUTC, None)}
  }
  /// Names of settings.
  /// Example: /// Example: Example settings
  /// Constraints: Minimum length = 1, Maximum length = 1024
  #[inline]
  pub fn systemInfo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_SYSTEMINFO, None)}
  }
  /// Details concerning the composition/intention/interpretation/audience/etc. of any data recorded here. This field may contain all of the intended information e.g. info on signal waveforms used, antenna setup, etc. OR may describe the data/settings to be provided in the “data” field.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 1024
  #[inline]
  pub fn systemNotes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_SYSTEMNOTES, None)}
  }
  /// List of Geodetic Latitude, Longitude, and Altitude coordinates in km of the receiver. Coordinates List must always have 3 elements. Valid ranges are -90.0 to 90.0 for Latitude and -180.0 to 180.0 for Longitude. Altitude is in km and its value must be 0 or greater.
  /// Example: /// Example: [[45.5, 179.3, 35.6], [-80.2, -20.5, 43.2]]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn transmitCoordinates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_TRANSMITCOORDINATES, None)}
  }
  /// Enums: Mobile, Static.
  /// Example: /// Example: Mobile
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn transmitSensorType(&self) -> IonoObservation_Ingest_transmitSensorType_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<IonoObservation_Ingest_transmitSensorType_Enum>(IonoObservation_Ingest::VT_TRANSMITSENSORTYPE, Some(IonoObservation_Ingest_transmitSensorType_Enum::MOBILE)).unwrap()}
  }
  /// List of Geodetic Latitude, Longitude, and Altitude coordinates in km of the receiver. Coordinates List must always have 3 elements. Valid ranges are -90.0 to 90.0 for Latitude and -180.0 to 180.0 for Longitude. Altitude is in km and its value must be 0 or greater.
  /// Example: /// Example: [[45.5, 179.3, 35.6], [-80.2, -20.5, 43.2]]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn receiveCoordinates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_RECEIVECOORDINATES, None)}
  }
  /// Enums: Mobile, Static.
  /// Example: /// Example: Mobile
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn receiveSensorType(&self) -> IonoObservation_Ingest_receiveSensorType_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<IonoObservation_Ingest_receiveSensorType_Enum>(IonoObservation_Ingest::VT_RECEIVESENSORTYPE, Some(IonoObservation_Ingest_receiveSensorType_Enum::MOBILE)).unwrap()}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn antennaElementPosition(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_ANTENNAELEMENTPOSITION, None)}
  }
  /// Enums: J2000, ECR/ECEF, TEME, GCRF, WGS84 (GEODetic lat, long, alt), GEOCentric (lat, long, radii).
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn antennaElementPositionCoordinateSystem(&self) -> IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum>(IonoObservation_Ingest::VT_ANTENNAELEMENTPOSITIONCOORDINATESYSTEM, Some(IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum::J2000)).unwrap()}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn power(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_POWER, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn range(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_RANGE, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn frequency(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_FREQUENCY, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polarization(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_POLARIZATION, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn azimuth(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_AZIMUTH, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_ELEVATION, None)}
  }
  /// Array of restricted frequencies.
  /// Example: /// Example: [12.5, 34.5, 45.3]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn restrictedFrequency(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_RESTRICTEDFREQUENCY, None)}
  }
  /// Notes for the restrictedFrequency data.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 512
  #[inline]
  pub fn restrictedFrequencyNotes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_RESTRICTEDFREQUENCYNOTES, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn doppler(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_DOPPLER, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn time(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_TIME, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stokes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_STOKES, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn amplitude(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_AMPLITUDE, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn phase(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_PHASE, None)}
  }
  /// The ordinary wave critical frequency of the highest stratification in the F region, specified in MHz. URSI ID: 00.
  /// Example: /// Example: 6.75
  /// Constraints: No constraints specified.
  #[inline]
  pub fn foF2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FOF2, Some(0.0)).unwrap()}
  }
  /// The ordinary wave F1 critical frequency, in MHz. URSI ID: 10.
  /// Example: /// Example: 8.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn foF1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FOF1, Some(0.0)).unwrap()}
  }
  /// The extraordinary wave F2 critical frequency, in MHz. URSI ID: 01.
  /// Example: /// Example: 4.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fxF2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FXF2, Some(0.0)).unwrap()}
  }
  /// The extraordinary wave F1 critical frequency, in MHz. URSI ID: 11.
  /// Example: /// Example: 4.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fxF1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FXF1, Some(0.0)).unwrap()}
  }
  /// MUF(D)/foF2.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn md(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_MD, Some(0.0)).unwrap()}
  }
  /// Lowest usable frequency.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn luf(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_LUF, Some(0.0)).unwrap()}
  }
  /// Maximum Usable Frequency for ground distance D in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mufd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_MUFD, Some(0.0)).unwrap()}
  }
  /// Lowest frequency at which echo traces are observed on the ionogram, in MHz. URSI ID: 42.
  /// Example: /// Example: 2.025
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fmin(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FMIN, Some(0.0)).unwrap()}
  }
  /// Highest ordinary wave frequency at which a mainly continuous Es trace is observed, in MHz. URSI ID: 30.
  /// Example: /// Example: 2.35
  /// Constraints: No constraints specified.
  #[inline]
  pub fn foEs(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FOES, Some(0.0)).unwrap()}
  }
  /// Minimum frequency of F layer echoes in MHz. URSI ID: 80.
  /// Example: /// Example: 2.7
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fminF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FMINF, Some(0.0)).unwrap()}
  }
  /// Minimum frequency of E layer echoes in MHz. URSI ID: 81.
  /// Example: /// Example: 2.025
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fminE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FMINE, Some(0.0)).unwrap()}
  }
  /// The ordinary wave critical frequency of the lowest thick layer which causes a discontinuity, in MHz. URSI ID: 20.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn foE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FOE, Some(0.0)).unwrap()}
  }
  /// The extraordinary wave E critical frequency, in MHz. URSI ID: 21.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fxE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FXE, Some(0.0)).unwrap()}
  }
  /// The highest frequency of F-trace in MHz. Note: fxI is with capital i. URSI ID: 51.
  /// Example: /// Example: 7.525
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fxI(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FXI, Some(0.0)).unwrap()}
  }
  /// The minimum virtual height of the ordinary wave trace taken as a whole, in km. URSI ID: 16.
  /// Example: /// Example: 238.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hprimeF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_HPRIMEF, Some(0.0)).unwrap()}
  }
  /// The minimum virtual height of ordinary wave trace for the highest stable stratification in the F region in km. URSI ID: 4.
  /// Example: /// Example: 238.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hprimeF2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_HPRIMEF2, Some(0.0)).unwrap()}
  }
  /// The minimum virtual height of reflection at a point where the trace is horizontal in the F region in km. URSI ID: 14.
  /// Example: /// Example: 230.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hprimeF1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_HPRIMEF1, Some(0.0)).unwrap()}
  }
  /// The minimum virtual height of the normal E layer trace in km. URSI ID: 24.
  /// Example: /// Example: 98.47
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hprimeE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_HPRIMEE, Some(0.0)).unwrap()}
  }
  /// The minimum height of the trace used to give foEs in km. URSI ID: 34.
  /// Example: /// Example: 95
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hprimeEs(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_HPRIMEES, Some(0.0)).unwrap()}
  }
  /// Peak height of E-layer in km. URSI ID: 90.
  /// Example: /// Example: 91.744
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zmE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_ZME, Some(0.0)).unwrap()}
  }
  /// Parabolic E layer semi-thickness in km. URSI ID: 83.
  /// Example: /// Example: 1.722
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_YE, Some(0.0)).unwrap()}
  }
  /// Average range spread of F layer in km. URSI ID: 84.
  /// Example: /// Example: 1.83
  /// Constraints: No constraints specified.
  #[inline]
  pub fn qf(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_QF, Some(0.0)).unwrap()}
  }
  /// Average range spread of E layer in km. URSI ID: 85.
  /// Example: /// Example: 0.95
  /// Constraints: No constraints specified.
  #[inline]
  pub fn qe(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_QE, Some(0.0)).unwrap()}
  }
  /// Lowering of F trace to the leading edge in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn downF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_DOWNF, Some(0.0)).unwrap()}
  }
  /// Lowering of E trace to the leading edge in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn downE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_DOWNE, Some(0.0)).unwrap()}
  }
  /// Lowering of Es trace to the leading edge in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn downEs(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_DOWNES, Some(0.0)).unwrap()}
  }
  /// Frequency spread between fxF2 and FxI in MHz. URSI ID: 86.
  /// Example: /// Example: 0.075
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ff(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FF, Some(0.0)).unwrap()}
  }
  /// Frequency spread beyond foE in MHz. URSI ID: 87.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fe(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FE, Some(0.0)).unwrap()}
  }
  /// Distance for MUF calculation in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_D, Some(0.0)).unwrap()}
  }
  /// MUF/OblFactor in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fmuf(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FMUF, Some(0.0)).unwrap()}
  }
  /// Virtual height at MUF/OblFactor frequency in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hprimefMUF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_HPRIMEFMUF, Some(0.0)).unwrap()}
  }
  /// Adjustment to the scaled foF2 during profile inversion in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltafoF2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_DELTAFOF2, Some(0.0)).unwrap()}
  }
  /// Predicted value of foE in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn foEp(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FOEP, Some(0.0)).unwrap()}
  }
  /// The frequency at which hprimeF is measured in MHz. URSI ID: 61.
  /// Example: /// Example: 2.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fhprimeF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FHPRIMEF, Some(0.0)).unwrap()}
  }
  /// The frequency at which hprimeF2 is measured in MHz. URSI ID: 60.
  /// Example: /// Example: 2.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fhprimeF2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FHPRIMEF2, Some(0.0)).unwrap()}
  }
  /// Predicted value of foF1 in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn foF1p(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FOF1P, Some(0.0)).unwrap()}
  }
  /// Predicted value of foF2 in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn foF2p(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FOF2P, Some(0.0)).unwrap()}
  }
  /// True height of the F2 peak in km. URSI ID: AE.
  /// Example: /// Example: 240.498
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hmF2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_HMF2, Some(0.0)).unwrap()}
  }
  /// True height of the F1 peak in km. URSI ID: BE.
  /// Example: /// Example: 230.128
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hmF1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_HMF1, Some(0.0)).unwrap()}
  }
  /// True height of the E peak in km. URSI ID: CE.
  /// Example: /// Example: 215.643
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hmE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_HME, Some(0.0)).unwrap()}
  }
  /// True height at half peak electron density in the F2 layer in km. URSI ID: 93.
  /// Example: /// Example: 240.498
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zhalfNm(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_ZHALFNM, Some(0.0)).unwrap()}
  }
  /// Minimum frequency of Es layer in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fminEs(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FMINES, Some(0.0)).unwrap()}
  }
  /// Parabolic F2 layer semi-thickness in km. URSI ID: 94.
  /// Example: /// Example: 62.178
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yF2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_YF2, Some(0.0)).unwrap()}
  }
  /// Parabolic F1 layer semi-thickness in km. URSI ID: 95.
  /// Example: /// Example: 55.645
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yF1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_YF1, Some(0.0)).unwrap()}
  }
  /// Total Ionospheric Electron Content *10^16e/m^2. 1 TEC Unit (TECU) = 10^16 electrons/m^2. URSI ID: 72.
  /// Example: /// Example: 24.673
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tec(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_TEC, Some(0.0)).unwrap()}
  }
  /// Effective scale height at hmF2 Titheridge method in km. URSI ID: 69.
  /// Example: /// Example: 35.613
  /// Constraints: No constraints specified.
  #[inline]
  pub fn scaleHeightF2Peak(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_SCALEHEIGHTF2PEAK, Some(0.0)).unwrap()}
  }
  /// IRI thickness parameter in km. URSI ID: D0.
  /// Example: /// Example: 68.07
  /// Constraints: No constraints specified.
  #[inline]
  pub fn b0(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_B0, Some(0.0)).unwrap()}
  }
  /// IRI profile shape parameter. URSI ID: D1.
  /// Example: /// Example: 1.87
  /// Constraints: No constraints specified.
  #[inline]
  pub fn b1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_B1, Some(0.0)).unwrap()}
  }
  /// IRI profile shape parameter, F1 layer. URSI ID: D2.
  /// Example: /// Example: 1.94
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_D1, Some(0.0)).unwrap()}
  }
  /// Critical frequency of night time auroral E layer in MHz. URSI ID: 23.
  /// Example: /// Example: 45.764
  /// Constraints: No constraints specified.
  #[inline]
  pub fn foEa(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FOEA, Some(0.0)).unwrap()}
  }
  /// Minimum virtual height of night time auroral E layer trace in km. URSI ID: 27.
  /// Example: /// Example: 102.6
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hprimeEa(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_HPRIMEEA, Some(0.0)).unwrap()}
  }
  /// Highest ordinary wave critical frequency of F region patch trace in MHz. URSI ID: 55.
  /// Example: /// Example: 87.21
  /// Constraints: No constraints specified.
  #[inline]
  pub fn foP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FOP, Some(0.0)).unwrap()}
  }
  /// Minimum virtual height of the trace used to determine foP in km. URSI ID: 56.
  /// Example: /// Example: 89.45
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hprimeP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_HPRIMEP, Some(0.0)).unwrap()}
  }
  /// The blanketing frequency of layer used to derive foEs in MHz. URSI ID: 32.
  /// Example: /// Example: 34.867
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fbEs(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservation_Ingest::VT_FBES, Some(0.0)).unwrap()}
  }
  /// Characterization of the shape of Es trace. URSI ID: 36.
  /// Example: /// Example: Auroral
  /// Constraints: Minimum length = 0, Maximum length = 25
  #[inline]
  pub fn typeEs(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_TYPEES, None)}
  }
  /// List of attributes that are associated with the specified characteristics. Characteristics are defined by the CHARS: URSI IIWG format for archiving monthly ionospheric characteristics, INAG Bulletin No. 62 specification. 
  /// Qualifying and Descriptive letters are defined by the URSI Handbook for Ionogram Interpretation and reduction, Report UAG, No. 23A specification.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn charAtts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_CHARATTS, None)}
  }
  /// Array of altitudes above station level for plasma frequency/density arrays in km (must match the size of the plasmaFrequency and electronDensity Arrays).
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn height(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_HEIGHT, None)}
  }
  /// Array of plasma frequencies in MHz (must match the size of the height and electronDensity arrays).
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn plasmaFrequency(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_PLASMAFREQUENCY, None)}
  }
  /// Uncertainty in specifying the electron plasma frequency at each height point of the profile (must match the size of the plasmaFrequency array).
  /// Example: /// Example: [0.8, 0.2, 0.5]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn plasmaFrequencyUncertainty(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_PLASMAFREQUENCYUNCERTAINTY, None)}
  }
  /// Array of electron densities in cm^-3 (must match the size of the height and plasmaFrequency arrays).
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn electronDensity(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_ELECTRONDENSITY, None)}
  }
  /// Uncertainty in specifying the electron density at each height point of the profile (must match the size of the electronDensity array).
  /// Example: /// Example: [0.8, 0.2, 0.5]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn electronDensityUncertainty(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_ELECTRONDENSITYUNCERTAINTY, None)}
  }
  /// Array of Legacy Artist Flags.
  /// Example: /// Example: [1, 2, 3]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn artistFlags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_ARTISTFLAGS, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn traceGeneric(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_TRACEGENERIC, None)}
  }
  /// Array of speed in m/s at which the disturbance travels through the ionosphere.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tidPhaseSpeeds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_TIDPHASESPEEDS, None)}
  }
  /// Array of degrees clockwise from true North of the TID.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tidAzimuth(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_TIDAZIMUTH, None)}
  }
  /// Array of 1/frequency of the TID wave.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tidPeriods(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservation_Ingest::VT_TIDPERIODS, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn datum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_DATUM, None)}
  }
  /// Equipment location.
  /// Example: /// Example: Millstone Hill
  /// Constraints: Minimum length = 0, Maximum length = 512
  #[inline]
  pub fn platformName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_PLATFORMNAME, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_CREATEDBY, None)}
  }
  /// Time the row was updated in the database, auto-populated by the system, example = 2018-01-01T16:00:00.123Z.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_UPDATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> IonoObservation_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<IonoObservation_Ingest_dataMode_Enum>(IonoObservation_Ingest::VT_DATAMODE, Some(IonoObservation_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservation_Ingest::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for IonoObservation_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor", Self::VT_IDSENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId", Self::VT_ORIGSENSORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("system", Self::VT_SYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("neProfileName", Self::VT_NEPROFILENAME, false)?
     .visit_field::<f64>("neProfileVersion", Self::VT_NEPROFILEVERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scalerInfo", Self::VT_SCALERINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("densityProfile", Self::VT_DENSITYPROFILE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stationId", Self::VT_STATIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("startTimeUTC", Self::VT_STARTTIMEUTC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("systemInfo", Self::VT_SYSTEMINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("systemNotes", Self::VT_SYSTEMNOTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("transmitCoordinates", Self::VT_TRANSMITCOORDINATES, false)?
     .visit_field::<IonoObservation_Ingest_transmitSensorType_Enum>("transmitSensorType", Self::VT_TRANSMITSENSORTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("receiveCoordinates", Self::VT_RECEIVECOORDINATES, false)?
     .visit_field::<IonoObservation_Ingest_receiveSensorType_Enum>("receiveSensorType", Self::VT_RECEIVESENSORTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("antennaElementPosition", Self::VT_ANTENNAELEMENTPOSITION, false)?
     .visit_field::<IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum>("antennaElementPositionCoordinateSystem", Self::VT_ANTENNAELEMENTPOSITIONCOORDINATESYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("power", Self::VT_POWER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("range", Self::VT_RANGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("frequency", Self::VT_FREQUENCY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("polarization", Self::VT_POLARIZATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("azimuth", Self::VT_AZIMUTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("elevation", Self::VT_ELEVATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("restrictedFrequency", Self::VT_RESTRICTEDFREQUENCY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("restrictedFrequencyNotes", Self::VT_RESTRICTEDFREQUENCYNOTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doppler", Self::VT_DOPPLER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("time", Self::VT_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stokes", Self::VT_STOKES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("amplitude", Self::VT_AMPLITUDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("phase", Self::VT_PHASE, false)?
     .visit_field::<f64>("foF2", Self::VT_FOF2, false)?
     .visit_field::<f64>("foF1", Self::VT_FOF1, false)?
     .visit_field::<f64>("fxF2", Self::VT_FXF2, false)?
     .visit_field::<f64>("fxF1", Self::VT_FXF1, false)?
     .visit_field::<f64>("md", Self::VT_MD, false)?
     .visit_field::<f64>("luf", Self::VT_LUF, false)?
     .visit_field::<f64>("mufd", Self::VT_MUFD, false)?
     .visit_field::<f64>("fmin", Self::VT_FMIN, false)?
     .visit_field::<f64>("foEs", Self::VT_FOES, false)?
     .visit_field::<f64>("fminF", Self::VT_FMINF, false)?
     .visit_field::<f64>("fminE", Self::VT_FMINE, false)?
     .visit_field::<f64>("foE", Self::VT_FOE, false)?
     .visit_field::<f64>("fxE", Self::VT_FXE, false)?
     .visit_field::<f64>("fxI", Self::VT_FXI, false)?
     .visit_field::<f64>("hprimeF", Self::VT_HPRIMEF, false)?
     .visit_field::<f64>("hprimeF2", Self::VT_HPRIMEF2, false)?
     .visit_field::<f64>("hprimeF1", Self::VT_HPRIMEF1, false)?
     .visit_field::<f64>("hprimeE", Self::VT_HPRIMEE, false)?
     .visit_field::<f64>("hprimeEs", Self::VT_HPRIMEES, false)?
     .visit_field::<f64>("zmE", Self::VT_ZME, false)?
     .visit_field::<f64>("yE", Self::VT_YE, false)?
     .visit_field::<f64>("qf", Self::VT_QF, false)?
     .visit_field::<f64>("qe", Self::VT_QE, false)?
     .visit_field::<f64>("downF", Self::VT_DOWNF, false)?
     .visit_field::<f64>("downE", Self::VT_DOWNE, false)?
     .visit_field::<f64>("downEs", Self::VT_DOWNES, false)?
     .visit_field::<f64>("ff", Self::VT_FF, false)?
     .visit_field::<f64>("fe", Self::VT_FE, false)?
     .visit_field::<f64>("d", Self::VT_D, false)?
     .visit_field::<f64>("fmuf", Self::VT_FMUF, false)?
     .visit_field::<f64>("hprimefMUF", Self::VT_HPRIMEFMUF, false)?
     .visit_field::<f64>("deltafoF2", Self::VT_DELTAFOF2, false)?
     .visit_field::<f64>("foEp", Self::VT_FOEP, false)?
     .visit_field::<f64>("fhprimeF", Self::VT_FHPRIMEF, false)?
     .visit_field::<f64>("fhprimeF2", Self::VT_FHPRIMEF2, false)?
     .visit_field::<f64>("foF1p", Self::VT_FOF1P, false)?
     .visit_field::<f64>("foF2p", Self::VT_FOF2P, false)?
     .visit_field::<f64>("hmF2", Self::VT_HMF2, false)?
     .visit_field::<f64>("hmF1", Self::VT_HMF1, false)?
     .visit_field::<f64>("hmE", Self::VT_HME, false)?
     .visit_field::<f64>("zhalfNm", Self::VT_ZHALFNM, false)?
     .visit_field::<f64>("fminEs", Self::VT_FMINES, false)?
     .visit_field::<f64>("yF2", Self::VT_YF2, false)?
     .visit_field::<f64>("yF1", Self::VT_YF1, false)?
     .visit_field::<f64>("tec", Self::VT_TEC, false)?
     .visit_field::<f64>("scaleHeightF2Peak", Self::VT_SCALEHEIGHTF2PEAK, false)?
     .visit_field::<f64>("b0", Self::VT_B0, false)?
     .visit_field::<f64>("b1", Self::VT_B1, false)?
     .visit_field::<f64>("d1", Self::VT_D1, false)?
     .visit_field::<f64>("foEa", Self::VT_FOEA, false)?
     .visit_field::<f64>("hprimeEa", Self::VT_HPRIMEEA, false)?
     .visit_field::<f64>("foP", Self::VT_FOP, false)?
     .visit_field::<f64>("hprimeP", Self::VT_HPRIMEP, false)?
     .visit_field::<f64>("fbEs", Self::VT_FBES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("typeEs", Self::VT_TYPEES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("charAtts", Self::VT_CHARATTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("height", Self::VT_HEIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("plasmaFrequency", Self::VT_PLASMAFREQUENCY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("plasmaFrequencyUncertainty", Self::VT_PLASMAFREQUENCYUNCERTAINTY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("electronDensity", Self::VT_ELECTRONDENSITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("electronDensityUncertainty", Self::VT_ELECTRONDENSITYUNCERTAINTY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("artistFlags", Self::VT_ARTISTFLAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("traceGeneric", Self::VT_TRACEGENERIC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tidPhaseSpeeds", Self::VT_TIDPHASESPEEDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tidAzimuth", Self::VT_TIDAZIMUTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tidPeriods", Self::VT_TIDPERIODS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("datum", Self::VT_DATUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("platformName", Self::VT_PLATFORMNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<IonoObservation_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct IonoObservation_IngestArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub system: Option<flatbuffers::WIPOffset<&'a str>>,
    pub neProfileName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub neProfileVersion: f64,
    pub scalerInfo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub densityProfile: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stationId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTimeUTC: Option<flatbuffers::WIPOffset<&'a str>>,
    pub systemInfo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub systemNotes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transmitCoordinates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub transmitSensorType: IonoObservation_Ingest_transmitSensorType_Enum,
    pub receiveCoordinates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub receiveSensorType: IonoObservation_Ingest_receiveSensorType_Enum,
    pub antennaElementPosition: Option<flatbuffers::WIPOffset<&'a str>>,
    pub antennaElementPositionCoordinateSystem: IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum,
    pub power: Option<flatbuffers::WIPOffset<&'a str>>,
    pub range: Option<flatbuffers::WIPOffset<&'a str>>,
    pub frequency: Option<flatbuffers::WIPOffset<&'a str>>,
    pub polarization: Option<flatbuffers::WIPOffset<&'a str>>,
    pub azimuth: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elevation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub restrictedFrequency: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub restrictedFrequencyNotes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub doppler: Option<flatbuffers::WIPOffset<&'a str>>,
    pub time: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stokes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub amplitude: Option<flatbuffers::WIPOffset<&'a str>>,
    pub phase: Option<flatbuffers::WIPOffset<&'a str>>,
    pub foF2: f64,
    pub foF1: f64,
    pub fxF2: f64,
    pub fxF1: f64,
    pub md: f64,
    pub luf: f64,
    pub mufd: f64,
    pub fmin: f64,
    pub foEs: f64,
    pub fminF: f64,
    pub fminE: f64,
    pub foE: f64,
    pub fxE: f64,
    pub fxI: f64,
    pub hprimeF: f64,
    pub hprimeF2: f64,
    pub hprimeF1: f64,
    pub hprimeE: f64,
    pub hprimeEs: f64,
    pub zmE: f64,
    pub yE: f64,
    pub qf: f64,
    pub qe: f64,
    pub downF: f64,
    pub downE: f64,
    pub downEs: f64,
    pub ff: f64,
    pub fe: f64,
    pub d: f64,
    pub fmuf: f64,
    pub hprimefMUF: f64,
    pub deltafoF2: f64,
    pub foEp: f64,
    pub fhprimeF: f64,
    pub fhprimeF2: f64,
    pub foF1p: f64,
    pub foF2p: f64,
    pub hmF2: f64,
    pub hmF1: f64,
    pub hmE: f64,
    pub zhalfNm: f64,
    pub fminEs: f64,
    pub yF2: f64,
    pub yF1: f64,
    pub tec: f64,
    pub scaleHeightF2Peak: f64,
    pub b0: f64,
    pub b1: f64,
    pub d1: f64,
    pub foEa: f64,
    pub hprimeEa: f64,
    pub foP: f64,
    pub hprimeP: f64,
    pub fbEs: f64,
    pub typeEs: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charAtts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub height: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub plasmaFrequency: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub plasmaFrequencyUncertainty: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub electronDensity: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub electronDensityUncertainty: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub artistFlags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub traceGeneric: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tidPhaseSpeeds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub tidAzimuth: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub tidPeriods: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub datum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub platformName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: IonoObservation_Ingest_dataMode_Enum,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for IonoObservation_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    IonoObservation_IngestArgs {
      id: None,
      classificationMarking: None,
      idSensor: None,
      origSensorId: None,
      system: None,
      neProfileName: None,
      neProfileVersion: 0.0,
      scalerInfo: None,
      densityProfile: None,
      stationId: None,
      startTimeUTC: None,
      systemInfo: None,
      systemNotes: None,
      transmitCoordinates: None,
      transmitSensorType: IonoObservation_Ingest_transmitSensorType_Enum::MOBILE,
      receiveCoordinates: None,
      receiveSensorType: IonoObservation_Ingest_receiveSensorType_Enum::MOBILE,
      antennaElementPosition: None,
      antennaElementPositionCoordinateSystem: IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum::J2000,
      power: None,
      range: None,
      frequency: None,
      polarization: None,
      azimuth: None,
      elevation: None,
      restrictedFrequency: None,
      restrictedFrequencyNotes: None,
      doppler: None,
      time: None,
      stokes: None,
      amplitude: None,
      phase: None,
      foF2: 0.0,
      foF1: 0.0,
      fxF2: 0.0,
      fxF1: 0.0,
      md: 0.0,
      luf: 0.0,
      mufd: 0.0,
      fmin: 0.0,
      foEs: 0.0,
      fminF: 0.0,
      fminE: 0.0,
      foE: 0.0,
      fxE: 0.0,
      fxI: 0.0,
      hprimeF: 0.0,
      hprimeF2: 0.0,
      hprimeF1: 0.0,
      hprimeE: 0.0,
      hprimeEs: 0.0,
      zmE: 0.0,
      yE: 0.0,
      qf: 0.0,
      qe: 0.0,
      downF: 0.0,
      downE: 0.0,
      downEs: 0.0,
      ff: 0.0,
      fe: 0.0,
      d: 0.0,
      fmuf: 0.0,
      hprimefMUF: 0.0,
      deltafoF2: 0.0,
      foEp: 0.0,
      fhprimeF: 0.0,
      fhprimeF2: 0.0,
      foF1p: 0.0,
      foF2p: 0.0,
      hmF2: 0.0,
      hmF1: 0.0,
      hmE: 0.0,
      zhalfNm: 0.0,
      fminEs: 0.0,
      yF2: 0.0,
      yF1: 0.0,
      tec: 0.0,
      scaleHeightF2Peak: 0.0,
      b0: 0.0,
      b1: 0.0,
      d1: 0.0,
      foEa: 0.0,
      hprimeEa: 0.0,
      foP: 0.0,
      hprimeP: 0.0,
      fbEs: 0.0,
      typeEs: None,
      charAtts: None,
      height: None,
      plasmaFrequency: None,
      plasmaFrequencyUncertainty: None,
      electronDensity: None,
      electronDensityUncertainty: None,
      artistFlags: None,
      traceGeneric: None,
      tidPhaseSpeeds: None,
      tidAzimuth: None,
      tidPeriods: None,
      datum: None,
      platformName: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      dataMode: IonoObservation_Ingest_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}

pub struct IonoObservation_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IonoObservation_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idSensor(&mut self, idSensor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_IDSENSOR, idSensor);
  }
  #[inline]
  pub fn add_origSensorId(&mut self, origSensorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_ORIGSENSORID, origSensorId);
  }
  #[inline]
  pub fn add_system(&mut self, system: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_SYSTEM, system);
  }
  #[inline]
  pub fn add_neProfileName(&mut self, neProfileName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_NEPROFILENAME, neProfileName);
  }
  #[inline]
  pub fn add_neProfileVersion(&mut self, neProfileVersion: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_NEPROFILEVERSION, neProfileVersion, 0.0);
  }
  #[inline]
  pub fn add_scalerInfo(&mut self, scalerInfo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_SCALERINFO, scalerInfo);
  }
  #[inline]
  pub fn add_densityProfile(&mut self, densityProfile: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_DENSITYPROFILE, densityProfile);
  }
  #[inline]
  pub fn add_stationId(&mut self, stationId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_STATIONID, stationId);
  }
  #[inline]
  pub fn add_startTimeUTC(&mut self, startTimeUTC: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_STARTTIMEUTC, startTimeUTC);
  }
  #[inline]
  pub fn add_systemInfo(&mut self, systemInfo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_SYSTEMINFO, systemInfo);
  }
  #[inline]
  pub fn add_systemNotes(&mut self, systemNotes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_SYSTEMNOTES, systemNotes);
  }
  #[inline]
  pub fn add_transmitCoordinates(&mut self, transmitCoordinates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_TRANSMITCOORDINATES, transmitCoordinates);
  }
  #[inline]
  pub fn add_transmitSensorType(&mut self, transmitSensorType: IonoObservation_Ingest_transmitSensorType_Enum) {
    self.fbb_.push_slot::<IonoObservation_Ingest_transmitSensorType_Enum>(IonoObservation_Ingest::VT_TRANSMITSENSORTYPE, transmitSensorType, IonoObservation_Ingest_transmitSensorType_Enum::MOBILE);
  }
  #[inline]
  pub fn add_receiveCoordinates(&mut self, receiveCoordinates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_RECEIVECOORDINATES, receiveCoordinates);
  }
  #[inline]
  pub fn add_receiveSensorType(&mut self, receiveSensorType: IonoObservation_Ingest_receiveSensorType_Enum) {
    self.fbb_.push_slot::<IonoObservation_Ingest_receiveSensorType_Enum>(IonoObservation_Ingest::VT_RECEIVESENSORTYPE, receiveSensorType, IonoObservation_Ingest_receiveSensorType_Enum::MOBILE);
  }
  #[inline]
  pub fn add_antennaElementPosition(&mut self, antennaElementPosition: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_ANTENNAELEMENTPOSITION, antennaElementPosition);
  }
  #[inline]
  pub fn add_antennaElementPositionCoordinateSystem(&mut self, antennaElementPositionCoordinateSystem: IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum) {
    self.fbb_.push_slot::<IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum>(IonoObservation_Ingest::VT_ANTENNAELEMENTPOSITIONCOORDINATESYSTEM, antennaElementPositionCoordinateSystem, IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum::J2000);
  }
  #[inline]
  pub fn add_power(&mut self, power: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_POWER, power);
  }
  #[inline]
  pub fn add_range(&mut self, range: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_RANGE, range);
  }
  #[inline]
  pub fn add_frequency(&mut self, frequency: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_FREQUENCY, frequency);
  }
  #[inline]
  pub fn add_polarization(&mut self, polarization: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_POLARIZATION, polarization);
  }
  #[inline]
  pub fn add_azimuth(&mut self, azimuth: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_AZIMUTH, azimuth);
  }
  #[inline]
  pub fn add_elevation(&mut self, elevation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_ELEVATION, elevation);
  }
  #[inline]
  pub fn add_restrictedFrequency(&mut self, restrictedFrequency: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_RESTRICTEDFREQUENCY, restrictedFrequency);
  }
  #[inline]
  pub fn add_restrictedFrequencyNotes(&mut self, restrictedFrequencyNotes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_RESTRICTEDFREQUENCYNOTES, restrictedFrequencyNotes);
  }
  #[inline]
  pub fn add_doppler(&mut self, doppler: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_DOPPLER, doppler);
  }
  #[inline]
  pub fn add_time(&mut self, time: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_TIME, time);
  }
  #[inline]
  pub fn add_stokes(&mut self, stokes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_STOKES, stokes);
  }
  #[inline]
  pub fn add_amplitude(&mut self, amplitude: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_AMPLITUDE, amplitude);
  }
  #[inline]
  pub fn add_phase(&mut self, phase: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_PHASE, phase);
  }
  #[inline]
  pub fn add_foF2(&mut self, foF2: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FOF2, foF2, 0.0);
  }
  #[inline]
  pub fn add_foF1(&mut self, foF1: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FOF1, foF1, 0.0);
  }
  #[inline]
  pub fn add_fxF2(&mut self, fxF2: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FXF2, fxF2, 0.0);
  }
  #[inline]
  pub fn add_fxF1(&mut self, fxF1: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FXF1, fxF1, 0.0);
  }
  #[inline]
  pub fn add_md(&mut self, md: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_MD, md, 0.0);
  }
  #[inline]
  pub fn add_luf(&mut self, luf: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_LUF, luf, 0.0);
  }
  #[inline]
  pub fn add_mufd(&mut self, mufd: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_MUFD, mufd, 0.0);
  }
  #[inline]
  pub fn add_fmin(&mut self, fmin: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FMIN, fmin, 0.0);
  }
  #[inline]
  pub fn add_foEs(&mut self, foEs: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FOES, foEs, 0.0);
  }
  #[inline]
  pub fn add_fminF(&mut self, fminF: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FMINF, fminF, 0.0);
  }
  #[inline]
  pub fn add_fminE(&mut self, fminE: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FMINE, fminE, 0.0);
  }
  #[inline]
  pub fn add_foE(&mut self, foE: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FOE, foE, 0.0);
  }
  #[inline]
  pub fn add_fxE(&mut self, fxE: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FXE, fxE, 0.0);
  }
  #[inline]
  pub fn add_fxI(&mut self, fxI: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FXI, fxI, 0.0);
  }
  #[inline]
  pub fn add_hprimeF(&mut self, hprimeF: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_HPRIMEF, hprimeF, 0.0);
  }
  #[inline]
  pub fn add_hprimeF2(&mut self, hprimeF2: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_HPRIMEF2, hprimeF2, 0.0);
  }
  #[inline]
  pub fn add_hprimeF1(&mut self, hprimeF1: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_HPRIMEF1, hprimeF1, 0.0);
  }
  #[inline]
  pub fn add_hprimeE(&mut self, hprimeE: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_HPRIMEE, hprimeE, 0.0);
  }
  #[inline]
  pub fn add_hprimeEs(&mut self, hprimeEs: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_HPRIMEES, hprimeEs, 0.0);
  }
  #[inline]
  pub fn add_zmE(&mut self, zmE: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_ZME, zmE, 0.0);
  }
  #[inline]
  pub fn add_yE(&mut self, yE: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_YE, yE, 0.0);
  }
  #[inline]
  pub fn add_qf(&mut self, qf: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_QF, qf, 0.0);
  }
  #[inline]
  pub fn add_qe(&mut self, qe: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_QE, qe, 0.0);
  }
  #[inline]
  pub fn add_downF(&mut self, downF: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_DOWNF, downF, 0.0);
  }
  #[inline]
  pub fn add_downE(&mut self, downE: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_DOWNE, downE, 0.0);
  }
  #[inline]
  pub fn add_downEs(&mut self, downEs: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_DOWNES, downEs, 0.0);
  }
  #[inline]
  pub fn add_ff(&mut self, ff: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FF, ff, 0.0);
  }
  #[inline]
  pub fn add_fe(&mut self, fe: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FE, fe, 0.0);
  }
  #[inline]
  pub fn add_d(&mut self, d: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_D, d, 0.0);
  }
  #[inline]
  pub fn add_fmuf(&mut self, fmuf: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FMUF, fmuf, 0.0);
  }
  #[inline]
  pub fn add_hprimefMUF(&mut self, hprimefMUF: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_HPRIMEFMUF, hprimefMUF, 0.0);
  }
  #[inline]
  pub fn add_deltafoF2(&mut self, deltafoF2: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_DELTAFOF2, deltafoF2, 0.0);
  }
  #[inline]
  pub fn add_foEp(&mut self, foEp: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FOEP, foEp, 0.0);
  }
  #[inline]
  pub fn add_fhprimeF(&mut self, fhprimeF: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FHPRIMEF, fhprimeF, 0.0);
  }
  #[inline]
  pub fn add_fhprimeF2(&mut self, fhprimeF2: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FHPRIMEF2, fhprimeF2, 0.0);
  }
  #[inline]
  pub fn add_foF1p(&mut self, foF1p: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FOF1P, foF1p, 0.0);
  }
  #[inline]
  pub fn add_foF2p(&mut self, foF2p: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FOF2P, foF2p, 0.0);
  }
  #[inline]
  pub fn add_hmF2(&mut self, hmF2: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_HMF2, hmF2, 0.0);
  }
  #[inline]
  pub fn add_hmF1(&mut self, hmF1: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_HMF1, hmF1, 0.0);
  }
  #[inline]
  pub fn add_hmE(&mut self, hmE: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_HME, hmE, 0.0);
  }
  #[inline]
  pub fn add_zhalfNm(&mut self, zhalfNm: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_ZHALFNM, zhalfNm, 0.0);
  }
  #[inline]
  pub fn add_fminEs(&mut self, fminEs: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FMINES, fminEs, 0.0);
  }
  #[inline]
  pub fn add_yF2(&mut self, yF2: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_YF2, yF2, 0.0);
  }
  #[inline]
  pub fn add_yF1(&mut self, yF1: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_YF1, yF1, 0.0);
  }
  #[inline]
  pub fn add_tec(&mut self, tec: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_TEC, tec, 0.0);
  }
  #[inline]
  pub fn add_scaleHeightF2Peak(&mut self, scaleHeightF2Peak: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_SCALEHEIGHTF2PEAK, scaleHeightF2Peak, 0.0);
  }
  #[inline]
  pub fn add_b0(&mut self, b0: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_B0, b0, 0.0);
  }
  #[inline]
  pub fn add_b1(&mut self, b1: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_B1, b1, 0.0);
  }
  #[inline]
  pub fn add_d1(&mut self, d1: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_D1, d1, 0.0);
  }
  #[inline]
  pub fn add_foEa(&mut self, foEa: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FOEA, foEa, 0.0);
  }
  #[inline]
  pub fn add_hprimeEa(&mut self, hprimeEa: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_HPRIMEEA, hprimeEa, 0.0);
  }
  #[inline]
  pub fn add_foP(&mut self, foP: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FOP, foP, 0.0);
  }
  #[inline]
  pub fn add_hprimeP(&mut self, hprimeP: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_HPRIMEP, hprimeP, 0.0);
  }
  #[inline]
  pub fn add_fbEs(&mut self, fbEs: f64) {
    self.fbb_.push_slot::<f64>(IonoObservation_Ingest::VT_FBES, fbEs, 0.0);
  }
  #[inline]
  pub fn add_typeEs(&mut self, typeEs: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_TYPEES, typeEs);
  }
  #[inline]
  pub fn add_charAtts(&mut self, charAtts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_CHARATTS, charAtts);
  }
  #[inline]
  pub fn add_height(&mut self, height: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_HEIGHT, height);
  }
  #[inline]
  pub fn add_plasmaFrequency(&mut self, plasmaFrequency: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_PLASMAFREQUENCY, plasmaFrequency);
  }
  #[inline]
  pub fn add_plasmaFrequencyUncertainty(&mut self, plasmaFrequencyUncertainty: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_PLASMAFREQUENCYUNCERTAINTY, plasmaFrequencyUncertainty);
  }
  #[inline]
  pub fn add_electronDensity(&mut self, electronDensity: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_ELECTRONDENSITY, electronDensity);
  }
  #[inline]
  pub fn add_electronDensityUncertainty(&mut self, electronDensityUncertainty: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_ELECTRONDENSITYUNCERTAINTY, electronDensityUncertainty);
  }
  #[inline]
  pub fn add_artistFlags(&mut self, artistFlags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_ARTISTFLAGS, artistFlags);
  }
  #[inline]
  pub fn add_traceGeneric(&mut self, traceGeneric: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_TRACEGENERIC, traceGeneric);
  }
  #[inline]
  pub fn add_tidPhaseSpeeds(&mut self, tidPhaseSpeeds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_TIDPHASESPEEDS, tidPhaseSpeeds);
  }
  #[inline]
  pub fn add_tidAzimuth(&mut self, tidAzimuth: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_TIDAZIMUTH, tidAzimuth);
  }
  #[inline]
  pub fn add_tidPeriods(&mut self, tidPeriods: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_TIDPERIODS, tidPeriods);
  }
  #[inline]
  pub fn add_datum(&mut self, datum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_DATUM, datum);
  }
  #[inline]
  pub fn add_platformName(&mut self, platformName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_PLATFORMNAME, platformName);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: IonoObservation_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<IonoObservation_Ingest_dataMode_Enum>(IonoObservation_Ingest::VT_DATAMODE, dataMode, IonoObservation_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservation_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IonoObservation_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IonoObservation_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IonoObservation_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IonoObservation_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IonoObservation_Ingest");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idSensor", &self.idSensor());
      ds.field("origSensorId", &self.origSensorId());
      ds.field("system", &self.system());
      ds.field("neProfileName", &self.neProfileName());
      ds.field("neProfileVersion", &self.neProfileVersion());
      ds.field("scalerInfo", &self.scalerInfo());
      ds.field("densityProfile", &self.densityProfile());
      ds.field("stationId", &self.stationId());
      ds.field("startTimeUTC", &self.startTimeUTC());
      ds.field("systemInfo", &self.systemInfo());
      ds.field("systemNotes", &self.systemNotes());
      ds.field("transmitCoordinates", &self.transmitCoordinates());
      ds.field("transmitSensorType", &self.transmitSensorType());
      ds.field("receiveCoordinates", &self.receiveCoordinates());
      ds.field("receiveSensorType", &self.receiveSensorType());
      ds.field("antennaElementPosition", &self.antennaElementPosition());
      ds.field("antennaElementPositionCoordinateSystem", &self.antennaElementPositionCoordinateSystem());
      ds.field("power", &self.power());
      ds.field("range", &self.range());
      ds.field("frequency", &self.frequency());
      ds.field("polarization", &self.polarization());
      ds.field("azimuth", &self.azimuth());
      ds.field("elevation", &self.elevation());
      ds.field("restrictedFrequency", &self.restrictedFrequency());
      ds.field("restrictedFrequencyNotes", &self.restrictedFrequencyNotes());
      ds.field("doppler", &self.doppler());
      ds.field("time", &self.time());
      ds.field("stokes", &self.stokes());
      ds.field("amplitude", &self.amplitude());
      ds.field("phase", &self.phase());
      ds.field("foF2", &self.foF2());
      ds.field("foF1", &self.foF1());
      ds.field("fxF2", &self.fxF2());
      ds.field("fxF1", &self.fxF1());
      ds.field("md", &self.md());
      ds.field("luf", &self.luf());
      ds.field("mufd", &self.mufd());
      ds.field("fmin", &self.fmin());
      ds.field("foEs", &self.foEs());
      ds.field("fminF", &self.fminF());
      ds.field("fminE", &self.fminE());
      ds.field("foE", &self.foE());
      ds.field("fxE", &self.fxE());
      ds.field("fxI", &self.fxI());
      ds.field("hprimeF", &self.hprimeF());
      ds.field("hprimeF2", &self.hprimeF2());
      ds.field("hprimeF1", &self.hprimeF1());
      ds.field("hprimeE", &self.hprimeE());
      ds.field("hprimeEs", &self.hprimeEs());
      ds.field("zmE", &self.zmE());
      ds.field("yE", &self.yE());
      ds.field("qf", &self.qf());
      ds.field("qe", &self.qe());
      ds.field("downF", &self.downF());
      ds.field("downE", &self.downE());
      ds.field("downEs", &self.downEs());
      ds.field("ff", &self.ff());
      ds.field("fe", &self.fe());
      ds.field("d", &self.d());
      ds.field("fmuf", &self.fmuf());
      ds.field("hprimefMUF", &self.hprimefMUF());
      ds.field("deltafoF2", &self.deltafoF2());
      ds.field("foEp", &self.foEp());
      ds.field("fhprimeF", &self.fhprimeF());
      ds.field("fhprimeF2", &self.fhprimeF2());
      ds.field("foF1p", &self.foF1p());
      ds.field("foF2p", &self.foF2p());
      ds.field("hmF2", &self.hmF2());
      ds.field("hmF1", &self.hmF1());
      ds.field("hmE", &self.hmE());
      ds.field("zhalfNm", &self.zhalfNm());
      ds.field("fminEs", &self.fminEs());
      ds.field("yF2", &self.yF2());
      ds.field("yF1", &self.yF1());
      ds.field("tec", &self.tec());
      ds.field("scaleHeightF2Peak", &self.scaleHeightF2Peak());
      ds.field("b0", &self.b0());
      ds.field("b1", &self.b1());
      ds.field("d1", &self.d1());
      ds.field("foEa", &self.foEa());
      ds.field("hprimeEa", &self.hprimeEa());
      ds.field("foP", &self.foP());
      ds.field("hprimeP", &self.hprimeP());
      ds.field("fbEs", &self.fbEs());
      ds.field("typeEs", &self.typeEs());
      ds.field("charAtts", &self.charAtts());
      ds.field("height", &self.height());
      ds.field("plasmaFrequency", &self.plasmaFrequency());
      ds.field("plasmaFrequencyUncertainty", &self.plasmaFrequencyUncertainty());
      ds.field("electronDensity", &self.electronDensity());
      ds.field("electronDensityUncertainty", &self.electronDensityUncertainty());
      ds.field("artistFlags", &self.artistFlags());
      ds.field("traceGeneric", &self.traceGeneric());
      ds.field("tidPhaseSpeeds", &self.tidPhaseSpeeds());
      ds.field("tidAzimuth", &self.tidAzimuth());
      ds.field("tidPeriods", &self.tidPeriods());
      ds.field("datum", &self.datum());
      ds.field("platformName", &self.platformName());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct IonoObservation_IngestT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idSensor: Option<String>,
  pub origSensorId: Option<String>,
  pub system: Option<String>,
  pub neProfileName: Option<String>,
  pub neProfileVersion: f64,
  pub scalerInfo: Option<String>,
  pub densityProfile: Option<String>,
  pub stationId: Option<String>,
  pub startTimeUTC: Option<String>,
  pub systemInfo: Option<String>,
  pub systemNotes: Option<String>,
  pub transmitCoordinates: Option<Vec<String>>,
  pub transmitSensorType: IonoObservation_Ingest_transmitSensorType_Enum,
  pub receiveCoordinates: Option<Vec<String>>,
  pub receiveSensorType: IonoObservation_Ingest_receiveSensorType_Enum,
  pub antennaElementPosition: Option<String>,
  pub antennaElementPositionCoordinateSystem: IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum,
  pub power: Option<String>,
  pub range: Option<String>,
  pub frequency: Option<String>,
  pub polarization: Option<String>,
  pub azimuth: Option<String>,
  pub elevation: Option<String>,
  pub restrictedFrequency: Option<Vec<String>>,
  pub restrictedFrequencyNotes: Option<String>,
  pub doppler: Option<String>,
  pub time: Option<String>,
  pub stokes: Option<String>,
  pub amplitude: Option<String>,
  pub phase: Option<String>,
  pub foF2: f64,
  pub foF1: f64,
  pub fxF2: f64,
  pub fxF1: f64,
  pub md: f64,
  pub luf: f64,
  pub mufd: f64,
  pub fmin: f64,
  pub foEs: f64,
  pub fminF: f64,
  pub fminE: f64,
  pub foE: f64,
  pub fxE: f64,
  pub fxI: f64,
  pub hprimeF: f64,
  pub hprimeF2: f64,
  pub hprimeF1: f64,
  pub hprimeE: f64,
  pub hprimeEs: f64,
  pub zmE: f64,
  pub yE: f64,
  pub qf: f64,
  pub qe: f64,
  pub downF: f64,
  pub downE: f64,
  pub downEs: f64,
  pub ff: f64,
  pub fe: f64,
  pub d: f64,
  pub fmuf: f64,
  pub hprimefMUF: f64,
  pub deltafoF2: f64,
  pub foEp: f64,
  pub fhprimeF: f64,
  pub fhprimeF2: f64,
  pub foF1p: f64,
  pub foF2p: f64,
  pub hmF2: f64,
  pub hmF1: f64,
  pub hmE: f64,
  pub zhalfNm: f64,
  pub fminEs: f64,
  pub yF2: f64,
  pub yF1: f64,
  pub tec: f64,
  pub scaleHeightF2Peak: f64,
  pub b0: f64,
  pub b1: f64,
  pub d1: f64,
  pub foEa: f64,
  pub hprimeEa: f64,
  pub foP: f64,
  pub hprimeP: f64,
  pub fbEs: f64,
  pub typeEs: Option<String>,
  pub charAtts: Option<Vec<String>>,
  pub height: Option<Vec<String>>,
  pub plasmaFrequency: Option<Vec<String>>,
  pub plasmaFrequencyUncertainty: Option<Vec<String>>,
  pub electronDensity: Option<Vec<String>>,
  pub electronDensityUncertainty: Option<Vec<String>>,
  pub artistFlags: Option<Vec<String>>,
  pub traceGeneric: Option<String>,
  pub tidPhaseSpeeds: Option<Vec<String>>,
  pub tidAzimuth: Option<Vec<String>>,
  pub tidPeriods: Option<Vec<String>>,
  pub datum: Option<String>,
  pub platformName: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: IonoObservation_Ingest_dataMode_Enum,
  pub origNetwork: Option<String>,
}
impl Default for IonoObservation_IngestT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idSensor: None,
      origSensorId: None,
      system: None,
      neProfileName: None,
      neProfileVersion: 0.0,
      scalerInfo: None,
      densityProfile: None,
      stationId: None,
      startTimeUTC: None,
      systemInfo: None,
      systemNotes: None,
      transmitCoordinates: None,
      transmitSensorType: IonoObservation_Ingest_transmitSensorType_Enum::MOBILE,
      receiveCoordinates: None,
      receiveSensorType: IonoObservation_Ingest_receiveSensorType_Enum::MOBILE,
      antennaElementPosition: None,
      antennaElementPositionCoordinateSystem: IonoObservation_Ingest_antennaElementPositionCoordinateSystem_Enum::J2000,
      power: None,
      range: None,
      frequency: None,
      polarization: None,
      azimuth: None,
      elevation: None,
      restrictedFrequency: None,
      restrictedFrequencyNotes: None,
      doppler: None,
      time: None,
      stokes: None,
      amplitude: None,
      phase: None,
      foF2: 0.0,
      foF1: 0.0,
      fxF2: 0.0,
      fxF1: 0.0,
      md: 0.0,
      luf: 0.0,
      mufd: 0.0,
      fmin: 0.0,
      foEs: 0.0,
      fminF: 0.0,
      fminE: 0.0,
      foE: 0.0,
      fxE: 0.0,
      fxI: 0.0,
      hprimeF: 0.0,
      hprimeF2: 0.0,
      hprimeF1: 0.0,
      hprimeE: 0.0,
      hprimeEs: 0.0,
      zmE: 0.0,
      yE: 0.0,
      qf: 0.0,
      qe: 0.0,
      downF: 0.0,
      downE: 0.0,
      downEs: 0.0,
      ff: 0.0,
      fe: 0.0,
      d: 0.0,
      fmuf: 0.0,
      hprimefMUF: 0.0,
      deltafoF2: 0.0,
      foEp: 0.0,
      fhprimeF: 0.0,
      fhprimeF2: 0.0,
      foF1p: 0.0,
      foF2p: 0.0,
      hmF2: 0.0,
      hmF1: 0.0,
      hmE: 0.0,
      zhalfNm: 0.0,
      fminEs: 0.0,
      yF2: 0.0,
      yF1: 0.0,
      tec: 0.0,
      scaleHeightF2Peak: 0.0,
      b0: 0.0,
      b1: 0.0,
      d1: 0.0,
      foEa: 0.0,
      hprimeEa: 0.0,
      foP: 0.0,
      hprimeP: 0.0,
      fbEs: 0.0,
      typeEs: None,
      charAtts: None,
      height: None,
      plasmaFrequency: None,
      plasmaFrequencyUncertainty: None,
      electronDensity: None,
      electronDensityUncertainty: None,
      artistFlags: None,
      traceGeneric: None,
      tidPhaseSpeeds: None,
      tidAzimuth: None,
      tidPeriods: None,
      datum: None,
      platformName: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      dataMode: IonoObservation_Ingest_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}
impl IonoObservation_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<IonoObservation_Ingest<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor = self.idSensor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId = self.origSensorId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let system = self.system.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let neProfileName = self.neProfileName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let neProfileVersion = self.neProfileVersion;
    let scalerInfo = self.scalerInfo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let densityProfile = self.densityProfile.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stationId = self.stationId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let startTimeUTC = self.startTimeUTC.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let systemInfo = self.systemInfo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let systemNotes = self.systemNotes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let transmitCoordinates = self.transmitCoordinates.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let transmitSensorType = self.transmitSensorType;
    let receiveCoordinates = self.receiveCoordinates.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let receiveSensorType = self.receiveSensorType;
    let antennaElementPosition = self.antennaElementPosition.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let antennaElementPositionCoordinateSystem = self.antennaElementPositionCoordinateSystem;
    let power = self.power.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let range = self.range.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let frequency = self.frequency.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let polarization = self.polarization.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let azimuth = self.azimuth.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let elevation = self.elevation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let restrictedFrequency = self.restrictedFrequency.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let restrictedFrequencyNotes = self.restrictedFrequencyNotes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let doppler = self.doppler.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let time = self.time.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stokes = self.stokes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let amplitude = self.amplitude.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let phase = self.phase.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let foF2 = self.foF2;
    let foF1 = self.foF1;
    let fxF2 = self.fxF2;
    let fxF1 = self.fxF1;
    let md = self.md;
    let luf = self.luf;
    let mufd = self.mufd;
    let fmin = self.fmin;
    let foEs = self.foEs;
    let fminF = self.fminF;
    let fminE = self.fminE;
    let foE = self.foE;
    let fxE = self.fxE;
    let fxI = self.fxI;
    let hprimeF = self.hprimeF;
    let hprimeF2 = self.hprimeF2;
    let hprimeF1 = self.hprimeF1;
    let hprimeE = self.hprimeE;
    let hprimeEs = self.hprimeEs;
    let zmE = self.zmE;
    let yE = self.yE;
    let qf = self.qf;
    let qe = self.qe;
    let downF = self.downF;
    let downE = self.downE;
    let downEs = self.downEs;
    let ff = self.ff;
    let fe = self.fe;
    let d = self.d;
    let fmuf = self.fmuf;
    let hprimefMUF = self.hprimefMUF;
    let deltafoF2 = self.deltafoF2;
    let foEp = self.foEp;
    let fhprimeF = self.fhprimeF;
    let fhprimeF2 = self.fhprimeF2;
    let foF1p = self.foF1p;
    let foF2p = self.foF2p;
    let hmF2 = self.hmF2;
    let hmF1 = self.hmF1;
    let hmE = self.hmE;
    let zhalfNm = self.zhalfNm;
    let fminEs = self.fminEs;
    let yF2 = self.yF2;
    let yF1 = self.yF1;
    let tec = self.tec;
    let scaleHeightF2Peak = self.scaleHeightF2Peak;
    let b0 = self.b0;
    let b1 = self.b1;
    let d1 = self.d1;
    let foEa = self.foEa;
    let hprimeEa = self.hprimeEa;
    let foP = self.foP;
    let hprimeP = self.hprimeP;
    let fbEs = self.fbEs;
    let typeEs = self.typeEs.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let charAtts = self.charAtts.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let height = self.height.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let plasmaFrequency = self.plasmaFrequency.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let plasmaFrequencyUncertainty = self.plasmaFrequencyUncertainty.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let electronDensity = self.electronDensity.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let electronDensityUncertainty = self.electronDensityUncertainty.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let artistFlags = self.artistFlags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let traceGeneric = self.traceGeneric.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tidPhaseSpeeds = self.tidPhaseSpeeds.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let tidAzimuth = self.tidAzimuth.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let tidPeriods = self.tidPeriods.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let datum = self.datum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let platformName = self.platformName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    IonoObservation_Ingest::create(_fbb, &IonoObservation_IngestArgs{
      id,
      classificationMarking,
      idSensor,
      origSensorId,
      system,
      neProfileName,
      neProfileVersion,
      scalerInfo,
      densityProfile,
      stationId,
      startTimeUTC,
      systemInfo,
      systemNotes,
      transmitCoordinates,
      transmitSensorType,
      receiveCoordinates,
      receiveSensorType,
      antennaElementPosition,
      antennaElementPositionCoordinateSystem,
      power,
      range,
      frequency,
      polarization,
      azimuth,
      elevation,
      restrictedFrequency,
      restrictedFrequencyNotes,
      doppler,
      time,
      stokes,
      amplitude,
      phase,
      foF2,
      foF1,
      fxF2,
      fxF1,
      md,
      luf,
      mufd,
      fmin,
      foEs,
      fminF,
      fminE,
      foE,
      fxE,
      fxI,
      hprimeF,
      hprimeF2,
      hprimeF1,
      hprimeE,
      hprimeEs,
      zmE,
      yE,
      qf,
      qe,
      downF,
      downE,
      downEs,
      ff,
      fe,
      d,
      fmuf,
      hprimefMUF,
      deltafoF2,
      foEp,
      fhprimeF,
      fhprimeF2,
      foF1p,
      foF2p,
      hmF2,
      hmF1,
      hmE,
      zhalfNm,
      fminEs,
      yF2,
      yF1,
      tec,
      scaleHeightF2Peak,
      b0,
      b1,
      d1,
      foEa,
      hprimeEa,
      foP,
      hprimeP,
      fbEs,
      typeEs,
      charAtts,
      height,
      plasmaFrequency,
      plasmaFrequencyUncertainty,
      electronDensity,
      electronDensityUncertainty,
      artistFlags,
      traceGeneric,
      tidPhaseSpeeds,
      tidAzimuth,
      tidPeriods,
      datum,
      platformName,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      dataMode,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `IonoObservation_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_iono_observation_ingest_unchecked`.
pub fn root_as_iono_observation_ingest(buf: &[u8]) -> Result<IonoObservation_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<IonoObservation_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `IonoObservation_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_iono_observation_ingest_unchecked`.
pub fn size_prefixed_root_as_iono_observation_ingest(buf: &[u8]) -> Result<IonoObservation_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<IonoObservation_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `IonoObservation_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_iono_observation_ingest_unchecked`.
pub fn root_as_iono_observation_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<IonoObservation_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<IonoObservation_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `IonoObservation_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_iono_observation_ingest_unchecked`.
pub fn size_prefixed_root_as_iono_observation_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<IonoObservation_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<IonoObservation_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a IonoObservation_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `IonoObservation_Ingest`.
pub unsafe fn root_as_iono_observation_ingest_unchecked(buf: &[u8]) -> IonoObservation_Ingest {
  flatbuffers::root_unchecked::<IonoObservation_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed IonoObservation_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `IonoObservation_Ingest`.
pub unsafe fn size_prefixed_root_as_iono_observation_ingest_unchecked(buf: &[u8]) -> IonoObservation_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<IonoObservation_Ingest>(buf)
}
pub const IONO_OBSERVATION_INGEST_IDENTIFIER: &str = "IONO";

#[inline]
pub fn iono_observation_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, IONO_OBSERVATION_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn iono_observation_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, IONO_OBSERVATION_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_iono_observation_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<IonoObservation_Ingest<'a>>) {
  fbb.finish(root, Some(IONO_OBSERVATION_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_iono_observation_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<IonoObservation_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(IONO_OBSERVATION_INGEST_IDENTIFIER));
}
