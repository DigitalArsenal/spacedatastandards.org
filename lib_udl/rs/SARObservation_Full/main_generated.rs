// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SAROBSERVATION_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SAROBSERVATION_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SAROBSERVATION_FULL_DATA_MODE_ENUM: [SARObservation_Full_dataMode_Enum; 4] = [
  SARObservation_Full_dataMode_Enum::REAL,
  SARObservation_Full_dataMode_Enum::TEST,
  SARObservation_Full_dataMode_Enum::SIMULATED,
  SARObservation_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SARObservation_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl SARObservation_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SARObservation_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SARObservation_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SARObservation_Full_dataMode_Enum {
    type Output = SARObservation_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SARObservation_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SARObservation_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SARObservation_Full_dataMode_Enum {}
pub enum SARObservation_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Model representation of observation data for SAR based sensor phenomenologies. J2000 is the preferred coordinate frame for all observations, but in some cases observations may be in another frame depending on the provider. Please see the 'Discover' tab in the storefront to confirm coordinate frames by data provider.
pub struct SARObservation_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SARObservation_Full<'a> {
  type Inner = SARObservation_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SARObservation_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 8;
  pub const VT_SATNO: flatbuffers::VOffsetT = 10;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 12;
  pub const VT_IDSENSOR: flatbuffers::VOffsetT = 14;
  pub const VT_ORIGSENSORID: flatbuffers::VOffsetT = 16;
  pub const VT_EXTERNALID: flatbuffers::VOffsetT = 18;
  pub const VT_COLLECTIONID: flatbuffers::VOffsetT = 20;
  pub const VT_DETECTIONID: flatbuffers::VOffsetT = 22;
  pub const VT_COLLECTIONSTART: flatbuffers::VOffsetT = 24;
  pub const VT_COLLECTIONEND: flatbuffers::VOffsetT = 26;
  pub const VT_CENTERTIME: flatbuffers::VOffsetT = 28;
  pub const VT_DETECTIONSTART: flatbuffers::VOffsetT = 30;
  pub const VT_DETECTIONEND: flatbuffers::VOffsetT = 32;
  pub const VT_DWELLTIME: flatbuffers::VOffsetT = 34;
  pub const VT_ORBITSTATE: flatbuffers::VOffsetT = 36;
  pub const VT_SARMODE: flatbuffers::VOffsetT = 38;
  pub const VT_OPERATINGBAND: flatbuffers::VOffsetT = 40;
  pub const VT_OPERATINGFREQ: flatbuffers::VOffsetT = 42;
  pub const VT_SNR: flatbuffers::VOffsetT = 44;
  pub const VT_TXPOLARIZATION: flatbuffers::VOffsetT = 46;
  pub const VT_RXPOLARIZATION: flatbuffers::VOffsetT = 48;
  pub const VT_GRAZEANGLE: flatbuffers::VOffsetT = 50;
  pub const VT_INCIDENCEANGLE: flatbuffers::VOffsetT = 52;
  pub const VT_SQUINTANGLE: flatbuffers::VOffsetT = 54;
  pub const VT_PULSEBANDWIDTH: flatbuffers::VOffsetT = 56;
  pub const VT_PULSEDURATION: flatbuffers::VOffsetT = 58;
  pub const VT_CONTINUOUSSPOTANGLE: flatbuffers::VOffsetT = 60;
  pub const VT_SLANTRANGE: flatbuffers::VOffsetT = 62;
  pub const VT_NEARRANGE: flatbuffers::VOffsetT = 64;
  pub const VT_FARRANGE: flatbuffers::VOffsetT = 66;
  pub const VT_SWATHLENGTH: flatbuffers::VOffsetT = 68;
  pub const VT_AREA: flatbuffers::VOffsetT = 70;
  pub const VT_ATEXT: flatbuffers::VOffsetT = 72;
  pub const VT_AGJSON: flatbuffers::VOffsetT = 74;
  pub const VT_ATYPE: flatbuffers::VOffsetT = 76;
  pub const VT_ANDIMS: flatbuffers::VOffsetT = 78;
  pub const VT_ASRID: flatbuffers::VOffsetT = 80;
  pub const VT_SPACINGRANGE: flatbuffers::VOffsetT = 82;
  pub const VT_SPACINGAZIMUTH: flatbuffers::VOffsetT = 84;
  pub const VT_LOOKSAZIMUTH: flatbuffers::VOffsetT = 86;
  pub const VT_LOOKSRANGE: flatbuffers::VOffsetT = 88;
  pub const VT_RESOLUTIONRANGE: flatbuffers::VOffsetT = 90;
  pub const VT_RESOLUTIONAZIMUTH: flatbuffers::VOffsetT = 92;
  pub const VT_OBDIRECTION: flatbuffers::VOffsetT = 94;
  pub const VT_COORDSYS: flatbuffers::VOffsetT = 96;
  pub const VT_TARGETPOSX: flatbuffers::VOffsetT = 98;
  pub const VT_TARGETPOSY: flatbuffers::VOffsetT = 100;
  pub const VT_TARGETPOSZ: flatbuffers::VOffsetT = 102;
  pub const VT_SENALT: flatbuffers::VOffsetT = 104;
  pub const VT_SENVELX: flatbuffers::VOffsetT = 106;
  pub const VT_SENVELY: flatbuffers::VOffsetT = 108;
  pub const VT_SENVELZ: flatbuffers::VOffsetT = 110;
  pub const VT_SENLATSTART: flatbuffers::VOffsetT = 112;
  pub const VT_SENLONSTART: flatbuffers::VOffsetT = 114;
  pub const VT_SENLATEND: flatbuffers::VOffsetT = 116;
  pub const VT_SENLONEND: flatbuffers::VOffsetT = 118;
  pub const VT_TRANSACTIONID: flatbuffers::VOffsetT = 120;
  pub const VT_TAGS: flatbuffers::VOffsetT = 122;
  pub const VT_SRCTYPS: flatbuffers::VOffsetT = 124;
  pub const VT_SRCIDS: flatbuffers::VOffsetT = 126;
  pub const VT_ONORBIT: flatbuffers::VOffsetT = 128;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 130;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 132;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 134;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 136;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 138;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 140;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 142;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SARObservation_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SARObservation_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<SARObservation_Full<'bldr>> {
    let mut builder = SARObservation_FullBuilder::new(_fbb);
    builder.add_senlonEnd(args.senlonEnd);
    builder.add_senlatEnd(args.senlatEnd);
    builder.add_senlonStart(args.senlonStart);
    builder.add_senlatStart(args.senlatStart);
    builder.add_senvelz(args.senvelz);
    builder.add_senvely(args.senvely);
    builder.add_senvelx(args.senvelx);
    builder.add_senalt(args.senalt);
    builder.add_targetposz(args.targetposz);
    builder.add_targetposy(args.targetposy);
    builder.add_targetposx(args.targetposx);
    builder.add_resolutionAzimuth(args.resolutionAzimuth);
    builder.add_resolutionRange(args.resolutionRange);
    builder.add_spacingAzimuth(args.spacingAzimuth);
    builder.add_spacingRange(args.spacingRange);
    builder.add_swathLength(args.swathLength);
    builder.add_farRange(args.farRange);
    builder.add_nearRange(args.nearRange);
    builder.add_slantRange(args.slantRange);
    builder.add_continuousSpotAngle(args.continuousSpotAngle);
    builder.add_pulseDuration(args.pulseDuration);
    builder.add_pulseBandwidth(args.pulseBandwidth);
    builder.add_squintAngle(args.squintAngle);
    builder.add_incidenceAngle(args.incidenceAngle);
    builder.add_grazeAngle(args.grazeAngle);
    builder.add_snr(args.snr);
    builder.add_operatingFreq(args.operatingFreq);
    builder.add_dwellTime(args.dwellTime);
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.onOrbit { builder.add_onOrbit(x); }
    if let Some(x) = args.srcIds { builder.add_srcIds(x); }
    if let Some(x) = args.srcTyps { builder.add_srcTyps(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.transactionId { builder.add_transactionId(x); }
    if let Some(x) = args.coordSys { builder.add_coordSys(x); }
    if let Some(x) = args.obDirection { builder.add_obDirection(x); }
    builder.add_looksRange(args.looksRange);
    builder.add_looksAzimuth(args.looksAzimuth);
    builder.add_asrid(args.asrid);
    builder.add_andims(args.andims);
    if let Some(x) = args.atype { builder.add_atype(x); }
    if let Some(x) = args.agjson { builder.add_agjson(x); }
    if let Some(x) = args.atext { builder.add_atext(x); }
    if let Some(x) = args.area { builder.add_area(x); }
    if let Some(x) = args.rxPolarization { builder.add_rxPolarization(x); }
    if let Some(x) = args.txPolarization { builder.add_txPolarization(x); }
    if let Some(x) = args.operatingBand { builder.add_operatingBand(x); }
    if let Some(x) = args.sarMode { builder.add_sarMode(x); }
    if let Some(x) = args.orbitState { builder.add_orbitState(x); }
    if let Some(x) = args.detectionEnd { builder.add_detectionEnd(x); }
    if let Some(x) = args.detectionStart { builder.add_detectionStart(x); }
    if let Some(x) = args.centerTime { builder.add_centerTime(x); }
    if let Some(x) = args.collectionEnd { builder.add_collectionEnd(x); }
    if let Some(x) = args.collectionStart { builder.add_collectionStart(x); }
    if let Some(x) = args.detectionId { builder.add_detectionId(x); }
    if let Some(x) = args.collectionId { builder.add_collectionId(x); }
    if let Some(x) = args.externalId { builder.add_externalId(x); }
    if let Some(x) = args.origSensorId { builder.add_origSensorId(x); }
    if let Some(x) = args.idSensor { builder.add_idSensor(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> SARObservation_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let satNo = self.satNo();
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let idSensor = self.idSensor().map(|x| {
      x.to_string()
    });
    let origSensorId = self.origSensorId().map(|x| {
      x.to_string()
    });
    let externalId = self.externalId().map(|x| {
      x.to_string()
    });
    let collectionId = self.collectionId().map(|x| {
      x.to_string()
    });
    let detectionId = self.detectionId().map(|x| {
      x.to_string()
    });
    let collectionStart = self.collectionStart().map(|x| {
      x.to_string()
    });
    let collectionEnd = self.collectionEnd().map(|x| {
      x.to_string()
    });
    let centerTime = self.centerTime().map(|x| {
      x.to_string()
    });
    let detectionStart = self.detectionStart().map(|x| {
      x.to_string()
    });
    let detectionEnd = self.detectionEnd().map(|x| {
      x.to_string()
    });
    let dwellTime = self.dwellTime();
    let orbitState = self.orbitState().map(|x| {
      x.to_string()
    });
    let sarMode = self.sarMode().map(|x| {
      x.to_string()
    });
    let operatingBand = self.operatingBand().map(|x| {
      x.to_string()
    });
    let operatingFreq = self.operatingFreq();
    let snr = self.snr();
    let txPolarization = self.txPolarization().map(|x| {
      x.to_string()
    });
    let rxPolarization = self.rxPolarization().map(|x| {
      x.to_string()
    });
    let grazeAngle = self.grazeAngle();
    let incidenceAngle = self.incidenceAngle();
    let squintAngle = self.squintAngle();
    let pulseBandwidth = self.pulseBandwidth();
    let pulseDuration = self.pulseDuration();
    let continuousSpotAngle = self.continuousSpotAngle();
    let slantRange = self.slantRange();
    let nearRange = self.nearRange();
    let farRange = self.farRange();
    let swathLength = self.swathLength();
    let area = self.area().map(|x| {
      x.to_string()
    });
    let atext = self.atext().map(|x| {
      x.to_string()
    });
    let agjson = self.agjson().map(|x| {
      x.to_string()
    });
    let atype = self.atype().map(|x| {
      x.to_string()
    });
    let andims = self.andims();
    let asrid = self.asrid();
    let spacingRange = self.spacingRange();
    let spacingAzimuth = self.spacingAzimuth();
    let looksAzimuth = self.looksAzimuth();
    let looksRange = self.looksRange();
    let resolutionRange = self.resolutionRange();
    let resolutionAzimuth = self.resolutionAzimuth();
    let obDirection = self.obDirection().map(|x| {
      x.to_string()
    });
    let coordSys = self.coordSys().map(|x| {
      x.to_string()
    });
    let targetposx = self.targetposx();
    let targetposy = self.targetposy();
    let targetposz = self.targetposz();
    let senalt = self.senalt();
    let senvelx = self.senvelx();
    let senvely = self.senvely();
    let senvelz = self.senvelz();
    let senlatStart = self.senlatStart();
    let senlonStart = self.senlonStart();
    let senlatEnd = self.senlatEnd();
    let senlonEnd = self.senlonEnd();
    let transactionId = self.transactionId().map(|x| {
      x.to_string()
    });
    let tags = self.tags().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let srcTyps = self.srcTyps().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let srcIds = self.srcIds().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let onOrbit = self.onOrbit().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    SARObservation_FullT {
      id,
      classificationMarking,
      idOnOrbit,
      satNo,
      origObjectId,
      idSensor,
      origSensorId,
      externalId,
      collectionId,
      detectionId,
      collectionStart,
      collectionEnd,
      centerTime,
      detectionStart,
      detectionEnd,
      dwellTime,
      orbitState,
      sarMode,
      operatingBand,
      operatingFreq,
      snr,
      txPolarization,
      rxPolarization,
      grazeAngle,
      incidenceAngle,
      squintAngle,
      pulseBandwidth,
      pulseDuration,
      continuousSpotAngle,
      slantRange,
      nearRange,
      farRange,
      swathLength,
      area,
      atext,
      agjson,
      atype,
      andims,
      asrid,
      spacingRange,
      spacingAzimuth,
      looksAzimuth,
      looksRange,
      resolutionRange,
      resolutionAzimuth,
      obDirection,
      coordSys,
      targetposx,
      targetposy,
      targetposz,
      senalt,
      senvelx,
      senvely,
      senvelz,
      senlatStart,
      senlonStart,
      senlatEnd,
      senlonEnd,
      transactionId,
      tags,
      srcTyps,
      srcIds,
      onOrbit,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      sourceDL,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: SAROBSERVATION-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the spacecraft hosting the sensor associated with this collection.
  /// Example: /// Example: 36036
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_IDONORBIT, None)}
  }
  /// Satellite/Catalog number of the spacecraft hosting the sensor associated with this collection.
  /// Example: /// Example: 36036
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SARObservation_Full::VT_SATNO, Some(0)).unwrap()}
  }
  /// Optional identifier provided by the source to indicate the onorbit object hosting the sensor associated with this collection. This may be an internal identifier and not necessarily a valid satellite number.
  /// Example: /// Example: 36036
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_ORIGOBJECTID, None)}
  }
  /// Unique identifier of the reporting sensor.
  /// Example: /// Example: 36036-1L
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_IDSENSOR, None)}
  }
  /// Optional identifier provided by the source to indicate the sensor for this collection. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: SMOS-1L
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origSensorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_ORIGSENSORID, None)}
  }
  /// Optional ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: EXTERNAL-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn externalId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_EXTERNALID, None)}
  }
  /// Optional identifier to indicate the specific collection tasking which produced this observation.
  /// Example: /// Example: COLLECTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn collectionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_COLLECTIONID, None)}
  }
  /// Identifier of the specific detection within a collection which produced this observation.
  /// Example: /// Example: DETECTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn detectionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_DETECTIONID, None)}
  }
  /// Collection start time in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2023-04-22T17:35:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn collectionStart(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_COLLECTIONSTART, None)}
  }
  /// Collection end time in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2023-04-22T17:38:10.20177Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn collectionEnd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_COLLECTIONEND, None)}
  }
  /// The datetime at the center point of the collection in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2023-04-22T17:36:35.100885Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn centerTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_CENTERTIME, None)}
  }
  /// The detection start time in ISO 8601 UTC format, with microsecond precision.
  /// Example: /// Example: 2023-07-08T17:35:01.615396Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn detectionStart(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_DETECTIONSTART, None)}
  }
  /// The detection end time in ISO 8601 UTC format, with microsecond precision.
  /// Example: /// Example: 2023-07-08T17:35:20.77219Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn detectionEnd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_DETECTIONEND, None)}
  }
  /// The duration, in seconds, of this detection.
  /// Example: /// Example: 79.156794
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dwellTime(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_DWELLTIME, Some(0.0)).unwrap()}
  }
  /// The orbital direction (ASCENDING, DESCENDING) of the platform during the collection.
  /// Example: /// Example: ASCENDING
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn orbitState(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_ORBITSTATE, None)}
  }
  /// Collection mode setting for this collection (e.g. AREA, SPOTLIGHT, STRIP, etc.).
  /// Example: /// Example: SPOTLIGHT
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn sarMode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_SARMODE, None)}
  }
  /// Name of the band containing operating frequency for the collection (e.g. C, E, EHF, HF, K, Ka, Ku, L, Q, S, SHF, UNK, UHF, V, VHF, VLF, W, X). See RFBandType for more details and descriptions of each band name.
  /// Example: /// Example: L
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn operatingBand(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_OPERATINGBAND, None)}
  }
  /// The operating frequency, in Mhz, for the collection.
  /// Example: /// Example: 2345.6
  /// Constraints: No constraints specified.
  #[inline]
  pub fn operatingFreq(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_OPERATINGFREQ, Some(0.0)).unwrap()}
  }
  /// Signal to noise ratio, in dB.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn snr(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SNR, Some(0.0)).unwrap()}
  }
  /// Transmit polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the earth's surface.
  /// Example: /// Example: H
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn txPolarization(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_TXPOLARIZATION, None)}
  }
  /// Receive polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the earth's surface.
  /// Example: /// Example: H
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn rxPolarization(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_RXPOLARIZATION, None)}
  }
  /// The graze angle (also referred to as look angle) for the collection in degrees.
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn grazeAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_GRAZEANGLE, Some(0.0)).unwrap()}
  }
  /// The center incidence angle in degrees.
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn incidenceAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_INCIDENCEANGLE, Some(0.0)).unwrap()}
  }
  /// The squint angle for the collection in degrees.
  /// Example: /// Example: 1.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn squintAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SQUINTANGLE, Some(0.0)).unwrap()}
  }
  /// The bandwidth frequency of the pulse in Mhz.
  /// Example: /// Example: 500.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pulseBandwidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_PULSEBANDWIDTH, Some(0.0)).unwrap()}
  }
  /// The duration of a pulse in seconds.
  /// Example: /// Example: 1.1e-05
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pulseDuration(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_PULSEDURATION, Some(0.0)).unwrap()}
  }
  /// Required sweep angle for the continuous spot scene in degrees.
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn continuousSpotAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_CONTINUOUSSPOTANGLE, Some(0.0)).unwrap()}
  }
  /// Slant distance from sensor to center point of imaging event in kilometers.
  /// Example: /// Example: 60.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn slantRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SLANTRANGE, Some(0.0)).unwrap()}
  }
  /// Specifies the closest range, in kilometers, from the flight path to target during the collection.
  /// Example: /// Example: 12.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn nearRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_NEARRANGE, Some(0.0)).unwrap()}
  }
  /// Specifies the farthest range, in kilometers, from the flight path to target during the collection.
  /// Example: /// Example: 34.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn farRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_FARRANGE, Some(0.0)).unwrap()}
  }
  /// The length of the collection as projected on the ground in kilometers.
  /// Example: /// Example: 12.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn swathLength(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SWATHLENGTH, Some(0.0)).unwrap()}
  }
  /// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the image event as projected on the ground.
  /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  /// Constraints: No constraints specified.
  #[inline]
  pub fn area(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_AREA, None)}
  }
  /// Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
  /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  /// Constraints: No constraints specified.
  #[inline]
  pub fn atext(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_ATEXT, None)}
  }
  /// Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
  /// Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
  /// Constraints: No constraints specified.
  #[inline]
  pub fn agjson(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_AGJSON, None)}
  }
  /// Type of region as projected on the ground (POLYGON, POINT, LINE).
  /// Example: /// Example: POLYGON
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn atype(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_ATYPE, None)}
  }
  /// Number of dimensions of the geometry depicted by region.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn andims(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SARObservation_Full::VT_ANDIMS, Some(0)).unwrap()}
  }
  /// Geographical spatial_ref_sys for region.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn asrid(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SARObservation_Full::VT_ASRID, Some(0)).unwrap()}
  }
  /// The pixel spacing in the range direction measured in meters.
  /// Example: /// Example: 0.123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spacingRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SPACINGRANGE, Some(0.0)).unwrap()}
  }
  /// The pixel spacing in the azimuth direction measured in meters.
  /// Example: /// Example: 0.123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spacingAzimuth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SPACINGAZIMUTH, Some(0.0)).unwrap()}
  }
  /// The number of looks in the azimuth direction.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn looksAzimuth(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SARObservation_Full::VT_LOOKSAZIMUTH, Some(0)).unwrap()}
  }
  /// The number of looks in the range direction.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn looksRange(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SARObservation_Full::VT_LOOKSRANGE, Some(0)).unwrap()}
  }
  /// The resolution in the range direction measured in meters.
  /// Example: /// Example: 0.123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn resolutionRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_RESOLUTIONRANGE, Some(0.0)).unwrap()}
  }
  /// The resolution in the azimuth direction measured in meters.
  /// Example: /// Example: 0.123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn resolutionAzimuth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_RESOLUTIONAZIMUTH, Some(0.0)).unwrap()}
  }
  /// The antenna pointing direction (LEFT, RIGHT).
  /// Example: /// Example: RIGHT
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn obDirection(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_OBDIRECTION, None)}
  }
  /// The coordinate system used for the sensor velocity and target position vectors for the collection.
  /// Example: /// Example: ECEF
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn coordSys(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_COORDSYS, None)}
  }
  /// The collection target X position in kilometers.
  /// Example: /// Example: 50.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn targetposx(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_TARGETPOSX, Some(0.0)).unwrap()}
  }
  /// The collection target Y position in kilometers.
  /// Example: /// Example: 50.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn targetposy(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_TARGETPOSY, Some(0.0)).unwrap()}
  }
  /// The collection target Z position in kilometers.
  /// Example: /// Example: 50.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn targetposz(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_TARGETPOSZ, Some(0.0)).unwrap()}
  }
  /// Sensor altitude during collection in kilometers.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senalt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SENALT, Some(0.0)).unwrap()}
  }
  /// Sensor platform X-velocity during collection in kilometers/second.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senvelx(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SENVELX, Some(0.0)).unwrap()}
  }
  /// Sensor platform Y-velocity during collection in kilometers/second.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senvely(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SENVELY, Some(0.0)).unwrap()}
  }
  /// Sensor platform Z-velocity during collection in kilometers/second.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senvelz(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SENVELZ, Some(0.0)).unwrap()}
  }
  /// WGS-84 sensor latitude sub-point at collect start time (collectionStart), represented as -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlatStart(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SENLATSTART, Some(0.0)).unwrap()}
  }
  /// WGS-84 sensor longitude sub-point at collect start time (collectionStart), represented as -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlonStart(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SENLONSTART, Some(0.0)).unwrap()}
  }
  /// WGS-84 sensor latitude sub-point at collect end time (collectionEnd), represented as -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlatEnd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SENLATEND, Some(0.0)).unwrap()}
  }
  /// WGS-84 sensor longitude sub-point at collect end time (collectionEnd), represented as -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlonEnd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SARObservation_Full::VT_SENLONEND, Some(0.0)).unwrap()}
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn transactionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_TRANSACTIONID, None)}
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SARObservation_Full::VT_TAGS, None)}
  }
  /// Array of UDL record types (e.g. ANALYTICMAGERY, ESID, GROUNDIMAGE, NOTIFICATION, POI, SV, TRACK) that are related to the SAR Observation. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
  /// Example: /// Example: ['ESID', 'GROUNDIMAGE']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn srcTyps(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SARObservation_Full::VT_SRCTYPS, None)}
  }
  /// Array of UUIDs of the UDL data records that are related to the SAR Observation. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object (e.g. /udl/sarobservation/{uuid}).
  /// Example: /// Example: ['f7e01cd4-626b-441f-a423-17b160eb78ba', '223833c4-be0d-4fdb-a2e4-325a48eccced']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn srcIds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SARObservation_Full::VT_SRCIDS, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn onOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_ONORBIT, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2023-04-22T17:51:40.854Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_ORIGNETWORK, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SARObservation_Full::VT_SOURCEDL, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> SARObservation_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SARObservation_Full_dataMode_Enum>(SARObservation_Full::VT_DATAMODE, Some(SARObservation_Full_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SARObservation_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor", Self::VT_IDSENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId", Self::VT_ORIGSENSORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("externalId", Self::VT_EXTERNALID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("collectionId", Self::VT_COLLECTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("detectionId", Self::VT_DETECTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("collectionStart", Self::VT_COLLECTIONSTART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("collectionEnd", Self::VT_COLLECTIONEND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("centerTime", Self::VT_CENTERTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("detectionStart", Self::VT_DETECTIONSTART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("detectionEnd", Self::VT_DETECTIONEND, false)?
     .visit_field::<f64>("dwellTime", Self::VT_DWELLTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("orbitState", Self::VT_ORBITSTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sarMode", Self::VT_SARMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("operatingBand", Self::VT_OPERATINGBAND, false)?
     .visit_field::<f64>("operatingFreq", Self::VT_OPERATINGFREQ, false)?
     .visit_field::<f64>("snr", Self::VT_SNR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("txPolarization", Self::VT_TXPOLARIZATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rxPolarization", Self::VT_RXPOLARIZATION, false)?
     .visit_field::<f64>("grazeAngle", Self::VT_GRAZEANGLE, false)?
     .visit_field::<f64>("incidenceAngle", Self::VT_INCIDENCEANGLE, false)?
     .visit_field::<f64>("squintAngle", Self::VT_SQUINTANGLE, false)?
     .visit_field::<f64>("pulseBandwidth", Self::VT_PULSEBANDWIDTH, false)?
     .visit_field::<f64>("pulseDuration", Self::VT_PULSEDURATION, false)?
     .visit_field::<f64>("continuousSpotAngle", Self::VT_CONTINUOUSSPOTANGLE, false)?
     .visit_field::<f64>("slantRange", Self::VT_SLANTRANGE, false)?
     .visit_field::<f64>("nearRange", Self::VT_NEARRANGE, false)?
     .visit_field::<f64>("farRange", Self::VT_FARRANGE, false)?
     .visit_field::<f64>("swathLength", Self::VT_SWATHLENGTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("area", Self::VT_AREA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("atext", Self::VT_ATEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("agjson", Self::VT_AGJSON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("atype", Self::VT_ATYPE, false)?
     .visit_field::<i32>("andims", Self::VT_ANDIMS, false)?
     .visit_field::<i32>("asrid", Self::VT_ASRID, false)?
     .visit_field::<f64>("spacingRange", Self::VT_SPACINGRANGE, false)?
     .visit_field::<f64>("spacingAzimuth", Self::VT_SPACINGAZIMUTH, false)?
     .visit_field::<i32>("looksAzimuth", Self::VT_LOOKSAZIMUTH, false)?
     .visit_field::<i32>("looksRange", Self::VT_LOOKSRANGE, false)?
     .visit_field::<f64>("resolutionRange", Self::VT_RESOLUTIONRANGE, false)?
     .visit_field::<f64>("resolutionAzimuth", Self::VT_RESOLUTIONAZIMUTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("obDirection", Self::VT_OBDIRECTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coordSys", Self::VT_COORDSYS, false)?
     .visit_field::<f64>("targetposx", Self::VT_TARGETPOSX, false)?
     .visit_field::<f64>("targetposy", Self::VT_TARGETPOSY, false)?
     .visit_field::<f64>("targetposz", Self::VT_TARGETPOSZ, false)?
     .visit_field::<f64>("senalt", Self::VT_SENALT, false)?
     .visit_field::<f64>("senvelx", Self::VT_SENVELX, false)?
     .visit_field::<f64>("senvely", Self::VT_SENVELY, false)?
     .visit_field::<f64>("senvelz", Self::VT_SENVELZ, false)?
     .visit_field::<f64>("senlatStart", Self::VT_SENLATSTART, false)?
     .visit_field::<f64>("senlonStart", Self::VT_SENLONSTART, false)?
     .visit_field::<f64>("senlatEnd", Self::VT_SENLATEND, false)?
     .visit_field::<f64>("senlonEnd", Self::VT_SENLONEND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transactionId", Self::VT_TRANSACTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("srcTyps", Self::VT_SRCTYPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("srcIds", Self::VT_SRCIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("onOrbit", Self::VT_ONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .visit_field::<SARObservation_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct SARObservation_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo: i32,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub externalId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub collectionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub detectionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub collectionStart: Option<flatbuffers::WIPOffset<&'a str>>,
    pub collectionEnd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub centerTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub detectionStart: Option<flatbuffers::WIPOffset<&'a str>>,
    pub detectionEnd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dwellTime: f64,
    pub orbitState: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sarMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operatingBand: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operatingFreq: f64,
    pub snr: f64,
    pub txPolarization: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rxPolarization: Option<flatbuffers::WIPOffset<&'a str>>,
    pub grazeAngle: f64,
    pub incidenceAngle: f64,
    pub squintAngle: f64,
    pub pulseBandwidth: f64,
    pub pulseDuration: f64,
    pub continuousSpotAngle: f64,
    pub slantRange: f64,
    pub nearRange: f64,
    pub farRange: f64,
    pub swathLength: f64,
    pub area: Option<flatbuffers::WIPOffset<&'a str>>,
    pub atext: Option<flatbuffers::WIPOffset<&'a str>>,
    pub agjson: Option<flatbuffers::WIPOffset<&'a str>>,
    pub atype: Option<flatbuffers::WIPOffset<&'a str>>,
    pub andims: i32,
    pub asrid: i32,
    pub spacingRange: f64,
    pub spacingAzimuth: f64,
    pub looksAzimuth: i32,
    pub looksRange: i32,
    pub resolutionRange: f64,
    pub resolutionAzimuth: f64,
    pub obDirection: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coordSys: Option<flatbuffers::WIPOffset<&'a str>>,
    pub targetposx: f64,
    pub targetposy: f64,
    pub targetposz: f64,
    pub senalt: f64,
    pub senvelx: f64,
    pub senvely: f64,
    pub senvelz: f64,
    pub senlatStart: f64,
    pub senlonStart: f64,
    pub senlatEnd: f64,
    pub senlonEnd: f64,
    pub transactionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub srcTyps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub srcIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub onOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: SARObservation_Full_dataMode_Enum,
}
impl<'a> Default for SARObservation_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    SARObservation_FullArgs {
      id: None,
      classificationMarking: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      idSensor: None,
      origSensorId: None,
      externalId: None,
      collectionId: None,
      detectionId: None,
      collectionStart: None,
      collectionEnd: None,
      centerTime: None,
      detectionStart: None,
      detectionEnd: None,
      dwellTime: 0.0,
      orbitState: None,
      sarMode: None,
      operatingBand: None,
      operatingFreq: 0.0,
      snr: 0.0,
      txPolarization: None,
      rxPolarization: None,
      grazeAngle: 0.0,
      incidenceAngle: 0.0,
      squintAngle: 0.0,
      pulseBandwidth: 0.0,
      pulseDuration: 0.0,
      continuousSpotAngle: 0.0,
      slantRange: 0.0,
      nearRange: 0.0,
      farRange: 0.0,
      swathLength: 0.0,
      area: None,
      atext: None,
      agjson: None,
      atype: None,
      andims: 0,
      asrid: 0,
      spacingRange: 0.0,
      spacingAzimuth: 0.0,
      looksAzimuth: 0,
      looksRange: 0,
      resolutionRange: 0.0,
      resolutionAzimuth: 0.0,
      obDirection: None,
      coordSys: None,
      targetposx: 0.0,
      targetposy: 0.0,
      targetposz: 0.0,
      senalt: 0.0,
      senvelx: 0.0,
      senvely: 0.0,
      senvelz: 0.0,
      senlatStart: 0.0,
      senlonStart: 0.0,
      senlatEnd: 0.0,
      senlonEnd: 0.0,
      transactionId: None,
      tags: None,
      srcTyps: None,
      srcIds: None,
      onOrbit: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      sourceDL: None,
      dataMode: SARObservation_Full_dataMode_Enum::REAL,
    }
  }
}

pub struct SARObservation_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SARObservation_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(SARObservation_Full::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_idSensor(&mut self, idSensor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_IDSENSOR, idSensor);
  }
  #[inline]
  pub fn add_origSensorId(&mut self, origSensorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_ORIGSENSORID, origSensorId);
  }
  #[inline]
  pub fn add_externalId(&mut self, externalId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_EXTERNALID, externalId);
  }
  #[inline]
  pub fn add_collectionId(&mut self, collectionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_COLLECTIONID, collectionId);
  }
  #[inline]
  pub fn add_detectionId(&mut self, detectionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_DETECTIONID, detectionId);
  }
  #[inline]
  pub fn add_collectionStart(&mut self, collectionStart: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_COLLECTIONSTART, collectionStart);
  }
  #[inline]
  pub fn add_collectionEnd(&mut self, collectionEnd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_COLLECTIONEND, collectionEnd);
  }
  #[inline]
  pub fn add_centerTime(&mut self, centerTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_CENTERTIME, centerTime);
  }
  #[inline]
  pub fn add_detectionStart(&mut self, detectionStart: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_DETECTIONSTART, detectionStart);
  }
  #[inline]
  pub fn add_detectionEnd(&mut self, detectionEnd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_DETECTIONEND, detectionEnd);
  }
  #[inline]
  pub fn add_dwellTime(&mut self, dwellTime: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_DWELLTIME, dwellTime, 0.0);
  }
  #[inline]
  pub fn add_orbitState(&mut self, orbitState: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_ORBITSTATE, orbitState);
  }
  #[inline]
  pub fn add_sarMode(&mut self, sarMode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_SARMODE, sarMode);
  }
  #[inline]
  pub fn add_operatingBand(&mut self, operatingBand: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_OPERATINGBAND, operatingBand);
  }
  #[inline]
  pub fn add_operatingFreq(&mut self, operatingFreq: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_OPERATINGFREQ, operatingFreq, 0.0);
  }
  #[inline]
  pub fn add_snr(&mut self, snr: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SNR, snr, 0.0);
  }
  #[inline]
  pub fn add_txPolarization(&mut self, txPolarization: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_TXPOLARIZATION, txPolarization);
  }
  #[inline]
  pub fn add_rxPolarization(&mut self, rxPolarization: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_RXPOLARIZATION, rxPolarization);
  }
  #[inline]
  pub fn add_grazeAngle(&mut self, grazeAngle: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_GRAZEANGLE, grazeAngle, 0.0);
  }
  #[inline]
  pub fn add_incidenceAngle(&mut self, incidenceAngle: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_INCIDENCEANGLE, incidenceAngle, 0.0);
  }
  #[inline]
  pub fn add_squintAngle(&mut self, squintAngle: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SQUINTANGLE, squintAngle, 0.0);
  }
  #[inline]
  pub fn add_pulseBandwidth(&mut self, pulseBandwidth: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_PULSEBANDWIDTH, pulseBandwidth, 0.0);
  }
  #[inline]
  pub fn add_pulseDuration(&mut self, pulseDuration: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_PULSEDURATION, pulseDuration, 0.0);
  }
  #[inline]
  pub fn add_continuousSpotAngle(&mut self, continuousSpotAngle: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_CONTINUOUSSPOTANGLE, continuousSpotAngle, 0.0);
  }
  #[inline]
  pub fn add_slantRange(&mut self, slantRange: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SLANTRANGE, slantRange, 0.0);
  }
  #[inline]
  pub fn add_nearRange(&mut self, nearRange: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_NEARRANGE, nearRange, 0.0);
  }
  #[inline]
  pub fn add_farRange(&mut self, farRange: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_FARRANGE, farRange, 0.0);
  }
  #[inline]
  pub fn add_swathLength(&mut self, swathLength: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SWATHLENGTH, swathLength, 0.0);
  }
  #[inline]
  pub fn add_area(&mut self, area: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_AREA, area);
  }
  #[inline]
  pub fn add_atext(&mut self, atext: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_ATEXT, atext);
  }
  #[inline]
  pub fn add_agjson(&mut self, agjson: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_AGJSON, agjson);
  }
  #[inline]
  pub fn add_atype(&mut self, atype: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_ATYPE, atype);
  }
  #[inline]
  pub fn add_andims(&mut self, andims: i32) {
    self.fbb_.push_slot::<i32>(SARObservation_Full::VT_ANDIMS, andims, 0);
  }
  #[inline]
  pub fn add_asrid(&mut self, asrid: i32) {
    self.fbb_.push_slot::<i32>(SARObservation_Full::VT_ASRID, asrid, 0);
  }
  #[inline]
  pub fn add_spacingRange(&mut self, spacingRange: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SPACINGRANGE, spacingRange, 0.0);
  }
  #[inline]
  pub fn add_spacingAzimuth(&mut self, spacingAzimuth: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SPACINGAZIMUTH, spacingAzimuth, 0.0);
  }
  #[inline]
  pub fn add_looksAzimuth(&mut self, looksAzimuth: i32) {
    self.fbb_.push_slot::<i32>(SARObservation_Full::VT_LOOKSAZIMUTH, looksAzimuth, 0);
  }
  #[inline]
  pub fn add_looksRange(&mut self, looksRange: i32) {
    self.fbb_.push_slot::<i32>(SARObservation_Full::VT_LOOKSRANGE, looksRange, 0);
  }
  #[inline]
  pub fn add_resolutionRange(&mut self, resolutionRange: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_RESOLUTIONRANGE, resolutionRange, 0.0);
  }
  #[inline]
  pub fn add_resolutionAzimuth(&mut self, resolutionAzimuth: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_RESOLUTIONAZIMUTH, resolutionAzimuth, 0.0);
  }
  #[inline]
  pub fn add_obDirection(&mut self, obDirection: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_OBDIRECTION, obDirection);
  }
  #[inline]
  pub fn add_coordSys(&mut self, coordSys: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_COORDSYS, coordSys);
  }
  #[inline]
  pub fn add_targetposx(&mut self, targetposx: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_TARGETPOSX, targetposx, 0.0);
  }
  #[inline]
  pub fn add_targetposy(&mut self, targetposy: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_TARGETPOSY, targetposy, 0.0);
  }
  #[inline]
  pub fn add_targetposz(&mut self, targetposz: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_TARGETPOSZ, targetposz, 0.0);
  }
  #[inline]
  pub fn add_senalt(&mut self, senalt: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SENALT, senalt, 0.0);
  }
  #[inline]
  pub fn add_senvelx(&mut self, senvelx: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SENVELX, senvelx, 0.0);
  }
  #[inline]
  pub fn add_senvely(&mut self, senvely: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SENVELY, senvely, 0.0);
  }
  #[inline]
  pub fn add_senvelz(&mut self, senvelz: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SENVELZ, senvelz, 0.0);
  }
  #[inline]
  pub fn add_senlatStart(&mut self, senlatStart: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SENLATSTART, senlatStart, 0.0);
  }
  #[inline]
  pub fn add_senlonStart(&mut self, senlonStart: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SENLONSTART, senlonStart, 0.0);
  }
  #[inline]
  pub fn add_senlatEnd(&mut self, senlatEnd: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SENLATEND, senlatEnd, 0.0);
  }
  #[inline]
  pub fn add_senlonEnd(&mut self, senlonEnd: f64) {
    self.fbb_.push_slot::<f64>(SARObservation_Full::VT_SENLONEND, senlonEnd, 0.0);
  }
  #[inline]
  pub fn add_transactionId(&mut self, transactionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_TRANSACTIONID, transactionId);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_srcTyps(&mut self, srcTyps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_SRCTYPS, srcTyps);
  }
  #[inline]
  pub fn add_srcIds(&mut self, srcIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_SRCIDS, srcIds);
  }
  #[inline]
  pub fn add_onOrbit(&mut self, onOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_ONORBIT, onOrbit);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SARObservation_Full::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: SARObservation_Full_dataMode_Enum) {
    self.fbb_.push_slot::<SARObservation_Full_dataMode_Enum>(SARObservation_Full::VT_DATAMODE, dataMode, SARObservation_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SARObservation_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SARObservation_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SARObservation_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SARObservation_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SARObservation_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("satNo", &self.satNo());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("idSensor", &self.idSensor());
      ds.field("origSensorId", &self.origSensorId());
      ds.field("externalId", &self.externalId());
      ds.field("collectionId", &self.collectionId());
      ds.field("detectionId", &self.detectionId());
      ds.field("collectionStart", &self.collectionStart());
      ds.field("collectionEnd", &self.collectionEnd());
      ds.field("centerTime", &self.centerTime());
      ds.field("detectionStart", &self.detectionStart());
      ds.field("detectionEnd", &self.detectionEnd());
      ds.field("dwellTime", &self.dwellTime());
      ds.field("orbitState", &self.orbitState());
      ds.field("sarMode", &self.sarMode());
      ds.field("operatingBand", &self.operatingBand());
      ds.field("operatingFreq", &self.operatingFreq());
      ds.field("snr", &self.snr());
      ds.field("txPolarization", &self.txPolarization());
      ds.field("rxPolarization", &self.rxPolarization());
      ds.field("grazeAngle", &self.grazeAngle());
      ds.field("incidenceAngle", &self.incidenceAngle());
      ds.field("squintAngle", &self.squintAngle());
      ds.field("pulseBandwidth", &self.pulseBandwidth());
      ds.field("pulseDuration", &self.pulseDuration());
      ds.field("continuousSpotAngle", &self.continuousSpotAngle());
      ds.field("slantRange", &self.slantRange());
      ds.field("nearRange", &self.nearRange());
      ds.field("farRange", &self.farRange());
      ds.field("swathLength", &self.swathLength());
      ds.field("area", &self.area());
      ds.field("atext", &self.atext());
      ds.field("agjson", &self.agjson());
      ds.field("atype", &self.atype());
      ds.field("andims", &self.andims());
      ds.field("asrid", &self.asrid());
      ds.field("spacingRange", &self.spacingRange());
      ds.field("spacingAzimuth", &self.spacingAzimuth());
      ds.field("looksAzimuth", &self.looksAzimuth());
      ds.field("looksRange", &self.looksRange());
      ds.field("resolutionRange", &self.resolutionRange());
      ds.field("resolutionAzimuth", &self.resolutionAzimuth());
      ds.field("obDirection", &self.obDirection());
      ds.field("coordSys", &self.coordSys());
      ds.field("targetposx", &self.targetposx());
      ds.field("targetposy", &self.targetposy());
      ds.field("targetposz", &self.targetposz());
      ds.field("senalt", &self.senalt());
      ds.field("senvelx", &self.senvelx());
      ds.field("senvely", &self.senvely());
      ds.field("senvelz", &self.senvelz());
      ds.field("senlatStart", &self.senlatStart());
      ds.field("senlonStart", &self.senlonStart());
      ds.field("senlatEnd", &self.senlatEnd());
      ds.field("senlonEnd", &self.senlonEnd());
      ds.field("transactionId", &self.transactionId());
      ds.field("tags", &self.tags());
      ds.field("srcTyps", &self.srcTyps());
      ds.field("srcIds", &self.srcIds());
      ds.field("onOrbit", &self.onOrbit());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("sourceDL", &self.sourceDL());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SARObservation_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idOnOrbit: Option<String>,
  pub satNo: i32,
  pub origObjectId: Option<String>,
  pub idSensor: Option<String>,
  pub origSensorId: Option<String>,
  pub externalId: Option<String>,
  pub collectionId: Option<String>,
  pub detectionId: Option<String>,
  pub collectionStart: Option<String>,
  pub collectionEnd: Option<String>,
  pub centerTime: Option<String>,
  pub detectionStart: Option<String>,
  pub detectionEnd: Option<String>,
  pub dwellTime: f64,
  pub orbitState: Option<String>,
  pub sarMode: Option<String>,
  pub operatingBand: Option<String>,
  pub operatingFreq: f64,
  pub snr: f64,
  pub txPolarization: Option<String>,
  pub rxPolarization: Option<String>,
  pub grazeAngle: f64,
  pub incidenceAngle: f64,
  pub squintAngle: f64,
  pub pulseBandwidth: f64,
  pub pulseDuration: f64,
  pub continuousSpotAngle: f64,
  pub slantRange: f64,
  pub nearRange: f64,
  pub farRange: f64,
  pub swathLength: f64,
  pub area: Option<String>,
  pub atext: Option<String>,
  pub agjson: Option<String>,
  pub atype: Option<String>,
  pub andims: i32,
  pub asrid: i32,
  pub spacingRange: f64,
  pub spacingAzimuth: f64,
  pub looksAzimuth: i32,
  pub looksRange: i32,
  pub resolutionRange: f64,
  pub resolutionAzimuth: f64,
  pub obDirection: Option<String>,
  pub coordSys: Option<String>,
  pub targetposx: f64,
  pub targetposy: f64,
  pub targetposz: f64,
  pub senalt: f64,
  pub senvelx: f64,
  pub senvely: f64,
  pub senvelz: f64,
  pub senlatStart: f64,
  pub senlonStart: f64,
  pub senlatEnd: f64,
  pub senlonEnd: f64,
  pub transactionId: Option<String>,
  pub tags: Option<Vec<String>>,
  pub srcTyps: Option<Vec<String>>,
  pub srcIds: Option<Vec<String>>,
  pub onOrbit: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub sourceDL: Option<String>,
  pub dataMode: SARObservation_Full_dataMode_Enum,
}
impl Default for SARObservation_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      idSensor: None,
      origSensorId: None,
      externalId: None,
      collectionId: None,
      detectionId: None,
      collectionStart: None,
      collectionEnd: None,
      centerTime: None,
      detectionStart: None,
      detectionEnd: None,
      dwellTime: 0.0,
      orbitState: None,
      sarMode: None,
      operatingBand: None,
      operatingFreq: 0.0,
      snr: 0.0,
      txPolarization: None,
      rxPolarization: None,
      grazeAngle: 0.0,
      incidenceAngle: 0.0,
      squintAngle: 0.0,
      pulseBandwidth: 0.0,
      pulseDuration: 0.0,
      continuousSpotAngle: 0.0,
      slantRange: 0.0,
      nearRange: 0.0,
      farRange: 0.0,
      swathLength: 0.0,
      area: None,
      atext: None,
      agjson: None,
      atype: None,
      andims: 0,
      asrid: 0,
      spacingRange: 0.0,
      spacingAzimuth: 0.0,
      looksAzimuth: 0,
      looksRange: 0,
      resolutionRange: 0.0,
      resolutionAzimuth: 0.0,
      obDirection: None,
      coordSys: None,
      targetposx: 0.0,
      targetposy: 0.0,
      targetposz: 0.0,
      senalt: 0.0,
      senvelx: 0.0,
      senvely: 0.0,
      senvelz: 0.0,
      senlatStart: 0.0,
      senlonStart: 0.0,
      senlatEnd: 0.0,
      senlonEnd: 0.0,
      transactionId: None,
      tags: None,
      srcTyps: None,
      srcIds: None,
      onOrbit: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      sourceDL: None,
      dataMode: SARObservation_Full_dataMode_Enum::REAL,
    }
  }
}
impl SARObservation_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SARObservation_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo = self.satNo;
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor = self.idSensor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId = self.origSensorId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let externalId = self.externalId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let collectionId = self.collectionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let detectionId = self.detectionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let collectionStart = self.collectionStart.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let collectionEnd = self.collectionEnd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let centerTime = self.centerTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let detectionStart = self.detectionStart.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let detectionEnd = self.detectionEnd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dwellTime = self.dwellTime;
    let orbitState = self.orbitState.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sarMode = self.sarMode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let operatingBand = self.operatingBand.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let operatingFreq = self.operatingFreq;
    let snr = self.snr;
    let txPolarization = self.txPolarization.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rxPolarization = self.rxPolarization.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let grazeAngle = self.grazeAngle;
    let incidenceAngle = self.incidenceAngle;
    let squintAngle = self.squintAngle;
    let pulseBandwidth = self.pulseBandwidth;
    let pulseDuration = self.pulseDuration;
    let continuousSpotAngle = self.continuousSpotAngle;
    let slantRange = self.slantRange;
    let nearRange = self.nearRange;
    let farRange = self.farRange;
    let swathLength = self.swathLength;
    let area = self.area.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let atext = self.atext.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let agjson = self.agjson.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let atype = self.atype.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let andims = self.andims;
    let asrid = self.asrid;
    let spacingRange = self.spacingRange;
    let spacingAzimuth = self.spacingAzimuth;
    let looksAzimuth = self.looksAzimuth;
    let looksRange = self.looksRange;
    let resolutionRange = self.resolutionRange;
    let resolutionAzimuth = self.resolutionAzimuth;
    let obDirection = self.obDirection.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let coordSys = self.coordSys.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let targetposx = self.targetposx;
    let targetposy = self.targetposy;
    let targetposz = self.targetposz;
    let senalt = self.senalt;
    let senvelx = self.senvelx;
    let senvely = self.senvely;
    let senvelz = self.senvelz;
    let senlatStart = self.senlatStart;
    let senlonStart = self.senlonStart;
    let senlatEnd = self.senlatEnd;
    let senlonEnd = self.senlonEnd;
    let transactionId = self.transactionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let srcTyps = self.srcTyps.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let srcIds = self.srcIds.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let onOrbit = self.onOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    SARObservation_Full::create(_fbb, &SARObservation_FullArgs{
      id,
      classificationMarking,
      idOnOrbit,
      satNo,
      origObjectId,
      idSensor,
      origSensorId,
      externalId,
      collectionId,
      detectionId,
      collectionStart,
      collectionEnd,
      centerTime,
      detectionStart,
      detectionEnd,
      dwellTime,
      orbitState,
      sarMode,
      operatingBand,
      operatingFreq,
      snr,
      txPolarization,
      rxPolarization,
      grazeAngle,
      incidenceAngle,
      squintAngle,
      pulseBandwidth,
      pulseDuration,
      continuousSpotAngle,
      slantRange,
      nearRange,
      farRange,
      swathLength,
      area,
      atext,
      agjson,
      atype,
      andims,
      asrid,
      spacingRange,
      spacingAzimuth,
      looksAzimuth,
      looksRange,
      resolutionRange,
      resolutionAzimuth,
      obDirection,
      coordSys,
      targetposx,
      targetposy,
      targetposz,
      senalt,
      senvelx,
      senvely,
      senvelz,
      senlatStart,
      senlonStart,
      senlatEnd,
      senlonEnd,
      transactionId,
      tags,
      srcTyps,
      srcIds,
      onOrbit,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      sourceDL,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SARObservation_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sarobservation_full_unchecked`.
pub fn root_as_sarobservation_full(buf: &[u8]) -> Result<SARObservation_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SARObservation_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SARObservation_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_sarobservation_full_unchecked`.
pub fn size_prefixed_root_as_sarobservation_full(buf: &[u8]) -> Result<SARObservation_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SARObservation_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SARObservation_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sarobservation_full_unchecked`.
pub fn root_as_sarobservation_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SARObservation_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SARObservation_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SARObservation_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sarobservation_full_unchecked`.
pub fn size_prefixed_root_as_sarobservation_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SARObservation_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SARObservation_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SARObservation_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SARObservation_Full`.
pub unsafe fn root_as_sarobservation_full_unchecked(buf: &[u8]) -> SARObservation_Full {
  flatbuffers::root_unchecked::<SARObservation_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SARObservation_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SARObservation_Full`.
pub unsafe fn size_prefixed_root_as_sarobservation_full_unchecked(buf: &[u8]) -> SARObservation_Full {
  flatbuffers::size_prefixed_root_unchecked::<SARObservation_Full>(buf)
}
pub const SAROBSERVATION_FULL_IDENTIFIER: &str = "SARO";

#[inline]
pub fn sarobservation_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SAROBSERVATION_FULL_IDENTIFIER, false)
}

#[inline]
pub fn sarobservation_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SAROBSERVATION_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_sarobservation_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<SARObservation_Full<'a>>) {
  fbb.finish(root, Some(SAROBSERVATION_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_sarobservation_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<SARObservation_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(SAROBSERVATION_FULL_IDENTIFIER));
}
