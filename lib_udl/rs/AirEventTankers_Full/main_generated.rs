// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum AirEventTankers_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Collection of tanker aircraft associated with this Air Event.
pub struct AirEventTankers_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AirEventTankers_Full<'a> {
  type Inner = AirEventTankers_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AirEventTankers_Full<'a> {
  pub const VT_IDTANKERSORTIE: flatbuffers::VOffsetT = 4;
  pub const VT_IDTANKERMISSION: flatbuffers::VOffsetT = 6;
  pub const VT_IDTANKERAIRFIELD: flatbuffers::VOffsetT = 8;
  pub const VT_EXTERNALTANKERID: flatbuffers::VOffsetT = 10;
  pub const VT_TANKERCOORD: flatbuffers::VOffsetT = 12;
  pub const VT_TANKERMDS: flatbuffers::VOffsetT = 14;
  pub const VT_AMCTANKERMISSIONID: flatbuffers::VOffsetT = 16;
  pub const VT_ALTTANKERMISSIONID: flatbuffers::VOffsetT = 18;
  pub const VT_TANKERCALLSIGN: flatbuffers::VOffsetT = 20;
  pub const VT_TANKEROWNER: flatbuffers::VOffsetT = 22;
  pub const VT_TANKERPOC: flatbuffers::VOffsetT = 24;
  pub const VT_TANKERLEGNUM: flatbuffers::VOffsetT = 26;
  pub const VT_TANKERDEPLOYEDICAO: flatbuffers::VOffsetT = 28;
  pub const VT_TANKERDELIVERYMETHOD: flatbuffers::VOffsetT = 30;
  pub const VT_FUELOFF: flatbuffers::VOffsetT = 32;
  pub const VT_TANKERCELLPOSITION: flatbuffers::VOffsetT = 34;
  pub const VT_TANKERFUELTYPE: flatbuffers::VOffsetT = 36;
  pub const VT_DUALROLE: flatbuffers::VOffsetT = 38;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AirEventTankers_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AirEventTankers_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<AirEventTankers_Full<'bldr>> {
    let mut builder = AirEventTankers_FullBuilder::new(_fbb);
    builder.add_fuelOff(args.fuelOff);
    if let Some(x) = args.tankerFuelType { builder.add_tankerFuelType(x); }
    builder.add_tankerCellPosition(args.tankerCellPosition);
    if let Some(x) = args.tankerDeliveryMethod { builder.add_tankerDeliveryMethod(x); }
    if let Some(x) = args.tankerDeployedICAO { builder.add_tankerDeployedICAO(x); }
    builder.add_tankerLegNum(args.tankerLegNum);
    if let Some(x) = args.tankerPOC { builder.add_tankerPOC(x); }
    if let Some(x) = args.tankerOwner { builder.add_tankerOwner(x); }
    if let Some(x) = args.tankerCallSign { builder.add_tankerCallSign(x); }
    if let Some(x) = args.altTankerMissionId { builder.add_altTankerMissionId(x); }
    if let Some(x) = args.amcTankerMissionId { builder.add_amcTankerMissionId(x); }
    if let Some(x) = args.tankerMDS { builder.add_tankerMDS(x); }
    if let Some(x) = args.tankerCoord { builder.add_tankerCoord(x); }
    if let Some(x) = args.externalTankerId { builder.add_externalTankerId(x); }
    if let Some(x) = args.idTankerAirfield { builder.add_idTankerAirfield(x); }
    if let Some(x) = args.idTankerMission { builder.add_idTankerMission(x); }
    if let Some(x) = args.idTankerSortie { builder.add_idTankerSortie(x); }
    builder.add_dualRole(args.dualRole);
    builder.finish()
  }

  pub fn unpack(&self) -> AirEventTankers_FullT {
    let idTankerSortie = self.idTankerSortie().map(|x| {
      x.to_string()
    });
    let idTankerMission = self.idTankerMission().map(|x| {
      x.to_string()
    });
    let idTankerAirfield = self.idTankerAirfield().map(|x| {
      x.to_string()
    });
    let externalTankerId = self.externalTankerId().map(|x| {
      x.to_string()
    });
    let tankerCoord = self.tankerCoord().map(|x| {
      x.to_string()
    });
    let tankerMDS = self.tankerMDS().map(|x| {
      x.to_string()
    });
    let amcTankerMissionId = self.amcTankerMissionId().map(|x| {
      x.to_string()
    });
    let altTankerMissionId = self.altTankerMissionId().map(|x| {
      x.to_string()
    });
    let tankerCallSign = self.tankerCallSign().map(|x| {
      x.to_string()
    });
    let tankerOwner = self.tankerOwner().map(|x| {
      x.to_string()
    });
    let tankerPOC = self.tankerPOC().map(|x| {
      x.to_string()
    });
    let tankerLegNum = self.tankerLegNum();
    let tankerDeployedICAO = self.tankerDeployedICAO().map(|x| {
      x.to_string()
    });
    let tankerDeliveryMethod = self.tankerDeliveryMethod().map(|x| {
      x.to_string()
    });
    let fuelOff = self.fuelOff();
    let tankerCellPosition = self.tankerCellPosition();
    let tankerFuelType = self.tankerFuelType().map(|x| {
      x.to_string()
    });
    let dualRole = self.dualRole();
    AirEventTankers_FullT {
      idTankerSortie,
      idTankerMission,
      idTankerAirfield,
      externalTankerId,
      tankerCoord,
      tankerMDS,
      amcTankerMissionId,
      altTankerMissionId,
      tankerCallSign,
      tankerOwner,
      tankerPOC,
      tankerLegNum,
      tankerDeployedICAO,
      tankerDeliveryMethod,
      fuelOff,
      tankerCellPosition,
      tankerFuelType,
      dualRole,
    }
  }

  /// The UDL ID of the aircraft sortie this tanker is associated with for this event.
  /// Example: /// Example: d833a4bc-756b-41d5-8845-f146fe563387
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idTankerSortie(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_IDTANKERSORTIE, None)}
  }
  /// The UDL ID of the mission this tanker is associated with for this event.
  /// Example: /// Example: edef700c-9917-4dbf-a153-89ffd4446fe9
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idTankerMission(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_IDTANKERMISSION, None)}
  }
  /// The UDL ID of the airfield this tanker is associated with for this event.
  /// Example: /// Example: b33955d2-67d3-42be-8316-263e284ce6cc
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idTankerAirfield(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_IDTANKERAIRFIELD, None)}
  }
  /// Optional tanker identifier from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: ca673c580fb949a5b733f0e0b67ffab2
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn externalTankerId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_EXTERNALTANKERID, None)}
  }
  /// Coordination record identifier of this tanker.
  /// Example: /// Example: TTC601
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn tankerCoord(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_TANKERCOORD, None)}
  }
  /// The Model Design Series designation of this tanker.
  /// Example: /// Example: KC135R
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn tankerMDS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_TANKERMDS, None)}
  }
  /// The Air Mobility Command (AMC) mission identifier of this tanker.
  /// Example: /// Example: 8PH000B1S052
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn amcTankerMissionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_AMCTANKERMISSIONID, None)}
  }
  /// Alternate mission identifier of this tanker provided by source.
  /// Example: /// Example: 1UN05201L121
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn altTankerMissionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_ALTTANKERMISSIONID, None)}
  }
  /// The call sign assigned to this tanker.
  /// Example: /// Example: BAKER
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn tankerCallSign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_TANKERCALLSIGN, None)}
  }
  /// The wing or unit that owns this tanker.
  /// Example: /// Example: 117ARW
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn tankerOwner(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_TANKEROWNER, None)}
  }
  /// The name and/or number of the point of contact for this tanker.
  /// Example: /// Example: JOHN SMITH (555)555-5555
  /// Constraints: Minimum length = 0, Maximum length = 68
  #[inline]
  pub fn tankerPOC(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_TANKERPOC, None)}
  }
  /// Identifies the itinerary point of a mission that this tanker is linked to.
  /// Example: /// Example: 825
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tankerLegNum(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirEventTankers_Full::VT_TANKERLEGNUM, Some(0)).unwrap()}
  }
  /// Location the tanker has been deployed to in preparation for an air refueling event.
  /// Example: /// Example: KOFF
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn tankerDeployedICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_TANKERDEPLOYEDICAO, None)}
  }
  /// Type of fuel delivery method used by the tanker during an air refueling event (BOOM, DROGUE, BOTH).
  /// Example: /// Example: DROGUE
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn tankerDeliveryMethod(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_TANKERDELIVERYMETHOD, None)}
  }
  /// Total weight of the fuel transferred from this tanker during an air refueling event, in pounds.
  /// Example: /// Example: 15000000.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fuelOff(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirEventTankers_Full::VT_FUELOFF, Some(0.0)).unwrap()}
  }
  /// Position of this tanker within a group of tankers in an air refueling event.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tankerCellPosition(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirEventTankers_Full::VT_TANKERCELLPOSITION, Some(0)).unwrap()}
  }
  /// Type of fuel being transferred from the tanker in an air refueling event.
  /// Example: /// Example: JP8
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn tankerFuelType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirEventTankers_Full::VT_TANKERFUELTYPE, None)}
  }
  /// Flag indicating that this tanker is flying a dual role mission in an air refueling event.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dualRole(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AirEventTankers_Full::VT_DUALROLE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AirEventTankers_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idTankerSortie", Self::VT_IDTANKERSORTIE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idTankerMission", Self::VT_IDTANKERMISSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idTankerAirfield", Self::VT_IDTANKERAIRFIELD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("externalTankerId", Self::VT_EXTERNALTANKERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tankerCoord", Self::VT_TANKERCOORD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tankerMDS", Self::VT_TANKERMDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("amcTankerMissionId", Self::VT_AMCTANKERMISSIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altTankerMissionId", Self::VT_ALTTANKERMISSIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tankerCallSign", Self::VT_TANKERCALLSIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tankerOwner", Self::VT_TANKEROWNER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tankerPOC", Self::VT_TANKERPOC, false)?
     .visit_field::<i32>("tankerLegNum", Self::VT_TANKERLEGNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tankerDeployedICAO", Self::VT_TANKERDEPLOYEDICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tankerDeliveryMethod", Self::VT_TANKERDELIVERYMETHOD, false)?
     .visit_field::<f64>("fuelOff", Self::VT_FUELOFF, false)?
     .visit_field::<i32>("tankerCellPosition", Self::VT_TANKERCELLPOSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tankerFuelType", Self::VT_TANKERFUELTYPE, false)?
     .visit_field::<bool>("dualRole", Self::VT_DUALROLE, false)?
     .finish();
    Ok(())
  }
}
pub struct AirEventTankers_FullArgs<'a> {
    pub idTankerSortie: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idTankerMission: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idTankerAirfield: Option<flatbuffers::WIPOffset<&'a str>>,
    pub externalTankerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tankerCoord: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tankerMDS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub amcTankerMissionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altTankerMissionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tankerCallSign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tankerOwner: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tankerPOC: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tankerLegNum: i32,
    pub tankerDeployedICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tankerDeliveryMethod: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fuelOff: f64,
    pub tankerCellPosition: i32,
    pub tankerFuelType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dualRole: bool,
}
impl<'a> Default for AirEventTankers_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    AirEventTankers_FullArgs {
      idTankerSortie: None,
      idTankerMission: None,
      idTankerAirfield: None,
      externalTankerId: None,
      tankerCoord: None,
      tankerMDS: None,
      amcTankerMissionId: None,
      altTankerMissionId: None,
      tankerCallSign: None,
      tankerOwner: None,
      tankerPOC: None,
      tankerLegNum: 0,
      tankerDeployedICAO: None,
      tankerDeliveryMethod: None,
      fuelOff: 0.0,
      tankerCellPosition: 0,
      tankerFuelType: None,
      dualRole: false,
    }
  }
}

pub struct AirEventTankers_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AirEventTankers_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_idTankerSortie(&mut self, idTankerSortie: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_IDTANKERSORTIE, idTankerSortie);
  }
  #[inline]
  pub fn add_idTankerMission(&mut self, idTankerMission: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_IDTANKERMISSION, idTankerMission);
  }
  #[inline]
  pub fn add_idTankerAirfield(&mut self, idTankerAirfield: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_IDTANKERAIRFIELD, idTankerAirfield);
  }
  #[inline]
  pub fn add_externalTankerId(&mut self, externalTankerId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_EXTERNALTANKERID, externalTankerId);
  }
  #[inline]
  pub fn add_tankerCoord(&mut self, tankerCoord: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_TANKERCOORD, tankerCoord);
  }
  #[inline]
  pub fn add_tankerMDS(&mut self, tankerMDS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_TANKERMDS, tankerMDS);
  }
  #[inline]
  pub fn add_amcTankerMissionId(&mut self, amcTankerMissionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_AMCTANKERMISSIONID, amcTankerMissionId);
  }
  #[inline]
  pub fn add_altTankerMissionId(&mut self, altTankerMissionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_ALTTANKERMISSIONID, altTankerMissionId);
  }
  #[inline]
  pub fn add_tankerCallSign(&mut self, tankerCallSign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_TANKERCALLSIGN, tankerCallSign);
  }
  #[inline]
  pub fn add_tankerOwner(&mut self, tankerOwner: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_TANKEROWNER, tankerOwner);
  }
  #[inline]
  pub fn add_tankerPOC(&mut self, tankerPOC: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_TANKERPOC, tankerPOC);
  }
  #[inline]
  pub fn add_tankerLegNum(&mut self, tankerLegNum: i32) {
    self.fbb_.push_slot::<i32>(AirEventTankers_Full::VT_TANKERLEGNUM, tankerLegNum, 0);
  }
  #[inline]
  pub fn add_tankerDeployedICAO(&mut self, tankerDeployedICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_TANKERDEPLOYEDICAO, tankerDeployedICAO);
  }
  #[inline]
  pub fn add_tankerDeliveryMethod(&mut self, tankerDeliveryMethod: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_TANKERDELIVERYMETHOD, tankerDeliveryMethod);
  }
  #[inline]
  pub fn add_fuelOff(&mut self, fuelOff: f64) {
    self.fbb_.push_slot::<f64>(AirEventTankers_Full::VT_FUELOFF, fuelOff, 0.0);
  }
  #[inline]
  pub fn add_tankerCellPosition(&mut self, tankerCellPosition: i32) {
    self.fbb_.push_slot::<i32>(AirEventTankers_Full::VT_TANKERCELLPOSITION, tankerCellPosition, 0);
  }
  #[inline]
  pub fn add_tankerFuelType(&mut self, tankerFuelType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirEventTankers_Full::VT_TANKERFUELTYPE, tankerFuelType);
  }
  #[inline]
  pub fn add_dualRole(&mut self, dualRole: bool) {
    self.fbb_.push_slot::<bool>(AirEventTankers_Full::VT_DUALROLE, dualRole, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AirEventTankers_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AirEventTankers_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AirEventTankers_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AirEventTankers_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AirEventTankers_Full");
      ds.field("idTankerSortie", &self.idTankerSortie());
      ds.field("idTankerMission", &self.idTankerMission());
      ds.field("idTankerAirfield", &self.idTankerAirfield());
      ds.field("externalTankerId", &self.externalTankerId());
      ds.field("tankerCoord", &self.tankerCoord());
      ds.field("tankerMDS", &self.tankerMDS());
      ds.field("amcTankerMissionId", &self.amcTankerMissionId());
      ds.field("altTankerMissionId", &self.altTankerMissionId());
      ds.field("tankerCallSign", &self.tankerCallSign());
      ds.field("tankerOwner", &self.tankerOwner());
      ds.field("tankerPOC", &self.tankerPOC());
      ds.field("tankerLegNum", &self.tankerLegNum());
      ds.field("tankerDeployedICAO", &self.tankerDeployedICAO());
      ds.field("tankerDeliveryMethod", &self.tankerDeliveryMethod());
      ds.field("fuelOff", &self.fuelOff());
      ds.field("tankerCellPosition", &self.tankerCellPosition());
      ds.field("tankerFuelType", &self.tankerFuelType());
      ds.field("dualRole", &self.dualRole());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AirEventTankers_FullT {
  pub idTankerSortie: Option<String>,
  pub idTankerMission: Option<String>,
  pub idTankerAirfield: Option<String>,
  pub externalTankerId: Option<String>,
  pub tankerCoord: Option<String>,
  pub tankerMDS: Option<String>,
  pub amcTankerMissionId: Option<String>,
  pub altTankerMissionId: Option<String>,
  pub tankerCallSign: Option<String>,
  pub tankerOwner: Option<String>,
  pub tankerPOC: Option<String>,
  pub tankerLegNum: i32,
  pub tankerDeployedICAO: Option<String>,
  pub tankerDeliveryMethod: Option<String>,
  pub fuelOff: f64,
  pub tankerCellPosition: i32,
  pub tankerFuelType: Option<String>,
  pub dualRole: bool,
}
impl Default for AirEventTankers_FullT {
  fn default() -> Self {
    Self {
      idTankerSortie: None,
      idTankerMission: None,
      idTankerAirfield: None,
      externalTankerId: None,
      tankerCoord: None,
      tankerMDS: None,
      amcTankerMissionId: None,
      altTankerMissionId: None,
      tankerCallSign: None,
      tankerOwner: None,
      tankerPOC: None,
      tankerLegNum: 0,
      tankerDeployedICAO: None,
      tankerDeliveryMethod: None,
      fuelOff: 0.0,
      tankerCellPosition: 0,
      tankerFuelType: None,
      dualRole: false,
    }
  }
}
impl AirEventTankers_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AirEventTankers_Full<'b>> {
    let idTankerSortie = self.idTankerSortie.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idTankerMission = self.idTankerMission.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idTankerAirfield = self.idTankerAirfield.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let externalTankerId = self.externalTankerId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tankerCoord = self.tankerCoord.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tankerMDS = self.tankerMDS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let amcTankerMissionId = self.amcTankerMissionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altTankerMissionId = self.altTankerMissionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tankerCallSign = self.tankerCallSign.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tankerOwner = self.tankerOwner.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tankerPOC = self.tankerPOC.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tankerLegNum = self.tankerLegNum;
    let tankerDeployedICAO = self.tankerDeployedICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tankerDeliveryMethod = self.tankerDeliveryMethod.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let fuelOff = self.fuelOff;
    let tankerCellPosition = self.tankerCellPosition;
    let tankerFuelType = self.tankerFuelType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dualRole = self.dualRole;
    AirEventTankers_Full::create(_fbb, &AirEventTankers_FullArgs{
      idTankerSortie,
      idTankerMission,
      idTankerAirfield,
      externalTankerId,
      tankerCoord,
      tankerMDS,
      amcTankerMissionId,
      altTankerMissionId,
      tankerCallSign,
      tankerOwner,
      tankerPOC,
      tankerLegNum,
      tankerDeployedICAO,
      tankerDeliveryMethod,
      fuelOff,
      tankerCellPosition,
      tankerFuelType,
      dualRole,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AirEventTankers_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_air_event_tankers_full_unchecked`.
pub fn root_as_air_event_tankers_full(buf: &[u8]) -> Result<AirEventTankers_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AirEventTankers_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AirEventTankers_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_air_event_tankers_full_unchecked`.
pub fn size_prefixed_root_as_air_event_tankers_full(buf: &[u8]) -> Result<AirEventTankers_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AirEventTankers_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AirEventTankers_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_air_event_tankers_full_unchecked`.
pub fn root_as_air_event_tankers_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirEventTankers_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AirEventTankers_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AirEventTankers_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_air_event_tankers_full_unchecked`.
pub fn size_prefixed_root_as_air_event_tankers_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirEventTankers_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AirEventTankers_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AirEventTankers_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AirEventTankers_Full`.
pub unsafe fn root_as_air_event_tankers_full_unchecked(buf: &[u8]) -> AirEventTankers_Full {
  flatbuffers::root_unchecked::<AirEventTankers_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AirEventTankers_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AirEventTankers_Full`.
pub unsafe fn size_prefixed_root_as_air_event_tankers_full_unchecked(buf: &[u8]) -> AirEventTankers_Full {
  flatbuffers::size_prefixed_root_unchecked::<AirEventTankers_Full>(buf)
}
pub const AIR_EVENT_TANKERS_FULL_IDENTIFIER: &str = "AIRE";

#[inline]
pub fn air_event_tankers_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIR_EVENT_TANKERS_FULL_IDENTIFIER, false)
}

#[inline]
pub fn air_event_tankers_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIR_EVENT_TANKERS_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_air_event_tankers_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AirEventTankers_Full<'a>>) {
  fbb.finish(root, Some(AIR_EVENT_TANKERS_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_air_event_tankers_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AirEventTankers_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(AIR_EVENT_TANKERS_FULL_IDENTIFIER));
}
