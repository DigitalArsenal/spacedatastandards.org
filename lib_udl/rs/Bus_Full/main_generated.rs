// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BUS_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BUS_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BUS_FULL_DATA_MODE_ENUM: [Bus_Full_dataMode_Enum; 4] = [
  Bus_Full_dataMode_Enum::REAL,
  Bus_Full_dataMode_Enum::TEST,
  Bus_Full_dataMode_Enum::SIMULATED,
  Bus_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Bus_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Bus_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Bus_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Bus_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Bus_Full_dataMode_Enum {
    type Output = Bus_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Bus_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Bus_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Bus_Full_dataMode_Enum {}
pub enum Bus_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// A bus is the physical and software infrastructure backbone to which on-orbit satellite payloads are attached for power, control, and other support functions.
pub struct Bus_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bus_Full<'a> {
  type Inner = Bus_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Bus_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 8;
  pub const VT_IDENTITY: flatbuffers::VOffsetT = 10;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 12;
  pub const VT_MAXLAUNCHMASSLOWER: flatbuffers::VOffsetT = 14;
  pub const VT_MAXLAUNCHMASSUPPER: flatbuffers::VOffsetT = 16;
  pub const VT_MAXBOLSTATIONMASS: flatbuffers::VOffsetT = 18;
  pub const VT_AVGPAYLOADMASS: flatbuffers::VOffsetT = 20;
  pub const VT_MAXPAYLOADMASS: flatbuffers::VOffsetT = 22;
  pub const VT_MINDRYMASS: flatbuffers::VOffsetT = 24;
  pub const VT_AVGDRYMASS: flatbuffers::VOffsetT = 26;
  pub const VT_MEDIANDRYMASS: flatbuffers::VOffsetT = 28;
  pub const VT_MAXDRYMASS: flatbuffers::VOffsetT = 30;
  pub const VT_MINWETMASS: flatbuffers::VOffsetT = 32;
  pub const VT_AVGWETMASS: flatbuffers::VOffsetT = 34;
  pub const VT_MEDIANWETMASS: flatbuffers::VOffsetT = 36;
  pub const VT_MAXWETMASS: flatbuffers::VOffsetT = 38;
  pub const VT_MAXBOLPOWERLOWER: flatbuffers::VOffsetT = 40;
  pub const VT_MAXBOLPOWERUPPER: flatbuffers::VOffsetT = 42;
  pub const VT_MAXEOLPOWERLOWER: flatbuffers::VOffsetT = 44;
  pub const VT_MAXEOLPOWERUPPER: flatbuffers::VOffsetT = 46;
  pub const VT_AVGSPACECRAFTPOWER: flatbuffers::VOffsetT = 48;
  pub const VT_MAXSPACECRAFTPOWER: flatbuffers::VOffsetT = 50;
  pub const VT_OAPSPACECRAFTPOWER: flatbuffers::VOffsetT = 52;
  pub const VT_AVGPAYLOADPOWER: flatbuffers::VOffsetT = 54;
  pub const VT_MAXPAYLOADPOWER: flatbuffers::VOffsetT = 56;
  pub const VT_OAPPAYLOADPOWER: flatbuffers::VOffsetT = 58;
  pub const VT_BODYDIMENSIONX: flatbuffers::VOffsetT = 60;
  pub const VT_BODYDIMENSIONY: flatbuffers::VOffsetT = 62;
  pub const VT_BODYDIMENSIONZ: flatbuffers::VOffsetT = 64;
  pub const VT_PAYLOADDIMENSIONX: flatbuffers::VOffsetT = 66;
  pub const VT_PAYLOADDIMENSIONY: flatbuffers::VOffsetT = 68;
  pub const VT_PAYLOADDIMENSIONZ: flatbuffers::VOffsetT = 70;
  pub const VT_PAYLOADVOLUME: flatbuffers::VOffsetT = 72;
  pub const VT_LAUNCHENVELOPEDIMENSIONX: flatbuffers::VOffsetT = 74;
  pub const VT_LAUNCHENVELOPEDIMENSIONY: flatbuffers::VOffsetT = 76;
  pub const VT_LAUNCHENVELOPEDIMENSIONZ: flatbuffers::VOffsetT = 78;
  pub const VT_NUMORBITTYPE: flatbuffers::VOffsetT = 80;
  pub const VT_ORBITTYPES: flatbuffers::VOffsetT = 82;
  pub const VT_TELEMETRYTRACKINGMANUFACTURERORGID: flatbuffers::VOffsetT = 84;
  pub const VT_MAINCOMPUTERMANUFACTURERORGID: flatbuffers::VOffsetT = 86;
  pub const VT_MANUFACTURERORGID: flatbuffers::VOffsetT = 88;
  pub const VT_BUSKITDESIGNERORGID: flatbuffers::VOffsetT = 90;
  pub const VT_COUNTRYCODE: flatbuffers::VOffsetT = 92;
  pub const VT_MASSCATEGORY: flatbuffers::VOffsetT = 94;
  pub const VT_POWERCATEGORY: flatbuffers::VOffsetT = 96;
  pub const VT_GENERIC: flatbuffers::VOffsetT = 98;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 100;
  pub const VT_AOCSNOTES: flatbuffers::VOffsetT = 102;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 104;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 106;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 108;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 110;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 112;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 114;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 116;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 118;
  pub const VT_ENTITY: flatbuffers::VOffsetT = 120;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Bus_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Bus_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<Bus_Full<'bldr>> {
    let mut builder = Bus_FullBuilder::new(_fbb);
    builder.add_launchEnvelopeDimensionZ(args.launchEnvelopeDimensionZ);
    builder.add_launchEnvelopeDimensionY(args.launchEnvelopeDimensionY);
    builder.add_launchEnvelopeDimensionX(args.launchEnvelopeDimensionX);
    builder.add_payloadVolume(args.payloadVolume);
    builder.add_payloadDimensionZ(args.payloadDimensionZ);
    builder.add_payloadDimensionY(args.payloadDimensionY);
    builder.add_payloadDimensionX(args.payloadDimensionX);
    builder.add_bodyDimensionZ(args.bodyDimensionZ);
    builder.add_bodyDimensionY(args.bodyDimensionY);
    builder.add_bodyDimensionX(args.bodyDimensionX);
    builder.add_oapPayloadPower(args.oapPayloadPower);
    builder.add_maxPayloadPower(args.maxPayloadPower);
    builder.add_avgPayloadPower(args.avgPayloadPower);
    builder.add_oapSpacecraftPower(args.oapSpacecraftPower);
    builder.add_maxSpacecraftPower(args.maxSpacecraftPower);
    builder.add_avgSpacecraftPower(args.avgSpacecraftPower);
    builder.add_maxEOLPowerUpper(args.maxEOLPowerUpper);
    builder.add_maxEOLPowerLower(args.maxEOLPowerLower);
    builder.add_maxBOLPowerUpper(args.maxBOLPowerUpper);
    builder.add_maxBOLPowerLower(args.maxBOLPowerLower);
    builder.add_maxWetMass(args.maxWetMass);
    builder.add_medianWetMass(args.medianWetMass);
    builder.add_avgWetMass(args.avgWetMass);
    builder.add_minWetMass(args.minWetMass);
    builder.add_maxDryMass(args.maxDryMass);
    builder.add_medianDryMass(args.medianDryMass);
    builder.add_avgDryMass(args.avgDryMass);
    builder.add_minDryMass(args.minDryMass);
    builder.add_maxPayloadMass(args.maxPayloadMass);
    builder.add_avgPayloadMass(args.avgPayloadMass);
    builder.add_maxBOLStationMass(args.maxBOLStationMass);
    builder.add_maxLaunchMassUpper(args.maxLaunchMassUpper);
    builder.add_maxLaunchMassLower(args.maxLaunchMassLower);
    if let Some(x) = args.entity { builder.add_entity(x); }
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.aocsNotes { builder.add_aocsNotes(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.powerCategory { builder.add_powerCategory(x); }
    if let Some(x) = args.massCategory { builder.add_massCategory(x); }
    if let Some(x) = args.countryCode { builder.add_countryCode(x); }
    if let Some(x) = args.busKitDesignerOrgId { builder.add_busKitDesignerOrgId(x); }
    if let Some(x) = args.manufacturerOrgId { builder.add_manufacturerOrgId(x); }
    if let Some(x) = args.mainComputerManufacturerOrgId { builder.add_mainComputerManufacturerOrgId(x); }
    if let Some(x) = args.telemetryTrackingManufacturerOrgId { builder.add_telemetryTrackingManufacturerOrgId(x); }
    if let Some(x) = args.orbitTypes { builder.add_orbitTypes(x); }
    builder.add_numOrbitType(args.numOrbitType);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.idEntity { builder.add_idEntity(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_generic(args.generic);
    builder.finish()
  }

  pub fn unpack(&self) -> Bus_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let name = self.name().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idEntity = self.idEntity().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let maxLaunchMassLower = self.maxLaunchMassLower();
    let maxLaunchMassUpper = self.maxLaunchMassUpper();
    let maxBOLStationMass = self.maxBOLStationMass();
    let avgPayloadMass = self.avgPayloadMass();
    let maxPayloadMass = self.maxPayloadMass();
    let minDryMass = self.minDryMass();
    let avgDryMass = self.avgDryMass();
    let medianDryMass = self.medianDryMass();
    let maxDryMass = self.maxDryMass();
    let minWetMass = self.minWetMass();
    let avgWetMass = self.avgWetMass();
    let medianWetMass = self.medianWetMass();
    let maxWetMass = self.maxWetMass();
    let maxBOLPowerLower = self.maxBOLPowerLower();
    let maxBOLPowerUpper = self.maxBOLPowerUpper();
    let maxEOLPowerLower = self.maxEOLPowerLower();
    let maxEOLPowerUpper = self.maxEOLPowerUpper();
    let avgSpacecraftPower = self.avgSpacecraftPower();
    let maxSpacecraftPower = self.maxSpacecraftPower();
    let oapSpacecraftPower = self.oapSpacecraftPower();
    let avgPayloadPower = self.avgPayloadPower();
    let maxPayloadPower = self.maxPayloadPower();
    let oapPayloadPower = self.oapPayloadPower();
    let bodyDimensionX = self.bodyDimensionX();
    let bodyDimensionY = self.bodyDimensionY();
    let bodyDimensionZ = self.bodyDimensionZ();
    let payloadDimensionX = self.payloadDimensionX();
    let payloadDimensionY = self.payloadDimensionY();
    let payloadDimensionZ = self.payloadDimensionZ();
    let payloadVolume = self.payloadVolume();
    let launchEnvelopeDimensionX = self.launchEnvelopeDimensionX();
    let launchEnvelopeDimensionY = self.launchEnvelopeDimensionY();
    let launchEnvelopeDimensionZ = self.launchEnvelopeDimensionZ();
    let numOrbitType = self.numOrbitType();
    let orbitTypes = self.orbitTypes().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let telemetryTrackingManufacturerOrgId = self.telemetryTrackingManufacturerOrgId().map(|x| {
      x.to_string()
    });
    let mainComputerManufacturerOrgId = self.mainComputerManufacturerOrgId().map(|x| {
      x.to_string()
    });
    let manufacturerOrgId = self.manufacturerOrgId().map(|x| {
      x.to_string()
    });
    let busKitDesignerOrgId = self.busKitDesignerOrgId().map(|x| {
      x.to_string()
    });
    let countryCode = self.countryCode().map(|x| {
      x.to_string()
    });
    let massCategory = self.massCategory().map(|x| {
      x.to_string()
    });
    let powerCategory = self.powerCategory().map(|x| {
      x.to_string()
    });
    let generic = self.generic();
    let description = self.description().map(|x| {
      x.to_string()
    });
    let aocsNotes = self.aocsNotes().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    let entity = self.entity().map(|x| {
      x.to_string()
    });
    Bus_FullT {
      id,
      name,
      classificationMarking,
      idEntity,
      type_,
      maxLaunchMassLower,
      maxLaunchMassUpper,
      maxBOLStationMass,
      avgPayloadMass,
      maxPayloadMass,
      minDryMass,
      avgDryMass,
      medianDryMass,
      maxDryMass,
      minWetMass,
      avgWetMass,
      medianWetMass,
      maxWetMass,
      maxBOLPowerLower,
      maxBOLPowerUpper,
      maxEOLPowerLower,
      maxEOLPowerUpper,
      avgSpacecraftPower,
      maxSpacecraftPower,
      oapSpacecraftPower,
      avgPayloadPower,
      maxPayloadPower,
      oapPayloadPower,
      bodyDimensionX,
      bodyDimensionY,
      bodyDimensionZ,
      payloadDimensionX,
      payloadDimensionY,
      payloadDimensionZ,
      payloadVolume,
      launchEnvelopeDimensionX,
      launchEnvelopeDimensionY,
      launchEnvelopeDimensionZ,
      numOrbitType,
      orbitTypes,
      telemetryTrackingManufacturerOrgId,
      mainComputerManufacturerOrgId,
      manufacturerOrgId,
      busKitDesignerOrgId,
      countryCode,
      massCategory,
      powerCategory,
      generic,
      description,
      aocsNotes,
      source,
      origin,
      origNetwork,
      dataMode,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      entity,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: BUS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_ID, None)}
  }
  /// Name of this bus.
  /// Example: /// Example: Example name
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_NAME, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// ID of the parent entity for this bus.
  /// Example: /// Example: 0167f577-e06c-358e-85aa-0a07a730bdd0
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idEntity(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_IDENTITY, None)}
  }
  /// Type of this bus.
  /// Example: /// Example: Example type
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_TYPE_, None)}
  }
  /// Maximum mass at launch, lower bounds, in kilograms.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxLaunchMassLower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXLAUNCHMASSLOWER, Some(0.0)).unwrap()}
  }
  /// Maximum mass at launch, upper bounds, in kilograms.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxLaunchMassUpper(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXLAUNCHMASSUPPER, Some(0.0)).unwrap()}
  }
  /// Maximum mass on station at beginning of life, in kilograms.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxBOLStationMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXBOLSTATIONMASS, Some(0.0)).unwrap()}
  }
  /// Average mass available on this bus for payloads, in kilograms.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn avgPayloadMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_AVGPAYLOADMASS, Some(0.0)).unwrap()}
  }
  /// Maximum payload mass available, in kilograms.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxPayloadMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXPAYLOADMASS, Some(0.0)).unwrap()}
  }
  /// Minimum mass of this bus without payloads or fuel, in kilograms.
  /// Example: /// Example: 2858.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn minDryMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MINDRYMASS, Some(0.0)).unwrap()}
  }
  /// Average mass of this bus without payloads or fuel, in kilograms.
  /// Example: /// Example: 2879.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn avgDryMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_AVGDRYMASS, Some(0.0)).unwrap()}
  }
  /// Median mass of this bus without payloads or fuel, in kilograms.
  /// Example: /// Example: 2950.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn medianDryMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MEDIANDRYMASS, Some(0.0)).unwrap()}
  }
  /// Maximum mass of this bus without payloads or fuel, in kilograms.
  /// Example: /// Example: 2900.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxDryMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXDRYMASS, Some(0.0)).unwrap()}
  }
  /// Minimum mass of this bus with fuel, but without payloads, in kilograms.
  /// Example: /// Example: 5192.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn minWetMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MINWETMASS, Some(0.0)).unwrap()}
  }
  /// Average mass of this bus with fuel, but without payloads, in kilograms.
  /// Example: /// Example: 5246.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn avgWetMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_AVGWETMASS, Some(0.0)).unwrap()}
  }
  /// Median mass of this bus with fuel, but without payloads, in kilograms.
  /// Example: /// Example: 5260.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn medianWetMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MEDIANWETMASS, Some(0.0)).unwrap()}
  }
  /// Maximum mass of this bus with fuel, but without payloads, in kilograms.
  /// Example: /// Example: 5300.0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxWetMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXWETMASS, Some(0.0)).unwrap()}
  }
  /// Maximum power at beginning of life, lower bounds, in kilowatts.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxBOLPowerLower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXBOLPOWERLOWER, Some(0.0)).unwrap()}
  }
  /// Maximum power at beginning of life, upper bounds, in kilowatts.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxBOLPowerUpper(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXBOLPOWERUPPER, Some(0.0)).unwrap()}
  }
  /// Maximum power at end of life, lower bounds, in kilowatts.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxEOLPowerLower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXEOLPOWERLOWER, Some(0.0)).unwrap()}
  }
  /// Maximum power at end of life, upper bounds, in kilowatts.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxEOLPowerUpper(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXEOLPOWERUPPER, Some(0.0)).unwrap()}
  }
  /// Average power available on this bus, in kilowatts.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn avgSpacecraftPower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_AVGSPACECRAFTPOWER, Some(0.0)).unwrap()}
  }
  /// Maximum power available on this bus, in kilowatts.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxSpacecraftPower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXSPACECRAFTPOWER, Some(0.0)).unwrap()}
  }
  /// Orbit averaged power (the power averaged over one orbit) available on this bus, in kilowatts.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn oapSpacecraftPower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_OAPSPACECRAFTPOWER, Some(0.0)).unwrap()}
  }
  /// Average power available on this bus for payloads, in kilowatts.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn avgPayloadPower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_AVGPAYLOADPOWER, Some(0.0)).unwrap()}
  }
  /// Maximum payload power available, in kilowatts.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxPayloadPower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_MAXPAYLOADPOWER, Some(0.0)).unwrap()}
  }
  /// Orbit averaged power (the power averaged over one orbit) available on this bus for payloads, in kilowatts.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn oapPayloadPower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_OAPPAYLOADPOWER, Some(0.0)).unwrap()}
  }
  /// Body dimension in X direction pertaining to length, in meters.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bodyDimensionX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_BODYDIMENSIONX, Some(0.0)).unwrap()}
  }
  /// Body dimension in Y direction pertaining to height, in meters.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bodyDimensionY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_BODYDIMENSIONY, Some(0.0)).unwrap()}
  }
  /// Body dimension in Z direction pertaining to width, in meters.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bodyDimensionZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_BODYDIMENSIONZ, Some(0.0)).unwrap()}
  }
  /// The radial dimension available on this bus for payloads, in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn payloadDimensionX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_PAYLOADDIMENSIONX, Some(0.0)).unwrap()}
  }
  /// The in-track dimension available on this bus for payloads, in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn payloadDimensionY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_PAYLOADDIMENSIONY, Some(0.0)).unwrap()}
  }
  /// The cross-track dimension available on this bus for payloads, in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn payloadDimensionZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_PAYLOADDIMENSIONZ, Some(0.0)).unwrap()}
  }
  /// The volume available on this bus for payloads, in cubic meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn payloadVolume(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_PAYLOADVOLUME, Some(0.0)).unwrap()}
  }
  /// Launch envelope dimension in X direction, in meters.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchEnvelopeDimensionX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_LAUNCHENVELOPEDIMENSIONX, Some(0.0)).unwrap()}
  }
  /// Launch envelope dimension in Y direction, in meters.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchEnvelopeDimensionY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_LAUNCHENVELOPEDIMENSIONY, Some(0.0)).unwrap()}
  }
  /// Launch envelope dimension in Z direction, in meters.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchEnvelopeDimensionZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Bus_Full::VT_LAUNCHENVELOPEDIMENSIONZ, Some(0.0)).unwrap()}
  }
  /// The number of orbit types this bus can support.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numOrbitType(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Bus_Full::VT_NUMORBITTYPE, Some(0)).unwrap()}
  }
  /// Array of orbit types this bus can support (e.g. GEO, LEO, etc.). Must contain the same number of elements as the value of numOrbitType.
  /// Example: /// Example: ['LEO', 'HEO', 'GEO']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn orbitTypes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Bus_Full::VT_ORBITTYPES, None)}
  }
  /// Unique identifier of the organization which manufactures the telemetry tracking and command subsystem for this bus.
  /// Example: /// Example: TELEMETRYTRACKINGMANUFACTURERORG-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn telemetryTrackingManufacturerOrgId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_TELEMETRYTRACKINGMANUFACTURERORGID, None)}
  }
  /// Unique identifier of the organization which manufactures the main onboard computer for this bus.
  /// Example: /// Example: MAINCOMPUTERMANUFACTURERORG-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn mainComputerManufacturerOrgId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_MAINCOMPUTERMANUFACTURERORGID, None)}
  }
  /// Unique identifier of the organization which manufactures this bus.
  /// Example: /// Example: MANUFACTURERORG-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn manufacturerOrgId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_MANUFACTURERORGID, None)}
  }
  /// Unique identifier of the organization which designs the bus kit.
  /// Example: /// Example: BUSKITDESIGNERORG-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn busKitDesignerOrgId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_BUSKITDESIGNERORGID, None)}
  }
  /// Country where this bus was manufactured. This value is typically the ISO 3166 Alpha-2 two-character country code, however it can also represent various consortiums that do not appear in the ISO document. The code must correspond to an existing country in the UDLâ€™s country API. Call udl/country/{code} to get any associated FIPS code, ISO Alpha-3 code, or alternate code values that exist for the specified country code.
  /// Example: /// Example: US
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn countryCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_COUNTRYCODE, None)}
  }
  /// Mass category of this bus (e.g. 1 - 10 kg: Nanosatellite, 10 - 100 kg: Microsatellite, 100 - 500 kg: Minisatellite, 1000 - 2500kg: Medium satellite, etc.).
  /// Example: /// Example: Nanosatellite
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn massCategory(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_MASSCATEGORY, None)}
  }
  /// Power category of this bus (e.g. 0-1kW low power, etc).
  /// Example: /// Example: low power
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn powerCategory(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_POWERCATEGORY, None)}
  }
  /// Boolean indicating if this bus is generic.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn generic(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Bus_Full::VT_GENERIC, Some(false)).unwrap()}
  }
  /// Notes/description of the bus.
  /// Example: /// Example: Dedicated small spacecraft bus.
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_DESCRIPTION, None)}
  }
  /// Attitude and Orbital Control Notes/description for the bus.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn aocsNotes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_AOCSNOTES, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> Bus_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bus_Full_dataMode_Enum>(Bus_Full::VT_DATAMODE, Some(Bus_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_CREATEDBY, None)}
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_UPDATEDBY, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn entity(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Bus_Full::VT_ENTITY, None)}
  }
}

impl flatbuffers::Verifiable for Bus_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idEntity", Self::VT_IDENTITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<f64>("maxLaunchMassLower", Self::VT_MAXLAUNCHMASSLOWER, false)?
     .visit_field::<f64>("maxLaunchMassUpper", Self::VT_MAXLAUNCHMASSUPPER, false)?
     .visit_field::<f64>("maxBOLStationMass", Self::VT_MAXBOLSTATIONMASS, false)?
     .visit_field::<f64>("avgPayloadMass", Self::VT_AVGPAYLOADMASS, false)?
     .visit_field::<f64>("maxPayloadMass", Self::VT_MAXPAYLOADMASS, false)?
     .visit_field::<f64>("minDryMass", Self::VT_MINDRYMASS, false)?
     .visit_field::<f64>("avgDryMass", Self::VT_AVGDRYMASS, false)?
     .visit_field::<f64>("medianDryMass", Self::VT_MEDIANDRYMASS, false)?
     .visit_field::<f64>("maxDryMass", Self::VT_MAXDRYMASS, false)?
     .visit_field::<f64>("minWetMass", Self::VT_MINWETMASS, false)?
     .visit_field::<f64>("avgWetMass", Self::VT_AVGWETMASS, false)?
     .visit_field::<f64>("medianWetMass", Self::VT_MEDIANWETMASS, false)?
     .visit_field::<f64>("maxWetMass", Self::VT_MAXWETMASS, false)?
     .visit_field::<f64>("maxBOLPowerLower", Self::VT_MAXBOLPOWERLOWER, false)?
     .visit_field::<f64>("maxBOLPowerUpper", Self::VT_MAXBOLPOWERUPPER, false)?
     .visit_field::<f64>("maxEOLPowerLower", Self::VT_MAXEOLPOWERLOWER, false)?
     .visit_field::<f64>("maxEOLPowerUpper", Self::VT_MAXEOLPOWERUPPER, false)?
     .visit_field::<f64>("avgSpacecraftPower", Self::VT_AVGSPACECRAFTPOWER, false)?
     .visit_field::<f64>("maxSpacecraftPower", Self::VT_MAXSPACECRAFTPOWER, false)?
     .visit_field::<f64>("oapSpacecraftPower", Self::VT_OAPSPACECRAFTPOWER, false)?
     .visit_field::<f64>("avgPayloadPower", Self::VT_AVGPAYLOADPOWER, false)?
     .visit_field::<f64>("maxPayloadPower", Self::VT_MAXPAYLOADPOWER, false)?
     .visit_field::<f64>("oapPayloadPower", Self::VT_OAPPAYLOADPOWER, false)?
     .visit_field::<f64>("bodyDimensionX", Self::VT_BODYDIMENSIONX, false)?
     .visit_field::<f64>("bodyDimensionY", Self::VT_BODYDIMENSIONY, false)?
     .visit_field::<f64>("bodyDimensionZ", Self::VT_BODYDIMENSIONZ, false)?
     .visit_field::<f64>("payloadDimensionX", Self::VT_PAYLOADDIMENSIONX, false)?
     .visit_field::<f64>("payloadDimensionY", Self::VT_PAYLOADDIMENSIONY, false)?
     .visit_field::<f64>("payloadDimensionZ", Self::VT_PAYLOADDIMENSIONZ, false)?
     .visit_field::<f64>("payloadVolume", Self::VT_PAYLOADVOLUME, false)?
     .visit_field::<f64>("launchEnvelopeDimensionX", Self::VT_LAUNCHENVELOPEDIMENSIONX, false)?
     .visit_field::<f64>("launchEnvelopeDimensionY", Self::VT_LAUNCHENVELOPEDIMENSIONY, false)?
     .visit_field::<f64>("launchEnvelopeDimensionZ", Self::VT_LAUNCHENVELOPEDIMENSIONZ, false)?
     .visit_field::<i32>("numOrbitType", Self::VT_NUMORBITTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("orbitTypes", Self::VT_ORBITTYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("telemetryTrackingManufacturerOrgId", Self::VT_TELEMETRYTRACKINGMANUFACTURERORGID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mainComputerManufacturerOrgId", Self::VT_MAINCOMPUTERMANUFACTURERORGID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("manufacturerOrgId", Self::VT_MANUFACTURERORGID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("busKitDesignerOrgId", Self::VT_BUSKITDESIGNERORGID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("countryCode", Self::VT_COUNTRYCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("massCategory", Self::VT_MASSCATEGORY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("powerCategory", Self::VT_POWERCATEGORY, false)?
     .visit_field::<bool>("generic", Self::VT_GENERIC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("aocsNotes", Self::VT_AOCSNOTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<Bus_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("entity", Self::VT_ENTITY, false)?
     .finish();
    Ok(())
  }
}
pub struct Bus_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idEntity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maxLaunchMassLower: f64,
    pub maxLaunchMassUpper: f64,
    pub maxBOLStationMass: f64,
    pub avgPayloadMass: f64,
    pub maxPayloadMass: f64,
    pub minDryMass: f64,
    pub avgDryMass: f64,
    pub medianDryMass: f64,
    pub maxDryMass: f64,
    pub minWetMass: f64,
    pub avgWetMass: f64,
    pub medianWetMass: f64,
    pub maxWetMass: f64,
    pub maxBOLPowerLower: f64,
    pub maxBOLPowerUpper: f64,
    pub maxEOLPowerLower: f64,
    pub maxEOLPowerUpper: f64,
    pub avgSpacecraftPower: f64,
    pub maxSpacecraftPower: f64,
    pub oapSpacecraftPower: f64,
    pub avgPayloadPower: f64,
    pub maxPayloadPower: f64,
    pub oapPayloadPower: f64,
    pub bodyDimensionX: f64,
    pub bodyDimensionY: f64,
    pub bodyDimensionZ: f64,
    pub payloadDimensionX: f64,
    pub payloadDimensionY: f64,
    pub payloadDimensionZ: f64,
    pub payloadVolume: f64,
    pub launchEnvelopeDimensionX: f64,
    pub launchEnvelopeDimensionY: f64,
    pub launchEnvelopeDimensionZ: f64,
    pub numOrbitType: i32,
    pub orbitTypes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub telemetryTrackingManufacturerOrgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mainComputerManufacturerOrgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub manufacturerOrgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub busKitDesignerOrgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub countryCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub massCategory: Option<flatbuffers::WIPOffset<&'a str>>,
    pub powerCategory: Option<flatbuffers::WIPOffset<&'a str>>,
    pub generic: bool,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub aocsNotes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: Bus_Full_dataMode_Enum,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub entity: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Bus_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    Bus_FullArgs {
      id: None,
      name: None,
      classificationMarking: None,
      idEntity: None,
      type_: None,
      maxLaunchMassLower: 0.0,
      maxLaunchMassUpper: 0.0,
      maxBOLStationMass: 0.0,
      avgPayloadMass: 0.0,
      maxPayloadMass: 0.0,
      minDryMass: 0.0,
      avgDryMass: 0.0,
      medianDryMass: 0.0,
      maxDryMass: 0.0,
      minWetMass: 0.0,
      avgWetMass: 0.0,
      medianWetMass: 0.0,
      maxWetMass: 0.0,
      maxBOLPowerLower: 0.0,
      maxBOLPowerUpper: 0.0,
      maxEOLPowerLower: 0.0,
      maxEOLPowerUpper: 0.0,
      avgSpacecraftPower: 0.0,
      maxSpacecraftPower: 0.0,
      oapSpacecraftPower: 0.0,
      avgPayloadPower: 0.0,
      maxPayloadPower: 0.0,
      oapPayloadPower: 0.0,
      bodyDimensionX: 0.0,
      bodyDimensionY: 0.0,
      bodyDimensionZ: 0.0,
      payloadDimensionX: 0.0,
      payloadDimensionY: 0.0,
      payloadDimensionZ: 0.0,
      payloadVolume: 0.0,
      launchEnvelopeDimensionX: 0.0,
      launchEnvelopeDimensionY: 0.0,
      launchEnvelopeDimensionZ: 0.0,
      numOrbitType: 0,
      orbitTypes: None,
      telemetryTrackingManufacturerOrgId: None,
      mainComputerManufacturerOrgId: None,
      manufacturerOrgId: None,
      busKitDesignerOrgId: None,
      countryCode: None,
      massCategory: None,
      powerCategory: None,
      generic: false,
      description: None,
      aocsNotes: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: Bus_Full_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      entity: None,
    }
  }
}

pub struct Bus_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Bus_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_NAME, name);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idEntity(&mut self, idEntity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_IDENTITY, idEntity);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_maxLaunchMassLower(&mut self, maxLaunchMassLower: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXLAUNCHMASSLOWER, maxLaunchMassLower, 0.0);
  }
  #[inline]
  pub fn add_maxLaunchMassUpper(&mut self, maxLaunchMassUpper: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXLAUNCHMASSUPPER, maxLaunchMassUpper, 0.0);
  }
  #[inline]
  pub fn add_maxBOLStationMass(&mut self, maxBOLStationMass: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXBOLSTATIONMASS, maxBOLStationMass, 0.0);
  }
  #[inline]
  pub fn add_avgPayloadMass(&mut self, avgPayloadMass: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_AVGPAYLOADMASS, avgPayloadMass, 0.0);
  }
  #[inline]
  pub fn add_maxPayloadMass(&mut self, maxPayloadMass: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXPAYLOADMASS, maxPayloadMass, 0.0);
  }
  #[inline]
  pub fn add_minDryMass(&mut self, minDryMass: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MINDRYMASS, minDryMass, 0.0);
  }
  #[inline]
  pub fn add_avgDryMass(&mut self, avgDryMass: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_AVGDRYMASS, avgDryMass, 0.0);
  }
  #[inline]
  pub fn add_medianDryMass(&mut self, medianDryMass: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MEDIANDRYMASS, medianDryMass, 0.0);
  }
  #[inline]
  pub fn add_maxDryMass(&mut self, maxDryMass: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXDRYMASS, maxDryMass, 0.0);
  }
  #[inline]
  pub fn add_minWetMass(&mut self, minWetMass: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MINWETMASS, minWetMass, 0.0);
  }
  #[inline]
  pub fn add_avgWetMass(&mut self, avgWetMass: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_AVGWETMASS, avgWetMass, 0.0);
  }
  #[inline]
  pub fn add_medianWetMass(&mut self, medianWetMass: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MEDIANWETMASS, medianWetMass, 0.0);
  }
  #[inline]
  pub fn add_maxWetMass(&mut self, maxWetMass: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXWETMASS, maxWetMass, 0.0);
  }
  #[inline]
  pub fn add_maxBOLPowerLower(&mut self, maxBOLPowerLower: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXBOLPOWERLOWER, maxBOLPowerLower, 0.0);
  }
  #[inline]
  pub fn add_maxBOLPowerUpper(&mut self, maxBOLPowerUpper: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXBOLPOWERUPPER, maxBOLPowerUpper, 0.0);
  }
  #[inline]
  pub fn add_maxEOLPowerLower(&mut self, maxEOLPowerLower: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXEOLPOWERLOWER, maxEOLPowerLower, 0.0);
  }
  #[inline]
  pub fn add_maxEOLPowerUpper(&mut self, maxEOLPowerUpper: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXEOLPOWERUPPER, maxEOLPowerUpper, 0.0);
  }
  #[inline]
  pub fn add_avgSpacecraftPower(&mut self, avgSpacecraftPower: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_AVGSPACECRAFTPOWER, avgSpacecraftPower, 0.0);
  }
  #[inline]
  pub fn add_maxSpacecraftPower(&mut self, maxSpacecraftPower: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXSPACECRAFTPOWER, maxSpacecraftPower, 0.0);
  }
  #[inline]
  pub fn add_oapSpacecraftPower(&mut self, oapSpacecraftPower: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_OAPSPACECRAFTPOWER, oapSpacecraftPower, 0.0);
  }
  #[inline]
  pub fn add_avgPayloadPower(&mut self, avgPayloadPower: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_AVGPAYLOADPOWER, avgPayloadPower, 0.0);
  }
  #[inline]
  pub fn add_maxPayloadPower(&mut self, maxPayloadPower: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_MAXPAYLOADPOWER, maxPayloadPower, 0.0);
  }
  #[inline]
  pub fn add_oapPayloadPower(&mut self, oapPayloadPower: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_OAPPAYLOADPOWER, oapPayloadPower, 0.0);
  }
  #[inline]
  pub fn add_bodyDimensionX(&mut self, bodyDimensionX: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_BODYDIMENSIONX, bodyDimensionX, 0.0);
  }
  #[inline]
  pub fn add_bodyDimensionY(&mut self, bodyDimensionY: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_BODYDIMENSIONY, bodyDimensionY, 0.0);
  }
  #[inline]
  pub fn add_bodyDimensionZ(&mut self, bodyDimensionZ: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_BODYDIMENSIONZ, bodyDimensionZ, 0.0);
  }
  #[inline]
  pub fn add_payloadDimensionX(&mut self, payloadDimensionX: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_PAYLOADDIMENSIONX, payloadDimensionX, 0.0);
  }
  #[inline]
  pub fn add_payloadDimensionY(&mut self, payloadDimensionY: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_PAYLOADDIMENSIONY, payloadDimensionY, 0.0);
  }
  #[inline]
  pub fn add_payloadDimensionZ(&mut self, payloadDimensionZ: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_PAYLOADDIMENSIONZ, payloadDimensionZ, 0.0);
  }
  #[inline]
  pub fn add_payloadVolume(&mut self, payloadVolume: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_PAYLOADVOLUME, payloadVolume, 0.0);
  }
  #[inline]
  pub fn add_launchEnvelopeDimensionX(&mut self, launchEnvelopeDimensionX: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_LAUNCHENVELOPEDIMENSIONX, launchEnvelopeDimensionX, 0.0);
  }
  #[inline]
  pub fn add_launchEnvelopeDimensionY(&mut self, launchEnvelopeDimensionY: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_LAUNCHENVELOPEDIMENSIONY, launchEnvelopeDimensionY, 0.0);
  }
  #[inline]
  pub fn add_launchEnvelopeDimensionZ(&mut self, launchEnvelopeDimensionZ: f64) {
    self.fbb_.push_slot::<f64>(Bus_Full::VT_LAUNCHENVELOPEDIMENSIONZ, launchEnvelopeDimensionZ, 0.0);
  }
  #[inline]
  pub fn add_numOrbitType(&mut self, numOrbitType: i32) {
    self.fbb_.push_slot::<i32>(Bus_Full::VT_NUMORBITTYPE, numOrbitType, 0);
  }
  #[inline]
  pub fn add_orbitTypes(&mut self, orbitTypes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_ORBITTYPES, orbitTypes);
  }
  #[inline]
  pub fn add_telemetryTrackingManufacturerOrgId(&mut self, telemetryTrackingManufacturerOrgId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_TELEMETRYTRACKINGMANUFACTURERORGID, telemetryTrackingManufacturerOrgId);
  }
  #[inline]
  pub fn add_mainComputerManufacturerOrgId(&mut self, mainComputerManufacturerOrgId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_MAINCOMPUTERMANUFACTURERORGID, mainComputerManufacturerOrgId);
  }
  #[inline]
  pub fn add_manufacturerOrgId(&mut self, manufacturerOrgId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_MANUFACTURERORGID, manufacturerOrgId);
  }
  #[inline]
  pub fn add_busKitDesignerOrgId(&mut self, busKitDesignerOrgId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_BUSKITDESIGNERORGID, busKitDesignerOrgId);
  }
  #[inline]
  pub fn add_countryCode(&mut self, countryCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_COUNTRYCODE, countryCode);
  }
  #[inline]
  pub fn add_massCategory(&mut self, massCategory: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_MASSCATEGORY, massCategory);
  }
  #[inline]
  pub fn add_powerCategory(&mut self, powerCategory: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_POWERCATEGORY, powerCategory);
  }
  #[inline]
  pub fn add_generic(&mut self, generic: bool) {
    self.fbb_.push_slot::<bool>(Bus_Full::VT_GENERIC, generic, false);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_aocsNotes(&mut self, aocsNotes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_AOCSNOTES, aocsNotes);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Bus_Full_dataMode_Enum) {
    self.fbb_.push_slot::<Bus_Full_dataMode_Enum>(Bus_Full::VT_DATAMODE, dataMode, Bus_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn add_entity(&mut self, entity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bus_Full::VT_ENTITY, entity);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Bus_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Bus_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Bus_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Bus_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Bus_Full");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idEntity", &self.idEntity());
      ds.field("type_", &self.type_());
      ds.field("maxLaunchMassLower", &self.maxLaunchMassLower());
      ds.field("maxLaunchMassUpper", &self.maxLaunchMassUpper());
      ds.field("maxBOLStationMass", &self.maxBOLStationMass());
      ds.field("avgPayloadMass", &self.avgPayloadMass());
      ds.field("maxPayloadMass", &self.maxPayloadMass());
      ds.field("minDryMass", &self.minDryMass());
      ds.field("avgDryMass", &self.avgDryMass());
      ds.field("medianDryMass", &self.medianDryMass());
      ds.field("maxDryMass", &self.maxDryMass());
      ds.field("minWetMass", &self.minWetMass());
      ds.field("avgWetMass", &self.avgWetMass());
      ds.field("medianWetMass", &self.medianWetMass());
      ds.field("maxWetMass", &self.maxWetMass());
      ds.field("maxBOLPowerLower", &self.maxBOLPowerLower());
      ds.field("maxBOLPowerUpper", &self.maxBOLPowerUpper());
      ds.field("maxEOLPowerLower", &self.maxEOLPowerLower());
      ds.field("maxEOLPowerUpper", &self.maxEOLPowerUpper());
      ds.field("avgSpacecraftPower", &self.avgSpacecraftPower());
      ds.field("maxSpacecraftPower", &self.maxSpacecraftPower());
      ds.field("oapSpacecraftPower", &self.oapSpacecraftPower());
      ds.field("avgPayloadPower", &self.avgPayloadPower());
      ds.field("maxPayloadPower", &self.maxPayloadPower());
      ds.field("oapPayloadPower", &self.oapPayloadPower());
      ds.field("bodyDimensionX", &self.bodyDimensionX());
      ds.field("bodyDimensionY", &self.bodyDimensionY());
      ds.field("bodyDimensionZ", &self.bodyDimensionZ());
      ds.field("payloadDimensionX", &self.payloadDimensionX());
      ds.field("payloadDimensionY", &self.payloadDimensionY());
      ds.field("payloadDimensionZ", &self.payloadDimensionZ());
      ds.field("payloadVolume", &self.payloadVolume());
      ds.field("launchEnvelopeDimensionX", &self.launchEnvelopeDimensionX());
      ds.field("launchEnvelopeDimensionY", &self.launchEnvelopeDimensionY());
      ds.field("launchEnvelopeDimensionZ", &self.launchEnvelopeDimensionZ());
      ds.field("numOrbitType", &self.numOrbitType());
      ds.field("orbitTypes", &self.orbitTypes());
      ds.field("telemetryTrackingManufacturerOrgId", &self.telemetryTrackingManufacturerOrgId());
      ds.field("mainComputerManufacturerOrgId", &self.mainComputerManufacturerOrgId());
      ds.field("manufacturerOrgId", &self.manufacturerOrgId());
      ds.field("busKitDesignerOrgId", &self.busKitDesignerOrgId());
      ds.field("countryCode", &self.countryCode());
      ds.field("massCategory", &self.massCategory());
      ds.field("powerCategory", &self.powerCategory());
      ds.field("generic", &self.generic());
      ds.field("description", &self.description());
      ds.field("aocsNotes", &self.aocsNotes());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.field("entity", &self.entity());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Bus_FullT {
  pub id: Option<String>,
  pub name: Option<String>,
  pub classificationMarking: Option<String>,
  pub idEntity: Option<String>,
  pub type_: Option<String>,
  pub maxLaunchMassLower: f64,
  pub maxLaunchMassUpper: f64,
  pub maxBOLStationMass: f64,
  pub avgPayloadMass: f64,
  pub maxPayloadMass: f64,
  pub minDryMass: f64,
  pub avgDryMass: f64,
  pub medianDryMass: f64,
  pub maxDryMass: f64,
  pub minWetMass: f64,
  pub avgWetMass: f64,
  pub medianWetMass: f64,
  pub maxWetMass: f64,
  pub maxBOLPowerLower: f64,
  pub maxBOLPowerUpper: f64,
  pub maxEOLPowerLower: f64,
  pub maxEOLPowerUpper: f64,
  pub avgSpacecraftPower: f64,
  pub maxSpacecraftPower: f64,
  pub oapSpacecraftPower: f64,
  pub avgPayloadPower: f64,
  pub maxPayloadPower: f64,
  pub oapPayloadPower: f64,
  pub bodyDimensionX: f64,
  pub bodyDimensionY: f64,
  pub bodyDimensionZ: f64,
  pub payloadDimensionX: f64,
  pub payloadDimensionY: f64,
  pub payloadDimensionZ: f64,
  pub payloadVolume: f64,
  pub launchEnvelopeDimensionX: f64,
  pub launchEnvelopeDimensionY: f64,
  pub launchEnvelopeDimensionZ: f64,
  pub numOrbitType: i32,
  pub orbitTypes: Option<Vec<String>>,
  pub telemetryTrackingManufacturerOrgId: Option<String>,
  pub mainComputerManufacturerOrgId: Option<String>,
  pub manufacturerOrgId: Option<String>,
  pub busKitDesignerOrgId: Option<String>,
  pub countryCode: Option<String>,
  pub massCategory: Option<String>,
  pub powerCategory: Option<String>,
  pub generic: bool,
  pub description: Option<String>,
  pub aocsNotes: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: Bus_Full_dataMode_Enum,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
  pub entity: Option<String>,
}
impl Default for Bus_FullT {
  fn default() -> Self {
    Self {
      id: None,
      name: None,
      classificationMarking: None,
      idEntity: None,
      type_: None,
      maxLaunchMassLower: 0.0,
      maxLaunchMassUpper: 0.0,
      maxBOLStationMass: 0.0,
      avgPayloadMass: 0.0,
      maxPayloadMass: 0.0,
      minDryMass: 0.0,
      avgDryMass: 0.0,
      medianDryMass: 0.0,
      maxDryMass: 0.0,
      minWetMass: 0.0,
      avgWetMass: 0.0,
      medianWetMass: 0.0,
      maxWetMass: 0.0,
      maxBOLPowerLower: 0.0,
      maxBOLPowerUpper: 0.0,
      maxEOLPowerLower: 0.0,
      maxEOLPowerUpper: 0.0,
      avgSpacecraftPower: 0.0,
      maxSpacecraftPower: 0.0,
      oapSpacecraftPower: 0.0,
      avgPayloadPower: 0.0,
      maxPayloadPower: 0.0,
      oapPayloadPower: 0.0,
      bodyDimensionX: 0.0,
      bodyDimensionY: 0.0,
      bodyDimensionZ: 0.0,
      payloadDimensionX: 0.0,
      payloadDimensionY: 0.0,
      payloadDimensionZ: 0.0,
      payloadVolume: 0.0,
      launchEnvelopeDimensionX: 0.0,
      launchEnvelopeDimensionY: 0.0,
      launchEnvelopeDimensionZ: 0.0,
      numOrbitType: 0,
      orbitTypes: None,
      telemetryTrackingManufacturerOrgId: None,
      mainComputerManufacturerOrgId: None,
      manufacturerOrgId: None,
      busKitDesignerOrgId: None,
      countryCode: None,
      massCategory: None,
      powerCategory: None,
      generic: false,
      description: None,
      aocsNotes: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: Bus_Full_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      entity: None,
    }
  }
}
impl Bus_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Bus_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idEntity = self.idEntity.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let maxLaunchMassLower = self.maxLaunchMassLower;
    let maxLaunchMassUpper = self.maxLaunchMassUpper;
    let maxBOLStationMass = self.maxBOLStationMass;
    let avgPayloadMass = self.avgPayloadMass;
    let maxPayloadMass = self.maxPayloadMass;
    let minDryMass = self.minDryMass;
    let avgDryMass = self.avgDryMass;
    let medianDryMass = self.medianDryMass;
    let maxDryMass = self.maxDryMass;
    let minWetMass = self.minWetMass;
    let avgWetMass = self.avgWetMass;
    let medianWetMass = self.medianWetMass;
    let maxWetMass = self.maxWetMass;
    let maxBOLPowerLower = self.maxBOLPowerLower;
    let maxBOLPowerUpper = self.maxBOLPowerUpper;
    let maxEOLPowerLower = self.maxEOLPowerLower;
    let maxEOLPowerUpper = self.maxEOLPowerUpper;
    let avgSpacecraftPower = self.avgSpacecraftPower;
    let maxSpacecraftPower = self.maxSpacecraftPower;
    let oapSpacecraftPower = self.oapSpacecraftPower;
    let avgPayloadPower = self.avgPayloadPower;
    let maxPayloadPower = self.maxPayloadPower;
    let oapPayloadPower = self.oapPayloadPower;
    let bodyDimensionX = self.bodyDimensionX;
    let bodyDimensionY = self.bodyDimensionY;
    let bodyDimensionZ = self.bodyDimensionZ;
    let payloadDimensionX = self.payloadDimensionX;
    let payloadDimensionY = self.payloadDimensionY;
    let payloadDimensionZ = self.payloadDimensionZ;
    let payloadVolume = self.payloadVolume;
    let launchEnvelopeDimensionX = self.launchEnvelopeDimensionX;
    let launchEnvelopeDimensionY = self.launchEnvelopeDimensionY;
    let launchEnvelopeDimensionZ = self.launchEnvelopeDimensionZ;
    let numOrbitType = self.numOrbitType;
    let orbitTypes = self.orbitTypes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let telemetryTrackingManufacturerOrgId = self.telemetryTrackingManufacturerOrgId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mainComputerManufacturerOrgId = self.mainComputerManufacturerOrgId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let manufacturerOrgId = self.manufacturerOrgId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let busKitDesignerOrgId = self.busKitDesignerOrgId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let countryCode = self.countryCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let massCategory = self.massCategory.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let powerCategory = self.powerCategory.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let generic = self.generic;
    let description = self.description.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let aocsNotes = self.aocsNotes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let entity = self.entity.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Bus_Full::create(_fbb, &Bus_FullArgs{
      id,
      name,
      classificationMarking,
      idEntity,
      type_,
      maxLaunchMassLower,
      maxLaunchMassUpper,
      maxBOLStationMass,
      avgPayloadMass,
      maxPayloadMass,
      minDryMass,
      avgDryMass,
      medianDryMass,
      maxDryMass,
      minWetMass,
      avgWetMass,
      medianWetMass,
      maxWetMass,
      maxBOLPowerLower,
      maxBOLPowerUpper,
      maxEOLPowerLower,
      maxEOLPowerUpper,
      avgSpacecraftPower,
      maxSpacecraftPower,
      oapSpacecraftPower,
      avgPayloadPower,
      maxPayloadPower,
      oapPayloadPower,
      bodyDimensionX,
      bodyDimensionY,
      bodyDimensionZ,
      payloadDimensionX,
      payloadDimensionY,
      payloadDimensionZ,
      payloadVolume,
      launchEnvelopeDimensionX,
      launchEnvelopeDimensionY,
      launchEnvelopeDimensionZ,
      numOrbitType,
      orbitTypes,
      telemetryTrackingManufacturerOrgId,
      mainComputerManufacturerOrgId,
      manufacturerOrgId,
      busKitDesignerOrgId,
      countryCode,
      massCategory,
      powerCategory,
      generic,
      description,
      aocsNotes,
      source,
      origin,
      origNetwork,
      dataMode,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      entity,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Bus_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_bus_full_unchecked`.
pub fn root_as_bus_full(buf: &[u8]) -> Result<Bus_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Bus_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Bus_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_bus_full_unchecked`.
pub fn size_prefixed_root_as_bus_full(buf: &[u8]) -> Result<Bus_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Bus_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Bus_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_bus_full_unchecked`.
pub fn root_as_bus_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Bus_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Bus_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Bus_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_bus_full_unchecked`.
pub fn size_prefixed_root_as_bus_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Bus_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Bus_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Bus_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Bus_Full`.
pub unsafe fn root_as_bus_full_unchecked(buf: &[u8]) -> Bus_Full {
  flatbuffers::root_unchecked::<Bus_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Bus_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Bus_Full`.
pub unsafe fn size_prefixed_root_as_bus_full_unchecked(buf: &[u8]) -> Bus_Full {
  flatbuffers::size_prefixed_root_unchecked::<Bus_Full>(buf)
}
pub const BUS_FULL_IDENTIFIER: &str = "BUSF";

#[inline]
pub fn bus_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, BUS_FULL_IDENTIFIER, false)
}

#[inline]
pub fn bus_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, BUS_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_bus_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Bus_Full<'a>>) {
  fbb.finish(root, Some(BUS_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_bus_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Bus_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(BUS_FULL_IDENTIFIER));
}
