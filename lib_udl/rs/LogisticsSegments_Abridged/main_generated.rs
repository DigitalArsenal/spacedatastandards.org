// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum LogisticsSegments_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Remarks associated with this LogisticsSupport record.
pub struct LogisticsSegments_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogisticsSegments_Abridged<'a> {
  type Inner = LogisticsSegments_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogisticsSegments_Abridged<'a> {
  pub const VT_SEGMENTNUMBER: flatbuffers::VOffsetT = 4;
  pub const VT_MODECODE: flatbuffers::VOffsetT = 6;
  pub const VT_MISSIONTYPE: flatbuffers::VOffsetT = 8;
  pub const VT_IDMISSION: flatbuffers::VOffsetT = 10;
  pub const VT_EXTMISSIONID: flatbuffers::VOffsetT = 12;
  pub const VT_MISSIONNUMBER: flatbuffers::VOffsetT = 14;
  pub const VT_ITIN: flatbuffers::VOffsetT = 16;
  pub const VT_SEGTAILNUMBER: flatbuffers::VOffsetT = 18;
  pub const VT_SEGAIRCRAFTMDS: flatbuffers::VOffsetT = 20;
  pub const VT_DEPARTUREICAO: flatbuffers::VOffsetT = 22;
  pub const VT_SEGACTDEPTIME: flatbuffers::VOffsetT = 24;
  pub const VT_ARRIVALICAO: flatbuffers::VOffsetT = 26;
  pub const VT_SEGACTARRTIME: flatbuffers::VOffsetT = 28;
  pub const VT_SEGESTDEPTIME: flatbuffers::VOffsetT = 30;
  pub const VT_SEGESTARRTIME: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogisticsSegments_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LogisticsSegments_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<LogisticsSegments_Abridged<'bldr>> {
    let mut builder = LogisticsSegments_AbridgedBuilder::new(_fbb);
    if let Some(x) = args.segEstArrTime { builder.add_segEstArrTime(x); }
    if let Some(x) = args.segEstDepTime { builder.add_segEstDepTime(x); }
    if let Some(x) = args.segActArrTime { builder.add_segActArrTime(x); }
    if let Some(x) = args.arrivalICAO { builder.add_arrivalICAO(x); }
    if let Some(x) = args.segActDepTime { builder.add_segActDepTime(x); }
    if let Some(x) = args.departureICAO { builder.add_departureICAO(x); }
    if let Some(x) = args.segAircraftMDS { builder.add_segAircraftMDS(x); }
    if let Some(x) = args.segTailNumber { builder.add_segTailNumber(x); }
    builder.add_itin(args.itin);
    if let Some(x) = args.missionNumber { builder.add_missionNumber(x); }
    if let Some(x) = args.extMissionId { builder.add_extMissionId(x); }
    if let Some(x) = args.idMission { builder.add_idMission(x); }
    if let Some(x) = args.missionType { builder.add_missionType(x); }
    if let Some(x) = args.modeCode { builder.add_modeCode(x); }
    builder.add_segmentNumber(args.segmentNumber);
    builder.finish()
  }

  pub fn unpack(&self) -> LogisticsSegments_AbridgedT {
    let segmentNumber = self.segmentNumber();
    let modeCode = self.modeCode().map(|x| {
      x.to_string()
    });
    let missionType = self.missionType().map(|x| {
      x.to_string()
    });
    let idMission = self.idMission().map(|x| {
      x.to_string()
    });
    let extMissionId = self.extMissionId().map(|x| {
      x.to_string()
    });
    let missionNumber = self.missionNumber().map(|x| {
      x.to_string()
    });
    let itin = self.itin();
    let segTailNumber = self.segTailNumber().map(|x| {
      x.to_string()
    });
    let segAircraftMDS = self.segAircraftMDS().map(|x| {
      x.to_string()
    });
    let departureICAO = self.departureICAO().map(|x| {
      x.to_string()
    });
    let segActDepTime = self.segActDepTime().map(|x| {
      x.to_string()
    });
    let arrivalICAO = self.arrivalICAO().map(|x| {
      x.to_string()
    });
    let segActArrTime = self.segActArrTime().map(|x| {
      x.to_string()
    });
    let segEstDepTime = self.segEstDepTime().map(|x| {
      x.to_string()
    });
    let segEstArrTime = self.segEstArrTime().map(|x| {
      x.to_string()
    });
    LogisticsSegments_AbridgedT {
      segmentNumber,
      modeCode,
      missionType,
      idMission,
      extMissionId,
      missionNumber,
      itin,
      segTailNumber,
      segAircraftMDS,
      departureICAO,
      segActDepTime,
      arrivalICAO,
      segActArrTime,
      segEstDepTime,
      segEstArrTime,
    }
  }

  /// Used to sequence the segments in the transportation plan.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn segmentNumber(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LogisticsSegments_Abridged::VT_SEGMENTNUMBER, Some(0)).unwrap()}
  }
  /// Transportation mode.  AMC airlift, Commercial airlift, Other, or surface transportation.
  /// Example: /// Example: A
  /// Constraints: Minimum length = 1, Maximum length = 1
  #[inline]
  pub fn modeCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_MODECODE, None)}
  }
  /// The type of mission (e.g. SAAM, CHNL, etc.).
  /// Example: /// Example: SAAM
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn missionType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_MISSIONTYPE, None)}
  }
  /// The unique identifier of the mission to which this logistics record is assigned.
  /// Example: /// Example: EXAMPLE-UUID
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn idMission(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_IDMISSION, None)}
  }
  /// The GDSS mission ID for this segment.
  /// Example: /// Example: 2001101RF01202307062205
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn extMissionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_EXTMISSIONID, None)}
  }
  /// The user generated identifier for an air mission subgroup.
  /// Example: /// Example: TAM308901196
  /// Constraints: Minimum length = 0, Maximum length = 12
  #[inline]
  pub fn missionNumber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_MISSIONNUMBER, None)}
  }
  /// Start air mission itinerary point identifier.
  /// Example: /// Example: 200
  /// Constraints: No constraints specified.
  #[inline]
  pub fn itin(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LogisticsSegments_Abridged::VT_ITIN, Some(0)).unwrap()}
  }
  /// The identifier that represents a specific aircraft within an aircraft type.
  /// Example: /// Example: N819AX
  /// Constraints: Minimum length = 0, Maximum length = 7
  #[inline]
  pub fn segTailNumber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_SEGTAILNUMBER, None)}
  }
  /// The aircraft Model Design Series (MDS) designation (e.g. E-2C HAWKEYE, F-15 EAGLE, KC-130 HERCULES, etc.) of this aircraft. Intended as, but not constrained to, MIL-STD-6016 environment dependent specific type designations.
  /// Example: /// Example: B7772E
  /// Constraints: Minimum length = 0, Maximum length = 30
  #[inline]
  pub fn segAircraftMDS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_SEGAIRCRAFTMDS, None)}
  }
  /// Airport ICAO departure code.
  /// Example: /// Example: PHIK
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn departureICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_DEPARTUREICAO, None)}
  }
  /// Actual departure time to the segment destination, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-17T19:20:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn segActDepTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_SEGACTDEPTIME, None)}
  }
  /// Airport ICAO arrival code.
  /// Example: /// Example: YBCS
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn arrivalICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_ARRIVALICAO, None)}
  }
  /// Actual arrival time to segment destination, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-17T19:20:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn segActArrTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_SEGACTARRTIME, None)}
  }
  /// GC. LGTPS_C_DT_EST_DEP.  GD2: Estimated departure time from the segment origin. Only supplied when the segment is not attached to a Mission, otherwise the ETD is derived from the Mission segment origin point. This datetime should be in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-17T19:20:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn segEstDepTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_SEGESTDEPTIME, None)}
  }
  /// GC. LGTPS_C_DT_EST_ARR.  GD2: Estimated arrival time to the segment destination. Only supplied when the segment is not attached to a Mission, otherwise the ETA is derived from the Mission segment destination point. This datetime should be in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-17T19:20:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn segEstArrTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSegments_Abridged::VT_SEGESTARRTIME, None)}
  }
}

impl flatbuffers::Verifiable for LogisticsSegments_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("segmentNumber", Self::VT_SEGMENTNUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("modeCode", Self::VT_MODECODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("missionType", Self::VT_MISSIONTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idMission", Self::VT_IDMISSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("extMissionId", Self::VT_EXTMISSIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("missionNumber", Self::VT_MISSIONNUMBER, false)?
     .visit_field::<i32>("itin", Self::VT_ITIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("segTailNumber", Self::VT_SEGTAILNUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("segAircraftMDS", Self::VT_SEGAIRCRAFTMDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("departureICAO", Self::VT_DEPARTUREICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("segActDepTime", Self::VT_SEGACTDEPTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("arrivalICAO", Self::VT_ARRIVALICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("segActArrTime", Self::VT_SEGACTARRTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("segEstDepTime", Self::VT_SEGESTDEPTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("segEstArrTime", Self::VT_SEGESTARRTIME, false)?
     .finish();
    Ok(())
  }
}
pub struct LogisticsSegments_AbridgedArgs<'a> {
    pub segmentNumber: i32,
    pub modeCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub missionType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idMission: Option<flatbuffers::WIPOffset<&'a str>>,
    pub extMissionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub missionNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itin: i32,
    pub segTailNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub segAircraftMDS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub departureICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub segActDepTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub arrivalICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub segActArrTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub segEstDepTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub segEstArrTime: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LogisticsSegments_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    LogisticsSegments_AbridgedArgs {
      segmentNumber: 0,
      modeCode: None,
      missionType: None,
      idMission: None,
      extMissionId: None,
      missionNumber: None,
      itin: 0,
      segTailNumber: None,
      segAircraftMDS: None,
      departureICAO: None,
      segActDepTime: None,
      arrivalICAO: None,
      segActArrTime: None,
      segEstDepTime: None,
      segEstArrTime: None,
    }
  }
}

pub struct LogisticsSegments_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LogisticsSegments_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_segmentNumber(&mut self, segmentNumber: i32) {
    self.fbb_.push_slot::<i32>(LogisticsSegments_Abridged::VT_SEGMENTNUMBER, segmentNumber, 0);
  }
  #[inline]
  pub fn add_modeCode(&mut self, modeCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_MODECODE, modeCode);
  }
  #[inline]
  pub fn add_missionType(&mut self, missionType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_MISSIONTYPE, missionType);
  }
  #[inline]
  pub fn add_idMission(&mut self, idMission: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_IDMISSION, idMission);
  }
  #[inline]
  pub fn add_extMissionId(&mut self, extMissionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_EXTMISSIONID, extMissionId);
  }
  #[inline]
  pub fn add_missionNumber(&mut self, missionNumber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_MISSIONNUMBER, missionNumber);
  }
  #[inline]
  pub fn add_itin(&mut self, itin: i32) {
    self.fbb_.push_slot::<i32>(LogisticsSegments_Abridged::VT_ITIN, itin, 0);
  }
  #[inline]
  pub fn add_segTailNumber(&mut self, segTailNumber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_SEGTAILNUMBER, segTailNumber);
  }
  #[inline]
  pub fn add_segAircraftMDS(&mut self, segAircraftMDS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_SEGAIRCRAFTMDS, segAircraftMDS);
  }
  #[inline]
  pub fn add_departureICAO(&mut self, departureICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_DEPARTUREICAO, departureICAO);
  }
  #[inline]
  pub fn add_segActDepTime(&mut self, segActDepTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_SEGACTDEPTIME, segActDepTime);
  }
  #[inline]
  pub fn add_arrivalICAO(&mut self, arrivalICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_ARRIVALICAO, arrivalICAO);
  }
  #[inline]
  pub fn add_segActArrTime(&mut self, segActArrTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_SEGACTARRTIME, segActArrTime);
  }
  #[inline]
  pub fn add_segEstDepTime(&mut self, segEstDepTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_SEGESTDEPTIME, segEstDepTime);
  }
  #[inline]
  pub fn add_segEstArrTime(&mut self, segEstArrTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSegments_Abridged::VT_SEGESTARRTIME, segEstArrTime);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LogisticsSegments_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LogisticsSegments_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogisticsSegments_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogisticsSegments_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogisticsSegments_Abridged");
      ds.field("segmentNumber", &self.segmentNumber());
      ds.field("modeCode", &self.modeCode());
      ds.field("missionType", &self.missionType());
      ds.field("idMission", &self.idMission());
      ds.field("extMissionId", &self.extMissionId());
      ds.field("missionNumber", &self.missionNumber());
      ds.field("itin", &self.itin());
      ds.field("segTailNumber", &self.segTailNumber());
      ds.field("segAircraftMDS", &self.segAircraftMDS());
      ds.field("departureICAO", &self.departureICAO());
      ds.field("segActDepTime", &self.segActDepTime());
      ds.field("arrivalICAO", &self.arrivalICAO());
      ds.field("segActArrTime", &self.segActArrTime());
      ds.field("segEstDepTime", &self.segEstDepTime());
      ds.field("segEstArrTime", &self.segEstArrTime());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LogisticsSegments_AbridgedT {
  pub segmentNumber: i32,
  pub modeCode: Option<String>,
  pub missionType: Option<String>,
  pub idMission: Option<String>,
  pub extMissionId: Option<String>,
  pub missionNumber: Option<String>,
  pub itin: i32,
  pub segTailNumber: Option<String>,
  pub segAircraftMDS: Option<String>,
  pub departureICAO: Option<String>,
  pub segActDepTime: Option<String>,
  pub arrivalICAO: Option<String>,
  pub segActArrTime: Option<String>,
  pub segEstDepTime: Option<String>,
  pub segEstArrTime: Option<String>,
}
impl Default for LogisticsSegments_AbridgedT {
  fn default() -> Self {
    Self {
      segmentNumber: 0,
      modeCode: None,
      missionType: None,
      idMission: None,
      extMissionId: None,
      missionNumber: None,
      itin: 0,
      segTailNumber: None,
      segAircraftMDS: None,
      departureICAO: None,
      segActDepTime: None,
      arrivalICAO: None,
      segActArrTime: None,
      segEstDepTime: None,
      segEstArrTime: None,
    }
  }
}
impl LogisticsSegments_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<LogisticsSegments_Abridged<'b>> {
    let segmentNumber = self.segmentNumber;
    let modeCode = self.modeCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let missionType = self.missionType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idMission = self.idMission.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let extMissionId = self.extMissionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let missionNumber = self.missionNumber.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let itin = self.itin;
    let segTailNumber = self.segTailNumber.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let segAircraftMDS = self.segAircraftMDS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let departureICAO = self.departureICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let segActDepTime = self.segActDepTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let arrivalICAO = self.arrivalICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let segActArrTime = self.segActArrTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let segEstDepTime = self.segEstDepTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let segEstArrTime = self.segEstArrTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    LogisticsSegments_Abridged::create(_fbb, &LogisticsSegments_AbridgedArgs{
      segmentNumber,
      modeCode,
      missionType,
      idMission,
      extMissionId,
      missionNumber,
      itin,
      segTailNumber,
      segAircraftMDS,
      departureICAO,
      segActDepTime,
      arrivalICAO,
      segActArrTime,
      segEstDepTime,
      segEstArrTime,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `LogisticsSegments_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_logistics_segments_abridged_unchecked`.
pub fn root_as_logistics_segments_abridged(buf: &[u8]) -> Result<LogisticsSegments_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<LogisticsSegments_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `LogisticsSegments_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_logistics_segments_abridged_unchecked`.
pub fn size_prefixed_root_as_logistics_segments_abridged(buf: &[u8]) -> Result<LogisticsSegments_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<LogisticsSegments_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `LogisticsSegments_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_logistics_segments_abridged_unchecked`.
pub fn root_as_logistics_segments_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LogisticsSegments_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<LogisticsSegments_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `LogisticsSegments_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_logistics_segments_abridged_unchecked`.
pub fn size_prefixed_root_as_logistics_segments_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LogisticsSegments_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<LogisticsSegments_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a LogisticsSegments_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `LogisticsSegments_Abridged`.
pub unsafe fn root_as_logistics_segments_abridged_unchecked(buf: &[u8]) -> LogisticsSegments_Abridged {
  flatbuffers::root_unchecked::<LogisticsSegments_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed LogisticsSegments_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `LogisticsSegments_Abridged`.
pub unsafe fn size_prefixed_root_as_logistics_segments_abridged_unchecked(buf: &[u8]) -> LogisticsSegments_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<LogisticsSegments_Abridged>(buf)
}
pub const LOGISTICS_SEGMENTS_ABRIDGED_IDENTIFIER: &str = "LOGI";

#[inline]
pub fn logistics_segments_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LOGISTICS_SEGMENTS_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn logistics_segments_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LOGISTICS_SEGMENTS_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_logistics_segments_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<LogisticsSegments_Abridged<'a>>) {
  fbb.finish(root, Some(LOGISTICS_SEGMENTS_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_logistics_segments_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<LogisticsSegments_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(LOGISTICS_SEGMENTS_ABRIDGED_IDENTIFIER));
}
