// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ENTITY_FULL_TYPE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ENTITY_FULL_TYPE_ENUM: i8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENTITY_FULL_TYPE_ENUM: [Entity_Full_type_Enum; 11] = [
  Entity_Full_type_Enum::AIRCRAFT,
  Entity_Full_type_Enum::BUS,
  Entity_Full_type_Enum::COMM,
  Entity_Full_type_Enum::IR,
  Entity_Full_type_Enum::NAVIGATION,
  Entity_Full_type_Enum::ONORBIT,
  Entity_Full_type_Enum::RFEMITTER,
  Entity_Full_type_Enum::SCIENTIFIC,
  Entity_Full_type_Enum::SENSOR,
  Entity_Full_type_Enum::SITE,
  Entity_Full_type_Enum::VESSEL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Entity_Full_type_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Entity_Full_type_Enum {
  /// No description available.
  pub const AIRCRAFT: Self = Self(0);
  /// No description available.
  pub const BUS: Self = Self(1);
  /// No description available.
  pub const COMM: Self = Self(2);
  /// No description available.
  pub const IR: Self = Self(3);
  /// No description available.
  pub const NAVIGATION: Self = Self(4);
  /// No description available.
  pub const ONORBIT: Self = Self(5);
  /// No description available.
  pub const RFEMITTER: Self = Self(6);
  /// No description available.
  pub const SCIENTIFIC: Self = Self(7);
  /// No description available.
  pub const SENSOR: Self = Self(8);
  /// No description available.
  pub const SITE: Self = Self(9);
  /// No description available.
  pub const VESSEL: Self = Self(10);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AIRCRAFT,
    Self::BUS,
    Self::COMM,
    Self::IR,
    Self::NAVIGATION,
    Self::ONORBIT,
    Self::RFEMITTER,
    Self::SCIENTIFIC,
    Self::SENSOR,
    Self::SITE,
    Self::VESSEL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AIRCRAFT => Some("AIRCRAFT"),
      Self::BUS => Some("BUS"),
      Self::COMM => Some("COMM"),
      Self::IR => Some("IR"),
      Self::NAVIGATION => Some("NAVIGATION"),
      Self::ONORBIT => Some("ONORBIT"),
      Self::RFEMITTER => Some("RFEMITTER"),
      Self::SCIENTIFIC => Some("SCIENTIFIC"),
      Self::SENSOR => Some("SENSOR"),
      Self::SITE => Some("SITE"),
      Self::VESSEL => Some("VESSEL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Entity_Full_type_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Entity_Full_type_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Entity_Full_type_Enum {
    type Output = Entity_Full_type_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Entity_Full_type_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Entity_Full_type_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Entity_Full_type_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ENTITY_FULL_OWNER_TYPE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ENTITY_FULL_OWNER_TYPE_ENUM: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENTITY_FULL_OWNER_TYPE_ENUM: [Entity_Full_ownerType_Enum; 5] = [
  Entity_Full_ownerType_Enum::COMMERCIAL,
  Entity_Full_ownerType_Enum::GOVERNMENT,
  Entity_Full_ownerType_Enum::ACADEMIC,
  Entity_Full_ownerType_Enum::CONSORTIUM,
  Entity_Full_ownerType_Enum::OTHER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Entity_Full_ownerType_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Entity_Full_ownerType_Enum {
  /// No description available.
  pub const COMMERCIAL: Self = Self(0);
  /// No description available.
  pub const GOVERNMENT: Self = Self(1);
  /// No description available.
  pub const ACADEMIC: Self = Self(2);
  /// No description available.
  pub const CONSORTIUM: Self = Self(3);
  /// No description available.
  pub const OTHER: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::COMMERCIAL,
    Self::GOVERNMENT,
    Self::ACADEMIC,
    Self::CONSORTIUM,
    Self::OTHER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::COMMERCIAL => Some("COMMERCIAL"),
      Self::GOVERNMENT => Some("GOVERNMENT"),
      Self::ACADEMIC => Some("ACADEMIC"),
      Self::CONSORTIUM => Some("CONSORTIUM"),
      Self::OTHER => Some("OTHER"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Entity_Full_ownerType_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Entity_Full_ownerType_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Entity_Full_ownerType_Enum {
    type Output = Entity_Full_ownerType_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Entity_Full_ownerType_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Entity_Full_ownerType_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Entity_Full_ownerType_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ENTITY_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ENTITY_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENTITY_FULL_DATA_MODE_ENUM: [Entity_Full_dataMode_Enum; 4] = [
  Entity_Full_dataMode_Enum::REAL,
  Entity_Full_dataMode_Enum::TEST,
  Entity_Full_dataMode_Enum::SIMULATED,
  Entity_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Entity_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Entity_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Entity_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Entity_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Entity_Full_dataMode_Enum {
    type Output = Entity_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Entity_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Entity_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Entity_Full_dataMode_Enum {}
pub enum Entity_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
pub struct Entity_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Entity_Full<'a> {
  type Inner = Entity_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Entity_Full<'a> {
  pub const VT_IDENTITY: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 8;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 10;
  pub const VT_IDLOCATION: flatbuffers::VOffsetT = 12;
  pub const VT_COUNTRYCODE: flatbuffers::VOffsetT = 14;
  pub const VT_OWNERTYPE: flatbuffers::VOffsetT = 16;
  pub const VT_TASKABLE: flatbuffers::VOffsetT = 18;
  pub const VT_URLS: flatbuffers::VOffsetT = 20;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 22;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 24;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 26;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 28;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 30;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 32;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 34;
  pub const VT_LOCATION: flatbuffers::VOffsetT = 36;
  pub const VT_ONORBIT: flatbuffers::VOffsetT = 38;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 40;
  pub const VT_OPERATINGUNIT: flatbuffers::VOffsetT = 42;
  pub const VT_IDOPERATINGUNIT: flatbuffers::VOffsetT = 44;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 46;
  pub const VT_STATUSCOLLECTION: flatbuffers::VOffsetT = 48;
  pub const VT_RFBANDS: flatbuffers::VOffsetT = 50;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Entity_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Entity_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<Entity_Full<'bldr>> {
    let mut builder = Entity_FullBuilder::new(_fbb);
    if let Some(x) = args.rfBands { builder.add_rfBands(x); }
    if let Some(x) = args.statusCollection { builder.add_statusCollection(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.idOperatingUnit { builder.add_idOperatingUnit(x); }
    if let Some(x) = args.operatingUnit { builder.add_operatingUnit(x); }
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.onOrbit { builder.add_onOrbit(x); }
    if let Some(x) = args.location { builder.add_location(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.urls { builder.add_urls(x); }
    if let Some(x) = args.countryCode { builder.add_countryCode(x); }
    if let Some(x) = args.idLocation { builder.add_idLocation(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.idEntity { builder.add_idEntity(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_taskable(args.taskable);
    builder.add_ownerType(args.ownerType);
    builder.add_type_(args.type_);
    builder.finish()
  }

  pub fn unpack(&self) -> Entity_FullT {
    let idEntity = self.idEntity().map(|x| {
      x.to_string()
    });
    let name = self.name().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let type_ = self.type_();
    let idLocation = self.idLocation().map(|x| {
      x.to_string()
    });
    let countryCode = self.countryCode().map(|x| {
      x.to_string()
    });
    let ownerType = self.ownerType();
    let taskable = self.taskable();
    let urls = self.urls().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let location = self.location().map(|x| {
      x.to_string()
    });
    let onOrbit = self.onOrbit().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let operatingUnit = self.operatingUnit().map(|x| {
      x.to_string()
    });
    let idOperatingUnit = self.idOperatingUnit().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let statusCollection = self.statusCollection().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let rfBands = self.rfBands().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    Entity_FullT {
      idEntity,
      name,
      classificationMarking,
      type_,
      idLocation,
      countryCode,
      ownerType,
      taskable,
      urls,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      dataMode,
      location,
      onOrbit,
      idOnOrbit,
      operatingUnit,
      idOperatingUnit,
      origNetwork,
      statusCollection,
      rfBands,
    }
  }

  /// Unique identifier of the record.
  /// Example: /// Example: ENTITY-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn idEntity(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_IDENTITY, None)}
  }
  /// Unique entity name.
  /// Example: /// Example: Example name
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_NAME, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// The type of entity represented by this record (AIRCRAFT, BUS, COMM, IR, NAVIGATION, ONORBIT, RFEMITTER, SCIENTIFIC, SENSOR, SITE, VESSEL).
  /// Example: /// Example: ONORBIT
  /// Constraints: Minimum length = 1, Maximum length = 45
  #[inline]
  pub fn type_(&self) -> Entity_Full_type_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Entity_Full_type_Enum>(Entity_Full::VT_TYPE_, Some(Entity_Full_type_Enum::AIRCRAFT)).unwrap()}
  }
  /// Unique identifier of the entity location, if terrestrial/fixed.
  /// Example: /// Example: LOCATION-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idLocation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_IDLOCATION, None)}
  }
  /// The country code. This value is typically the ISO 3166 Alpha-2 two-character country code, however it can also represent various consortiums that do not appear in the ISO document. The code must correspond to an existing country in the UDL’s country API. Call udl/country/{code} to get any associated FIPS code, ISO Alpha-3 code, or alternate code values that exist for the specified country code.
  /// Example: /// Example: US
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn countryCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_COUNTRYCODE, None)}
  }
  /// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc).
  /// Example: /// Example: Commercial
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn ownerType(&self) -> Entity_Full_ownerType_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Entity_Full_ownerType_Enum>(Entity_Full::VT_OWNERTYPE, Some(Entity_Full_ownerType_Enum::COMMERCIAL)).unwrap()}
  }
  /// Boolean indicating if this entity is taskable.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taskable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Entity_Full::VT_TASKABLE, Some(false)).unwrap()}
  }
  /// List of URLs to additional details/documents for this entity.
  /// Example: /// Example: ['URL1', 'URL2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn urls(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Entity_Full::VT_URLS, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_CREATEDBY, None)}
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_UPDATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> Entity_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Entity_Full_dataMode_Enum>(Entity_Full::VT_DATAMODE, Some(Entity_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn location(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_LOCATION, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn onOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_ONORBIT, None)}
  }
  /// Onorbit identifier if this entity is part of an on-orbit object. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_IDONORBIT, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn operatingUnit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_OPERATINGUNIT, None)}
  }
  /// Unique identifier of the associated operating unit object.
  /// Example: /// Example: OPERATINGUNIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOperatingUnit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_IDOPERATINGUNIT, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity_Full::VT_ORIGNETWORK, None)}
  }
  /// Read-only collection of statuses which can be collected by multiple sources.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn statusCollection(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Entity_Full::VT_STATUSCOLLECTION, None)}
  }
  /// Read-only collection of RF bands utilized by this entity for communication and/or operation.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rfBands(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Entity_Full::VT_RFBANDS, None)}
  }
}

impl flatbuffers::Verifiable for Entity_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idEntity", Self::VT_IDENTITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<Entity_Full_type_Enum>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idLocation", Self::VT_IDLOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("countryCode", Self::VT_COUNTRYCODE, false)?
     .visit_field::<Entity_Full_ownerType_Enum>("ownerType", Self::VT_OWNERTYPE, false)?
     .visit_field::<bool>("taskable", Self::VT_TASKABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("urls", Self::VT_URLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<Entity_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("location", Self::VT_LOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("onOrbit", Self::VT_ONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("operatingUnit", Self::VT_OPERATINGUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOperatingUnit", Self::VT_IDOPERATINGUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("statusCollection", Self::VT_STATUSCOLLECTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("rfBands", Self::VT_RFBANDS, false)?
     .finish();
    Ok(())
  }
}
pub struct Entity_FullArgs<'a> {
    pub idEntity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Entity_Full_type_Enum,
    pub idLocation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub countryCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ownerType: Entity_Full_ownerType_Enum,
    pub taskable: bool,
    pub urls: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: Entity_Full_dataMode_Enum,
    pub location: Option<flatbuffers::WIPOffset<&'a str>>,
    pub onOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operatingUnit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOperatingUnit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub statusCollection: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub rfBands: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for Entity_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    Entity_FullArgs {
      idEntity: None,
      name: None,
      classificationMarking: None,
      type_: Entity_Full_type_Enum::AIRCRAFT,
      idLocation: None,
      countryCode: None,
      ownerType: Entity_Full_ownerType_Enum::COMMERCIAL,
      taskable: false,
      urls: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      dataMode: Entity_Full_dataMode_Enum::REAL,
      location: None,
      onOrbit: None,
      idOnOrbit: None,
      operatingUnit: None,
      idOperatingUnit: None,
      origNetwork: None,
      statusCollection: None,
      rfBands: None,
    }
  }
}

pub struct Entity_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Entity_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_idEntity(&mut self, idEntity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_IDENTITY, idEntity);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_NAME, name);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: Entity_Full_type_Enum) {
    self.fbb_.push_slot::<Entity_Full_type_Enum>(Entity_Full::VT_TYPE_, type_, Entity_Full_type_Enum::AIRCRAFT);
  }
  #[inline]
  pub fn add_idLocation(&mut self, idLocation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_IDLOCATION, idLocation);
  }
  #[inline]
  pub fn add_countryCode(&mut self, countryCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_COUNTRYCODE, countryCode);
  }
  #[inline]
  pub fn add_ownerType(&mut self, ownerType: Entity_Full_ownerType_Enum) {
    self.fbb_.push_slot::<Entity_Full_ownerType_Enum>(Entity_Full::VT_OWNERTYPE, ownerType, Entity_Full_ownerType_Enum::COMMERCIAL);
  }
  #[inline]
  pub fn add_taskable(&mut self, taskable: bool) {
    self.fbb_.push_slot::<bool>(Entity_Full::VT_TASKABLE, taskable, false);
  }
  #[inline]
  pub fn add_urls(&mut self, urls: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_URLS, urls);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Entity_Full_dataMode_Enum) {
    self.fbb_.push_slot::<Entity_Full_dataMode_Enum>(Entity_Full::VT_DATAMODE, dataMode, Entity_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_location(&mut self, location: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_onOrbit(&mut self, onOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_ONORBIT, onOrbit);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_operatingUnit(&mut self, operatingUnit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_OPERATINGUNIT, operatingUnit);
  }
  #[inline]
  pub fn add_idOperatingUnit(&mut self, idOperatingUnit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_IDOPERATINGUNIT, idOperatingUnit);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_statusCollection(&mut self, statusCollection: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_STATUSCOLLECTION, statusCollection);
  }
  #[inline]
  pub fn add_rfBands(&mut self, rfBands: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity_Full::VT_RFBANDS, rfBands);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Entity_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Entity_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Entity_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Entity_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Entity_Full");
      ds.field("idEntity", &self.idEntity());
      ds.field("name", &self.name());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("type_", &self.type_());
      ds.field("idLocation", &self.idLocation());
      ds.field("countryCode", &self.countryCode());
      ds.field("ownerType", &self.ownerType());
      ds.field("taskable", &self.taskable());
      ds.field("urls", &self.urls());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("location", &self.location());
      ds.field("onOrbit", &self.onOrbit());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("operatingUnit", &self.operatingUnit());
      ds.field("idOperatingUnit", &self.idOperatingUnit());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("statusCollection", &self.statusCollection());
      ds.field("rfBands", &self.rfBands());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Entity_FullT {
  pub idEntity: Option<String>,
  pub name: Option<String>,
  pub classificationMarking: Option<String>,
  pub type_: Entity_Full_type_Enum,
  pub idLocation: Option<String>,
  pub countryCode: Option<String>,
  pub ownerType: Entity_Full_ownerType_Enum,
  pub taskable: bool,
  pub urls: Option<Vec<String>>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: Entity_Full_dataMode_Enum,
  pub location: Option<String>,
  pub onOrbit: Option<String>,
  pub idOnOrbit: Option<String>,
  pub operatingUnit: Option<String>,
  pub idOperatingUnit: Option<String>,
  pub origNetwork: Option<String>,
  pub statusCollection: Option<Vec<String>>,
  pub rfBands: Option<Vec<String>>,
}
impl Default for Entity_FullT {
  fn default() -> Self {
    Self {
      idEntity: None,
      name: None,
      classificationMarking: None,
      type_: Entity_Full_type_Enum::AIRCRAFT,
      idLocation: None,
      countryCode: None,
      ownerType: Entity_Full_ownerType_Enum::COMMERCIAL,
      taskable: false,
      urls: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      dataMode: Entity_Full_dataMode_Enum::REAL,
      location: None,
      onOrbit: None,
      idOnOrbit: None,
      operatingUnit: None,
      idOperatingUnit: None,
      origNetwork: None,
      statusCollection: None,
      rfBands: None,
    }
  }
}
impl Entity_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Entity_Full<'b>> {
    let idEntity = self.idEntity.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_;
    let idLocation = self.idLocation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let countryCode = self.countryCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ownerType = self.ownerType;
    let taskable = self.taskable;
    let urls = self.urls.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let location = self.location.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let onOrbit = self.onOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let operatingUnit = self.operatingUnit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOperatingUnit = self.idOperatingUnit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let statusCollection = self.statusCollection.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let rfBands = self.rfBands.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    Entity_Full::create(_fbb, &Entity_FullArgs{
      idEntity,
      name,
      classificationMarking,
      type_,
      idLocation,
      countryCode,
      ownerType,
      taskable,
      urls,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      dataMode,
      location,
      onOrbit,
      idOnOrbit,
      operatingUnit,
      idOperatingUnit,
      origNetwork,
      statusCollection,
      rfBands,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Entity_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_entity_full_unchecked`.
pub fn root_as_entity_full(buf: &[u8]) -> Result<Entity_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Entity_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Entity_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_entity_full_unchecked`.
pub fn size_prefixed_root_as_entity_full(buf: &[u8]) -> Result<Entity_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Entity_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Entity_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_entity_full_unchecked`.
pub fn root_as_entity_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Entity_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Entity_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Entity_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_entity_full_unchecked`.
pub fn size_prefixed_root_as_entity_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Entity_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Entity_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Entity_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Entity_Full`.
pub unsafe fn root_as_entity_full_unchecked(buf: &[u8]) -> Entity_Full {
  flatbuffers::root_unchecked::<Entity_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Entity_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Entity_Full`.
pub unsafe fn size_prefixed_root_as_entity_full_unchecked(buf: &[u8]) -> Entity_Full {
  flatbuffers::size_prefixed_root_unchecked::<Entity_Full>(buf)
}
pub const ENTITY_FULL_IDENTIFIER: &str = "ENTI";

#[inline]
pub fn entity_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ENTITY_FULL_IDENTIFIER, false)
}

#[inline]
pub fn entity_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ENTITY_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_entity_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Entity_Full<'a>>) {
  fbb.finish(root, Some(ENTITY_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_entity_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Entity_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(ENTITY_FULL_IDENTIFIER));
}
