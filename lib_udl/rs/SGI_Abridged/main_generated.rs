// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SGI_ABRIDGED_STATE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SGI_ABRIDGED_STATE_ENUM: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SGI_ABRIDGED_STATE_ENUM: [SGI_Abridged_state_Enum; 3] = [
  SGI_Abridged_state_Enum::I,
  SGI_Abridged_state_Enum::N,
  SGI_Abridged_state_Enum::P,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SGI_Abridged_state_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl SGI_Abridged_state_Enum {
  /// No description available.
  pub const I: Self = Self(0);
  /// No description available.
  pub const N: Self = Self(1);
  /// No description available.
  pub const P: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::I,
    Self::N,
    Self::P,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::I => Some("I"),
      Self::N => Some("N"),
      Self::P => Some("P"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SGI_Abridged_state_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SGI_Abridged_state_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SGI_Abridged_state_Enum {
    type Output = SGI_Abridged_state_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SGI_Abridged_state_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SGI_Abridged_state_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SGI_Abridged_state_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SGI_ABRIDGED_PRECEDENCE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SGI_ABRIDGED_PRECEDENCE_ENUM: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SGI_ABRIDGED_PRECEDENCE_ENUM: [SGI_Abridged_precedence_Enum; 5] = [
  SGI_Abridged_precedence_Enum::O,
  SGI_Abridged_precedence_Enum::P,
  SGI_Abridged_precedence_Enum::R,
  SGI_Abridged_precedence_Enum::Y,
  SGI_Abridged_precedence_Enum::Z,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SGI_Abridged_precedence_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl SGI_Abridged_precedence_Enum {
  /// No description available.
  pub const O: Self = Self(0);
  /// No description available.
  pub const P: Self = Self(1);
  /// No description available.
  pub const R: Self = Self(2);
  /// No description available.
  pub const Y: Self = Self(3);
  /// No description available.
  pub const Z: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::O,
    Self::P,
    Self::R,
    Self::Y,
    Self::Z,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::O => Some("O"),
      Self::P => Some("P"),
      Self::R => Some("R"),
      Self::Y => Some("Y"),
      Self::Z => Some("Z"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SGI_Abridged_precedence_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SGI_Abridged_precedence_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SGI_Abridged_precedence_Enum {
    type Output = SGI_Abridged_precedence_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SGI_Abridged_precedence_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SGI_Abridged_precedence_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SGI_Abridged_precedence_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SGI_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SGI_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SGI_ABRIDGED_DATA_MODE_ENUM: [SGI_Abridged_dataMode_Enum; 4] = [
  SGI_Abridged_dataMode_Enum::REAL,
  SGI_Abridged_dataMode_Enum::TEST,
  SGI_Abridged_dataMode_Enum::SIMULATED,
  SGI_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SGI_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl SGI_Abridged_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SGI_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SGI_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SGI_Abridged_dataMode_Enum {
    type Output = SGI_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SGI_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SGI_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SGI_Abridged_dataMode_Enum {}
pub enum SGI_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Model representation of space weather/solar, geomagnetic, and radiation belt indices.
pub struct SGI_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SGI_Abridged<'a> {
  type Inner = SGI_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SGI_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_EFFECTIVEDATE: flatbuffers::VOffsetT = 8;
  pub const VT_SGIDATE: flatbuffers::VOffsetT = 10;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 12;
  pub const VT_STATE: flatbuffers::VOffsetT = 14;
  pub const VT_STATIONNAME: flatbuffers::VOffsetT = 16;
  pub const VT_IDSENSOR: flatbuffers::VOffsetT = 18;
  pub const VT_ORIGSENSORID: flatbuffers::VOffsetT = 20;
  pub const VT_MODE: flatbuffers::VOffsetT = 22;
  pub const VT_PRECEDENCE: flatbuffers::VOffsetT = 24;
  pub const VT_COEFFDEGREE: flatbuffers::VOffsetT = 26;
  pub const VT_COEFFORDER: flatbuffers::VOffsetT = 28;
  pub const VT_CTCE: flatbuffers::VOffsetT = 30;
  pub const VT_STCE: flatbuffers::VOffsetT = 32;
  pub const VT_CTCI: flatbuffers::VOffsetT = 34;
  pub const VT_STCI: flatbuffers::VOffsetT = 36;
  pub const VT_E10: flatbuffers::VOffsetT = 38;
  pub const VT_E54: flatbuffers::VOffsetT = 40;
  pub const VT_S10: flatbuffers::VOffsetT = 42;
  pub const VT_S54: flatbuffers::VOffsetT = 44;
  pub const VT_M10: flatbuffers::VOffsetT = 46;
  pub const VT_M54: flatbuffers::VOffsetT = 48;
  pub const VT_Y10: flatbuffers::VOffsetT = 50;
  pub const VT_Y54: flatbuffers::VOffsetT = 52;
  pub const VT_F10: flatbuffers::VOffsetT = 54;
  pub const VT_F54: flatbuffers::VOffsetT = 56;
  pub const VT_F81: flatbuffers::VOffsetT = 58;
  pub const VT_AP: flatbuffers::VOffsetT = 60;
  pub const VT_APDURATION: flatbuffers::VOffsetT = 62;
  pub const VT_KINDEX: flatbuffers::VOffsetT = 64;
  pub const VT_KP: flatbuffers::VOffsetT = 66;
  pub const VT_KPDURATION: flatbuffers::VOffsetT = 68;
  pub const VT_GAMMA: flatbuffers::VOffsetT = 70;
  pub const VT_DST: flatbuffers::VOffsetT = 72;
  pub const VT_DTC: flatbuffers::VOffsetT = 74;
  pub const VT_RBREGIONCODE: flatbuffers::VOffsetT = 76;
  pub const VT_RBINDEX: flatbuffers::VOffsetT = 78;
  pub const VT_NORMFACTOR: flatbuffers::VOffsetT = 80;
  pub const VT_RBDURATION: flatbuffers::VOffsetT = 82;
  pub const VT_ANALYZERATTENUATION: flatbuffers::VOffsetT = 84;
  pub const VT_RAWFILEURI: flatbuffers::VOffsetT = 86;
  pub const VT_TRANSACTIONID: flatbuffers::VOffsetT = 88;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 90;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 92;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 94;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 96;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 98;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 100;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SGI_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SGI_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<SGI_Abridged<'bldr>> {
    let mut builder = SGI_AbridgedBuilder::new(_fbb);
    builder.add_analyzerAttenuation(args.analyzerAttenuation);
    builder.add_normFactor(args.normFactor);
    builder.add_rbIndex(args.rbIndex);
    builder.add_dtc(args.dtc);
    builder.add_dst(args.dst);
    builder.add_kp(args.kp);
    builder.add_ap(args.ap);
    builder.add_f81(args.f81);
    builder.add_f54(args.f54);
    builder.add_f10(args.f10);
    builder.add_y54(args.y54);
    builder.add_y10(args.y10);
    builder.add_m54(args.m54);
    builder.add_m10(args.m10);
    builder.add_s54(args.s54);
    builder.add_s10(args.s10);
    builder.add_e54(args.e54);
    builder.add_e10(args.e10);
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.transactionId { builder.add_transactionId(x); }
    if let Some(x) = args.rawFileURI { builder.add_rawFileURI(x); }
    builder.add_rbDuration(args.rbDuration);
    builder.add_rbRegionCode(args.rbRegionCode);
    builder.add_gamma(args.gamma);
    builder.add_kpDuration(args.kpDuration);
    builder.add_kIndex(args.kIndex);
    builder.add_apDuration(args.apDuration);
    if let Some(x) = args.stci { builder.add_stci(x); }
    if let Some(x) = args.ctci { builder.add_ctci(x); }
    if let Some(x) = args.stce { builder.add_stce(x); }
    if let Some(x) = args.ctce { builder.add_ctce(x); }
    if let Some(x) = args.coeffOrder { builder.add_coeffOrder(x); }
    if let Some(x) = args.coeffDegree { builder.add_coeffDegree(x); }
    builder.add_mode(args.mode);
    if let Some(x) = args.origSensorId { builder.add_origSensorId(x); }
    if let Some(x) = args.idSensor { builder.add_idSensor(x); }
    if let Some(x) = args.stationName { builder.add_stationName(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.sgiDate { builder.add_sgiDate(x); }
    if let Some(x) = args.effectiveDate { builder.add_effectiveDate(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_precedence(args.precedence);
    builder.add_state(args.state);
    builder.finish()
  }

  pub fn unpack(&self) -> SGI_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let effectiveDate = self.effectiveDate().map(|x| {
      x.to_string()
    });
    let sgiDate = self.sgiDate().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let state = self.state();
    let stationName = self.stationName().map(|x| {
      x.to_string()
    });
    let idSensor = self.idSensor().map(|x| {
      x.to_string()
    });
    let origSensorId = self.origSensorId().map(|x| {
      x.to_string()
    });
    let mode = self.mode();
    let precedence = self.precedence();
    let coeffDegree = self.coeffDegree().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let coeffOrder = self.coeffOrder().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ctce = self.ctce().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let stce = self.stce().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ctci = self.ctci().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let stci = self.stci().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let e10 = self.e10();
    let e54 = self.e54();
    let s10 = self.s10();
    let s54 = self.s54();
    let m10 = self.m10();
    let m54 = self.m54();
    let y10 = self.y10();
    let y54 = self.y54();
    let f10 = self.f10();
    let f54 = self.f54();
    let f81 = self.f81();
    let ap = self.ap();
    let apDuration = self.apDuration();
    let kIndex = self.kIndex();
    let kp = self.kp();
    let kpDuration = self.kpDuration();
    let gamma = self.gamma();
    let dst = self.dst();
    let dtc = self.dtc();
    let rbRegionCode = self.rbRegionCode();
    let rbIndex = self.rbIndex();
    let normFactor = self.normFactor();
    let rbDuration = self.rbDuration();
    let analyzerAttenuation = self.analyzerAttenuation();
    let rawFileURI = self.rawFileURI().map(|x| {
      x.to_string()
    });
    let transactionId = self.transactionId().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    SGI_AbridgedT {
      id,
      classificationMarking,
      effectiveDate,
      sgiDate,
      type_,
      state,
      stationName,
      idSensor,
      origSensorId,
      mode,
      precedence,
      coeffDegree,
      coeffOrder,
      ctce,
      stce,
      ctci,
      stci,
      e10,
      e54,
      s10,
      s54,
      m10,
      m54,
      y10,
      y54,
      f10,
      f54,
      f81,
      ap,
      apDuration,
      kIndex,
      kp,
      kpDuration,
      gamma,
      dst,
      dtc,
      rbRegionCode,
      rbIndex,
      normFactor,
      rbDuration,
      analyzerAttenuation,
      rawFileURI,
      transactionId,
      source,
      origin,
      origNetwork,
      dataMode,
      createdAt,
      createdBy,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: SGI-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// ISO8601 UTC Time the data was received and processed from the source. Typically a source provides data for a date window with each transmission including past, present, and future predicted values.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn effectiveDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_EFFECTIVEDATE, None)}
  }
  /// ISO8601 UTC Time of the index value. This could be a past, current, or future predicted value. Note: sgiDate defines the start time of the time window for this  data record.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sgiDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_SGIDATE, None)}
  }
  /// The type of data contained in this record (e.g. HASDM, JBH09, K-Index, PSD-dB, RBI, RFI-SFU, etc).
  /// Example: /// Example: JBH09
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_TYPE_, None)}
  }
  /// State indicating Issued (I), Nowcast (N), or Predicted (P) values for this record.
  /// Example: /// Example: I
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn state(&self) -> SGI_Abridged_state_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SGI_Abridged_state_Enum>(SGI_Abridged::VT_STATE, Some(SGI_Abridged_state_Enum::I)).unwrap()}
  }
  /// The name/location of the station that collected the geomagnetic data for this record.
  /// Example: /// Example: Boulder
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn stationName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_STATIONNAME, None)}
  }
  /// Unique identifier of the reporting sensor.
  /// Example: /// Example: 57c96c97-e076-48af-a068-73ee2cb37e65
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_IDSENSOR, None)}
  }
  /// Optional identifier provided by the reporting source to indicate the sensor identifier which produced this data. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origSensorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_ORIGSENSORID, None)}
  }
  /// The transmitted DCA mode of the record (1-3).
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mode(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SGI_Abridged::VT_MODE, Some(0)).unwrap()}
  }
  /// The precedence of data in this record (O = Immediate, P = Priority, R = Routine, Y = Emergency, Z = Flash).
  /// Example: /// Example: R
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn precedence(&self) -> SGI_Abridged_precedence_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SGI_Abridged_precedence_Enum>(SGI_Abridged::VT_PRECEDENCE, Some(SGI_Abridged_precedence_Enum::O)).unwrap()}
  }
  /// Array containing the degree of the temperature coefficients. The coeffDegree and coeffOrder arrays must be the same length.
  /// Example: /// Example: [1, 2, 3]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn coeffDegree(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SGI_Abridged::VT_COEFFDEGREE, None)}
  }
  /// Array containing the order of the temperature coefficients. The coeffDegree and coeffOrder arrays must be the same length.
  /// Example: /// Example: [1, 2, 3]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn coeffOrder(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SGI_Abridged::VT_COEFFORDER, None)}
  }
  /// Array containing the cosine spherical-harmonic coefficients for Exospheric temperature (DTC) difference.  Each array element corresponds to the positional index of the coeffDegree and coeffOrder arrays.
  /// Example: /// Example: [1.23, 342.3, 1.32]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ctce(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SGI_Abridged::VT_CTCE, None)}
  }
  /// Array containing the sine spherical-harmonic coefficients for Exospheric temperature (DTC) difference.  Each array element corresponds to the positional index of the coeffDegree and coeffOrder arrays.
  /// Example: /// Example: [1.23, 342.3, 1.32]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stce(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SGI_Abridged::VT_STCE, None)}
  }
  /// Array containing the cosine spherical-harmonic coefficients for Inflection temperature (DTX) difference.  Each array element corresponds to the positional index of the coeffDegree and coeffOrder arrays.
  /// Example: /// Example: [1.23, 342.3, 1.32]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ctci(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SGI_Abridged::VT_CTCI, None)}
  }
  /// Array containing the sine spherical harmonic coefficients for Inflection temperature (DTX) difference.  Each array element corresponds to the positional index of the coeffDegree and coeffOrder arrays.
  /// Example: /// Example: [1.23, 342.3, 1.32]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stci(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SGI_Abridged::VT_STCI, None)}
  }
  /// Extreme Ultraviolet (EUV) proxy, E10.7, in x10-22 Watts per meter squared per Hertz, is the integrated solar EUV energy flux at the top of atmosphere and normalized to solar flux units.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn e10(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_E10, Some(0.0)).unwrap()}
  }
  /// E54 (E10-Bar), in x10-22 Watts per meter squared per Hertz, uses the past 54-days E10 values to determine the E10 average.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn e54(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_E54, Some(0.0)).unwrap()}
  }
  /// Daily S10.7 index for >200 km heating of O by solar chromosphere. 28.4-30.4 nm emissions in x10-22 Watts per meter squared per Hertz.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn s10(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_S10, Some(0.0)).unwrap()}
  }
  /// 54 day S10.7 index for >200 km heating of O by solar chromosphere. 28.4-30.4 nm emissions in x10-22 Watts per meter squared per Hertz.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn s54(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_S54, Some(0.0)).unwrap()}
  }
  /// Daily M10.7 index for 100-110 km heating of O2 by solar photosphere. 160 nm SRC emissions in x10-22 Watts per meter squared per Hertz.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn m10(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_M10, Some(0.0)).unwrap()}
  }
  /// 54 day M10.7 index for 100-110 km heating of O2 by solar photosphere. 160 nm SRC emissions in x10-22 Watts per meter squared per Hertz.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn m54(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_M54, Some(0.0)).unwrap()}
  }
  /// Daily Y10.7 index for 85-90 km heating of N2, O2, H2O, NO by solar coronal. 0.1-0.8 nm and Lya 121 nm emissions in x10-22 Watts per meter squared per Hertz.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn y10(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_Y10, Some(0.0)).unwrap()}
  }
  /// 54 day Y10.7 index for 85-90 km heating of N2, O2, H2O, NO by solar coronal. 0.1-0.8 nm and Lya 121 nm emissions in x10-22 Watts per meter squared per Hertz.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn y54(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_Y54, Some(0.0)).unwrap()}
  }
  /// Daily solar 10.7 cm radio flux in x10-22 Watts per meter squared per Hertz.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn f10(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_F10, Some(0.0)).unwrap()}
  }
  /// 54 day solar 10.7 cm radio flux in x10-22 Watts per meter squared per Hertz.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn f54(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_F54, Some(0.0)).unwrap()}
  }
  /// 81 day solar 10.7 cm radio flux in x10-22 Watts per meter squared per Hertz.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn f81(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_F81, Some(0.0)).unwrap()}
  }
  /// Ap is the planetary geomagnetic 2 nT index (00-21 UT) for the timespan specified in apDuration. If apDuration is null, a 3 hour duration should be assumed.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ap(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_AP, Some(0.0)).unwrap()}
  }
  /// The time, in hours, for which the Ap index value is valid. If null, a span of 3 hours is assumed.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn apDuration(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SGI_Abridged::VT_APDURATION, Some(0)).unwrap()}
  }
  /// The maximum measured K-Index at the associated station during the kpDuration timespan. The K-Index is a unitless measure (0 - 9) of the deviation in the Earth's magnetic field from normal at the station geographic location, with 0 indicating the absence of geomagnetic disturbance, and 9 indicating the most significant disturbance. If kpDuration is null, a 3 hour duration should be assumed.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn kIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SGI_Abridged::VT_KINDEX, Some(0)).unwrap()}
  }
  /// The Planetary K-index (Kp) over the kpDuration timespan. The Kp-Index is the average K-Index for the entire Earth, utilizing a unitless scale (0-9, in incremenets of 1/3), with 0 indicating the absence of geomagnetic disturbance, and 9 indicating the most significant disturbance. If kpDuration is null, a 3 hour duration should be assumed.
  /// Example: /// Example: 4.66
  /// Constraints: No constraints specified.
  #[inline]
  pub fn kp(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_KP, Some(0.0)).unwrap()}
  }
  /// The time, in hours, over which the K, Kp, and/or gamma index values are measured.  If null, a span of 3 hours is assumed.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn kpDuration(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SGI_Abridged::VT_KPDURATION, Some(0)).unwrap()}
  }
  /// The maximum measured gamma deflection during the kpDuration timespan. If kpDuration is null, a 3 hour duration should be assumed.
  /// Example: /// Example: 25
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gamma(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SGI_Abridged::VT_GAMMA, Some(0)).unwrap()}
  }
  /// Disturbance Storm Time geomagnetic index in nT.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dst(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_DST, Some(0.0)).unwrap()}
  }
  /// delta exospheric temperature correction in units of K.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dtc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_DTC, Some(0.0)).unwrap()}
  }
  /// Region code for the associated radiation belt index. This is the code associated with the corresponding radiation belt location. See the provider card for reference to specific region code definitions.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rbRegionCode(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SGI_Abridged::VT_RBREGIONCODE, Some(0)).unwrap()}
  }
  /// The value of the radiation belt index. This is the ratio of current intensity of a radiation belt to long-term average value. It's long-term average should be close to 1. Depending on the type of belt sensor, this ratio may measure Flux (number of particles / (cm^2 sec energy solid-angle)), dose rate (rad per second), or relative counts of particles per time (counts per second). The index value may also be normalized, the normalization value typically represents an average of the sensor measurements taken within a region over a given time interval. See the normFactor field for the specific normalization factor, if provided.
  /// Example: /// Example: 1.02947164506
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rbIndex(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_RBINDEX, Some(0.0)).unwrap()}
  }
  /// The normalization factor that has already been applied to the index value prior to record ingest. Typically used to normalize the index value to a particular interval. Units of the normalization factor may vary depending on the provider of this data (REACH, POES, CEASE3, etc.).
  /// Example: /// Example: 2.12679e-07
  /// Constraints: No constraints specified.
  #[inline]
  pub fn normFactor(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_NORMFACTOR, Some(0.0)).unwrap()}
  }
  /// The timespan over which the associated radiation belt index is factored. If rbDuration is null, a 24 hour duration should be assumed. Note: rbDuration defines the length of the time window for this data record. The time window start time is defined by sgiDate, and the time window end time is defined by sgiDate plus rbDuration.
  /// Example: /// Example: 24
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rbDuration(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SGI_Abridged::VT_RBDURATION, Some(0)).unwrap()}
  }
  /// Signal analyzer's input attenuation level, in decibels. Attenuation is a setting on the hardware that measures the power of a signal.
  /// Example: /// Example: 5.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn analyzerAttenuation(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SGI_Abridged::VT_ANALYZERATTENUATION, Some(0.0)).unwrap()}
  }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  /// Example: /// Example: rawFileURI
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn rawFileURI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_RAWFILEURI, None)}
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn transactionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_TRANSACTIONID, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> SGI_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SGI_Abridged_dataMode_Enum>(SGI_Abridged::VT_DATAMODE, Some(SGI_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SGI_Abridged::VT_CREATEDBY, None)}
  }
}

impl flatbuffers::Verifiable for SGI_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("effectiveDate", Self::VT_EFFECTIVEDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sgiDate", Self::VT_SGIDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<SGI_Abridged_state_Enum>("state", Self::VT_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stationName", Self::VT_STATIONNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor", Self::VT_IDSENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId", Self::VT_ORIGSENSORID, false)?
     .visit_field::<i32>("mode", Self::VT_MODE, false)?
     .visit_field::<SGI_Abridged_precedence_Enum>("precedence", Self::VT_PRECEDENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("coeffDegree", Self::VT_COEFFDEGREE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("coeffOrder", Self::VT_COEFFORDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ctce", Self::VT_CTCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("stce", Self::VT_STCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ctci", Self::VT_CTCI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("stci", Self::VT_STCI, false)?
     .visit_field::<f64>("e10", Self::VT_E10, false)?
     .visit_field::<f64>("e54", Self::VT_E54, false)?
     .visit_field::<f64>("s10", Self::VT_S10, false)?
     .visit_field::<f64>("s54", Self::VT_S54, false)?
     .visit_field::<f64>("m10", Self::VT_M10, false)?
     .visit_field::<f64>("m54", Self::VT_M54, false)?
     .visit_field::<f64>("y10", Self::VT_Y10, false)?
     .visit_field::<f64>("y54", Self::VT_Y54, false)?
     .visit_field::<f64>("f10", Self::VT_F10, false)?
     .visit_field::<f64>("f54", Self::VT_F54, false)?
     .visit_field::<f64>("f81", Self::VT_F81, false)?
     .visit_field::<f64>("ap", Self::VT_AP, false)?
     .visit_field::<i32>("apDuration", Self::VT_APDURATION, false)?
     .visit_field::<i32>("kIndex", Self::VT_KINDEX, false)?
     .visit_field::<f64>("kp", Self::VT_KP, false)?
     .visit_field::<i32>("kpDuration", Self::VT_KPDURATION, false)?
     .visit_field::<i32>("gamma", Self::VT_GAMMA, false)?
     .visit_field::<f64>("dst", Self::VT_DST, false)?
     .visit_field::<f64>("dtc", Self::VT_DTC, false)?
     .visit_field::<i32>("rbRegionCode", Self::VT_RBREGIONCODE, false)?
     .visit_field::<f64>("rbIndex", Self::VT_RBINDEX, false)?
     .visit_field::<f64>("normFactor", Self::VT_NORMFACTOR, false)?
     .visit_field::<i32>("rbDuration", Self::VT_RBDURATION, false)?
     .visit_field::<f64>("analyzerAttenuation", Self::VT_ANALYZERATTENUATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawFileURI", Self::VT_RAWFILEURI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transactionId", Self::VT_TRANSACTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<SGI_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .finish();
    Ok(())
  }
}
pub struct SGI_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub effectiveDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sgiDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub state: SGI_Abridged_state_Enum,
    pub stationName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mode: i32,
    pub precedence: SGI_Abridged_precedence_Enum,
    pub coeffDegree: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub coeffOrder: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ctce: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub stce: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ctci: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub stci: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub e10: f64,
    pub e54: f64,
    pub s10: f64,
    pub s54: f64,
    pub m10: f64,
    pub m54: f64,
    pub y10: f64,
    pub y54: f64,
    pub f10: f64,
    pub f54: f64,
    pub f81: f64,
    pub ap: f64,
    pub apDuration: i32,
    pub kIndex: i32,
    pub kp: f64,
    pub kpDuration: i32,
    pub gamma: i32,
    pub dst: f64,
    pub dtc: f64,
    pub rbRegionCode: i32,
    pub rbIndex: f64,
    pub normFactor: f64,
    pub rbDuration: i32,
    pub analyzerAttenuation: f64,
    pub rawFileURI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transactionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: SGI_Abridged_dataMode_Enum,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SGI_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    SGI_AbridgedArgs {
      id: None,
      classificationMarking: None,
      effectiveDate: None,
      sgiDate: None,
      type_: None,
      state: SGI_Abridged_state_Enum::I,
      stationName: None,
      idSensor: None,
      origSensorId: None,
      mode: 0,
      precedence: SGI_Abridged_precedence_Enum::O,
      coeffDegree: None,
      coeffOrder: None,
      ctce: None,
      stce: None,
      ctci: None,
      stci: None,
      e10: 0.0,
      e54: 0.0,
      s10: 0.0,
      s54: 0.0,
      m10: 0.0,
      m54: 0.0,
      y10: 0.0,
      y54: 0.0,
      f10: 0.0,
      f54: 0.0,
      f81: 0.0,
      ap: 0.0,
      apDuration: 0,
      kIndex: 0,
      kp: 0.0,
      kpDuration: 0,
      gamma: 0,
      dst: 0.0,
      dtc: 0.0,
      rbRegionCode: 0,
      rbIndex: 0.0,
      normFactor: 0.0,
      rbDuration: 0,
      analyzerAttenuation: 0.0,
      rawFileURI: None,
      transactionId: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: SGI_Abridged_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
    }
  }
}

pub struct SGI_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SGI_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_effectiveDate(&mut self, effectiveDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_EFFECTIVEDATE, effectiveDate);
  }
  #[inline]
  pub fn add_sgiDate(&mut self, sgiDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_SGIDATE, sgiDate);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_state(&mut self, state: SGI_Abridged_state_Enum) {
    self.fbb_.push_slot::<SGI_Abridged_state_Enum>(SGI_Abridged::VT_STATE, state, SGI_Abridged_state_Enum::I);
  }
  #[inline]
  pub fn add_stationName(&mut self, stationName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_STATIONNAME, stationName);
  }
  #[inline]
  pub fn add_idSensor(&mut self, idSensor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_IDSENSOR, idSensor);
  }
  #[inline]
  pub fn add_origSensorId(&mut self, origSensorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_ORIGSENSORID, origSensorId);
  }
  #[inline]
  pub fn add_mode(&mut self, mode: i32) {
    self.fbb_.push_slot::<i32>(SGI_Abridged::VT_MODE, mode, 0);
  }
  #[inline]
  pub fn add_precedence(&mut self, precedence: SGI_Abridged_precedence_Enum) {
    self.fbb_.push_slot::<SGI_Abridged_precedence_Enum>(SGI_Abridged::VT_PRECEDENCE, precedence, SGI_Abridged_precedence_Enum::O);
  }
  #[inline]
  pub fn add_coeffDegree(&mut self, coeffDegree: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_COEFFDEGREE, coeffDegree);
  }
  #[inline]
  pub fn add_coeffOrder(&mut self, coeffOrder: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_COEFFORDER, coeffOrder);
  }
  #[inline]
  pub fn add_ctce(&mut self, ctce: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_CTCE, ctce);
  }
  #[inline]
  pub fn add_stce(&mut self, stce: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_STCE, stce);
  }
  #[inline]
  pub fn add_ctci(&mut self, ctci: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_CTCI, ctci);
  }
  #[inline]
  pub fn add_stci(&mut self, stci: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_STCI, stci);
  }
  #[inline]
  pub fn add_e10(&mut self, e10: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_E10, e10, 0.0);
  }
  #[inline]
  pub fn add_e54(&mut self, e54: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_E54, e54, 0.0);
  }
  #[inline]
  pub fn add_s10(&mut self, s10: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_S10, s10, 0.0);
  }
  #[inline]
  pub fn add_s54(&mut self, s54: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_S54, s54, 0.0);
  }
  #[inline]
  pub fn add_m10(&mut self, m10: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_M10, m10, 0.0);
  }
  #[inline]
  pub fn add_m54(&mut self, m54: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_M54, m54, 0.0);
  }
  #[inline]
  pub fn add_y10(&mut self, y10: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_Y10, y10, 0.0);
  }
  #[inline]
  pub fn add_y54(&mut self, y54: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_Y54, y54, 0.0);
  }
  #[inline]
  pub fn add_f10(&mut self, f10: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_F10, f10, 0.0);
  }
  #[inline]
  pub fn add_f54(&mut self, f54: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_F54, f54, 0.0);
  }
  #[inline]
  pub fn add_f81(&mut self, f81: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_F81, f81, 0.0);
  }
  #[inline]
  pub fn add_ap(&mut self, ap: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_AP, ap, 0.0);
  }
  #[inline]
  pub fn add_apDuration(&mut self, apDuration: i32) {
    self.fbb_.push_slot::<i32>(SGI_Abridged::VT_APDURATION, apDuration, 0);
  }
  #[inline]
  pub fn add_kIndex(&mut self, kIndex: i32) {
    self.fbb_.push_slot::<i32>(SGI_Abridged::VT_KINDEX, kIndex, 0);
  }
  #[inline]
  pub fn add_kp(&mut self, kp: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_KP, kp, 0.0);
  }
  #[inline]
  pub fn add_kpDuration(&mut self, kpDuration: i32) {
    self.fbb_.push_slot::<i32>(SGI_Abridged::VT_KPDURATION, kpDuration, 0);
  }
  #[inline]
  pub fn add_gamma(&mut self, gamma: i32) {
    self.fbb_.push_slot::<i32>(SGI_Abridged::VT_GAMMA, gamma, 0);
  }
  #[inline]
  pub fn add_dst(&mut self, dst: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_DST, dst, 0.0);
  }
  #[inline]
  pub fn add_dtc(&mut self, dtc: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_DTC, dtc, 0.0);
  }
  #[inline]
  pub fn add_rbRegionCode(&mut self, rbRegionCode: i32) {
    self.fbb_.push_slot::<i32>(SGI_Abridged::VT_RBREGIONCODE, rbRegionCode, 0);
  }
  #[inline]
  pub fn add_rbIndex(&mut self, rbIndex: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_RBINDEX, rbIndex, 0.0);
  }
  #[inline]
  pub fn add_normFactor(&mut self, normFactor: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_NORMFACTOR, normFactor, 0.0);
  }
  #[inline]
  pub fn add_rbDuration(&mut self, rbDuration: i32) {
    self.fbb_.push_slot::<i32>(SGI_Abridged::VT_RBDURATION, rbDuration, 0);
  }
  #[inline]
  pub fn add_analyzerAttenuation(&mut self, analyzerAttenuation: f64) {
    self.fbb_.push_slot::<f64>(SGI_Abridged::VT_ANALYZERATTENUATION, analyzerAttenuation, 0.0);
  }
  #[inline]
  pub fn add_rawFileURI(&mut self, rawFileURI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_RAWFILEURI, rawFileURI);
  }
  #[inline]
  pub fn add_transactionId(&mut self, transactionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_TRANSACTIONID, transactionId);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: SGI_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<SGI_Abridged_dataMode_Enum>(SGI_Abridged::VT_DATAMODE, dataMode, SGI_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SGI_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SGI_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SGI_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SGI_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SGI_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SGI_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("effectiveDate", &self.effectiveDate());
      ds.field("sgiDate", &self.sgiDate());
      ds.field("type_", &self.type_());
      ds.field("state", &self.state());
      ds.field("stationName", &self.stationName());
      ds.field("idSensor", &self.idSensor());
      ds.field("origSensorId", &self.origSensorId());
      ds.field("mode", &self.mode());
      ds.field("precedence", &self.precedence());
      ds.field("coeffDegree", &self.coeffDegree());
      ds.field("coeffOrder", &self.coeffOrder());
      ds.field("ctce", &self.ctce());
      ds.field("stce", &self.stce());
      ds.field("ctci", &self.ctci());
      ds.field("stci", &self.stci());
      ds.field("e10", &self.e10());
      ds.field("e54", &self.e54());
      ds.field("s10", &self.s10());
      ds.field("s54", &self.s54());
      ds.field("m10", &self.m10());
      ds.field("m54", &self.m54());
      ds.field("y10", &self.y10());
      ds.field("y54", &self.y54());
      ds.field("f10", &self.f10());
      ds.field("f54", &self.f54());
      ds.field("f81", &self.f81());
      ds.field("ap", &self.ap());
      ds.field("apDuration", &self.apDuration());
      ds.field("kIndex", &self.kIndex());
      ds.field("kp", &self.kp());
      ds.field("kpDuration", &self.kpDuration());
      ds.field("gamma", &self.gamma());
      ds.field("dst", &self.dst());
      ds.field("dtc", &self.dtc());
      ds.field("rbRegionCode", &self.rbRegionCode());
      ds.field("rbIndex", &self.rbIndex());
      ds.field("normFactor", &self.normFactor());
      ds.field("rbDuration", &self.rbDuration());
      ds.field("analyzerAttenuation", &self.analyzerAttenuation());
      ds.field("rawFileURI", &self.rawFileURI());
      ds.field("transactionId", &self.transactionId());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SGI_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub effectiveDate: Option<String>,
  pub sgiDate: Option<String>,
  pub type_: Option<String>,
  pub state: SGI_Abridged_state_Enum,
  pub stationName: Option<String>,
  pub idSensor: Option<String>,
  pub origSensorId: Option<String>,
  pub mode: i32,
  pub precedence: SGI_Abridged_precedence_Enum,
  pub coeffDegree: Option<Vec<String>>,
  pub coeffOrder: Option<Vec<String>>,
  pub ctce: Option<Vec<String>>,
  pub stce: Option<Vec<String>>,
  pub ctci: Option<Vec<String>>,
  pub stci: Option<Vec<String>>,
  pub e10: f64,
  pub e54: f64,
  pub s10: f64,
  pub s54: f64,
  pub m10: f64,
  pub m54: f64,
  pub y10: f64,
  pub y54: f64,
  pub f10: f64,
  pub f54: f64,
  pub f81: f64,
  pub ap: f64,
  pub apDuration: i32,
  pub kIndex: i32,
  pub kp: f64,
  pub kpDuration: i32,
  pub gamma: i32,
  pub dst: f64,
  pub dtc: f64,
  pub rbRegionCode: i32,
  pub rbIndex: f64,
  pub normFactor: f64,
  pub rbDuration: i32,
  pub analyzerAttenuation: f64,
  pub rawFileURI: Option<String>,
  pub transactionId: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: SGI_Abridged_dataMode_Enum,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
}
impl Default for SGI_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      effectiveDate: None,
      sgiDate: None,
      type_: None,
      state: SGI_Abridged_state_Enum::I,
      stationName: None,
      idSensor: None,
      origSensorId: None,
      mode: 0,
      precedence: SGI_Abridged_precedence_Enum::O,
      coeffDegree: None,
      coeffOrder: None,
      ctce: None,
      stce: None,
      ctci: None,
      stci: None,
      e10: 0.0,
      e54: 0.0,
      s10: 0.0,
      s54: 0.0,
      m10: 0.0,
      m54: 0.0,
      y10: 0.0,
      y54: 0.0,
      f10: 0.0,
      f54: 0.0,
      f81: 0.0,
      ap: 0.0,
      apDuration: 0,
      kIndex: 0,
      kp: 0.0,
      kpDuration: 0,
      gamma: 0,
      dst: 0.0,
      dtc: 0.0,
      rbRegionCode: 0,
      rbIndex: 0.0,
      normFactor: 0.0,
      rbDuration: 0,
      analyzerAttenuation: 0.0,
      rawFileURI: None,
      transactionId: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: SGI_Abridged_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
    }
  }
}
impl SGI_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SGI_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let effectiveDate = self.effectiveDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sgiDate = self.sgiDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let state = self.state;
    let stationName = self.stationName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor = self.idSensor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId = self.origSensorId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mode = self.mode;
    let precedence = self.precedence;
    let coeffDegree = self.coeffDegree.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let coeffOrder = self.coeffOrder.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ctce = self.ctce.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let stce = self.stce.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ctci = self.ctci.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let stci = self.stci.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let e10 = self.e10;
    let e54 = self.e54;
    let s10 = self.s10;
    let s54 = self.s54;
    let m10 = self.m10;
    let m54 = self.m54;
    let y10 = self.y10;
    let y54 = self.y54;
    let f10 = self.f10;
    let f54 = self.f54;
    let f81 = self.f81;
    let ap = self.ap;
    let apDuration = self.apDuration;
    let kIndex = self.kIndex;
    let kp = self.kp;
    let kpDuration = self.kpDuration;
    let gamma = self.gamma;
    let dst = self.dst;
    let dtc = self.dtc;
    let rbRegionCode = self.rbRegionCode;
    let rbIndex = self.rbIndex;
    let normFactor = self.normFactor;
    let rbDuration = self.rbDuration;
    let analyzerAttenuation = self.analyzerAttenuation;
    let rawFileURI = self.rawFileURI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let transactionId = self.transactionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    SGI_Abridged::create(_fbb, &SGI_AbridgedArgs{
      id,
      classificationMarking,
      effectiveDate,
      sgiDate,
      type_,
      state,
      stationName,
      idSensor,
      origSensorId,
      mode,
      precedence,
      coeffDegree,
      coeffOrder,
      ctce,
      stce,
      ctci,
      stci,
      e10,
      e54,
      s10,
      s54,
      m10,
      m54,
      y10,
      y54,
      f10,
      f54,
      f81,
      ap,
      apDuration,
      kIndex,
      kp,
      kpDuration,
      gamma,
      dst,
      dtc,
      rbRegionCode,
      rbIndex,
      normFactor,
      rbDuration,
      analyzerAttenuation,
      rawFileURI,
      transactionId,
      source,
      origin,
      origNetwork,
      dataMode,
      createdAt,
      createdBy,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SGI_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sgi_abridged_unchecked`.
pub fn root_as_sgi_abridged(buf: &[u8]) -> Result<SGI_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SGI_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SGI_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_sgi_abridged_unchecked`.
pub fn size_prefixed_root_as_sgi_abridged(buf: &[u8]) -> Result<SGI_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SGI_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SGI_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sgi_abridged_unchecked`.
pub fn root_as_sgi_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SGI_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SGI_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SGI_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sgi_abridged_unchecked`.
pub fn size_prefixed_root_as_sgi_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SGI_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SGI_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SGI_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SGI_Abridged`.
pub unsafe fn root_as_sgi_abridged_unchecked(buf: &[u8]) -> SGI_Abridged {
  flatbuffers::root_unchecked::<SGI_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SGI_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SGI_Abridged`.
pub unsafe fn size_prefixed_root_as_sgi_abridged_unchecked(buf: &[u8]) -> SGI_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<SGI_Abridged>(buf)
}
pub const SGI_ABRIDGED_IDENTIFIER: &str = "SGIA";

#[inline]
pub fn sgi_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SGI_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn sgi_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SGI_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_sgi_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<SGI_Abridged<'a>>) {
  fbb.finish(root, Some(SGI_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_sgi_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<SGI_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(SGI_ABRIDGED_IDENTIFIER));
}
