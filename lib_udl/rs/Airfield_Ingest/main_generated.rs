// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AIRFIELD_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AIRFIELD_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AIRFIELD_INGEST_DATA_MODE_ENUM: [Airfield_Ingest_dataMode_Enum; 4] = [
  Airfield_Ingest_dataMode_Enum::REAL,
  Airfield_Ingest_dataMode_Enum::TEST,
  Airfield_Ingest_dataMode_Enum::SIMULATED,
  Airfield_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Airfield_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Airfield_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Airfield_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Airfield_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Airfield_Ingest_dataMode_Enum {
    type Output = Airfield_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Airfield_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Airfield_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Airfield_Ingest_dataMode_Enum {}
pub enum Airfield_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Properties and characteristics of an airfield, which includes location, airfield codes, suitability codes, and remarks.
pub struct Airfield_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Airfield_Ingest<'a> {
  type Inner = Airfield_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Airfield_Ingest<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDSITE: flatbuffers::VOffsetT = 8;
  pub const VT_ALTAIRFIELDID: flatbuffers::VOffsetT = 10;
  pub const VT_WACINNR: flatbuffers::VOffsetT = 12;
  pub const VT_ZARID: flatbuffers::VOffsetT = 14;
  pub const VT_ICAO: flatbuffers::VOffsetT = 16;
  pub const VT_IATA: flatbuffers::VOffsetT = 18;
  pub const VT_FAA: flatbuffers::VOffsetT = 20;
  pub const VT_HOSTNATCODE: flatbuffers::VOffsetT = 22;
  pub const VT_NAME: flatbuffers::VOffsetT = 24;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 26;
  pub const VT_LAT: flatbuffers::VOffsetT = 28;
  pub const VT_LON: flatbuffers::VOffsetT = 30;
  pub const VT_ELEVFT: flatbuffers::VOffsetT = 32;
  pub const VT_ELEVM: flatbuffers::VOffsetT = 34;
  pub const VT_MAGDEC: flatbuffers::VOffsetT = 36;
  pub const VT_REGIONNAME: flatbuffers::VOffsetT = 38;
  pub const VT_COUNTRYCODE: flatbuffers::VOffsetT = 40;
  pub const VT_CITY: flatbuffers::VOffsetT = 42;
  pub const VT_STATE: flatbuffers::VOffsetT = 44;
  pub const VT_GEOLOC: flatbuffers::VOffsetT = 46;
  pub const VT_GMTOFFSET: flatbuffers::VOffsetT = 48;
  pub const VT_SUITABILITYCODES: flatbuffers::VOffsetT = 50;
  pub const VT_MISCCODES: flatbuffers::VOffsetT = 52;
  pub const VT_RUNWAYS: flatbuffers::VOffsetT = 54;
  pub const VT_MAXRUNWAYLENGTH: flatbuffers::VOffsetT = 56;
  pub const VT_INFOURL: flatbuffers::VOffsetT = 58;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 60;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 62;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 64;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 66;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 68;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 70;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 72;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Airfield_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Airfield_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<Airfield_Ingest<'bldr>> {
    let mut builder = Airfield_IngestBuilder::new(_fbb);
    builder.add_magDec(args.magDec);
    builder.add_elevM(args.elevM);
    builder.add_elevFt(args.elevFt);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.infoURL { builder.add_infoURL(x); }
    builder.add_maxRunwayLength(args.maxRunwayLength);
    builder.add_runways(args.runways);
    if let Some(x) = args.miscCodes { builder.add_miscCodes(x); }
    if let Some(x) = args.suitabilityCodes { builder.add_suitabilityCodes(x); }
    if let Some(x) = args.gmtOffset { builder.add_gmtOffset(x); }
    if let Some(x) = args.geoloc { builder.add_geoloc(x); }
    if let Some(x) = args.state { builder.add_state(x); }
    if let Some(x) = args.city { builder.add_city(x); }
    if let Some(x) = args.countryCode { builder.add_countryCode(x); }
    if let Some(x) = args.regionName { builder.add_regionName(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.hostNatCode { builder.add_hostNatCode(x); }
    if let Some(x) = args.faa { builder.add_faa(x); }
    if let Some(x) = args.iata { builder.add_iata(x); }
    if let Some(x) = args.icao { builder.add_icao(x); }
    if let Some(x) = args.zarId { builder.add_zarId(x); }
    if let Some(x) = args.wacINNR { builder.add_wacINNR(x); }
    if let Some(x) = args.altAirfieldId { builder.add_altAirfieldId(x); }
    if let Some(x) = args.idSite { builder.add_idSite(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> Airfield_IngestT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idSite = self.idSite().map(|x| {
      x.to_string()
    });
    let altAirfieldId = self.altAirfieldId().map(|x| {
      x.to_string()
    });
    let wacINNR = self.wacINNR().map(|x| {
      x.to_string()
    });
    let zarId = self.zarId().map(|x| {
      x.to_string()
    });
    let icao = self.icao().map(|x| {
      x.to_string()
    });
    let iata = self.iata().map(|x| {
      x.to_string()
    });
    let faa = self.faa().map(|x| {
      x.to_string()
    });
    let hostNatCode = self.hostNatCode().map(|x| {
      x.to_string()
    });
    let name = self.name().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let lat = self.lat();
    let lon = self.lon();
    let elevFt = self.elevFt();
    let elevM = self.elevM();
    let magDec = self.magDec();
    let regionName = self.regionName().map(|x| {
      x.to_string()
    });
    let countryCode = self.countryCode().map(|x| {
      x.to_string()
    });
    let city = self.city().map(|x| {
      x.to_string()
    });
    let state = self.state().map(|x| {
      x.to_string()
    });
    let geoloc = self.geoloc().map(|x| {
      x.to_string()
    });
    let gmtOffset = self.gmtOffset().map(|x| {
      x.to_string()
    });
    let suitabilityCodes = self.suitabilityCodes().map(|x| {
      x.to_string()
    });
    let miscCodes = self.miscCodes().map(|x| {
      x.to_string()
    });
    let runways = self.runways();
    let maxRunwayLength = self.maxRunwayLength();
    let infoURL = self.infoURL().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    Airfield_IngestT {
      id,
      classificationMarking,
      idSite,
      altAirfieldId,
      wacINNR,
      zarId,
      icao,
      iata,
      faa,
      hostNatCode,
      name,
      type_,
      lat,
      lon,
      elevFt,
      elevM,
      magDec,
      regionName,
      countryCode,
      city,
      state,
      geoloc,
      gmtOffset,
      suitabilityCodes,
      miscCodes,
      runways,
      maxRunwayLength,
      infoURL,
      createdAt,
      createdBy,
      sourceDL,
      source,
      origin,
      origNetwork,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: 3f28f60b-3a50-2aef-ac88-8e9d0e39912b
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// The ID of the parent site.
  /// Example: /// Example: a150b3ee-884b-b9ac-60a0-6408b4b16088
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSite(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_IDSITE, None)}
  }
  /// Alternate Airfield identifier provided by source.
  /// Example: /// Example: 45301
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn altAirfieldId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_ALTAIRFIELDID, None)}
  }
  /// The airfield's World Area Code installation number (WAC-INNR).
  /// Example: /// Example: 0409-00039
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn wacINNR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_WACINNR, None)}
  }
  /// Air Mobility Command (AMC) Zone availability Report identifier.
  /// Example: /// Example: 231
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn zarId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_ZARID, None)}
  }
  /// The International Civil Aviation Organization (ICAO) code of the airfield.
  /// Example: /// Example: KCOS
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn icao(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_ICAO, None)}
  }
  /// The International Aviation Transport Association (IATA) code of the airfield.
  /// Example: /// Example: AAA
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn iata(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_IATA, None)}
  }
  /// The Federal Aviation Administration (FAA) location identifier of this airfield.
  /// Example: /// Example: FAA1
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn faa(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_FAA, None)}
  }
  /// The host nation code of this airfield, used for non-DoD/FAA locations.
  /// Example: /// Example: ZPU
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn hostNatCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_HOSTNATCODE, None)}
  }
  /// The name of the airfield.
  /// Example: /// Example: USAF Academy AFLD
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_NAME, None)}
  }
  /// The airfield activity use type (e.g. Commercial, Airport, Heliport, Gliderport, etc.).
  /// Example: /// Example: Commercial
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_TYPE_, None)}
  }
  /// WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Airfield_Ingest::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Airfield_Ingest::VT_LON, Some(0.0)).unwrap()}
  }
  /// Elevation of the airfield above mean sea level, in feet.
  /// Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 33.562
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevFt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Airfield_Ingest::VT_ELEVFT, Some(0.0)).unwrap()}
  }
  /// Elevation of the airfield above mean sea level, in meters.
  /// Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 10.29
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevM(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Airfield_Ingest::VT_ELEVM, Some(0.0)).unwrap()}
  }
  /// The magnetic declination/variation of the airfield's location from true north, in degrees.  Positive values east of true north and negative values west of true north.
  /// Example: /// Example: 7.35
  /// Constraints: No constraints specified.
  #[inline]
  pub fn magDec(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Airfield_Ingest::VT_MAGDEC, Some(0.0)).unwrap()}
  }
  /// Region where the airfield resides.
  /// Example: /// Example: North America
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn regionName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_REGIONNAME, None)}
  }
  /// The country code. This value is typically the ISO 3166 Alpha-2 two-character country code, however it can also represent various consortiums that do not appear in the ISO document. The code must correspond to an existing country in the UDL’s country API. Call udl/country/{code} to get any associated FIPS code, ISO Alpha-3 code, or alternate code values that exist for the specified country code.
  /// Example: /// Example: US
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn countryCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_COUNTRYCODE, None)}
  }
  /// Closest city to the airfield's location.
  /// Example: /// Example: Colorado Springs
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn city(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_CITY, None)}
  }
  /// State or province of the airfield's location.
  /// Example: /// Example: Colorado
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn state(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_STATE, None)}
  }
  /// Air Force geographic location code of the airfield.
  /// Example: /// Example: XLSX
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn geoloc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_GEOLOC, None)}
  }
  /// Time difference between the location of the airfield and the Greenwich Mean Time (GMT), expressed as +/-HH:MM. Time zones east of Greenwich have positive offsets and time zones west of Greenwich are negative.
  /// Example: /// Example: -4:30
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn gmtOffset(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_GMTOFFSET, None)}
  }
  /// Associated suitability codes according to the Airfield Suitability and Restrictions Report (ASRR) for this airfield.
  /// Example: /// Example: ABCDEF
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn suitabilityCodes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_SUITABILITYCODES, None)}
  }
  /// Applicable miscellaneous codes according to the Airfield Suitability and Restrictions Report (ASRR) for this airfield.
  /// Example: /// Example: AMZ
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn miscCodes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_MISCCODES, None)}
  }
  /// The number of runways at the site.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn runways(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Airfield_Ingest::VT_RUNWAYS, Some(0)).unwrap()}
  }
  /// The length of the longest runway at this airfield in feet.
  /// Example: /// Example: 1000
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxRunwayLength(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Airfield_Ingest::VT_MAXRUNWAYLENGTH, Some(0)).unwrap()}
  }
  /// The URL link to information about airfield.
  /// Example: /// Example: URL Link to the Airfield
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn infoURL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_INFOURL, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_CREATEDBY, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_SOURCEDL, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Airfield_Ingest::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> Airfield_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Airfield_Ingest_dataMode_Enum>(Airfield_Ingest::VT_DATAMODE, Some(Airfield_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Airfield_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSite", Self::VT_IDSITE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altAirfieldId", Self::VT_ALTAIRFIELDID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("wacINNR", Self::VT_WACINNR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zarId", Self::VT_ZARID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("icao", Self::VT_ICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iata", Self::VT_IATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("faa", Self::VT_FAA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hostNatCode", Self::VT_HOSTNATCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<f64>("elevFt", Self::VT_ELEVFT, false)?
     .visit_field::<f64>("elevM", Self::VT_ELEVM, false)?
     .visit_field::<f64>("magDec", Self::VT_MAGDEC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("regionName", Self::VT_REGIONNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("countryCode", Self::VT_COUNTRYCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("city", Self::VT_CITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("state", Self::VT_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("geoloc", Self::VT_GEOLOC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("gmtOffset", Self::VT_GMTOFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("suitabilityCodes", Self::VT_SUITABILITYCODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("miscCodes", Self::VT_MISCCODES, false)?
     .visit_field::<i32>("runways", Self::VT_RUNWAYS, false)?
     .visit_field::<i32>("maxRunwayLength", Self::VT_MAXRUNWAYLENGTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("infoURL", Self::VT_INFOURL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<Airfield_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct Airfield_IngestArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSite: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altAirfieldId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub wacINNR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zarId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub icao: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iata: Option<flatbuffers::WIPOffset<&'a str>>,
    pub faa: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hostNatCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lat: f64,
    pub lon: f64,
    pub elevFt: f64,
    pub elevM: f64,
    pub magDec: f64,
    pub regionName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub countryCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub city: Option<flatbuffers::WIPOffset<&'a str>>,
    pub state: Option<flatbuffers::WIPOffset<&'a str>>,
    pub geoloc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gmtOffset: Option<flatbuffers::WIPOffset<&'a str>>,
    pub suitabilityCodes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub miscCodes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub runways: i32,
    pub maxRunwayLength: i32,
    pub infoURL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: Airfield_Ingest_dataMode_Enum,
}
impl<'a> Default for Airfield_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    Airfield_IngestArgs {
      id: None,
      classificationMarking: None,
      idSite: None,
      altAirfieldId: None,
      wacINNR: None,
      zarId: None,
      icao: None,
      iata: None,
      faa: None,
      hostNatCode: None,
      name: None,
      type_: None,
      lat: 0.0,
      lon: 0.0,
      elevFt: 0.0,
      elevM: 0.0,
      magDec: 0.0,
      regionName: None,
      countryCode: None,
      city: None,
      state: None,
      geoloc: None,
      gmtOffset: None,
      suitabilityCodes: None,
      miscCodes: None,
      runways: 0,
      maxRunwayLength: 0,
      infoURL: None,
      createdAt: None,
      createdBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: Airfield_Ingest_dataMode_Enum::REAL,
    }
  }
}

pub struct Airfield_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Airfield_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idSite(&mut self, idSite: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_IDSITE, idSite);
  }
  #[inline]
  pub fn add_altAirfieldId(&mut self, altAirfieldId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_ALTAIRFIELDID, altAirfieldId);
  }
  #[inline]
  pub fn add_wacINNR(&mut self, wacINNR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_WACINNR, wacINNR);
  }
  #[inline]
  pub fn add_zarId(&mut self, zarId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_ZARID, zarId);
  }
  #[inline]
  pub fn add_icao(&mut self, icao: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_ICAO, icao);
  }
  #[inline]
  pub fn add_iata(&mut self, iata: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_IATA, iata);
  }
  #[inline]
  pub fn add_faa(&mut self, faa: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_FAA, faa);
  }
  #[inline]
  pub fn add_hostNatCode(&mut self, hostNatCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_HOSTNATCODE, hostNatCode);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(Airfield_Ingest::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(Airfield_Ingest::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_elevFt(&mut self, elevFt: f64) {
    self.fbb_.push_slot::<f64>(Airfield_Ingest::VT_ELEVFT, elevFt, 0.0);
  }
  #[inline]
  pub fn add_elevM(&mut self, elevM: f64) {
    self.fbb_.push_slot::<f64>(Airfield_Ingest::VT_ELEVM, elevM, 0.0);
  }
  #[inline]
  pub fn add_magDec(&mut self, magDec: f64) {
    self.fbb_.push_slot::<f64>(Airfield_Ingest::VT_MAGDEC, magDec, 0.0);
  }
  #[inline]
  pub fn add_regionName(&mut self, regionName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_REGIONNAME, regionName);
  }
  #[inline]
  pub fn add_countryCode(&mut self, countryCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_COUNTRYCODE, countryCode);
  }
  #[inline]
  pub fn add_city(&mut self, city: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_CITY, city);
  }
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_STATE, state);
  }
  #[inline]
  pub fn add_geoloc(&mut self, geoloc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_GEOLOC, geoloc);
  }
  #[inline]
  pub fn add_gmtOffset(&mut self, gmtOffset: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_GMTOFFSET, gmtOffset);
  }
  #[inline]
  pub fn add_suitabilityCodes(&mut self, suitabilityCodes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_SUITABILITYCODES, suitabilityCodes);
  }
  #[inline]
  pub fn add_miscCodes(&mut self, miscCodes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_MISCCODES, miscCodes);
  }
  #[inline]
  pub fn add_runways(&mut self, runways: i32) {
    self.fbb_.push_slot::<i32>(Airfield_Ingest::VT_RUNWAYS, runways, 0);
  }
  #[inline]
  pub fn add_maxRunwayLength(&mut self, maxRunwayLength: i32) {
    self.fbb_.push_slot::<i32>(Airfield_Ingest::VT_MAXRUNWAYLENGTH, maxRunwayLength, 0);
  }
  #[inline]
  pub fn add_infoURL(&mut self, infoURL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_INFOURL, infoURL);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Airfield_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Airfield_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<Airfield_Ingest_dataMode_Enum>(Airfield_Ingest::VT_DATAMODE, dataMode, Airfield_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Airfield_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Airfield_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Airfield_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Airfield_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Airfield_Ingest");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idSite", &self.idSite());
      ds.field("altAirfieldId", &self.altAirfieldId());
      ds.field("wacINNR", &self.wacINNR());
      ds.field("zarId", &self.zarId());
      ds.field("icao", &self.icao());
      ds.field("iata", &self.iata());
      ds.field("faa", &self.faa());
      ds.field("hostNatCode", &self.hostNatCode());
      ds.field("name", &self.name());
      ds.field("type_", &self.type_());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("elevFt", &self.elevFt());
      ds.field("elevM", &self.elevM());
      ds.field("magDec", &self.magDec());
      ds.field("regionName", &self.regionName());
      ds.field("countryCode", &self.countryCode());
      ds.field("city", &self.city());
      ds.field("state", &self.state());
      ds.field("geoloc", &self.geoloc());
      ds.field("gmtOffset", &self.gmtOffset());
      ds.field("suitabilityCodes", &self.suitabilityCodes());
      ds.field("miscCodes", &self.miscCodes());
      ds.field("runways", &self.runways());
      ds.field("maxRunwayLength", &self.maxRunwayLength());
      ds.field("infoURL", &self.infoURL());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("sourceDL", &self.sourceDL());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Airfield_IngestT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idSite: Option<String>,
  pub altAirfieldId: Option<String>,
  pub wacINNR: Option<String>,
  pub zarId: Option<String>,
  pub icao: Option<String>,
  pub iata: Option<String>,
  pub faa: Option<String>,
  pub hostNatCode: Option<String>,
  pub name: Option<String>,
  pub type_: Option<String>,
  pub lat: f64,
  pub lon: f64,
  pub elevFt: f64,
  pub elevM: f64,
  pub magDec: f64,
  pub regionName: Option<String>,
  pub countryCode: Option<String>,
  pub city: Option<String>,
  pub state: Option<String>,
  pub geoloc: Option<String>,
  pub gmtOffset: Option<String>,
  pub suitabilityCodes: Option<String>,
  pub miscCodes: Option<String>,
  pub runways: i32,
  pub maxRunwayLength: i32,
  pub infoURL: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub sourceDL: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: Airfield_Ingest_dataMode_Enum,
}
impl Default for Airfield_IngestT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idSite: None,
      altAirfieldId: None,
      wacINNR: None,
      zarId: None,
      icao: None,
      iata: None,
      faa: None,
      hostNatCode: None,
      name: None,
      type_: None,
      lat: 0.0,
      lon: 0.0,
      elevFt: 0.0,
      elevM: 0.0,
      magDec: 0.0,
      regionName: None,
      countryCode: None,
      city: None,
      state: None,
      geoloc: None,
      gmtOffset: None,
      suitabilityCodes: None,
      miscCodes: None,
      runways: 0,
      maxRunwayLength: 0,
      infoURL: None,
      createdAt: None,
      createdBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: Airfield_Ingest_dataMode_Enum::REAL,
    }
  }
}
impl Airfield_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Airfield_Ingest<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSite = self.idSite.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altAirfieldId = self.altAirfieldId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let wacINNR = self.wacINNR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let zarId = self.zarId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let icao = self.icao.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let iata = self.iata.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let faa = self.faa.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let hostNatCode = self.hostNatCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lat = self.lat;
    let lon = self.lon;
    let elevFt = self.elevFt;
    let elevM = self.elevM;
    let magDec = self.magDec;
    let regionName = self.regionName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let countryCode = self.countryCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let city = self.city.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let state = self.state.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let geoloc = self.geoloc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let gmtOffset = self.gmtOffset.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let suitabilityCodes = self.suitabilityCodes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let miscCodes = self.miscCodes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let runways = self.runways;
    let maxRunwayLength = self.maxRunwayLength;
    let infoURL = self.infoURL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    Airfield_Ingest::create(_fbb, &Airfield_IngestArgs{
      id,
      classificationMarking,
      idSite,
      altAirfieldId,
      wacINNR,
      zarId,
      icao,
      iata,
      faa,
      hostNatCode,
      name,
      type_,
      lat,
      lon,
      elevFt,
      elevM,
      magDec,
      regionName,
      countryCode,
      city,
      state,
      geoloc,
      gmtOffset,
      suitabilityCodes,
      miscCodes,
      runways,
      maxRunwayLength,
      infoURL,
      createdAt,
      createdBy,
      sourceDL,
      source,
      origin,
      origNetwork,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Airfield_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airfield_ingest_unchecked`.
pub fn root_as_airfield_ingest(buf: &[u8]) -> Result<Airfield_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Airfield_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Airfield_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_airfield_ingest_unchecked`.
pub fn size_prefixed_root_as_airfield_ingest(buf: &[u8]) -> Result<Airfield_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Airfield_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Airfield_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airfield_ingest_unchecked`.
pub fn root_as_airfield_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Airfield_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Airfield_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Airfield_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airfield_ingest_unchecked`.
pub fn size_prefixed_root_as_airfield_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Airfield_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Airfield_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Airfield_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Airfield_Ingest`.
pub unsafe fn root_as_airfield_ingest_unchecked(buf: &[u8]) -> Airfield_Ingest {
  flatbuffers::root_unchecked::<Airfield_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Airfield_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Airfield_Ingest`.
pub unsafe fn size_prefixed_root_as_airfield_ingest_unchecked(buf: &[u8]) -> Airfield_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<Airfield_Ingest>(buf)
}
pub const AIRFIELD_INGEST_IDENTIFIER: &str = "AIRF";

#[inline]
pub fn airfield_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRFIELD_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn airfield_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRFIELD_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_airfield_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Airfield_Ingest<'a>>) {
  fbb.finish(root, Some(AIRFIELD_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_airfield_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Airfield_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(AIRFIELD_INGEST_IDENTIFIER));
}
