// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EOOBSERVATION_DETAILS_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EOOBSERVATION_DETAILS_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EOOBSERVATION_DETAILS_INGEST_DATA_MODE_ENUM: [EOObservationDetails_Ingest_dataMode_Enum; 4] = [
  EOObservationDetails_Ingest_dataMode_Enum::REAL,
  EOObservationDetails_Ingest_dataMode_Enum::TEST,
  EOObservationDetails_Ingest_dataMode_Enum::SIMULATED,
  EOObservationDetails_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EOObservationDetails_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl EOObservationDetails_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EOObservationDetails_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EOObservationDetails_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for EOObservationDetails_Ingest_dataMode_Enum {
    type Output = EOObservationDetails_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for EOObservationDetails_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EOObservationDetails_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EOObservationDetails_Ingest_dataMode_Enum {}
pub enum EOObservationDetails_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Model representation of additional detailed observation data for electro-optical based sensor phenomenologies.
pub struct EOObservationDetails_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EOObservationDetails_Ingest<'a> {
  type Inner = EOObservationDetails_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EOObservationDetails_Ingest<'a> {
  pub const VT_IDEOOBSERVATION: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_OBTIME: flatbuffers::VOffsetT = 8;
  pub const VT_PREDICTEDRA: flatbuffers::VOffsetT = 10;
  pub const VT_PREDICTEDDECLINATION: flatbuffers::VOffsetT = 12;
  pub const VT_PREDICTEDAZIMUTH: flatbuffers::VOffsetT = 14;
  pub const VT_PREDICTEDELEVATION: flatbuffers::VOffsetT = 16;
  pub const VT_SUNAZIMUTH: flatbuffers::VOffsetT = 18;
  pub const VT_SUNELEVATION: flatbuffers::VOffsetT = 20;
  pub const VT_NUMSPECTRALFILTERS: flatbuffers::VOffsetT = 22;
  pub const VT_SPECTRALFILTERS: flatbuffers::VOffsetT = 24;
  pub const VT_SPECTRALZMFL: flatbuffers::VOffsetT = 26;
  pub const VT_SPECTRALFILTERSOLARMAG: flatbuffers::VOffsetT = 28;
  pub const VT_ZEROPOINTS: flatbuffers::VOffsetT = 30;
  pub const VT_ZEROPOINTSUNC: flatbuffers::VOffsetT = 32;
  pub const VT_EXTINCTIONCOEFFS: flatbuffers::VOffsetT = 34;
  pub const VT_EXTINCTIONCOEFFSUNC: flatbuffers::VOffsetT = 36;
  pub const VT_COLORCOEFFS: flatbuffers::VOffsetT = 38;
  pub const VT_NUMNEUTRALDENSITYFILTERS: flatbuffers::VOffsetT = 40;
  pub const VT_NEUTRALDENSITYFILTERNAMES: flatbuffers::VOffsetT = 42;
  pub const VT_NEUTRALDENSITYFILTERTRANSMISSIONS: flatbuffers::VOffsetT = 44;
  pub const VT_NEUTRALDENSITYFILTERTRANSMISSIONSUNC: flatbuffers::VOffsetT = 46;
  pub const VT_GAIN: flatbuffers::VOffsetT = 48;
  pub const VT_IFOV: flatbuffers::VOffsetT = 50;
  pub const VT_PIXELARRAYWIDTH: flatbuffers::VOffsetT = 52;
  pub const VT_PIXELARRAYHEIGHT: flatbuffers::VOffsetT = 54;
  pub const VT_PIXELMIN: flatbuffers::VOffsetT = 56;
  pub const VT_PIXELMAX: flatbuffers::VOffsetT = 58;
  pub const VT_CENTROIDROW: flatbuffers::VOffsetT = 60;
  pub const VT_CENTROIDCOLUMN: flatbuffers::VOffsetT = 62;
  pub const VT_ROWVARIANCE: flatbuffers::VOffsetT = 64;
  pub const VT_COLUMNVARIANCE: flatbuffers::VOffsetT = 66;
  pub const VT_ROWCOLCOV: flatbuffers::VOffsetT = 68;
  pub const VT_DISTFROMSTREAKCENTER: flatbuffers::VOffsetT = 70;
  pub const VT_SURFBRIGHTNESS: flatbuffers::VOffsetT = 72;
  pub const VT_SURFBRIGHTNESSUNC: flatbuffers::VOffsetT = 74;
  pub const VT_TIMESUNC: flatbuffers::VOffsetT = 76;
  pub const VT_CCDTEMP: flatbuffers::VOffsetT = 78;
  pub const VT_CURRENTSPECTRALFILTERNUM: flatbuffers::VOffsetT = 80;
  pub const VT_CURRENTNEUTRALDENSITYFILTERNUM: flatbuffers::VOffsetT = 82;
  pub const VT_BINNINGHORIZ: flatbuffers::VOffsetT = 84;
  pub const VT_BINNINGVERT: flatbuffers::VOffsetT = 86;
  pub const VT_PCALNUMSTARS: flatbuffers::VOffsetT = 88;
  pub const VT_CCDOBJPOSX: flatbuffers::VOffsetT = 90;
  pub const VT_CCDOBJPOSY: flatbuffers::VOffsetT = 92;
  pub const VT_CCDOBJWIDTH: flatbuffers::VOffsetT = 94;
  pub const VT_BACKGROUNDSIGNAL: flatbuffers::VOffsetT = 96;
  pub const VT_BACKGROUNDSIGNALUNC: flatbuffers::VOffsetT = 98;
  pub const VT_PEAKAPERTURECOUNT: flatbuffers::VOffsetT = 100;
  pub const VT_PEAKBACKGROUNDCOUNT: flatbuffers::VOffsetT = 102;
  pub const VT_SNREST: flatbuffers::VOffsetT = 104;
  pub const VT_MAGINSTRUMENTAL: flatbuffers::VOffsetT = 106;
  pub const VT_MAGINSTRUMENTALUNC: flatbuffers::VOffsetT = 108;
  pub const VT_OPTICALCROSSSECTION: flatbuffers::VOffsetT = 110;
  pub const VT_OPTICALCROSSSECTIONUNC: flatbuffers::VOffsetT = 112;
  pub const VT_SUNSTATEPOSX: flatbuffers::VOffsetT = 114;
  pub const VT_SUNSTATEPOSY: flatbuffers::VOffsetT = 116;
  pub const VT_SUNSTATEPOSZ: flatbuffers::VOffsetT = 118;
  pub const VT_SUNSTATEVELX: flatbuffers::VOffsetT = 120;
  pub const VT_SUNSTATEVELY: flatbuffers::VOffsetT = 122;
  pub const VT_SUNSTATEVELZ: flatbuffers::VOffsetT = 124;
  pub const VT_NUMCATALOGSTARS: flatbuffers::VOffsetT = 126;
  pub const VT_NUMDETECTEDSTARS: flatbuffers::VOffsetT = 128;
  pub const VT_NUMCORRELATEDSTARS: flatbuffers::VOffsetT = 130;
  pub const VT_PREDICTEDRAUNC: flatbuffers::VOffsetT = 132;
  pub const VT_PREDICTEDDECLINATIONUNC: flatbuffers::VOffsetT = 134;
  pub const VT_RACOV: flatbuffers::VOffsetT = 136;
  pub const VT_DECLINATIONCOV: flatbuffers::VOffsetT = 138;
  pub const VT_RADECLINATIONCOV: flatbuffers::VOffsetT = 140;
  pub const VT_ACALCRPIXX: flatbuffers::VOffsetT = 142;
  pub const VT_ACALCRPIXY: flatbuffers::VOffsetT = 144;
  pub const VT_ACALCRVALX: flatbuffers::VOffsetT = 146;
  pub const VT_ACALCRVALY: flatbuffers::VOffsetT = 148;
  pub const VT_ACALNUMSTARS: flatbuffers::VOffsetT = 150;
  pub const VT_OBJSUNRANGE: flatbuffers::VOffsetT = 152;
  pub const VT_PHASEANGBISECT: flatbuffers::VOffsetT = 154;
  pub const VT_SOLARDISKFRAC: flatbuffers::VOffsetT = 156;
  pub const VT_TOES: flatbuffers::VOffsetT = 158;
  pub const VT_DOES: flatbuffers::VOffsetT = 160;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 162;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 164;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 166;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 168;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EOObservationDetails_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EOObservationDetails_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<EOObservationDetails_Ingest<'bldr>> {
    let mut builder = EOObservationDetails_IngestBuilder::new(_fbb);
    builder.add_does(args.does);
    builder.add_toes(args.toes);
    builder.add_solarDiskFrac(args.solarDiskFrac);
    builder.add_phaseAngBisect(args.phaseAngBisect);
    builder.add_objSunRange(args.objSunRange);
    builder.add_acalCrValY(args.acalCrValY);
    builder.add_acalCrValX(args.acalCrValX);
    builder.add_acalCrPixY(args.acalCrPixY);
    builder.add_acalCrPixX(args.acalCrPixX);
    builder.add_raDeclinationCov(args.raDeclinationCov);
    builder.add_declinationCov(args.declinationCov);
    builder.add_raCov(args.raCov);
    builder.add_predictedDeclinationUnc(args.predictedDeclinationUnc);
    builder.add_predictedRaUnc(args.predictedRaUnc);
    builder.add_sunStateVelZ(args.sunStateVelZ);
    builder.add_sunStateVelY(args.sunStateVelY);
    builder.add_sunStateVelX(args.sunStateVelX);
    builder.add_sunStatePosZ(args.sunStatePosZ);
    builder.add_sunStatePosY(args.sunStatePosY);
    builder.add_sunStatePosX(args.sunStatePosX);
    builder.add_opticalCrossSectionUnc(args.opticalCrossSectionUnc);
    builder.add_opticalCrossSection(args.opticalCrossSection);
    builder.add_magInstrumentalUnc(args.magInstrumentalUnc);
    builder.add_magInstrumental(args.magInstrumental);
    builder.add_snrEst(args.snrEst);
    builder.add_peakApertureCount(args.peakApertureCount);
    builder.add_backgroundSignalUnc(args.backgroundSignalUnc);
    builder.add_backgroundSignal(args.backgroundSignal);
    builder.add_ccdObjWidth(args.ccdObjWidth);
    builder.add_ccdObjPosY(args.ccdObjPosY);
    builder.add_ccdObjPosX(args.ccdObjPosX);
    builder.add_ccdTemp(args.ccdTemp);
    builder.add_timesUnc(args.timesUnc);
    builder.add_rowColCov(args.rowColCov);
    builder.add_columnVariance(args.columnVariance);
    builder.add_rowVariance(args.rowVariance);
    builder.add_centroidColumn(args.centroidColumn);
    builder.add_centroidRow(args.centroidRow);
    builder.add_ifov(args.ifov);
    builder.add_gain(args.gain);
    builder.add_sunElevation(args.sunElevation);
    builder.add_sunAzimuth(args.sunAzimuth);
    builder.add_predictedElevation(args.predictedElevation);
    builder.add_predictedAzimuth(args.predictedAzimuth);
    builder.add_predictedDeclination(args.predictedDeclination);
    builder.add_predictedRa(args.predictedRa);
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    builder.add_acalNumStars(args.acalNumStars);
    builder.add_numCorrelatedStars(args.numCorrelatedStars);
    builder.add_numDetectedStars(args.numDetectedStars);
    builder.add_numCatalogStars(args.numCatalogStars);
    builder.add_peakBackgroundCount(args.peakBackgroundCount);
    builder.add_pcalNumStars(args.pcalNumStars);
    builder.add_binningVert(args.binningVert);
    builder.add_binningHoriz(args.binningHoriz);
    builder.add_currentNeutralDensityFilterNum(args.currentNeutralDensityFilterNum);
    builder.add_currentSpectralFilterNum(args.currentSpectralFilterNum);
    if let Some(x) = args.surfBrightnessUnc { builder.add_surfBrightnessUnc(x); }
    if let Some(x) = args.surfBrightness { builder.add_surfBrightness(x); }
    if let Some(x) = args.distFromStreakCenter { builder.add_distFromStreakCenter(x); }
    builder.add_pixelMax(args.pixelMax);
    builder.add_pixelMin(args.pixelMin);
    builder.add_pixelArrayHeight(args.pixelArrayHeight);
    builder.add_pixelArrayWidth(args.pixelArrayWidth);
    if let Some(x) = args.neutralDensityFilterTransmissionsUnc { builder.add_neutralDensityFilterTransmissionsUnc(x); }
    if let Some(x) = args.neutralDensityFilterTransmissions { builder.add_neutralDensityFilterTransmissions(x); }
    if let Some(x) = args.neutralDensityFilterNames { builder.add_neutralDensityFilterNames(x); }
    builder.add_numNeutralDensityFilters(args.numNeutralDensityFilters);
    if let Some(x) = args.colorCoeffs { builder.add_colorCoeffs(x); }
    if let Some(x) = args.extinctionCoeffsUnc { builder.add_extinctionCoeffsUnc(x); }
    if let Some(x) = args.extinctionCoeffs { builder.add_extinctionCoeffs(x); }
    if let Some(x) = args.zeroPointsUnc { builder.add_zeroPointsUnc(x); }
    if let Some(x) = args.zeroPoints { builder.add_zeroPoints(x); }
    if let Some(x) = args.spectralFilterSolarMag { builder.add_spectralFilterSolarMag(x); }
    if let Some(x) = args.spectralZMFL { builder.add_spectralZMFL(x); }
    if let Some(x) = args.spectralFilters { builder.add_spectralFilters(x); }
    builder.add_numSpectralFilters(args.numSpectralFilters);
    if let Some(x) = args.obTime { builder.add_obTime(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.idEOObservation { builder.add_idEOObservation(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> EOObservationDetails_IngestT {
    let idEOObservation = self.idEOObservation().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let obTime = self.obTime().map(|x| {
      x.to_string()
    });
    let predictedRa = self.predictedRa();
    let predictedDeclination = self.predictedDeclination();
    let predictedAzimuth = self.predictedAzimuth();
    let predictedElevation = self.predictedElevation();
    let sunAzimuth = self.sunAzimuth();
    let sunElevation = self.sunElevation();
    let numSpectralFilters = self.numSpectralFilters();
    let spectralFilters = self.spectralFilters().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let spectralZMFL = self.spectralZMFL().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let spectralFilterSolarMag = self.spectralFilterSolarMag().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let zeroPoints = self.zeroPoints().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let zeroPointsUnc = self.zeroPointsUnc().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let extinctionCoeffs = self.extinctionCoeffs().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let extinctionCoeffsUnc = self.extinctionCoeffsUnc().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let colorCoeffs = self.colorCoeffs().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let numNeutralDensityFilters = self.numNeutralDensityFilters();
    let neutralDensityFilterNames = self.neutralDensityFilterNames().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let neutralDensityFilterTransmissions = self.neutralDensityFilterTransmissions().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let neutralDensityFilterTransmissionsUnc = self.neutralDensityFilterTransmissionsUnc().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let gain = self.gain();
    let ifov = self.ifov();
    let pixelArrayWidth = self.pixelArrayWidth();
    let pixelArrayHeight = self.pixelArrayHeight();
    let pixelMin = self.pixelMin();
    let pixelMax = self.pixelMax();
    let centroidRow = self.centroidRow();
    let centroidColumn = self.centroidColumn();
    let rowVariance = self.rowVariance();
    let columnVariance = self.columnVariance();
    let rowColCov = self.rowColCov();
    let distFromStreakCenter = self.distFromStreakCenter().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let surfBrightness = self.surfBrightness().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let surfBrightnessUnc = self.surfBrightnessUnc().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let timesUnc = self.timesUnc();
    let ccdTemp = self.ccdTemp();
    let currentSpectralFilterNum = self.currentSpectralFilterNum();
    let currentNeutralDensityFilterNum = self.currentNeutralDensityFilterNum();
    let binningHoriz = self.binningHoriz();
    let binningVert = self.binningVert();
    let pcalNumStars = self.pcalNumStars();
    let ccdObjPosX = self.ccdObjPosX();
    let ccdObjPosY = self.ccdObjPosY();
    let ccdObjWidth = self.ccdObjWidth();
    let backgroundSignal = self.backgroundSignal();
    let backgroundSignalUnc = self.backgroundSignalUnc();
    let peakApertureCount = self.peakApertureCount();
    let peakBackgroundCount = self.peakBackgroundCount();
    let snrEst = self.snrEst();
    let magInstrumental = self.magInstrumental();
    let magInstrumentalUnc = self.magInstrumentalUnc();
    let opticalCrossSection = self.opticalCrossSection();
    let opticalCrossSectionUnc = self.opticalCrossSectionUnc();
    let sunStatePosX = self.sunStatePosX();
    let sunStatePosY = self.sunStatePosY();
    let sunStatePosZ = self.sunStatePosZ();
    let sunStateVelX = self.sunStateVelX();
    let sunStateVelY = self.sunStateVelY();
    let sunStateVelZ = self.sunStateVelZ();
    let numCatalogStars = self.numCatalogStars();
    let numDetectedStars = self.numDetectedStars();
    let numCorrelatedStars = self.numCorrelatedStars();
    let predictedRaUnc = self.predictedRaUnc();
    let predictedDeclinationUnc = self.predictedDeclinationUnc();
    let raCov = self.raCov();
    let declinationCov = self.declinationCov();
    let raDeclinationCov = self.raDeclinationCov();
    let acalCrPixX = self.acalCrPixX();
    let acalCrPixY = self.acalCrPixY();
    let acalCrValX = self.acalCrValX();
    let acalCrValY = self.acalCrValY();
    let acalNumStars = self.acalNumStars();
    let objSunRange = self.objSunRange();
    let phaseAngBisect = self.phaseAngBisect();
    let solarDiskFrac = self.solarDiskFrac();
    let toes = self.toes();
    let does = self.does();
    let source = self.source().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    EOObservationDetails_IngestT {
      idEOObservation,
      classificationMarking,
      obTime,
      predictedRa,
      predictedDeclination,
      predictedAzimuth,
      predictedElevation,
      sunAzimuth,
      sunElevation,
      numSpectralFilters,
      spectralFilters,
      spectralZMFL,
      spectralFilterSolarMag,
      zeroPoints,
      zeroPointsUnc,
      extinctionCoeffs,
      extinctionCoeffsUnc,
      colorCoeffs,
      numNeutralDensityFilters,
      neutralDensityFilterNames,
      neutralDensityFilterTransmissions,
      neutralDensityFilterTransmissionsUnc,
      gain,
      ifov,
      pixelArrayWidth,
      pixelArrayHeight,
      pixelMin,
      pixelMax,
      centroidRow,
      centroidColumn,
      rowVariance,
      columnVariance,
      rowColCov,
      distFromStreakCenter,
      surfBrightness,
      surfBrightnessUnc,
      timesUnc,
      ccdTemp,
      currentSpectralFilterNum,
      currentNeutralDensityFilterNum,
      binningHoriz,
      binningVert,
      pcalNumStars,
      ccdObjPosX,
      ccdObjPosY,
      ccdObjWidth,
      backgroundSignal,
      backgroundSignalUnc,
      peakApertureCount,
      peakBackgroundCount,
      snrEst,
      magInstrumental,
      magInstrumentalUnc,
      opticalCrossSection,
      opticalCrossSectionUnc,
      sunStatePosX,
      sunStatePosY,
      sunStatePosZ,
      sunStateVelX,
      sunStateVelY,
      sunStateVelZ,
      numCatalogStars,
      numDetectedStars,
      numCorrelatedStars,
      predictedRaUnc,
      predictedDeclinationUnc,
      raCov,
      declinationCov,
      raDeclinationCov,
      acalCrPixX,
      acalCrPixY,
      acalCrValX,
      acalCrValY,
      acalNumStars,
      objSunRange,
      phaseAngBisect,
      solarDiskFrac,
      toes,
      does,
      source,
      dataMode,
      createdAt,
      createdBy,
    }
  }

  /// Unique identifier of the parent EOObservation.
  /// Example: /// Example: EOOBSERVATION-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn idEOObservation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOObservationDetails_Ingest::VT_IDEOOBSERVATION, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format, will be set to EOObservation classificationMarking if blank.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOObservationDetails_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Ob detection time in ISO 8601 UTC with microsecond precision, will be set to EOObservation obTime if blank.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOObservationDetails_Ingest::VT_OBTIME, None)}
  }
  /// Predicted Right Ascension of the Target object from the frame of reference of the sensor (J2000, geocentric velocity aberration). SGP4 and VCMs produce geocentric origin and velocity aberration and subtracting the sensor geocentric position of the sensor places in its reference frame.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn predictedRa(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDRA, Some(0.0)).unwrap()}
  }
  /// Predicted Declination of the Target object from the frame of reference of the sensor (J2000, geocentric velocity aberration). SGP4 and VCMs produce geocentric origin and velocity aberration and subtracting the sensor geocentric position of the sensor places in its reference frame.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn predictedDeclination(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDDECLINATION, Some(0.0)).unwrap()}
  }
  /// Predicted Azimuth angle of the target object from a ground -based sensor (no atmospheric refraction correction required). AZ_EL implies apparent topocentric place in true of date reference frame as seen from the observer with aberration due to the observer velocity and light travel time applied.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn predictedAzimuth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDAZIMUTH, Some(0.0)).unwrap()}
  }
  /// Predicted elevation angle of the target object from a ground -based sensor (no atmospheric refraction correction required). AZ_EL implies apparent topocentric place in true of date reference frame as seen from the observer with aberration due to the observer velocity and light travel time applied.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn predictedElevation(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDELEVATION, Some(0.0)).unwrap()}
  }
  /// Azimuth angle of the sun from a ground-based telescope (no atmospheric refraction correction required) the observer with aberration due to the observer velocity and light travel time applied.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sunAzimuth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_SUNAZIMUTH, Some(0.0)).unwrap()}
  }
  /// Elevation angle of the sun from a ground-based telescope (no atmospheric refraction correction required).
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sunElevation(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_SUNELEVATION, Some(0.0)).unwrap()}
  }
  /// The value is the number of spectral filters used.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numSpectralFilters(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_NUMSPECTRALFILTERS, Some(0)).unwrap()}
  }
  /// Array of the SpectralFilters keywords, must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.
  /// Example: /// Example: ['Keyword1', 'Keyword2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spectralFilters(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_SPECTRALFILTERS, None)}
  }
  /// This is the in-band average irradiance of a 0th mag source. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.  Units = W/m2/nm.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spectralZMFL(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_SPECTRALZMFL, None)}
  }
  /// This is the in-band solar magnitude at 1 A.U. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.  Units = mag.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spectralFilterSolarMag(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_SPECTRALFILTERSOLARMAG, None)}
  }
  /// This is the value for the zero-point calculated for each filter denoted in spectralFilters. It is the difference between the catalog mag and instrumental mag for a set of standard stars. For use with All Sky photometry. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zeroPoints(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_ZEROPOINTS, None)}
  }
  /// This is the uncertainty in the zero point for the filter denoted in spectralFilters. For use with All Sky photometry. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zeroPointsUnc(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_ZEROPOINTSUNC, None)}
  }
  /// The extinction coefficient computed for the nth filter. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n. Units = mag/airmass.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn extinctionCoeffs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_EXTINCTIONCOEFFS, None)}
  }
  /// This is the uncertainty in the extinction coefficient for the nth filter. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n. -9999 for space-based sensors. Units = mag/airmass.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn extinctionCoeffsUnc(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_EXTINCTIONCOEFFSUNC, None)}
  }
  /// Color coefficient for filter n for a space-based sensor where there is no atmospheric extinction. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn colorCoeffs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_COLORCOEFFS, None)}
  }
  /// The value is the number of neutral density filters used.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numNeutralDensityFilters(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_NUMNEUTRALDENSITYFILTERS, Some(0)).unwrap()}
  }
  /// Must be present for all values n=1 to numNeutralDensityFilters, in incrementing order of n, and for no other values of n.
  /// Example: /// Example: ['numNeutralDensityFilters1', 'numNeutralDensityFilters2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn neutralDensityFilterNames(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_NEUTRALDENSITYFILTERNAMES, None)}
  }
  /// The transmission of the nth neutral density filter. Must be present for all values n=1 to numNeutralDensityFilters, in incrementing order of n, and for no other values of n.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn neutralDensityFilterTransmissions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_NEUTRALDENSITYFILTERTRANSMISSIONS, None)}
  }
  /// This is the uncertainty in the transmission for the nth filter. Must be present for all values n=1 to numNeutralDensityFilters, in incrementing order of n, and for no other values of n.
  /// Example: /// Example: [1.1, 2.1, 3.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn neutralDensityFilterTransmissionsUnc(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_NEUTRALDENSITYFILTERTRANSMISSIONSUNC, None)}
  }
  /// Some sensors have gain settings. This value is the gain used during the observation in units e-/ADU. If no gain is used, the value = 1.
  /// Example: /// Example: 234.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gain(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_GAIN, Some(0.0)).unwrap()}
  }
  /// Sensor instantaneous field of view (ratio of pixel pitch to focal length).
  /// Example: /// Example: 0.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ifov(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_IFOV, Some(0.0)).unwrap()}
  }
  /// Pixel array size (width) in pixels.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pixelArrayWidth(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_PIXELARRAYWIDTH, Some(0)).unwrap()}
  }
  /// Pixel array size (height) in pixels.
  /// Example: /// Example: 23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pixelArrayHeight(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_PIXELARRAYHEIGHT, Some(0)).unwrap()}
  }
  /// Minimum valid pixel value, this is typically 0.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pixelMin(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_PIXELMIN, Some(0)).unwrap()}
  }
  /// Maximum valid pixel value, this is defined as 2^(number of bits per pixel). For example, a CCD with 8-bitpixels, would have a maximum valid pixel value of 2^8 = 256. This can represent the saturation value of the detector, but some sensors will saturate at a value significantly lower than full well depth. This is the analog-to-digital conversion (ADC) saturation value.
  /// Example: /// Example: 256
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pixelMax(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_PIXELMAX, Some(0)).unwrap()}
  }
  /// Observed centroid row number on the focal plane in pixels (0 is top edge, 0.5 is center of pixels along top of image).
  /// Example: /// Example: 0.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn centroidRow(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_CENTROIDROW, Some(0.0)).unwrap()}
  }
  /// Observed centroid column number on the focal plane in pixels (0 is left edge, 0.5 is center of pixels along left of image).
  /// Example: /// Example: 0.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn centroidColumn(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_CENTROIDCOLUMN, Some(0.0)).unwrap()}
  }
  /// Spatial variance of image distribution in vertical direction measured in pixels squared.
  /// Example: /// Example: 0.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rowVariance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_ROWVARIANCE, Some(0.0)).unwrap()}
  }
  /// Spatial variance of image distribution in horizontal direction measured in pixels squared.
  /// Example: /// Example: 0.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn columnVariance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_COLUMNVARIANCE, Some(0.0)).unwrap()}
  }
  /// Spatial covariance of image distribution across horizontal and vertical directions measured in pixels squared.
  /// Example: /// Example: 0.01
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rowColCov(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_ROWCOLCOV, Some(0.0)).unwrap()}
  }
  /// An array of measurements that correspond to the distance from the streak center measured from the optical image in pixels that show change over an interval of time. The array length is dependent on the length of the streak. The distFromStreakCenter, surfBrightness, and surfBrightnessUnc arrays will match in size.
  /// Example: /// Example: [-127.153, -126.153, -125.153]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn distFromStreakCenter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_DISTFROMSTREAKCENTER, None)}
  }
  /// An array of surface brightness measurements in magnitudes per square arcsecond from the optical image that show change over an interval of time. The array length is dependent on the length of the streak. The distFromStreakCenter, surfBrightness, and surfBrightnessUnc arrays will match in size.
  /// Example: /// Example: [21.01, 21.382, 21.725]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn surfBrightness(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_SURFBRIGHTNESS, None)}
  }
  /// An array of surface brightness uncertainty measurements in magnitudes per square arcsecond from the optical image that show change over an interval of time. The array length is dependent on the length of the streak. The distFromStreakCenter, surfBrightness, and surfBrightnessUnc arrays will match in size.
  /// Example: /// Example: [0.165, 0.165, 0.165]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn surfBrightnessUnc(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EOObservationDetails_Ingest::VT_SURFBRIGHTNESSUNC, None)}
  }
  /// Uncertainty in the times reported in UTC in seconds.
  /// Example: /// Example: 13.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn timesUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_TIMESUNC, Some(0.0)).unwrap()}
  }
  /// Operating temperature of CCD recorded during exposure or measured during calibrations in K.
  /// Example: /// Example: 123.4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ccdTemp(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_CCDTEMP, Some(0.0)).unwrap()}
  }
  /// The reference number, x, where x ranges from 1 to n, where n is the number specified in spectralFilters that corresponds to the spectral filter given in the corresponding spectralFilterNames.
  /// Example: /// Example: 23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn currentSpectralFilterNum(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_CURRENTSPECTRALFILTERNUM, Some(0)).unwrap()}
  }
  /// The reference number n, in neutralDensityFilters for the currently used neutral density filter.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn currentNeutralDensityFilterNum(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_CURRENTNEUTRALDENSITYFILTERNUM, Some(0)).unwrap()}
  }
  /// The number of pixels binned horizontally.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn binningHoriz(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_BINNINGHORIZ, Some(0)).unwrap()}
  }
  /// The number of pixels binned vertically.
  /// Example: /// Example: 14
  /// Constraints: No constraints specified.
  #[inline]
  pub fn binningVert(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_BINNINGVERT, Some(0)).unwrap()}
  }
  /// Number of stars used in photometric fit count.
  /// Example: /// Example: 23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pcalNumStars(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_PCALNUMSTARS, Some(0)).unwrap()}
  }
  /// The x centroid position on the CCD of the target object in pixels.
  /// Example: /// Example: 123.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ccdObjPosX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_CCDOBJPOSX, Some(0.0)).unwrap()}
  }
  /// The y centroid position on the CCD of the target object in pixels.
  /// Example: /// Example: 321.4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ccdObjPosY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_CCDOBJPOSY, Some(0.0)).unwrap()}
  }
  /// This is the pixel width of the target. This is either a frame-by-frame measurement or a constant point spread function or synthetic aperture used in the extraction.
  /// Example: /// Example: 133.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ccdObjWidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_CCDOBJWIDTH, Some(0.0)).unwrap()}
  }
  /// This is the background signal at or in the vicinity of the radiometric source position. Specifically, this is the average background count level (DN/pixel) divided by the exposure time in seconds of the background pixels used in the photometric extraction. DN/pixel/sec.
  /// Example: /// Example: 4134.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn backgroundSignal(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_BACKGROUNDSIGNAL, Some(0.0)).unwrap()}
  }
  /// Estimated 1-sigma uncertainty in the background signal at or in the vicinity of the radiometric source position. DN/pixel/sec.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn backgroundSignalUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_BACKGROUNDSIGNALUNC, Some(0.0)).unwrap()}
  }
  /// Peak Aperture Raw Counts is the value of the peak pixel in the real or synthetic aperture containing the target signal.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn peakApertureCount(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_PEAKAPERTURECOUNT, Some(0.0)).unwrap()}
  }
  /// Peak Background Raw Counts is the largest pixel value used in background signal.
  /// Example: /// Example: 321
  /// Constraints: No constraints specified.
  #[inline]
  pub fn peakBackgroundCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_PEAKBACKGROUNDCOUNT, Some(0)).unwrap()}
  }
  /// Estimated signal-to-noise ratio (SNR) for the total radiometric signal. Under some algorithms, this can be a constant per target (not per observation). Note: this SNR applies to the total signal of the radiometric source (i.e., Net_Obj_Sig with units DN/sec), not to be confused with the SNR of the signal in the peak pixel (i.e., DN/pixel/sec).
  /// Example: /// Example: 13.4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn snrEst(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_SNREST, Some(0.0)).unwrap()}
  }
  /// Instrumental magnitude of a sensor before corrections are applied for atmosphere or to transform to standard magnitude scale.
  /// Example: /// Example: 123.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn magInstrumental(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_MAGINSTRUMENTAL, Some(0.0)).unwrap()}
  }
  /// Uncertainty in the instrumental magnitude.
  /// Example: /// Example: 123.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn magInstrumentalUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_MAGINSTRUMENTALUNC, Some(0.0)).unwrap()}
  }
  /// Optical Cross Section computed in units m(2)/ster.
  /// Example: /// Example: 123.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn opticalCrossSection(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_OPTICALCROSSSECTION, Some(0.0)).unwrap()}
  }
  /// Uncertainty in Optical Cross Section computed in units m(2)/ster.
  /// Example: /// Example: 123.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn opticalCrossSectionUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_OPTICALCROSSSECTIONUNC, Some(0.0)).unwrap()}
  }
  /// Sun state vector in ECI J2000 coordinate frame in km.
  /// Example: /// Example: 123.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sunStatePosX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEPOSX, Some(0.0)).unwrap()}
  }
  /// Sun state vector in ECI J2000 coordinate frame in km.
  /// Example: /// Example: 123.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sunStatePosY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEPOSY, Some(0.0)).unwrap()}
  }
  /// Sun state vector in ECI J2000 coordinate frame in km.
  /// Example: /// Example: 123.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sunStatePosZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEPOSZ, Some(0.0)).unwrap()}
  }
  /// Sun state vector in ECI J2000 coordinate frame in km/sec.
  /// Example: /// Example: 123.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sunStateVelX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEVELX, Some(0.0)).unwrap()}
  }
  /// Sun state vector in ECI J2000 coordinate frame in km/sec.
  /// Example: /// Example: 123.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sunStateVelY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEVELY, Some(0.0)).unwrap()}
  }
  /// Sun state vector in ECI J2000 coordinate frame in km/sec.
  /// Example: /// Example: 123.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sunStateVelZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEVELZ, Some(0.0)).unwrap()}
  }
  /// Number of catalog stars in the detector field of view (FOV) with the target object. Can be 0 for narrow FOV sensors.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numCatalogStars(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_NUMCATALOGSTARS, Some(0)).unwrap()}
  }
  /// Number of detected stars in the FOV with the target object. Helps identify frames with clouds.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numDetectedStars(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_NUMDETECTEDSTARS, Some(0)).unwrap()}
  }
  /// Number of correlated stars in the FOV with the target object. Can be 0 for narrow FOV sensors.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numCorrelatedStars(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_NUMCORRELATEDSTARS, Some(0)).unwrap()}
  }
  /// Uncertainty of predicted Right Ascension of the Target object from the frame of reference of the sensor (J2000, geocentric velocity aberration). SGP4 and VCMs produce geocentric origin and velocity aberration and subtracting the sensor geocentric position of the sensor places in its reference frame.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn predictedRaUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDRAUNC, Some(0.0)).unwrap()}
  }
  /// Uncertainty of Predicted Declination of the Target object from the frame of reference of the sensor (J2000, geocentric velocity aberration). SGP4 and VCMs produce geocentric origin and velocity aberration and subtracting the sensor geocentric position of the sensor places in its reference frame.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn predictedDeclinationUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDDECLINATIONUNC, Some(0.0)).unwrap()}
  }
  /// Covariance (x^2) in measured Right Ascension (X) in deg^2.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn raCov(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_RACOV, Some(0.0)).unwrap()}
  }
  /// Covariance (Y^2) in measured declination (Y) in deg^2.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn declinationCov(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_DECLINATIONCOV, Some(0.0)).unwrap()}
  }
  /// Covariance (XY) in measured ra/declination (XY) in deg^2.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn raDeclinationCov(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_RADECLINATIONCOV, Some(0.0)).unwrap()}
  }
  /// World Coordinate System (WCS) X pixel origin in astrometric fit.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn acalCrPixX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_ACALCRPIXX, Some(0.0)).unwrap()}
  }
  /// World Coordinate System (WCS) Y pixel origin in astrometric fit.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn acalCrPixY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_ACALCRPIXY, Some(0.0)).unwrap()}
  }
  /// World Coordinate System (WCS) equatorial coordinate X origin corresponding to CRPIX in astrometric fit in degrees.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn acalCrValX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_ACALCRVALX, Some(0.0)).unwrap()}
  }
  /// World Coordinate System (WCS) equatorial coordinate Y origin corresponding to CRPIX in astrometric fit in degrees.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn acalCrValY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_ACALCRVALY, Some(0.0)).unwrap()}
  }
  /// Number of stars used in astrometric fit.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn acalNumStars(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOObservationDetails_Ingest::VT_ACALNUMSTARS, Some(0)).unwrap()}
  }
  /// Distance from the target object to the sun during the observation in meters.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn objSunRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_OBJSUNRANGE, Some(0.0)).unwrap()}
  }
  /// Solar phase angle bisector vector. The vector that bisects the solar phase angle. The phase angle bisector is the angle that is << of the value in #48. Then calculate the point on the RA/DEC (ECI J2000.0) sphere that a vector at this angle would intersect.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn phaseAngBisect(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_PHASEANGBISECT, Some(0.0)).unwrap()}
  }
  /// Fraction of the sun that is illuminating the target object. This indicates if the target is in the Earths penumbra or umbra. (It is 0 when object is in umbra and 1 when object is fully illuminated.).
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solarDiskFrac(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_SOLARDISKFRAC, Some(0.0)).unwrap()}
  }
  /// Time off element set.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn toes(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_TOES, Some(0.0)).unwrap()}
  }
  /// Degrees Off Element Set.
  /// Example: /// Example: 123.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn does(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EOObservationDetails_Ingest::VT_DOES, Some(0.0)).unwrap()}
  }
  /// Source of the data, will be set to EOObservation source if blank.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOObservationDetails_Ingest::VT_SOURCE, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// , will be set to EOObservation dataMode if blank.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> EOObservationDetails_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EOObservationDetails_Ingest_dataMode_Enum>(EOObservationDetails_Ingest::VT_DATAMODE, Some(EOObservationDetails_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOObservationDetails_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOObservationDetails_Ingest::VT_CREATEDBY, None)}
  }
}

impl flatbuffers::Verifiable for EOObservationDetails_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idEOObservation", Self::VT_IDEOOBSERVATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("obTime", Self::VT_OBTIME, false)?
     .visit_field::<f64>("predictedRa", Self::VT_PREDICTEDRA, false)?
     .visit_field::<f64>("predictedDeclination", Self::VT_PREDICTEDDECLINATION, false)?
     .visit_field::<f64>("predictedAzimuth", Self::VT_PREDICTEDAZIMUTH, false)?
     .visit_field::<f64>("predictedElevation", Self::VT_PREDICTEDELEVATION, false)?
     .visit_field::<f64>("sunAzimuth", Self::VT_SUNAZIMUTH, false)?
     .visit_field::<f64>("sunElevation", Self::VT_SUNELEVATION, false)?
     .visit_field::<i32>("numSpectralFilters", Self::VT_NUMSPECTRALFILTERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("spectralFilters", Self::VT_SPECTRALFILTERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("spectralZMFL", Self::VT_SPECTRALZMFL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("spectralFilterSolarMag", Self::VT_SPECTRALFILTERSOLARMAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("zeroPoints", Self::VT_ZEROPOINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("zeroPointsUnc", Self::VT_ZEROPOINTSUNC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("extinctionCoeffs", Self::VT_EXTINCTIONCOEFFS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("extinctionCoeffsUnc", Self::VT_EXTINCTIONCOEFFSUNC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("colorCoeffs", Self::VT_COLORCOEFFS, false)?
     .visit_field::<i32>("numNeutralDensityFilters", Self::VT_NUMNEUTRALDENSITYFILTERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("neutralDensityFilterNames", Self::VT_NEUTRALDENSITYFILTERNAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("neutralDensityFilterTransmissions", Self::VT_NEUTRALDENSITYFILTERTRANSMISSIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("neutralDensityFilterTransmissionsUnc", Self::VT_NEUTRALDENSITYFILTERTRANSMISSIONSUNC, false)?
     .visit_field::<f64>("gain", Self::VT_GAIN, false)?
     .visit_field::<f64>("ifov", Self::VT_IFOV, false)?
     .visit_field::<i32>("pixelArrayWidth", Self::VT_PIXELARRAYWIDTH, false)?
     .visit_field::<i32>("pixelArrayHeight", Self::VT_PIXELARRAYHEIGHT, false)?
     .visit_field::<i32>("pixelMin", Self::VT_PIXELMIN, false)?
     .visit_field::<i32>("pixelMax", Self::VT_PIXELMAX, false)?
     .visit_field::<f64>("centroidRow", Self::VT_CENTROIDROW, false)?
     .visit_field::<f64>("centroidColumn", Self::VT_CENTROIDCOLUMN, false)?
     .visit_field::<f64>("rowVariance", Self::VT_ROWVARIANCE, false)?
     .visit_field::<f64>("columnVariance", Self::VT_COLUMNVARIANCE, false)?
     .visit_field::<f64>("rowColCov", Self::VT_ROWCOLCOV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("distFromStreakCenter", Self::VT_DISTFROMSTREAKCENTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("surfBrightness", Self::VT_SURFBRIGHTNESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("surfBrightnessUnc", Self::VT_SURFBRIGHTNESSUNC, false)?
     .visit_field::<f64>("timesUnc", Self::VT_TIMESUNC, false)?
     .visit_field::<f64>("ccdTemp", Self::VT_CCDTEMP, false)?
     .visit_field::<i32>("currentSpectralFilterNum", Self::VT_CURRENTSPECTRALFILTERNUM, false)?
     .visit_field::<i32>("currentNeutralDensityFilterNum", Self::VT_CURRENTNEUTRALDENSITYFILTERNUM, false)?
     .visit_field::<i32>("binningHoriz", Self::VT_BINNINGHORIZ, false)?
     .visit_field::<i32>("binningVert", Self::VT_BINNINGVERT, false)?
     .visit_field::<i32>("pcalNumStars", Self::VT_PCALNUMSTARS, false)?
     .visit_field::<f64>("ccdObjPosX", Self::VT_CCDOBJPOSX, false)?
     .visit_field::<f64>("ccdObjPosY", Self::VT_CCDOBJPOSY, false)?
     .visit_field::<f64>("ccdObjWidth", Self::VT_CCDOBJWIDTH, false)?
     .visit_field::<f64>("backgroundSignal", Self::VT_BACKGROUNDSIGNAL, false)?
     .visit_field::<f64>("backgroundSignalUnc", Self::VT_BACKGROUNDSIGNALUNC, false)?
     .visit_field::<f64>("peakApertureCount", Self::VT_PEAKAPERTURECOUNT, false)?
     .visit_field::<i32>("peakBackgroundCount", Self::VT_PEAKBACKGROUNDCOUNT, false)?
     .visit_field::<f64>("snrEst", Self::VT_SNREST, false)?
     .visit_field::<f64>("magInstrumental", Self::VT_MAGINSTRUMENTAL, false)?
     .visit_field::<f64>("magInstrumentalUnc", Self::VT_MAGINSTRUMENTALUNC, false)?
     .visit_field::<f64>("opticalCrossSection", Self::VT_OPTICALCROSSSECTION, false)?
     .visit_field::<f64>("opticalCrossSectionUnc", Self::VT_OPTICALCROSSSECTIONUNC, false)?
     .visit_field::<f64>("sunStatePosX", Self::VT_SUNSTATEPOSX, false)?
     .visit_field::<f64>("sunStatePosY", Self::VT_SUNSTATEPOSY, false)?
     .visit_field::<f64>("sunStatePosZ", Self::VT_SUNSTATEPOSZ, false)?
     .visit_field::<f64>("sunStateVelX", Self::VT_SUNSTATEVELX, false)?
     .visit_field::<f64>("sunStateVelY", Self::VT_SUNSTATEVELY, false)?
     .visit_field::<f64>("sunStateVelZ", Self::VT_SUNSTATEVELZ, false)?
     .visit_field::<i32>("numCatalogStars", Self::VT_NUMCATALOGSTARS, false)?
     .visit_field::<i32>("numDetectedStars", Self::VT_NUMDETECTEDSTARS, false)?
     .visit_field::<i32>("numCorrelatedStars", Self::VT_NUMCORRELATEDSTARS, false)?
     .visit_field::<f64>("predictedRaUnc", Self::VT_PREDICTEDRAUNC, false)?
     .visit_field::<f64>("predictedDeclinationUnc", Self::VT_PREDICTEDDECLINATIONUNC, false)?
     .visit_field::<f64>("raCov", Self::VT_RACOV, false)?
     .visit_field::<f64>("declinationCov", Self::VT_DECLINATIONCOV, false)?
     .visit_field::<f64>("raDeclinationCov", Self::VT_RADECLINATIONCOV, false)?
     .visit_field::<f64>("acalCrPixX", Self::VT_ACALCRPIXX, false)?
     .visit_field::<f64>("acalCrPixY", Self::VT_ACALCRPIXY, false)?
     .visit_field::<f64>("acalCrValX", Self::VT_ACALCRVALX, false)?
     .visit_field::<f64>("acalCrValY", Self::VT_ACALCRVALY, false)?
     .visit_field::<i32>("acalNumStars", Self::VT_ACALNUMSTARS, false)?
     .visit_field::<f64>("objSunRange", Self::VT_OBJSUNRANGE, false)?
     .visit_field::<f64>("phaseAngBisect", Self::VT_PHASEANGBISECT, false)?
     .visit_field::<f64>("solarDiskFrac", Self::VT_SOLARDISKFRAC, false)?
     .visit_field::<f64>("toes", Self::VT_TOES, false)?
     .visit_field::<f64>("does", Self::VT_DOES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<EOObservationDetails_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .finish();
    Ok(())
  }
}
pub struct EOObservationDetails_IngestArgs<'a> {
    pub idEOObservation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub predictedRa: f64,
    pub predictedDeclination: f64,
    pub predictedAzimuth: f64,
    pub predictedElevation: f64,
    pub sunAzimuth: f64,
    pub sunElevation: f64,
    pub numSpectralFilters: i32,
    pub spectralFilters: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub spectralZMFL: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub spectralFilterSolarMag: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub zeroPoints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub zeroPointsUnc: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub extinctionCoeffs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub extinctionCoeffsUnc: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub colorCoeffs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub numNeutralDensityFilters: i32,
    pub neutralDensityFilterNames: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub neutralDensityFilterTransmissions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub neutralDensityFilterTransmissionsUnc: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub gain: f64,
    pub ifov: f64,
    pub pixelArrayWidth: i32,
    pub pixelArrayHeight: i32,
    pub pixelMin: i32,
    pub pixelMax: i32,
    pub centroidRow: f64,
    pub centroidColumn: f64,
    pub rowVariance: f64,
    pub columnVariance: f64,
    pub rowColCov: f64,
    pub distFromStreakCenter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub surfBrightness: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub surfBrightnessUnc: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub timesUnc: f64,
    pub ccdTemp: f64,
    pub currentSpectralFilterNum: i32,
    pub currentNeutralDensityFilterNum: i32,
    pub binningHoriz: i32,
    pub binningVert: i32,
    pub pcalNumStars: i32,
    pub ccdObjPosX: f64,
    pub ccdObjPosY: f64,
    pub ccdObjWidth: f64,
    pub backgroundSignal: f64,
    pub backgroundSignalUnc: f64,
    pub peakApertureCount: f64,
    pub peakBackgroundCount: i32,
    pub snrEst: f64,
    pub magInstrumental: f64,
    pub magInstrumentalUnc: f64,
    pub opticalCrossSection: f64,
    pub opticalCrossSectionUnc: f64,
    pub sunStatePosX: f64,
    pub sunStatePosY: f64,
    pub sunStatePosZ: f64,
    pub sunStateVelX: f64,
    pub sunStateVelY: f64,
    pub sunStateVelZ: f64,
    pub numCatalogStars: i32,
    pub numDetectedStars: i32,
    pub numCorrelatedStars: i32,
    pub predictedRaUnc: f64,
    pub predictedDeclinationUnc: f64,
    pub raCov: f64,
    pub declinationCov: f64,
    pub raDeclinationCov: f64,
    pub acalCrPixX: f64,
    pub acalCrPixY: f64,
    pub acalCrValX: f64,
    pub acalCrValY: f64,
    pub acalNumStars: i32,
    pub objSunRange: f64,
    pub phaseAngBisect: f64,
    pub solarDiskFrac: f64,
    pub toes: f64,
    pub does: f64,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: EOObservationDetails_Ingest_dataMode_Enum,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EOObservationDetails_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    EOObservationDetails_IngestArgs {
      idEOObservation: None,
      classificationMarking: None,
      obTime: None,
      predictedRa: 0.0,
      predictedDeclination: 0.0,
      predictedAzimuth: 0.0,
      predictedElevation: 0.0,
      sunAzimuth: 0.0,
      sunElevation: 0.0,
      numSpectralFilters: 0,
      spectralFilters: None,
      spectralZMFL: None,
      spectralFilterSolarMag: None,
      zeroPoints: None,
      zeroPointsUnc: None,
      extinctionCoeffs: None,
      extinctionCoeffsUnc: None,
      colorCoeffs: None,
      numNeutralDensityFilters: 0,
      neutralDensityFilterNames: None,
      neutralDensityFilterTransmissions: None,
      neutralDensityFilterTransmissionsUnc: None,
      gain: 0.0,
      ifov: 0.0,
      pixelArrayWidth: 0,
      pixelArrayHeight: 0,
      pixelMin: 0,
      pixelMax: 0,
      centroidRow: 0.0,
      centroidColumn: 0.0,
      rowVariance: 0.0,
      columnVariance: 0.0,
      rowColCov: 0.0,
      distFromStreakCenter: None,
      surfBrightness: None,
      surfBrightnessUnc: None,
      timesUnc: 0.0,
      ccdTemp: 0.0,
      currentSpectralFilterNum: 0,
      currentNeutralDensityFilterNum: 0,
      binningHoriz: 0,
      binningVert: 0,
      pcalNumStars: 0,
      ccdObjPosX: 0.0,
      ccdObjPosY: 0.0,
      ccdObjWidth: 0.0,
      backgroundSignal: 0.0,
      backgroundSignalUnc: 0.0,
      peakApertureCount: 0.0,
      peakBackgroundCount: 0,
      snrEst: 0.0,
      magInstrumental: 0.0,
      magInstrumentalUnc: 0.0,
      opticalCrossSection: 0.0,
      opticalCrossSectionUnc: 0.0,
      sunStatePosX: 0.0,
      sunStatePosY: 0.0,
      sunStatePosZ: 0.0,
      sunStateVelX: 0.0,
      sunStateVelY: 0.0,
      sunStateVelZ: 0.0,
      numCatalogStars: 0,
      numDetectedStars: 0,
      numCorrelatedStars: 0,
      predictedRaUnc: 0.0,
      predictedDeclinationUnc: 0.0,
      raCov: 0.0,
      declinationCov: 0.0,
      raDeclinationCov: 0.0,
      acalCrPixX: 0.0,
      acalCrPixY: 0.0,
      acalCrValX: 0.0,
      acalCrValY: 0.0,
      acalNumStars: 0,
      objSunRange: 0.0,
      phaseAngBisect: 0.0,
      solarDiskFrac: 0.0,
      toes: 0.0,
      does: 0.0,
      source: None,
      dataMode: EOObservationDetails_Ingest_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
    }
  }
}

pub struct EOObservationDetails_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EOObservationDetails_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_idEOObservation(&mut self, idEOObservation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_IDEOOBSERVATION, idEOObservation);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_obTime(&mut self, obTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_OBTIME, obTime);
  }
  #[inline]
  pub fn add_predictedRa(&mut self, predictedRa: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDRA, predictedRa, 0.0);
  }
  #[inline]
  pub fn add_predictedDeclination(&mut self, predictedDeclination: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDDECLINATION, predictedDeclination, 0.0);
  }
  #[inline]
  pub fn add_predictedAzimuth(&mut self, predictedAzimuth: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDAZIMUTH, predictedAzimuth, 0.0);
  }
  #[inline]
  pub fn add_predictedElevation(&mut self, predictedElevation: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDELEVATION, predictedElevation, 0.0);
  }
  #[inline]
  pub fn add_sunAzimuth(&mut self, sunAzimuth: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_SUNAZIMUTH, sunAzimuth, 0.0);
  }
  #[inline]
  pub fn add_sunElevation(&mut self, sunElevation: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_SUNELEVATION, sunElevation, 0.0);
  }
  #[inline]
  pub fn add_numSpectralFilters(&mut self, numSpectralFilters: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_NUMSPECTRALFILTERS, numSpectralFilters, 0);
  }
  #[inline]
  pub fn add_spectralFilters(&mut self, spectralFilters: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_SPECTRALFILTERS, spectralFilters);
  }
  #[inline]
  pub fn add_spectralZMFL(&mut self, spectralZMFL: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_SPECTRALZMFL, spectralZMFL);
  }
  #[inline]
  pub fn add_spectralFilterSolarMag(&mut self, spectralFilterSolarMag: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_SPECTRALFILTERSOLARMAG, spectralFilterSolarMag);
  }
  #[inline]
  pub fn add_zeroPoints(&mut self, zeroPoints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_ZEROPOINTS, zeroPoints);
  }
  #[inline]
  pub fn add_zeroPointsUnc(&mut self, zeroPointsUnc: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_ZEROPOINTSUNC, zeroPointsUnc);
  }
  #[inline]
  pub fn add_extinctionCoeffs(&mut self, extinctionCoeffs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_EXTINCTIONCOEFFS, extinctionCoeffs);
  }
  #[inline]
  pub fn add_extinctionCoeffsUnc(&mut self, extinctionCoeffsUnc: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_EXTINCTIONCOEFFSUNC, extinctionCoeffsUnc);
  }
  #[inline]
  pub fn add_colorCoeffs(&mut self, colorCoeffs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_COLORCOEFFS, colorCoeffs);
  }
  #[inline]
  pub fn add_numNeutralDensityFilters(&mut self, numNeutralDensityFilters: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_NUMNEUTRALDENSITYFILTERS, numNeutralDensityFilters, 0);
  }
  #[inline]
  pub fn add_neutralDensityFilterNames(&mut self, neutralDensityFilterNames: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_NEUTRALDENSITYFILTERNAMES, neutralDensityFilterNames);
  }
  #[inline]
  pub fn add_neutralDensityFilterTransmissions(&mut self, neutralDensityFilterTransmissions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_NEUTRALDENSITYFILTERTRANSMISSIONS, neutralDensityFilterTransmissions);
  }
  #[inline]
  pub fn add_neutralDensityFilterTransmissionsUnc(&mut self, neutralDensityFilterTransmissionsUnc: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_NEUTRALDENSITYFILTERTRANSMISSIONSUNC, neutralDensityFilterTransmissionsUnc);
  }
  #[inline]
  pub fn add_gain(&mut self, gain: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_GAIN, gain, 0.0);
  }
  #[inline]
  pub fn add_ifov(&mut self, ifov: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_IFOV, ifov, 0.0);
  }
  #[inline]
  pub fn add_pixelArrayWidth(&mut self, pixelArrayWidth: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_PIXELARRAYWIDTH, pixelArrayWidth, 0);
  }
  #[inline]
  pub fn add_pixelArrayHeight(&mut self, pixelArrayHeight: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_PIXELARRAYHEIGHT, pixelArrayHeight, 0);
  }
  #[inline]
  pub fn add_pixelMin(&mut self, pixelMin: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_PIXELMIN, pixelMin, 0);
  }
  #[inline]
  pub fn add_pixelMax(&mut self, pixelMax: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_PIXELMAX, pixelMax, 0);
  }
  #[inline]
  pub fn add_centroidRow(&mut self, centroidRow: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_CENTROIDROW, centroidRow, 0.0);
  }
  #[inline]
  pub fn add_centroidColumn(&mut self, centroidColumn: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_CENTROIDCOLUMN, centroidColumn, 0.0);
  }
  #[inline]
  pub fn add_rowVariance(&mut self, rowVariance: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_ROWVARIANCE, rowVariance, 0.0);
  }
  #[inline]
  pub fn add_columnVariance(&mut self, columnVariance: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_COLUMNVARIANCE, columnVariance, 0.0);
  }
  #[inline]
  pub fn add_rowColCov(&mut self, rowColCov: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_ROWCOLCOV, rowColCov, 0.0);
  }
  #[inline]
  pub fn add_distFromStreakCenter(&mut self, distFromStreakCenter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_DISTFROMSTREAKCENTER, distFromStreakCenter);
  }
  #[inline]
  pub fn add_surfBrightness(&mut self, surfBrightness: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_SURFBRIGHTNESS, surfBrightness);
  }
  #[inline]
  pub fn add_surfBrightnessUnc(&mut self, surfBrightnessUnc: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_SURFBRIGHTNESSUNC, surfBrightnessUnc);
  }
  #[inline]
  pub fn add_timesUnc(&mut self, timesUnc: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_TIMESUNC, timesUnc, 0.0);
  }
  #[inline]
  pub fn add_ccdTemp(&mut self, ccdTemp: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_CCDTEMP, ccdTemp, 0.0);
  }
  #[inline]
  pub fn add_currentSpectralFilterNum(&mut self, currentSpectralFilterNum: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_CURRENTSPECTRALFILTERNUM, currentSpectralFilterNum, 0);
  }
  #[inline]
  pub fn add_currentNeutralDensityFilterNum(&mut self, currentNeutralDensityFilterNum: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_CURRENTNEUTRALDENSITYFILTERNUM, currentNeutralDensityFilterNum, 0);
  }
  #[inline]
  pub fn add_binningHoriz(&mut self, binningHoriz: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_BINNINGHORIZ, binningHoriz, 0);
  }
  #[inline]
  pub fn add_binningVert(&mut self, binningVert: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_BINNINGVERT, binningVert, 0);
  }
  #[inline]
  pub fn add_pcalNumStars(&mut self, pcalNumStars: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_PCALNUMSTARS, pcalNumStars, 0);
  }
  #[inline]
  pub fn add_ccdObjPosX(&mut self, ccdObjPosX: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_CCDOBJPOSX, ccdObjPosX, 0.0);
  }
  #[inline]
  pub fn add_ccdObjPosY(&mut self, ccdObjPosY: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_CCDOBJPOSY, ccdObjPosY, 0.0);
  }
  #[inline]
  pub fn add_ccdObjWidth(&mut self, ccdObjWidth: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_CCDOBJWIDTH, ccdObjWidth, 0.0);
  }
  #[inline]
  pub fn add_backgroundSignal(&mut self, backgroundSignal: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_BACKGROUNDSIGNAL, backgroundSignal, 0.0);
  }
  #[inline]
  pub fn add_backgroundSignalUnc(&mut self, backgroundSignalUnc: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_BACKGROUNDSIGNALUNC, backgroundSignalUnc, 0.0);
  }
  #[inline]
  pub fn add_peakApertureCount(&mut self, peakApertureCount: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_PEAKAPERTURECOUNT, peakApertureCount, 0.0);
  }
  #[inline]
  pub fn add_peakBackgroundCount(&mut self, peakBackgroundCount: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_PEAKBACKGROUNDCOUNT, peakBackgroundCount, 0);
  }
  #[inline]
  pub fn add_snrEst(&mut self, snrEst: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_SNREST, snrEst, 0.0);
  }
  #[inline]
  pub fn add_magInstrumental(&mut self, magInstrumental: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_MAGINSTRUMENTAL, magInstrumental, 0.0);
  }
  #[inline]
  pub fn add_magInstrumentalUnc(&mut self, magInstrumentalUnc: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_MAGINSTRUMENTALUNC, magInstrumentalUnc, 0.0);
  }
  #[inline]
  pub fn add_opticalCrossSection(&mut self, opticalCrossSection: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_OPTICALCROSSSECTION, opticalCrossSection, 0.0);
  }
  #[inline]
  pub fn add_opticalCrossSectionUnc(&mut self, opticalCrossSectionUnc: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_OPTICALCROSSSECTIONUNC, opticalCrossSectionUnc, 0.0);
  }
  #[inline]
  pub fn add_sunStatePosX(&mut self, sunStatePosX: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEPOSX, sunStatePosX, 0.0);
  }
  #[inline]
  pub fn add_sunStatePosY(&mut self, sunStatePosY: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEPOSY, sunStatePosY, 0.0);
  }
  #[inline]
  pub fn add_sunStatePosZ(&mut self, sunStatePosZ: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEPOSZ, sunStatePosZ, 0.0);
  }
  #[inline]
  pub fn add_sunStateVelX(&mut self, sunStateVelX: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEVELX, sunStateVelX, 0.0);
  }
  #[inline]
  pub fn add_sunStateVelY(&mut self, sunStateVelY: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEVELY, sunStateVelY, 0.0);
  }
  #[inline]
  pub fn add_sunStateVelZ(&mut self, sunStateVelZ: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_SUNSTATEVELZ, sunStateVelZ, 0.0);
  }
  #[inline]
  pub fn add_numCatalogStars(&mut self, numCatalogStars: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_NUMCATALOGSTARS, numCatalogStars, 0);
  }
  #[inline]
  pub fn add_numDetectedStars(&mut self, numDetectedStars: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_NUMDETECTEDSTARS, numDetectedStars, 0);
  }
  #[inline]
  pub fn add_numCorrelatedStars(&mut self, numCorrelatedStars: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_NUMCORRELATEDSTARS, numCorrelatedStars, 0);
  }
  #[inline]
  pub fn add_predictedRaUnc(&mut self, predictedRaUnc: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDRAUNC, predictedRaUnc, 0.0);
  }
  #[inline]
  pub fn add_predictedDeclinationUnc(&mut self, predictedDeclinationUnc: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_PREDICTEDDECLINATIONUNC, predictedDeclinationUnc, 0.0);
  }
  #[inline]
  pub fn add_raCov(&mut self, raCov: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_RACOV, raCov, 0.0);
  }
  #[inline]
  pub fn add_declinationCov(&mut self, declinationCov: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_DECLINATIONCOV, declinationCov, 0.0);
  }
  #[inline]
  pub fn add_raDeclinationCov(&mut self, raDeclinationCov: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_RADECLINATIONCOV, raDeclinationCov, 0.0);
  }
  #[inline]
  pub fn add_acalCrPixX(&mut self, acalCrPixX: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_ACALCRPIXX, acalCrPixX, 0.0);
  }
  #[inline]
  pub fn add_acalCrPixY(&mut self, acalCrPixY: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_ACALCRPIXY, acalCrPixY, 0.0);
  }
  #[inline]
  pub fn add_acalCrValX(&mut self, acalCrValX: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_ACALCRVALX, acalCrValX, 0.0);
  }
  #[inline]
  pub fn add_acalCrValY(&mut self, acalCrValY: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_ACALCRVALY, acalCrValY, 0.0);
  }
  #[inline]
  pub fn add_acalNumStars(&mut self, acalNumStars: i32) {
    self.fbb_.push_slot::<i32>(EOObservationDetails_Ingest::VT_ACALNUMSTARS, acalNumStars, 0);
  }
  #[inline]
  pub fn add_objSunRange(&mut self, objSunRange: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_OBJSUNRANGE, objSunRange, 0.0);
  }
  #[inline]
  pub fn add_phaseAngBisect(&mut self, phaseAngBisect: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_PHASEANGBISECT, phaseAngBisect, 0.0);
  }
  #[inline]
  pub fn add_solarDiskFrac(&mut self, solarDiskFrac: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_SOLARDISKFRAC, solarDiskFrac, 0.0);
  }
  #[inline]
  pub fn add_toes(&mut self, toes: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_TOES, toes, 0.0);
  }
  #[inline]
  pub fn add_does(&mut self, does: f64) {
    self.fbb_.push_slot::<f64>(EOObservationDetails_Ingest::VT_DOES, does, 0.0);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: EOObservationDetails_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<EOObservationDetails_Ingest_dataMode_Enum>(EOObservationDetails_Ingest::VT_DATAMODE, dataMode, EOObservationDetails_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOObservationDetails_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EOObservationDetails_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EOObservationDetails_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EOObservationDetails_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EOObservationDetails_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EOObservationDetails_Ingest");
      ds.field("idEOObservation", &self.idEOObservation());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("obTime", &self.obTime());
      ds.field("predictedRa", &self.predictedRa());
      ds.field("predictedDeclination", &self.predictedDeclination());
      ds.field("predictedAzimuth", &self.predictedAzimuth());
      ds.field("predictedElevation", &self.predictedElevation());
      ds.field("sunAzimuth", &self.sunAzimuth());
      ds.field("sunElevation", &self.sunElevation());
      ds.field("numSpectralFilters", &self.numSpectralFilters());
      ds.field("spectralFilters", &self.spectralFilters());
      ds.field("spectralZMFL", &self.spectralZMFL());
      ds.field("spectralFilterSolarMag", &self.spectralFilterSolarMag());
      ds.field("zeroPoints", &self.zeroPoints());
      ds.field("zeroPointsUnc", &self.zeroPointsUnc());
      ds.field("extinctionCoeffs", &self.extinctionCoeffs());
      ds.field("extinctionCoeffsUnc", &self.extinctionCoeffsUnc());
      ds.field("colorCoeffs", &self.colorCoeffs());
      ds.field("numNeutralDensityFilters", &self.numNeutralDensityFilters());
      ds.field("neutralDensityFilterNames", &self.neutralDensityFilterNames());
      ds.field("neutralDensityFilterTransmissions", &self.neutralDensityFilterTransmissions());
      ds.field("neutralDensityFilterTransmissionsUnc", &self.neutralDensityFilterTransmissionsUnc());
      ds.field("gain", &self.gain());
      ds.field("ifov", &self.ifov());
      ds.field("pixelArrayWidth", &self.pixelArrayWidth());
      ds.field("pixelArrayHeight", &self.pixelArrayHeight());
      ds.field("pixelMin", &self.pixelMin());
      ds.field("pixelMax", &self.pixelMax());
      ds.field("centroidRow", &self.centroidRow());
      ds.field("centroidColumn", &self.centroidColumn());
      ds.field("rowVariance", &self.rowVariance());
      ds.field("columnVariance", &self.columnVariance());
      ds.field("rowColCov", &self.rowColCov());
      ds.field("distFromStreakCenter", &self.distFromStreakCenter());
      ds.field("surfBrightness", &self.surfBrightness());
      ds.field("surfBrightnessUnc", &self.surfBrightnessUnc());
      ds.field("timesUnc", &self.timesUnc());
      ds.field("ccdTemp", &self.ccdTemp());
      ds.field("currentSpectralFilterNum", &self.currentSpectralFilterNum());
      ds.field("currentNeutralDensityFilterNum", &self.currentNeutralDensityFilterNum());
      ds.field("binningHoriz", &self.binningHoriz());
      ds.field("binningVert", &self.binningVert());
      ds.field("pcalNumStars", &self.pcalNumStars());
      ds.field("ccdObjPosX", &self.ccdObjPosX());
      ds.field("ccdObjPosY", &self.ccdObjPosY());
      ds.field("ccdObjWidth", &self.ccdObjWidth());
      ds.field("backgroundSignal", &self.backgroundSignal());
      ds.field("backgroundSignalUnc", &self.backgroundSignalUnc());
      ds.field("peakApertureCount", &self.peakApertureCount());
      ds.field("peakBackgroundCount", &self.peakBackgroundCount());
      ds.field("snrEst", &self.snrEst());
      ds.field("magInstrumental", &self.magInstrumental());
      ds.field("magInstrumentalUnc", &self.magInstrumentalUnc());
      ds.field("opticalCrossSection", &self.opticalCrossSection());
      ds.field("opticalCrossSectionUnc", &self.opticalCrossSectionUnc());
      ds.field("sunStatePosX", &self.sunStatePosX());
      ds.field("sunStatePosY", &self.sunStatePosY());
      ds.field("sunStatePosZ", &self.sunStatePosZ());
      ds.field("sunStateVelX", &self.sunStateVelX());
      ds.field("sunStateVelY", &self.sunStateVelY());
      ds.field("sunStateVelZ", &self.sunStateVelZ());
      ds.field("numCatalogStars", &self.numCatalogStars());
      ds.field("numDetectedStars", &self.numDetectedStars());
      ds.field("numCorrelatedStars", &self.numCorrelatedStars());
      ds.field("predictedRaUnc", &self.predictedRaUnc());
      ds.field("predictedDeclinationUnc", &self.predictedDeclinationUnc());
      ds.field("raCov", &self.raCov());
      ds.field("declinationCov", &self.declinationCov());
      ds.field("raDeclinationCov", &self.raDeclinationCov());
      ds.field("acalCrPixX", &self.acalCrPixX());
      ds.field("acalCrPixY", &self.acalCrPixY());
      ds.field("acalCrValX", &self.acalCrValX());
      ds.field("acalCrValY", &self.acalCrValY());
      ds.field("acalNumStars", &self.acalNumStars());
      ds.field("objSunRange", &self.objSunRange());
      ds.field("phaseAngBisect", &self.phaseAngBisect());
      ds.field("solarDiskFrac", &self.solarDiskFrac());
      ds.field("toes", &self.toes());
      ds.field("does", &self.does());
      ds.field("source", &self.source());
      ds.field("dataMode", &self.dataMode());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EOObservationDetails_IngestT {
  pub idEOObservation: Option<String>,
  pub classificationMarking: Option<String>,
  pub obTime: Option<String>,
  pub predictedRa: f64,
  pub predictedDeclination: f64,
  pub predictedAzimuth: f64,
  pub predictedElevation: f64,
  pub sunAzimuth: f64,
  pub sunElevation: f64,
  pub numSpectralFilters: i32,
  pub spectralFilters: Option<Vec<String>>,
  pub spectralZMFL: Option<Vec<String>>,
  pub spectralFilterSolarMag: Option<Vec<String>>,
  pub zeroPoints: Option<Vec<String>>,
  pub zeroPointsUnc: Option<Vec<String>>,
  pub extinctionCoeffs: Option<Vec<String>>,
  pub extinctionCoeffsUnc: Option<Vec<String>>,
  pub colorCoeffs: Option<Vec<String>>,
  pub numNeutralDensityFilters: i32,
  pub neutralDensityFilterNames: Option<Vec<String>>,
  pub neutralDensityFilterTransmissions: Option<Vec<String>>,
  pub neutralDensityFilterTransmissionsUnc: Option<Vec<String>>,
  pub gain: f64,
  pub ifov: f64,
  pub pixelArrayWidth: i32,
  pub pixelArrayHeight: i32,
  pub pixelMin: i32,
  pub pixelMax: i32,
  pub centroidRow: f64,
  pub centroidColumn: f64,
  pub rowVariance: f64,
  pub columnVariance: f64,
  pub rowColCov: f64,
  pub distFromStreakCenter: Option<Vec<String>>,
  pub surfBrightness: Option<Vec<String>>,
  pub surfBrightnessUnc: Option<Vec<String>>,
  pub timesUnc: f64,
  pub ccdTemp: f64,
  pub currentSpectralFilterNum: i32,
  pub currentNeutralDensityFilterNum: i32,
  pub binningHoriz: i32,
  pub binningVert: i32,
  pub pcalNumStars: i32,
  pub ccdObjPosX: f64,
  pub ccdObjPosY: f64,
  pub ccdObjWidth: f64,
  pub backgroundSignal: f64,
  pub backgroundSignalUnc: f64,
  pub peakApertureCount: f64,
  pub peakBackgroundCount: i32,
  pub snrEst: f64,
  pub magInstrumental: f64,
  pub magInstrumentalUnc: f64,
  pub opticalCrossSection: f64,
  pub opticalCrossSectionUnc: f64,
  pub sunStatePosX: f64,
  pub sunStatePosY: f64,
  pub sunStatePosZ: f64,
  pub sunStateVelX: f64,
  pub sunStateVelY: f64,
  pub sunStateVelZ: f64,
  pub numCatalogStars: i32,
  pub numDetectedStars: i32,
  pub numCorrelatedStars: i32,
  pub predictedRaUnc: f64,
  pub predictedDeclinationUnc: f64,
  pub raCov: f64,
  pub declinationCov: f64,
  pub raDeclinationCov: f64,
  pub acalCrPixX: f64,
  pub acalCrPixY: f64,
  pub acalCrValX: f64,
  pub acalCrValY: f64,
  pub acalNumStars: i32,
  pub objSunRange: f64,
  pub phaseAngBisect: f64,
  pub solarDiskFrac: f64,
  pub toes: f64,
  pub does: f64,
  pub source: Option<String>,
  pub dataMode: EOObservationDetails_Ingest_dataMode_Enum,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
}
impl Default for EOObservationDetails_IngestT {
  fn default() -> Self {
    Self {
      idEOObservation: None,
      classificationMarking: None,
      obTime: None,
      predictedRa: 0.0,
      predictedDeclination: 0.0,
      predictedAzimuth: 0.0,
      predictedElevation: 0.0,
      sunAzimuth: 0.0,
      sunElevation: 0.0,
      numSpectralFilters: 0,
      spectralFilters: None,
      spectralZMFL: None,
      spectralFilterSolarMag: None,
      zeroPoints: None,
      zeroPointsUnc: None,
      extinctionCoeffs: None,
      extinctionCoeffsUnc: None,
      colorCoeffs: None,
      numNeutralDensityFilters: 0,
      neutralDensityFilterNames: None,
      neutralDensityFilterTransmissions: None,
      neutralDensityFilterTransmissionsUnc: None,
      gain: 0.0,
      ifov: 0.0,
      pixelArrayWidth: 0,
      pixelArrayHeight: 0,
      pixelMin: 0,
      pixelMax: 0,
      centroidRow: 0.0,
      centroidColumn: 0.0,
      rowVariance: 0.0,
      columnVariance: 0.0,
      rowColCov: 0.0,
      distFromStreakCenter: None,
      surfBrightness: None,
      surfBrightnessUnc: None,
      timesUnc: 0.0,
      ccdTemp: 0.0,
      currentSpectralFilterNum: 0,
      currentNeutralDensityFilterNum: 0,
      binningHoriz: 0,
      binningVert: 0,
      pcalNumStars: 0,
      ccdObjPosX: 0.0,
      ccdObjPosY: 0.0,
      ccdObjWidth: 0.0,
      backgroundSignal: 0.0,
      backgroundSignalUnc: 0.0,
      peakApertureCount: 0.0,
      peakBackgroundCount: 0,
      snrEst: 0.0,
      magInstrumental: 0.0,
      magInstrumentalUnc: 0.0,
      opticalCrossSection: 0.0,
      opticalCrossSectionUnc: 0.0,
      sunStatePosX: 0.0,
      sunStatePosY: 0.0,
      sunStatePosZ: 0.0,
      sunStateVelX: 0.0,
      sunStateVelY: 0.0,
      sunStateVelZ: 0.0,
      numCatalogStars: 0,
      numDetectedStars: 0,
      numCorrelatedStars: 0,
      predictedRaUnc: 0.0,
      predictedDeclinationUnc: 0.0,
      raCov: 0.0,
      declinationCov: 0.0,
      raDeclinationCov: 0.0,
      acalCrPixX: 0.0,
      acalCrPixY: 0.0,
      acalCrValX: 0.0,
      acalCrValY: 0.0,
      acalNumStars: 0,
      objSunRange: 0.0,
      phaseAngBisect: 0.0,
      solarDiskFrac: 0.0,
      toes: 0.0,
      does: 0.0,
      source: None,
      dataMode: EOObservationDetails_Ingest_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
    }
  }
}
impl EOObservationDetails_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EOObservationDetails_Ingest<'b>> {
    let idEOObservation = self.idEOObservation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let obTime = self.obTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let predictedRa = self.predictedRa;
    let predictedDeclination = self.predictedDeclination;
    let predictedAzimuth = self.predictedAzimuth;
    let predictedElevation = self.predictedElevation;
    let sunAzimuth = self.sunAzimuth;
    let sunElevation = self.sunElevation;
    let numSpectralFilters = self.numSpectralFilters;
    let spectralFilters = self.spectralFilters.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let spectralZMFL = self.spectralZMFL.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let spectralFilterSolarMag = self.spectralFilterSolarMag.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let zeroPoints = self.zeroPoints.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let zeroPointsUnc = self.zeroPointsUnc.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let extinctionCoeffs = self.extinctionCoeffs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let extinctionCoeffsUnc = self.extinctionCoeffsUnc.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let colorCoeffs = self.colorCoeffs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let numNeutralDensityFilters = self.numNeutralDensityFilters;
    let neutralDensityFilterNames = self.neutralDensityFilterNames.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let neutralDensityFilterTransmissions = self.neutralDensityFilterTransmissions.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let neutralDensityFilterTransmissionsUnc = self.neutralDensityFilterTransmissionsUnc.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let gain = self.gain;
    let ifov = self.ifov;
    let pixelArrayWidth = self.pixelArrayWidth;
    let pixelArrayHeight = self.pixelArrayHeight;
    let pixelMin = self.pixelMin;
    let pixelMax = self.pixelMax;
    let centroidRow = self.centroidRow;
    let centroidColumn = self.centroidColumn;
    let rowVariance = self.rowVariance;
    let columnVariance = self.columnVariance;
    let rowColCov = self.rowColCov;
    let distFromStreakCenter = self.distFromStreakCenter.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let surfBrightness = self.surfBrightness.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let surfBrightnessUnc = self.surfBrightnessUnc.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let timesUnc = self.timesUnc;
    let ccdTemp = self.ccdTemp;
    let currentSpectralFilterNum = self.currentSpectralFilterNum;
    let currentNeutralDensityFilterNum = self.currentNeutralDensityFilterNum;
    let binningHoriz = self.binningHoriz;
    let binningVert = self.binningVert;
    let pcalNumStars = self.pcalNumStars;
    let ccdObjPosX = self.ccdObjPosX;
    let ccdObjPosY = self.ccdObjPosY;
    let ccdObjWidth = self.ccdObjWidth;
    let backgroundSignal = self.backgroundSignal;
    let backgroundSignalUnc = self.backgroundSignalUnc;
    let peakApertureCount = self.peakApertureCount;
    let peakBackgroundCount = self.peakBackgroundCount;
    let snrEst = self.snrEst;
    let magInstrumental = self.magInstrumental;
    let magInstrumentalUnc = self.magInstrumentalUnc;
    let opticalCrossSection = self.opticalCrossSection;
    let opticalCrossSectionUnc = self.opticalCrossSectionUnc;
    let sunStatePosX = self.sunStatePosX;
    let sunStatePosY = self.sunStatePosY;
    let sunStatePosZ = self.sunStatePosZ;
    let sunStateVelX = self.sunStateVelX;
    let sunStateVelY = self.sunStateVelY;
    let sunStateVelZ = self.sunStateVelZ;
    let numCatalogStars = self.numCatalogStars;
    let numDetectedStars = self.numDetectedStars;
    let numCorrelatedStars = self.numCorrelatedStars;
    let predictedRaUnc = self.predictedRaUnc;
    let predictedDeclinationUnc = self.predictedDeclinationUnc;
    let raCov = self.raCov;
    let declinationCov = self.declinationCov;
    let raDeclinationCov = self.raDeclinationCov;
    let acalCrPixX = self.acalCrPixX;
    let acalCrPixY = self.acalCrPixY;
    let acalCrValX = self.acalCrValX;
    let acalCrValY = self.acalCrValY;
    let acalNumStars = self.acalNumStars;
    let objSunRange = self.objSunRange;
    let phaseAngBisect = self.phaseAngBisect;
    let solarDiskFrac = self.solarDiskFrac;
    let toes = self.toes;
    let does = self.does;
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    EOObservationDetails_Ingest::create(_fbb, &EOObservationDetails_IngestArgs{
      idEOObservation,
      classificationMarking,
      obTime,
      predictedRa,
      predictedDeclination,
      predictedAzimuth,
      predictedElevation,
      sunAzimuth,
      sunElevation,
      numSpectralFilters,
      spectralFilters,
      spectralZMFL,
      spectralFilterSolarMag,
      zeroPoints,
      zeroPointsUnc,
      extinctionCoeffs,
      extinctionCoeffsUnc,
      colorCoeffs,
      numNeutralDensityFilters,
      neutralDensityFilterNames,
      neutralDensityFilterTransmissions,
      neutralDensityFilterTransmissionsUnc,
      gain,
      ifov,
      pixelArrayWidth,
      pixelArrayHeight,
      pixelMin,
      pixelMax,
      centroidRow,
      centroidColumn,
      rowVariance,
      columnVariance,
      rowColCov,
      distFromStreakCenter,
      surfBrightness,
      surfBrightnessUnc,
      timesUnc,
      ccdTemp,
      currentSpectralFilterNum,
      currentNeutralDensityFilterNum,
      binningHoriz,
      binningVert,
      pcalNumStars,
      ccdObjPosX,
      ccdObjPosY,
      ccdObjWidth,
      backgroundSignal,
      backgroundSignalUnc,
      peakApertureCount,
      peakBackgroundCount,
      snrEst,
      magInstrumental,
      magInstrumentalUnc,
      opticalCrossSection,
      opticalCrossSectionUnc,
      sunStatePosX,
      sunStatePosY,
      sunStatePosZ,
      sunStateVelX,
      sunStateVelY,
      sunStateVelZ,
      numCatalogStars,
      numDetectedStars,
      numCorrelatedStars,
      predictedRaUnc,
      predictedDeclinationUnc,
      raCov,
      declinationCov,
      raDeclinationCov,
      acalCrPixX,
      acalCrPixY,
      acalCrValX,
      acalCrValY,
      acalNumStars,
      objSunRange,
      phaseAngBisect,
      solarDiskFrac,
      toes,
      does,
      source,
      dataMode,
      createdAt,
      createdBy,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EOObservationDetails_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_eoobservation_details_ingest_unchecked`.
pub fn root_as_eoobservation_details_ingest(buf: &[u8]) -> Result<EOObservationDetails_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EOObservationDetails_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EOObservationDetails_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_eoobservation_details_ingest_unchecked`.
pub fn size_prefixed_root_as_eoobservation_details_ingest(buf: &[u8]) -> Result<EOObservationDetails_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EOObservationDetails_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EOObservationDetails_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_eoobservation_details_ingest_unchecked`.
pub fn root_as_eoobservation_details_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EOObservationDetails_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EOObservationDetails_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EOObservationDetails_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_eoobservation_details_ingest_unchecked`.
pub fn size_prefixed_root_as_eoobservation_details_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EOObservationDetails_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EOObservationDetails_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EOObservationDetails_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EOObservationDetails_Ingest`.
pub unsafe fn root_as_eoobservation_details_ingest_unchecked(buf: &[u8]) -> EOObservationDetails_Ingest {
  flatbuffers::root_unchecked::<EOObservationDetails_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EOObservationDetails_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EOObservationDetails_Ingest`.
pub unsafe fn size_prefixed_root_as_eoobservation_details_ingest_unchecked(buf: &[u8]) -> EOObservationDetails_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<EOObservationDetails_Ingest>(buf)
}
pub const EOOBSERVATION_DETAILS_INGEST_IDENTIFIER: &str = "EOOB";

#[inline]
pub fn eoobservation_details_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EOOBSERVATION_DETAILS_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn eoobservation_details_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EOOBSERVATION_DETAILS_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_eoobservation_details_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<EOObservationDetails_Ingest<'a>>) {
  fbb.finish(root, Some(EOOBSERVATION_DETAILS_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_eoobservation_details_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<EOObservationDetails_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(EOOBSERVATION_DETAILS_INGEST_IDENTIFIER));
}
