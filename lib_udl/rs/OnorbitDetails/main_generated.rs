// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ONORBIT_DETAILS_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ONORBIT_DETAILS_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ONORBIT_DETAILS_DATA_MODE_ENUM: [OnorbitDetails_dataMode_Enum; 4] = [
  OnorbitDetails_dataMode_Enum::REAL,
  OnorbitDetails_dataMode_Enum::TEST,
  OnorbitDetails_dataMode_Enum::SIMULATED,
  OnorbitDetails_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OnorbitDetails_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl OnorbitDetails_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OnorbitDetails_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OnorbitDetails_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for OnorbitDetails_dataMode_Enum {
    type Output = OnorbitDetails_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OnorbitDetails_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OnorbitDetails_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OnorbitDetails_dataMode_Enum {}
pub enum OnorbitDetailsOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Contains details of the OnOrbit object.
pub struct OnorbitDetails<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OnorbitDetails<'a> {
  type Inner = OnorbitDetails<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OnorbitDetails<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 6;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 8;
  pub const VT_LASTOBTIME: flatbuffers::VOffsetT = 10;
  pub const VT_VISMAG: flatbuffers::VOffsetT = 12;
  pub const VT_VISMAGMIN: flatbuffers::VOffsetT = 14;
  pub const VT_VISMAGMAX: flatbuffers::VOffsetT = 16;
  pub const VT_VISMAGMEAN: flatbuffers::VOffsetT = 18;
  pub const VT_RCS: flatbuffers::VOffsetT = 20;
  pub const VT_RCSMIN: flatbuffers::VOffsetT = 22;
  pub const VT_RCSMAX: flatbuffers::VOffsetT = 24;
  pub const VT_RCSMEAN: flatbuffers::VOffsetT = 26;
  pub const VT_BOLDELTAV: flatbuffers::VOffsetT = 28;
  pub const VT_MAXDELTAV: flatbuffers::VOffsetT = 30;
  pub const VT_DELTAVUNC: flatbuffers::VOffsetT = 32;
  pub const VT_ESTDELTAVDURATION: flatbuffers::VOffsetT = 34;
  pub const VT_NUMMISSION: flatbuffers::VOffsetT = 36;
  pub const VT_MISSIONTYPES: flatbuffers::VOffsetT = 38;
  pub const VT_BUSTYPE: flatbuffers::VOffsetT = 40;
  pub const VT_GEOSLOT: flatbuffers::VOffsetT = 42;
  pub const VT_DRIFTRATE: flatbuffers::VOffsetT = 44;
  pub const VT_DRYMASS: flatbuffers::VOffsetT = 46;
  pub const VT_ADDITIONALMASS: flatbuffers::VOffsetT = 48;
  pub const VT_LAUNCHMASSMIN: flatbuffers::VOffsetT = 50;
  pub const VT_LAUNCHMASS: flatbuffers::VOffsetT = 52;
  pub const VT_LAUNCHMASSMAX: flatbuffers::VOffsetT = 54;
  pub const VT_BOLFUELMASS: flatbuffers::VOffsetT = 56;
  pub const VT_CURRENTMASS: flatbuffers::VOffsetT = 58;
  pub const VT_TOTALMASSUNC: flatbuffers::VOffsetT = 60;
  pub const VT_SOLARARRAYAREA: flatbuffers::VOffsetT = 62;
  pub const VT_MANEUVERABLE: flatbuffers::VOffsetT = 64;
  pub const VT_FUELREMAINING: flatbuffers::VOffsetT = 66;
  pub const VT_CROSSSECTION: flatbuffers::VOffsetT = 68;
  pub const VT_BUSCROSSSECTION: flatbuffers::VOffsetT = 70;
  pub const VT_MAXRADIUS: flatbuffers::VOffsetT = 72;
  pub const VT_COLARADIUS: flatbuffers::VOffsetT = 74;
  pub const VT_ADEPTRADIUS: flatbuffers::VOffsetT = 76;
  pub const VT_NUMDEPLOYABLE: flatbuffers::VOffsetT = 78;
  pub const VT_DEPNAMES: flatbuffers::VOffsetT = 80;
  pub const VT_DEPESTMASSES: flatbuffers::VOffsetT = 82;
  pub const VT_DEPMASSUNCS: flatbuffers::VOffsetT = 84;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 86;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 88;
  pub const VT_LASTOBSOURCE: flatbuffers::VOffsetT = 90;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 92;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 94;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 96;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 98;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 100;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 102;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OnorbitDetails { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OnorbitDetailsArgs<'args>
  ) -> flatbuffers::WIPOffset<OnorbitDetails<'bldr>> {
    let mut builder = OnorbitDetailsBuilder::new(_fbb);
    builder.add_adeptRadius(args.adeptRadius);
    builder.add_colaRadius(args.colaRadius);
    builder.add_maxRadius(args.maxRadius);
    builder.add_busCrossSection(args.busCrossSection);
    builder.add_crossSection(args.crossSection);
    builder.add_fuelRemaining(args.fuelRemaining);
    builder.add_solarArrayArea(args.solarArrayArea);
    builder.add_totalMassUnc(args.totalMassUnc);
    builder.add_currentMass(args.currentMass);
    builder.add_bolFuelMass(args.bolFuelMass);
    builder.add_launchMassMax(args.launchMassMax);
    builder.add_launchMass(args.launchMass);
    builder.add_launchMassMin(args.launchMassMin);
    builder.add_additionalMass(args.additionalMass);
    builder.add_dryMass(args.dryMass);
    builder.add_driftRate(args.driftRate);
    builder.add_geoSlot(args.geoSlot);
    builder.add_estDeltaVDuration(args.estDeltaVDuration);
    builder.add_deltaVUnc(args.deltaVUnc);
    builder.add_maxDeltaV(args.maxDeltaV);
    builder.add_bolDeltaV(args.bolDeltaV);
    builder.add_rcsMean(args.rcsMean);
    builder.add_rcsMax(args.rcsMax);
    builder.add_rcsMin(args.rcsMin);
    builder.add_rcs(args.rcs);
    builder.add_vismagMean(args.vismagMean);
    builder.add_vismagMax(args.vismagMax);
    builder.add_vismagMin(args.vismagMin);
    builder.add_vismag(args.vismag);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.lastObSource { builder.add_lastObSource(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.depMassUncs { builder.add_depMassUncs(x); }
    if let Some(x) = args.depEstMasses { builder.add_depEstMasses(x); }
    if let Some(x) = args.depNames { builder.add_depNames(x); }
    builder.add_numDeployable(args.numDeployable);
    if let Some(x) = args.busType { builder.add_busType(x); }
    if let Some(x) = args.missionTypes { builder.add_missionTypes(x); }
    builder.add_numMission(args.numMission);
    if let Some(x) = args.lastObTime { builder.add_lastObTime(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_maneuverable(args.maneuverable);
    builder.finish()
  }

  pub fn unpack(&self) -> OnorbitDetailsT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let lastObTime = self.lastObTime().map(|x| {
      x.to_string()
    });
    let vismag = self.vismag();
    let vismagMin = self.vismagMin();
    let vismagMax = self.vismagMax();
    let vismagMean = self.vismagMean();
    let rcs = self.rcs();
    let rcsMin = self.rcsMin();
    let rcsMax = self.rcsMax();
    let rcsMean = self.rcsMean();
    let bolDeltaV = self.bolDeltaV();
    let maxDeltaV = self.maxDeltaV();
    let deltaVUnc = self.deltaVUnc();
    let estDeltaVDuration = self.estDeltaVDuration();
    let numMission = self.numMission();
    let missionTypes = self.missionTypes().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let busType = self.busType().map(|x| {
      x.to_string()
    });
    let geoSlot = self.geoSlot();
    let driftRate = self.driftRate();
    let dryMass = self.dryMass();
    let additionalMass = self.additionalMass();
    let launchMassMin = self.launchMassMin();
    let launchMass = self.launchMass();
    let launchMassMax = self.launchMassMax();
    let bolFuelMass = self.bolFuelMass();
    let currentMass = self.currentMass();
    let totalMassUnc = self.totalMassUnc();
    let solarArrayArea = self.solarArrayArea();
    let maneuverable = self.maneuverable();
    let fuelRemaining = self.fuelRemaining();
    let crossSection = self.crossSection();
    let busCrossSection = self.busCrossSection();
    let maxRadius = self.maxRadius();
    let colaRadius = self.colaRadius();
    let adeptRadius = self.adeptRadius();
    let numDeployable = self.numDeployable();
    let depNames = self.depNames().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let depEstMasses = self.depEstMasses().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let depMassUncs = self.depMassUncs().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let lastObSource = self.lastObSource().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    OnorbitDetailsT {
      id,
      idOnOrbit,
      classificationMarking,
      lastObTime,
      vismag,
      vismagMin,
      vismagMax,
      vismagMean,
      rcs,
      rcsMin,
      rcsMax,
      rcsMean,
      bolDeltaV,
      maxDeltaV,
      deltaVUnc,
      estDeltaVDuration,
      numMission,
      missionTypes,
      busType,
      geoSlot,
      driftRate,
      dryMass,
      additionalMass,
      launchMassMin,
      launchMass,
      launchMassMax,
      bolFuelMass,
      currentMass,
      totalMassUnc,
      solarArrayArea,
      maneuverable,
      fuelRemaining,
      crossSection,
      busCrossSection,
      maxRadius,
      colaRadius,
      adeptRadius,
      numDeployable,
      depNames,
      depEstMasses,
      depMassUncs,
      source,
      origin,
      lastObSource,
      dataMode,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: ONORBITDETAILS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_ID, None)}
  }
  /// UUID of the parent Onorbit record.
  /// Example: /// Example: REF-ONORBIT-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_IDONORBIT, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Time of last reported observation for this object in ISO 8601 UTC with microsecond precision.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lastObTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_LASTOBTIME, None)}
  }
  /// Current/latest visual magnitude in M.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vismag(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_VISMAG, Some(0.0)).unwrap()}
  }
  /// Minimum visual magnitude in M.
  /// Example: /// Example: 5.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vismagMin(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_VISMAGMIN, Some(0.0)).unwrap()}
  }
  /// Maximum visual magnitude in M.
  /// Example: /// Example: 15.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vismagMax(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_VISMAGMAX, Some(0.0)).unwrap()}
  }
  /// Mean visual magnitude in M.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vismagMean(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_VISMAGMEAN, Some(0.0)).unwrap()}
  }
  /// Current/latest radar cross section in meters squared.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rcs(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_RCS, Some(0.0)).unwrap()}
  }
  /// Minimum radar cross section in meters squared.
  /// Example: /// Example: 5.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rcsMin(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_RCSMIN, Some(0.0)).unwrap()}
  }
  /// Maximum radar cross section in meters squared.
  /// Example: /// Example: 15.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rcsMax(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_RCSMAX, Some(0.0)).unwrap()}
  }
  /// Mean radar cross section in meters squared.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rcsMean(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_RCSMEAN, Some(0.0)).unwrap()}
  }
  /// The total beginning of life delta V of the spacecraft, in meters per second.
  /// Example: /// Example: 1000.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bolDeltaV(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_BOLDELTAV, Some(0.0)).unwrap()}
  }
  /// Maximum delta V available for this on-orbit spacecraft, in meters per second.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxDeltaV(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_MAXDELTAV, Some(0.0)).unwrap()}
  }
  /// The 1-sigma uncertainty of the total spacecraft delta V, in meters per second.
  /// Example: /// Example: 50.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaVUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_DELTAVUNC, Some(0.0)).unwrap()}
  }
  /// Estimated maximum burn duration for the object, in seconds.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn estDeltaVDuration(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_ESTDELTAVDURATION, Some(0.0)).unwrap()}
  }
  /// The number of distinct missions the spacecraft performs.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numMission(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OnorbitDetails::VT_NUMMISSION, Some(0)).unwrap()}
  }
  /// Array of the type of missions the spacecraft performs. Must contain the same number of elements as the value of numMission.
  /// Example: /// Example: ['Weather', 'Space Weather']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn missionTypes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OnorbitDetails::VT_MISSIONTYPES, None)}
  }
  /// Type of the bus on the spacecraft.
  /// Example: /// Example: A2100
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn busType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_BUSTYPE, None)}
  }
  /// GEO slot if applicable, in degrees. -180 (West of Prime Meridian) to 180 degrees (East of Prime Meridian). Prime Meridian is 0.
  /// Example: /// Example: 90.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn geoSlot(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_GEOSLOT, Some(0.0)).unwrap()}
  }
  /// GEO drift rate, if applicable in degrees per day.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn driftRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_DRIFTRATE, Some(0.0)).unwrap()}
  }
  /// Spacecraft dry mass (without fuel or disposables) in kilograms.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dryMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_DRYMASS, Some(0.0)).unwrap()}
  }
  /// Mass of fuel and disposables at launch time in kilograms.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn additionalMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_ADDITIONALMASS, Some(0.0)).unwrap()}
  }
  /// Minimum (estimated) mass of spacecraft and fuel at launch time, in kilograms.
  /// Example: /// Example: 5.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchMassMin(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_LAUNCHMASSMIN, Some(0.0)).unwrap()}
  }
  /// Nominal mass of spacecraft and fuel at launch time, in kilograms.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_LAUNCHMASS, Some(0.0)).unwrap()}
  }
  /// Maximum (estimated) mass of spacecraft and fuel at launch time, in kilograms.
  /// Example: /// Example: 15.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchMassMax(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_LAUNCHMASSMAX, Some(0.0)).unwrap()}
  }
  /// Spacecraft beginning of life fuel mass, in orbit, in kilograms.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bolFuelMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_BOLFUELMASS, Some(0.0)).unwrap()}
  }
  /// The estimated total current mass of the spacecraft, in kilograms.
  /// Example: /// Example: 500
  /// Constraints: No constraints specified.
  #[inline]
  pub fn currentMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_CURRENTMASS, Some(0.0)).unwrap()}
  }
  /// The 1-sigma uncertainty of the total spacecraft mass, in kilograms.
  /// Example: /// Example: 50.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn totalMassUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_TOTALMASSUNC, Some(0.0)).unwrap()}
  }
  /// Spacecraft deployed area of solar array in meters squared.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solarArrayArea(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_SOLARARRAYAREA, Some(0.0)).unwrap()}
  }
  /// Boolean indicating whether a spacecraft is maneuverable. Note that a spacecraft may have propulsion capability but may not be maneuverable due to lack of fuel, anomalous condition, or other operational constraints.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maneuverable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OnorbitDetails::VT_MANEUVERABLE, Some(false)).unwrap()}
  }
  /// Estimated remaining fuel for the object in kilograms.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fuelRemaining(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_FUELREMAINING, Some(0.0)).unwrap()}
  }
  /// Average cross sectional area in meters squared.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn crossSection(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_CROSSSECTION, Some(0.0)).unwrap()}
  }
  /// Average cross sectional area of the bus in meters squared.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn busCrossSection(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_BUSCROSSSECTION, Some(0.0)).unwrap()}
  }
  /// Maximum dimension across the spacecraft (e.g., tip-to-tip across the solar panel arrays) in meters.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxRadius(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_MAXRADIUS, Some(0.0)).unwrap()}
  }
  /// Maximum dimension of the box circumscribing the spacecraft (d = sqrt(a*a + b*b + c*c) where a is the tip-to-tip dimension, b and c are perpendicular to that.) in meters.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn colaRadius(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_COLARADIUS, Some(0.0)).unwrap()}
  }
  /// The radius used for long-term debris environment projection analyses that is not as conservative as COLA Radius, in meters.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn adeptRadius(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OnorbitDetails::VT_ADEPTRADIUS, Some(0.0)).unwrap()}
  }
  /// The number of sub-satellites or deployable objects on the spacecraft.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numDeployable(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OnorbitDetails::VT_NUMDEPLOYABLE, Some(0)).unwrap()}
  }
  /// Array of satellite deployable objects. Must contain the same number of elements as the value of numDeployable.
  /// Example: /// Example: ['GOES-18A', 'GOES-18B']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn depNames(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OnorbitDetails::VT_DEPNAMES, None)}
  }
  /// Array of the estimated mass of each deployable object, in kilograms. Must contain the same number of elements as the value of numDeployable.
  /// Example: /// Example: [20, 21]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn depEstMasses(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OnorbitDetails::VT_DEPESTMASSES, None)}
  }
  /// Array of the 1-sigma uncertainty of the mass for each deployable object, in kilograms. Must contain the same number of elements as the value of numDeployable.
  /// Example: /// Example: [10, 5]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn depMassUncs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OnorbitDetails::VT_DEPMASSUNCS, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_ORIGIN, None)}
  }
  /// The name of the source who last provided an observation for this idOnOrbit.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn lastObSource(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_LASTOBSOURCE, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> OnorbitDetails_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OnorbitDetails_dataMode_Enum>(OnorbitDetails::VT_DATAMODE, Some(OnorbitDetails_dataMode_Enum::REAL)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_CREATEDBY, None)}
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_UPDATEDBY, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OnorbitDetails::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for OnorbitDetails<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastObTime", Self::VT_LASTOBTIME, false)?
     .visit_field::<f64>("vismag", Self::VT_VISMAG, false)?
     .visit_field::<f64>("vismagMin", Self::VT_VISMAGMIN, false)?
     .visit_field::<f64>("vismagMax", Self::VT_VISMAGMAX, false)?
     .visit_field::<f64>("vismagMean", Self::VT_VISMAGMEAN, false)?
     .visit_field::<f64>("rcs", Self::VT_RCS, false)?
     .visit_field::<f64>("rcsMin", Self::VT_RCSMIN, false)?
     .visit_field::<f64>("rcsMax", Self::VT_RCSMAX, false)?
     .visit_field::<f64>("rcsMean", Self::VT_RCSMEAN, false)?
     .visit_field::<f64>("bolDeltaV", Self::VT_BOLDELTAV, false)?
     .visit_field::<f64>("maxDeltaV", Self::VT_MAXDELTAV, false)?
     .visit_field::<f64>("deltaVUnc", Self::VT_DELTAVUNC, false)?
     .visit_field::<f64>("estDeltaVDuration", Self::VT_ESTDELTAVDURATION, false)?
     .visit_field::<i32>("numMission", Self::VT_NUMMISSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("missionTypes", Self::VT_MISSIONTYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("busType", Self::VT_BUSTYPE, false)?
     .visit_field::<f64>("geoSlot", Self::VT_GEOSLOT, false)?
     .visit_field::<f64>("driftRate", Self::VT_DRIFTRATE, false)?
     .visit_field::<f64>("dryMass", Self::VT_DRYMASS, false)?
     .visit_field::<f64>("additionalMass", Self::VT_ADDITIONALMASS, false)?
     .visit_field::<f64>("launchMassMin", Self::VT_LAUNCHMASSMIN, false)?
     .visit_field::<f64>("launchMass", Self::VT_LAUNCHMASS, false)?
     .visit_field::<f64>("launchMassMax", Self::VT_LAUNCHMASSMAX, false)?
     .visit_field::<f64>("bolFuelMass", Self::VT_BOLFUELMASS, false)?
     .visit_field::<f64>("currentMass", Self::VT_CURRENTMASS, false)?
     .visit_field::<f64>("totalMassUnc", Self::VT_TOTALMASSUNC, false)?
     .visit_field::<f64>("solarArrayArea", Self::VT_SOLARARRAYAREA, false)?
     .visit_field::<bool>("maneuverable", Self::VT_MANEUVERABLE, false)?
     .visit_field::<f64>("fuelRemaining", Self::VT_FUELREMAINING, false)?
     .visit_field::<f64>("crossSection", Self::VT_CROSSSECTION, false)?
     .visit_field::<f64>("busCrossSection", Self::VT_BUSCROSSSECTION, false)?
     .visit_field::<f64>("maxRadius", Self::VT_MAXRADIUS, false)?
     .visit_field::<f64>("colaRadius", Self::VT_COLARADIUS, false)?
     .visit_field::<f64>("adeptRadius", Self::VT_ADEPTRADIUS, false)?
     .visit_field::<i32>("numDeployable", Self::VT_NUMDEPLOYABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("depNames", Self::VT_DEPNAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("depEstMasses", Self::VT_DEPESTMASSES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("depMassUncs", Self::VT_DEPMASSUNCS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastObSource", Self::VT_LASTOBSOURCE, false)?
     .visit_field::<OnorbitDetails_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct OnorbitDetailsArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lastObTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vismag: f64,
    pub vismagMin: f64,
    pub vismagMax: f64,
    pub vismagMean: f64,
    pub rcs: f64,
    pub rcsMin: f64,
    pub rcsMax: f64,
    pub rcsMean: f64,
    pub bolDeltaV: f64,
    pub maxDeltaV: f64,
    pub deltaVUnc: f64,
    pub estDeltaVDuration: f64,
    pub numMission: i32,
    pub missionTypes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub busType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub geoSlot: f64,
    pub driftRate: f64,
    pub dryMass: f64,
    pub additionalMass: f64,
    pub launchMassMin: f64,
    pub launchMass: f64,
    pub launchMassMax: f64,
    pub bolFuelMass: f64,
    pub currentMass: f64,
    pub totalMassUnc: f64,
    pub solarArrayArea: f64,
    pub maneuverable: bool,
    pub fuelRemaining: f64,
    pub crossSection: f64,
    pub busCrossSection: f64,
    pub maxRadius: f64,
    pub colaRadius: f64,
    pub adeptRadius: f64,
    pub numDeployable: i32,
    pub depNames: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub depEstMasses: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub depMassUncs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lastObSource: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: OnorbitDetails_dataMode_Enum,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OnorbitDetailsArgs<'a> {
  #[inline]
  fn default() -> Self {
    OnorbitDetailsArgs {
      id: None,
      idOnOrbit: None,
      classificationMarking: None,
      lastObTime: None,
      vismag: 0.0,
      vismagMin: 0.0,
      vismagMax: 0.0,
      vismagMean: 0.0,
      rcs: 0.0,
      rcsMin: 0.0,
      rcsMax: 0.0,
      rcsMean: 0.0,
      bolDeltaV: 0.0,
      maxDeltaV: 0.0,
      deltaVUnc: 0.0,
      estDeltaVDuration: 0.0,
      numMission: 0,
      missionTypes: None,
      busType: None,
      geoSlot: 0.0,
      driftRate: 0.0,
      dryMass: 0.0,
      additionalMass: 0.0,
      launchMassMin: 0.0,
      launchMass: 0.0,
      launchMassMax: 0.0,
      bolFuelMass: 0.0,
      currentMass: 0.0,
      totalMassUnc: 0.0,
      solarArrayArea: 0.0,
      maneuverable: false,
      fuelRemaining: 0.0,
      crossSection: 0.0,
      busCrossSection: 0.0,
      maxRadius: 0.0,
      colaRadius: 0.0,
      adeptRadius: 0.0,
      numDeployable: 0,
      depNames: None,
      depEstMasses: None,
      depMassUncs: None,
      source: None,
      origin: None,
      lastObSource: None,
      dataMode: OnorbitDetails_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      origNetwork: None,
    }
  }
}

pub struct OnorbitDetailsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OnorbitDetailsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_ID, id);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_lastObTime(&mut self, lastObTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_LASTOBTIME, lastObTime);
  }
  #[inline]
  pub fn add_vismag(&mut self, vismag: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_VISMAG, vismag, 0.0);
  }
  #[inline]
  pub fn add_vismagMin(&mut self, vismagMin: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_VISMAGMIN, vismagMin, 0.0);
  }
  #[inline]
  pub fn add_vismagMax(&mut self, vismagMax: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_VISMAGMAX, vismagMax, 0.0);
  }
  #[inline]
  pub fn add_vismagMean(&mut self, vismagMean: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_VISMAGMEAN, vismagMean, 0.0);
  }
  #[inline]
  pub fn add_rcs(&mut self, rcs: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_RCS, rcs, 0.0);
  }
  #[inline]
  pub fn add_rcsMin(&mut self, rcsMin: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_RCSMIN, rcsMin, 0.0);
  }
  #[inline]
  pub fn add_rcsMax(&mut self, rcsMax: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_RCSMAX, rcsMax, 0.0);
  }
  #[inline]
  pub fn add_rcsMean(&mut self, rcsMean: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_RCSMEAN, rcsMean, 0.0);
  }
  #[inline]
  pub fn add_bolDeltaV(&mut self, bolDeltaV: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_BOLDELTAV, bolDeltaV, 0.0);
  }
  #[inline]
  pub fn add_maxDeltaV(&mut self, maxDeltaV: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_MAXDELTAV, maxDeltaV, 0.0);
  }
  #[inline]
  pub fn add_deltaVUnc(&mut self, deltaVUnc: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_DELTAVUNC, deltaVUnc, 0.0);
  }
  #[inline]
  pub fn add_estDeltaVDuration(&mut self, estDeltaVDuration: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_ESTDELTAVDURATION, estDeltaVDuration, 0.0);
  }
  #[inline]
  pub fn add_numMission(&mut self, numMission: i32) {
    self.fbb_.push_slot::<i32>(OnorbitDetails::VT_NUMMISSION, numMission, 0);
  }
  #[inline]
  pub fn add_missionTypes(&mut self, missionTypes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_MISSIONTYPES, missionTypes);
  }
  #[inline]
  pub fn add_busType(&mut self, busType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_BUSTYPE, busType);
  }
  #[inline]
  pub fn add_geoSlot(&mut self, geoSlot: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_GEOSLOT, geoSlot, 0.0);
  }
  #[inline]
  pub fn add_driftRate(&mut self, driftRate: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_DRIFTRATE, driftRate, 0.0);
  }
  #[inline]
  pub fn add_dryMass(&mut self, dryMass: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_DRYMASS, dryMass, 0.0);
  }
  #[inline]
  pub fn add_additionalMass(&mut self, additionalMass: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_ADDITIONALMASS, additionalMass, 0.0);
  }
  #[inline]
  pub fn add_launchMassMin(&mut self, launchMassMin: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_LAUNCHMASSMIN, launchMassMin, 0.0);
  }
  #[inline]
  pub fn add_launchMass(&mut self, launchMass: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_LAUNCHMASS, launchMass, 0.0);
  }
  #[inline]
  pub fn add_launchMassMax(&mut self, launchMassMax: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_LAUNCHMASSMAX, launchMassMax, 0.0);
  }
  #[inline]
  pub fn add_bolFuelMass(&mut self, bolFuelMass: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_BOLFUELMASS, bolFuelMass, 0.0);
  }
  #[inline]
  pub fn add_currentMass(&mut self, currentMass: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_CURRENTMASS, currentMass, 0.0);
  }
  #[inline]
  pub fn add_totalMassUnc(&mut self, totalMassUnc: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_TOTALMASSUNC, totalMassUnc, 0.0);
  }
  #[inline]
  pub fn add_solarArrayArea(&mut self, solarArrayArea: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_SOLARARRAYAREA, solarArrayArea, 0.0);
  }
  #[inline]
  pub fn add_maneuverable(&mut self, maneuverable: bool) {
    self.fbb_.push_slot::<bool>(OnorbitDetails::VT_MANEUVERABLE, maneuverable, false);
  }
  #[inline]
  pub fn add_fuelRemaining(&mut self, fuelRemaining: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_FUELREMAINING, fuelRemaining, 0.0);
  }
  #[inline]
  pub fn add_crossSection(&mut self, crossSection: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_CROSSSECTION, crossSection, 0.0);
  }
  #[inline]
  pub fn add_busCrossSection(&mut self, busCrossSection: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_BUSCROSSSECTION, busCrossSection, 0.0);
  }
  #[inline]
  pub fn add_maxRadius(&mut self, maxRadius: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_MAXRADIUS, maxRadius, 0.0);
  }
  #[inline]
  pub fn add_colaRadius(&mut self, colaRadius: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_COLARADIUS, colaRadius, 0.0);
  }
  #[inline]
  pub fn add_adeptRadius(&mut self, adeptRadius: f64) {
    self.fbb_.push_slot::<f64>(OnorbitDetails::VT_ADEPTRADIUS, adeptRadius, 0.0);
  }
  #[inline]
  pub fn add_numDeployable(&mut self, numDeployable: i32) {
    self.fbb_.push_slot::<i32>(OnorbitDetails::VT_NUMDEPLOYABLE, numDeployable, 0);
  }
  #[inline]
  pub fn add_depNames(&mut self, depNames: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_DEPNAMES, depNames);
  }
  #[inline]
  pub fn add_depEstMasses(&mut self, depEstMasses: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_DEPESTMASSES, depEstMasses);
  }
  #[inline]
  pub fn add_depMassUncs(&mut self, depMassUncs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_DEPMASSUNCS, depMassUncs);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_lastObSource(&mut self, lastObSource: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_LASTOBSOURCE, lastObSource);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: OnorbitDetails_dataMode_Enum) {
    self.fbb_.push_slot::<OnorbitDetails_dataMode_Enum>(OnorbitDetails::VT_DATAMODE, dataMode, OnorbitDetails_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OnorbitDetails::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OnorbitDetailsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OnorbitDetailsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OnorbitDetails<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OnorbitDetails<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OnorbitDetails");
      ds.field("id", &self.id());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("lastObTime", &self.lastObTime());
      ds.field("vismag", &self.vismag());
      ds.field("vismagMin", &self.vismagMin());
      ds.field("vismagMax", &self.vismagMax());
      ds.field("vismagMean", &self.vismagMean());
      ds.field("rcs", &self.rcs());
      ds.field("rcsMin", &self.rcsMin());
      ds.field("rcsMax", &self.rcsMax());
      ds.field("rcsMean", &self.rcsMean());
      ds.field("bolDeltaV", &self.bolDeltaV());
      ds.field("maxDeltaV", &self.maxDeltaV());
      ds.field("deltaVUnc", &self.deltaVUnc());
      ds.field("estDeltaVDuration", &self.estDeltaVDuration());
      ds.field("numMission", &self.numMission());
      ds.field("missionTypes", &self.missionTypes());
      ds.field("busType", &self.busType());
      ds.field("geoSlot", &self.geoSlot());
      ds.field("driftRate", &self.driftRate());
      ds.field("dryMass", &self.dryMass());
      ds.field("additionalMass", &self.additionalMass());
      ds.field("launchMassMin", &self.launchMassMin());
      ds.field("launchMass", &self.launchMass());
      ds.field("launchMassMax", &self.launchMassMax());
      ds.field("bolFuelMass", &self.bolFuelMass());
      ds.field("currentMass", &self.currentMass());
      ds.field("totalMassUnc", &self.totalMassUnc());
      ds.field("solarArrayArea", &self.solarArrayArea());
      ds.field("maneuverable", &self.maneuverable());
      ds.field("fuelRemaining", &self.fuelRemaining());
      ds.field("crossSection", &self.crossSection());
      ds.field("busCrossSection", &self.busCrossSection());
      ds.field("maxRadius", &self.maxRadius());
      ds.field("colaRadius", &self.colaRadius());
      ds.field("adeptRadius", &self.adeptRadius());
      ds.field("numDeployable", &self.numDeployable());
      ds.field("depNames", &self.depNames());
      ds.field("depEstMasses", &self.depEstMasses());
      ds.field("depMassUncs", &self.depMassUncs());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("lastObSource", &self.lastObSource());
      ds.field("dataMode", &self.dataMode());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OnorbitDetailsT {
  pub id: Option<String>,
  pub idOnOrbit: Option<String>,
  pub classificationMarking: Option<String>,
  pub lastObTime: Option<String>,
  pub vismag: f64,
  pub vismagMin: f64,
  pub vismagMax: f64,
  pub vismagMean: f64,
  pub rcs: f64,
  pub rcsMin: f64,
  pub rcsMax: f64,
  pub rcsMean: f64,
  pub bolDeltaV: f64,
  pub maxDeltaV: f64,
  pub deltaVUnc: f64,
  pub estDeltaVDuration: f64,
  pub numMission: i32,
  pub missionTypes: Option<Vec<String>>,
  pub busType: Option<String>,
  pub geoSlot: f64,
  pub driftRate: f64,
  pub dryMass: f64,
  pub additionalMass: f64,
  pub launchMassMin: f64,
  pub launchMass: f64,
  pub launchMassMax: f64,
  pub bolFuelMass: f64,
  pub currentMass: f64,
  pub totalMassUnc: f64,
  pub solarArrayArea: f64,
  pub maneuverable: bool,
  pub fuelRemaining: f64,
  pub crossSection: f64,
  pub busCrossSection: f64,
  pub maxRadius: f64,
  pub colaRadius: f64,
  pub adeptRadius: f64,
  pub numDeployable: i32,
  pub depNames: Option<Vec<String>>,
  pub depEstMasses: Option<Vec<String>>,
  pub depMassUncs: Option<Vec<String>>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub lastObSource: Option<String>,
  pub dataMode: OnorbitDetails_dataMode_Enum,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
  pub origNetwork: Option<String>,
}
impl Default for OnorbitDetailsT {
  fn default() -> Self {
    Self {
      id: None,
      idOnOrbit: None,
      classificationMarking: None,
      lastObTime: None,
      vismag: 0.0,
      vismagMin: 0.0,
      vismagMax: 0.0,
      vismagMean: 0.0,
      rcs: 0.0,
      rcsMin: 0.0,
      rcsMax: 0.0,
      rcsMean: 0.0,
      bolDeltaV: 0.0,
      maxDeltaV: 0.0,
      deltaVUnc: 0.0,
      estDeltaVDuration: 0.0,
      numMission: 0,
      missionTypes: None,
      busType: None,
      geoSlot: 0.0,
      driftRate: 0.0,
      dryMass: 0.0,
      additionalMass: 0.0,
      launchMassMin: 0.0,
      launchMass: 0.0,
      launchMassMax: 0.0,
      bolFuelMass: 0.0,
      currentMass: 0.0,
      totalMassUnc: 0.0,
      solarArrayArea: 0.0,
      maneuverable: false,
      fuelRemaining: 0.0,
      crossSection: 0.0,
      busCrossSection: 0.0,
      maxRadius: 0.0,
      colaRadius: 0.0,
      adeptRadius: 0.0,
      numDeployable: 0,
      depNames: None,
      depEstMasses: None,
      depMassUncs: None,
      source: None,
      origin: None,
      lastObSource: None,
      dataMode: OnorbitDetails_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      origNetwork: None,
    }
  }
}
impl OnorbitDetailsT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OnorbitDetails<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lastObTime = self.lastObTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let vismag = self.vismag;
    let vismagMin = self.vismagMin;
    let vismagMax = self.vismagMax;
    let vismagMean = self.vismagMean;
    let rcs = self.rcs;
    let rcsMin = self.rcsMin;
    let rcsMax = self.rcsMax;
    let rcsMean = self.rcsMean;
    let bolDeltaV = self.bolDeltaV;
    let maxDeltaV = self.maxDeltaV;
    let deltaVUnc = self.deltaVUnc;
    let estDeltaVDuration = self.estDeltaVDuration;
    let numMission = self.numMission;
    let missionTypes = self.missionTypes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let busType = self.busType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let geoSlot = self.geoSlot;
    let driftRate = self.driftRate;
    let dryMass = self.dryMass;
    let additionalMass = self.additionalMass;
    let launchMassMin = self.launchMassMin;
    let launchMass = self.launchMass;
    let launchMassMax = self.launchMassMax;
    let bolFuelMass = self.bolFuelMass;
    let currentMass = self.currentMass;
    let totalMassUnc = self.totalMassUnc;
    let solarArrayArea = self.solarArrayArea;
    let maneuverable = self.maneuverable;
    let fuelRemaining = self.fuelRemaining;
    let crossSection = self.crossSection;
    let busCrossSection = self.busCrossSection;
    let maxRadius = self.maxRadius;
    let colaRadius = self.colaRadius;
    let adeptRadius = self.adeptRadius;
    let numDeployable = self.numDeployable;
    let depNames = self.depNames.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let depEstMasses = self.depEstMasses.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let depMassUncs = self.depMassUncs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lastObSource = self.lastObSource.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    OnorbitDetails::create(_fbb, &OnorbitDetailsArgs{
      id,
      idOnOrbit,
      classificationMarking,
      lastObTime,
      vismag,
      vismagMin,
      vismagMax,
      vismagMean,
      rcs,
      rcsMin,
      rcsMax,
      rcsMean,
      bolDeltaV,
      maxDeltaV,
      deltaVUnc,
      estDeltaVDuration,
      numMission,
      missionTypes,
      busType,
      geoSlot,
      driftRate,
      dryMass,
      additionalMass,
      launchMassMin,
      launchMass,
      launchMassMax,
      bolFuelMass,
      currentMass,
      totalMassUnc,
      solarArrayArea,
      maneuverable,
      fuelRemaining,
      crossSection,
      busCrossSection,
      maxRadius,
      colaRadius,
      adeptRadius,
      numDeployable,
      depNames,
      depEstMasses,
      depMassUncs,
      source,
      origin,
      lastObSource,
      dataMode,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OnorbitDetails`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_onorbit_details_unchecked`.
pub fn root_as_onorbit_details(buf: &[u8]) -> Result<OnorbitDetails, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OnorbitDetails>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OnorbitDetails` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_onorbit_details_unchecked`.
pub fn size_prefixed_root_as_onorbit_details(buf: &[u8]) -> Result<OnorbitDetails, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OnorbitDetails>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OnorbitDetails` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_onorbit_details_unchecked`.
pub fn root_as_onorbit_details_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OnorbitDetails<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OnorbitDetails<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OnorbitDetails` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_onorbit_details_unchecked`.
pub fn size_prefixed_root_as_onorbit_details_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OnorbitDetails<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OnorbitDetails<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OnorbitDetails and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OnorbitDetails`.
pub unsafe fn root_as_onorbit_details_unchecked(buf: &[u8]) -> OnorbitDetails {
  flatbuffers::root_unchecked::<OnorbitDetails>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OnorbitDetails and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OnorbitDetails`.
pub unsafe fn size_prefixed_root_as_onorbit_details_unchecked(buf: &[u8]) -> OnorbitDetails {
  flatbuffers::size_prefixed_root_unchecked::<OnorbitDetails>(buf)
}
pub const ONORBIT_DETAILS_IDENTIFIER: &str = "ONOR";

#[inline]
pub fn onorbit_details_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ONORBIT_DETAILS_IDENTIFIER, false)
}

#[inline]
pub fn onorbit_details_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ONORBIT_DETAILS_IDENTIFIER, true)
}

#[inline]
pub fn finish_onorbit_details_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OnorbitDetails<'a>>) {
  fbb.finish(root, Some(ONORBIT_DETAILS_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_onorbit_details_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OnorbitDetails<'a>>) {
  fbb.finish_size_prefixed(root, Some(ONORBIT_DETAILS_IDENTIFIER));
}
