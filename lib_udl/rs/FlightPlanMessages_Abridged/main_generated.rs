// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum FlightPlanMessages_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Collection of messages associated with this flight plan indicating the severity, the point where the message was generated, the path (Primary, Alternate, etc.), and the text of the message.
pub struct FlightPlanMessages_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FlightPlanMessages_Abridged<'a> {
  type Inner = FlightPlanMessages_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FlightPlanMessages_Abridged<'a> {
  pub const VT_SEVERITY: flatbuffers::VOffsetT = 4;
  pub const VT_WPNUM: flatbuffers::VOffsetT = 6;
  pub const VT_ROUTEPATH: flatbuffers::VOffsetT = 8;
  pub const VT_MSGTEXT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FlightPlanMessages_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FlightPlanMessages_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<FlightPlanMessages_Abridged<'bldr>> {
    let mut builder = FlightPlanMessages_AbridgedBuilder::new(_fbb);
    if let Some(x) = args.msgText { builder.add_msgText(x); }
    if let Some(x) = args.routePath { builder.add_routePath(x); }
    if let Some(x) = args.wpNum { builder.add_wpNum(x); }
    if let Some(x) = args.severity { builder.add_severity(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> FlightPlanMessages_AbridgedT {
    let severity = self.severity().map(|x| {
      x.to_string()
    });
    let wpNum = self.wpNum().map(|x| {
      x.to_string()
    });
    let routePath = self.routePath().map(|x| {
      x.to_string()
    });
    let msgText = self.msgText().map(|x| {
      x.to_string()
    });
    FlightPlanMessages_AbridgedT {
      severity,
      wpNum,
      routePath,
      msgText,
    }
  }

  /// The severity of the message.
  /// Example: /// Example: SEVERE
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn severity(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanMessages_Abridged::VT_SEVERITY, None)}
  }
  /// The waypoint number for which the message was generated, or enter "PLAN" for a message impacting the entire route.
  /// Example: /// Example: 20
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn wpNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanMessages_Abridged::VT_WPNUM, None)}
  }
  /// The flight path that generated the message (PRIMARY, ALTERNATE, etc.).
  /// Example: /// Example: PRIMARY
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn routePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanMessages_Abridged::VT_ROUTEPATH, None)}
  }
  /// The text of the message.
  /// Example: /// Example: Message text
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn msgText(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanMessages_Abridged::VT_MSGTEXT, None)}
  }
}

impl flatbuffers::Verifiable for FlightPlanMessages_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("severity", Self::VT_SEVERITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("wpNum", Self::VT_WPNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("routePath", Self::VT_ROUTEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msgText", Self::VT_MSGTEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct FlightPlanMessages_AbridgedArgs<'a> {
    pub severity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub wpNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub routePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgText: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FlightPlanMessages_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    FlightPlanMessages_AbridgedArgs {
      severity: None,
      wpNum: None,
      routePath: None,
      msgText: None,
    }
  }
}

pub struct FlightPlanMessages_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FlightPlanMessages_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_severity(&mut self, severity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanMessages_Abridged::VT_SEVERITY, severity);
  }
  #[inline]
  pub fn add_wpNum(&mut self, wpNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanMessages_Abridged::VT_WPNUM, wpNum);
  }
  #[inline]
  pub fn add_routePath(&mut self, routePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanMessages_Abridged::VT_ROUTEPATH, routePath);
  }
  #[inline]
  pub fn add_msgText(&mut self, msgText: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanMessages_Abridged::VT_MSGTEXT, msgText);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FlightPlanMessages_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FlightPlanMessages_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FlightPlanMessages_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FlightPlanMessages_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FlightPlanMessages_Abridged");
      ds.field("severity", &self.severity());
      ds.field("wpNum", &self.wpNum());
      ds.field("routePath", &self.routePath());
      ds.field("msgText", &self.msgText());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FlightPlanMessages_AbridgedT {
  pub severity: Option<String>,
  pub wpNum: Option<String>,
  pub routePath: Option<String>,
  pub msgText: Option<String>,
}
impl Default for FlightPlanMessages_AbridgedT {
  fn default() -> Self {
    Self {
      severity: None,
      wpNum: None,
      routePath: None,
      msgText: None,
    }
  }
}
impl FlightPlanMessages_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<FlightPlanMessages_Abridged<'b>> {
    let severity = self.severity.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let wpNum = self.wpNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let routePath = self.routePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msgText = self.msgText.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    FlightPlanMessages_Abridged::create(_fbb, &FlightPlanMessages_AbridgedArgs{
      severity,
      wpNum,
      routePath,
      msgText,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `FlightPlanMessages_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_messages_abridged_unchecked`.
pub fn root_as_flight_plan_messages_abridged(buf: &[u8]) -> Result<FlightPlanMessages_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<FlightPlanMessages_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FlightPlanMessages_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_flight_plan_messages_abridged_unchecked`.
pub fn size_prefixed_root_as_flight_plan_messages_abridged(buf: &[u8]) -> Result<FlightPlanMessages_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<FlightPlanMessages_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FlightPlanMessages_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_messages_abridged_unchecked`.
pub fn root_as_flight_plan_messages_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlightPlanMessages_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<FlightPlanMessages_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FlightPlanMessages_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_messages_abridged_unchecked`.
pub fn size_prefixed_root_as_flight_plan_messages_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlightPlanMessages_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<FlightPlanMessages_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FlightPlanMessages_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FlightPlanMessages_Abridged`.
pub unsafe fn root_as_flight_plan_messages_abridged_unchecked(buf: &[u8]) -> FlightPlanMessages_Abridged {
  flatbuffers::root_unchecked::<FlightPlanMessages_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FlightPlanMessages_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FlightPlanMessages_Abridged`.
pub unsafe fn size_prefixed_root_as_flight_plan_messages_abridged_unchecked(buf: &[u8]) -> FlightPlanMessages_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<FlightPlanMessages_Abridged>(buf)
}
pub const FLIGHT_PLAN_MESSAGES_ABRIDGED_IDENTIFIER: &str = "FLIG";

#[inline]
pub fn flight_plan_messages_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, FLIGHT_PLAN_MESSAGES_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn flight_plan_messages_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, FLIGHT_PLAN_MESSAGES_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_flight_plan_messages_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<FlightPlanMessages_Abridged<'a>>) {
  fbb.finish(root, Some(FLIGHT_PLAN_MESSAGES_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_flight_plan_messages_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<FlightPlanMessages_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(FLIGHT_PLAN_MESSAGES_ABRIDGED_IDENTIFIER));
}
