// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum CotData_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Schema for the CotData to post.
pub struct CotData_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CotData_Ingest<'a> {
  type Inner = CotData_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CotData_Ingest<'a> {
  pub const VT_SENDERUID: flatbuffers::VOffsetT = 4;
  pub const VT_HOW: flatbuffers::VOffsetT = 6;
  pub const VT_CE: flatbuffers::VOffsetT = 8;
  pub const VT_LE: flatbuffers::VOffsetT = 10;
  pub const VT_STALE: flatbuffers::VOffsetT = 12;
  pub const VT_START: flatbuffers::VOffsetT = 14;
  pub const VT_LAT: flatbuffers::VOffsetT = 16;
  pub const VT_LON: flatbuffers::VOffsetT = 18;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 20;
  pub const VT_ALT: flatbuffers::VOffsetT = 22;
  pub const VT_COTPOSITIONDATA: flatbuffers::VOffsetT = 24;
  pub const VT_COTCHATDATA: flatbuffers::VOffsetT = 26;
  pub const VT_CALLSIGNS: flatbuffers::VOffsetT = 28;
  pub const VT_UIDS: flatbuffers::VOffsetT = 30;
  pub const VT_GROUPS: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CotData_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CotData_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<CotData_Ingest<'bldr>> {
    let mut builder = CotData_IngestBuilder::new(_fbb);
    builder.add_alt(args.alt);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    builder.add_le(args.le);
    builder.add_ce(args.ce);
    if let Some(x) = args.groups { builder.add_groups(x); }
    if let Some(x) = args.uids { builder.add_uids(x); }
    if let Some(x) = args.callSigns { builder.add_callSigns(x); }
    if let Some(x) = args.cotChatData { builder.add_cotChatData(x); }
    if let Some(x) = args.cotPositionData { builder.add_cotPositionData(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.start { builder.add_start(x); }
    if let Some(x) = args.stale { builder.add_stale(x); }
    if let Some(x) = args.how { builder.add_how(x); }
    if let Some(x) = args.senderUid { builder.add_senderUid(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CotData_IngestT {
    let senderUid = self.senderUid().map(|x| {
      x.to_string()
    });
    let how = self.how().map(|x| {
      x.to_string()
    });
    let ce = self.ce();
    let le = self.le();
    let stale = self.stale().map(|x| {
      x.to_string()
    });
    let start = self.start().map(|x| {
      x.to_string()
    });
    let lat = self.lat();
    let lon = self.lon();
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let alt = self.alt();
    let cotPositionData = self.cotPositionData().map(|x| {
      x.to_string()
    });
    let cotChatData = self.cotChatData().map(|x| {
      x.to_string()
    });
    let callSigns = self.callSigns().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let uids = self.uids().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let groups = self.groups().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    CotData_IngestT {
      senderUid,
      how,
      ce,
      le,
      stale,
      start,
      lat,
      lon,
      type_,
      alt,
      cotPositionData,
      cotChatData,
      callSigns,
      uids,
      groups,
    }
  }

  /// Identifier of the sender of the cot message which should remain the same on subsequent POI records of the same point of interest.
  /// Example: /// Example: POI-ID
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senderUid(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CotData_Ingest::VT_SENDERUID, None)}
  }
  /// How the event point was generated, in CoT object heirarchy notation (optional, CoT).
  /// Example: /// Example: h-e
  /// Constraints: No constraints specified.
  #[inline]
  pub fn how(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CotData_Ingest::VT_HOW, None)}
  }
  /// Radius of circular area about lat/lon point, in meters (1-sigma, if representing error).
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ce(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CotData_Ingest::VT_CE, Some(0.0)).unwrap()}
  }
  /// Height above lat/lon point, in meters (1-sigma, if representing linear error).
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn le(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CotData_Ingest::VT_LE, Some(0.0)).unwrap()}
  }
  /// Stale timestamp (optional), in ISO8601 UTC format.
  /// Example: /// Example: 2020-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stale(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CotData_Ingest::VT_STALE, None)}
  }
  /// Start time of event validity (optional), in ISO8601 UTC format.
  /// Example: /// Example: 2020-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn start(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CotData_Ingest::VT_START, None)}
  }
  /// WGS-84 latitude of the POI, in degrees (+N, -S), -90 to 90.
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CotData_Ingest::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude of the POI, in degrees (+E, -W), -180 to 180.
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CotData_Ingest::VT_LON, Some(0.0)).unwrap()}
  }
  /// Event type, in CoT object heirarchy notation (optional, CoT).
  /// Example: /// Example: a-h-G
  /// Constraints: No constraints specified.
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CotData_Ingest::VT_TYPE_, None)}
  }
  /// Point height above ellipsoid (WGS-84), in meters.
  /// Example: /// Example: 5.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn alt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CotData_Ingest::VT_ALT, Some(0.0)).unwrap()}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cotPositionData(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CotData_Ingest::VT_COTPOSITIONDATA, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cotChatData(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CotData_Ingest::VT_COTCHATDATA, None)}
  }
  /// Optional list of call signs to send message to directly.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn callSigns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CotData_Ingest::VT_CALLSIGNS, None)}
  }
  /// Optional list of TAK user ids to send message to directly.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn uids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CotData_Ingest::VT_UIDS, None)}
  }
  /// Optional set of groups to send message to specifically.  If not specified, the message will be sent to the default _ANON_ group.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn groups(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CotData_Ingest::VT_GROUPS, None)}
  }
}

impl flatbuffers::Verifiable for CotData_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("senderUid", Self::VT_SENDERUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("how", Self::VT_HOW, false)?
     .visit_field::<f64>("ce", Self::VT_CE, false)?
     .visit_field::<f64>("le", Self::VT_LE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stale", Self::VT_STALE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("start", Self::VT_START, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<f64>("alt", Self::VT_ALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cotPositionData", Self::VT_COTPOSITIONDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cotChatData", Self::VT_COTCHATDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("callSigns", Self::VT_CALLSIGNS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("uids", Self::VT_UIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("groups", Self::VT_GROUPS, false)?
     .finish();
    Ok(())
  }
}
pub struct CotData_IngestArgs<'a> {
    pub senderUid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub how: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ce: f64,
    pub le: f64,
    pub stale: Option<flatbuffers::WIPOffset<&'a str>>,
    pub start: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lat: f64,
    pub lon: f64,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub alt: f64,
    pub cotPositionData: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cotChatData: Option<flatbuffers::WIPOffset<&'a str>>,
    pub callSigns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub uids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub groups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for CotData_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    CotData_IngestArgs {
      senderUid: None,
      how: None,
      ce: 0.0,
      le: 0.0,
      stale: None,
      start: None,
      lat: 0.0,
      lon: 0.0,
      type_: None,
      alt: 0.0,
      cotPositionData: None,
      cotChatData: None,
      callSigns: None,
      uids: None,
      groups: None,
    }
  }
}

pub struct CotData_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CotData_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_senderUid(&mut self, senderUid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CotData_Ingest::VT_SENDERUID, senderUid);
  }
  #[inline]
  pub fn add_how(&mut self, how: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CotData_Ingest::VT_HOW, how);
  }
  #[inline]
  pub fn add_ce(&mut self, ce: f64) {
    self.fbb_.push_slot::<f64>(CotData_Ingest::VT_CE, ce, 0.0);
  }
  #[inline]
  pub fn add_le(&mut self, le: f64) {
    self.fbb_.push_slot::<f64>(CotData_Ingest::VT_LE, le, 0.0);
  }
  #[inline]
  pub fn add_stale(&mut self, stale: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CotData_Ingest::VT_STALE, stale);
  }
  #[inline]
  pub fn add_start(&mut self, start: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CotData_Ingest::VT_START, start);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(CotData_Ingest::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(CotData_Ingest::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CotData_Ingest::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_alt(&mut self, alt: f64) {
    self.fbb_.push_slot::<f64>(CotData_Ingest::VT_ALT, alt, 0.0);
  }
  #[inline]
  pub fn add_cotPositionData(&mut self, cotPositionData: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CotData_Ingest::VT_COTPOSITIONDATA, cotPositionData);
  }
  #[inline]
  pub fn add_cotChatData(&mut self, cotChatData: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CotData_Ingest::VT_COTCHATDATA, cotChatData);
  }
  #[inline]
  pub fn add_callSigns(&mut self, callSigns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CotData_Ingest::VT_CALLSIGNS, callSigns);
  }
  #[inline]
  pub fn add_uids(&mut self, uids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CotData_Ingest::VT_UIDS, uids);
  }
  #[inline]
  pub fn add_groups(&mut self, groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CotData_Ingest::VT_GROUPS, groups);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CotData_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CotData_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CotData_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CotData_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CotData_Ingest");
      ds.field("senderUid", &self.senderUid());
      ds.field("how", &self.how());
      ds.field("ce", &self.ce());
      ds.field("le", &self.le());
      ds.field("stale", &self.stale());
      ds.field("start", &self.start());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("type_", &self.type_());
      ds.field("alt", &self.alt());
      ds.field("cotPositionData", &self.cotPositionData());
      ds.field("cotChatData", &self.cotChatData());
      ds.field("callSigns", &self.callSigns());
      ds.field("uids", &self.uids());
      ds.field("groups", &self.groups());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CotData_IngestT {
  pub senderUid: Option<String>,
  pub how: Option<String>,
  pub ce: f64,
  pub le: f64,
  pub stale: Option<String>,
  pub start: Option<String>,
  pub lat: f64,
  pub lon: f64,
  pub type_: Option<String>,
  pub alt: f64,
  pub cotPositionData: Option<String>,
  pub cotChatData: Option<String>,
  pub callSigns: Option<Vec<String>>,
  pub uids: Option<Vec<String>>,
  pub groups: Option<Vec<String>>,
}
impl Default for CotData_IngestT {
  fn default() -> Self {
    Self {
      senderUid: None,
      how: None,
      ce: 0.0,
      le: 0.0,
      stale: None,
      start: None,
      lat: 0.0,
      lon: 0.0,
      type_: None,
      alt: 0.0,
      cotPositionData: None,
      cotChatData: None,
      callSigns: None,
      uids: None,
      groups: None,
    }
  }
}
impl CotData_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CotData_Ingest<'b>> {
    let senderUid = self.senderUid.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let how = self.how.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ce = self.ce;
    let le = self.le;
    let stale = self.stale.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let start = self.start.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lat = self.lat;
    let lon = self.lon;
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let alt = self.alt;
    let cotPositionData = self.cotPositionData.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cotChatData = self.cotChatData.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let callSigns = self.callSigns.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let uids = self.uids.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let groups = self.groups.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    CotData_Ingest::create(_fbb, &CotData_IngestArgs{
      senderUid,
      how,
      ce,
      le,
      stale,
      start,
      lat,
      lon,
      type_,
      alt,
      cotPositionData,
      cotChatData,
      callSigns,
      uids,
      groups,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CotData_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_cot_data_ingest_unchecked`.
pub fn root_as_cot_data_ingest(buf: &[u8]) -> Result<CotData_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<CotData_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CotData_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_cot_data_ingest_unchecked`.
pub fn size_prefixed_root_as_cot_data_ingest(buf: &[u8]) -> Result<CotData_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<CotData_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CotData_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_cot_data_ingest_unchecked`.
pub fn root_as_cot_data_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CotData_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<CotData_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CotData_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_cot_data_ingest_unchecked`.
pub fn size_prefixed_root_as_cot_data_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CotData_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<CotData_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CotData_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CotData_Ingest`.
pub unsafe fn root_as_cot_data_ingest_unchecked(buf: &[u8]) -> CotData_Ingest {
  flatbuffers::root_unchecked::<CotData_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CotData_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CotData_Ingest`.
pub unsafe fn size_prefixed_root_as_cot_data_ingest_unchecked(buf: &[u8]) -> CotData_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<CotData_Ingest>(buf)
}
pub const COT_DATA_INGEST_IDENTIFIER: &str = "COTD";

#[inline]
pub fn cot_data_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, COT_DATA_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn cot_data_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, COT_DATA_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_cot_data_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CotData_Ingest<'a>>) {
  fbb.finish(root, Some(COT_DATA_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_cot_data_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<CotData_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(COT_DATA_INGEST_IDENTIFIER));
}
