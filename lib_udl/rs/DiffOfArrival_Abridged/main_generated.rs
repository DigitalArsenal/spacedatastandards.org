// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIFF_OF_ARRIVAL_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIFF_OF_ARRIVAL_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIFF_OF_ARRIVAL_ABRIDGED_DATA_MODE_ENUM: [DiffOfArrival_Abridged_dataMode_Enum; 4] = [
  DiffOfArrival_Abridged_dataMode_Enum::REAL,
  DiffOfArrival_Abridged_dataMode_Enum::TEST,
  DiffOfArrival_Abridged_dataMode_Enum::SIMULATED,
  DiffOfArrival_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DiffOfArrival_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl DiffOfArrival_Abridged_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DiffOfArrival_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DiffOfArrival_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DiffOfArrival_Abridged_dataMode_Enum {
    type Output = DiffOfArrival_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DiffOfArrival_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DiffOfArrival_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DiffOfArrival_Abridged_dataMode_Enum {}
pub enum DiffOfArrival_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Model representation of Signal time and frequency difference of arrival (TDOA/FDOA) information obtained by using passive RF based sensor phenomenologies and sensor triangulation.
pub struct DiffOfArrival_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DiffOfArrival_Abridged<'a> {
  type Inner = DiffOfArrival_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DiffOfArrival_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_OBTIME: flatbuffers::VOffsetT = 8;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 10;
  pub const VT_IDSENSOR1: flatbuffers::VOffsetT = 12;
  pub const VT_IDSENSOR2: flatbuffers::VOffsetT = 14;
  pub const VT_SATNO: flatbuffers::VOffsetT = 16;
  pub const VT_TASKID: flatbuffers::VOffsetT = 18;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 20;
  pub const VT_ORIGSENSORID1: flatbuffers::VOffsetT = 22;
  pub const VT_ORIGSENSORID2: flatbuffers::VOffsetT = 24;
  pub const VT_UCT: flatbuffers::VOffsetT = 26;
  pub const VT_SENSOR1DELAY: flatbuffers::VOffsetT = 28;
  pub const VT_SENSOR2DELAY: flatbuffers::VOffsetT = 30;
  pub const VT_SENLAT: flatbuffers::VOffsetT = 32;
  pub const VT_SENLON: flatbuffers::VOffsetT = 34;
  pub const VT_SENALT: flatbuffers::VOffsetT = 36;
  pub const VT_SEN2LAT: flatbuffers::VOffsetT = 38;
  pub const VT_SEN2LON: flatbuffers::VOffsetT = 40;
  pub const VT_SEN2ALT: flatbuffers::VOffsetT = 42;
  pub const VT_FREQUENCY: flatbuffers::VOffsetT = 44;
  pub const VT_BANDWIDTH: flatbuffers::VOffsetT = 46;
  pub const VT_DELTARANGE: flatbuffers::VOffsetT = 48;
  pub const VT_DELTARANGEUNC: flatbuffers::VOffsetT = 50;
  pub const VT_DELTARANGERATE: flatbuffers::VOffsetT = 52;
  pub const VT_DELTARANGERATEUNC: flatbuffers::VOffsetT = 54;
  pub const VT_SNR: flatbuffers::VOffsetT = 56;
  pub const VT_TDOA: flatbuffers::VOffsetT = 58;
  pub const VT_TDOAUNC: flatbuffers::VOffsetT = 60;
  pub const VT_FDOA: flatbuffers::VOffsetT = 62;
  pub const VT_FDOAUNC: flatbuffers::VOffsetT = 64;
  pub const VT_COLLECTIONMODE: flatbuffers::VOffsetT = 66;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 68;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 70;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 72;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 74;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 76;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 78;
  pub const VT_TRANSACTIONID: flatbuffers::VOffsetT = 80;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 82;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 84;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DiffOfArrival_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DiffOfArrival_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<DiffOfArrival_Abridged<'bldr>> {
    let mut builder = DiffOfArrival_AbridgedBuilder::new(_fbb);
    builder.add_fdoaUnc(args.fdoaUnc);
    builder.add_fdoa(args.fdoa);
    builder.add_tdoaUnc(args.tdoaUnc);
    builder.add_tdoa(args.tdoa);
    builder.add_snr(args.snr);
    builder.add_deltaRangeRateUnc(args.deltaRangeRateUnc);
    builder.add_deltaRangeRate(args.deltaRangeRate);
    builder.add_deltaRangeUnc(args.deltaRangeUnc);
    builder.add_deltaRange(args.deltaRange);
    builder.add_bandwidth(args.bandwidth);
    builder.add_frequency(args.frequency);
    builder.add_sen2alt(args.sen2alt);
    builder.add_sen2lon(args.sen2lon);
    builder.add_sen2lat(args.sen2lat);
    builder.add_senalt(args.senalt);
    builder.add_senlon(args.senlon);
    builder.add_senlat(args.senlat);
    builder.add_sensor2Delay(args.sensor2Delay);
    builder.add_sensor1Delay(args.sensor1Delay);
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.transactionId { builder.add_transactionId(x); }
    if let Some(x) = args.descriptor { builder.add_descriptor(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.collectionMode { builder.add_collectionMode(x); }
    if let Some(x) = args.origSensorId2 { builder.add_origSensorId2(x); }
    if let Some(x) = args.origSensorId1 { builder.add_origSensorId1(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    if let Some(x) = args.taskId { builder.add_taskId(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.idSensor2 { builder.add_idSensor2(x); }
    if let Some(x) = args.idSensor1 { builder.add_idSensor1(x); }
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.obTime { builder.add_obTime(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_uct(args.uct);
    builder.finish()
  }

  pub fn unpack(&self) -> DiffOfArrival_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let obTime = self.obTime().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let idSensor1 = self.idSensor1().map(|x| {
      x.to_string()
    });
    let idSensor2 = self.idSensor2().map(|x| {
      x.to_string()
    });
    let satNo = self.satNo();
    let taskId = self.taskId().map(|x| {
      x.to_string()
    });
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let origSensorId1 = self.origSensorId1().map(|x| {
      x.to_string()
    });
    let origSensorId2 = self.origSensorId2().map(|x| {
      x.to_string()
    });
    let uct = self.uct();
    let sensor1Delay = self.sensor1Delay();
    let sensor2Delay = self.sensor2Delay();
    let senlat = self.senlat();
    let senlon = self.senlon();
    let senalt = self.senalt();
    let sen2lat = self.sen2lat();
    let sen2lon = self.sen2lon();
    let sen2alt = self.sen2alt();
    let frequency = self.frequency();
    let bandwidth = self.bandwidth();
    let deltaRange = self.deltaRange();
    let deltaRangeUnc = self.deltaRangeUnc();
    let deltaRangeRate = self.deltaRangeRate();
    let deltaRangeRateUnc = self.deltaRangeRateUnc();
    let snr = self.snr();
    let tdoa = self.tdoa();
    let tdoaUnc = self.tdoaUnc();
    let fdoa = self.fdoa();
    let fdoaUnc = self.fdoaUnc();
    let collectionMode = self.collectionMode().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let descriptor = self.descriptor().map(|x| {
      x.to_string()
    });
    let transactionId = self.transactionId().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    DiffOfArrival_AbridgedT {
      id,
      classificationMarking,
      obTime,
      idOnOrbit,
      idSensor1,
      idSensor2,
      satNo,
      taskId,
      origObjectId,
      origSensorId1,
      origSensorId2,
      uct,
      sensor1Delay,
      sensor2Delay,
      senlat,
      senlon,
      senalt,
      sen2lat,
      sen2lon,
      sen2alt,
      frequency,
      bandwidth,
      deltaRange,
      deltaRangeUnc,
      deltaRangeRate,
      deltaRangeRateUnc,
      snr,
      tdoa,
      tdoaUnc,
      fdoa,
      fdoaUnc,
      collectionMode,
      source,
      dataMode,
      origin,
      createdAt,
      createdBy,
      descriptor,
      transactionId,
      origNetwork,
      sourceDL,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: DIFFOFARRIVAL-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Ob detection time in ISO 8601 UTC with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_OBTIME, None)}
  }
  /// Unique identifier of the target on-orbit object, if correlated.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_IDONORBIT, None)}
  }
  /// Sensor ID of the primary/1st sensor used for this measurement.
  /// Example: /// Example: SENSOR1-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_IDSENSOR1, None)}
  }
  /// Sensor ID of the secondary/2nd sensor used for this measurement.
  /// Example: /// Example: SENSOR2-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_IDSENSOR2, None)}
  }
  /// Catalog number of the target on-orbit object.
  /// Example: /// Example: 25544
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DiffOfArrival_Abridged::VT_SATNO, Some(0)).unwrap()}
  }
  /// Optional identifier to indicate the specific tasking which produced this observation.
  /// Example: /// Example: TASK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn taskId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_TASKID, None)}
  }
  /// Optional identifier provided by observation source to indicate the target onorbit object of this observation. This may be an internal identifier and not necessarily a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_ORIGOBJECTID, None)}
  }
  /// Optional identifier provided by DOA source to indicate the primary/1st sensor identifier used for this measurement. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR1-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origSensorId1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_ORIGSENSORID1, None)}
  }
  /// Optional identifier provided by DOA source to indicate the secondary/2nd sensor identifier used for this this observation. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR2-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origSensorId2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_ORIGSENSORID2, None)}
  }
  /// Boolean indicating this observation is part of an uncorrelated track or was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn uct(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DiffOfArrival_Abridged::VT_UCT, Some(false)).unwrap()}
  }
  /// The signal arrival delay relative to sensor 1 in seconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sensor1Delay(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_SENSOR1DELAY, Some(0.0)).unwrap()}
  }
  /// The signal arrival delay relative to sensor 2 in seconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sensor2Delay(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_SENSOR2DELAY, Some(0.0)).unwrap()}
  }
  /// Sensor WGS84 latitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_SENLAT, Some(0.0)).unwrap()}
  }
  /// Sensor WGS84 longitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 120.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_SENLON, Some(0.0)).unwrap()}
  }
  /// Sensor altitude at obTime (if mobile/onorbit) in km. If null, can be obtained from sensor info.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senalt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_SENALT, Some(0.0)).unwrap()}
  }
  /// Sensor 2 WGS84 latitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sen2lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_SEN2LAT, Some(0.0)).unwrap()}
  }
  /// Sensor 2 WGS84 longitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sen2lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_SEN2LON, Some(0.0)).unwrap()}
  }
  /// Sensor 2 altitude at obTime (if mobile/onorbit) in km. If null, can be obtained from sensor info.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sen2alt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_SEN2ALT, Some(0.0)).unwrap()}
  }
  /// Center frequency of the collect in Hz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn frequency(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_FREQUENCY, Some(0.0)).unwrap()}
  }
  /// Bandwidth of the signal in Hz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bandwidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_BANDWIDTH, Some(0.0)).unwrap()}
  }
  /// Delta range, in km. Delta range calculation convention is (sensor2 - sensor1).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_DELTARANGE, Some(0.0)).unwrap()}
  }
  /// One sigma uncertainty in delta range, in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaRangeUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_DELTARANGEUNC, Some(0.0)).unwrap()}
  }
  /// Delta range rate, in km/sec. Delta range rate calculation convention is (sensor2 - sensor1).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaRangeRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_DELTARANGERATE, Some(0.0)).unwrap()}
  }
  /// One sigma uncertainty in the delta range rate, in km/sec.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaRangeRateUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_DELTARANGERATEUNC, Some(0.0)).unwrap()}
  }
  /// Signal to noise ratio, in dB.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn snr(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_SNR, Some(0.0)).unwrap()}
  }
  /// Time difference of arrival of the center frequency signal, in seconds.  TDOA calculation convention is (sensor2 - sensor1).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tdoa(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_TDOA, Some(0.0)).unwrap()}
  }
  /// One sigma uncertainty in time difference of arrival of the center frequency signal, in seconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tdoaUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_TDOAUNC, Some(0.0)).unwrap()}
  }
  /// Frequency difference of arrival of the center frequency signal, in Hz.  FDOA calculation convention is (sensor2 - sensor1).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fdoa(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_FDOA, Some(0.0)).unwrap()}
  }
  /// One sigma uncertainty in frequency difference of arrival of the center frequency signal, in Hz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fdoaUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DiffOfArrival_Abridged::VT_FDOAUNC, Some(0.0)).unwrap()}
  }
  /// Collection mode (e.g. SURVEY, SPOT_SEARCH, NEIGHBORHOOD_WATCH, DIRECTED_SEARCH, MANUAL, etc).
  /// Example: /// Example: SURVEY
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn collectionMode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_COLLECTIONMODE, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_SOURCE, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> DiffOfArrival_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DiffOfArrival_Abridged_dataMode_Enum>(DiffOfArrival_Abridged::VT_DATAMODE, Some(DiffOfArrival_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_ORIGIN, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_CREATEDBY, None)}
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: Example descriptor
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn descriptor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_DESCRIPTOR, None)}
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn transactionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_TRANSACTIONID, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_ORIGNETWORK, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiffOfArrival_Abridged::VT_SOURCEDL, None)}
  }
}

impl flatbuffers::Verifiable for DiffOfArrival_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("obTime", Self::VT_OBTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor1", Self::VT_IDSENSOR1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor2", Self::VT_IDSENSOR2, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskId", Self::VT_TASKID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId1", Self::VT_ORIGSENSORID1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId2", Self::VT_ORIGSENSORID2, false)?
     .visit_field::<bool>("uct", Self::VT_UCT, false)?
     .visit_field::<f64>("sensor1Delay", Self::VT_SENSOR1DELAY, false)?
     .visit_field::<f64>("sensor2Delay", Self::VT_SENSOR2DELAY, false)?
     .visit_field::<f64>("senlat", Self::VT_SENLAT, false)?
     .visit_field::<f64>("senlon", Self::VT_SENLON, false)?
     .visit_field::<f64>("senalt", Self::VT_SENALT, false)?
     .visit_field::<f64>("sen2lat", Self::VT_SEN2LAT, false)?
     .visit_field::<f64>("sen2lon", Self::VT_SEN2LON, false)?
     .visit_field::<f64>("sen2alt", Self::VT_SEN2ALT, false)?
     .visit_field::<f64>("frequency", Self::VT_FREQUENCY, false)?
     .visit_field::<f64>("bandwidth", Self::VT_BANDWIDTH, false)?
     .visit_field::<f64>("deltaRange", Self::VT_DELTARANGE, false)?
     .visit_field::<f64>("deltaRangeUnc", Self::VT_DELTARANGEUNC, false)?
     .visit_field::<f64>("deltaRangeRate", Self::VT_DELTARANGERATE, false)?
     .visit_field::<f64>("deltaRangeRateUnc", Self::VT_DELTARANGERATEUNC, false)?
     .visit_field::<f64>("snr", Self::VT_SNR, false)?
     .visit_field::<f64>("tdoa", Self::VT_TDOA, false)?
     .visit_field::<f64>("tdoaUnc", Self::VT_TDOAUNC, false)?
     .visit_field::<f64>("fdoa", Self::VT_FDOA, false)?
     .visit_field::<f64>("fdoaUnc", Self::VT_FDOAUNC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("collectionMode", Self::VT_COLLECTIONMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<DiffOfArrival_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("descriptor", Self::VT_DESCRIPTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transactionId", Self::VT_TRANSACTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .finish();
    Ok(())
  }
}
pub struct DiffOfArrival_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo: i32,
    pub taskId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uct: bool,
    pub sensor1Delay: f64,
    pub sensor2Delay: f64,
    pub senlat: f64,
    pub senlon: f64,
    pub senalt: f64,
    pub sen2lat: f64,
    pub sen2lon: f64,
    pub sen2alt: f64,
    pub frequency: f64,
    pub bandwidth: f64,
    pub deltaRange: f64,
    pub deltaRangeUnc: f64,
    pub deltaRangeRate: f64,
    pub deltaRangeRateUnc: f64,
    pub snr: f64,
    pub tdoa: f64,
    pub tdoaUnc: f64,
    pub fdoa: f64,
    pub fdoaUnc: f64,
    pub collectionMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: DiffOfArrival_Abridged_dataMode_Enum,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub descriptor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transactionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DiffOfArrival_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    DiffOfArrival_AbridgedArgs {
      id: None,
      classificationMarking: None,
      obTime: None,
      idOnOrbit: None,
      idSensor1: None,
      idSensor2: None,
      satNo: 0,
      taskId: None,
      origObjectId: None,
      origSensorId1: None,
      origSensorId2: None,
      uct: false,
      sensor1Delay: 0.0,
      sensor2Delay: 0.0,
      senlat: 0.0,
      senlon: 0.0,
      senalt: 0.0,
      sen2lat: 0.0,
      sen2lon: 0.0,
      sen2alt: 0.0,
      frequency: 0.0,
      bandwidth: 0.0,
      deltaRange: 0.0,
      deltaRangeUnc: 0.0,
      deltaRangeRate: 0.0,
      deltaRangeRateUnc: 0.0,
      snr: 0.0,
      tdoa: 0.0,
      tdoaUnc: 0.0,
      fdoa: 0.0,
      fdoaUnc: 0.0,
      collectionMode: None,
      source: None,
      dataMode: DiffOfArrival_Abridged_dataMode_Enum::REAL,
      origin: None,
      createdAt: None,
      createdBy: None,
      descriptor: None,
      transactionId: None,
      origNetwork: None,
      sourceDL: None,
    }
  }
}

pub struct DiffOfArrival_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DiffOfArrival_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_obTime(&mut self, obTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_OBTIME, obTime);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_idSensor1(&mut self, idSensor1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_IDSENSOR1, idSensor1);
  }
  #[inline]
  pub fn add_idSensor2(&mut self, idSensor2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_IDSENSOR2, idSensor2);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(DiffOfArrival_Abridged::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_taskId(&mut self, taskId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_TASKID, taskId);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_origSensorId1(&mut self, origSensorId1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_ORIGSENSORID1, origSensorId1);
  }
  #[inline]
  pub fn add_origSensorId2(&mut self, origSensorId2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_ORIGSENSORID2, origSensorId2);
  }
  #[inline]
  pub fn add_uct(&mut self, uct: bool) {
    self.fbb_.push_slot::<bool>(DiffOfArrival_Abridged::VT_UCT, uct, false);
  }
  #[inline]
  pub fn add_sensor1Delay(&mut self, sensor1Delay: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_SENSOR1DELAY, sensor1Delay, 0.0);
  }
  #[inline]
  pub fn add_sensor2Delay(&mut self, sensor2Delay: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_SENSOR2DELAY, sensor2Delay, 0.0);
  }
  #[inline]
  pub fn add_senlat(&mut self, senlat: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_SENLAT, senlat, 0.0);
  }
  #[inline]
  pub fn add_senlon(&mut self, senlon: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_SENLON, senlon, 0.0);
  }
  #[inline]
  pub fn add_senalt(&mut self, senalt: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_SENALT, senalt, 0.0);
  }
  #[inline]
  pub fn add_sen2lat(&mut self, sen2lat: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_SEN2LAT, sen2lat, 0.0);
  }
  #[inline]
  pub fn add_sen2lon(&mut self, sen2lon: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_SEN2LON, sen2lon, 0.0);
  }
  #[inline]
  pub fn add_sen2alt(&mut self, sen2alt: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_SEN2ALT, sen2alt, 0.0);
  }
  #[inline]
  pub fn add_frequency(&mut self, frequency: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_FREQUENCY, frequency, 0.0);
  }
  #[inline]
  pub fn add_bandwidth(&mut self, bandwidth: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_BANDWIDTH, bandwidth, 0.0);
  }
  #[inline]
  pub fn add_deltaRange(&mut self, deltaRange: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_DELTARANGE, deltaRange, 0.0);
  }
  #[inline]
  pub fn add_deltaRangeUnc(&mut self, deltaRangeUnc: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_DELTARANGEUNC, deltaRangeUnc, 0.0);
  }
  #[inline]
  pub fn add_deltaRangeRate(&mut self, deltaRangeRate: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_DELTARANGERATE, deltaRangeRate, 0.0);
  }
  #[inline]
  pub fn add_deltaRangeRateUnc(&mut self, deltaRangeRateUnc: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_DELTARANGERATEUNC, deltaRangeRateUnc, 0.0);
  }
  #[inline]
  pub fn add_snr(&mut self, snr: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_SNR, snr, 0.0);
  }
  #[inline]
  pub fn add_tdoa(&mut self, tdoa: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_TDOA, tdoa, 0.0);
  }
  #[inline]
  pub fn add_tdoaUnc(&mut self, tdoaUnc: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_TDOAUNC, tdoaUnc, 0.0);
  }
  #[inline]
  pub fn add_fdoa(&mut self, fdoa: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_FDOA, fdoa, 0.0);
  }
  #[inline]
  pub fn add_fdoaUnc(&mut self, fdoaUnc: f64) {
    self.fbb_.push_slot::<f64>(DiffOfArrival_Abridged::VT_FDOAUNC, fdoaUnc, 0.0);
  }
  #[inline]
  pub fn add_collectionMode(&mut self, collectionMode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_COLLECTIONMODE, collectionMode);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: DiffOfArrival_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<DiffOfArrival_Abridged_dataMode_Enum>(DiffOfArrival_Abridged::VT_DATAMODE, dataMode, DiffOfArrival_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_descriptor(&mut self, descriptor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_DESCRIPTOR, descriptor);
  }
  #[inline]
  pub fn add_transactionId(&mut self, transactionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_TRANSACTIONID, transactionId);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiffOfArrival_Abridged::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DiffOfArrival_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DiffOfArrival_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DiffOfArrival_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DiffOfArrival_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DiffOfArrival_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("obTime", &self.obTime());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("idSensor1", &self.idSensor1());
      ds.field("idSensor2", &self.idSensor2());
      ds.field("satNo", &self.satNo());
      ds.field("taskId", &self.taskId());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("origSensorId1", &self.origSensorId1());
      ds.field("origSensorId2", &self.origSensorId2());
      ds.field("uct", &self.uct());
      ds.field("sensor1Delay", &self.sensor1Delay());
      ds.field("sensor2Delay", &self.sensor2Delay());
      ds.field("senlat", &self.senlat());
      ds.field("senlon", &self.senlon());
      ds.field("senalt", &self.senalt());
      ds.field("sen2lat", &self.sen2lat());
      ds.field("sen2lon", &self.sen2lon());
      ds.field("sen2alt", &self.sen2alt());
      ds.field("frequency", &self.frequency());
      ds.field("bandwidth", &self.bandwidth());
      ds.field("deltaRange", &self.deltaRange());
      ds.field("deltaRangeUnc", &self.deltaRangeUnc());
      ds.field("deltaRangeRate", &self.deltaRangeRate());
      ds.field("deltaRangeRateUnc", &self.deltaRangeRateUnc());
      ds.field("snr", &self.snr());
      ds.field("tdoa", &self.tdoa());
      ds.field("tdoaUnc", &self.tdoaUnc());
      ds.field("fdoa", &self.fdoa());
      ds.field("fdoaUnc", &self.fdoaUnc());
      ds.field("collectionMode", &self.collectionMode());
      ds.field("source", &self.source());
      ds.field("dataMode", &self.dataMode());
      ds.field("origin", &self.origin());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("descriptor", &self.descriptor());
      ds.field("transactionId", &self.transactionId());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("sourceDL", &self.sourceDL());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DiffOfArrival_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub obTime: Option<String>,
  pub idOnOrbit: Option<String>,
  pub idSensor1: Option<String>,
  pub idSensor2: Option<String>,
  pub satNo: i32,
  pub taskId: Option<String>,
  pub origObjectId: Option<String>,
  pub origSensorId1: Option<String>,
  pub origSensorId2: Option<String>,
  pub uct: bool,
  pub sensor1Delay: f64,
  pub sensor2Delay: f64,
  pub senlat: f64,
  pub senlon: f64,
  pub senalt: f64,
  pub sen2lat: f64,
  pub sen2lon: f64,
  pub sen2alt: f64,
  pub frequency: f64,
  pub bandwidth: f64,
  pub deltaRange: f64,
  pub deltaRangeUnc: f64,
  pub deltaRangeRate: f64,
  pub deltaRangeRateUnc: f64,
  pub snr: f64,
  pub tdoa: f64,
  pub tdoaUnc: f64,
  pub fdoa: f64,
  pub fdoaUnc: f64,
  pub collectionMode: Option<String>,
  pub source: Option<String>,
  pub dataMode: DiffOfArrival_Abridged_dataMode_Enum,
  pub origin: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub descriptor: Option<String>,
  pub transactionId: Option<String>,
  pub origNetwork: Option<String>,
  pub sourceDL: Option<String>,
}
impl Default for DiffOfArrival_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      obTime: None,
      idOnOrbit: None,
      idSensor1: None,
      idSensor2: None,
      satNo: 0,
      taskId: None,
      origObjectId: None,
      origSensorId1: None,
      origSensorId2: None,
      uct: false,
      sensor1Delay: 0.0,
      sensor2Delay: 0.0,
      senlat: 0.0,
      senlon: 0.0,
      senalt: 0.0,
      sen2lat: 0.0,
      sen2lon: 0.0,
      sen2alt: 0.0,
      frequency: 0.0,
      bandwidth: 0.0,
      deltaRange: 0.0,
      deltaRangeUnc: 0.0,
      deltaRangeRate: 0.0,
      deltaRangeRateUnc: 0.0,
      snr: 0.0,
      tdoa: 0.0,
      tdoaUnc: 0.0,
      fdoa: 0.0,
      fdoaUnc: 0.0,
      collectionMode: None,
      source: None,
      dataMode: DiffOfArrival_Abridged_dataMode_Enum::REAL,
      origin: None,
      createdAt: None,
      createdBy: None,
      descriptor: None,
      transactionId: None,
      origNetwork: None,
      sourceDL: None,
    }
  }
}
impl DiffOfArrival_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<DiffOfArrival_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let obTime = self.obTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor1 = self.idSensor1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor2 = self.idSensor2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo = self.satNo;
    let taskId = self.taskId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId1 = self.origSensorId1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId2 = self.origSensorId2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let uct = self.uct;
    let sensor1Delay = self.sensor1Delay;
    let sensor2Delay = self.sensor2Delay;
    let senlat = self.senlat;
    let senlon = self.senlon;
    let senalt = self.senalt;
    let sen2lat = self.sen2lat;
    let sen2lon = self.sen2lon;
    let sen2alt = self.sen2alt;
    let frequency = self.frequency;
    let bandwidth = self.bandwidth;
    let deltaRange = self.deltaRange;
    let deltaRangeUnc = self.deltaRangeUnc;
    let deltaRangeRate = self.deltaRangeRate;
    let deltaRangeRateUnc = self.deltaRangeRateUnc;
    let snr = self.snr;
    let tdoa = self.tdoa;
    let tdoaUnc = self.tdoaUnc;
    let fdoa = self.fdoa;
    let fdoaUnc = self.fdoaUnc;
    let collectionMode = self.collectionMode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let descriptor = self.descriptor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let transactionId = self.transactionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    DiffOfArrival_Abridged::create(_fbb, &DiffOfArrival_AbridgedArgs{
      id,
      classificationMarking,
      obTime,
      idOnOrbit,
      idSensor1,
      idSensor2,
      satNo,
      taskId,
      origObjectId,
      origSensorId1,
      origSensorId2,
      uct,
      sensor1Delay,
      sensor2Delay,
      senlat,
      senlon,
      senalt,
      sen2lat,
      sen2lon,
      sen2alt,
      frequency,
      bandwidth,
      deltaRange,
      deltaRangeUnc,
      deltaRangeRate,
      deltaRangeRateUnc,
      snr,
      tdoa,
      tdoaUnc,
      fdoa,
      fdoaUnc,
      collectionMode,
      source,
      dataMode,
      origin,
      createdAt,
      createdBy,
      descriptor,
      transactionId,
      origNetwork,
      sourceDL,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `DiffOfArrival_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_diff_of_arrival_abridged_unchecked`.
pub fn root_as_diff_of_arrival_abridged(buf: &[u8]) -> Result<DiffOfArrival_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<DiffOfArrival_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `DiffOfArrival_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_diff_of_arrival_abridged_unchecked`.
pub fn size_prefixed_root_as_diff_of_arrival_abridged(buf: &[u8]) -> Result<DiffOfArrival_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<DiffOfArrival_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `DiffOfArrival_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_diff_of_arrival_abridged_unchecked`.
pub fn root_as_diff_of_arrival_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<DiffOfArrival_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<DiffOfArrival_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `DiffOfArrival_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_diff_of_arrival_abridged_unchecked`.
pub fn size_prefixed_root_as_diff_of_arrival_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<DiffOfArrival_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<DiffOfArrival_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a DiffOfArrival_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `DiffOfArrival_Abridged`.
pub unsafe fn root_as_diff_of_arrival_abridged_unchecked(buf: &[u8]) -> DiffOfArrival_Abridged {
  flatbuffers::root_unchecked::<DiffOfArrival_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed DiffOfArrival_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `DiffOfArrival_Abridged`.
pub unsafe fn size_prefixed_root_as_diff_of_arrival_abridged_unchecked(buf: &[u8]) -> DiffOfArrival_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<DiffOfArrival_Abridged>(buf)
}
pub const DIFF_OF_ARRIVAL_ABRIDGED_IDENTIFIER: &str = "DIFF";

#[inline]
pub fn diff_of_arrival_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, DIFF_OF_ARRIVAL_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn diff_of_arrival_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, DIFF_OF_ARRIVAL_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_diff_of_arrival_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<DiffOfArrival_Abridged<'a>>) {
  fbb.finish(root, Some(DIFF_OF_ARRIVAL_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_diff_of_arrival_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<DiffOfArrival_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(DIFF_OF_ARRIVAL_ABRIDGED_IDENTIFIER));
}
