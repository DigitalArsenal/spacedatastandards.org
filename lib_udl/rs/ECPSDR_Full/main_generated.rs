// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ECPSDR_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ECPSDR_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ECPSDR_FULL_DATA_MODE_ENUM: [ECPSDR_Full_dataMode_Enum; 4] = [
  ECPSDR_Full_dataMode_Enum::REAL,
  ECPSDR_Full_dataMode_Enum::TEST,
  ECPSDR_Full_dataMode_Enum::SIMULATED,
  ECPSDR_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ECPSDR_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl ECPSDR_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ECPSDR_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ECPSDR_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ECPSDR_Full_dataMode_Enum {
    type Output = ECPSDR_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ECPSDR_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ECPSDR_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ECPSDR_Full_dataMode_Enum {}
pub enum ECPSDR_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Supports Sensor Data Records (SDR) from space-borne Energetic Charged Particle (ECP) Sensors.  SDR contains sensor status telemetry and raw dosimeter measurements of the space environment.
pub struct ECPSDR_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ECPSDR_Full<'a> {
  type Inner = ECPSDR_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ECPSDR_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 8;
  pub const VT_SATNO: flatbuffers::VOffsetT = 10;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 12;
  pub const VT_IDSENSOR: flatbuffers::VOffsetT = 14;
  pub const VT_ORIGSENSORID: flatbuffers::VOffsetT = 16;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 18;
  pub const VT_MSGTIME: flatbuffers::VOffsetT = 20;
  pub const VT_OBTIME: flatbuffers::VOffsetT = 22;
  pub const VT_RETRANSMIT: flatbuffers::VOffsetT = 24;
  pub const VT_SENMODE: flatbuffers::VOffsetT = 26;
  pub const VT_DOSBIAS: flatbuffers::VOffsetT = 28;
  pub const VT_ASL5VCURRMON: flatbuffers::VOffsetT = 30;
  pub const VT_DSL5VCURRMON: flatbuffers::VOffsetT = 32;
  pub const VT_PSTEMPMON: flatbuffers::VOffsetT = 34;
  pub const VT_CDSPLATEVMON: flatbuffers::VOffsetT = 36;
  pub const VT_CDSREFVMON: flatbuffers::VOffsetT = 38;
  pub const VT_MPTEMP: flatbuffers::VOffsetT = 40;
  pub const VT_VREF: flatbuffers::VOffsetT = 42;
  pub const VT_PD1SIGLEV: flatbuffers::VOffsetT = 44;
  pub const VT_PD2SIGLEV: flatbuffers::VOffsetT = 46;
  pub const VT_ESDTRIGCOUNTL: flatbuffers::VOffsetT = 48;
  pub const VT_ESDTRIGCOUNTH: flatbuffers::VOffsetT = 50;
  pub const VT_LOWLETL: flatbuffers::VOffsetT = 52;
  pub const VT_LOWLETM: flatbuffers::VOffsetT = 54;
  pub const VT_MEDLET1L: flatbuffers::VOffsetT = 56;
  pub const VT_MEDLET1M: flatbuffers::VOffsetT = 58;
  pub const VT_MEDLET2L: flatbuffers::VOffsetT = 60;
  pub const VT_MEDLET2M: flatbuffers::VOffsetT = 62;
  pub const VT_MEDLET3L: flatbuffers::VOffsetT = 64;
  pub const VT_MEDLET3M: flatbuffers::VOffsetT = 66;
  pub const VT_MEDLET4L: flatbuffers::VOffsetT = 68;
  pub const VT_MEDLET4M: flatbuffers::VOffsetT = 70;
  pub const VT_HILETL: flatbuffers::VOffsetT = 72;
  pub const VT_HILETM: flatbuffers::VOffsetT = 74;
  pub const VT_SURFDOSL: flatbuffers::VOffsetT = 76;
  pub const VT_SURFDOSM: flatbuffers::VOffsetT = 78;
  pub const VT_SURFDOSH: flatbuffers::VOffsetT = 80;
  pub const VT_SURFDOSCHARGEL: flatbuffers::VOffsetT = 82;
  pub const VT_SURFDOSCHARGEH: flatbuffers::VOffsetT = 84;
  pub const VT_SURFDOSSTAT: flatbuffers::VOffsetT = 86;
  pub const VT_CDSTHROTTLE: flatbuffers::VOffsetT = 88;
  pub const VT_CDSTHRESHOLD: flatbuffers::VOffsetT = 90;
  pub const VT_CHECKSUM: flatbuffers::VOffsetT = 92;
  pub const VT_TRANSIENTDATA: flatbuffers::VOffsetT = 94;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 96;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 98;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 100;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 102;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 104;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 106;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 108;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 110;
  pub const VT_ONORBIT: flatbuffers::VOffsetT = 112;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ECPSDR_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ECPSDR_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<ECPSDR_Full<'bldr>> {
    let mut builder = ECPSDR_FullBuilder::new(_fbb);
    if let Some(x) = args.onOrbit { builder.add_onOrbit(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.transientData { builder.add_transientData(x); }
    builder.add_checksum(args.checksum);
    builder.add_cdsThreshold(args.cdsThreshold);
    builder.add_cdsThrottle(args.cdsThrottle);
    builder.add_surfDosStat(args.surfDosStat);
    builder.add_surfDosChargeH(args.surfDosChargeH);
    builder.add_surfDosChargeL(args.surfDosChargeL);
    builder.add_surfDosH(args.surfDosH);
    builder.add_surfDosM(args.surfDosM);
    builder.add_surfDosL(args.surfDosL);
    builder.add_hiLetM(args.hiLetM);
    builder.add_hiLetL(args.hiLetL);
    builder.add_medLet4M(args.medLet4M);
    builder.add_medLet4L(args.medLet4L);
    builder.add_medLet3M(args.medLet3M);
    builder.add_medLet3L(args.medLet3L);
    builder.add_medLet2M(args.medLet2M);
    builder.add_medLet2L(args.medLet2L);
    builder.add_medLet1M(args.medLet1M);
    builder.add_medLet1L(args.medLet1L);
    builder.add_lowLetM(args.lowLetM);
    builder.add_lowLetL(args.lowLetL);
    builder.add_esdTrigCountH(args.esdTrigCountH);
    builder.add_esdTrigCountL(args.esdTrigCountL);
    builder.add_pd2SigLev(args.pd2SigLev);
    builder.add_pd1SigLev(args.pd1SigLev);
    builder.add_vRef(args.vRef);
    builder.add_mpTemp(args.mpTemp);
    builder.add_cdsRefVMon(args.cdsRefVMon);
    builder.add_cdsPlateVMon(args.cdsPlateVMon);
    builder.add_psTempMon(args.psTempMon);
    builder.add_dsl5VCurrMon(args.dsl5VCurrMon);
    builder.add_asl5VCurrMon(args.asl5VCurrMon);
    builder.add_dosBias(args.dosBias);
    if let Some(x) = args.senMode { builder.add_senMode(x); }
    if let Some(x) = args.obTime { builder.add_obTime(x); }
    if let Some(x) = args.msgTime { builder.add_msgTime(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.origSensorId { builder.add_origSensorId(x); }
    if let Some(x) = args.idSensor { builder.add_idSensor(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_retransmit(args.retransmit);
    builder.finish()
  }

  pub fn unpack(&self) -> ECPSDR_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let satNo = self.satNo();
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let idSensor = self.idSensor().map(|x| {
      x.to_string()
    });
    let origSensorId = self.origSensorId().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let msgTime = self.msgTime().map(|x| {
      x.to_string()
    });
    let obTime = self.obTime().map(|x| {
      x.to_string()
    });
    let retransmit = self.retransmit();
    let senMode = self.senMode().map(|x| {
      x.to_string()
    });
    let dosBias = self.dosBias();
    let asl5VCurrMon = self.asl5VCurrMon();
    let dsl5VCurrMon = self.dsl5VCurrMon();
    let psTempMon = self.psTempMon();
    let cdsPlateVMon = self.cdsPlateVMon();
    let cdsRefVMon = self.cdsRefVMon();
    let mpTemp = self.mpTemp();
    let vRef = self.vRef();
    let pd1SigLev = self.pd1SigLev();
    let pd2SigLev = self.pd2SigLev();
    let esdTrigCountL = self.esdTrigCountL();
    let esdTrigCountH = self.esdTrigCountH();
    let lowLetL = self.lowLetL();
    let lowLetM = self.lowLetM();
    let medLet1L = self.medLet1L();
    let medLet1M = self.medLet1M();
    let medLet2L = self.medLet2L();
    let medLet2M = self.medLet2M();
    let medLet3L = self.medLet3L();
    let medLet3M = self.medLet3M();
    let medLet4L = self.medLet4L();
    let medLet4M = self.medLet4M();
    let hiLetL = self.hiLetL();
    let hiLetM = self.hiLetM();
    let surfDosL = self.surfDosL();
    let surfDosM = self.surfDosM();
    let surfDosH = self.surfDosH();
    let surfDosChargeL = self.surfDosChargeL();
    let surfDosChargeH = self.surfDosChargeH();
    let surfDosStat = self.surfDosStat();
    let cdsThrottle = self.cdsThrottle();
    let cdsThreshold = self.cdsThreshold();
    let checksum = self.checksum();
    let transientData = self.transientData().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let onOrbit = self.onOrbit().map(|x| {
      x.to_string()
    });
    ECPSDR_FullT {
      id,
      classificationMarking,
      idOnOrbit,
      satNo,
      origObjectId,
      idSensor,
      origSensorId,
      type_,
      msgTime,
      obTime,
      retransmit,
      senMode,
      dosBias,
      asl5VCurrMon,
      dsl5VCurrMon,
      psTempMon,
      cdsPlateVMon,
      cdsRefVMon,
      mpTemp,
      vRef,
      pd1SigLev,
      pd2SigLev,
      esdTrigCountL,
      esdTrigCountH,
      lowLetL,
      lowLetM,
      medLet1L,
      medLet1M,
      medLet2L,
      medLet2M,
      medLet3L,
      medLet3M,
      medLet4L,
      medLet4M,
      hiLetL,
      hiLetM,
      surfDosL,
      surfDosM,
      surfDosH,
      surfDosChargeL,
      surfDosChargeH,
      surfDosStat,
      cdsThrottle,
      cdsThreshold,
      checksum,
      transientData,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      origNetwork,
      dataMode,
      onOrbit,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: ECPSDR-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the on-orbit satellite hosting the sensor.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_IDONORBIT, None)}
  }
  /// Satellite/catalog number of the on-orbit satellite hosting the sensor.
  /// Example: /// Example: 101
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_SATNO, Some(0)).unwrap()}
  }
  /// Optional identifier provided by the record source to indicate the satellite hosting the sensor.  This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_ORIGOBJECTID, None)}
  }
  /// Unique identifier of the reporting sensor.
  /// Example: /// Example: SENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_IDSENSOR, None)}
  }
  /// Optional identifier provided by the record source to indicate the sensor identifier which produced this data.  This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origSensorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_ORIGSENSORID, None)}
  }
  /// The type of data associated with this record (STANDARD, TRANSIENT).
  /// Example: /// Example: STANDARD
  /// Constraints: Minimum length = 1, Maximum length = 12
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_TYPE_, None)}
  }
  /// Time stamp of time packet receipt on ground, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn msgTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_MSGTIME, None)}
  }
  /// Time of the observation, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_OBTIME, None)}
  }
  /// Flag indicating whether this record is an original or re-transmitted dataset (TRUE indicates a retransmit from the host).
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn retransmit(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ECPSDR_Full::VT_RETRANSMIT, Some(false)).unwrap()}
  }
  /// The sensor mode associated with this measurements (NORMAL, TEST).
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 0, Maximum length = 12
  #[inline]
  pub fn senMode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_SENMODE, None)}
  }
  /// Unitless dosimeter detector bias for MedLET and HiLET.  MedLET (Linear Energy Transfer) and HiLET subsensors detect particles above LET thresholds, 300keV and 1MeV, respectively.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dosBias(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_DOSBIAS, Some(0)).unwrap()}
  }
  /// Internal 5V current monitor for analog supply line.  This is sensor status telemetry.  See vRef for conversion factor to Volts.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn asl5VCurrMon(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_ASL5VCURRMON, Some(0)).unwrap()}
  }
  /// Internal 5V current monitor for digital supply line.  This is sensor status telemetry.  See vRef for conversion factor to Volts.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dsl5VCurrMon(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_DSL5VCURRMON, Some(0)).unwrap()}
  }
  /// Power supply temperature monitor.  This is sensor status telemetry.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn psTempMon(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_PSTEMPMON, Some(0)).unwrap()}
  }
  /// CDS Charge Plate voltage monitor.  See vRef for conversion factor to Volts.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cdsPlateVMon(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_CDSPLATEVMON, Some(0)).unwrap()}
  }
  /// CDS reference voltage monitor.  See vRef for conversion factor to Volts.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cdsRefVMon(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_CDSREFVMON, Some(0)).unwrap()}
  }
  /// Unitless sensor mounting plate temperature.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mpTemp(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_MPTEMP, Some(0)).unwrap()}
  }
  /// Reference voltage (volts/bit).  Conversion factor used to convert analog V monitor data from bytes to volts.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vRef(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_VREF, Some(0)).unwrap()}
  }
  /// Photodiode 1 signal level.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pd1SigLev(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_PD1SIGLEV, Some(0)).unwrap()}
  }
  /// Photodiode 2 signal level.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pd2SigLev(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_PD2SIGLEV, Some(0)).unwrap()}
  }
  /// Number of ESD triggers, low byte of 2-byte counter.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn esdTrigCountL(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_ESDTRIGCOUNTL, Some(0)).unwrap()}
  }
  /// Number of ESD triggers, high byte of 2-byte counter.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn esdTrigCountH(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_ESDTRIGCOUNTH, Some(0)).unwrap()}
  }
  /// LowLET dosimeter low range output.  Low byte of (LowLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lowLetL(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_LOWLETL, Some(0)).unwrap()}
  }
  /// LowLET dosimeter medium range output.  Medium byte of (LowLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lowLetM(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_LOWLETM, Some(0)).unwrap()}
  }
  /// MedLET1 dosimeter low range output.   Low byte of the 1st (MedLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn medLet1L(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_MEDLET1L, Some(0)).unwrap()}
  }
  /// MedLET1 dosimeter medium range output.  Medium byte of the 1st (MedLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn medLet1M(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_MEDLET1M, Some(0)).unwrap()}
  }
  /// MedLET2 dosimeter low range output.  Low byte of the 2nd (MedLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn medLet2L(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_MEDLET2L, Some(0)).unwrap()}
  }
  /// MedLET2 dosimeter medium range output.  Medium byte of the 2nd (MedLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn medLet2M(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_MEDLET2M, Some(0)).unwrap()}
  }
  /// MedLET3 dosimeter low range output.  Low byte of the 3rd (MedLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn medLet3L(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_MEDLET3L, Some(0)).unwrap()}
  }
  /// MedLET3 dosimeter medium range output.  Medium byte of the 3rd (MedLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn medLet3M(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_MEDLET3M, Some(0)).unwrap()}
  }
  /// MedLET4 dosimeter low range output.  Low byte of the 4th (MedLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn medLet4L(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_MEDLET4L, Some(0)).unwrap()}
  }
  /// MedLET4 dosimeter medium range output.  Medium byte of the 4th (MedLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn medLet4M(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_MEDLET4M, Some(0)).unwrap()}
  }
  /// HiLET dosimeter low range output.  Low byte of scaler (HiLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hiLetL(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_HILETL, Some(0)).unwrap()}
  }
  /// Unitless HiLET dosimeter medium range output.  Medium byte of (HiLET) dosimeter output.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hiLetM(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_HILETM, Some(0)).unwrap()}
  }
  /// Surface dosimeter low range output (converts to pico-coulombs/bit).   Low byte of 3 bytes.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn surfDosL(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_SURFDOSL, Some(0)).unwrap()}
  }
  /// Surface dosimeter medium range output (converts to pico-coulombs/bit).  Middle byte of 3 bytes.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn surfDosM(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_SURFDOSM, Some(0)).unwrap()}
  }
  /// Surface dosimeter high range output (converts to pico-coulombs/bit).  High byte of 3 bytes.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn surfDosH(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_SURFDOSH, Some(0)).unwrap()}
  }
  /// Surface dosimeter charge rate low output (converts to pico-amps/bit).  Low byte of 2 bytes.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn surfDosChargeL(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_SURFDOSCHARGEL, Some(0)).unwrap()}
  }
  /// Surface dosimeter charge rate high output (converts to pico-amps/bit).   High byte of 2 bytes.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn surfDosChargeH(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_SURFDOSCHARGEH, Some(0)).unwrap()}
  }
  /// Surface dosimeter status byte.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn surfDosStat(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_SURFDOSSTAT, Some(0)).unwrap()}
  }
  /// CDS throttle number of seconds between CDS transient capture readouts.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cdsThrottle(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_CDSTHROTTLE, Some(0)).unwrap()}
  }
  /// CDS Threshold setting for ESD detection threshold.  The CDS Threshold is the adjustable sensitivity of recording/digitizing an ESD as a transient packet.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cdsThreshold(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_CDSTHRESHOLD, Some(0)).unwrap()}
  }
  /// Two byte CRC-16-CCITT checksum (ordered as first byte, second byte).
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn checksum(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ECPSDR_Full::VT_CHECKSUM, Some(0)).unwrap()}
  }
  /// Array of 144 digitized samples of ESD waveform for transient packets.
  /// Example: /// Example: [1, 2, 3]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn transientData(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ECPSDR_Full::VT_TRANSIENTDATA, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_CREATEDBY, None)}
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_UPDATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> ECPSDR_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ECPSDR_Full_dataMode_Enum>(ECPSDR_Full::VT_DATAMODE, Some(ECPSDR_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn onOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ECPSDR_Full::VT_ONORBIT, None)}
  }
}

impl flatbuffers::Verifiable for ECPSDR_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor", Self::VT_IDSENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId", Self::VT_ORIGSENSORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msgTime", Self::VT_MSGTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("obTime", Self::VT_OBTIME, false)?
     .visit_field::<bool>("retransmit", Self::VT_RETRANSMIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("senMode", Self::VT_SENMODE, false)?
     .visit_field::<i32>("dosBias", Self::VT_DOSBIAS, false)?
     .visit_field::<i32>("asl5VCurrMon", Self::VT_ASL5VCURRMON, false)?
     .visit_field::<i32>("dsl5VCurrMon", Self::VT_DSL5VCURRMON, false)?
     .visit_field::<i32>("psTempMon", Self::VT_PSTEMPMON, false)?
     .visit_field::<i32>("cdsPlateVMon", Self::VT_CDSPLATEVMON, false)?
     .visit_field::<i32>("cdsRefVMon", Self::VT_CDSREFVMON, false)?
     .visit_field::<i32>("mpTemp", Self::VT_MPTEMP, false)?
     .visit_field::<i32>("vRef", Self::VT_VREF, false)?
     .visit_field::<i32>("pd1SigLev", Self::VT_PD1SIGLEV, false)?
     .visit_field::<i32>("pd2SigLev", Self::VT_PD2SIGLEV, false)?
     .visit_field::<i32>("esdTrigCountL", Self::VT_ESDTRIGCOUNTL, false)?
     .visit_field::<i32>("esdTrigCountH", Self::VT_ESDTRIGCOUNTH, false)?
     .visit_field::<i32>("lowLetL", Self::VT_LOWLETL, false)?
     .visit_field::<i32>("lowLetM", Self::VT_LOWLETM, false)?
     .visit_field::<i32>("medLet1L", Self::VT_MEDLET1L, false)?
     .visit_field::<i32>("medLet1M", Self::VT_MEDLET1M, false)?
     .visit_field::<i32>("medLet2L", Self::VT_MEDLET2L, false)?
     .visit_field::<i32>("medLet2M", Self::VT_MEDLET2M, false)?
     .visit_field::<i32>("medLet3L", Self::VT_MEDLET3L, false)?
     .visit_field::<i32>("medLet3M", Self::VT_MEDLET3M, false)?
     .visit_field::<i32>("medLet4L", Self::VT_MEDLET4L, false)?
     .visit_field::<i32>("medLet4M", Self::VT_MEDLET4M, false)?
     .visit_field::<i32>("hiLetL", Self::VT_HILETL, false)?
     .visit_field::<i32>("hiLetM", Self::VT_HILETM, false)?
     .visit_field::<i32>("surfDosL", Self::VT_SURFDOSL, false)?
     .visit_field::<i32>("surfDosM", Self::VT_SURFDOSM, false)?
     .visit_field::<i32>("surfDosH", Self::VT_SURFDOSH, false)?
     .visit_field::<i32>("surfDosChargeL", Self::VT_SURFDOSCHARGEL, false)?
     .visit_field::<i32>("surfDosChargeH", Self::VT_SURFDOSCHARGEH, false)?
     .visit_field::<i32>("surfDosStat", Self::VT_SURFDOSSTAT, false)?
     .visit_field::<i32>("cdsThrottle", Self::VT_CDSTHROTTLE, false)?
     .visit_field::<i32>("cdsThreshold", Self::VT_CDSTHRESHOLD, false)?
     .visit_field::<i32>("checksum", Self::VT_CHECKSUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("transientData", Self::VT_TRANSIENTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<ECPSDR_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("onOrbit", Self::VT_ONORBIT, false)?
     .finish();
    Ok(())
  }
}
pub struct ECPSDR_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo: i32,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub retransmit: bool,
    pub senMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dosBias: i32,
    pub asl5VCurrMon: i32,
    pub dsl5VCurrMon: i32,
    pub psTempMon: i32,
    pub cdsPlateVMon: i32,
    pub cdsRefVMon: i32,
    pub mpTemp: i32,
    pub vRef: i32,
    pub pd1SigLev: i32,
    pub pd2SigLev: i32,
    pub esdTrigCountL: i32,
    pub esdTrigCountH: i32,
    pub lowLetL: i32,
    pub lowLetM: i32,
    pub medLet1L: i32,
    pub medLet1M: i32,
    pub medLet2L: i32,
    pub medLet2M: i32,
    pub medLet3L: i32,
    pub medLet3M: i32,
    pub medLet4L: i32,
    pub medLet4M: i32,
    pub hiLetL: i32,
    pub hiLetM: i32,
    pub surfDosL: i32,
    pub surfDosM: i32,
    pub surfDosH: i32,
    pub surfDosChargeL: i32,
    pub surfDosChargeH: i32,
    pub surfDosStat: i32,
    pub cdsThrottle: i32,
    pub cdsThreshold: i32,
    pub checksum: i32,
    pub transientData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: ECPSDR_Full_dataMode_Enum,
    pub onOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ECPSDR_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    ECPSDR_FullArgs {
      id: None,
      classificationMarking: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      idSensor: None,
      origSensorId: None,
      type_: None,
      msgTime: None,
      obTime: None,
      retransmit: false,
      senMode: None,
      dosBias: 0,
      asl5VCurrMon: 0,
      dsl5VCurrMon: 0,
      psTempMon: 0,
      cdsPlateVMon: 0,
      cdsRefVMon: 0,
      mpTemp: 0,
      vRef: 0,
      pd1SigLev: 0,
      pd2SigLev: 0,
      esdTrigCountL: 0,
      esdTrigCountH: 0,
      lowLetL: 0,
      lowLetM: 0,
      medLet1L: 0,
      medLet1M: 0,
      medLet2L: 0,
      medLet2M: 0,
      medLet3L: 0,
      medLet3M: 0,
      medLet4L: 0,
      medLet4M: 0,
      hiLetL: 0,
      hiLetM: 0,
      surfDosL: 0,
      surfDosM: 0,
      surfDosH: 0,
      surfDosChargeL: 0,
      surfDosChargeH: 0,
      surfDosStat: 0,
      cdsThrottle: 0,
      cdsThreshold: 0,
      checksum: 0,
      transientData: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: ECPSDR_Full_dataMode_Enum::REAL,
      onOrbit: None,
    }
  }
}

pub struct ECPSDR_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ECPSDR_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_idSensor(&mut self, idSensor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_IDSENSOR, idSensor);
  }
  #[inline]
  pub fn add_origSensorId(&mut self, origSensorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_ORIGSENSORID, origSensorId);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_msgTime(&mut self, msgTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_MSGTIME, msgTime);
  }
  #[inline]
  pub fn add_obTime(&mut self, obTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_OBTIME, obTime);
  }
  #[inline]
  pub fn add_retransmit(&mut self, retransmit: bool) {
    self.fbb_.push_slot::<bool>(ECPSDR_Full::VT_RETRANSMIT, retransmit, false);
  }
  #[inline]
  pub fn add_senMode(&mut self, senMode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_SENMODE, senMode);
  }
  #[inline]
  pub fn add_dosBias(&mut self, dosBias: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_DOSBIAS, dosBias, 0);
  }
  #[inline]
  pub fn add_asl5VCurrMon(&mut self, asl5VCurrMon: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_ASL5VCURRMON, asl5VCurrMon, 0);
  }
  #[inline]
  pub fn add_dsl5VCurrMon(&mut self, dsl5VCurrMon: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_DSL5VCURRMON, dsl5VCurrMon, 0);
  }
  #[inline]
  pub fn add_psTempMon(&mut self, psTempMon: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_PSTEMPMON, psTempMon, 0);
  }
  #[inline]
  pub fn add_cdsPlateVMon(&mut self, cdsPlateVMon: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_CDSPLATEVMON, cdsPlateVMon, 0);
  }
  #[inline]
  pub fn add_cdsRefVMon(&mut self, cdsRefVMon: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_CDSREFVMON, cdsRefVMon, 0);
  }
  #[inline]
  pub fn add_mpTemp(&mut self, mpTemp: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_MPTEMP, mpTemp, 0);
  }
  #[inline]
  pub fn add_vRef(&mut self, vRef: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_VREF, vRef, 0);
  }
  #[inline]
  pub fn add_pd1SigLev(&mut self, pd1SigLev: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_PD1SIGLEV, pd1SigLev, 0);
  }
  #[inline]
  pub fn add_pd2SigLev(&mut self, pd2SigLev: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_PD2SIGLEV, pd2SigLev, 0);
  }
  #[inline]
  pub fn add_esdTrigCountL(&mut self, esdTrigCountL: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_ESDTRIGCOUNTL, esdTrigCountL, 0);
  }
  #[inline]
  pub fn add_esdTrigCountH(&mut self, esdTrigCountH: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_ESDTRIGCOUNTH, esdTrigCountH, 0);
  }
  #[inline]
  pub fn add_lowLetL(&mut self, lowLetL: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_LOWLETL, lowLetL, 0);
  }
  #[inline]
  pub fn add_lowLetM(&mut self, lowLetM: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_LOWLETM, lowLetM, 0);
  }
  #[inline]
  pub fn add_medLet1L(&mut self, medLet1L: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_MEDLET1L, medLet1L, 0);
  }
  #[inline]
  pub fn add_medLet1M(&mut self, medLet1M: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_MEDLET1M, medLet1M, 0);
  }
  #[inline]
  pub fn add_medLet2L(&mut self, medLet2L: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_MEDLET2L, medLet2L, 0);
  }
  #[inline]
  pub fn add_medLet2M(&mut self, medLet2M: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_MEDLET2M, medLet2M, 0);
  }
  #[inline]
  pub fn add_medLet3L(&mut self, medLet3L: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_MEDLET3L, medLet3L, 0);
  }
  #[inline]
  pub fn add_medLet3M(&mut self, medLet3M: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_MEDLET3M, medLet3M, 0);
  }
  #[inline]
  pub fn add_medLet4L(&mut self, medLet4L: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_MEDLET4L, medLet4L, 0);
  }
  #[inline]
  pub fn add_medLet4M(&mut self, medLet4M: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_MEDLET4M, medLet4M, 0);
  }
  #[inline]
  pub fn add_hiLetL(&mut self, hiLetL: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_HILETL, hiLetL, 0);
  }
  #[inline]
  pub fn add_hiLetM(&mut self, hiLetM: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_HILETM, hiLetM, 0);
  }
  #[inline]
  pub fn add_surfDosL(&mut self, surfDosL: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_SURFDOSL, surfDosL, 0);
  }
  #[inline]
  pub fn add_surfDosM(&mut self, surfDosM: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_SURFDOSM, surfDosM, 0);
  }
  #[inline]
  pub fn add_surfDosH(&mut self, surfDosH: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_SURFDOSH, surfDosH, 0);
  }
  #[inline]
  pub fn add_surfDosChargeL(&mut self, surfDosChargeL: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_SURFDOSCHARGEL, surfDosChargeL, 0);
  }
  #[inline]
  pub fn add_surfDosChargeH(&mut self, surfDosChargeH: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_SURFDOSCHARGEH, surfDosChargeH, 0);
  }
  #[inline]
  pub fn add_surfDosStat(&mut self, surfDosStat: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_SURFDOSSTAT, surfDosStat, 0);
  }
  #[inline]
  pub fn add_cdsThrottle(&mut self, cdsThrottle: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_CDSTHROTTLE, cdsThrottle, 0);
  }
  #[inline]
  pub fn add_cdsThreshold(&mut self, cdsThreshold: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_CDSTHRESHOLD, cdsThreshold, 0);
  }
  #[inline]
  pub fn add_checksum(&mut self, checksum: i32) {
    self.fbb_.push_slot::<i32>(ECPSDR_Full::VT_CHECKSUM, checksum, 0);
  }
  #[inline]
  pub fn add_transientData(&mut self, transientData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_TRANSIENTDATA, transientData);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: ECPSDR_Full_dataMode_Enum) {
    self.fbb_.push_slot::<ECPSDR_Full_dataMode_Enum>(ECPSDR_Full::VT_DATAMODE, dataMode, ECPSDR_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_onOrbit(&mut self, onOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ECPSDR_Full::VT_ONORBIT, onOrbit);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ECPSDR_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ECPSDR_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ECPSDR_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ECPSDR_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ECPSDR_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("satNo", &self.satNo());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("idSensor", &self.idSensor());
      ds.field("origSensorId", &self.origSensorId());
      ds.field("type_", &self.type_());
      ds.field("msgTime", &self.msgTime());
      ds.field("obTime", &self.obTime());
      ds.field("retransmit", &self.retransmit());
      ds.field("senMode", &self.senMode());
      ds.field("dosBias", &self.dosBias());
      ds.field("asl5VCurrMon", &self.asl5VCurrMon());
      ds.field("dsl5VCurrMon", &self.dsl5VCurrMon());
      ds.field("psTempMon", &self.psTempMon());
      ds.field("cdsPlateVMon", &self.cdsPlateVMon());
      ds.field("cdsRefVMon", &self.cdsRefVMon());
      ds.field("mpTemp", &self.mpTemp());
      ds.field("vRef", &self.vRef());
      ds.field("pd1SigLev", &self.pd1SigLev());
      ds.field("pd2SigLev", &self.pd2SigLev());
      ds.field("esdTrigCountL", &self.esdTrigCountL());
      ds.field("esdTrigCountH", &self.esdTrigCountH());
      ds.field("lowLetL", &self.lowLetL());
      ds.field("lowLetM", &self.lowLetM());
      ds.field("medLet1L", &self.medLet1L());
      ds.field("medLet1M", &self.medLet1M());
      ds.field("medLet2L", &self.medLet2L());
      ds.field("medLet2M", &self.medLet2M());
      ds.field("medLet3L", &self.medLet3L());
      ds.field("medLet3M", &self.medLet3M());
      ds.field("medLet4L", &self.medLet4L());
      ds.field("medLet4M", &self.medLet4M());
      ds.field("hiLetL", &self.hiLetL());
      ds.field("hiLetM", &self.hiLetM());
      ds.field("surfDosL", &self.surfDosL());
      ds.field("surfDosM", &self.surfDosM());
      ds.field("surfDosH", &self.surfDosH());
      ds.field("surfDosChargeL", &self.surfDosChargeL());
      ds.field("surfDosChargeH", &self.surfDosChargeH());
      ds.field("surfDosStat", &self.surfDosStat());
      ds.field("cdsThrottle", &self.cdsThrottle());
      ds.field("cdsThreshold", &self.cdsThreshold());
      ds.field("checksum", &self.checksum());
      ds.field("transientData", &self.transientData());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.field("onOrbit", &self.onOrbit());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ECPSDR_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idOnOrbit: Option<String>,
  pub satNo: i32,
  pub origObjectId: Option<String>,
  pub idSensor: Option<String>,
  pub origSensorId: Option<String>,
  pub type_: Option<String>,
  pub msgTime: Option<String>,
  pub obTime: Option<String>,
  pub retransmit: bool,
  pub senMode: Option<String>,
  pub dosBias: i32,
  pub asl5VCurrMon: i32,
  pub dsl5VCurrMon: i32,
  pub psTempMon: i32,
  pub cdsPlateVMon: i32,
  pub cdsRefVMon: i32,
  pub mpTemp: i32,
  pub vRef: i32,
  pub pd1SigLev: i32,
  pub pd2SigLev: i32,
  pub esdTrigCountL: i32,
  pub esdTrigCountH: i32,
  pub lowLetL: i32,
  pub lowLetM: i32,
  pub medLet1L: i32,
  pub medLet1M: i32,
  pub medLet2L: i32,
  pub medLet2M: i32,
  pub medLet3L: i32,
  pub medLet3M: i32,
  pub medLet4L: i32,
  pub medLet4M: i32,
  pub hiLetL: i32,
  pub hiLetM: i32,
  pub surfDosL: i32,
  pub surfDosM: i32,
  pub surfDosH: i32,
  pub surfDosChargeL: i32,
  pub surfDosChargeH: i32,
  pub surfDosStat: i32,
  pub cdsThrottle: i32,
  pub cdsThreshold: i32,
  pub checksum: i32,
  pub transientData: Option<Vec<String>>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: ECPSDR_Full_dataMode_Enum,
  pub onOrbit: Option<String>,
}
impl Default for ECPSDR_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      idSensor: None,
      origSensorId: None,
      type_: None,
      msgTime: None,
      obTime: None,
      retransmit: false,
      senMode: None,
      dosBias: 0,
      asl5VCurrMon: 0,
      dsl5VCurrMon: 0,
      psTempMon: 0,
      cdsPlateVMon: 0,
      cdsRefVMon: 0,
      mpTemp: 0,
      vRef: 0,
      pd1SigLev: 0,
      pd2SigLev: 0,
      esdTrigCountL: 0,
      esdTrigCountH: 0,
      lowLetL: 0,
      lowLetM: 0,
      medLet1L: 0,
      medLet1M: 0,
      medLet2L: 0,
      medLet2M: 0,
      medLet3L: 0,
      medLet3M: 0,
      medLet4L: 0,
      medLet4M: 0,
      hiLetL: 0,
      hiLetM: 0,
      surfDosL: 0,
      surfDosM: 0,
      surfDosH: 0,
      surfDosChargeL: 0,
      surfDosChargeH: 0,
      surfDosStat: 0,
      cdsThrottle: 0,
      cdsThreshold: 0,
      checksum: 0,
      transientData: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: ECPSDR_Full_dataMode_Enum::REAL,
      onOrbit: None,
    }
  }
}
impl ECPSDR_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ECPSDR_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo = self.satNo;
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor = self.idSensor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId = self.origSensorId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msgTime = self.msgTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let obTime = self.obTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let retransmit = self.retransmit;
    let senMode = self.senMode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dosBias = self.dosBias;
    let asl5VCurrMon = self.asl5VCurrMon;
    let dsl5VCurrMon = self.dsl5VCurrMon;
    let psTempMon = self.psTempMon;
    let cdsPlateVMon = self.cdsPlateVMon;
    let cdsRefVMon = self.cdsRefVMon;
    let mpTemp = self.mpTemp;
    let vRef = self.vRef;
    let pd1SigLev = self.pd1SigLev;
    let pd2SigLev = self.pd2SigLev;
    let esdTrigCountL = self.esdTrigCountL;
    let esdTrigCountH = self.esdTrigCountH;
    let lowLetL = self.lowLetL;
    let lowLetM = self.lowLetM;
    let medLet1L = self.medLet1L;
    let medLet1M = self.medLet1M;
    let medLet2L = self.medLet2L;
    let medLet2M = self.medLet2M;
    let medLet3L = self.medLet3L;
    let medLet3M = self.medLet3M;
    let medLet4L = self.medLet4L;
    let medLet4M = self.medLet4M;
    let hiLetL = self.hiLetL;
    let hiLetM = self.hiLetM;
    let surfDosL = self.surfDosL;
    let surfDosM = self.surfDosM;
    let surfDosH = self.surfDosH;
    let surfDosChargeL = self.surfDosChargeL;
    let surfDosChargeH = self.surfDosChargeH;
    let surfDosStat = self.surfDosStat;
    let cdsThrottle = self.cdsThrottle;
    let cdsThreshold = self.cdsThreshold;
    let checksum = self.checksum;
    let transientData = self.transientData.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let onOrbit = self.onOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ECPSDR_Full::create(_fbb, &ECPSDR_FullArgs{
      id,
      classificationMarking,
      idOnOrbit,
      satNo,
      origObjectId,
      idSensor,
      origSensorId,
      type_,
      msgTime,
      obTime,
      retransmit,
      senMode,
      dosBias,
      asl5VCurrMon,
      dsl5VCurrMon,
      psTempMon,
      cdsPlateVMon,
      cdsRefVMon,
      mpTemp,
      vRef,
      pd1SigLev,
      pd2SigLev,
      esdTrigCountL,
      esdTrigCountH,
      lowLetL,
      lowLetM,
      medLet1L,
      medLet1M,
      medLet2L,
      medLet2M,
      medLet3L,
      medLet3M,
      medLet4L,
      medLet4M,
      hiLetL,
      hiLetM,
      surfDosL,
      surfDosM,
      surfDosH,
      surfDosChargeL,
      surfDosChargeH,
      surfDosStat,
      cdsThrottle,
      cdsThreshold,
      checksum,
      transientData,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      origNetwork,
      dataMode,
      onOrbit,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ECPSDR_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ecpsdr_full_unchecked`.
pub fn root_as_ecpsdr_full(buf: &[u8]) -> Result<ECPSDR_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ECPSDR_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ECPSDR_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ecpsdr_full_unchecked`.
pub fn size_prefixed_root_as_ecpsdr_full(buf: &[u8]) -> Result<ECPSDR_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ECPSDR_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ECPSDR_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ecpsdr_full_unchecked`.
pub fn root_as_ecpsdr_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ECPSDR_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ECPSDR_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ECPSDR_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ecpsdr_full_unchecked`.
pub fn size_prefixed_root_as_ecpsdr_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ECPSDR_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ECPSDR_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ECPSDR_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ECPSDR_Full`.
pub unsafe fn root_as_ecpsdr_full_unchecked(buf: &[u8]) -> ECPSDR_Full {
  flatbuffers::root_unchecked::<ECPSDR_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ECPSDR_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ECPSDR_Full`.
pub unsafe fn size_prefixed_root_as_ecpsdr_full_unchecked(buf: &[u8]) -> ECPSDR_Full {
  flatbuffers::size_prefixed_root_unchecked::<ECPSDR_Full>(buf)
}
pub const ECPSDR_FULL_IDENTIFIER: &str = "ECPS";

#[inline]
pub fn ecpsdr_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ECPSDR_FULL_IDENTIFIER, false)
}

#[inline]
pub fn ecpsdr_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ECPSDR_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_ecpsdr_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ECPSDR_Full<'a>>) {
  fbb.finish(root, Some(ECPSDR_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_ecpsdr_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ECPSDR_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(ECPSDR_FULL_IDENTIFIER));
}
