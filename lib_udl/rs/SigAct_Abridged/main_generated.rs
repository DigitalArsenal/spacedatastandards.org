// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SIG_ACT_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SIG_ACT_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SIG_ACT_ABRIDGED_DATA_MODE_ENUM: [SigAct_Abridged_dataMode_Enum; 4] = [
  SigAct_Abridged_dataMode_Enum::REAL,
  SigAct_Abridged_dataMode_Enum::TEST,
  SigAct_Abridged_dataMode_Enum::SIMULATED,
  SigAct_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SigAct_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl SigAct_Abridged_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SigAct_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SigAct_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SigAct_Abridged_dataMode_Enum {
    type Output = SigAct_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SigAct_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SigAct_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SigAct_Abridged_dataMode_Enum {}
pub enum SigAct_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Provides information on the dates, actors, locations, fatalities, and types of all reported political violence and protest events across the world.
pub struct SigAct_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SigAct_Abridged<'a> {
  type Inner = SigAct_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SigAct_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_SOURCELANGUAGE: flatbuffers::VOffsetT = 8;
  pub const VT_COUNTRYCODE: flatbuffers::VOffsetT = 10;
  pub const VT_CITY: flatbuffers::VOffsetT = 12;
  pub const VT_DISTRICT: flatbuffers::VOffsetT = 14;
  pub const VT_PROVINCE: flatbuffers::VOffsetT = 16;
  pub const VT_LAT: flatbuffers::VOffsetT = 18;
  pub const VT_LON: flatbuffers::VOffsetT = 20;
  pub const VT_MILGRID: flatbuffers::VOffsetT = 22;
  pub const VT_THEATER: flatbuffers::VOffsetT = 24;
  pub const VT_ATEXT: flatbuffers::VOffsetT = 26;
  pub const VT_AGJSON: flatbuffers::VOffsetT = 28;
  pub const VT_ATYPE: flatbuffers::VOffsetT = 30;
  pub const VT_ANDIMS: flatbuffers::VOffsetT = 32;
  pub const VT_ASRID: flatbuffers::VOffsetT = 34;
  pub const VT_EVENTSTART: flatbuffers::VOffsetT = 36;
  pub const VT_EVENTEND: flatbuffers::VOffsetT = 38;
  pub const VT_REPORTDATE: flatbuffers::VOffsetT = 40;
  pub const VT_ACTORS: flatbuffers::VOffsetT = 42;
  pub const VT_CIVABD: flatbuffers::VOffsetT = 44;
  pub const VT_CIVDET: flatbuffers::VOffsetT = 46;
  pub const VT_CIVKIA: flatbuffers::VOffsetT = 48;
  pub const VT_CIVWOUND: flatbuffers::VOffsetT = 50;
  pub const VT_COALABD: flatbuffers::VOffsetT = 52;
  pub const VT_COALDET: flatbuffers::VOffsetT = 54;
  pub const VT_COALKIA: flatbuffers::VOffsetT = 56;
  pub const VT_COALWOUND: flatbuffers::VOffsetT = 58;
  pub const VT_ENEMYABD: flatbuffers::VOffsetT = 60;
  pub const VT_ENEMYDET: flatbuffers::VOffsetT = 62;
  pub const VT_ENEMYKIA: flatbuffers::VOffsetT = 64;
  pub const VT_FRIENDLYABD: flatbuffers::VOffsetT = 66;
  pub const VT_FRIENDLYDET: flatbuffers::VOffsetT = 68;
  pub const VT_FRIENDLYKIA: flatbuffers::VOffsetT = 70;
  pub const VT_FRIENDLYWOUND: flatbuffers::VOffsetT = 72;
  pub const VT_HOSTNATABD: flatbuffers::VOffsetT = 74;
  pub const VT_HOSTNATDET: flatbuffers::VOffsetT = 76;
  pub const VT_HOSTNATKIA: flatbuffers::VOffsetT = 78;
  pub const VT_HOSTNATWOUND: flatbuffers::VOffsetT = 80;
  pub const VT_SIDEAABD: flatbuffers::VOffsetT = 82;
  pub const VT_SIDEADET: flatbuffers::VOffsetT = 84;
  pub const VT_SIDEAKIA: flatbuffers::VOffsetT = 86;
  pub const VT_SIDEAWOUND: flatbuffers::VOffsetT = 88;
  pub const VT_SIDEBABD: flatbuffers::VOffsetT = 90;
  pub const VT_SIDEBDET: flatbuffers::VOffsetT = 92;
  pub const VT_SIDEBKIA: flatbuffers::VOffsetT = 94;
  pub const VT_SIDEBWOUND: flatbuffers::VOffsetT = 96;
  pub const VT_TARGET: flatbuffers::VOffsetT = 98;
  pub const VT_EVENTDESCRIPTION: flatbuffers::VOffsetT = 100;
  pub const VT_EVENTTYPE: flatbuffers::VOffsetT = 102;
  pub const VT_TYPEOFATTACK: flatbuffers::VOffsetT = 104;
  pub const VT_COMPLEXATTACK: flatbuffers::VOffsetT = 106;
  pub const VT_IDNUMBER: flatbuffers::VOffsetT = 108;
  pub const VT_CONFIDENCE: flatbuffers::VOffsetT = 110;
  pub const VT_ACCURACY: flatbuffers::VOffsetT = 112;
  pub const VT_CLARITY: flatbuffers::VOffsetT = 114;
  pub const VT_CAMEOCODE: flatbuffers::VOffsetT = 116;
  pub const VT_CAMEOBASECODE: flatbuffers::VOffsetT = 118;
  pub const VT_CAMEOROOTCODE: flatbuffers::VOffsetT = 120;
  pub const VT_GOLDSTEIN: flatbuffers::VOffsetT = 122;
  pub const VT_DOCUMENTSOURCE: flatbuffers::VOffsetT = 124;
  pub const VT_DOCUMENTFILENAME: flatbuffers::VOffsetT = 126;
  pub const VT_HASATTACHMENT: flatbuffers::VOffsetT = 128;
  pub const VT_FILESIZE: flatbuffers::VOffsetT = 130;
  pub const VT_CHECKSUMVALUE: flatbuffers::VOffsetT = 132;
  pub const VT_REPUNIT: flatbuffers::VOffsetT = 134;
  pub const VT_REPUNITTYPE: flatbuffers::VOffsetT = 136;
  pub const VT_REPUNITACTIVITY: flatbuffers::VOffsetT = 138;
  pub const VT_NUMMENTIONS: flatbuffers::VOffsetT = 140;
  pub const VT_NUMSOURCES: flatbuffers::VOffsetT = 142;
  pub const VT_NUMARTICLES: flatbuffers::VOffsetT = 144;
  pub const VT_AVGTONE: flatbuffers::VOffsetT = 146;
  pub const VT_SOURCEURL: flatbuffers::VOffsetT = 148;
  pub const VT_RELATEDDOCS: flatbuffers::VOffsetT = 150;
  pub const VT_SUMMARY: flatbuffers::VOffsetT = 152;
  pub const VT_NOTES: flatbuffers::VOffsetT = 154;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 156;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 158;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 160;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 162;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 164;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 166;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SigAct_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SigAct_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<SigAct_Abridged<'bldr>> {
    let mut builder = SigAct_AbridgedBuilder::new(_fbb);
    builder.add_avgTone(args.avgTone);
    builder.add_filesize(args.filesize);
    builder.add_goldstein(args.goldstein);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.notes { builder.add_notes(x); }
    if let Some(x) = args.summary { builder.add_summary(x); }
    if let Some(x) = args.relatedDocs { builder.add_relatedDocs(x); }
    if let Some(x) = args.sourceUrl { builder.add_sourceUrl(x); }
    builder.add_numArticles(args.numArticles);
    builder.add_numSources(args.numSources);
    builder.add_numMentions(args.numMentions);
    if let Some(x) = args.repUnitActivity { builder.add_repUnitActivity(x); }
    if let Some(x) = args.repUnitType { builder.add_repUnitType(x); }
    if let Some(x) = args.repUnit { builder.add_repUnit(x); }
    if let Some(x) = args.checksumValue { builder.add_checksumValue(x); }
    if let Some(x) = args.documentFilename { builder.add_documentFilename(x); }
    if let Some(x) = args.documentSource { builder.add_documentSource(x); }
    if let Some(x) = args.cameoRootCode { builder.add_cameoRootCode(x); }
    if let Some(x) = args.cameoBaseCode { builder.add_cameoBaseCode(x); }
    if let Some(x) = args.cameoCode { builder.add_cameoCode(x); }
    builder.add_clarity(args.clarity);
    builder.add_accuracy(args.accuracy);
    builder.add_confidence(args.confidence);
    if let Some(x) = args.idNumber { builder.add_idNumber(x); }
    if let Some(x) = args.typeOfAttack { builder.add_typeOfAttack(x); }
    if let Some(x) = args.eventType { builder.add_eventType(x); }
    if let Some(x) = args.eventDescription { builder.add_eventDescription(x); }
    if let Some(x) = args.target { builder.add_target(x); }
    builder.add_sideBWound(args.sideBWound);
    builder.add_sideBKIA(args.sideBKIA);
    builder.add_sideBDet(args.sideBDet);
    builder.add_sideBAbd(args.sideBAbd);
    builder.add_sideAWound(args.sideAWound);
    builder.add_sideAKIA(args.sideAKIA);
    builder.add_sideADet(args.sideADet);
    builder.add_sideAAbd(args.sideAAbd);
    builder.add_hostNatWound(args.hostNatWound);
    builder.add_hostNatKIA(args.hostNatKIA);
    builder.add_hostNatDet(args.hostNatDet);
    builder.add_hostNatAbd(args.hostNatAbd);
    builder.add_friendlyWound(args.friendlyWound);
    builder.add_friendlyKIA(args.friendlyKIA);
    builder.add_friendlyDet(args.friendlyDet);
    builder.add_friendlyAbd(args.friendlyAbd);
    builder.add_enemyKIA(args.enemyKIA);
    builder.add_enemyDet(args.enemyDet);
    builder.add_enemyAbd(args.enemyAbd);
    builder.add_coalWound(args.coalWound);
    builder.add_coalKIA(args.coalKIA);
    builder.add_coalDet(args.coalDet);
    builder.add_coalAbd(args.coalAbd);
    builder.add_civWound(args.civWound);
    builder.add_civKIA(args.civKIA);
    builder.add_civDet(args.civDet);
    builder.add_civAbd(args.civAbd);
    if let Some(x) = args.actors { builder.add_actors(x); }
    if let Some(x) = args.reportDate { builder.add_reportDate(x); }
    if let Some(x) = args.eventEnd { builder.add_eventEnd(x); }
    if let Some(x) = args.eventStart { builder.add_eventStart(x); }
    builder.add_asrid(args.asrid);
    builder.add_andims(args.andims);
    if let Some(x) = args.atype { builder.add_atype(x); }
    if let Some(x) = args.agjson { builder.add_agjson(x); }
    if let Some(x) = args.atext { builder.add_atext(x); }
    if let Some(x) = args.theater { builder.add_theater(x); }
    if let Some(x) = args.milgrid { builder.add_milgrid(x); }
    if let Some(x) = args.province { builder.add_province(x); }
    if let Some(x) = args.district { builder.add_district(x); }
    if let Some(x) = args.city { builder.add_city(x); }
    if let Some(x) = args.countryCode { builder.add_countryCode(x); }
    if let Some(x) = args.sourceLanguage { builder.add_sourceLanguage(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_hasAttachment(args.hasAttachment);
    builder.add_complexAttack(args.complexAttack);
    builder.finish()
  }

  pub fn unpack(&self) -> SigAct_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let sourceLanguage = self.sourceLanguage().map(|x| {
      x.to_string()
    });
    let countryCode = self.countryCode().map(|x| {
      x.to_string()
    });
    let city = self.city().map(|x| {
      x.to_string()
    });
    let district = self.district().map(|x| {
      x.to_string()
    });
    let province = self.province().map(|x| {
      x.to_string()
    });
    let lat = self.lat();
    let lon = self.lon();
    let milgrid = self.milgrid().map(|x| {
      x.to_string()
    });
    let theater = self.theater().map(|x| {
      x.to_string()
    });
    let atext = self.atext().map(|x| {
      x.to_string()
    });
    let agjson = self.agjson().map(|x| {
      x.to_string()
    });
    let atype = self.atype().map(|x| {
      x.to_string()
    });
    let andims = self.andims();
    let asrid = self.asrid();
    let eventStart = self.eventStart().map(|x| {
      x.to_string()
    });
    let eventEnd = self.eventEnd().map(|x| {
      x.to_string()
    });
    let reportDate = self.reportDate().map(|x| {
      x.to_string()
    });
    let actors = self.actors().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let civAbd = self.civAbd();
    let civDet = self.civDet();
    let civKIA = self.civKIA();
    let civWound = self.civWound();
    let coalAbd = self.coalAbd();
    let coalDet = self.coalDet();
    let coalKIA = self.coalKIA();
    let coalWound = self.coalWound();
    let enemyAbd = self.enemyAbd();
    let enemyDet = self.enemyDet();
    let enemyKIA = self.enemyKIA();
    let friendlyAbd = self.friendlyAbd();
    let friendlyDet = self.friendlyDet();
    let friendlyKIA = self.friendlyKIA();
    let friendlyWound = self.friendlyWound();
    let hostNatAbd = self.hostNatAbd();
    let hostNatDet = self.hostNatDet();
    let hostNatKIA = self.hostNatKIA();
    let hostNatWound = self.hostNatWound();
    let sideAAbd = self.sideAAbd();
    let sideADet = self.sideADet();
    let sideAKIA = self.sideAKIA();
    let sideAWound = self.sideAWound();
    let sideBAbd = self.sideBAbd();
    let sideBDet = self.sideBDet();
    let sideBKIA = self.sideBKIA();
    let sideBWound = self.sideBWound();
    let target = self.target().map(|x| {
      x.to_string()
    });
    let eventDescription = self.eventDescription().map(|x| {
      x.to_string()
    });
    let eventType = self.eventType().map(|x| {
      x.to_string()
    });
    let typeOfAttack = self.typeOfAttack().map(|x| {
      x.to_string()
    });
    let complexAttack = self.complexAttack();
    let idNumber = self.idNumber().map(|x| {
      x.to_string()
    });
    let confidence = self.confidence();
    let accuracy = self.accuracy();
    let clarity = self.clarity();
    let cameoCode = self.cameoCode().map(|x| {
      x.to_string()
    });
    let cameoBaseCode = self.cameoBaseCode().map(|x| {
      x.to_string()
    });
    let cameoRootCode = self.cameoRootCode().map(|x| {
      x.to_string()
    });
    let goldstein = self.goldstein();
    let documentSource = self.documentSource().map(|x| {
      x.to_string()
    });
    let documentFilename = self.documentFilename().map(|x| {
      x.to_string()
    });
    let hasAttachment = self.hasAttachment();
    let filesize = self.filesize();
    let checksumValue = self.checksumValue().map(|x| {
      x.to_string()
    });
    let repUnit = self.repUnit().map(|x| {
      x.to_string()
    });
    let repUnitType = self.repUnitType().map(|x| {
      x.to_string()
    });
    let repUnitActivity = self.repUnitActivity().map(|x| {
      x.to_string()
    });
    let numMentions = self.numMentions();
    let numSources = self.numSources();
    let numArticles = self.numArticles();
    let avgTone = self.avgTone();
    let sourceUrl = self.sourceUrl().map(|x| {
      x.to_string()
    });
    let relatedDocs = self.relatedDocs().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let summary = self.summary().map(|x| {
      x.to_string()
    });
    let notes = self.notes().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    SigAct_AbridgedT {
      id,
      classificationMarking,
      sourceLanguage,
      countryCode,
      city,
      district,
      province,
      lat,
      lon,
      milgrid,
      theater,
      atext,
      agjson,
      atype,
      andims,
      asrid,
      eventStart,
      eventEnd,
      reportDate,
      actors,
      civAbd,
      civDet,
      civKIA,
      civWound,
      coalAbd,
      coalDet,
      coalKIA,
      coalWound,
      enemyAbd,
      enemyDet,
      enemyKIA,
      friendlyAbd,
      friendlyDet,
      friendlyKIA,
      friendlyWound,
      hostNatAbd,
      hostNatDet,
      hostNatKIA,
      hostNatWound,
      sideAAbd,
      sideADet,
      sideAKIA,
      sideAWound,
      sideBAbd,
      sideBDet,
      sideBKIA,
      sideBWound,
      target,
      eventDescription,
      eventType,
      typeOfAttack,
      complexAttack,
      idNumber,
      confidence,
      accuracy,
      clarity,
      cameoCode,
      cameoBaseCode,
      cameoRootCode,
      goldstein,
      documentSource,
      documentFilename,
      hasAttachment,
      filesize,
      checksumValue,
      repUnit,
      repUnitType,
      repUnitActivity,
      numMentions,
      numSources,
      numArticles,
      avgTone,
      sourceUrl,
      relatedDocs,
      summary,
      notes,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: SIGACT-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// The source language of the significant event using the ISO 639-3, 3 character code definition.
  /// Example: /// Example: eng
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn sourceLanguage(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_SOURCELANGUAGE, None)}
  }
  /// The country code. This value is typically the ISO 3166 Alpha-2 two-character country code, however it can also represent various consortiums that do not appear in the ISO document. The code must correspond to an existing country in the UDLâ€™s country API. Call udl/country/{code} to get any associated FIPS code, ISO Alpha-3 code, or alternate code values that exist for the specified country code.
  /// Example: /// Example: US
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn countryCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_COUNTRYCODE, None)}
  }
  /// The city in or near which this event occurred.
  /// Example: /// Example: Austin
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn city(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_CITY, None)}
  }
  /// The district in which this event occurred.
  /// Example: /// Example: district 12
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn district(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_DISTRICT, None)}
  }
  /// The province in which this event occurred.
  /// Example: /// Example: Province_Example
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn province(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_PROVINCE, None)}
  }
  /// WGS-84 centroid latitude of the event location, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.31
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SigAct_Abridged::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 centroid longitude of the event location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 90.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SigAct_Abridged::VT_LON, Some(0.0)).unwrap()}
  }
  /// The Military Grid Reference System is the geocoordinate standard used by NATO militaries for locating points on Earth. The MGRS is derived from the Universal Transverse Mercator (UTM) grid system and the Universal Polar Stereographic (UPS) grid system, but uses a different labeling convention. The MGRS is used as geocode for the entire Earth. Example of an milgrid coordinate, or grid reference, would be 4QFJ12345678, which consists of three parts:
  /// &nbsp;&nbsp;4Q (grid zone designator, GZD)
  /// &nbsp;&nbsp;FJ (the 100,000-meter square identifier)
  /// &nbsp;&nbsp;12345678 (numerical location; easting is 1234 and northing is 5678, in this case specifying a location with 10 m resolution).
  /// Example: /// Example: 4QFJ12345678
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn milgrid(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_MILGRID, None)}
  }
  /// Area in which important military events occur or are progressing.  A theater can include the entirety of the airspace, land and sea area that is or that may potentially become involved in war operations.
  /// Example: /// Example: Kabul
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn theater(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_THEATER, None)}
  }
  /// Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
  /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  /// Constraints: Minimum length = 0, Maximum length = 512
  #[inline]
  pub fn atext(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_ATEXT, None)}
  }
  /// Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
  /// Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
  /// Constraints: Minimum length = 0, Maximum length = 512
  #[inline]
  pub fn agjson(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_AGJSON, None)}
  }
  /// Type of region as projected on the ground.
  /// Example: /// Example: Type1
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn atype(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_ATYPE, None)}
  }
  /// Number of dimensions of the geometry depicted by region.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn andims(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_ANDIMS, Some(0)).unwrap()}
  }
  /// Geographical spatial_ref_sys for region.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn asrid(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_ASRID, Some(0)).unwrap()}
  }
  /// The approximate start time of the event, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-01-01T01:02:03.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn eventStart(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_EVENTSTART, None)}
  }
  /// The approximate end time of the event, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-01-01T01:02:03.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn eventEnd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_EVENTEND, None)}
  }
  /// Date of the report or filing.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn reportDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_REPORTDATE, None)}
  }
  /// A list of one or more actors involved in the event.
  /// Example: /// Example: ['US', 'CAN']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn actors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SigAct_Abridged::VT_ACTORS, None)}
  }
  /// Number of civilians abducted in the activity.
  /// Example: /// Example: 423
  /// Constraints: No constraints specified.
  #[inline]
  pub fn civAbd(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_CIVABD, Some(0)).unwrap()}
  }
  /// Number of civilians detained in the activity.
  /// Example: /// Example: 234
  /// Constraints: No constraints specified.
  #[inline]
  pub fn civDet(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_CIVDET, Some(0)).unwrap()}
  }
  /// Number of civilians killed in the activity.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn civKIA(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_CIVKIA, Some(0)).unwrap()}
  }
  /// Number of civilians wounded in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn civWound(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_CIVWOUND, Some(0)).unwrap()}
  }
  /// Number of coalition members abducted in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn coalAbd(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_COALABD, Some(0)).unwrap()}
  }
  /// Number of coalition members detained in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn coalDet(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_COALDET, Some(0)).unwrap()}
  }
  /// Number of coalition members killed in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn coalKIA(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_COALKIA, Some(0)).unwrap()}
  }
  /// Number of coalition members wounded in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn coalWound(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_COALWOUND, Some(0)).unwrap()}
  }
  /// Number of enemy combatants abducted in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn enemyAbd(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_ENEMYABD, Some(0)).unwrap()}
  }
  /// Number of enemy combatants detained in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn enemyDet(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_ENEMYDET, Some(0)).unwrap()}
  }
  /// Number of enemy combatants killed in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn enemyKIA(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_ENEMYKIA, Some(0)).unwrap()}
  }
  /// Number of friendlies abducted in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn friendlyAbd(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_FRIENDLYABD, Some(0)).unwrap()}
  }
  /// Number of friendlies in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn friendlyDet(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_FRIENDLYDET, Some(0)).unwrap()}
  }
  /// Number of friendlies killed in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn friendlyKIA(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_FRIENDLYKIA, Some(0)).unwrap()}
  }
  /// Number of friendlies wounded in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn friendlyWound(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_FRIENDLYWOUND, Some(0)).unwrap()}
  }
  /// Number of Host Nation members abducted in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hostNatAbd(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_HOSTNATABD, Some(0)).unwrap()}
  }
  /// Number of Host Nation members detained in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hostNatDet(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_HOSTNATDET, Some(0)).unwrap()}
  }
  /// Number of Host Nation members killed in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hostNatKIA(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_HOSTNATKIA, Some(0)).unwrap()}
  }
  /// Number of Host Nation members wounded in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hostNatWound(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_HOSTNATWOUND, Some(0)).unwrap()}
  }
  /// Number of side A members abducted in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sideAAbd(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_SIDEAABD, Some(0)).unwrap()}
  }
  /// Number of side A members detained in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sideADet(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_SIDEADET, Some(0)).unwrap()}
  }
  /// Number of side A members killed in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sideAKIA(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_SIDEAKIA, Some(0)).unwrap()}
  }
  /// Number of side A members wounded in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sideAWound(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_SIDEAWOUND, Some(0)).unwrap()}
  }
  /// Number of side B members abducted in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sideBAbd(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_SIDEBABD, Some(0)).unwrap()}
  }
  /// Number of side B members detained in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sideBDet(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_SIDEBDET, Some(0)).unwrap()}
  }
  /// Number of side B members killed in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sideBKIA(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_SIDEBKIA, Some(0)).unwrap()}
  }
  /// Number of side B members wounded in the activity.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sideBWound(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_SIDEBWOUND, Some(0)).unwrap()}
  }
  /// The name of the target.  The target may be an individual, an entity, or a country/region.
  /// Example: /// Example: US
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn target(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_TARGET, None)}
  }
  /// A description of the event.
  /// Example: /// Example: Example_Description
  /// Constraints: Minimum length = 0, Maximum length = 4096
  #[inline]
  pub fn eventDescription(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_EVENTDESCRIPTION, None)}
  }
  /// The type of event (e.g.  Military, Natural, Political, Social, etc.).
  /// Example: /// Example: Military
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn eventType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_EVENTTYPE, None)}
  }
  /// The mode of this attack or event (e.g. Direct Fire, IED Explosion, etc.).
  /// Example: /// Example: IED Explosion
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn typeOfAttack(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_TYPEOFATTACK, None)}
  }
  /// Flag indicating that this attack was of a complex or coordinated nature.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn complexAttack(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SigAct_Abridged::VT_COMPLEXATTACK, Some(false)).unwrap()}
  }
  /// Unique identifier assigned to each event record that uniquely identifies it in the master dataset.  This ID is provided for convenience of mapping to external systems.
  /// Example: /// Example: NUMBER-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn idNumber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_IDNUMBER, None)}
  }
  /// Estimate of the confidence that this event occurred.
  /// Example: /// Example: 13
  /// Constraints: No constraints specified.
  #[inline]
  pub fn confidence(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_CONFIDENCE, Some(0)).unwrap()}
  }
  /// Estimate of the accuracy that this event occurred as described/reported.
  /// Example: /// Example: 13
  /// Constraints: No constraints specified.
  #[inline]
  pub fn accuracy(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_ACCURACY, Some(0)).unwrap()}
  }
  /// 1 (high) for events where the reporting allows the coder to identify the event in full. That is, events where the individual happening is described by the original source in a sufficiently detailed way as to identify individual incidents, i.e. separate activities of fighting in a single location:
  /// 2 (lower) for events where an aggregation of information was already made by the source material that is impossible to undo in the coding process. Such events are described by the original source only as aggregates (totals) of multiple separate activities of fighting spanning over a longer period than a single, clearly defined day.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn clarity(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_CLARITY, Some(0)).unwrap()}
  }
  /// This is the raw CAMEO action code describing the action that Actor1 performed upon Actor2.  Additional information about Cameo Codes can be obtained from the GDELT project documentation here: https://www.gdeltproject.org/data.html#documentation.
  /// Example: /// Example: CAMEO_CODE
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn cameoCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_CAMEOCODE, None)}
  }
  /// CAMEO event codes are defined in a three-level taxonomy. For events at level three in the taxonomy, this yields its level two leaf root node. For example, code 0251 (Appeal for easing of administrative sanctions) would yield an EventBaseCode of 025 (Appeal to yield). This makes it possible to aggregate events at various resolutions of specificity. For events at levels two or one, this field will be set to EventCode.
  /// Example: /// Example: Example_cameoBaseCode
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn cameoBaseCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_CAMEOBASECODE, None)}
  }
  /// Similar to EventBaseCode, this defines the root-level category the event code falls under. For example, code 0251 (Appeal for easing of administrative sanctions) has a root code of 02 (Appeal). This makes it possible to aggregate events at various resolutions of specificity. For events at levels two or one, this field will be set to EventCode.
  /// Example: /// Example: Example_cameoRootCode
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn cameoRootCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_CAMEOROOTCODE, None)}
  }
  /// Each CAMEO event code is assigned a numeric score from -10 to +10, capturing the theoretical potential impact that type of event will have on the stability of a country. This is known as the Goldstein Scale. NOTE: this score is based on the type of event, not the specifics of the actual event record being recorded  thus two riots, one with 10 people and one with 10,000, will both receive the same Goldstein score. This can be aggregated to various levels of time resolution to yield an approximation of the stability of a location over time.
  /// Example: /// Example: 9.32
  /// Constraints: No constraints specified.
  #[inline]
  pub fn goldstein(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SigAct_Abridged::VT_GOLDSTEIN, Some(0.0)).unwrap()}
  }
  /// The source of the document or report.
  /// Example: /// Example: Example_documentSource
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn documentSource(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_DOCUMENTSOURCE, None)}
  }
  /// The filename of the document or report.
  /// Example: /// Example: Example_documentFilename
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn documentFilename(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_DOCUMENTFILENAME, None)}
  }
  /// Flag indicating this SigAct record has an associated txt file stored in the UDL. Retrieve the txt file by using the GET/udl/sigact/getFile/{id} where id is the same as the SigAct record id. The maximum file size for this service is 10,000,000 bytes (10MB). Files exceeding the maximum size will be rejected.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hasAttachment(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SigAct_Abridged::VT_HASATTACHMENT, Some(false)).unwrap()}
  }
  /// Size of the associated text file. Units in bytes. If filesize is provided without an associated file, it defaults to 0.
  /// Example: /// Example: 0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn filesize(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(SigAct_Abridged::VT_FILESIZE, Some(0)).unwrap()}
  }
  /// MD5 value of the file. The ingest/create operation will automatically generate the value.
  /// Example: /// Example: 120EA8A25E5D487BF68B5F7096440019
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn checksumValue(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_CHECKSUMVALUE, None)}
  }
  /// The reporting unit.
  /// Example: /// Example: Unit_1
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn repUnit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_REPUNIT, None)}
  }
  /// The reporting unit type.
  /// Example: /// Example: Example_repUnitType
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn repUnitType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_REPUNITTYPE, None)}
  }
  /// The activity the unit was engaged in.
  /// Example: /// Example: Example_Activity
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn repUnitActivity(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_REPUNITACTIVITY, None)}
  }
  /// This is the total number of mentions of this event across all source documents during the 15 minute update in which it was first seen. Multiple references to an event within a single document also contribute to this count. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
  /// Example: /// Example: 8
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numMentions(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_NUMMENTIONS, Some(0)).unwrap()}
  }
  /// This is the total number of information sources containing one or more mentions of this event during the 15 minute update in which it was first seen. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
  /// Example: /// Example: 8
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numSources(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_NUMSOURCES, Some(0)).unwrap()}
  }
  /// This is the total number of source documents containing one or more mentions of this event during the 15 minute update in which it was first seen. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
  /// Example: /// Example: 8
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numArticles(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SigAct_Abridged::VT_NUMARTICLES, Some(0)).unwrap()}
  }
  /// This is the average tone of all documents containing one or more mentions of this event during the 15 minute update in which it was first seen. The score ranges from -100 (extremely negative) to +100 (extremely positive). Common values range between -10 and +10, with 0 indicating neutral.
  /// Example: /// Example: 8.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn avgTone(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SigAct_Abridged::VT_AVGTONE, Some(0.0)).unwrap()}
  }
  /// This field records the URL or citation of the first news report it found this event in. In most cases this is the first report it saw the article in, but due to the timing and flow of news reports through the processing pipeline, this may not always be the very first report, but is at least in the first few reports.
  /// Example: /// Example: Example_URL
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn sourceUrl(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_SOURCEURL, None)}
  }
  /// Related document ids.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn relatedDocs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SigAct_Abridged::VT_RELATEDDOCS, None)}
  }
  /// A summary of the event.
  /// Example: /// Example: Example_Summary
  /// Constraints: Minimum length = 0, Maximum length = 4096
  #[inline]
  pub fn summary(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_SUMMARY, None)}
  }
  /// Notes related to the documents or event.
  /// Example: /// Example: Example_Notes
  /// Constraints: Minimum length = 0, Maximum length = 4096
  #[inline]
  pub fn notes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_NOTES, None)}
  }
  /// Time the row was created in the database, auto-populated by the system, example = 2018-01-01T16:00:00.123Z.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> SigAct_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SigAct_Abridged_dataMode_Enum>(SigAct_Abridged::VT_DATAMODE, Some(SigAct_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SigAct_Abridged::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for SigAct_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceLanguage", Self::VT_SOURCELANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("countryCode", Self::VT_COUNTRYCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("city", Self::VT_CITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("district", Self::VT_DISTRICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("province", Self::VT_PROVINCE, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("milgrid", Self::VT_MILGRID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("theater", Self::VT_THEATER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("atext", Self::VT_ATEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("agjson", Self::VT_AGJSON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("atype", Self::VT_ATYPE, false)?
     .visit_field::<i32>("andims", Self::VT_ANDIMS, false)?
     .visit_field::<i32>("asrid", Self::VT_ASRID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventStart", Self::VT_EVENTSTART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventEnd", Self::VT_EVENTEND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reportDate", Self::VT_REPORTDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("actors", Self::VT_ACTORS, false)?
     .visit_field::<i32>("civAbd", Self::VT_CIVABD, false)?
     .visit_field::<i32>("civDet", Self::VT_CIVDET, false)?
     .visit_field::<i32>("civKIA", Self::VT_CIVKIA, false)?
     .visit_field::<i32>("civWound", Self::VT_CIVWOUND, false)?
     .visit_field::<i32>("coalAbd", Self::VT_COALABD, false)?
     .visit_field::<i32>("coalDet", Self::VT_COALDET, false)?
     .visit_field::<i32>("coalKIA", Self::VT_COALKIA, false)?
     .visit_field::<i32>("coalWound", Self::VT_COALWOUND, false)?
     .visit_field::<i32>("enemyAbd", Self::VT_ENEMYABD, false)?
     .visit_field::<i32>("enemyDet", Self::VT_ENEMYDET, false)?
     .visit_field::<i32>("enemyKIA", Self::VT_ENEMYKIA, false)?
     .visit_field::<i32>("friendlyAbd", Self::VT_FRIENDLYABD, false)?
     .visit_field::<i32>("friendlyDet", Self::VT_FRIENDLYDET, false)?
     .visit_field::<i32>("friendlyKIA", Self::VT_FRIENDLYKIA, false)?
     .visit_field::<i32>("friendlyWound", Self::VT_FRIENDLYWOUND, false)?
     .visit_field::<i32>("hostNatAbd", Self::VT_HOSTNATABD, false)?
     .visit_field::<i32>("hostNatDet", Self::VT_HOSTNATDET, false)?
     .visit_field::<i32>("hostNatKIA", Self::VT_HOSTNATKIA, false)?
     .visit_field::<i32>("hostNatWound", Self::VT_HOSTNATWOUND, false)?
     .visit_field::<i32>("sideAAbd", Self::VT_SIDEAABD, false)?
     .visit_field::<i32>("sideADet", Self::VT_SIDEADET, false)?
     .visit_field::<i32>("sideAKIA", Self::VT_SIDEAKIA, false)?
     .visit_field::<i32>("sideAWound", Self::VT_SIDEAWOUND, false)?
     .visit_field::<i32>("sideBAbd", Self::VT_SIDEBABD, false)?
     .visit_field::<i32>("sideBDet", Self::VT_SIDEBDET, false)?
     .visit_field::<i32>("sideBKIA", Self::VT_SIDEBKIA, false)?
     .visit_field::<i32>("sideBWound", Self::VT_SIDEBWOUND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target", Self::VT_TARGET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventDescription", Self::VT_EVENTDESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventType", Self::VT_EVENTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("typeOfAttack", Self::VT_TYPEOFATTACK, false)?
     .visit_field::<bool>("complexAttack", Self::VT_COMPLEXATTACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idNumber", Self::VT_IDNUMBER, false)?
     .visit_field::<i32>("confidence", Self::VT_CONFIDENCE, false)?
     .visit_field::<i32>("accuracy", Self::VT_ACCURACY, false)?
     .visit_field::<i32>("clarity", Self::VT_CLARITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cameoCode", Self::VT_CAMEOCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cameoBaseCode", Self::VT_CAMEOBASECODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cameoRootCode", Self::VT_CAMEOROOTCODE, false)?
     .visit_field::<f64>("goldstein", Self::VT_GOLDSTEIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("documentSource", Self::VT_DOCUMENTSOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("documentFilename", Self::VT_DOCUMENTFILENAME, false)?
     .visit_field::<bool>("hasAttachment", Self::VT_HASATTACHMENT, false)?
     .visit_field::<i64>("filesize", Self::VT_FILESIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("checksumValue", Self::VT_CHECKSUMVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("repUnit", Self::VT_REPUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("repUnitType", Self::VT_REPUNITTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("repUnitActivity", Self::VT_REPUNITACTIVITY, false)?
     .visit_field::<i32>("numMentions", Self::VT_NUMMENTIONS, false)?
     .visit_field::<i32>("numSources", Self::VT_NUMSOURCES, false)?
     .visit_field::<i32>("numArticles", Self::VT_NUMARTICLES, false)?
     .visit_field::<f64>("avgTone", Self::VT_AVGTONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceUrl", Self::VT_SOURCEURL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relatedDocs", Self::VT_RELATEDDOCS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("summary", Self::VT_SUMMARY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("notes", Self::VT_NOTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<SigAct_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct SigAct_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceLanguage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub countryCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub city: Option<flatbuffers::WIPOffset<&'a str>>,
    pub district: Option<flatbuffers::WIPOffset<&'a str>>,
    pub province: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lat: f64,
    pub lon: f64,
    pub milgrid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub theater: Option<flatbuffers::WIPOffset<&'a str>>,
    pub atext: Option<flatbuffers::WIPOffset<&'a str>>,
    pub agjson: Option<flatbuffers::WIPOffset<&'a str>>,
    pub atype: Option<flatbuffers::WIPOffset<&'a str>>,
    pub andims: i32,
    pub asrid: i32,
    pub eventStart: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventEnd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reportDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub actors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub civAbd: i32,
    pub civDet: i32,
    pub civKIA: i32,
    pub civWound: i32,
    pub coalAbd: i32,
    pub coalDet: i32,
    pub coalKIA: i32,
    pub coalWound: i32,
    pub enemyAbd: i32,
    pub enemyDet: i32,
    pub enemyKIA: i32,
    pub friendlyAbd: i32,
    pub friendlyDet: i32,
    pub friendlyKIA: i32,
    pub friendlyWound: i32,
    pub hostNatAbd: i32,
    pub hostNatDet: i32,
    pub hostNatKIA: i32,
    pub hostNatWound: i32,
    pub sideAAbd: i32,
    pub sideADet: i32,
    pub sideAKIA: i32,
    pub sideAWound: i32,
    pub sideBAbd: i32,
    pub sideBDet: i32,
    pub sideBKIA: i32,
    pub sideBWound: i32,
    pub target: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub typeOfAttack: Option<flatbuffers::WIPOffset<&'a str>>,
    pub complexAttack: bool,
    pub idNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub confidence: i32,
    pub accuracy: i32,
    pub clarity: i32,
    pub cameoCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cameoBaseCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cameoRootCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub goldstein: f64,
    pub documentSource: Option<flatbuffers::WIPOffset<&'a str>>,
    pub documentFilename: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hasAttachment: bool,
    pub filesize: i64,
    pub checksumValue: Option<flatbuffers::WIPOffset<&'a str>>,
    pub repUnit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub repUnitType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub repUnitActivity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub numMentions: i32,
    pub numSources: i32,
    pub numArticles: i32,
    pub avgTone: f64,
    pub sourceUrl: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relatedDocs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub summary: Option<flatbuffers::WIPOffset<&'a str>>,
    pub notes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: SigAct_Abridged_dataMode_Enum,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SigAct_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    SigAct_AbridgedArgs {
      id: None,
      classificationMarking: None,
      sourceLanguage: None,
      countryCode: None,
      city: None,
      district: None,
      province: None,
      lat: 0.0,
      lon: 0.0,
      milgrid: None,
      theater: None,
      atext: None,
      agjson: None,
      atype: None,
      andims: 0,
      asrid: 0,
      eventStart: None,
      eventEnd: None,
      reportDate: None,
      actors: None,
      civAbd: 0,
      civDet: 0,
      civKIA: 0,
      civWound: 0,
      coalAbd: 0,
      coalDet: 0,
      coalKIA: 0,
      coalWound: 0,
      enemyAbd: 0,
      enemyDet: 0,
      enemyKIA: 0,
      friendlyAbd: 0,
      friendlyDet: 0,
      friendlyKIA: 0,
      friendlyWound: 0,
      hostNatAbd: 0,
      hostNatDet: 0,
      hostNatKIA: 0,
      hostNatWound: 0,
      sideAAbd: 0,
      sideADet: 0,
      sideAKIA: 0,
      sideAWound: 0,
      sideBAbd: 0,
      sideBDet: 0,
      sideBKIA: 0,
      sideBWound: 0,
      target: None,
      eventDescription: None,
      eventType: None,
      typeOfAttack: None,
      complexAttack: false,
      idNumber: None,
      confidence: 0,
      accuracy: 0,
      clarity: 0,
      cameoCode: None,
      cameoBaseCode: None,
      cameoRootCode: None,
      goldstein: 0.0,
      documentSource: None,
      documentFilename: None,
      hasAttachment: false,
      filesize: 0,
      checksumValue: None,
      repUnit: None,
      repUnitType: None,
      repUnitActivity: None,
      numMentions: 0,
      numSources: 0,
      numArticles: 0,
      avgTone: 0.0,
      sourceUrl: None,
      relatedDocs: None,
      summary: None,
      notes: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: SigAct_Abridged_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}

pub struct SigAct_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SigAct_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_sourceLanguage(&mut self, sourceLanguage: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_SOURCELANGUAGE, sourceLanguage);
  }
  #[inline]
  pub fn add_countryCode(&mut self, countryCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_COUNTRYCODE, countryCode);
  }
  #[inline]
  pub fn add_city(&mut self, city: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_CITY, city);
  }
  #[inline]
  pub fn add_district(&mut self, district: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_DISTRICT, district);
  }
  #[inline]
  pub fn add_province(&mut self, province: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_PROVINCE, province);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(SigAct_Abridged::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(SigAct_Abridged::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_milgrid(&mut self, milgrid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_MILGRID, milgrid);
  }
  #[inline]
  pub fn add_theater(&mut self, theater: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_THEATER, theater);
  }
  #[inline]
  pub fn add_atext(&mut self, atext: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_ATEXT, atext);
  }
  #[inline]
  pub fn add_agjson(&mut self, agjson: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_AGJSON, agjson);
  }
  #[inline]
  pub fn add_atype(&mut self, atype: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_ATYPE, atype);
  }
  #[inline]
  pub fn add_andims(&mut self, andims: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_ANDIMS, andims, 0);
  }
  #[inline]
  pub fn add_asrid(&mut self, asrid: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_ASRID, asrid, 0);
  }
  #[inline]
  pub fn add_eventStart(&mut self, eventStart: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_EVENTSTART, eventStart);
  }
  #[inline]
  pub fn add_eventEnd(&mut self, eventEnd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_EVENTEND, eventEnd);
  }
  #[inline]
  pub fn add_reportDate(&mut self, reportDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_REPORTDATE, reportDate);
  }
  #[inline]
  pub fn add_actors(&mut self, actors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_ACTORS, actors);
  }
  #[inline]
  pub fn add_civAbd(&mut self, civAbd: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_CIVABD, civAbd, 0);
  }
  #[inline]
  pub fn add_civDet(&mut self, civDet: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_CIVDET, civDet, 0);
  }
  #[inline]
  pub fn add_civKIA(&mut self, civKIA: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_CIVKIA, civKIA, 0);
  }
  #[inline]
  pub fn add_civWound(&mut self, civWound: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_CIVWOUND, civWound, 0);
  }
  #[inline]
  pub fn add_coalAbd(&mut self, coalAbd: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_COALABD, coalAbd, 0);
  }
  #[inline]
  pub fn add_coalDet(&mut self, coalDet: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_COALDET, coalDet, 0);
  }
  #[inline]
  pub fn add_coalKIA(&mut self, coalKIA: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_COALKIA, coalKIA, 0);
  }
  #[inline]
  pub fn add_coalWound(&mut self, coalWound: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_COALWOUND, coalWound, 0);
  }
  #[inline]
  pub fn add_enemyAbd(&mut self, enemyAbd: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_ENEMYABD, enemyAbd, 0);
  }
  #[inline]
  pub fn add_enemyDet(&mut self, enemyDet: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_ENEMYDET, enemyDet, 0);
  }
  #[inline]
  pub fn add_enemyKIA(&mut self, enemyKIA: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_ENEMYKIA, enemyKIA, 0);
  }
  #[inline]
  pub fn add_friendlyAbd(&mut self, friendlyAbd: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_FRIENDLYABD, friendlyAbd, 0);
  }
  #[inline]
  pub fn add_friendlyDet(&mut self, friendlyDet: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_FRIENDLYDET, friendlyDet, 0);
  }
  #[inline]
  pub fn add_friendlyKIA(&mut self, friendlyKIA: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_FRIENDLYKIA, friendlyKIA, 0);
  }
  #[inline]
  pub fn add_friendlyWound(&mut self, friendlyWound: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_FRIENDLYWOUND, friendlyWound, 0);
  }
  #[inline]
  pub fn add_hostNatAbd(&mut self, hostNatAbd: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_HOSTNATABD, hostNatAbd, 0);
  }
  #[inline]
  pub fn add_hostNatDet(&mut self, hostNatDet: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_HOSTNATDET, hostNatDet, 0);
  }
  #[inline]
  pub fn add_hostNatKIA(&mut self, hostNatKIA: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_HOSTNATKIA, hostNatKIA, 0);
  }
  #[inline]
  pub fn add_hostNatWound(&mut self, hostNatWound: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_HOSTNATWOUND, hostNatWound, 0);
  }
  #[inline]
  pub fn add_sideAAbd(&mut self, sideAAbd: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_SIDEAABD, sideAAbd, 0);
  }
  #[inline]
  pub fn add_sideADet(&mut self, sideADet: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_SIDEADET, sideADet, 0);
  }
  #[inline]
  pub fn add_sideAKIA(&mut self, sideAKIA: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_SIDEAKIA, sideAKIA, 0);
  }
  #[inline]
  pub fn add_sideAWound(&mut self, sideAWound: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_SIDEAWOUND, sideAWound, 0);
  }
  #[inline]
  pub fn add_sideBAbd(&mut self, sideBAbd: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_SIDEBABD, sideBAbd, 0);
  }
  #[inline]
  pub fn add_sideBDet(&mut self, sideBDet: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_SIDEBDET, sideBDet, 0);
  }
  #[inline]
  pub fn add_sideBKIA(&mut self, sideBKIA: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_SIDEBKIA, sideBKIA, 0);
  }
  #[inline]
  pub fn add_sideBWound(&mut self, sideBWound: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_SIDEBWOUND, sideBWound, 0);
  }
  #[inline]
  pub fn add_target(&mut self, target: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_TARGET, target);
  }
  #[inline]
  pub fn add_eventDescription(&mut self, eventDescription: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_EVENTDESCRIPTION, eventDescription);
  }
  #[inline]
  pub fn add_eventType(&mut self, eventType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_EVENTTYPE, eventType);
  }
  #[inline]
  pub fn add_typeOfAttack(&mut self, typeOfAttack: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_TYPEOFATTACK, typeOfAttack);
  }
  #[inline]
  pub fn add_complexAttack(&mut self, complexAttack: bool) {
    self.fbb_.push_slot::<bool>(SigAct_Abridged::VT_COMPLEXATTACK, complexAttack, false);
  }
  #[inline]
  pub fn add_idNumber(&mut self, idNumber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_IDNUMBER, idNumber);
  }
  #[inline]
  pub fn add_confidence(&mut self, confidence: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_CONFIDENCE, confidence, 0);
  }
  #[inline]
  pub fn add_accuracy(&mut self, accuracy: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_ACCURACY, accuracy, 0);
  }
  #[inline]
  pub fn add_clarity(&mut self, clarity: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_CLARITY, clarity, 0);
  }
  #[inline]
  pub fn add_cameoCode(&mut self, cameoCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_CAMEOCODE, cameoCode);
  }
  #[inline]
  pub fn add_cameoBaseCode(&mut self, cameoBaseCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_CAMEOBASECODE, cameoBaseCode);
  }
  #[inline]
  pub fn add_cameoRootCode(&mut self, cameoRootCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_CAMEOROOTCODE, cameoRootCode);
  }
  #[inline]
  pub fn add_goldstein(&mut self, goldstein: f64) {
    self.fbb_.push_slot::<f64>(SigAct_Abridged::VT_GOLDSTEIN, goldstein, 0.0);
  }
  #[inline]
  pub fn add_documentSource(&mut self, documentSource: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_DOCUMENTSOURCE, documentSource);
  }
  #[inline]
  pub fn add_documentFilename(&mut self, documentFilename: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_DOCUMENTFILENAME, documentFilename);
  }
  #[inline]
  pub fn add_hasAttachment(&mut self, hasAttachment: bool) {
    self.fbb_.push_slot::<bool>(SigAct_Abridged::VT_HASATTACHMENT, hasAttachment, false);
  }
  #[inline]
  pub fn add_filesize(&mut self, filesize: i64) {
    self.fbb_.push_slot::<i64>(SigAct_Abridged::VT_FILESIZE, filesize, 0);
  }
  #[inline]
  pub fn add_checksumValue(&mut self, checksumValue: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_CHECKSUMVALUE, checksumValue);
  }
  #[inline]
  pub fn add_repUnit(&mut self, repUnit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_REPUNIT, repUnit);
  }
  #[inline]
  pub fn add_repUnitType(&mut self, repUnitType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_REPUNITTYPE, repUnitType);
  }
  #[inline]
  pub fn add_repUnitActivity(&mut self, repUnitActivity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_REPUNITACTIVITY, repUnitActivity);
  }
  #[inline]
  pub fn add_numMentions(&mut self, numMentions: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_NUMMENTIONS, numMentions, 0);
  }
  #[inline]
  pub fn add_numSources(&mut self, numSources: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_NUMSOURCES, numSources, 0);
  }
  #[inline]
  pub fn add_numArticles(&mut self, numArticles: i32) {
    self.fbb_.push_slot::<i32>(SigAct_Abridged::VT_NUMARTICLES, numArticles, 0);
  }
  #[inline]
  pub fn add_avgTone(&mut self, avgTone: f64) {
    self.fbb_.push_slot::<f64>(SigAct_Abridged::VT_AVGTONE, avgTone, 0.0);
  }
  #[inline]
  pub fn add_sourceUrl(&mut self, sourceUrl: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_SOURCEURL, sourceUrl);
  }
  #[inline]
  pub fn add_relatedDocs(&mut self, relatedDocs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_RELATEDDOCS, relatedDocs);
  }
  #[inline]
  pub fn add_summary(&mut self, summary: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_SUMMARY, summary);
  }
  #[inline]
  pub fn add_notes(&mut self, notes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_NOTES, notes);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: SigAct_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<SigAct_Abridged_dataMode_Enum>(SigAct_Abridged::VT_DATAMODE, dataMode, SigAct_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SigAct_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SigAct_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SigAct_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SigAct_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SigAct_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SigAct_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("sourceLanguage", &self.sourceLanguage());
      ds.field("countryCode", &self.countryCode());
      ds.field("city", &self.city());
      ds.field("district", &self.district());
      ds.field("province", &self.province());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("milgrid", &self.milgrid());
      ds.field("theater", &self.theater());
      ds.field("atext", &self.atext());
      ds.field("agjson", &self.agjson());
      ds.field("atype", &self.atype());
      ds.field("andims", &self.andims());
      ds.field("asrid", &self.asrid());
      ds.field("eventStart", &self.eventStart());
      ds.field("eventEnd", &self.eventEnd());
      ds.field("reportDate", &self.reportDate());
      ds.field("actors", &self.actors());
      ds.field("civAbd", &self.civAbd());
      ds.field("civDet", &self.civDet());
      ds.field("civKIA", &self.civKIA());
      ds.field("civWound", &self.civWound());
      ds.field("coalAbd", &self.coalAbd());
      ds.field("coalDet", &self.coalDet());
      ds.field("coalKIA", &self.coalKIA());
      ds.field("coalWound", &self.coalWound());
      ds.field("enemyAbd", &self.enemyAbd());
      ds.field("enemyDet", &self.enemyDet());
      ds.field("enemyKIA", &self.enemyKIA());
      ds.field("friendlyAbd", &self.friendlyAbd());
      ds.field("friendlyDet", &self.friendlyDet());
      ds.field("friendlyKIA", &self.friendlyKIA());
      ds.field("friendlyWound", &self.friendlyWound());
      ds.field("hostNatAbd", &self.hostNatAbd());
      ds.field("hostNatDet", &self.hostNatDet());
      ds.field("hostNatKIA", &self.hostNatKIA());
      ds.field("hostNatWound", &self.hostNatWound());
      ds.field("sideAAbd", &self.sideAAbd());
      ds.field("sideADet", &self.sideADet());
      ds.field("sideAKIA", &self.sideAKIA());
      ds.field("sideAWound", &self.sideAWound());
      ds.field("sideBAbd", &self.sideBAbd());
      ds.field("sideBDet", &self.sideBDet());
      ds.field("sideBKIA", &self.sideBKIA());
      ds.field("sideBWound", &self.sideBWound());
      ds.field("target", &self.target());
      ds.field("eventDescription", &self.eventDescription());
      ds.field("eventType", &self.eventType());
      ds.field("typeOfAttack", &self.typeOfAttack());
      ds.field("complexAttack", &self.complexAttack());
      ds.field("idNumber", &self.idNumber());
      ds.field("confidence", &self.confidence());
      ds.field("accuracy", &self.accuracy());
      ds.field("clarity", &self.clarity());
      ds.field("cameoCode", &self.cameoCode());
      ds.field("cameoBaseCode", &self.cameoBaseCode());
      ds.field("cameoRootCode", &self.cameoRootCode());
      ds.field("goldstein", &self.goldstein());
      ds.field("documentSource", &self.documentSource());
      ds.field("documentFilename", &self.documentFilename());
      ds.field("hasAttachment", &self.hasAttachment());
      ds.field("filesize", &self.filesize());
      ds.field("checksumValue", &self.checksumValue());
      ds.field("repUnit", &self.repUnit());
      ds.field("repUnitType", &self.repUnitType());
      ds.field("repUnitActivity", &self.repUnitActivity());
      ds.field("numMentions", &self.numMentions());
      ds.field("numSources", &self.numSources());
      ds.field("numArticles", &self.numArticles());
      ds.field("avgTone", &self.avgTone());
      ds.field("sourceUrl", &self.sourceUrl());
      ds.field("relatedDocs", &self.relatedDocs());
      ds.field("summary", &self.summary());
      ds.field("notes", &self.notes());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SigAct_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub sourceLanguage: Option<String>,
  pub countryCode: Option<String>,
  pub city: Option<String>,
  pub district: Option<String>,
  pub province: Option<String>,
  pub lat: f64,
  pub lon: f64,
  pub milgrid: Option<String>,
  pub theater: Option<String>,
  pub atext: Option<String>,
  pub agjson: Option<String>,
  pub atype: Option<String>,
  pub andims: i32,
  pub asrid: i32,
  pub eventStart: Option<String>,
  pub eventEnd: Option<String>,
  pub reportDate: Option<String>,
  pub actors: Option<Vec<String>>,
  pub civAbd: i32,
  pub civDet: i32,
  pub civKIA: i32,
  pub civWound: i32,
  pub coalAbd: i32,
  pub coalDet: i32,
  pub coalKIA: i32,
  pub coalWound: i32,
  pub enemyAbd: i32,
  pub enemyDet: i32,
  pub enemyKIA: i32,
  pub friendlyAbd: i32,
  pub friendlyDet: i32,
  pub friendlyKIA: i32,
  pub friendlyWound: i32,
  pub hostNatAbd: i32,
  pub hostNatDet: i32,
  pub hostNatKIA: i32,
  pub hostNatWound: i32,
  pub sideAAbd: i32,
  pub sideADet: i32,
  pub sideAKIA: i32,
  pub sideAWound: i32,
  pub sideBAbd: i32,
  pub sideBDet: i32,
  pub sideBKIA: i32,
  pub sideBWound: i32,
  pub target: Option<String>,
  pub eventDescription: Option<String>,
  pub eventType: Option<String>,
  pub typeOfAttack: Option<String>,
  pub complexAttack: bool,
  pub idNumber: Option<String>,
  pub confidence: i32,
  pub accuracy: i32,
  pub clarity: i32,
  pub cameoCode: Option<String>,
  pub cameoBaseCode: Option<String>,
  pub cameoRootCode: Option<String>,
  pub goldstein: f64,
  pub documentSource: Option<String>,
  pub documentFilename: Option<String>,
  pub hasAttachment: bool,
  pub filesize: i64,
  pub checksumValue: Option<String>,
  pub repUnit: Option<String>,
  pub repUnitType: Option<String>,
  pub repUnitActivity: Option<String>,
  pub numMentions: i32,
  pub numSources: i32,
  pub numArticles: i32,
  pub avgTone: f64,
  pub sourceUrl: Option<String>,
  pub relatedDocs: Option<Vec<String>>,
  pub summary: Option<String>,
  pub notes: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: SigAct_Abridged_dataMode_Enum,
  pub origNetwork: Option<String>,
}
impl Default for SigAct_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      sourceLanguage: None,
      countryCode: None,
      city: None,
      district: None,
      province: None,
      lat: 0.0,
      lon: 0.0,
      milgrid: None,
      theater: None,
      atext: None,
      agjson: None,
      atype: None,
      andims: 0,
      asrid: 0,
      eventStart: None,
      eventEnd: None,
      reportDate: None,
      actors: None,
      civAbd: 0,
      civDet: 0,
      civKIA: 0,
      civWound: 0,
      coalAbd: 0,
      coalDet: 0,
      coalKIA: 0,
      coalWound: 0,
      enemyAbd: 0,
      enemyDet: 0,
      enemyKIA: 0,
      friendlyAbd: 0,
      friendlyDet: 0,
      friendlyKIA: 0,
      friendlyWound: 0,
      hostNatAbd: 0,
      hostNatDet: 0,
      hostNatKIA: 0,
      hostNatWound: 0,
      sideAAbd: 0,
      sideADet: 0,
      sideAKIA: 0,
      sideAWound: 0,
      sideBAbd: 0,
      sideBDet: 0,
      sideBKIA: 0,
      sideBWound: 0,
      target: None,
      eventDescription: None,
      eventType: None,
      typeOfAttack: None,
      complexAttack: false,
      idNumber: None,
      confidence: 0,
      accuracy: 0,
      clarity: 0,
      cameoCode: None,
      cameoBaseCode: None,
      cameoRootCode: None,
      goldstein: 0.0,
      documentSource: None,
      documentFilename: None,
      hasAttachment: false,
      filesize: 0,
      checksumValue: None,
      repUnit: None,
      repUnitType: None,
      repUnitActivity: None,
      numMentions: 0,
      numSources: 0,
      numArticles: 0,
      avgTone: 0.0,
      sourceUrl: None,
      relatedDocs: None,
      summary: None,
      notes: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: SigAct_Abridged_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}
impl SigAct_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SigAct_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceLanguage = self.sourceLanguage.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let countryCode = self.countryCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let city = self.city.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let district = self.district.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let province = self.province.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lat = self.lat;
    let lon = self.lon;
    let milgrid = self.milgrid.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let theater = self.theater.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let atext = self.atext.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let agjson = self.agjson.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let atype = self.atype.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let andims = self.andims;
    let asrid = self.asrid;
    let eventStart = self.eventStart.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eventEnd = self.eventEnd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reportDate = self.reportDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let actors = self.actors.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let civAbd = self.civAbd;
    let civDet = self.civDet;
    let civKIA = self.civKIA;
    let civWound = self.civWound;
    let coalAbd = self.coalAbd;
    let coalDet = self.coalDet;
    let coalKIA = self.coalKIA;
    let coalWound = self.coalWound;
    let enemyAbd = self.enemyAbd;
    let enemyDet = self.enemyDet;
    let enemyKIA = self.enemyKIA;
    let friendlyAbd = self.friendlyAbd;
    let friendlyDet = self.friendlyDet;
    let friendlyKIA = self.friendlyKIA;
    let friendlyWound = self.friendlyWound;
    let hostNatAbd = self.hostNatAbd;
    let hostNatDet = self.hostNatDet;
    let hostNatKIA = self.hostNatKIA;
    let hostNatWound = self.hostNatWound;
    let sideAAbd = self.sideAAbd;
    let sideADet = self.sideADet;
    let sideAKIA = self.sideAKIA;
    let sideAWound = self.sideAWound;
    let sideBAbd = self.sideBAbd;
    let sideBDet = self.sideBDet;
    let sideBKIA = self.sideBKIA;
    let sideBWound = self.sideBWound;
    let target = self.target.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eventDescription = self.eventDescription.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eventType = self.eventType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let typeOfAttack = self.typeOfAttack.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let complexAttack = self.complexAttack;
    let idNumber = self.idNumber.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let confidence = self.confidence;
    let accuracy = self.accuracy;
    let clarity = self.clarity;
    let cameoCode = self.cameoCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cameoBaseCode = self.cameoBaseCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cameoRootCode = self.cameoRootCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let goldstein = self.goldstein;
    let documentSource = self.documentSource.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let documentFilename = self.documentFilename.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let hasAttachment = self.hasAttachment;
    let filesize = self.filesize;
    let checksumValue = self.checksumValue.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let repUnit = self.repUnit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let repUnitType = self.repUnitType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let repUnitActivity = self.repUnitActivity.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let numMentions = self.numMentions;
    let numSources = self.numSources;
    let numArticles = self.numArticles;
    let avgTone = self.avgTone;
    let sourceUrl = self.sourceUrl.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let relatedDocs = self.relatedDocs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let summary = self.summary.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let notes = self.notes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    SigAct_Abridged::create(_fbb, &SigAct_AbridgedArgs{
      id,
      classificationMarking,
      sourceLanguage,
      countryCode,
      city,
      district,
      province,
      lat,
      lon,
      milgrid,
      theater,
      atext,
      agjson,
      atype,
      andims,
      asrid,
      eventStart,
      eventEnd,
      reportDate,
      actors,
      civAbd,
      civDet,
      civKIA,
      civWound,
      coalAbd,
      coalDet,
      coalKIA,
      coalWound,
      enemyAbd,
      enemyDet,
      enemyKIA,
      friendlyAbd,
      friendlyDet,
      friendlyKIA,
      friendlyWound,
      hostNatAbd,
      hostNatDet,
      hostNatKIA,
      hostNatWound,
      sideAAbd,
      sideADet,
      sideAKIA,
      sideAWound,
      sideBAbd,
      sideBDet,
      sideBKIA,
      sideBWound,
      target,
      eventDescription,
      eventType,
      typeOfAttack,
      complexAttack,
      idNumber,
      confidence,
      accuracy,
      clarity,
      cameoCode,
      cameoBaseCode,
      cameoRootCode,
      goldstein,
      documentSource,
      documentFilename,
      hasAttachment,
      filesize,
      checksumValue,
      repUnit,
      repUnitType,
      repUnitActivity,
      numMentions,
      numSources,
      numArticles,
      avgTone,
      sourceUrl,
      relatedDocs,
      summary,
      notes,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SigAct_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sig_act_abridged_unchecked`.
pub fn root_as_sig_act_abridged(buf: &[u8]) -> Result<SigAct_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SigAct_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SigAct_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_sig_act_abridged_unchecked`.
pub fn size_prefixed_root_as_sig_act_abridged(buf: &[u8]) -> Result<SigAct_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SigAct_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SigAct_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sig_act_abridged_unchecked`.
pub fn root_as_sig_act_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SigAct_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SigAct_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SigAct_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sig_act_abridged_unchecked`.
pub fn size_prefixed_root_as_sig_act_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SigAct_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SigAct_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SigAct_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SigAct_Abridged`.
pub unsafe fn root_as_sig_act_abridged_unchecked(buf: &[u8]) -> SigAct_Abridged {
  flatbuffers::root_unchecked::<SigAct_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SigAct_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SigAct_Abridged`.
pub unsafe fn size_prefixed_root_as_sig_act_abridged_unchecked(buf: &[u8]) -> SigAct_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<SigAct_Abridged>(buf)
}
pub const SIG_ACT_ABRIDGED_IDENTIFIER: &str = "SIGA";

#[inline]
pub fn sig_act_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SIG_ACT_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn sig_act_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SIG_ACT_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_sig_act_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<SigAct_Abridged<'a>>) {
  fbb.finish(root, Some(SIG_ACT_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_sig_act_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<SigAct_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(SIG_ACT_ABRIDGED_IDENTIFIER));
}
