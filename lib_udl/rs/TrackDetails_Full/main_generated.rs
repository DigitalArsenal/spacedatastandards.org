// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TRACK_DETAILS_FULL_ENV_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TRACK_DETAILS_FULL_ENV_ENUM: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRACK_DETAILS_FULL_ENV_ENUM: [TrackDetails_Full_env_Enum; 6] = [
  TrackDetails_Full_env_Enum::AIR,
  TrackDetails_Full_env_Enum::LAND,
  TrackDetails_Full_env_Enum::SPACE,
  TrackDetails_Full_env_Enum::SURFACE,
  TrackDetails_Full_env_Enum::SUBSURFACE,
  TrackDetails_Full_env_Enum::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TrackDetails_Full_env_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl TrackDetails_Full_env_Enum {
  /// Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
  pub const AIR: Self = Self(0);
  /// On the surface of dry land.
  pub const LAND: Self = Self(1);
  /// Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
  pub const SPACE: Self = Self(2);
  /// On the surface of a body of water.
  pub const SURFACE: Self = Self(3);
  /// Below the surface of a body of water.
  pub const SUBSURFACE: Self = Self(4);
  /// Environment is not known.
  pub const UNKNOWN: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AIR,
    Self::LAND,
    Self::SPACE,
    Self::SURFACE,
    Self::SUBSURFACE,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AIR => Some("AIR"),
      Self::LAND => Some("LAND"),
      Self::SPACE => Some("SPACE"),
      Self::SURFACE => Some("SURFACE"),
      Self::SUBSURFACE => Some("SUBSURFACE"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TrackDetails_Full_env_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TrackDetails_Full_env_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TrackDetails_Full_env_Enum {
    type Output = TrackDetails_Full_env_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TrackDetails_Full_env_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TrackDetails_Full_env_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TrackDetails_Full_env_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TRACK_DETAILS_FULL_OBJ_IDENT_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TRACK_DETAILS_FULL_OBJ_IDENT_ENUM: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRACK_DETAILS_FULL_OBJ_IDENT_ENUM: [TrackDetails_Full_objIdent_Enum; 7] = [
  TrackDetails_Full_objIdent_Enum::ASSUMED_FRIEND,
  TrackDetails_Full_objIdent_Enum::FRIEND,
  TrackDetails_Full_objIdent_Enum::HOSTILE,
  TrackDetails_Full_objIdent_Enum::NEUTRAL,
  TrackDetails_Full_objIdent_Enum::PENDING,
  TrackDetails_Full_objIdent_Enum::SUSPECT,
  TrackDetails_Full_objIdent_Enum::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TrackDetails_Full_objIdent_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl TrackDetails_Full_objIdent_Enum {
  /// Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  pub const ASSUMED_FRIEND: Self = Self(0);
  /// Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  pub const FRIEND: Self = Self(1);
  /// Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  pub const HOSTILE: Self = Self(2);
  /// Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  pub const NEUTRAL: Self = Self(3);
  /// Track object which has not been evaluated.
  pub const PENDING: Self = Self(4);
  /// Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  pub const SUSPECT: Self = Self(5);
  /// Track object which has been evaluated and does not meet criteria for any standard identity.
  pub const UNKNOWN: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ASSUMED_FRIEND,
    Self::FRIEND,
    Self::HOSTILE,
    Self::NEUTRAL,
    Self::PENDING,
    Self::SUSPECT,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ASSUMED_FRIEND => Some("ASSUMED_FRIEND"),
      Self::FRIEND => Some("FRIEND"),
      Self::HOSTILE => Some("HOSTILE"),
      Self::NEUTRAL => Some("NEUTRAL"),
      Self::PENDING => Some("PENDING"),
      Self::SUSPECT => Some("SUSPECT"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TrackDetails_Full_objIdent_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TrackDetails_Full_objIdent_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TrackDetails_Full_objIdent_Enum {
    type Output = TrackDetails_Full_objIdent_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TrackDetails_Full_objIdent_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TrackDetails_Full_objIdent_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TrackDetails_Full_objIdent_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TRACK_DETAILS_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TRACK_DETAILS_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRACK_DETAILS_FULL_DATA_MODE_ENUM: [TrackDetails_Full_dataMode_Enum; 4] = [
  TrackDetails_Full_dataMode_Enum::REAL,
  TrackDetails_Full_dataMode_Enum::TEST,
  TrackDetails_Full_dataMode_Enum::SIMULATED,
  TrackDetails_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TrackDetails_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl TrackDetails_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TrackDetails_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TrackDetails_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TrackDetails_Full_dataMode_Enum {
    type Output = TrackDetails_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TrackDetails_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TrackDetails_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TrackDetails_Full_dataMode_Enum {}
pub enum TrackDetails_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// These services provide operations for querying of all available track details and amplifying track data. A track is a position and optionally a heading/velocity of an object such as an aircraft, marine vessel, etc at a particular timestamp. It also includes optional information regarding the identity/type of the target object and other amplifying object data, if known.
pub struct TrackDetails_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TrackDetails_Full<'a> {
  type Inner = TrackDetails_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TrackDetails_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_ENV: flatbuffers::VOffsetT = 8;
  pub const VT_MSGTYPE: flatbuffers::VOffsetT = 10;
  pub const VT_HULLNUM: flatbuffers::VOffsetT = 12;
  pub const VT_PIF: flatbuffers::VOffsetT = 14;
  pub const VT_SCONUM: flatbuffers::VOffsetT = 16;
  pub const VT_NTDS: flatbuffers::VOffsetT = 18;
  pub const VT_DISID: flatbuffers::VOffsetT = 20;
  pub const VT_MIDBCAT: flatbuffers::VOffsetT = 22;
  pub const VT_BENUMBER: flatbuffers::VOffsetT = 24;
  pub const VT_OSUFFIX: flatbuffers::VOffsetT = 26;
  pub const VT_PIN: flatbuffers::VOffsetT = 28;
  pub const VT_LOSTTRKIND: flatbuffers::VOffsetT = 30;
  pub const VT_MUIDSRCTRK: flatbuffers::VOffsetT = 32;
  pub const VT_MUIDSRC: flatbuffers::VOffsetT = 34;
  pub const VT_MSLSTATUS: flatbuffers::VOffsetT = 36;
  pub const VT_TRKCONF: flatbuffers::VOffsetT = 38;
  pub const VT_TRKQUAL: flatbuffers::VOffsetT = 40;
  pub const VT_ALERT: flatbuffers::VOffsetT = 42;
  pub const VT_ORIGXREF: flatbuffers::VOffsetT = 44;
  pub const VT_ELNOT1: flatbuffers::VOffsetT = 46;
  pub const VT_ELNOT2: flatbuffers::VOffsetT = 48;
  pub const VT_OBJIDENT: flatbuffers::VOffsetT = 50;
  pub const VT_OBJTYPE: flatbuffers::VOffsetT = 52;
  pub const VT_OBJPLAT: flatbuffers::VOffsetT = 54;
  pub const VT_OBJACT: flatbuffers::VOffsetT = 56;
  pub const VT_OBJNAT: flatbuffers::VOffsetT = 58;
  pub const VT_NAME: flatbuffers::VOffsetT = 60;
  pub const VT_SHORTNAME: flatbuffers::VOffsetT = 62;
  pub const VT_TRKID: flatbuffers::VOffsetT = 64;
  pub const VT_TRKNUM: flatbuffers::VOffsetT = 66;
  pub const VT_TRKSCOPE: flatbuffers::VOffsetT = 68;
  pub const VT_SOURCEUID: flatbuffers::VOffsetT = 70;
  pub const VT_CALLSIGN: flatbuffers::VOffsetT = 72;
  pub const VT_IDENTAMP: flatbuffers::VOffsetT = 74;
  pub const VT_SPACEAMP: flatbuffers::VOffsetT = 76;
  pub const VT_SPACEAMPCONF: flatbuffers::VOffsetT = 78;
  pub const VT_SPACESPECTYPE: flatbuffers::VOffsetT = 80;
  pub const VT_ACFTSUBTYPE: flatbuffers::VOffsetT = 82;
  pub const VT_TS: flatbuffers::VOffsetT = 84;
  pub const VT_LAUNCHTIME: flatbuffers::VOffsetT = 86;
  pub const VT_IMPACTTIME: flatbuffers::VOffsetT = 88;
  pub const VT_FTNMSGTS: flatbuffers::VOffsetT = 90;
  pub const VT_FTN: flatbuffers::VOffsetT = 92;
  pub const VT_FTNCMD: flatbuffers::VOffsetT = 94;
  pub const VT_RTNMSGTS: flatbuffers::VOffsetT = 96;
  pub const VT_RTN: flatbuffers::VOffsetT = 98;
  pub const VT_RTNTRKSTATE: flatbuffers::VOffsetT = 100;
  pub const VT_RTNCMD: flatbuffers::VOffsetT = 102;
  pub const VT_SEN: flatbuffers::VOffsetT = 104;
  pub const VT_RPTCHXREF: flatbuffers::VOffsetT = 106;
  pub const VT_RPTARCHIVED: flatbuffers::VOffsetT = 108;
  pub const VT_SELFREPORT: flatbuffers::VOffsetT = 110;
  pub const VT_MIL2525BSTR: flatbuffers::VOffsetT = 112;
  pub const VT_TRNSPDRID: flatbuffers::VOffsetT = 114;
  pub const VT_TRNSPDRTYPE: flatbuffers::VOffsetT = 116;
  pub const VT_EMITTERNAME: flatbuffers::VOffsetT = 118;
  pub const VT_INFOSOURCE: flatbuffers::VOffsetT = 120;
  pub const VT_BOOSTING: flatbuffers::VOffsetT = 122;
  pub const VT_FREQ: flatbuffers::VOffsetT = 124;
  pub const VT_MAXFREQ: flatbuffers::VOffsetT = 126;
  pub const VT_HARMONICS: flatbuffers::VOffsetT = 128;
  pub const VT_PRI: flatbuffers::VOffsetT = 130;
  pub const VT_PRF: flatbuffers::VOffsetT = 132;
  pub const VT_PW: flatbuffers::VOffsetT = 134;
  pub const VT_SCANTYPE: flatbuffers::VOffsetT = 136;
  pub const VT_SCANRATE: flatbuffers::VOffsetT = 138;
  pub const VT_SCN: flatbuffers::VOffsetT = 140;
  pub const VT_CI: flatbuffers::VOffsetT = 142;
  pub const VT_ANGELEV: flatbuffers::VOffsetT = 144;
  pub const VT_LAT: flatbuffers::VOffsetT = 146;
  pub const VT_LON: flatbuffers::VOffsetT = 148;
  pub const VT_LAUNCHLAT: flatbuffers::VOffsetT = 150;
  pub const VT_LAUNCHLON: flatbuffers::VOffsetT = 152;
  pub const VT_IMPACTLAT: flatbuffers::VOffsetT = 154;
  pub const VT_IMPACTLON: flatbuffers::VOffsetT = 156;
  pub const VT_POLARSINGLOCLAT: flatbuffers::VOffsetT = 158;
  pub const VT_POLARSINGLOCLON: flatbuffers::VOffsetT = 160;
  pub const VT_AZCORRCENTERLINE: flatbuffers::VOffsetT = 162;
  pub const VT_AZCORRARCWIDTH: flatbuffers::VOffsetT = 164;
  pub const VT_ERRSEMIINTAXIS: flatbuffers::VOffsetT = 166;
  pub const VT_ERRAREAORIENT: flatbuffers::VOffsetT = 168;
  pub const VT_ERRSEMIMAJELEV: flatbuffers::VOffsetT = 170;
  pub const VT_ERRGEOAREASWITCH: flatbuffers::VOffsetT = 172;
  pub const VT_BURNOUTALT: flatbuffers::VOffsetT = 174;
  pub const VT_TESEVENTID: flatbuffers::VOffsetT = 176;
  pub const VT_SPD: flatbuffers::VOffsetT = 178;
  pub const VT_AVGSPD: flatbuffers::VOffsetT = 180;
  pub const VT_TOL: flatbuffers::VOffsetT = 182;
  pub const VT_ALT: flatbuffers::VOffsetT = 184;
  pub const VT_HDNG: flatbuffers::VOffsetT = 186;
  pub const VT_COURSE: flatbuffers::VOffsetT = 188;
  pub const VT_PROPRPM: flatbuffers::VOffsetT = 190;
  pub const VT_TPK: flatbuffers::VOffsetT = 192;
  pub const VT_COOPLOCIND: flatbuffers::VOffsetT = 194;
  pub const VT_MANEUVERIND: flatbuffers::VOffsetT = 196;
  pub const VT_LAUNCHAOUTYPE: flatbuffers::VOffsetT = 198;
  pub const VT_LAUNCHAOUDATA: flatbuffers::VOffsetT = 200;
  pub const VT_IMPACTAOUTYPE: flatbuffers::VOffsetT = 202;
  pub const VT_IMPACTAOUDATA: flatbuffers::VOffsetT = 204;
  pub const VT_AOURPTTYPE: flatbuffers::VOffsetT = 206;
  pub const VT_AOURPTDATA: flatbuffers::VOffsetT = 208;
  pub const VT_ECEFPOS: flatbuffers::VOffsetT = 210;
  pub const VT_ECEFVEL: flatbuffers::VOffsetT = 212;
  pub const VT_CONTAINMENT: flatbuffers::VOffsetT = 214;
  pub const VT_CPA: flatbuffers::VOffsetT = 216;
  pub const VT_TCPA: flatbuffers::VOffsetT = 218;
  pub const VT_NAVSTATUS: flatbuffers::VOffsetT = 220;
  pub const VT_POSDEVICETYPE: flatbuffers::VOffsetT = 222;
  pub const VT_ATON: flatbuffers::VOffsetT = 224;
  pub const VT_OFFPOSIND: flatbuffers::VOffsetT = 226;
  pub const VT_ANTENNAREFDIMENSIONS: flatbuffers::VOffsetT = 228;
  pub const VT_SHIPCLASS: flatbuffers::VOffsetT = 230;
  pub const VT_IMON: flatbuffers::VOffsetT = 232;
  pub const VT_MMSI: flatbuffers::VOffsetT = 234;
  pub const VT_DRAUGHT: flatbuffers::VOffsetT = 236;
  pub const VT_LENGTH: flatbuffers::VOffsetT = 238;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 240;
  pub const VT_CARGOTYPE: flatbuffers::VOffsetT = 242;
  pub const VT_APPGRP: flatbuffers::VOffsetT = 244;
  pub const VT_HULLPROF: flatbuffers::VOffsetT = 246;
  pub const VT_PROPTYPE: flatbuffers::VOffsetT = 248;
  pub const VT_NUMBLADES: flatbuffers::VOffsetT = 250;
  pub const VT_NUMSHAFTS: flatbuffers::VOffsetT = 252;
  pub const VT_STERNTYPE: flatbuffers::VOffsetT = 254;
  pub const VT_VSLWT: flatbuffers::VOffsetT = 256;
  pub const VT_ARRTIME: flatbuffers::VOffsetT = 258;
  pub const VT_ARRFLAG: flatbuffers::VOffsetT = 260;
  pub const VT_ARRCARGO: flatbuffers::VOffsetT = 262;
  pub const VT_ARRPORT: flatbuffers::VOffsetT = 264;
  pub const VT_DEPPORT: flatbuffers::VOffsetT = 266;
  pub const VT_DEPFLAG: flatbuffers::VOffsetT = 268;
  pub const VT_DEPCARGO: flatbuffers::VOffsetT = 270;
  pub const VT_DESFLAG: flatbuffers::VOffsetT = 272;
  pub const VT_DESCARGO: flatbuffers::VOffsetT = 274;
  pub const VT_DESTINATION: flatbuffers::VOffsetT = 276;
  pub const VT_ETA: flatbuffers::VOffsetT = 278;
  pub const VT_ETD: flatbuffers::VOffsetT = 280;
  pub const VT_IFF: flatbuffers::VOffsetT = 282;
  pub const VT_EMGIND: flatbuffers::VOffsetT = 284;
  pub const VT_DROPPTIND: flatbuffers::VOffsetT = 286;
  pub const VT_REINFORCED: flatbuffers::VOffsetT = 288;
  pub const VT_REDUCED: flatbuffers::VOffsetT = 290;
  pub const VT_HQ: flatbuffers::VOffsetT = 292;
  pub const VT_DUMMY: flatbuffers::VOffsetT = 294;
  pub const VT_TASKFORCE: flatbuffers::VOffsetT = 296;
  pub const VT_FEINT: flatbuffers::VOffsetT = 298;
  pub const VT_INSTALLATION: flatbuffers::VOffsetT = 300;
  pub const VT_STAFFCMTS: flatbuffers::VOffsetT = 302;
  pub const VT_ADDINFO: flatbuffers::VOffsetT = 304;
  pub const VT_EVALRATING: flatbuffers::VOffsetT = 306;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 308;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 310;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 312;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 314;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 316;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 318;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TrackDetails_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TrackDetails_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<TrackDetails_Full<'bldr>> {
    let mut builder = TrackDetails_FullBuilder::new(_fbb);
    builder.add_vslWt(args.vslWt);
    builder.add_width(args.width);
    builder.add_length(args.length);
    builder.add_draught(args.draught);
    builder.add_cpa(args.cpa);
    builder.add_containment(args.containment);
    builder.add_tpk(args.tpk);
    builder.add_propRPM(args.propRPM);
    builder.add_course(args.course);
    builder.add_hdng(args.hdng);
    builder.add_alt(args.alt);
    builder.add_tol(args.tol);
    builder.add_avgSpd(args.avgSpd);
    builder.add_spd(args.spd);
    builder.add_burnoutAlt(args.burnoutAlt);
    builder.add_errSemiMajElev(args.errSemiMajElev);
    builder.add_errAreaOrient(args.errAreaOrient);
    builder.add_errSemiIntAxis(args.errSemiIntAxis);
    builder.add_azCorrArcWidth(args.azCorrArcWidth);
    builder.add_azCorrCenterLine(args.azCorrCenterLine);
    builder.add_polarSingLocLon(args.polarSingLocLon);
    builder.add_polarSingLocLat(args.polarSingLocLat);
    builder.add_impactLon(args.impactLon);
    builder.add_impactLat(args.impactLat);
    builder.add_launchLon(args.launchLon);
    builder.add_launchLat(args.launchLat);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    builder.add_angElev(args.angElev);
    builder.add_scanRate(args.scanRate);
    builder.add_pw(args.pw);
    builder.add_prf(args.prf);
    builder.add_pri(args.pri);
    builder.add_maxFreq(args.maxFreq);
    builder.add_freq(args.freq);
    builder.add_trkConf(args.trkConf);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.evalRating { builder.add_evalRating(x); }
    if let Some(x) = args.addInfo { builder.add_addInfo(x); }
    if let Some(x) = args.staffCmts { builder.add_staffCmts(x); }
    if let Some(x) = args.iff { builder.add_iff(x); }
    if let Some(x) = args.etd { builder.add_etd(x); }
    if let Some(x) = args.eta { builder.add_eta(x); }
    if let Some(x) = args.destination { builder.add_destination(x); }
    if let Some(x) = args.desCargo { builder.add_desCargo(x); }
    if let Some(x) = args.desFlag { builder.add_desFlag(x); }
    if let Some(x) = args.depCargo { builder.add_depCargo(x); }
    if let Some(x) = args.depFlag { builder.add_depFlag(x); }
    if let Some(x) = args.depPort { builder.add_depPort(x); }
    if let Some(x) = args.arrPort { builder.add_arrPort(x); }
    if let Some(x) = args.arrCargo { builder.add_arrCargo(x); }
    if let Some(x) = args.arrFlag { builder.add_arrFlag(x); }
    if let Some(x) = args.arrTime { builder.add_arrTime(x); }
    if let Some(x) = args.sternType { builder.add_sternType(x); }
    builder.add_numShafts(args.numShafts);
    builder.add_numBlades(args.numBlades);
    if let Some(x) = args.propType { builder.add_propType(x); }
    if let Some(x) = args.hullProf { builder.add_hullProf(x); }
    if let Some(x) = args.appGrp { builder.add_appGrp(x); }
    if let Some(x) = args.cargoType { builder.add_cargoType(x); }
    builder.add_mmsi(args.mmsi);
    builder.add_imon(args.imon);
    if let Some(x) = args.shipClass { builder.add_shipClass(x); }
    if let Some(x) = args.antennaRefDimensions { builder.add_antennaRefDimensions(x); }
    if let Some(x) = args.offPosInd { builder.add_offPosInd(x); }
    if let Some(x) = args.aton { builder.add_aton(x); }
    if let Some(x) = args.posDeviceType { builder.add_posDeviceType(x); }
    if let Some(x) = args.navStatus { builder.add_navStatus(x); }
    if let Some(x) = args.tcpa { builder.add_tcpa(x); }
    if let Some(x) = args.ecefVel { builder.add_ecefVel(x); }
    if let Some(x) = args.ecefPos { builder.add_ecefPos(x); }
    if let Some(x) = args.aouRptData { builder.add_aouRptData(x); }
    if let Some(x) = args.aouRptType { builder.add_aouRptType(x); }
    if let Some(x) = args.impactAouData { builder.add_impactAouData(x); }
    if let Some(x) = args.impactAouType { builder.add_impactAouType(x); }
    if let Some(x) = args.launchAouData { builder.add_launchAouData(x); }
    if let Some(x) = args.launchAouType { builder.add_launchAouType(x); }
    if let Some(x) = args.maneuverInd { builder.add_maneuverInd(x); }
    if let Some(x) = args.coopLocInd { builder.add_coopLocInd(x); }
    if let Some(x) = args.tesEventId { builder.add_tesEventId(x); }
    if let Some(x) = args.errGeoAreaSwitch { builder.add_errGeoAreaSwitch(x); }
    if let Some(x) = args.cI { builder.add_cI(x); }
    builder.add_scn(args.scn);
    if let Some(x) = args.scanType { builder.add_scanType(x); }
    if let Some(x) = args.harmonics { builder.add_harmonics(x); }
    if let Some(x) = args.infoSource { builder.add_infoSource(x); }
    if let Some(x) = args.emitterName { builder.add_emitterName(x); }
    if let Some(x) = args.trnspdrType { builder.add_trnspdrType(x); }
    if let Some(x) = args.trnspdrId { builder.add_trnspdrId(x); }
    if let Some(x) = args.mil2525Bstr { builder.add_mil2525Bstr(x); }
    if let Some(x) = args.rptChxref { builder.add_rptChxref(x); }
    if let Some(x) = args.sen { builder.add_sen(x); }
    if let Some(x) = args.rtnCmd { builder.add_rtnCmd(x); }
    if let Some(x) = args.rtnTrkState { builder.add_rtnTrkState(x); }
    if let Some(x) = args.rtn { builder.add_rtn(x); }
    if let Some(x) = args.rtnMsgTs { builder.add_rtnMsgTs(x); }
    if let Some(x) = args.ftnCmd { builder.add_ftnCmd(x); }
    if let Some(x) = args.ftn { builder.add_ftn(x); }
    if let Some(x) = args.ftnMsgTs { builder.add_ftnMsgTs(x); }
    if let Some(x) = args.impactTime { builder.add_impactTime(x); }
    if let Some(x) = args.launchTime { builder.add_launchTime(x); }
    if let Some(x) = args.ts { builder.add_ts(x); }
    if let Some(x) = args.acftSubType { builder.add_acftSubType(x); }
    if let Some(x) = args.spaceSpecType { builder.add_spaceSpecType(x); }
    builder.add_spaceAmpConf(args.spaceAmpConf);
    if let Some(x) = args.spaceAmp { builder.add_spaceAmp(x); }
    if let Some(x) = args.identAmp { builder.add_identAmp(x); }
    if let Some(x) = args.callSign { builder.add_callSign(x); }
    if let Some(x) = args.sourceUid { builder.add_sourceUid(x); }
    if let Some(x) = args.trkScope { builder.add_trkScope(x); }
    if let Some(x) = args.trkNum { builder.add_trkNum(x); }
    if let Some(x) = args.trkId { builder.add_trkId(x); }
    if let Some(x) = args.shortName { builder.add_shortName(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.objNat { builder.add_objNat(x); }
    if let Some(x) = args.objAct { builder.add_objAct(x); }
    if let Some(x) = args.objPlat { builder.add_objPlat(x); }
    if let Some(x) = args.objType { builder.add_objType(x); }
    if let Some(x) = args.elnot2 { builder.add_elnot2(x); }
    if let Some(x) = args.elnot1 { builder.add_elnot1(x); }
    if let Some(x) = args.origXref { builder.add_origXref(x); }
    if let Some(x) = args.alert { builder.add_alert(x); }
    builder.add_trkQual(args.trkQual);
    if let Some(x) = args.mslStatus { builder.add_mslStatus(x); }
    if let Some(x) = args.muidSrc { builder.add_muidSrc(x); }
    if let Some(x) = args.muidSrcTrk { builder.add_muidSrcTrk(x); }
    if let Some(x) = args.pin { builder.add_pin(x); }
    if let Some(x) = args.oSuffix { builder.add_oSuffix(x); }
    if let Some(x) = args.beNumber { builder.add_beNumber(x); }
    if let Some(x) = args.midbCat { builder.add_midbCat(x); }
    if let Some(x) = args.disId { builder.add_disId(x); }
    if let Some(x) = args.ntds { builder.add_ntds(x); }
    if let Some(x) = args.sconum { builder.add_sconum(x); }
    if let Some(x) = args.pif { builder.add_pif(x); }
    if let Some(x) = args.hullNum { builder.add_hullNum(x); }
    if let Some(x) = args.msgType { builder.add_msgType(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_installation(args.installation);
    builder.add_feint(args.feint);
    builder.add_taskForce(args.taskForce);
    builder.add_dummy(args.dummy);
    builder.add_hq(args.hq);
    builder.add_reduced(args.reduced);
    builder.add_reinforced(args.reinforced);
    builder.add_dropPtInd(args.dropPtInd);
    builder.add_emgInd(args.emgInd);
    builder.add_boosting(args.boosting);
    builder.add_selfReport(args.selfReport);
    builder.add_rptArchived(args.rptArchived);
    builder.add_objIdent(args.objIdent);
    builder.add_lostTrkInd(args.lostTrkInd);
    builder.add_env(args.env);
    builder.finish()
  }

  pub fn unpack(&self) -> TrackDetails_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let env = self.env();
    let msgType = self.msgType().map(|x| {
      x.to_string()
    });
    let hullNum = self.hullNum().map(|x| {
      x.to_string()
    });
    let pif = self.pif().map(|x| {
      x.to_string()
    });
    let sconum = self.sconum().map(|x| {
      x.to_string()
    });
    let ntds = self.ntds().map(|x| {
      x.to_string()
    });
    let disId = self.disId().map(|x| {
      x.to_string()
    });
    let midbCat = self.midbCat().map(|x| {
      x.to_string()
    });
    let beNumber = self.beNumber().map(|x| {
      x.to_string()
    });
    let oSuffix = self.oSuffix().map(|x| {
      x.to_string()
    });
    let pin = self.pin().map(|x| {
      x.to_string()
    });
    let lostTrkInd = self.lostTrkInd();
    let muidSrcTrk = self.muidSrcTrk().map(|x| {
      x.to_string()
    });
    let muidSrc = self.muidSrc().map(|x| {
      x.to_string()
    });
    let mslStatus = self.mslStatus().map(|x| {
      x.to_string()
    });
    let trkConf = self.trkConf();
    let trkQual = self.trkQual();
    let alert = self.alert().map(|x| {
      x.to_string()
    });
    let origXref = self.origXref().map(|x| {
      x.to_string()
    });
    let elnot1 = self.elnot1().map(|x| {
      x.to_string()
    });
    let elnot2 = self.elnot2().map(|x| {
      x.to_string()
    });
    let objIdent = self.objIdent();
    let objType = self.objType().map(|x| {
      x.to_string()
    });
    let objPlat = self.objPlat().map(|x| {
      x.to_string()
    });
    let objAct = self.objAct().map(|x| {
      x.to_string()
    });
    let objNat = self.objNat().map(|x| {
      x.to_string()
    });
    let name = self.name().map(|x| {
      x.to_string()
    });
    let shortName = self.shortName().map(|x| {
      x.to_string()
    });
    let trkId = self.trkId().map(|x| {
      x.to_string()
    });
    let trkNum = self.trkNum().map(|x| {
      x.to_string()
    });
    let trkScope = self.trkScope().map(|x| {
      x.to_string()
    });
    let sourceUid = self.sourceUid().map(|x| {
      x.to_string()
    });
    let callSign = self.callSign().map(|x| {
      x.to_string()
    });
    let identAmp = self.identAmp().map(|x| {
      x.to_string()
    });
    let spaceAmp = self.spaceAmp().map(|x| {
      x.to_string()
    });
    let spaceAmpConf = self.spaceAmpConf();
    let spaceSpecType = self.spaceSpecType().map(|x| {
      x.to_string()
    });
    let acftSubType = self.acftSubType().map(|x| {
      x.to_string()
    });
    let ts = self.ts().map(|x| {
      x.to_string()
    });
    let launchTime = self.launchTime().map(|x| {
      x.to_string()
    });
    let impactTime = self.impactTime().map(|x| {
      x.to_string()
    });
    let ftnMsgTs = self.ftnMsgTs().map(|x| {
      x.to_string()
    });
    let ftn = self.ftn().map(|x| {
      x.to_string()
    });
    let ftnCmd = self.ftnCmd().map(|x| {
      x.to_string()
    });
    let rtnMsgTs = self.rtnMsgTs().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let rtn = self.rtn().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let rtnTrkState = self.rtnTrkState().map(|x| {
      x.to_string()
    });
    let rtnCmd = self.rtnCmd().map(|x| {
      x.to_string()
    });
    let sen = self.sen().map(|x| {
      x.to_string()
    });
    let rptChxref = self.rptChxref().map(|x| {
      x.to_string()
    });
    let rptArchived = self.rptArchived();
    let selfReport = self.selfReport();
    let mil2525Bstr = self.mil2525Bstr().map(|x| {
      x.to_string()
    });
    let trnspdrId = self.trnspdrId().map(|x| {
      x.to_string()
    });
    let trnspdrType = self.trnspdrType().map(|x| {
      x.to_string()
    });
    let emitterName = self.emitterName().map(|x| {
      x.to_string()
    });
    let infoSource = self.infoSource().map(|x| {
      x.to_string()
    });
    let boosting = self.boosting();
    let freq = self.freq();
    let maxFreq = self.maxFreq();
    let harmonics = self.harmonics().map(|x| {
      x.to_string()
    });
    let pri = self.pri();
    let prf = self.prf();
    let pw = self.pw();
    let scanType = self.scanType().map(|x| {
      x.to_string()
    });
    let scanRate = self.scanRate();
    let scn = self.scn();
    let cI = self.cI().map(|x| {
      x.to_string()
    });
    let angElev = self.angElev();
    let lat = self.lat();
    let lon = self.lon();
    let launchLat = self.launchLat();
    let launchLon = self.launchLon();
    let impactLat = self.impactLat();
    let impactLon = self.impactLon();
    let polarSingLocLat = self.polarSingLocLat();
    let polarSingLocLon = self.polarSingLocLon();
    let azCorrCenterLine = self.azCorrCenterLine();
    let azCorrArcWidth = self.azCorrArcWidth();
    let errSemiIntAxis = self.errSemiIntAxis();
    let errAreaOrient = self.errAreaOrient();
    let errSemiMajElev = self.errSemiMajElev();
    let errGeoAreaSwitch = self.errGeoAreaSwitch().map(|x| {
      x.to_string()
    });
    let burnoutAlt = self.burnoutAlt();
    let tesEventId = self.tesEventId().map(|x| {
      x.to_string()
    });
    let spd = self.spd();
    let avgSpd = self.avgSpd();
    let tol = self.tol();
    let alt = self.alt();
    let hdng = self.hdng();
    let course = self.course();
    let propRPM = self.propRPM();
    let tpk = self.tpk();
    let coopLocInd = self.coopLocInd().map(|x| {
      x.to_string()
    });
    let maneuverInd = self.maneuverInd().map(|x| {
      x.to_string()
    });
    let launchAouType = self.launchAouType().map(|x| {
      x.to_string()
    });
    let launchAouData = self.launchAouData().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let impactAouType = self.impactAouType().map(|x| {
      x.to_string()
    });
    let impactAouData = self.impactAouData().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let aouRptType = self.aouRptType().map(|x| {
      x.to_string()
    });
    let aouRptData = self.aouRptData().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ecefPos = self.ecefPos().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ecefVel = self.ecefVel().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let containment = self.containment();
    let cpa = self.cpa();
    let tcpa = self.tcpa().map(|x| {
      x.to_string()
    });
    let navStatus = self.navStatus().map(|x| {
      x.to_string()
    });
    let posDeviceType = self.posDeviceType().map(|x| {
      x.to_string()
    });
    let aton = self.aton().map(|x| {
      x.to_string()
    });
    let offPosInd = self.offPosInd().map(|x| {
      x.to_string()
    });
    let antennaRefDimensions = self.antennaRefDimensions().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let shipClass = self.shipClass().map(|x| {
      x.to_string()
    });
    let imon = self.imon();
    let mmsi = self.mmsi();
    let draught = self.draught();
    let length = self.length();
    let width = self.width();
    let cargoType = self.cargoType().map(|x| {
      x.to_string()
    });
    let appGrp = self.appGrp().map(|x| {
      x.to_string()
    });
    let hullProf = self.hullProf().map(|x| {
      x.to_string()
    });
    let propType = self.propType().map(|x| {
      x.to_string()
    });
    let numBlades = self.numBlades();
    let numShafts = self.numShafts();
    let sternType = self.sternType().map(|x| {
      x.to_string()
    });
    let vslWt = self.vslWt();
    let arrTime = self.arrTime().map(|x| {
      x.to_string()
    });
    let arrFlag = self.arrFlag().map(|x| {
      x.to_string()
    });
    let arrCargo = self.arrCargo().map(|x| {
      x.to_string()
    });
    let arrPort = self.arrPort().map(|x| {
      x.to_string()
    });
    let depPort = self.depPort().map(|x| {
      x.to_string()
    });
    let depFlag = self.depFlag().map(|x| {
      x.to_string()
    });
    let depCargo = self.depCargo().map(|x| {
      x.to_string()
    });
    let desFlag = self.desFlag().map(|x| {
      x.to_string()
    });
    let desCargo = self.desCargo().map(|x| {
      x.to_string()
    });
    let destination = self.destination().map(|x| {
      x.to_string()
    });
    let eta = self.eta().map(|x| {
      x.to_string()
    });
    let etd = self.etd().map(|x| {
      x.to_string()
    });
    let iff = self.iff().map(|x| {
      x.to_string()
    });
    let emgInd = self.emgInd();
    let dropPtInd = self.dropPtInd();
    let reinforced = self.reinforced();
    let reduced = self.reduced();
    let hq = self.hq();
    let dummy = self.dummy();
    let taskForce = self.taskForce();
    let feint = self.feint();
    let installation = self.installation();
    let staffCmts = self.staffCmts().map(|x| {
      x.to_string()
    });
    let addInfo = self.addInfo().map(|x| {
      x.to_string()
    });
    let evalRating = self.evalRating().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    TrackDetails_FullT {
      id,
      classificationMarking,
      env,
      msgType,
      hullNum,
      pif,
      sconum,
      ntds,
      disId,
      midbCat,
      beNumber,
      oSuffix,
      pin,
      lostTrkInd,
      muidSrcTrk,
      muidSrc,
      mslStatus,
      trkConf,
      trkQual,
      alert,
      origXref,
      elnot1,
      elnot2,
      objIdent,
      objType,
      objPlat,
      objAct,
      objNat,
      name,
      shortName,
      trkId,
      trkNum,
      trkScope,
      sourceUid,
      callSign,
      identAmp,
      spaceAmp,
      spaceAmpConf,
      spaceSpecType,
      acftSubType,
      ts,
      launchTime,
      impactTime,
      ftnMsgTs,
      ftn,
      ftnCmd,
      rtnMsgTs,
      rtn,
      rtnTrkState,
      rtnCmd,
      sen,
      rptChxref,
      rptArchived,
      selfReport,
      mil2525Bstr,
      trnspdrId,
      trnspdrType,
      emitterName,
      infoSource,
      boosting,
      freq,
      maxFreq,
      harmonics,
      pri,
      prf,
      pw,
      scanType,
      scanRate,
      scn,
      cI,
      angElev,
      lat,
      lon,
      launchLat,
      launchLon,
      impactLat,
      impactLon,
      polarSingLocLat,
      polarSingLocLon,
      azCorrCenterLine,
      azCorrArcWidth,
      errSemiIntAxis,
      errAreaOrient,
      errSemiMajElev,
      errGeoAreaSwitch,
      burnoutAlt,
      tesEventId,
      spd,
      avgSpd,
      tol,
      alt,
      hdng,
      course,
      propRPM,
      tpk,
      coopLocInd,
      maneuverInd,
      launchAouType,
      launchAouData,
      impactAouType,
      impactAouData,
      aouRptType,
      aouRptData,
      ecefPos,
      ecefVel,
      containment,
      cpa,
      tcpa,
      navStatus,
      posDeviceType,
      aton,
      offPosInd,
      antennaRefDimensions,
      shipClass,
      imon,
      mmsi,
      draught,
      length,
      width,
      cargoType,
      appGrp,
      hullProf,
      propType,
      numBlades,
      numShafts,
      sternType,
      vslWt,
      arrTime,
      arrFlag,
      arrCargo,
      arrPort,
      depPort,
      depFlag,
      depCargo,
      desFlag,
      desCargo,
      destination,
      eta,
      etd,
      iff,
      emgInd,
      dropPtInd,
      reinforced,
      reduced,
      hq,
      dummy,
      taskForce,
      feint,
      installation,
      staffCmts,
      addInfo,
      evalRating,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: TRACK-DETAILS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
  ///  AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///  LAND: On the surface of dry land.
  ///  SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///  SURFACE: On the surface of a body of water.
  ///  SUBSURFACE: Below the surface of a body of water.
  ///  UNKNOWN: Environment is not known.
  /// Example: /// Example: LAND
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn env(&self) -> TrackDetails_Full_env_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TrackDetails_Full_env_Enum>(TrackDetails_Full::VT_ENV, Some(TrackDetails_Full_env_Enum::AIR)).unwrap()}
  }
  /// Optional message type designation.
  /// Example: /// Example: PLATFORM
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn msgType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_MSGTYPE, None)}
  }
  /// The vessel hull number designation of this maritime vessel.  The hull number is a 1-6 character alphanumeric entry assigned to a ship and painted on the hull.
  /// Example: /// Example: A30081
  /// Constraints: Minimum length = 0, Maximum length = 7
  #[inline]
  pub fn hullNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_HULLNUM, None)}
  }
  /// The Pseudo Identification Feature (PIF) number is a four digit code that provides an exact ID for the ship or aircraft. Friendly military only.
  /// Example: /// Example: 0137
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn pif(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_PIF, None)}
  }
  /// The Ship Control Number (SCONUM) is a naval vessel identification number (alphanumeric code) assigned by the Office of Naval Intelligence. SCONUM is sometimes referred to as NOIC ID. SCONUMs are typically of the form A#####, where A is an alpha character and # is numerical.
  /// Example: /// Example: B45524
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn sconum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_SCONUM, None)}
  }
  /// The Naval Tactical Data System (NTDS) track number assigned to this track.
  /// Example: /// Example: ZZ777
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn ntds(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_NTDS, None)}
  }
  /// The Intel Discrete Identifier (IDI) code assigned to this track.  The IDI is a four-digit code representing hostile or unknown tracks.
  /// Example: /// Example: 7670
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn disId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_DISID, None)}
  }
  /// The category code that represents the associated facility purpose within the target system.  This value is the category code in the MIDB (Modernized Intelligence Database).
  /// Example: /// Example: 20345
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn midbCat(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_MIDBCAT, None)}
  }
  /// The Basic Encyclopedia (BE) number associated with this installation or area.
  /// Example: /// Example: ENC-123
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn beNumber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_BENUMBER, None)}
  }
  /// The O-suffix associated with this facility.  The O-suffix is a five-character alpha/numeric system used to identify a facility, or demographic area, within an installation. The Installation Basic Encyclopedia (beNumber), in conjunction with the O-suffix, uniquely identifies the facility within the Modernized Integrated Database (MIDB).  The Installation beNumber and oSuffix are also used in conjunction with the midbCat code to classify the function or purpose of the facility.
  /// Example: /// Example: AA125
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn oSuffix(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_OSUFFIX, None)}
  }
  /// This value represents the site number of a specific electronic site or its associated equipment.
  /// Example: /// Example: E12345012
  /// Constraints: Minimum length = 0, Maximum length = 9
  #[inline]
  pub fn pin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_PIN, None)}
  }
  /// Flag indicating whether the missile is considered lost, if reporting a missile track.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lostTrkInd(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_LOSTTRKIND, Some(false)).unwrap()}
  }
  /// Track ID for the source of the Missile-Unique Identifier (MUID), if reporting a missile track.
  /// Example: /// Example: MUID-SRC-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn muidSrcTrk(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_MUIDSRCTRK, None)}
  }
  /// Source of the Missile-Unique Identifier (MUID), if reporting a missile track.
  /// Example: /// Example: MUID-SRC
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn muidSrc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_MUIDSRC, None)}
  }
  /// The status of the missile track in this record, if reporting a missile track (e.g. AT LAUNCH, AT OBSERVATION, FLYING, IMPACTED, LOST, STALE, DEBRIS).
  /// Example: /// Example: AT LAUNCH
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn mslStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_MSLSTATUS, None)}
  }
  /// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
  /// Example: /// Example: 0.95
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trkConf(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_TRKCONF, Some(0.0)).unwrap()}
  }
  /// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track; Higher values indicate higher track quality, i.e., lower errors in reported position.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trkQual(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TrackDetails_Full::VT_TRKQUAL, Some(0)).unwrap()}
  }
  /// A track may be designated as an alert track with the following designations:
  /// HIT - High Interest Track
  /// TGT - Target
  /// SUS - Suspect Carrier
  /// NSP - Cleared Suspect
  /// If alert is null, the track is assumed to be of non-alert status.
  /// Example: /// Example: TGT
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn alert(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ALERT, None)}
  }
  /// Original source cross-reference code for the Command that originated the report.
  /// Example: /// Example: INT
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn origXref(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ORIGXREF, None)}
  }
  /// Primary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
  /// Example: /// Example: A123A
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn elnot1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ELNOT1, None)}
  }
  /// Secondary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
  /// Example: /// Example: A123B
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn elnot2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ELNOT2, None)}
  }
  /// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
  ///  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  ///  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  ///  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  ///  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  ///  PENDING: Track object which has not been evaluated.
  ///  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  ///  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
  /// Example: /// Example: FRIEND
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn objIdent(&self) -> TrackDetails_Full_objIdent_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TrackDetails_Full_objIdent_Enum>(TrackDetails_Full::VT_OBJIDENT, Some(TrackDetails_Full_objIdent_Enum::ASSUMED_FRIEND)).unwrap()}
  }
  /// The generic classification of the track object/group (e.g., BALLISTIC, HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
  /// Example: /// Example: TRACKED
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn objType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_OBJTYPE, None)}
  }
  /// The object platform type is intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. SATELLITE).
  /// Example: /// Example: WEAPON
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn objPlat(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_OBJPLAT, None)}
  }
  /// The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. ANTISPACE WARFARE).
  /// Example: /// Example: HOLDING
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn objAct(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_OBJACT, None)}
  }
  /// Nationality of the tracked object.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn objNat(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_OBJNAT, None)}
  }
  /// Track name.
  /// Example: /// Example: TRACK-NAME
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_NAME, None)}
  }
  /// Abbreviated track name.
  /// Example: /// Example: COMMSCHECK
  /// Constraints: Minimum length = 0, Maximum length = 11
  #[inline]
  pub fn shortName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_SHORTNAME, None)}
  }
  /// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
  /// Example: /// Example: trkId
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn trkId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_TRKID, None)}
  }
  /// The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
  /// Example: /// Example: trkNum
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn trkNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_TRKNUM, None)}
  }
  /// Value Indicating the scope of this track:
  /// 1 - TERMINAL  (Terminal) - available only on the workstation where they were created.
  /// 2 - LOCAL  (Local) - available only on workstations in the local area network
  /// 3 - OTH  (Over the Horizon) - available to everyone.
  /// Example: /// Example: OTH
  /// Constraints: Minimum length = 0, Maximum length = 12
  #[inline]
  pub fn trkScope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_TRKSCOPE, None)}
  }
  /// The unique identifier of the source node.
  /// Example: /// Example: MCS
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn sourceUid(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_SOURCEUID, None)}
  }
  /// The call sign currently assigned to this track object.
  /// Example: /// Example: Charlie
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn callSign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_CALLSIGN, None)}
  }
  /// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
  ///  FAKER: Friendly track, object, or entity acting as an exercise hostile.
  ///  JOKER: Friendly track, object, or entity acting as an exercise suspect.
  ///  KILO: Friendly high-value object.
  ///  TRAVELLER: Suspect land or surface track following a recognized traffic route.
  ///  ZOMBIE: Suspect track, object, or entity of special interest.
  /// Example: /// Example: JOKER
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn identAmp(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_IDENTAMP, None)}
  }
  /// Space amplification indicates additional information on the space environment object being reported (e.g. DEBRIS, FUEL-AIR EXPLOSIVE, NUCLEAR WARHEAD).
  /// Example: /// Example: NUCLEAR WARHEAD
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn spaceAmp(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_SPACEAMP, None)}
  }
  /// Confidence level of the amplifying characteristics.  Values range from 0 to 6, with 0 indicating the lowest confidence and 6 indicating the highest.
  /// Example: /// Example: 6
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spaceAmpConf(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TrackDetails_Full::VT_SPACEAMPCONF, Some(0)).unwrap()}
  }
  /// Specific type of point or track with an environment of space.
  /// Example: /// Example: SS-21_MOD_2_CRBM
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn spaceSpecType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_SPACESPECTYPE, None)}
  }
  /// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM:
  /// SRBM - Short-Range Ballistic Missile
  /// MRBM - Medium-Range Ballistic Missile
  /// IRBM - Intermediate-Range Ballistic Missile
  /// LRBM - Long-Range Ballistic Missile
  /// ICBM - Intercontinental Ballistic Missile
  /// SLBM - Submarine-Launched Ballistic Missile.
  /// Example: /// Example: SLBM
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn acftSubType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ACFTSUBTYPE, None)}
  }
  /// Track timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ts(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_TS, None)}
  }
  /// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_LAUNCHTIME, None)}
  }
  /// Missile impact timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn impactTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_IMPACTTIME, None)}
  }
  /// The message timestamp that the ftn track position was recorded, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ftnMsgTs(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_FTNMSGTS, None)}
  }
  /// An ftn used to associate information and directives with the track.
  /// Example: /// Example: FTN
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn ftn(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_FTN, None)}
  }
  /// The name of the Command reporting the Force Over-The-Horizon Track Coordinator (FOTC) track number.
  /// Example: /// Example: TRUETT
  /// Constraints: Minimum length = 0, Maximum length = 18
  #[inline]
  pub fn ftnCmd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_FTNCMD, None)}
  }
  /// The message timestamp that the reference track position was recorded, in ISO 8601 UTC format with microsecond precision. The 'rtnMsgTs' and 'rtn' arrays must match in size.
  /// Example: /// Example: ['2021-02-25T12:00:00.123456Z']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rtnMsgTs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TrackDetails_Full::VT_RTNMSGTS, None)}
  }
  /// A Reference Track Number used to associate information and directives with the track.  Referenced, but not constrained to, MIL-STD-6016F Reference Track Number. The 'rtnMsgTs' and 'rtn' arrays must match in size.
  /// Example: /// Example: ['ex-a']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rtn(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TrackDetails_Full::VT_RTN, None)}
  }
  /// Value representing the state of the Received Track.
  /// Example: /// Example: Local_RTN
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn rtnTrkState(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_RTNTRKSTATE, None)}
  }
  /// The name of the Command reporting the Received Track Number (RTN).
  /// Example: /// Example: YORKTOWN
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn rtnCmd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_RTNCMD, None)}
  }
  /// Id/name of sensor providing the track data.
  /// Example: /// Example: OTH
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn sen(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_SEN, None)}
  }
  /// Source cross-reference code for the Command that originated the track report.
  /// Example: /// Example: INT
  /// Constraints: Minimum length = 0, Maximum length = 18
  #[inline]
  pub fn rptChxref(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_RPTCHXREF, None)}
  }
  /// Flag indicating whether this track is archived.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rptArchived(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_RPTARCHIVED, Some(false)).unwrap()}
  }
  /// Flag indicating that this track is self reported.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn selfReport(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_SELFREPORT, Some(false)).unwrap()}
  }
  /// The MIL-STD-2525B symbology code that applies to the subject of this track.
  /// Example: /// Example: SHP*S----------
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn mil2525Bstr(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_MIL2525BSTR, None)}
  }
  /// Transponder ID for the track.  This does not correspond to the UDL transponder schema.
  /// Example: /// Example: 11
  /// Constraints: Minimum length = 0, Maximum length = 61
  #[inline]
  pub fn trnspdrId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_TRNSPDRID, None)}
  }
  /// Transponder type for the track.
  /// Example: /// Example: AFTS
  /// Constraints: Minimum length = 0, Maximum length = 51
  #[inline]
  pub fn trnspdrType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_TRNSPDRTYPE, None)}
  }
  /// Radar name of the sensor tracking this object (e.g., RAY1500, SPN-43, HEADNET).
  /// Example: /// Example: RAY1500
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn emitterName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_EMITTERNAME, None)}
  }
  /// Source code for source of information used to detect track.
  /// Example: /// Example: S1
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn infoSource(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_INFOSOURCE, None)}
  }
  /// Flag indicating that the missile is currently in a state of boosting, if reporting a missile track.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn boosting(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_BOOSTING, Some(false)).unwrap()}
  }
  /// Frequency, in hertz, for the signature report.
  /// Example: /// Example: 63.65
  /// Constraints: No constraints specified.
  #[inline]
  pub fn freq(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_FREQ, Some(0.0)).unwrap()}
  }
  /// Maximum frequency, in hertz, reported for this acoustic track.
  /// Example: /// Example: 10324.53
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxFreq(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_MAXFREQ, Some(0.0)).unwrap()}
  }
  /// List of harmonics of the signature report in descending order of predominance using 1-2 digit combinations separated by commas, e.g., 8,12,4. (1-22NS).
  /// Example: /// Example: 8,12,4
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn harmonics(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_HARMONICS, None)}
  }
  /// Pulse repetition interval of the emitter, measured in microseconds.  The interval between the start of one pulse and the start of another.
  /// Example: /// Example: 56657.2238
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pri(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_PRI, Some(0.0)).unwrap()}
  }
  /// Pulse repetition frequency of the emitter, measured in pulses per second.  PRF is the number of pulses transmitted per second. This is the reciprocal of the pri value.
  /// Example: /// Example: 17.65
  /// Constraints: No constraints specified.
  #[inline]
  pub fn prf(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_PRF, Some(0.0)).unwrap()}
  }
  /// Pulse width of the emitter, measured in microseconds.  This is the duration of the pulse.
  /// Example: /// Example: 1347.45
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pw(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_PW, Some(0.0)).unwrap()}
  }
  /// Type of radar scan.
  /// Example: /// Example: UNK
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn scanType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_SCANTYPE, None)}
  }
  /// Scan rate of the emitter, measured in seconds per rotation (SPR).
  /// Example: /// Example: 12.01
  /// Constraints: No constraints specified.
  #[inline]
  pub fn scanRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_SCANRATE, Some(0.0)).unwrap()}
  }
  /// The Sequential Contact Number (SCN) for this track.
  /// Example: /// Example: 1474305
  /// Constraints: No constraints specified.
  #[inline]
  pub fn scn(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TrackDetails_Full::VT_SCN, Some(0)).unwrap()}
  }
  /// Correlation Index; reference code for the site that originally reported the track.
  /// Example: /// Example: BB
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn cI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_CI, None)}
  }
  /// The angle formed between the line of sight of the observer and the horizon, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
  /// Example: /// Example: 15.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn angElev(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_ANGELEV, Some(0.0)).unwrap()}
  }
  /// WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_LON, Some(0.0)).unwrap()}
  }
  /// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_LAUNCHLAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74550102
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchLon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_LAUNCHLON, Some(0.0)).unwrap()}
  }
  /// WGS-84 latitude of the missile impact point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  #[inline]
  pub fn impactLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_IMPACTLAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude of the missile impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74550102
  /// Constraints: No constraints specified.
  #[inline]
  pub fn impactLon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_IMPACTLON, Some(0.0)).unwrap()}
  }
  /// WGS-84 azimuth corridor reference point latitude, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polarSingLocLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_POLARSINGLOCLAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 azimuth corridor reference point longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74550102
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polarSingLocLon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_POLARSINGLOCLON, Some(0.0)).unwrap()}
  }
  /// The azimuth corridor centerline angle measured in degrees clockwise from true north, of the center line of an azimuth corridor. The center line extends from the referenced corridor origin location.
  /// Example: /// Example: 12.876
  /// Constraints: No constraints specified.
  #[inline]
  pub fn azCorrCenterLine(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_AZCORRCENTERLINE, Some(0.0)).unwrap()}
  }
  /// Azimuth corridor arc distance measured in meters from reference point of azimuth corridor to far edge of bounded azimuth corridor wedge, measured along azimuth corridor center line.
  /// Example: /// Example: 71.76
  /// Constraints: No constraints specified.
  #[inline]
  pub fn azCorrArcWidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_AZCORRARCWIDTH, Some(0.0)).unwrap()}
  }
  /// The error in the semi-intermediate axis.  The semi-intermediate axis is intermediate in length between semi-major and semi-minor axes. This field is doubled and centered on intersection of area semi-major axis and area semi-minor axis at 90 degrees to the plane defined by those axes. For these shapes, the volume is defined as having a 50-percent probability of containing the true location of the referenced entity.
  /// Example: /// Example: 7010.882
  /// Constraints: No constraints specified.
  #[inline]
  pub fn errSemiIntAxis(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_ERRSEMIINTAXIS, Some(0.0)).unwrap()}
  }
  /// The error in the Area Orientation.  Area Orientation is the angle or roll in degrees, between area semi-minor axis and plane defined by local vertical and area semi-major axis. When reported without major and minor axis, it is angle between an axis perpendicular to a 2D true north axis and plane defined by local vertical and a 2D true north axis.
  /// Example: /// Example: 69.6
  /// Constraints: No constraints specified.
  #[inline]
  pub fn errAreaOrient(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_ERRAREAORIENT, Some(0.0)).unwrap()}
  }
  /// The error in the Semi-major elevation axis. Semi-major elevation axis is the elevation of the cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical semi-major axis, in degrees, measured from local horizontal.
  /// Example: /// Example: 168.8
  /// Constraints: No constraints specified.
  #[inline]
  pub fn errSemiMajElev(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_ERRSEMIMAJELEV, Some(0.0)).unwrap()}
  }
  /// Geometric area switch identifies the 3D shape of the error volume by providing the 2D shape for the 3D plane. The 3D plane is the plane orthogonal to the area semi-major axis and area semi-minor axis. Depending on whether the 2D plane is reported as an error ellipse 2D or as an error rectangle 2D, this switch reports a complete error volume that is cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical.
  /// 0 - SWITCH_TYPE_UNKNOWN
  /// 1 - SQUARE_RECTANGLE
  /// 2 - CIRCLE_ELLIPSE.
  /// Example: /// Example: CIRCLE_ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn errGeoAreaSwitch(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ERRGEOAREASWITCH, None)}
  }
  /// Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
  /// Example: /// Example: 30567.452
  /// Constraints: No constraints specified.
  #[inline]
  pub fn burnoutAlt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_BURNOUTALT, Some(0.0)).unwrap()}
  }
  /// Threat Event System Track ID.
  /// Example: /// Example: 6217
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn tesEventId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_TESEVENTID, None)}
  }
  /// Track object speed, in meters/sec.
  /// Example: /// Example: 15.03443
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_SPD, Some(0.0)).unwrap()}
  }
  /// The average speed, in kilometers/hour, calculated for the subject during the latest voyage/excursion.
  /// Example: /// Example: 18.25
  /// Constraints: No constraints specified.
  #[inline]
  pub fn avgSpd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_AVGSPD, Some(0.0)).unwrap()}
  }
  /// Motion model Time On Leg in hours.
  /// Example: /// Example: 4.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tol(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_TOL, Some(0.0)).unwrap()}
  }
  /// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
  /// Example: /// Example: 153.01
  /// Constraints: No constraints specified.
  #[inline]
  pub fn alt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_ALT, Some(0.0)).unwrap()}
  }
  /// Track object heading, in degrees clockwise from true north.
  /// Example: /// Example: 19.7
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hdng(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_HDNG, Some(0.0)).unwrap()}
  }
  /// The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
  /// Example: /// Example: 4.3580153
  /// Constraints: No constraints specified.
  #[inline]
  pub fn course(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_COURSE, Some(0.0)).unwrap()}
  }
  /// The number of propeller revolutions per minute for a submarine or ship.
  /// Example: /// Example: 8.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn propRPM(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_PROPRPM, Some(0.0)).unwrap()}
  }
  /// The number of turns of the vessel propellers per knot of forward motion.
  /// Example: /// Example: 2.65
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tpk(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_TPK, Some(0.0)).unwrap()}
  }
  /// The Cooperative Location Indicator specifies whether the reported entity location was derived using reported locations from sensors on more than one platform.
  /// 0 - COOPERATIVE_LOCATOR_NONE
  /// 1 - SINGLE_PLATFORM
  /// 2 - FRAGMENT
  /// 3 - COOPERATIVE.
  /// Example: /// Example: COOPERATIVE
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn coopLocInd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_COOPLOCIND, None)}
  }
  /// The manuevering indicator specifying the missile boost phase.
  /// 0 - POST_BOOST_NONE
  /// 1 - POST_BOOST_MANUEVER
  /// 2 - POST_BOOST_COMPLETE_MANUEVER.
  /// Example: /// Example: POST_BOOST_NONE
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn maneuverInd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_MANEUVERIND, None)}
  }
  /// The launch location Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the launchAouData array and is required if launchAouData is not null. See the launchAouData field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 20
  #[inline]
  pub fn launchAouType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_LAUNCHAOUTYPE, None)}
  }
  /// Three element array representing the launch location Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the launchAouType specified in this record:
  ///  ELLIPSE:
  ///    brg - orientation in degrees of the ellipse
  ///    a1 - semi-major axis in meters
  ///    a2 - semi-minor axis in meters
  ///  BEARING (BEARING BOX or MTST BEARING BOX):
  ///    brg - orientation in degrees of the bearing box
  ///    a1 - length of bearing box in meters
  ///    a2 - half-width of bearing box in meters
  ///  OTHER (All other type values):
  ///    brg - line of bearing in degrees true
  ///    a1 - bearing error in degrees
  ///    a2 - estimated range in meters.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchAouData(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TrackDetails_Full::VT_LAUNCHAOUDATA, None)}
  }
  /// The impact point Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the impactAouData array and is required if impactAouData is not null. See the impactAouData field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 20
  #[inline]
  pub fn impactAouType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_IMPACTAOUTYPE, None)}
  }
  /// Three element array representing the impact point Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the impactAouType specified in this record:
  ///  ELLIPSE:
  ///    brg - orientation in degrees of the ellipse
  ///    a1 - semi-major axis in meters
  ///    a2 - semi-minor axis in meters
  ///  BEARING (BEARING BOX or MTST BEARING BOX):
  ///    brg - orientation in degrees of the bearing box
  ///    a1 - length of bearing box in meters
  ///    a2 - half-width of bearing box in meters
  ///  OTHER (All other type values):
  ///    brg - line of bearing in degrees true
  ///    a1 - bearing error in degrees
  ///    a2 - estimated range in meters.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn impactAouData(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TrackDetails_Full::VT_IMPACTAOUDATA, None)}
  }
  /// The track Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouRptData array and is required if aouRptData is not null. See the aouRptData field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 20
  #[inline]
  pub fn aouRptType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_AOURPTTYPE, None)}
  }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouRptType specified in this record:
  ///  ELLIPSE:
  ///    brg - orientation in degrees of the ellipse
  ///    a1 - semi-major axis in meters
  ///    a2 - semi-minor axis in meters
  ///  BEARING (BEARING BOX or MTST BEARING BOX):
  ///    brg - orientation in degrees of the bearing box
  ///    a1 - length of bearing box in meters
  ///    a2 - half-width of bearing box in meters
  ///  OTHER (All other type values):
  ///    brg - line of bearing in degrees true
  ///    a1 - bearing error in degrees
  ///    a2 - estimated range in meters.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn aouRptData(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TrackDetails_Full::VT_AOURPTDATA, None)}
  }
  /// Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
  /// Example: /// Example: [1.23, 2.35, 3.42]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ecefPos(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TrackDetails_Full::VT_ECEFPOS, None)}
  }
  /// Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
  /// Example: /// Example: [1.23, 2.35, 3.42]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ecefVel(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TrackDetails_Full::VT_ECEFVEL, None)}
  }
  /// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
  /// Example: /// Example: 97
  /// Constraints: No constraints specified.
  #[inline]
  pub fn containment(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_CONTAINMENT, Some(0.0)).unwrap()}
  }
  /// The distance, in meters, of the closest point of approach between this track to the master reference track.
  /// Example: /// Example: 500
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cpa(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_CPA, Some(0.0)).unwrap()}
  }
  /// The time, in ISO 8601 UTC format with millisecond precision, of the  closest point of approach between this track and the master reference track.
  /// Example: /// Example: 2021-02-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tcpa(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_TCPA, None)}
  }
  /// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Underway Using Engine
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn navStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_NAVSTATUS, None)}
  }
  /// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: GPS
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn posDeviceType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_POSDEVICETYPE, None)}
  }
  /// Type of Aid to Navigation. Intended as, but not constrained to, the USCG NAVCEN  aids to navigation. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Cardinal Mark N
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn aton(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ATON, None)}
  }
  /// Indicator position (OFF, ON, UNK) for optional floating navigational aids only.
  /// Example: /// Example: ON
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn offPosInd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_OFFPOSIND, None)}
  }
  /// The reference dimensions of the vessel, reported as [A, B, C, D], in meters. Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna. Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
  /// Example: /// Example: [50.1, 50.1, 20.1, 20.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn antennaRefDimensions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TrackDetails_Full::VT_ANTENNAREFDIMENSIONS, None)}
  }
  /// The common name for a group of ships with similar design, usually named for the first vessel of the class.
  /// Example: /// Example: Nimitz
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn shipClass(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_SHIPCLASS, None)}
  }
  /// The International Maritime Organization Number of the vessel. IMON is a seven-digit number that uniquely identifies the vessel.
  /// Example: /// Example: 9015462
  /// Constraints: No constraints specified.
  #[inline]
  pub fn imon(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TrackDetails_Full::VT_IMON, Some(0)).unwrap()}
  }
  /// The Maritime Mobile Service Identity of the vessel. MMSI is a nine-digit number that identifies the transmitter station of the vessel.
  /// Example: /// Example: 304010417
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mmsi(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TrackDetails_Full::VT_MMSI, Some(0)).unwrap()}
  }
  /// The maximum static draught, in meters, of the vessel according to the AIS transmission.
  /// Example: /// Example: 21.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn draught(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_DRAUGHT, Some(0.0)).unwrap()}
  }
  /// The overall length of the vessel, in meters. A value of 511 indicates a vessel length of 511 meters or greater.
  /// Example: /// Example: 511.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn length(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_LENGTH, Some(0.0)).unwrap()}
  }
  /// The breadth of the vessel, in meters. A value of 63 indicates a vessel breadth of 63 meters or greater.
  /// Example: /// Example: 24.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_WIDTH, Some(0.0)).unwrap()}
  }
  /// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn cargoType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_CARGOTYPE, None)}
  }
  /// Appearance group code.
  /// GP1 - Superstructure exceeds 1/3 of ship length.
  /// GP2 - Superstructure less than 1/3 of ship length.
  /// GP3 - Stack aft.
  /// Example: /// Example: GP1
  /// Constraints: Minimum length = 0, Maximum length = 7
  #[inline]
  pub fn appGrp(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_APPGRP, None)}
  }
  /// Hull profile code. Based on GCCS-J hull profiles.
  /// FLUSH           No breaks in Hull Profile.
  /// RAISED 1        Hull Profile shows distinct raised area at bow. Remainder of deck is flush.
  /// RAISED 2        Hull Profile shows distinct raised area amidships. Bow and stern are flush.
  /// RAISED 3        Hull Profile shows distinct raised area at stern. Remainder of deck is flush.
  /// RAISED 1-2-3    Distinct raised areas at bow, midships, and stern with breaks between each raise.
  /// RAISED 1-2      Raised area at bow and midships with break between.
  /// RAISED 1-3      Raised area at bow and stern with break between.
  /// RAISED 12       Continuous raised area encompassing both bow and midships.
  /// RAISED 23       Continuous raised area encompassing midships and stern.
  /// RAISED 12-3     Raised areas at bow, midships and stern. Bow and midship raises are continuous. Break between midship and stern raises.
  /// RAISED 1-23     Raised areas at bow, midships, and stern. Midship and stern raises are continuous with break between bow and midship raises.
  /// RAISED 1-L2-3   Raised areas at bow, midships, and stern with break between each raise. Midships raise is longer than that associated with raised 1-2-3.
  /// Example: /// Example: Raised 1-23
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn hullProf(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_HULLPROF, None)}
  }
  /// The type of propulsion employed by the track object (Diesel, Nuclear).
  /// Example: /// Example: Diesel
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn propType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_PROPTYPE, None)}
  }
  /// The number of blades per shaft of the track object.  Applicable for maritime vessels.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numBlades(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TrackDetails_Full::VT_NUMBLADES, Some(0)).unwrap()}
  }
  /// The number of shafts on the track object.  Applicable for maritime vessels.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numShafts(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TrackDetails_Full::VT_NUMSHAFTS, Some(0)).unwrap()}
  }
  /// The stern type code (Counter, Cruiser) associated with the track object.
  /// Example: /// Example: Cruiser
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn sternType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_STERNTYPE, None)}
  }
  /// The weight, in tons, of the vessel associated with this track.
  /// Example: /// Example: 3423.76
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vslWt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackDetails_Full::VT_VSLWT, Some(0.0)).unwrap()}
  }
  /// The Arrival Time of the vessel at the destination, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn arrTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ARRTIME, None)}
  }
  /// The flag of the arrival port.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn arrFlag(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ARRFLAG, None)}
  }
  /// The reported arrival cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn arrCargo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ARRCARGO, None)}
  }
  /// The Arrival Port of the vessel according to the AIS transmission.
  /// Example: /// Example: Lanshan
  /// Constraints: Minimum length = 0, Maximum length = 20
  #[inline]
  pub fn arrPort(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ARRPORT, None)}
  }
  /// The Departure Port of the vessel according to the AIS transmission.
  /// Example: /// Example: Lanshan
  /// Constraints: Minimum length = 0, Maximum length = 20
  #[inline]
  pub fn depPort(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_DEPPORT, None)}
  }
  /// The flag of the departure port.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn depFlag(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_DEPFLAG, None)}
  }
  /// The reported departure cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn depCargo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_DEPCARGO, None)}
  }
  /// The flag of the destination port.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn desFlag(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_DESFLAG, None)}
  }
  /// The reported destination cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn desCargo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_DESCARGO, None)}
  }
  /// The destination of the vessel according to the AIS transmission.
  /// Example: /// Example: USCLE
  /// Constraints: Minimum length = 0, Maximum length = 20
  #[inline]
  pub fn destination(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_DESTINATION, None)}
  }
  /// The Estimated Time of Arrival of the vessel at the destination port, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn eta(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ETA, None)}
  }
  /// The Estimated Time of Departure of the vessel from the departure port (depPort), according to Marine Traffic calculations, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn etd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ETD, None)}
  }
  /// A text amplifier displaying IFF/SIF/AIS Identification modes and codes.
  /// Example: /// Example: ID Mode
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn iff(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_IFF, None)}
  }
  /// Flag indicating that the track object has an emergency.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn emgInd(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_EMGIND, Some(false)).unwrap()}
  }
  /// The drop-point indicator setting.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dropPtInd(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_DROPPTIND, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn reinforced(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_REINFORCED, Some(false)).unwrap()}
  }
  /// Flag indicating for the track represents a reduced force object or group.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn reduced(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_REDUCED, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hq(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_HQ, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dummy(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_DUMMY, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taskForce(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_TASKFORCE, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn feint(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_FEINT, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn installation(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TrackDetails_Full::VT_INSTALLATION, Some(false)).unwrap()}
  }
  /// A text amplifier for units, equipment and installations; content is implementation specific.
  /// Example: /// Example: Staff Comments
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn staffCmts(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_STAFFCMTS, None)}
  }
  /// A text amplifier for units, equipment and installations; content is implementation specific.
  /// Example: /// Example: Additional information
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn addInfo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ADDINFO, None)}
  }
  /// A text amplifier code for units, equipment, and installations that consists of a one-letter reliability rating and a one-number credibility rating based on the following definitions of each:
  ///  Reliability Ratings:
  ///   A-completely reliable
  ///   B-usually reliable
  ///   C-fairly reliable
  ///   D-not usually reliable
  ///   E-unreliable
  ///   F-reliability cannot be judged
  ///  Credibility Ratings:
  ///   1-confirmed by other sources
  ///   2-probably true
  ///   3-possibly true
  ///   4-doubtfully true
  ///   5-improbable
  ///   6-truth cannot be judged.
  /// Example: /// Example: A1
  /// Constraints: Minimum length = 0, Maximum length = 2
  #[inline]
  pub fn evalRating(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_EVALRATING, None)}
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2021-02-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> TrackDetails_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TrackDetails_Full_dataMode_Enum>(TrackDetails_Full::VT_DATAMODE, Some(TrackDetails_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackDetails_Full::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for TrackDetails_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<TrackDetails_Full_env_Enum>("env", Self::VT_ENV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msgType", Self::VT_MSGTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hullNum", Self::VT_HULLNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pif", Self::VT_PIF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sconum", Self::VT_SCONUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ntds", Self::VT_NTDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("disId", Self::VT_DISID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("midbCat", Self::VT_MIDBCAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("beNumber", Self::VT_BENUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("oSuffix", Self::VT_OSUFFIX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pin", Self::VT_PIN, false)?
     .visit_field::<bool>("lostTrkInd", Self::VT_LOSTTRKIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("muidSrcTrk", Self::VT_MUIDSRCTRK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("muidSrc", Self::VT_MUIDSRC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mslStatus", Self::VT_MSLSTATUS, false)?
     .visit_field::<f64>("trkConf", Self::VT_TRKCONF, false)?
     .visit_field::<i32>("trkQual", Self::VT_TRKQUAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alert", Self::VT_ALERT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origXref", Self::VT_ORIGXREF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("elnot1", Self::VT_ELNOT1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("elnot2", Self::VT_ELNOT2, false)?
     .visit_field::<TrackDetails_Full_objIdent_Enum>("objIdent", Self::VT_OBJIDENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("objType", Self::VT_OBJTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("objPlat", Self::VT_OBJPLAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("objAct", Self::VT_OBJACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("objNat", Self::VT_OBJNAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shortName", Self::VT_SHORTNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trkId", Self::VT_TRKID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trkNum", Self::VT_TRKNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trkScope", Self::VT_TRKSCOPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceUid", Self::VT_SOURCEUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("callSign", Self::VT_CALLSIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("identAmp", Self::VT_IDENTAMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("spaceAmp", Self::VT_SPACEAMP, false)?
     .visit_field::<i32>("spaceAmpConf", Self::VT_SPACEAMPCONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("spaceSpecType", Self::VT_SPACESPECTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("acftSubType", Self::VT_ACFTSUBTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ts", Self::VT_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("launchTime", Self::VT_LAUNCHTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("impactTime", Self::VT_IMPACTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ftnMsgTs", Self::VT_FTNMSGTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ftn", Self::VT_FTN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ftnCmd", Self::VT_FTNCMD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("rtnMsgTs", Self::VT_RTNMSGTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("rtn", Self::VT_RTN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rtnTrkState", Self::VT_RTNTRKSTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rtnCmd", Self::VT_RTNCMD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sen", Self::VT_SEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rptChxref", Self::VT_RPTCHXREF, false)?
     .visit_field::<bool>("rptArchived", Self::VT_RPTARCHIVED, false)?
     .visit_field::<bool>("selfReport", Self::VT_SELFREPORT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mil2525Bstr", Self::VT_MIL2525BSTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trnspdrId", Self::VT_TRNSPDRID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trnspdrType", Self::VT_TRNSPDRTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("emitterName", Self::VT_EMITTERNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("infoSource", Self::VT_INFOSOURCE, false)?
     .visit_field::<bool>("boosting", Self::VT_BOOSTING, false)?
     .visit_field::<f64>("freq", Self::VT_FREQ, false)?
     .visit_field::<f64>("maxFreq", Self::VT_MAXFREQ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("harmonics", Self::VT_HARMONICS, false)?
     .visit_field::<f64>("pri", Self::VT_PRI, false)?
     .visit_field::<f64>("prf", Self::VT_PRF, false)?
     .visit_field::<f64>("pw", Self::VT_PW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scanType", Self::VT_SCANTYPE, false)?
     .visit_field::<f64>("scanRate", Self::VT_SCANRATE, false)?
     .visit_field::<i32>("scn", Self::VT_SCN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cI", Self::VT_CI, false)?
     .visit_field::<f64>("angElev", Self::VT_ANGELEV, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<f64>("launchLat", Self::VT_LAUNCHLAT, false)?
     .visit_field::<f64>("launchLon", Self::VT_LAUNCHLON, false)?
     .visit_field::<f64>("impactLat", Self::VT_IMPACTLAT, false)?
     .visit_field::<f64>("impactLon", Self::VT_IMPACTLON, false)?
     .visit_field::<f64>("polarSingLocLat", Self::VT_POLARSINGLOCLAT, false)?
     .visit_field::<f64>("polarSingLocLon", Self::VT_POLARSINGLOCLON, false)?
     .visit_field::<f64>("azCorrCenterLine", Self::VT_AZCORRCENTERLINE, false)?
     .visit_field::<f64>("azCorrArcWidth", Self::VT_AZCORRARCWIDTH, false)?
     .visit_field::<f64>("errSemiIntAxis", Self::VT_ERRSEMIINTAXIS, false)?
     .visit_field::<f64>("errAreaOrient", Self::VT_ERRAREAORIENT, false)?
     .visit_field::<f64>("errSemiMajElev", Self::VT_ERRSEMIMAJELEV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("errGeoAreaSwitch", Self::VT_ERRGEOAREASWITCH, false)?
     .visit_field::<f64>("burnoutAlt", Self::VT_BURNOUTALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tesEventId", Self::VT_TESEVENTID, false)?
     .visit_field::<f64>("spd", Self::VT_SPD, false)?
     .visit_field::<f64>("avgSpd", Self::VT_AVGSPD, false)?
     .visit_field::<f64>("tol", Self::VT_TOL, false)?
     .visit_field::<f64>("alt", Self::VT_ALT, false)?
     .visit_field::<f64>("hdng", Self::VT_HDNG, false)?
     .visit_field::<f64>("course", Self::VT_COURSE, false)?
     .visit_field::<f64>("propRPM", Self::VT_PROPRPM, false)?
     .visit_field::<f64>("tpk", Self::VT_TPK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coopLocInd", Self::VT_COOPLOCIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("maneuverInd", Self::VT_MANEUVERIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("launchAouType", Self::VT_LAUNCHAOUTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("launchAouData", Self::VT_LAUNCHAOUDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("impactAouType", Self::VT_IMPACTAOUTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("impactAouData", Self::VT_IMPACTAOUDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("aouRptType", Self::VT_AOURPTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("aouRptData", Self::VT_AOURPTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ecefPos", Self::VT_ECEFPOS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ecefVel", Self::VT_ECEFVEL, false)?
     .visit_field::<f64>("containment", Self::VT_CONTAINMENT, false)?
     .visit_field::<f64>("cpa", Self::VT_CPA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tcpa", Self::VT_TCPA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("navStatus", Self::VT_NAVSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("posDeviceType", Self::VT_POSDEVICETYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("aton", Self::VT_ATON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("offPosInd", Self::VT_OFFPOSIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("antennaRefDimensions", Self::VT_ANTENNAREFDIMENSIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shipClass", Self::VT_SHIPCLASS, false)?
     .visit_field::<i32>("imon", Self::VT_IMON, false)?
     .visit_field::<i32>("mmsi", Self::VT_MMSI, false)?
     .visit_field::<f64>("draught", Self::VT_DRAUGHT, false)?
     .visit_field::<f64>("length", Self::VT_LENGTH, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cargoType", Self::VT_CARGOTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("appGrp", Self::VT_APPGRP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hullProf", Self::VT_HULLPROF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("propType", Self::VT_PROPTYPE, false)?
     .visit_field::<i32>("numBlades", Self::VT_NUMBLADES, false)?
     .visit_field::<i32>("numShafts", Self::VT_NUMSHAFTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sternType", Self::VT_STERNTYPE, false)?
     .visit_field::<f64>("vslWt", Self::VT_VSLWT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("arrTime", Self::VT_ARRTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("arrFlag", Self::VT_ARRFLAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("arrCargo", Self::VT_ARRCARGO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("arrPort", Self::VT_ARRPORT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("depPort", Self::VT_DEPPORT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("depFlag", Self::VT_DEPFLAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("depCargo", Self::VT_DEPCARGO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desFlag", Self::VT_DESFLAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desCargo", Self::VT_DESCARGO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("destination", Self::VT_DESTINATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eta", Self::VT_ETA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("etd", Self::VT_ETD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iff", Self::VT_IFF, false)?
     .visit_field::<bool>("emgInd", Self::VT_EMGIND, false)?
     .visit_field::<bool>("dropPtInd", Self::VT_DROPPTIND, false)?
     .visit_field::<bool>("reinforced", Self::VT_REINFORCED, false)?
     .visit_field::<bool>("reduced", Self::VT_REDUCED, false)?
     .visit_field::<bool>("hq", Self::VT_HQ, false)?
     .visit_field::<bool>("dummy", Self::VT_DUMMY, false)?
     .visit_field::<bool>("taskForce", Self::VT_TASKFORCE, false)?
     .visit_field::<bool>("feint", Self::VT_FEINT, false)?
     .visit_field::<bool>("installation", Self::VT_INSTALLATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("staffCmts", Self::VT_STAFFCMTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("addInfo", Self::VT_ADDINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("evalRating", Self::VT_EVALRATING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<TrackDetails_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct TrackDetails_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub env: TrackDetails_Full_env_Enum,
    pub msgType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hullNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pif: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sconum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ntds: Option<flatbuffers::WIPOffset<&'a str>>,
    pub disId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub midbCat: Option<flatbuffers::WIPOffset<&'a str>>,
    pub beNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub oSuffix: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lostTrkInd: bool,
    pub muidSrcTrk: Option<flatbuffers::WIPOffset<&'a str>>,
    pub muidSrc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mslStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trkConf: f64,
    pub trkQual: i32,
    pub alert: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origXref: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elnot1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elnot2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objIdent: TrackDetails_Full_objIdent_Enum,
    pub objType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objPlat: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objAct: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objNat: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shortName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trkId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trkNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trkScope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceUid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub callSign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub identAmp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub spaceAmp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub spaceAmpConf: i32,
    pub spaceSpecType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub acftSubType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub launchTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub impactTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ftnMsgTs: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ftn: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ftnCmd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rtnMsgTs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub rtn: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub rtnTrkState: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rtnCmd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sen: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rptChxref: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rptArchived: bool,
    pub selfReport: bool,
    pub mil2525Bstr: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trnspdrId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trnspdrType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub emitterName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub infoSource: Option<flatbuffers::WIPOffset<&'a str>>,
    pub boosting: bool,
    pub freq: f64,
    pub maxFreq: f64,
    pub harmonics: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pri: f64,
    pub prf: f64,
    pub pw: f64,
    pub scanType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scanRate: f64,
    pub scn: i32,
    pub cI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub angElev: f64,
    pub lat: f64,
    pub lon: f64,
    pub launchLat: f64,
    pub launchLon: f64,
    pub impactLat: f64,
    pub impactLon: f64,
    pub polarSingLocLat: f64,
    pub polarSingLocLon: f64,
    pub azCorrCenterLine: f64,
    pub azCorrArcWidth: f64,
    pub errSemiIntAxis: f64,
    pub errAreaOrient: f64,
    pub errSemiMajElev: f64,
    pub errGeoAreaSwitch: Option<flatbuffers::WIPOffset<&'a str>>,
    pub burnoutAlt: f64,
    pub tesEventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub spd: f64,
    pub avgSpd: f64,
    pub tol: f64,
    pub alt: f64,
    pub hdng: f64,
    pub course: f64,
    pub propRPM: f64,
    pub tpk: f64,
    pub coopLocInd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maneuverInd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub launchAouType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub launchAouData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub impactAouType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub impactAouData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub aouRptType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub aouRptData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ecefPos: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ecefVel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub containment: f64,
    pub cpa: f64,
    pub tcpa: Option<flatbuffers::WIPOffset<&'a str>>,
    pub navStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub posDeviceType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub aton: Option<flatbuffers::WIPOffset<&'a str>>,
    pub offPosInd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub antennaRefDimensions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub shipClass: Option<flatbuffers::WIPOffset<&'a str>>,
    pub imon: i32,
    pub mmsi: i32,
    pub draught: f64,
    pub length: f64,
    pub width: f64,
    pub cargoType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub appGrp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hullProf: Option<flatbuffers::WIPOffset<&'a str>>,
    pub propType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub numBlades: i32,
    pub numShafts: i32,
    pub sternType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vslWt: f64,
    pub arrTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub arrFlag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub arrCargo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub arrPort: Option<flatbuffers::WIPOffset<&'a str>>,
    pub depPort: Option<flatbuffers::WIPOffset<&'a str>>,
    pub depFlag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub depCargo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desFlag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desCargo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub destination: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eta: Option<flatbuffers::WIPOffset<&'a str>>,
    pub etd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iff: Option<flatbuffers::WIPOffset<&'a str>>,
    pub emgInd: bool,
    pub dropPtInd: bool,
    pub reinforced: bool,
    pub reduced: bool,
    pub hq: bool,
    pub dummy: bool,
    pub taskForce: bool,
    pub feint: bool,
    pub installation: bool,
    pub staffCmts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub addInfo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub evalRating: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: TrackDetails_Full_dataMode_Enum,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TrackDetails_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    TrackDetails_FullArgs {
      id: None,
      classificationMarking: None,
      env: TrackDetails_Full_env_Enum::AIR,
      msgType: None,
      hullNum: None,
      pif: None,
      sconum: None,
      ntds: None,
      disId: None,
      midbCat: None,
      beNumber: None,
      oSuffix: None,
      pin: None,
      lostTrkInd: false,
      muidSrcTrk: None,
      muidSrc: None,
      mslStatus: None,
      trkConf: 0.0,
      trkQual: 0,
      alert: None,
      origXref: None,
      elnot1: None,
      elnot2: None,
      objIdent: TrackDetails_Full_objIdent_Enum::ASSUMED_FRIEND,
      objType: None,
      objPlat: None,
      objAct: None,
      objNat: None,
      name: None,
      shortName: None,
      trkId: None,
      trkNum: None,
      trkScope: None,
      sourceUid: None,
      callSign: None,
      identAmp: None,
      spaceAmp: None,
      spaceAmpConf: 0,
      spaceSpecType: None,
      acftSubType: None,
      ts: None,
      launchTime: None,
      impactTime: None,
      ftnMsgTs: None,
      ftn: None,
      ftnCmd: None,
      rtnMsgTs: None,
      rtn: None,
      rtnTrkState: None,
      rtnCmd: None,
      sen: None,
      rptChxref: None,
      rptArchived: false,
      selfReport: false,
      mil2525Bstr: None,
      trnspdrId: None,
      trnspdrType: None,
      emitterName: None,
      infoSource: None,
      boosting: false,
      freq: 0.0,
      maxFreq: 0.0,
      harmonics: None,
      pri: 0.0,
      prf: 0.0,
      pw: 0.0,
      scanType: None,
      scanRate: 0.0,
      scn: 0,
      cI: None,
      angElev: 0.0,
      lat: 0.0,
      lon: 0.0,
      launchLat: 0.0,
      launchLon: 0.0,
      impactLat: 0.0,
      impactLon: 0.0,
      polarSingLocLat: 0.0,
      polarSingLocLon: 0.0,
      azCorrCenterLine: 0.0,
      azCorrArcWidth: 0.0,
      errSemiIntAxis: 0.0,
      errAreaOrient: 0.0,
      errSemiMajElev: 0.0,
      errGeoAreaSwitch: None,
      burnoutAlt: 0.0,
      tesEventId: None,
      spd: 0.0,
      avgSpd: 0.0,
      tol: 0.0,
      alt: 0.0,
      hdng: 0.0,
      course: 0.0,
      propRPM: 0.0,
      tpk: 0.0,
      coopLocInd: None,
      maneuverInd: None,
      launchAouType: None,
      launchAouData: None,
      impactAouType: None,
      impactAouData: None,
      aouRptType: None,
      aouRptData: None,
      ecefPos: None,
      ecefVel: None,
      containment: 0.0,
      cpa: 0.0,
      tcpa: None,
      navStatus: None,
      posDeviceType: None,
      aton: None,
      offPosInd: None,
      antennaRefDimensions: None,
      shipClass: None,
      imon: 0,
      mmsi: 0,
      draught: 0.0,
      length: 0.0,
      width: 0.0,
      cargoType: None,
      appGrp: None,
      hullProf: None,
      propType: None,
      numBlades: 0,
      numShafts: 0,
      sternType: None,
      vslWt: 0.0,
      arrTime: None,
      arrFlag: None,
      arrCargo: None,
      arrPort: None,
      depPort: None,
      depFlag: None,
      depCargo: None,
      desFlag: None,
      desCargo: None,
      destination: None,
      eta: None,
      etd: None,
      iff: None,
      emgInd: false,
      dropPtInd: false,
      reinforced: false,
      reduced: false,
      hq: false,
      dummy: false,
      taskForce: false,
      feint: false,
      installation: false,
      staffCmts: None,
      addInfo: None,
      evalRating: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: TrackDetails_Full_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}

pub struct TrackDetails_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TrackDetails_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_env(&mut self, env: TrackDetails_Full_env_Enum) {
    self.fbb_.push_slot::<TrackDetails_Full_env_Enum>(TrackDetails_Full::VT_ENV, env, TrackDetails_Full_env_Enum::AIR);
  }
  #[inline]
  pub fn add_msgType(&mut self, msgType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_MSGTYPE, msgType);
  }
  #[inline]
  pub fn add_hullNum(&mut self, hullNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_HULLNUM, hullNum);
  }
  #[inline]
  pub fn add_pif(&mut self, pif: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_PIF, pif);
  }
  #[inline]
  pub fn add_sconum(&mut self, sconum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_SCONUM, sconum);
  }
  #[inline]
  pub fn add_ntds(&mut self, ntds: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_NTDS, ntds);
  }
  #[inline]
  pub fn add_disId(&mut self, disId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_DISID, disId);
  }
  #[inline]
  pub fn add_midbCat(&mut self, midbCat: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_MIDBCAT, midbCat);
  }
  #[inline]
  pub fn add_beNumber(&mut self, beNumber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_BENUMBER, beNumber);
  }
  #[inline]
  pub fn add_oSuffix(&mut self, oSuffix: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_OSUFFIX, oSuffix);
  }
  #[inline]
  pub fn add_pin(&mut self, pin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_PIN, pin);
  }
  #[inline]
  pub fn add_lostTrkInd(&mut self, lostTrkInd: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_LOSTTRKIND, lostTrkInd, false);
  }
  #[inline]
  pub fn add_muidSrcTrk(&mut self, muidSrcTrk: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_MUIDSRCTRK, muidSrcTrk);
  }
  #[inline]
  pub fn add_muidSrc(&mut self, muidSrc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_MUIDSRC, muidSrc);
  }
  #[inline]
  pub fn add_mslStatus(&mut self, mslStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_MSLSTATUS, mslStatus);
  }
  #[inline]
  pub fn add_trkConf(&mut self, trkConf: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_TRKCONF, trkConf, 0.0);
  }
  #[inline]
  pub fn add_trkQual(&mut self, trkQual: i32) {
    self.fbb_.push_slot::<i32>(TrackDetails_Full::VT_TRKQUAL, trkQual, 0);
  }
  #[inline]
  pub fn add_alert(&mut self, alert: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ALERT, alert);
  }
  #[inline]
  pub fn add_origXref(&mut self, origXref: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ORIGXREF, origXref);
  }
  #[inline]
  pub fn add_elnot1(&mut self, elnot1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ELNOT1, elnot1);
  }
  #[inline]
  pub fn add_elnot2(&mut self, elnot2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ELNOT2, elnot2);
  }
  #[inline]
  pub fn add_objIdent(&mut self, objIdent: TrackDetails_Full_objIdent_Enum) {
    self.fbb_.push_slot::<TrackDetails_Full_objIdent_Enum>(TrackDetails_Full::VT_OBJIDENT, objIdent, TrackDetails_Full_objIdent_Enum::ASSUMED_FRIEND);
  }
  #[inline]
  pub fn add_objType(&mut self, objType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_OBJTYPE, objType);
  }
  #[inline]
  pub fn add_objPlat(&mut self, objPlat: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_OBJPLAT, objPlat);
  }
  #[inline]
  pub fn add_objAct(&mut self, objAct: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_OBJACT, objAct);
  }
  #[inline]
  pub fn add_objNat(&mut self, objNat: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_OBJNAT, objNat);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_NAME, name);
  }
  #[inline]
  pub fn add_shortName(&mut self, shortName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_SHORTNAME, shortName);
  }
  #[inline]
  pub fn add_trkId(&mut self, trkId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_TRKID, trkId);
  }
  #[inline]
  pub fn add_trkNum(&mut self, trkNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_TRKNUM, trkNum);
  }
  #[inline]
  pub fn add_trkScope(&mut self, trkScope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_TRKSCOPE, trkScope);
  }
  #[inline]
  pub fn add_sourceUid(&mut self, sourceUid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_SOURCEUID, sourceUid);
  }
  #[inline]
  pub fn add_callSign(&mut self, callSign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_CALLSIGN, callSign);
  }
  #[inline]
  pub fn add_identAmp(&mut self, identAmp: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_IDENTAMP, identAmp);
  }
  #[inline]
  pub fn add_spaceAmp(&mut self, spaceAmp: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_SPACEAMP, spaceAmp);
  }
  #[inline]
  pub fn add_spaceAmpConf(&mut self, spaceAmpConf: i32) {
    self.fbb_.push_slot::<i32>(TrackDetails_Full::VT_SPACEAMPCONF, spaceAmpConf, 0);
  }
  #[inline]
  pub fn add_spaceSpecType(&mut self, spaceSpecType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_SPACESPECTYPE, spaceSpecType);
  }
  #[inline]
  pub fn add_acftSubType(&mut self, acftSubType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ACFTSUBTYPE, acftSubType);
  }
  #[inline]
  pub fn add_ts(&mut self, ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_TS, ts);
  }
  #[inline]
  pub fn add_launchTime(&mut self, launchTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_LAUNCHTIME, launchTime);
  }
  #[inline]
  pub fn add_impactTime(&mut self, impactTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_IMPACTTIME, impactTime);
  }
  #[inline]
  pub fn add_ftnMsgTs(&mut self, ftnMsgTs: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_FTNMSGTS, ftnMsgTs);
  }
  #[inline]
  pub fn add_ftn(&mut self, ftn: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_FTN, ftn);
  }
  #[inline]
  pub fn add_ftnCmd(&mut self, ftnCmd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_FTNCMD, ftnCmd);
  }
  #[inline]
  pub fn add_rtnMsgTs(&mut self, rtnMsgTs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_RTNMSGTS, rtnMsgTs);
  }
  #[inline]
  pub fn add_rtn(&mut self, rtn: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_RTN, rtn);
  }
  #[inline]
  pub fn add_rtnTrkState(&mut self, rtnTrkState: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_RTNTRKSTATE, rtnTrkState);
  }
  #[inline]
  pub fn add_rtnCmd(&mut self, rtnCmd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_RTNCMD, rtnCmd);
  }
  #[inline]
  pub fn add_sen(&mut self, sen: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_SEN, sen);
  }
  #[inline]
  pub fn add_rptChxref(&mut self, rptChxref: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_RPTCHXREF, rptChxref);
  }
  #[inline]
  pub fn add_rptArchived(&mut self, rptArchived: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_RPTARCHIVED, rptArchived, false);
  }
  #[inline]
  pub fn add_selfReport(&mut self, selfReport: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_SELFREPORT, selfReport, false);
  }
  #[inline]
  pub fn add_mil2525Bstr(&mut self, mil2525Bstr: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_MIL2525BSTR, mil2525Bstr);
  }
  #[inline]
  pub fn add_trnspdrId(&mut self, trnspdrId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_TRNSPDRID, trnspdrId);
  }
  #[inline]
  pub fn add_trnspdrType(&mut self, trnspdrType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_TRNSPDRTYPE, trnspdrType);
  }
  #[inline]
  pub fn add_emitterName(&mut self, emitterName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_EMITTERNAME, emitterName);
  }
  #[inline]
  pub fn add_infoSource(&mut self, infoSource: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_INFOSOURCE, infoSource);
  }
  #[inline]
  pub fn add_boosting(&mut self, boosting: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_BOOSTING, boosting, false);
  }
  #[inline]
  pub fn add_freq(&mut self, freq: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_FREQ, freq, 0.0);
  }
  #[inline]
  pub fn add_maxFreq(&mut self, maxFreq: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_MAXFREQ, maxFreq, 0.0);
  }
  #[inline]
  pub fn add_harmonics(&mut self, harmonics: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_HARMONICS, harmonics);
  }
  #[inline]
  pub fn add_pri(&mut self, pri: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_PRI, pri, 0.0);
  }
  #[inline]
  pub fn add_prf(&mut self, prf: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_PRF, prf, 0.0);
  }
  #[inline]
  pub fn add_pw(&mut self, pw: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_PW, pw, 0.0);
  }
  #[inline]
  pub fn add_scanType(&mut self, scanType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_SCANTYPE, scanType);
  }
  #[inline]
  pub fn add_scanRate(&mut self, scanRate: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_SCANRATE, scanRate, 0.0);
  }
  #[inline]
  pub fn add_scn(&mut self, scn: i32) {
    self.fbb_.push_slot::<i32>(TrackDetails_Full::VT_SCN, scn, 0);
  }
  #[inline]
  pub fn add_cI(&mut self, cI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_CI, cI);
  }
  #[inline]
  pub fn add_angElev(&mut self, angElev: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_ANGELEV, angElev, 0.0);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_launchLat(&mut self, launchLat: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_LAUNCHLAT, launchLat, 0.0);
  }
  #[inline]
  pub fn add_launchLon(&mut self, launchLon: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_LAUNCHLON, launchLon, 0.0);
  }
  #[inline]
  pub fn add_impactLat(&mut self, impactLat: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_IMPACTLAT, impactLat, 0.0);
  }
  #[inline]
  pub fn add_impactLon(&mut self, impactLon: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_IMPACTLON, impactLon, 0.0);
  }
  #[inline]
  pub fn add_polarSingLocLat(&mut self, polarSingLocLat: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_POLARSINGLOCLAT, polarSingLocLat, 0.0);
  }
  #[inline]
  pub fn add_polarSingLocLon(&mut self, polarSingLocLon: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_POLARSINGLOCLON, polarSingLocLon, 0.0);
  }
  #[inline]
  pub fn add_azCorrCenterLine(&mut self, azCorrCenterLine: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_AZCORRCENTERLINE, azCorrCenterLine, 0.0);
  }
  #[inline]
  pub fn add_azCorrArcWidth(&mut self, azCorrArcWidth: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_AZCORRARCWIDTH, azCorrArcWidth, 0.0);
  }
  #[inline]
  pub fn add_errSemiIntAxis(&mut self, errSemiIntAxis: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_ERRSEMIINTAXIS, errSemiIntAxis, 0.0);
  }
  #[inline]
  pub fn add_errAreaOrient(&mut self, errAreaOrient: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_ERRAREAORIENT, errAreaOrient, 0.0);
  }
  #[inline]
  pub fn add_errSemiMajElev(&mut self, errSemiMajElev: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_ERRSEMIMAJELEV, errSemiMajElev, 0.0);
  }
  #[inline]
  pub fn add_errGeoAreaSwitch(&mut self, errGeoAreaSwitch: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ERRGEOAREASWITCH, errGeoAreaSwitch);
  }
  #[inline]
  pub fn add_burnoutAlt(&mut self, burnoutAlt: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_BURNOUTALT, burnoutAlt, 0.0);
  }
  #[inline]
  pub fn add_tesEventId(&mut self, tesEventId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_TESEVENTID, tesEventId);
  }
  #[inline]
  pub fn add_spd(&mut self, spd: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_SPD, spd, 0.0);
  }
  #[inline]
  pub fn add_avgSpd(&mut self, avgSpd: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_AVGSPD, avgSpd, 0.0);
  }
  #[inline]
  pub fn add_tol(&mut self, tol: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_TOL, tol, 0.0);
  }
  #[inline]
  pub fn add_alt(&mut self, alt: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_ALT, alt, 0.0);
  }
  #[inline]
  pub fn add_hdng(&mut self, hdng: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_HDNG, hdng, 0.0);
  }
  #[inline]
  pub fn add_course(&mut self, course: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_COURSE, course, 0.0);
  }
  #[inline]
  pub fn add_propRPM(&mut self, propRPM: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_PROPRPM, propRPM, 0.0);
  }
  #[inline]
  pub fn add_tpk(&mut self, tpk: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_TPK, tpk, 0.0);
  }
  #[inline]
  pub fn add_coopLocInd(&mut self, coopLocInd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_COOPLOCIND, coopLocInd);
  }
  #[inline]
  pub fn add_maneuverInd(&mut self, maneuverInd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_MANEUVERIND, maneuverInd);
  }
  #[inline]
  pub fn add_launchAouType(&mut self, launchAouType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_LAUNCHAOUTYPE, launchAouType);
  }
  #[inline]
  pub fn add_launchAouData(&mut self, launchAouData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_LAUNCHAOUDATA, launchAouData);
  }
  #[inline]
  pub fn add_impactAouType(&mut self, impactAouType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_IMPACTAOUTYPE, impactAouType);
  }
  #[inline]
  pub fn add_impactAouData(&mut self, impactAouData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_IMPACTAOUDATA, impactAouData);
  }
  #[inline]
  pub fn add_aouRptType(&mut self, aouRptType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_AOURPTTYPE, aouRptType);
  }
  #[inline]
  pub fn add_aouRptData(&mut self, aouRptData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_AOURPTDATA, aouRptData);
  }
  #[inline]
  pub fn add_ecefPos(&mut self, ecefPos: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ECEFPOS, ecefPos);
  }
  #[inline]
  pub fn add_ecefVel(&mut self, ecefVel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ECEFVEL, ecefVel);
  }
  #[inline]
  pub fn add_containment(&mut self, containment: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_CONTAINMENT, containment, 0.0);
  }
  #[inline]
  pub fn add_cpa(&mut self, cpa: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_CPA, cpa, 0.0);
  }
  #[inline]
  pub fn add_tcpa(&mut self, tcpa: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_TCPA, tcpa);
  }
  #[inline]
  pub fn add_navStatus(&mut self, navStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_NAVSTATUS, navStatus);
  }
  #[inline]
  pub fn add_posDeviceType(&mut self, posDeviceType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_POSDEVICETYPE, posDeviceType);
  }
  #[inline]
  pub fn add_aton(&mut self, aton: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ATON, aton);
  }
  #[inline]
  pub fn add_offPosInd(&mut self, offPosInd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_OFFPOSIND, offPosInd);
  }
  #[inline]
  pub fn add_antennaRefDimensions(&mut self, antennaRefDimensions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ANTENNAREFDIMENSIONS, antennaRefDimensions);
  }
  #[inline]
  pub fn add_shipClass(&mut self, shipClass: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_SHIPCLASS, shipClass);
  }
  #[inline]
  pub fn add_imon(&mut self, imon: i32) {
    self.fbb_.push_slot::<i32>(TrackDetails_Full::VT_IMON, imon, 0);
  }
  #[inline]
  pub fn add_mmsi(&mut self, mmsi: i32) {
    self.fbb_.push_slot::<i32>(TrackDetails_Full::VT_MMSI, mmsi, 0);
  }
  #[inline]
  pub fn add_draught(&mut self, draught: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_DRAUGHT, draught, 0.0);
  }
  #[inline]
  pub fn add_length(&mut self, length: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_LENGTH, length, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_cargoType(&mut self, cargoType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_CARGOTYPE, cargoType);
  }
  #[inline]
  pub fn add_appGrp(&mut self, appGrp: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_APPGRP, appGrp);
  }
  #[inline]
  pub fn add_hullProf(&mut self, hullProf: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_HULLPROF, hullProf);
  }
  #[inline]
  pub fn add_propType(&mut self, propType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_PROPTYPE, propType);
  }
  #[inline]
  pub fn add_numBlades(&mut self, numBlades: i32) {
    self.fbb_.push_slot::<i32>(TrackDetails_Full::VT_NUMBLADES, numBlades, 0);
  }
  #[inline]
  pub fn add_numShafts(&mut self, numShafts: i32) {
    self.fbb_.push_slot::<i32>(TrackDetails_Full::VT_NUMSHAFTS, numShafts, 0);
  }
  #[inline]
  pub fn add_sternType(&mut self, sternType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_STERNTYPE, sternType);
  }
  #[inline]
  pub fn add_vslWt(&mut self, vslWt: f64) {
    self.fbb_.push_slot::<f64>(TrackDetails_Full::VT_VSLWT, vslWt, 0.0);
  }
  #[inline]
  pub fn add_arrTime(&mut self, arrTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ARRTIME, arrTime);
  }
  #[inline]
  pub fn add_arrFlag(&mut self, arrFlag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ARRFLAG, arrFlag);
  }
  #[inline]
  pub fn add_arrCargo(&mut self, arrCargo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ARRCARGO, arrCargo);
  }
  #[inline]
  pub fn add_arrPort(&mut self, arrPort: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ARRPORT, arrPort);
  }
  #[inline]
  pub fn add_depPort(&mut self, depPort: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_DEPPORT, depPort);
  }
  #[inline]
  pub fn add_depFlag(&mut self, depFlag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_DEPFLAG, depFlag);
  }
  #[inline]
  pub fn add_depCargo(&mut self, depCargo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_DEPCARGO, depCargo);
  }
  #[inline]
  pub fn add_desFlag(&mut self, desFlag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_DESFLAG, desFlag);
  }
  #[inline]
  pub fn add_desCargo(&mut self, desCargo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_DESCARGO, desCargo);
  }
  #[inline]
  pub fn add_destination(&mut self, destination: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_DESTINATION, destination);
  }
  #[inline]
  pub fn add_eta(&mut self, eta: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ETA, eta);
  }
  #[inline]
  pub fn add_etd(&mut self, etd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ETD, etd);
  }
  #[inline]
  pub fn add_iff(&mut self, iff: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_IFF, iff);
  }
  #[inline]
  pub fn add_emgInd(&mut self, emgInd: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_EMGIND, emgInd, false);
  }
  #[inline]
  pub fn add_dropPtInd(&mut self, dropPtInd: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_DROPPTIND, dropPtInd, false);
  }
  #[inline]
  pub fn add_reinforced(&mut self, reinforced: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_REINFORCED, reinforced, false);
  }
  #[inline]
  pub fn add_reduced(&mut self, reduced: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_REDUCED, reduced, false);
  }
  #[inline]
  pub fn add_hq(&mut self, hq: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_HQ, hq, false);
  }
  #[inline]
  pub fn add_dummy(&mut self, dummy: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_DUMMY, dummy, false);
  }
  #[inline]
  pub fn add_taskForce(&mut self, taskForce: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_TASKFORCE, taskForce, false);
  }
  #[inline]
  pub fn add_feint(&mut self, feint: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_FEINT, feint, false);
  }
  #[inline]
  pub fn add_installation(&mut self, installation: bool) {
    self.fbb_.push_slot::<bool>(TrackDetails_Full::VT_INSTALLATION, installation, false);
  }
  #[inline]
  pub fn add_staffCmts(&mut self, staffCmts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_STAFFCMTS, staffCmts);
  }
  #[inline]
  pub fn add_addInfo(&mut self, addInfo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ADDINFO, addInfo);
  }
  #[inline]
  pub fn add_evalRating(&mut self, evalRating: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_EVALRATING, evalRating);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: TrackDetails_Full_dataMode_Enum) {
    self.fbb_.push_slot::<TrackDetails_Full_dataMode_Enum>(TrackDetails_Full::VT_DATAMODE, dataMode, TrackDetails_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackDetails_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TrackDetails_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TrackDetails_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TrackDetails_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TrackDetails_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TrackDetails_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("env", &self.env());
      ds.field("msgType", &self.msgType());
      ds.field("hullNum", &self.hullNum());
      ds.field("pif", &self.pif());
      ds.field("sconum", &self.sconum());
      ds.field("ntds", &self.ntds());
      ds.field("disId", &self.disId());
      ds.field("midbCat", &self.midbCat());
      ds.field("beNumber", &self.beNumber());
      ds.field("oSuffix", &self.oSuffix());
      ds.field("pin", &self.pin());
      ds.field("lostTrkInd", &self.lostTrkInd());
      ds.field("muidSrcTrk", &self.muidSrcTrk());
      ds.field("muidSrc", &self.muidSrc());
      ds.field("mslStatus", &self.mslStatus());
      ds.field("trkConf", &self.trkConf());
      ds.field("trkQual", &self.trkQual());
      ds.field("alert", &self.alert());
      ds.field("origXref", &self.origXref());
      ds.field("elnot1", &self.elnot1());
      ds.field("elnot2", &self.elnot2());
      ds.field("objIdent", &self.objIdent());
      ds.field("objType", &self.objType());
      ds.field("objPlat", &self.objPlat());
      ds.field("objAct", &self.objAct());
      ds.field("objNat", &self.objNat());
      ds.field("name", &self.name());
      ds.field("shortName", &self.shortName());
      ds.field("trkId", &self.trkId());
      ds.field("trkNum", &self.trkNum());
      ds.field("trkScope", &self.trkScope());
      ds.field("sourceUid", &self.sourceUid());
      ds.field("callSign", &self.callSign());
      ds.field("identAmp", &self.identAmp());
      ds.field("spaceAmp", &self.spaceAmp());
      ds.field("spaceAmpConf", &self.spaceAmpConf());
      ds.field("spaceSpecType", &self.spaceSpecType());
      ds.field("acftSubType", &self.acftSubType());
      ds.field("ts", &self.ts());
      ds.field("launchTime", &self.launchTime());
      ds.field("impactTime", &self.impactTime());
      ds.field("ftnMsgTs", &self.ftnMsgTs());
      ds.field("ftn", &self.ftn());
      ds.field("ftnCmd", &self.ftnCmd());
      ds.field("rtnMsgTs", &self.rtnMsgTs());
      ds.field("rtn", &self.rtn());
      ds.field("rtnTrkState", &self.rtnTrkState());
      ds.field("rtnCmd", &self.rtnCmd());
      ds.field("sen", &self.sen());
      ds.field("rptChxref", &self.rptChxref());
      ds.field("rptArchived", &self.rptArchived());
      ds.field("selfReport", &self.selfReport());
      ds.field("mil2525Bstr", &self.mil2525Bstr());
      ds.field("trnspdrId", &self.trnspdrId());
      ds.field("trnspdrType", &self.trnspdrType());
      ds.field("emitterName", &self.emitterName());
      ds.field("infoSource", &self.infoSource());
      ds.field("boosting", &self.boosting());
      ds.field("freq", &self.freq());
      ds.field("maxFreq", &self.maxFreq());
      ds.field("harmonics", &self.harmonics());
      ds.field("pri", &self.pri());
      ds.field("prf", &self.prf());
      ds.field("pw", &self.pw());
      ds.field("scanType", &self.scanType());
      ds.field("scanRate", &self.scanRate());
      ds.field("scn", &self.scn());
      ds.field("cI", &self.cI());
      ds.field("angElev", &self.angElev());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("launchLat", &self.launchLat());
      ds.field("launchLon", &self.launchLon());
      ds.field("impactLat", &self.impactLat());
      ds.field("impactLon", &self.impactLon());
      ds.field("polarSingLocLat", &self.polarSingLocLat());
      ds.field("polarSingLocLon", &self.polarSingLocLon());
      ds.field("azCorrCenterLine", &self.azCorrCenterLine());
      ds.field("azCorrArcWidth", &self.azCorrArcWidth());
      ds.field("errSemiIntAxis", &self.errSemiIntAxis());
      ds.field("errAreaOrient", &self.errAreaOrient());
      ds.field("errSemiMajElev", &self.errSemiMajElev());
      ds.field("errGeoAreaSwitch", &self.errGeoAreaSwitch());
      ds.field("burnoutAlt", &self.burnoutAlt());
      ds.field("tesEventId", &self.tesEventId());
      ds.field("spd", &self.spd());
      ds.field("avgSpd", &self.avgSpd());
      ds.field("tol", &self.tol());
      ds.field("alt", &self.alt());
      ds.field("hdng", &self.hdng());
      ds.field("course", &self.course());
      ds.field("propRPM", &self.propRPM());
      ds.field("tpk", &self.tpk());
      ds.field("coopLocInd", &self.coopLocInd());
      ds.field("maneuverInd", &self.maneuverInd());
      ds.field("launchAouType", &self.launchAouType());
      ds.field("launchAouData", &self.launchAouData());
      ds.field("impactAouType", &self.impactAouType());
      ds.field("impactAouData", &self.impactAouData());
      ds.field("aouRptType", &self.aouRptType());
      ds.field("aouRptData", &self.aouRptData());
      ds.field("ecefPos", &self.ecefPos());
      ds.field("ecefVel", &self.ecefVel());
      ds.field("containment", &self.containment());
      ds.field("cpa", &self.cpa());
      ds.field("tcpa", &self.tcpa());
      ds.field("navStatus", &self.navStatus());
      ds.field("posDeviceType", &self.posDeviceType());
      ds.field("aton", &self.aton());
      ds.field("offPosInd", &self.offPosInd());
      ds.field("antennaRefDimensions", &self.antennaRefDimensions());
      ds.field("shipClass", &self.shipClass());
      ds.field("imon", &self.imon());
      ds.field("mmsi", &self.mmsi());
      ds.field("draught", &self.draught());
      ds.field("length", &self.length());
      ds.field("width", &self.width());
      ds.field("cargoType", &self.cargoType());
      ds.field("appGrp", &self.appGrp());
      ds.field("hullProf", &self.hullProf());
      ds.field("propType", &self.propType());
      ds.field("numBlades", &self.numBlades());
      ds.field("numShafts", &self.numShafts());
      ds.field("sternType", &self.sternType());
      ds.field("vslWt", &self.vslWt());
      ds.field("arrTime", &self.arrTime());
      ds.field("arrFlag", &self.arrFlag());
      ds.field("arrCargo", &self.arrCargo());
      ds.field("arrPort", &self.arrPort());
      ds.field("depPort", &self.depPort());
      ds.field("depFlag", &self.depFlag());
      ds.field("depCargo", &self.depCargo());
      ds.field("desFlag", &self.desFlag());
      ds.field("desCargo", &self.desCargo());
      ds.field("destination", &self.destination());
      ds.field("eta", &self.eta());
      ds.field("etd", &self.etd());
      ds.field("iff", &self.iff());
      ds.field("emgInd", &self.emgInd());
      ds.field("dropPtInd", &self.dropPtInd());
      ds.field("reinforced", &self.reinforced());
      ds.field("reduced", &self.reduced());
      ds.field("hq", &self.hq());
      ds.field("dummy", &self.dummy());
      ds.field("taskForce", &self.taskForce());
      ds.field("feint", &self.feint());
      ds.field("installation", &self.installation());
      ds.field("staffCmts", &self.staffCmts());
      ds.field("addInfo", &self.addInfo());
      ds.field("evalRating", &self.evalRating());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TrackDetails_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub env: TrackDetails_Full_env_Enum,
  pub msgType: Option<String>,
  pub hullNum: Option<String>,
  pub pif: Option<String>,
  pub sconum: Option<String>,
  pub ntds: Option<String>,
  pub disId: Option<String>,
  pub midbCat: Option<String>,
  pub beNumber: Option<String>,
  pub oSuffix: Option<String>,
  pub pin: Option<String>,
  pub lostTrkInd: bool,
  pub muidSrcTrk: Option<String>,
  pub muidSrc: Option<String>,
  pub mslStatus: Option<String>,
  pub trkConf: f64,
  pub trkQual: i32,
  pub alert: Option<String>,
  pub origXref: Option<String>,
  pub elnot1: Option<String>,
  pub elnot2: Option<String>,
  pub objIdent: TrackDetails_Full_objIdent_Enum,
  pub objType: Option<String>,
  pub objPlat: Option<String>,
  pub objAct: Option<String>,
  pub objNat: Option<String>,
  pub name: Option<String>,
  pub shortName: Option<String>,
  pub trkId: Option<String>,
  pub trkNum: Option<String>,
  pub trkScope: Option<String>,
  pub sourceUid: Option<String>,
  pub callSign: Option<String>,
  pub identAmp: Option<String>,
  pub spaceAmp: Option<String>,
  pub spaceAmpConf: i32,
  pub spaceSpecType: Option<String>,
  pub acftSubType: Option<String>,
  pub ts: Option<String>,
  pub launchTime: Option<String>,
  pub impactTime: Option<String>,
  pub ftnMsgTs: Option<String>,
  pub ftn: Option<String>,
  pub ftnCmd: Option<String>,
  pub rtnMsgTs: Option<Vec<String>>,
  pub rtn: Option<Vec<String>>,
  pub rtnTrkState: Option<String>,
  pub rtnCmd: Option<String>,
  pub sen: Option<String>,
  pub rptChxref: Option<String>,
  pub rptArchived: bool,
  pub selfReport: bool,
  pub mil2525Bstr: Option<String>,
  pub trnspdrId: Option<String>,
  pub trnspdrType: Option<String>,
  pub emitterName: Option<String>,
  pub infoSource: Option<String>,
  pub boosting: bool,
  pub freq: f64,
  pub maxFreq: f64,
  pub harmonics: Option<String>,
  pub pri: f64,
  pub prf: f64,
  pub pw: f64,
  pub scanType: Option<String>,
  pub scanRate: f64,
  pub scn: i32,
  pub cI: Option<String>,
  pub angElev: f64,
  pub lat: f64,
  pub lon: f64,
  pub launchLat: f64,
  pub launchLon: f64,
  pub impactLat: f64,
  pub impactLon: f64,
  pub polarSingLocLat: f64,
  pub polarSingLocLon: f64,
  pub azCorrCenterLine: f64,
  pub azCorrArcWidth: f64,
  pub errSemiIntAxis: f64,
  pub errAreaOrient: f64,
  pub errSemiMajElev: f64,
  pub errGeoAreaSwitch: Option<String>,
  pub burnoutAlt: f64,
  pub tesEventId: Option<String>,
  pub spd: f64,
  pub avgSpd: f64,
  pub tol: f64,
  pub alt: f64,
  pub hdng: f64,
  pub course: f64,
  pub propRPM: f64,
  pub tpk: f64,
  pub coopLocInd: Option<String>,
  pub maneuverInd: Option<String>,
  pub launchAouType: Option<String>,
  pub launchAouData: Option<Vec<String>>,
  pub impactAouType: Option<String>,
  pub impactAouData: Option<Vec<String>>,
  pub aouRptType: Option<String>,
  pub aouRptData: Option<Vec<String>>,
  pub ecefPos: Option<Vec<String>>,
  pub ecefVel: Option<Vec<String>>,
  pub containment: f64,
  pub cpa: f64,
  pub tcpa: Option<String>,
  pub navStatus: Option<String>,
  pub posDeviceType: Option<String>,
  pub aton: Option<String>,
  pub offPosInd: Option<String>,
  pub antennaRefDimensions: Option<Vec<String>>,
  pub shipClass: Option<String>,
  pub imon: i32,
  pub mmsi: i32,
  pub draught: f64,
  pub length: f64,
  pub width: f64,
  pub cargoType: Option<String>,
  pub appGrp: Option<String>,
  pub hullProf: Option<String>,
  pub propType: Option<String>,
  pub numBlades: i32,
  pub numShafts: i32,
  pub sternType: Option<String>,
  pub vslWt: f64,
  pub arrTime: Option<String>,
  pub arrFlag: Option<String>,
  pub arrCargo: Option<String>,
  pub arrPort: Option<String>,
  pub depPort: Option<String>,
  pub depFlag: Option<String>,
  pub depCargo: Option<String>,
  pub desFlag: Option<String>,
  pub desCargo: Option<String>,
  pub destination: Option<String>,
  pub eta: Option<String>,
  pub etd: Option<String>,
  pub iff: Option<String>,
  pub emgInd: bool,
  pub dropPtInd: bool,
  pub reinforced: bool,
  pub reduced: bool,
  pub hq: bool,
  pub dummy: bool,
  pub taskForce: bool,
  pub feint: bool,
  pub installation: bool,
  pub staffCmts: Option<String>,
  pub addInfo: Option<String>,
  pub evalRating: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: TrackDetails_Full_dataMode_Enum,
  pub origNetwork: Option<String>,
}
impl Default for TrackDetails_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      env: TrackDetails_Full_env_Enum::AIR,
      msgType: None,
      hullNum: None,
      pif: None,
      sconum: None,
      ntds: None,
      disId: None,
      midbCat: None,
      beNumber: None,
      oSuffix: None,
      pin: None,
      lostTrkInd: false,
      muidSrcTrk: None,
      muidSrc: None,
      mslStatus: None,
      trkConf: 0.0,
      trkQual: 0,
      alert: None,
      origXref: None,
      elnot1: None,
      elnot2: None,
      objIdent: TrackDetails_Full_objIdent_Enum::ASSUMED_FRIEND,
      objType: None,
      objPlat: None,
      objAct: None,
      objNat: None,
      name: None,
      shortName: None,
      trkId: None,
      trkNum: None,
      trkScope: None,
      sourceUid: None,
      callSign: None,
      identAmp: None,
      spaceAmp: None,
      spaceAmpConf: 0,
      spaceSpecType: None,
      acftSubType: None,
      ts: None,
      launchTime: None,
      impactTime: None,
      ftnMsgTs: None,
      ftn: None,
      ftnCmd: None,
      rtnMsgTs: None,
      rtn: None,
      rtnTrkState: None,
      rtnCmd: None,
      sen: None,
      rptChxref: None,
      rptArchived: false,
      selfReport: false,
      mil2525Bstr: None,
      trnspdrId: None,
      trnspdrType: None,
      emitterName: None,
      infoSource: None,
      boosting: false,
      freq: 0.0,
      maxFreq: 0.0,
      harmonics: None,
      pri: 0.0,
      prf: 0.0,
      pw: 0.0,
      scanType: None,
      scanRate: 0.0,
      scn: 0,
      cI: None,
      angElev: 0.0,
      lat: 0.0,
      lon: 0.0,
      launchLat: 0.0,
      launchLon: 0.0,
      impactLat: 0.0,
      impactLon: 0.0,
      polarSingLocLat: 0.0,
      polarSingLocLon: 0.0,
      azCorrCenterLine: 0.0,
      azCorrArcWidth: 0.0,
      errSemiIntAxis: 0.0,
      errAreaOrient: 0.0,
      errSemiMajElev: 0.0,
      errGeoAreaSwitch: None,
      burnoutAlt: 0.0,
      tesEventId: None,
      spd: 0.0,
      avgSpd: 0.0,
      tol: 0.0,
      alt: 0.0,
      hdng: 0.0,
      course: 0.0,
      propRPM: 0.0,
      tpk: 0.0,
      coopLocInd: None,
      maneuverInd: None,
      launchAouType: None,
      launchAouData: None,
      impactAouType: None,
      impactAouData: None,
      aouRptType: None,
      aouRptData: None,
      ecefPos: None,
      ecefVel: None,
      containment: 0.0,
      cpa: 0.0,
      tcpa: None,
      navStatus: None,
      posDeviceType: None,
      aton: None,
      offPosInd: None,
      antennaRefDimensions: None,
      shipClass: None,
      imon: 0,
      mmsi: 0,
      draught: 0.0,
      length: 0.0,
      width: 0.0,
      cargoType: None,
      appGrp: None,
      hullProf: None,
      propType: None,
      numBlades: 0,
      numShafts: 0,
      sternType: None,
      vslWt: 0.0,
      arrTime: None,
      arrFlag: None,
      arrCargo: None,
      arrPort: None,
      depPort: None,
      depFlag: None,
      depCargo: None,
      desFlag: None,
      desCargo: None,
      destination: None,
      eta: None,
      etd: None,
      iff: None,
      emgInd: false,
      dropPtInd: false,
      reinforced: false,
      reduced: false,
      hq: false,
      dummy: false,
      taskForce: false,
      feint: false,
      installation: false,
      staffCmts: None,
      addInfo: None,
      evalRating: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: TrackDetails_Full_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}
impl TrackDetails_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TrackDetails_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let env = self.env;
    let msgType = self.msgType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let hullNum = self.hullNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pif = self.pif.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sconum = self.sconum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ntds = self.ntds.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let disId = self.disId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let midbCat = self.midbCat.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let beNumber = self.beNumber.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let oSuffix = self.oSuffix.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pin = self.pin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lostTrkInd = self.lostTrkInd;
    let muidSrcTrk = self.muidSrcTrk.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let muidSrc = self.muidSrc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mslStatus = self.mslStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trkConf = self.trkConf;
    let trkQual = self.trkQual;
    let alert = self.alert.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origXref = self.origXref.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let elnot1 = self.elnot1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let elnot2 = self.elnot2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let objIdent = self.objIdent;
    let objType = self.objType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let objPlat = self.objPlat.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let objAct = self.objAct.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let objNat = self.objNat.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let shortName = self.shortName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trkId = self.trkId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trkNum = self.trkNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trkScope = self.trkScope.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceUid = self.sourceUid.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let callSign = self.callSign.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let identAmp = self.identAmp.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let spaceAmp = self.spaceAmp.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let spaceAmpConf = self.spaceAmpConf;
    let spaceSpecType = self.spaceSpecType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let acftSubType = self.acftSubType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ts = self.ts.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let launchTime = self.launchTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let impactTime = self.impactTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ftnMsgTs = self.ftnMsgTs.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ftn = self.ftn.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ftnCmd = self.ftnCmd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rtnMsgTs = self.rtnMsgTs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let rtn = self.rtn.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let rtnTrkState = self.rtnTrkState.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rtnCmd = self.rtnCmd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sen = self.sen.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rptChxref = self.rptChxref.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rptArchived = self.rptArchived;
    let selfReport = self.selfReport;
    let mil2525Bstr = self.mil2525Bstr.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trnspdrId = self.trnspdrId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trnspdrType = self.trnspdrType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let emitterName = self.emitterName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let infoSource = self.infoSource.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let boosting = self.boosting;
    let freq = self.freq;
    let maxFreq = self.maxFreq;
    let harmonics = self.harmonics.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pri = self.pri;
    let prf = self.prf;
    let pw = self.pw;
    let scanType = self.scanType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let scanRate = self.scanRate;
    let scn = self.scn;
    let cI = self.cI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let angElev = self.angElev;
    let lat = self.lat;
    let lon = self.lon;
    let launchLat = self.launchLat;
    let launchLon = self.launchLon;
    let impactLat = self.impactLat;
    let impactLon = self.impactLon;
    let polarSingLocLat = self.polarSingLocLat;
    let polarSingLocLon = self.polarSingLocLon;
    let azCorrCenterLine = self.azCorrCenterLine;
    let azCorrArcWidth = self.azCorrArcWidth;
    let errSemiIntAxis = self.errSemiIntAxis;
    let errAreaOrient = self.errAreaOrient;
    let errSemiMajElev = self.errSemiMajElev;
    let errGeoAreaSwitch = self.errGeoAreaSwitch.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let burnoutAlt = self.burnoutAlt;
    let tesEventId = self.tesEventId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let spd = self.spd;
    let avgSpd = self.avgSpd;
    let tol = self.tol;
    let alt = self.alt;
    let hdng = self.hdng;
    let course = self.course;
    let propRPM = self.propRPM;
    let tpk = self.tpk;
    let coopLocInd = self.coopLocInd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let maneuverInd = self.maneuverInd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let launchAouType = self.launchAouType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let launchAouData = self.launchAouData.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let impactAouType = self.impactAouType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let impactAouData = self.impactAouData.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let aouRptType = self.aouRptType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let aouRptData = self.aouRptData.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ecefPos = self.ecefPos.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ecefVel = self.ecefVel.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let containment = self.containment;
    let cpa = self.cpa;
    let tcpa = self.tcpa.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let navStatus = self.navStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let posDeviceType = self.posDeviceType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let aton = self.aton.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let offPosInd = self.offPosInd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let antennaRefDimensions = self.antennaRefDimensions.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let shipClass = self.shipClass.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let imon = self.imon;
    let mmsi = self.mmsi;
    let draught = self.draught;
    let length = self.length;
    let width = self.width;
    let cargoType = self.cargoType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let appGrp = self.appGrp.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let hullProf = self.hullProf.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let propType = self.propType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let numBlades = self.numBlades;
    let numShafts = self.numShafts;
    let sternType = self.sternType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let vslWt = self.vslWt;
    let arrTime = self.arrTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let arrFlag = self.arrFlag.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let arrCargo = self.arrCargo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let arrPort = self.arrPort.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let depPort = self.depPort.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let depFlag = self.depFlag.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let depCargo = self.depCargo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let desFlag = self.desFlag.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let desCargo = self.desCargo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let destination = self.destination.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eta = self.eta.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let etd = self.etd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let iff = self.iff.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let emgInd = self.emgInd;
    let dropPtInd = self.dropPtInd;
    let reinforced = self.reinforced;
    let reduced = self.reduced;
    let hq = self.hq;
    let dummy = self.dummy;
    let taskForce = self.taskForce;
    let feint = self.feint;
    let installation = self.installation;
    let staffCmts = self.staffCmts.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let addInfo = self.addInfo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let evalRating = self.evalRating.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    TrackDetails_Full::create(_fbb, &TrackDetails_FullArgs{
      id,
      classificationMarking,
      env,
      msgType,
      hullNum,
      pif,
      sconum,
      ntds,
      disId,
      midbCat,
      beNumber,
      oSuffix,
      pin,
      lostTrkInd,
      muidSrcTrk,
      muidSrc,
      mslStatus,
      trkConf,
      trkQual,
      alert,
      origXref,
      elnot1,
      elnot2,
      objIdent,
      objType,
      objPlat,
      objAct,
      objNat,
      name,
      shortName,
      trkId,
      trkNum,
      trkScope,
      sourceUid,
      callSign,
      identAmp,
      spaceAmp,
      spaceAmpConf,
      spaceSpecType,
      acftSubType,
      ts,
      launchTime,
      impactTime,
      ftnMsgTs,
      ftn,
      ftnCmd,
      rtnMsgTs,
      rtn,
      rtnTrkState,
      rtnCmd,
      sen,
      rptChxref,
      rptArchived,
      selfReport,
      mil2525Bstr,
      trnspdrId,
      trnspdrType,
      emitterName,
      infoSource,
      boosting,
      freq,
      maxFreq,
      harmonics,
      pri,
      prf,
      pw,
      scanType,
      scanRate,
      scn,
      cI,
      angElev,
      lat,
      lon,
      launchLat,
      launchLon,
      impactLat,
      impactLon,
      polarSingLocLat,
      polarSingLocLon,
      azCorrCenterLine,
      azCorrArcWidth,
      errSemiIntAxis,
      errAreaOrient,
      errSemiMajElev,
      errGeoAreaSwitch,
      burnoutAlt,
      tesEventId,
      spd,
      avgSpd,
      tol,
      alt,
      hdng,
      course,
      propRPM,
      tpk,
      coopLocInd,
      maneuverInd,
      launchAouType,
      launchAouData,
      impactAouType,
      impactAouData,
      aouRptType,
      aouRptData,
      ecefPos,
      ecefVel,
      containment,
      cpa,
      tcpa,
      navStatus,
      posDeviceType,
      aton,
      offPosInd,
      antennaRefDimensions,
      shipClass,
      imon,
      mmsi,
      draught,
      length,
      width,
      cargoType,
      appGrp,
      hullProf,
      propType,
      numBlades,
      numShafts,
      sternType,
      vslWt,
      arrTime,
      arrFlag,
      arrCargo,
      arrPort,
      depPort,
      depFlag,
      depCargo,
      desFlag,
      desCargo,
      destination,
      eta,
      etd,
      iff,
      emgInd,
      dropPtInd,
      reinforced,
      reduced,
      hq,
      dummy,
      taskForce,
      feint,
      installation,
      staffCmts,
      addInfo,
      evalRating,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TrackDetails_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_track_details_full_unchecked`.
pub fn root_as_track_details_full(buf: &[u8]) -> Result<TrackDetails_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TrackDetails_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TrackDetails_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_track_details_full_unchecked`.
pub fn size_prefixed_root_as_track_details_full(buf: &[u8]) -> Result<TrackDetails_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TrackDetails_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TrackDetails_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_track_details_full_unchecked`.
pub fn root_as_track_details_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TrackDetails_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TrackDetails_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TrackDetails_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_track_details_full_unchecked`.
pub fn size_prefixed_root_as_track_details_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TrackDetails_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TrackDetails_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TrackDetails_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TrackDetails_Full`.
pub unsafe fn root_as_track_details_full_unchecked(buf: &[u8]) -> TrackDetails_Full {
  flatbuffers::root_unchecked::<TrackDetails_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TrackDetails_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TrackDetails_Full`.
pub unsafe fn size_prefixed_root_as_track_details_full_unchecked(buf: &[u8]) -> TrackDetails_Full {
  flatbuffers::size_prefixed_root_unchecked::<TrackDetails_Full>(buf)
}
pub const TRACK_DETAILS_FULL_IDENTIFIER: &str = "TRAC";

#[inline]
pub fn track_details_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TRACK_DETAILS_FULL_IDENTIFIER, false)
}

#[inline]
pub fn track_details_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TRACK_DETAILS_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_track_details_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<TrackDetails_Full<'a>>) {
  fbb.finish(root, Some(TRACK_DETAILS_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_track_details_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<TrackDetails_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(TRACK_DETAILS_FULL_IDENTIFIER));
}
