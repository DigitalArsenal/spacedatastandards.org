// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum RadarSOIObservation_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// A Radar SOI record contains observation information taken from a sensor about a Space Object.
pub struct RadarSOIObservation_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RadarSOIObservation_Full<'a> {
  type Inner = RadarSOIObservation_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RadarSOIObservation_Full<'a> {
  pub const VT_OBSTARTTIME: flatbuffers::VOffsetT = 4;
  pub const VT_TOVS: flatbuffers::VOffsetT = 6;
  pub const VT_RSPACES: flatbuffers::VOffsetT = 8;
  pub const VT_XSPACES: flatbuffers::VOffsetT = 10;
  pub const VT_DOPPLER2XRS: flatbuffers::VOffsetT = 12;
  pub const VT_DELTATIMES: flatbuffers::VOffsetT = 14;
  pub const VT_ASPECTANGLES: flatbuffers::VOffsetT = 16;
  pub const VT_PROJANGVELS: flatbuffers::VOffsetT = 18;
  pub const VT_IDSTATEVECTOR: flatbuffers::VOffsetT = 20;
  pub const VT_IDATTITUDESET: flatbuffers::VOffsetT = 22;
  pub const VT_RANGES: flatbuffers::VOffsetT = 24;
  pub const VT_AZIMUTHS: flatbuffers::VOffsetT = 26;
  pub const VT_ELEVATIONS: flatbuffers::VOffsetT = 28;
  pub const VT_RANGERATES: flatbuffers::VOffsetT = 30;
  pub const VT_AZIMUTHRATES: flatbuffers::VOffsetT = 32;
  pub const VT_ELEVATIONRATES: flatbuffers::VOffsetT = 34;
  pub const VT_AZIMUTHBIASES: flatbuffers::VOffsetT = 36;
  pub const VT_ELEVATIONBIASES: flatbuffers::VOffsetT = 38;
  pub const VT_RANGEBIASES: flatbuffers::VOffsetT = 40;
  pub const VT_INTEGRATIONANGLES: flatbuffers::VOffsetT = 42;
  pub const VT_CROSSRANGERES: flatbuffers::VOffsetT = 44;
  pub const VT_BETA: flatbuffers::VOffsetT = 46;
  pub const VT_KAPPA: flatbuffers::VOffsetT = 48;
  pub const VT_PEAKAMPLITUDES: flatbuffers::VOffsetT = 50;
  pub const VT_CENTERFREQUENCY: flatbuffers::VOffsetT = 52;
  pub const VT_PULSEBANDWIDTH: flatbuffers::VOffsetT = 54;
  pub const VT_XPOS: flatbuffers::VOffsetT = 56;
  pub const VT_YPOS: flatbuffers::VOffsetT = 58;
  pub const VT_ZPOS: flatbuffers::VOffsetT = 60;
  pub const VT_XVEL: flatbuffers::VOffsetT = 62;
  pub const VT_YVEL: flatbuffers::VOffsetT = 64;
  pub const VT_ZVEL: flatbuffers::VOffsetT = 66;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RadarSOIObservation_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RadarSOIObservation_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<RadarSOIObservation_Full<'bldr>> {
    let mut builder = RadarSOIObservation_FullBuilder::new(_fbb);
    builder.add_pulseBandwidth(args.pulseBandwidth);
    builder.add_centerFrequency(args.centerFrequency);
    builder.add_kappa(args.kappa);
    builder.add_beta(args.beta);
    if let Some(x) = args.zvel { builder.add_zvel(x); }
    if let Some(x) = args.yvel { builder.add_yvel(x); }
    if let Some(x) = args.xvel { builder.add_xvel(x); }
    if let Some(x) = args.zpos { builder.add_zpos(x); }
    if let Some(x) = args.ypos { builder.add_ypos(x); }
    if let Some(x) = args.xpos { builder.add_xpos(x); }
    if let Some(x) = args.peakAmplitudes { builder.add_peakAmplitudes(x); }
    if let Some(x) = args.crossRangeRes { builder.add_crossRangeRes(x); }
    if let Some(x) = args.integrationAngles { builder.add_integrationAngles(x); }
    if let Some(x) = args.rangeBiases { builder.add_rangeBiases(x); }
    if let Some(x) = args.elevationBiases { builder.add_elevationBiases(x); }
    if let Some(x) = args.azimuthBiases { builder.add_azimuthBiases(x); }
    if let Some(x) = args.elevationRates { builder.add_elevationRates(x); }
    if let Some(x) = args.azimuthRates { builder.add_azimuthRates(x); }
    if let Some(x) = args.rangeRates { builder.add_rangeRates(x); }
    if let Some(x) = args.elevations { builder.add_elevations(x); }
    if let Some(x) = args.azimuths { builder.add_azimuths(x); }
    if let Some(x) = args.ranges { builder.add_ranges(x); }
    if let Some(x) = args.idAttitudeSet { builder.add_idAttitudeSet(x); }
    if let Some(x) = args.idStateVector { builder.add_idStateVector(x); }
    if let Some(x) = args.projAngVels { builder.add_projAngVels(x); }
    if let Some(x) = args.aspectAngles { builder.add_aspectAngles(x); }
    if let Some(x) = args.deltaTimes { builder.add_deltaTimes(x); }
    if let Some(x) = args.doppler2XRs { builder.add_doppler2XRs(x); }
    if let Some(x) = args.xspaces { builder.add_xspaces(x); }
    if let Some(x) = args.rspaces { builder.add_rspaces(x); }
    if let Some(x) = args.tovs { builder.add_tovs(x); }
    if let Some(x) = args.obStartTime { builder.add_obStartTime(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> RadarSOIObservation_FullT {
    let obStartTime = self.obStartTime().map(|x| {
      x.to_string()
    });
    let tovs = self.tovs().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let rspaces = self.rspaces().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let xspaces = self.xspaces().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let doppler2XRs = self.doppler2XRs().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let deltaTimes = self.deltaTimes().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let aspectAngles = self.aspectAngles().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let projAngVels = self.projAngVels().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let idStateVector = self.idStateVector().map(|x| {
      x.to_string()
    });
    let idAttitudeSet = self.idAttitudeSet().map(|x| {
      x.to_string()
    });
    let ranges = self.ranges().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let azimuths = self.azimuths().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let elevations = self.elevations().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let rangeRates = self.rangeRates().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let azimuthRates = self.azimuthRates().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let elevationRates = self.elevationRates().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let azimuthBiases = self.azimuthBiases().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let elevationBiases = self.elevationBiases().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let rangeBiases = self.rangeBiases().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let integrationAngles = self.integrationAngles().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let crossRangeRes = self.crossRangeRes().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let beta = self.beta();
    let kappa = self.kappa();
    let peakAmplitudes = self.peakAmplitudes().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let centerFrequency = self.centerFrequency();
    let pulseBandwidth = self.pulseBandwidth();
    let xpos = self.xpos().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ypos = self.ypos().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let zpos = self.zpos().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let xvel = self.xvel().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let yvel = self.yvel().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let zvel = self.zvel().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    RadarSOIObservation_FullT {
      obStartTime,
      tovs,
      rspaces,
      xspaces,
      doppler2XRs,
      deltaTimes,
      aspectAngles,
      projAngVels,
      idStateVector,
      idAttitudeSet,
      ranges,
      azimuths,
      elevations,
      rangeRates,
      azimuthRates,
      elevationRates,
      azimuthBiases,
      elevationBiases,
      rangeBiases,
      integrationAngles,
      crossRangeRes,
      beta,
      kappa,
      peakAmplitudes,
      centerFrequency,
      pulseBandwidth,
      xpos,
      ypos,
      zpos,
      xvel,
      yvel,
      zvel,
    }
  }

  /// Observation detection start time in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.888456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obStartTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RadarSOIObservation_Full::VT_OBSTARTTIME, None)}
  }
  /// Array of the times of validity in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: ['2018-01-01T16:00:00.888456Z', '2018-01-01T16:00:00.888456Z', '2018-01-01T16:00:00.888456Z']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tovs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_TOVS, None)}
  }
  /// Array of range sample spacing in meters. The 'tov' and 'rspace' arrays must match in size.
  /// Example: /// Example: [0.006, 0.006, 0.006]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rspaces(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_RSPACES, None)}
  }
  /// Array of cross-range sample spacing in meters. The 'tov' and 'xspace' arrays must match in size.
  /// Example: /// Example: [0.006, 0.006, 0.006]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xspaces(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_XSPACES, None)}
  }
  /// Array of conversion factors between Doppler in hertz and cross-range in meters. The 'tov' and 'doppler2XR' arrays must match in size.
  /// Example: /// Example: [5644.27, 5644.27, 5644.27]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn doppler2XRs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_DOPPLER2XRS, None)}
  }
  /// Array of average Interpulse spacing in seconds. The 'tov' and 'deltaTime' arrays must match in size.
  /// Example: /// Example: [0.005, 0.005, 0.005]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaTimes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_DELTATIMES, None)}
  }
  /// Array of the aspect angle at the center of the image in degrees.  The 'tov' and 'aspectAngle' arrays must match in size.
  /// Example: /// Example: [4.278, 4.278, 4.278]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn aspectAngles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_ASPECTANGLES, None)}
  }
  /// Array of the component of target angular velocity observable by radar in radians per second.  The 'tov' and 'projAngVel' arrays must match in size.
  /// Example: /// Example: [0.166, 0.166, 0.166]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn projAngVels(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_PROJANGVELS, None)}
  }
  /// Optional id of assumed StateVector of object being observed.
  /// Example: /// Example: 99a0de63-b38f-4d81-b057
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idStateVector(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RadarSOIObservation_Full::VT_IDSTATEVECTOR, None)}
  }
  /// Optional id of assumed AttitudeSet of object being observed.
  /// Example: /// Example: 99a0de63-b38f-4d81-b057
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idAttitudeSet(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RadarSOIObservation_Full::VT_IDATTITUDESET, None)}
  }
  /// Array of the range to target at image center in kilometers. The 'tov' and 'range' arrays must match in size.
  /// Example: /// Example: [877.938, 877.938, 877.938]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ranges(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_RANGES, None)}
  }
  /// Array of the azimuth angle to target at image center in degrees. The 'tov' and 'azimuth' arrays must match in size.
  /// Example: /// Example: [278.27, 278.27, 278.27]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn azimuths(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_AZIMUTHS, None)}
  }
  /// Array of the elevation angle to target at image center in degrees. The 'tov' and 'elevation' arrays must match in size.
  /// Example: /// Example: [70.85, 70.85, 70.85]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevations(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_ELEVATIONS, None)}
  }
  /// Array of the range rate of target at image center in kilometers per second. The 'tov' and 'rangeRate' arrays must match in size.
  /// Example: /// Example: [0.317, 0.317, 0.317]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rangeRates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_RANGERATES, None)}
  }
  /// Array of the azimuth rate of target at image center in degrees per second. The 'tov' and 'azimuthRate' arrays must match in size.
  /// Example: /// Example: [-1.481, -1.481, -1.481]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn azimuthRates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_AZIMUTHRATES, None)}
  }
  /// Array of the elevation rate of target at image center in degrees per second. The 'tov' and 'elevationRate' arrays must match in size.
  /// Example: /// Example: [-0.074, -0.074, -0.074]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevationRates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_ELEVATIONRATES, None)}
  }
  /// Array of  sensor azimuth angle biases in degrees. The 'tov' and 'azimuthBias' arrays must match in size.
  /// Example: /// Example: [45.23, 45.23, 45.23]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn azimuthBiases(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_AZIMUTHBIASES, None)}
  }
  /// Array of sensor elevation biases in degrees. The 'tov' and 'elevationBias' arrays must match in size.
  /// Example: /// Example: [1.23, 1.23, 1.23]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevationBiases(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_ELEVATIONBIASES, None)}
  }
  /// Array of sensor range biases in kilometers. The 'tov' and 'rangeBias' arrays must match in size.
  /// Example: /// Example: [1.23, 1.23, 1.23]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rangeBiases(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_RANGEBIASES, None)}
  }
  /// Array of Integration angles in degrees. The 'tov' and 'integrationAngle' arrays must match in size.
  /// Example: /// Example: [8.594, 8.594, 8.594]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn integrationAngles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_INTEGRATIONANGLES, None)}
  }
  /// Array of cross-range resolutions (accounting for weighting function) in kilometers. The 'tov' and 'crossRangeRes' arrays must match in size.
  /// Example: /// Example: [11.301, 11.301, 11.301]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn crossRangeRes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_CROSSRANGERES, None)}
  }
  /// Beta angle (between target and radar-image frame z axis) in degrees.
  /// Example: /// Example: -89.97
  /// Constraints: No constraints specified.
  #[inline]
  pub fn beta(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RadarSOIObservation_Full::VT_BETA, Some(0.0)).unwrap()}
  }
  /// Kappa angle (between radar-line-of-sight and target-frame x axis) in degrees.
  /// Example: /// Example: 103.04
  /// Constraints: No constraints specified.
  #[inline]
  pub fn kappa(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RadarSOIObservation_Full::VT_KAPPA, Some(0.0)).unwrap()}
  }
  /// Array of the peak pixel amplitude for each image in decibels. The 'tov' and 'peakAmplitude' arrays must match in size.
  /// Example: /// Example: [33.1, 33.1, 33.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn peakAmplitudes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_PEAKAMPLITUDES, None)}
  }
  /// Radar center frequency of the radar in hertz.
  /// Example: /// Example: 160047.0625
  /// Constraints: No constraints specified.
  #[inline]
  pub fn centerFrequency(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RadarSOIObservation_Full::VT_CENTERFREQUENCY, Some(0.0)).unwrap()}
  }
  /// Bandwidth of radar pulse in hertz.
  /// Example: /// Example: 24094.12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pulseBandwidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RadarSOIObservation_Full::VT_PULSEBANDWIDTH, Some(0.0)).unwrap()}
  }
  /// Array of the cartesian X positions of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'xpos' arrays must match in size.
  /// Example: /// Example: [-1118.577381, -1118.577381, -1118.577381]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xpos(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_XPOS, None)}
  }
  /// Array of the cartesian Y positions of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'ypos' arrays must match in size.
  /// Example: /// Example: [3026.231084, 3026.231084, 3026.231084]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ypos(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_YPOS, None)}
  }
  /// Array of the cartesian Z positions of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'zpos' arrays must match in size.
  /// Example: /// Example: [6167.831808, 6167.831808, 6167.831808]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zpos(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_ZPOS, None)}
  }
  /// Array of the cartesian X velocities of target, in kilometers per second, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed. The 'tov' and 'xvel' arrays must match in size.
  /// Example: /// Example: [-4.25242784, -4.25242784, -4.25242784]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xvel(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_XVEL, None)}
  }
  /// Array of the cartesian Y velocities of target, in kilometers per second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed. The 'tov' and 'yvel' arrays must match in size.
  /// Example: /// Example: [5.291107434, 5.291107434, 5.291107434]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yvel(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_YVEL, None)}
  }
  /// Array of the cartesian Z velocities of target, in kilometers per second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed. The 'tov' and 'zvel' arrays must match in size.
  /// Example: /// Example: [-3.356493869, -3.356493869, -3.356493869]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zvel(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RadarSOIObservation_Full::VT_ZVEL, None)}
  }
}

impl flatbuffers::Verifiable for RadarSOIObservation_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("obStartTime", Self::VT_OBSTARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tovs", Self::VT_TOVS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("rspaces", Self::VT_RSPACES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("xspaces", Self::VT_XSPACES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("doppler2XRs", Self::VT_DOPPLER2XRS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("deltaTimes", Self::VT_DELTATIMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("aspectAngles", Self::VT_ASPECTANGLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("projAngVels", Self::VT_PROJANGVELS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idStateVector", Self::VT_IDSTATEVECTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idAttitudeSet", Self::VT_IDATTITUDESET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ranges", Self::VT_RANGES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("azimuths", Self::VT_AZIMUTHS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("elevations", Self::VT_ELEVATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("rangeRates", Self::VT_RANGERATES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("azimuthRates", Self::VT_AZIMUTHRATES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("elevationRates", Self::VT_ELEVATIONRATES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("azimuthBiases", Self::VT_AZIMUTHBIASES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("elevationBiases", Self::VT_ELEVATIONBIASES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("rangeBiases", Self::VT_RANGEBIASES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("integrationAngles", Self::VT_INTEGRATIONANGLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("crossRangeRes", Self::VT_CROSSRANGERES, false)?
     .visit_field::<f64>("beta", Self::VT_BETA, false)?
     .visit_field::<f64>("kappa", Self::VT_KAPPA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("peakAmplitudes", Self::VT_PEAKAMPLITUDES, false)?
     .visit_field::<f64>("centerFrequency", Self::VT_CENTERFREQUENCY, false)?
     .visit_field::<f64>("pulseBandwidth", Self::VT_PULSEBANDWIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("xpos", Self::VT_XPOS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ypos", Self::VT_YPOS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("zpos", Self::VT_ZPOS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("xvel", Self::VT_XVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("yvel", Self::VT_YVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("zvel", Self::VT_ZVEL, false)?
     .finish();
    Ok(())
  }
}
pub struct RadarSOIObservation_FullArgs<'a> {
    pub obStartTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tovs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub rspaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub xspaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub doppler2XRs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub deltaTimes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub aspectAngles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub projAngVels: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub idStateVector: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idAttitudeSet: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ranges: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub azimuths: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub elevations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub rangeRates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub azimuthRates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub elevationRates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub azimuthBiases: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub elevationBiases: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub rangeBiases: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub integrationAngles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub crossRangeRes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub beta: f64,
    pub kappa: f64,
    pub peakAmplitudes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub centerFrequency: f64,
    pub pulseBandwidth: f64,
    pub xpos: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ypos: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub zpos: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub xvel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub yvel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub zvel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for RadarSOIObservation_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    RadarSOIObservation_FullArgs {
      obStartTime: None,
      tovs: None,
      rspaces: None,
      xspaces: None,
      doppler2XRs: None,
      deltaTimes: None,
      aspectAngles: None,
      projAngVels: None,
      idStateVector: None,
      idAttitudeSet: None,
      ranges: None,
      azimuths: None,
      elevations: None,
      rangeRates: None,
      azimuthRates: None,
      elevationRates: None,
      azimuthBiases: None,
      elevationBiases: None,
      rangeBiases: None,
      integrationAngles: None,
      crossRangeRes: None,
      beta: 0.0,
      kappa: 0.0,
      peakAmplitudes: None,
      centerFrequency: 0.0,
      pulseBandwidth: 0.0,
      xpos: None,
      ypos: None,
      zpos: None,
      xvel: None,
      yvel: None,
      zvel: None,
    }
  }
}

pub struct RadarSOIObservation_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RadarSOIObservation_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_obStartTime(&mut self, obStartTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_OBSTARTTIME, obStartTime);
  }
  #[inline]
  pub fn add_tovs(&mut self, tovs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_TOVS, tovs);
  }
  #[inline]
  pub fn add_rspaces(&mut self, rspaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_RSPACES, rspaces);
  }
  #[inline]
  pub fn add_xspaces(&mut self, xspaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_XSPACES, xspaces);
  }
  #[inline]
  pub fn add_doppler2XRs(&mut self, doppler2XRs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_DOPPLER2XRS, doppler2XRs);
  }
  #[inline]
  pub fn add_deltaTimes(&mut self, deltaTimes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_DELTATIMES, deltaTimes);
  }
  #[inline]
  pub fn add_aspectAngles(&mut self, aspectAngles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_ASPECTANGLES, aspectAngles);
  }
  #[inline]
  pub fn add_projAngVels(&mut self, projAngVels: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_PROJANGVELS, projAngVels);
  }
  #[inline]
  pub fn add_idStateVector(&mut self, idStateVector: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_IDSTATEVECTOR, idStateVector);
  }
  #[inline]
  pub fn add_idAttitudeSet(&mut self, idAttitudeSet: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_IDATTITUDESET, idAttitudeSet);
  }
  #[inline]
  pub fn add_ranges(&mut self, ranges: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_RANGES, ranges);
  }
  #[inline]
  pub fn add_azimuths(&mut self, azimuths: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_AZIMUTHS, azimuths);
  }
  #[inline]
  pub fn add_elevations(&mut self, elevations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_ELEVATIONS, elevations);
  }
  #[inline]
  pub fn add_rangeRates(&mut self, rangeRates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_RANGERATES, rangeRates);
  }
  #[inline]
  pub fn add_azimuthRates(&mut self, azimuthRates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_AZIMUTHRATES, azimuthRates);
  }
  #[inline]
  pub fn add_elevationRates(&mut self, elevationRates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_ELEVATIONRATES, elevationRates);
  }
  #[inline]
  pub fn add_azimuthBiases(&mut self, azimuthBiases: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_AZIMUTHBIASES, azimuthBiases);
  }
  #[inline]
  pub fn add_elevationBiases(&mut self, elevationBiases: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_ELEVATIONBIASES, elevationBiases);
  }
  #[inline]
  pub fn add_rangeBiases(&mut self, rangeBiases: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_RANGEBIASES, rangeBiases);
  }
  #[inline]
  pub fn add_integrationAngles(&mut self, integrationAngles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_INTEGRATIONANGLES, integrationAngles);
  }
  #[inline]
  pub fn add_crossRangeRes(&mut self, crossRangeRes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_CROSSRANGERES, crossRangeRes);
  }
  #[inline]
  pub fn add_beta(&mut self, beta: f64) {
    self.fbb_.push_slot::<f64>(RadarSOIObservation_Full::VT_BETA, beta, 0.0);
  }
  #[inline]
  pub fn add_kappa(&mut self, kappa: f64) {
    self.fbb_.push_slot::<f64>(RadarSOIObservation_Full::VT_KAPPA, kappa, 0.0);
  }
  #[inline]
  pub fn add_peakAmplitudes(&mut self, peakAmplitudes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_PEAKAMPLITUDES, peakAmplitudes);
  }
  #[inline]
  pub fn add_centerFrequency(&mut self, centerFrequency: f64) {
    self.fbb_.push_slot::<f64>(RadarSOIObservation_Full::VT_CENTERFREQUENCY, centerFrequency, 0.0);
  }
  #[inline]
  pub fn add_pulseBandwidth(&mut self, pulseBandwidth: f64) {
    self.fbb_.push_slot::<f64>(RadarSOIObservation_Full::VT_PULSEBANDWIDTH, pulseBandwidth, 0.0);
  }
  #[inline]
  pub fn add_xpos(&mut self, xpos: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_XPOS, xpos);
  }
  #[inline]
  pub fn add_ypos(&mut self, ypos: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_YPOS, ypos);
  }
  #[inline]
  pub fn add_zpos(&mut self, zpos: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_ZPOS, zpos);
  }
  #[inline]
  pub fn add_xvel(&mut self, xvel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_XVEL, xvel);
  }
  #[inline]
  pub fn add_yvel(&mut self, yvel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_YVEL, yvel);
  }
  #[inline]
  pub fn add_zvel(&mut self, zvel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RadarSOIObservation_Full::VT_ZVEL, zvel);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RadarSOIObservation_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RadarSOIObservation_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RadarSOIObservation_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RadarSOIObservation_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RadarSOIObservation_Full");
      ds.field("obStartTime", &self.obStartTime());
      ds.field("tovs", &self.tovs());
      ds.field("rspaces", &self.rspaces());
      ds.field("xspaces", &self.xspaces());
      ds.field("doppler2XRs", &self.doppler2XRs());
      ds.field("deltaTimes", &self.deltaTimes());
      ds.field("aspectAngles", &self.aspectAngles());
      ds.field("projAngVels", &self.projAngVels());
      ds.field("idStateVector", &self.idStateVector());
      ds.field("idAttitudeSet", &self.idAttitudeSet());
      ds.field("ranges", &self.ranges());
      ds.field("azimuths", &self.azimuths());
      ds.field("elevations", &self.elevations());
      ds.field("rangeRates", &self.rangeRates());
      ds.field("azimuthRates", &self.azimuthRates());
      ds.field("elevationRates", &self.elevationRates());
      ds.field("azimuthBiases", &self.azimuthBiases());
      ds.field("elevationBiases", &self.elevationBiases());
      ds.field("rangeBiases", &self.rangeBiases());
      ds.field("integrationAngles", &self.integrationAngles());
      ds.field("crossRangeRes", &self.crossRangeRes());
      ds.field("beta", &self.beta());
      ds.field("kappa", &self.kappa());
      ds.field("peakAmplitudes", &self.peakAmplitudes());
      ds.field("centerFrequency", &self.centerFrequency());
      ds.field("pulseBandwidth", &self.pulseBandwidth());
      ds.field("xpos", &self.xpos());
      ds.field("ypos", &self.ypos());
      ds.field("zpos", &self.zpos());
      ds.field("xvel", &self.xvel());
      ds.field("yvel", &self.yvel());
      ds.field("zvel", &self.zvel());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RadarSOIObservation_FullT {
  pub obStartTime: Option<String>,
  pub tovs: Option<Vec<String>>,
  pub rspaces: Option<Vec<String>>,
  pub xspaces: Option<Vec<String>>,
  pub doppler2XRs: Option<Vec<String>>,
  pub deltaTimes: Option<Vec<String>>,
  pub aspectAngles: Option<Vec<String>>,
  pub projAngVels: Option<Vec<String>>,
  pub idStateVector: Option<String>,
  pub idAttitudeSet: Option<String>,
  pub ranges: Option<Vec<String>>,
  pub azimuths: Option<Vec<String>>,
  pub elevations: Option<Vec<String>>,
  pub rangeRates: Option<Vec<String>>,
  pub azimuthRates: Option<Vec<String>>,
  pub elevationRates: Option<Vec<String>>,
  pub azimuthBiases: Option<Vec<String>>,
  pub elevationBiases: Option<Vec<String>>,
  pub rangeBiases: Option<Vec<String>>,
  pub integrationAngles: Option<Vec<String>>,
  pub crossRangeRes: Option<Vec<String>>,
  pub beta: f64,
  pub kappa: f64,
  pub peakAmplitudes: Option<Vec<String>>,
  pub centerFrequency: f64,
  pub pulseBandwidth: f64,
  pub xpos: Option<Vec<String>>,
  pub ypos: Option<Vec<String>>,
  pub zpos: Option<Vec<String>>,
  pub xvel: Option<Vec<String>>,
  pub yvel: Option<Vec<String>>,
  pub zvel: Option<Vec<String>>,
}
impl Default for RadarSOIObservation_FullT {
  fn default() -> Self {
    Self {
      obStartTime: None,
      tovs: None,
      rspaces: None,
      xspaces: None,
      doppler2XRs: None,
      deltaTimes: None,
      aspectAngles: None,
      projAngVels: None,
      idStateVector: None,
      idAttitudeSet: None,
      ranges: None,
      azimuths: None,
      elevations: None,
      rangeRates: None,
      azimuthRates: None,
      elevationRates: None,
      azimuthBiases: None,
      elevationBiases: None,
      rangeBiases: None,
      integrationAngles: None,
      crossRangeRes: None,
      beta: 0.0,
      kappa: 0.0,
      peakAmplitudes: None,
      centerFrequency: 0.0,
      pulseBandwidth: 0.0,
      xpos: None,
      ypos: None,
      zpos: None,
      xvel: None,
      yvel: None,
      zvel: None,
    }
  }
}
impl RadarSOIObservation_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<RadarSOIObservation_Full<'b>> {
    let obStartTime = self.obStartTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tovs = self.tovs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let rspaces = self.rspaces.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let xspaces = self.xspaces.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let doppler2XRs = self.doppler2XRs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let deltaTimes = self.deltaTimes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let aspectAngles = self.aspectAngles.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let projAngVels = self.projAngVels.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let idStateVector = self.idStateVector.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idAttitudeSet = self.idAttitudeSet.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ranges = self.ranges.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let azimuths = self.azimuths.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let elevations = self.elevations.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let rangeRates = self.rangeRates.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let azimuthRates = self.azimuthRates.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let elevationRates = self.elevationRates.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let azimuthBiases = self.azimuthBiases.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let elevationBiases = self.elevationBiases.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let rangeBiases = self.rangeBiases.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let integrationAngles = self.integrationAngles.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let crossRangeRes = self.crossRangeRes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let beta = self.beta;
    let kappa = self.kappa;
    let peakAmplitudes = self.peakAmplitudes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let centerFrequency = self.centerFrequency;
    let pulseBandwidth = self.pulseBandwidth;
    let xpos = self.xpos.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ypos = self.ypos.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let zpos = self.zpos.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let xvel = self.xvel.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let yvel = self.yvel.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let zvel = self.zvel.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    RadarSOIObservation_Full::create(_fbb, &RadarSOIObservation_FullArgs{
      obStartTime,
      tovs,
      rspaces,
      xspaces,
      doppler2XRs,
      deltaTimes,
      aspectAngles,
      projAngVels,
      idStateVector,
      idAttitudeSet,
      ranges,
      azimuths,
      elevations,
      rangeRates,
      azimuthRates,
      elevationRates,
      azimuthBiases,
      elevationBiases,
      rangeBiases,
      integrationAngles,
      crossRangeRes,
      beta,
      kappa,
      peakAmplitudes,
      centerFrequency,
      pulseBandwidth,
      xpos,
      ypos,
      zpos,
      xvel,
      yvel,
      zvel,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `RadarSOIObservation_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_radar_soiobservation_full_unchecked`.
pub fn root_as_radar_soiobservation_full(buf: &[u8]) -> Result<RadarSOIObservation_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<RadarSOIObservation_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `RadarSOIObservation_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_radar_soiobservation_full_unchecked`.
pub fn size_prefixed_root_as_radar_soiobservation_full(buf: &[u8]) -> Result<RadarSOIObservation_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<RadarSOIObservation_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `RadarSOIObservation_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_radar_soiobservation_full_unchecked`.
pub fn root_as_radar_soiobservation_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RadarSOIObservation_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<RadarSOIObservation_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `RadarSOIObservation_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_radar_soiobservation_full_unchecked`.
pub fn size_prefixed_root_as_radar_soiobservation_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RadarSOIObservation_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<RadarSOIObservation_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a RadarSOIObservation_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `RadarSOIObservation_Full`.
pub unsafe fn root_as_radar_soiobservation_full_unchecked(buf: &[u8]) -> RadarSOIObservation_Full {
  flatbuffers::root_unchecked::<RadarSOIObservation_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed RadarSOIObservation_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `RadarSOIObservation_Full`.
pub unsafe fn size_prefixed_root_as_radar_soiobservation_full_unchecked(buf: &[u8]) -> RadarSOIObservation_Full {
  flatbuffers::size_prefixed_root_unchecked::<RadarSOIObservation_Full>(buf)
}
pub const RADAR_SOIOBSERVATION_FULL_IDENTIFIER: &str = "RADA";

#[inline]
pub fn radar_soiobservation_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, RADAR_SOIOBSERVATION_FULL_IDENTIFIER, false)
}

#[inline]
pub fn radar_soiobservation_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, RADAR_SOIOBSERVATION_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_radar_soiobservation_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<RadarSOIObservation_Full<'a>>) {
  fbb.finish(root, Some(RADAR_SOIOBSERVATION_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_radar_soiobservation_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<RadarSOIObservation_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(RADAR_SOIOBSERVATION_FULL_IDENTIFIER));
}
