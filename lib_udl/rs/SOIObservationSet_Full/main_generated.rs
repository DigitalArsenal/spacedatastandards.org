// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SOIOBSERVATION_SET_FULL_TYPE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SOIOBSERVATION_SET_FULL_TYPE_ENUM: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOIOBSERVATION_SET_FULL_TYPE_ENUM: [SOIObservationSet_Full_type_Enum; 2] = [
  SOIObservationSet_Full_type_Enum::OPTICAL,
  SOIObservationSet_Full_type_Enum::RADAR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SOIObservationSet_Full_type_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl SOIObservationSet_Full_type_Enum {
  /// No description available.
  pub const OPTICAL: Self = Self(0);
  /// No description available.
  pub const RADAR: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OPTICAL,
    Self::RADAR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OPTICAL => Some("OPTICAL"),
      Self::RADAR => Some("RADAR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SOIObservationSet_Full_type_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SOIObservationSet_Full_type_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SOIObservationSet_Full_type_Enum {
    type Output = SOIObservationSet_Full_type_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SOIObservationSet_Full_type_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SOIObservationSet_Full_type_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SOIObservationSet_Full_type_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SOIOBSERVATION_SET_FULL_REFERENCE_FRAME_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SOIOBSERVATION_SET_FULL_REFERENCE_FRAME_ENUM: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOIOBSERVATION_SET_FULL_REFERENCE_FRAME_ENUM: [SOIObservationSet_Full_referenceFrame_Enum; 6] = [
  SOIObservationSet_Full_referenceFrame_Enum::J2000,
  SOIObservationSet_Full_referenceFrame_Enum::EFG_TDR,
  SOIObservationSet_Full_referenceFrame_Enum::ECR_ECEF,
  SOIObservationSet_Full_referenceFrame_Enum::TEME,
  SOIObservationSet_Full_referenceFrame_Enum::ITRF,
  SOIObservationSet_Full_referenceFrame_Enum::GCRF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SOIObservationSet_Full_referenceFrame_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl SOIObservationSet_Full_referenceFrame_Enum {
  /// No description available.
  pub const J2000: Self = Self(0);
  /// No description available.
  pub const EFG_TDR: Self = Self(1);
  /// No description available.
  pub const ECR_ECEF: Self = Self(2);
  /// No description available.
  pub const TEME: Self = Self(3);
  /// No description available.
  pub const ITRF: Self = Self(4);
  /// No description available.
  pub const GCRF: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::J2000,
    Self::EFG_TDR,
    Self::ECR_ECEF,
    Self::TEME,
    Self::ITRF,
    Self::GCRF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::J2000 => Some("J2000"),
      Self::EFG_TDR => Some("EFG_TDR"),
      Self::ECR_ECEF => Some("ECR_ECEF"),
      Self::TEME => Some("TEME"),
      Self::ITRF => Some("ITRF"),
      Self::GCRF => Some("GCRF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SOIObservationSet_Full_referenceFrame_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SOIObservationSet_Full_referenceFrame_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SOIObservationSet_Full_referenceFrame_Enum {
    type Output = SOIObservationSet_Full_referenceFrame_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SOIObservationSet_Full_referenceFrame_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SOIObservationSet_Full_referenceFrame_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SOIObservationSet_Full_referenceFrame_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SOIOBSERVATION_SET_FULL_SEN_REFERENCE_FRAME_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SOIOBSERVATION_SET_FULL_SEN_REFERENCE_FRAME_ENUM: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOIOBSERVATION_SET_FULL_SEN_REFERENCE_FRAME_ENUM: [SOIObservationSet_Full_senReferenceFrame_Enum; 6] = [
  SOIObservationSet_Full_senReferenceFrame_Enum::J2000,
  SOIObservationSet_Full_senReferenceFrame_Enum::EFG_TDR,
  SOIObservationSet_Full_senReferenceFrame_Enum::ECR_ECEF,
  SOIObservationSet_Full_senReferenceFrame_Enum::TEME,
  SOIObservationSet_Full_senReferenceFrame_Enum::ITRF,
  SOIObservationSet_Full_senReferenceFrame_Enum::GCRF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SOIObservationSet_Full_senReferenceFrame_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl SOIObservationSet_Full_senReferenceFrame_Enum {
  /// No description available.
  pub const J2000: Self = Self(0);
  /// No description available.
  pub const EFG_TDR: Self = Self(1);
  /// No description available.
  pub const ECR_ECEF: Self = Self(2);
  /// No description available.
  pub const TEME: Self = Self(3);
  /// No description available.
  pub const ITRF: Self = Self(4);
  /// No description available.
  pub const GCRF: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::J2000,
    Self::EFG_TDR,
    Self::ECR_ECEF,
    Self::TEME,
    Self::ITRF,
    Self::GCRF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::J2000 => Some("J2000"),
      Self::EFG_TDR => Some("EFG_TDR"),
      Self::ECR_ECEF => Some("ECR_ECEF"),
      Self::TEME => Some("TEME"),
      Self::ITRF => Some("ITRF"),
      Self::GCRF => Some("GCRF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SOIObservationSet_Full_senReferenceFrame_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SOIObservationSet_Full_senReferenceFrame_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SOIObservationSet_Full_senReferenceFrame_Enum {
    type Output = SOIObservationSet_Full_senReferenceFrame_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SOIObservationSet_Full_senReferenceFrame_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SOIObservationSet_Full_senReferenceFrame_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SOIObservationSet_Full_senReferenceFrame_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SOIOBSERVATION_SET_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SOIOBSERVATION_SET_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOIOBSERVATION_SET_FULL_DATA_MODE_ENUM: [SOIObservationSet_Full_dataMode_Enum; 4] = [
  SOIObservationSet_Full_dataMode_Enum::REAL,
  SOIObservationSet_Full_dataMode_Enum::TEST,
  SOIObservationSet_Full_dataMode_Enum::SIMULATED,
  SOIObservationSet_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SOIObservationSet_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl SOIObservationSet_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SOIObservationSet_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SOIObservationSet_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SOIObservationSet_Full_dataMode_Enum {
    type Output = SOIObservationSet_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SOIObservationSet_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SOIObservationSet_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SOIObservationSet_Full_dataMode_Enum {}
pub enum SOIObservationSet_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// These services provide operations for posting space object idenfification observation sets.
pub struct SOIObservationSet_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SOIObservationSet_Full<'a> {
  type Inner = SOIObservationSet_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SOIObservationSet_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_MSGCREATEDATE: flatbuffers::VOffsetT = 8;
  pub const VT_IDSENSOR: flatbuffers::VOffsetT = 10;
  pub const VT_ORIGSENSORID: flatbuffers::VOffsetT = 12;
  pub const VT_SENSORASID: flatbuffers::VOffsetT = 14;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 16;
  pub const VT_SATNO: flatbuffers::VOffsetT = 18;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 20;
  pub const VT_SENLAT: flatbuffers::VOffsetT = 22;
  pub const VT_SENLON: flatbuffers::VOffsetT = 24;
  pub const VT_SENALT: flatbuffers::VOffsetT = 26;
  pub const VT_SENX: flatbuffers::VOffsetT = 28;
  pub const VT_SENY: flatbuffers::VOffsetT = 30;
  pub const VT_SENZ: flatbuffers::VOffsetT = 32;
  pub const VT_SENVELX: flatbuffers::VOffsetT = 34;
  pub const VT_SENVELY: flatbuffers::VOffsetT = 36;
  pub const VT_SENVELZ: flatbuffers::VOffsetT = 38;
  pub const VT_IDELSET: flatbuffers::VOffsetT = 40;
  pub const VT_STARTTIME: flatbuffers::VOffsetT = 42;
  pub const VT_ENDTIME: flatbuffers::VOffsetT = 44;
  pub const VT_NUMOBS: flatbuffers::VOffsetT = 46;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 48;
  pub const VT_POLARANGLESTART: flatbuffers::VOffsetT = 50;
  pub const VT_POLARANGLEEND: flatbuffers::VOffsetT = 52;
  pub const VT_REFERENCEFRAME: flatbuffers::VOffsetT = 54;
  pub const VT_SENREFERENCEFRAME: flatbuffers::VOffsetT = 56;
  pub const VT_LOSDECLINATIONSTART: flatbuffers::VOffsetT = 58;
  pub const VT_LOSDECLINATIONEND: flatbuffers::VOffsetT = 60;
  pub const VT_POINTINGANGLEAZSTART: flatbuffers::VOffsetT = 62;
  pub const VT_POINTINGANGLEAZEND: flatbuffers::VOffsetT = 64;
  pub const VT_POINTINGANGLEELSTART: flatbuffers::VOffsetT = 66;
  pub const VT_POINTINGANGLEELEND: flatbuffers::VOffsetT = 68;
  pub const VT_PIXELARRAYWIDTH: flatbuffers::VOffsetT = 70;
  pub const VT_PIXELARRAYHEIGHT: flatbuffers::VOffsetT = 72;
  pub const VT_NUMSPECTRALFILTERS: flatbuffers::VOffsetT = 74;
  pub const VT_SPECTRALFILTERS: flatbuffers::VOffsetT = 76;
  pub const VT_COLLECTIONMODE: flatbuffers::VOffsetT = 78;
  pub const VT_GAIN: flatbuffers::VOffsetT = 80;
  pub const VT_BINNINGHORIZ: flatbuffers::VOffsetT = 82;
  pub const VT_BINNINGVERT: flatbuffers::VOffsetT = 84;
  pub const VT_SOLARMAG: flatbuffers::VOffsetT = 86;
  pub const VT_PIXELMIN: flatbuffers::VOffsetT = 88;
  pub const VT_PIXELMAX: flatbuffers::VOffsetT = 90;
  pub const VT_SOFTWAREVERSION: flatbuffers::VOffsetT = 92;
  pub const VT_SATELLITENAME: flatbuffers::VOffsetT = 94;
  pub const VT_STARCATNAME: flatbuffers::VOffsetT = 96;
  pub const VT_CORRQUALITY: flatbuffers::VOffsetT = 98;
  pub const VT_UCT: flatbuffers::VOffsetT = 100;
  pub const VT_VALIDCALIBRATIONS: flatbuffers::VOffsetT = 102;
  pub const VT_CALIBRATIONTYPE: flatbuffers::VOffsetT = 104;
  pub const VT_PERCENTSATTHRESHOLD: flatbuffers::VOffsetT = 106;
  pub const VT_CHANGEDETECTED: flatbuffers::VOffsetT = 108;
  pub const VT_PERIODICITYCHANGEDETECTED: flatbuffers::VOffsetT = 110;
  pub const VT_BRIGHTNESSVARIANCECHANGEDETECTED: flatbuffers::VOffsetT = 112;
  pub const VT_SOLARPHASEANGLEBRIGHTNESSCHANGEDETECTED: flatbuffers::VOffsetT = 114;
  pub const VT_CHANGECONF: flatbuffers::VOffsetT = 116;
  pub const VT_COLLECTIONDENSITYCONF: flatbuffers::VOffsetT = 118;
  pub const VT_PERIODICITYSAMPLINGCONF: flatbuffers::VOffsetT = 120;
  pub const VT_PERIODICITYDETECTIONCONF: flatbuffers::VOffsetT = 122;
  pub const VT_COLLECTIONID: flatbuffers::VOffsetT = 124;
  pub const VT_CALIBRATIONS: flatbuffers::VOffsetT = 126;
  pub const VT_TAGS: flatbuffers::VOffsetT = 128;
  pub const VT_TRANSACTIONID: flatbuffers::VOffsetT = 130;
  pub const VT_OPTICALSOIOBSERVATIONLIST: flatbuffers::VOffsetT = 132;
  pub const VT_RADARSOIOBSERVATIONLIST: flatbuffers::VOffsetT = 134;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 136;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 138;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 140;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 142;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 144;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 146;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 148;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SOIObservationSet_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SOIObservationSet_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<SOIObservationSet_Full<'bldr>> {
    let mut builder = SOIObservationSet_FullBuilder::new(_fbb);
    builder.add_percentSatThreshold(args.percentSatThreshold);
    builder.add_corrQuality(args.corrQuality);
    builder.add_solarMag(args.solarMag);
    builder.add_gain(args.gain);
    builder.add_pointingAngleElEnd(args.pointingAngleElEnd);
    builder.add_pointingAngleElStart(args.pointingAngleElStart);
    builder.add_pointingAngleAzEnd(args.pointingAngleAzEnd);
    builder.add_pointingAngleAzStart(args.pointingAngleAzStart);
    builder.add_losDeclinationEnd(args.losDeclinationEnd);
    builder.add_losDeclinationStart(args.losDeclinationStart);
    builder.add_polarAngleEnd(args.polarAngleEnd);
    builder.add_polarAngleStart(args.polarAngleStart);
    builder.add_senvelz(args.senvelz);
    builder.add_senvely(args.senvely);
    builder.add_senvelx(args.senvelx);
    builder.add_senz(args.senz);
    builder.add_seny(args.seny);
    builder.add_senx(args.senx);
    builder.add_senalt(args.senalt);
    builder.add_senlon(args.senlon);
    builder.add_senlat(args.senlat);
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.radarSOIObservationList { builder.add_radarSOIObservationList(x); }
    if let Some(x) = args.opticalSOIObservationList { builder.add_opticalSOIObservationList(x); }
    if let Some(x) = args.transactionId { builder.add_transactionId(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.calibrations { builder.add_calibrations(x); }
    if let Some(x) = args.collectionId { builder.add_collectionId(x); }
    if let Some(x) = args.periodicityDetectionConf { builder.add_periodicityDetectionConf(x); }
    if let Some(x) = args.periodicitySamplingConf { builder.add_periodicitySamplingConf(x); }
    if let Some(x) = args.collectionDensityConf { builder.add_collectionDensityConf(x); }
    if let Some(x) = args.changeConf { builder.add_changeConf(x); }
    if let Some(x) = args.calibrationType { builder.add_calibrationType(x); }
    if let Some(x) = args.validCalibrations { builder.add_validCalibrations(x); }
    if let Some(x) = args.starCatName { builder.add_starCatName(x); }
    if let Some(x) = args.satelliteName { builder.add_satelliteName(x); }
    if let Some(x) = args.softwareVersion { builder.add_softwareVersion(x); }
    builder.add_pixelMax(args.pixelMax);
    builder.add_pixelMin(args.pixelMin);
    builder.add_binningVert(args.binningVert);
    builder.add_binningHoriz(args.binningHoriz);
    if let Some(x) = args.collectionMode { builder.add_collectionMode(x); }
    if let Some(x) = args.spectralFilters { builder.add_spectralFilters(x); }
    builder.add_numSpectralFilters(args.numSpectralFilters);
    builder.add_pixelArrayHeight(args.pixelArrayHeight);
    builder.add_pixelArrayWidth(args.pixelArrayWidth);
    builder.add_numObs(args.numObs);
    if let Some(x) = args.endTime { builder.add_endTime(x); }
    if let Some(x) = args.startTime { builder.add_startTime(x); }
    if let Some(x) = args.idElset { builder.add_idElset(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.sensorAsId { builder.add_sensorAsId(x); }
    if let Some(x) = args.origSensorId { builder.add_origSensorId(x); }
    if let Some(x) = args.idSensor { builder.add_idSensor(x); }
    if let Some(x) = args.msgCreateDate { builder.add_msgCreateDate(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_solarPhaseAngleBrightnessChangeDetected(args.solarPhaseAngleBrightnessChangeDetected);
    builder.add_brightnessVarianceChangeDetected(args.brightnessVarianceChangeDetected);
    builder.add_periodicityChangeDetected(args.periodicityChangeDetected);
    builder.add_changeDetected(args.changeDetected);
    builder.add_uct(args.uct);
    builder.add_senReferenceFrame(args.senReferenceFrame);
    builder.add_referenceFrame(args.referenceFrame);
    builder.add_type_(args.type_);
    builder.finish()
  }

  pub fn unpack(&self) -> SOIObservationSet_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let msgCreateDate = self.msgCreateDate().map(|x| {
      x.to_string()
    });
    let idSensor = self.idSensor().map(|x| {
      x.to_string()
    });
    let origSensorId = self.origSensorId().map(|x| {
      x.to_string()
    });
    let sensorAsId = self.sensorAsId().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let satNo = self.satNo();
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let senlat = self.senlat();
    let senlon = self.senlon();
    let senalt = self.senalt();
    let senx = self.senx();
    let seny = self.seny();
    let senz = self.senz();
    let senvelx = self.senvelx();
    let senvely = self.senvely();
    let senvelz = self.senvelz();
    let idElset = self.idElset().map(|x| {
      x.to_string()
    });
    let startTime = self.startTime().map(|x| {
      x.to_string()
    });
    let endTime = self.endTime().map(|x| {
      x.to_string()
    });
    let numObs = self.numObs();
    let type_ = self.type_();
    let polarAngleStart = self.polarAngleStart();
    let polarAngleEnd = self.polarAngleEnd();
    let referenceFrame = self.referenceFrame();
    let senReferenceFrame = self.senReferenceFrame();
    let losDeclinationStart = self.losDeclinationStart();
    let losDeclinationEnd = self.losDeclinationEnd();
    let pointingAngleAzStart = self.pointingAngleAzStart();
    let pointingAngleAzEnd = self.pointingAngleAzEnd();
    let pointingAngleElStart = self.pointingAngleElStart();
    let pointingAngleElEnd = self.pointingAngleElEnd();
    let pixelArrayWidth = self.pixelArrayWidth();
    let pixelArrayHeight = self.pixelArrayHeight();
    let numSpectralFilters = self.numSpectralFilters();
    let spectralFilters = self.spectralFilters().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let collectionMode = self.collectionMode().map(|x| {
      x.to_string()
    });
    let gain = self.gain();
    let binningHoriz = self.binningHoriz();
    let binningVert = self.binningVert();
    let solarMag = self.solarMag();
    let pixelMin = self.pixelMin();
    let pixelMax = self.pixelMax();
    let softwareVersion = self.softwareVersion().map(|x| {
      x.to_string()
    });
    let satelliteName = self.satelliteName().map(|x| {
      x.to_string()
    });
    let starCatName = self.starCatName().map(|x| {
      x.to_string()
    });
    let corrQuality = self.corrQuality();
    let uct = self.uct();
    let validCalibrations = self.validCalibrations().map(|x| {
      x.to_string()
    });
    let calibrationType = self.calibrationType().map(|x| {
      x.to_string()
    });
    let percentSatThreshold = self.percentSatThreshold();
    let changeDetected = self.changeDetected();
    let periodicityChangeDetected = self.periodicityChangeDetected();
    let brightnessVarianceChangeDetected = self.brightnessVarianceChangeDetected();
    let solarPhaseAngleBrightnessChangeDetected = self.solarPhaseAngleBrightnessChangeDetected();
    let changeConf = self.changeConf().map(|x| {
      x.to_string()
    });
    let collectionDensityConf = self.collectionDensityConf().map(|x| {
      x.to_string()
    });
    let periodicitySamplingConf = self.periodicitySamplingConf().map(|x| {
      x.to_string()
    });
    let periodicityDetectionConf = self.periodicityDetectionConf().map(|x| {
      x.to_string()
    });
    let collectionId = self.collectionId().map(|x| {
      x.to_string()
    });
    let calibrations = self.calibrations().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let tags = self.tags().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let transactionId = self.transactionId().map(|x| {
      x.to_string()
    });
    let opticalSOIObservationList = self.opticalSOIObservationList().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let radarSOIObservationList = self.radarSOIObservationList().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    SOIObservationSet_FullT {
      id,
      classificationMarking,
      msgCreateDate,
      idSensor,
      origSensorId,
      sensorAsId,
      idOnOrbit,
      satNo,
      origObjectId,
      senlat,
      senlon,
      senalt,
      senx,
      seny,
      senz,
      senvelx,
      senvely,
      senvelz,
      idElset,
      startTime,
      endTime,
      numObs,
      type_,
      polarAngleStart,
      polarAngleEnd,
      referenceFrame,
      senReferenceFrame,
      losDeclinationStart,
      losDeclinationEnd,
      pointingAngleAzStart,
      pointingAngleAzEnd,
      pointingAngleElStart,
      pointingAngleElEnd,
      pixelArrayWidth,
      pixelArrayHeight,
      numSpectralFilters,
      spectralFilters,
      collectionMode,
      gain,
      binningHoriz,
      binningVert,
      solarMag,
      pixelMin,
      pixelMax,
      softwareVersion,
      satelliteName,
      starCatName,
      corrQuality,
      uct,
      validCalibrations,
      calibrationType,
      percentSatThreshold,
      changeDetected,
      periodicityChangeDetected,
      brightnessVarianceChangeDetected,
      solarPhaseAngleBrightnessChangeDetected,
      changeConf,
      collectionDensityConf,
      periodicitySamplingConf,
      periodicityDetectionConf,
      collectionId,
      calibrations,
      tags,
      transactionId,
      opticalSOIObservationList,
      radarSOIObservationList,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      sourceDL,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// SOI msgCreateDate time in ISO 8601 UTC time, with millisecond precision.
  /// Example: /// Example: 2022-07-07T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn msgCreateDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_MSGCREATEDATE, None)}
  }
  /// ID of the observing sensor.
  /// Example: /// Example: SENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_IDSENSOR, None)}
  }
  /// Optional identifier provided by the record source to indicate the sensor identifier to which this attitude set applies if this set is reporting a single sensor orientation. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origSensorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_ORIGSENSORID, None)}
  }
  /// ID of the AttitudeSet record for the observing sensor.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn sensorAsId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_SENSORASID, None)}
  }
  /// Unique identifier of the target on-orbit object, if correlated.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_IDONORBIT, None)}
  }
  /// Satellite/catalog number of the target on-orbit object.
  /// Example: /// Example: 101
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOIObservationSet_Full::VT_SATNO, Some(0)).unwrap()}
  }
  /// Optional identifier provided by observation source to indicate the target onorbit object of this observation. This may be an internal identifier and not necessarily a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_ORIGOBJECTID, None)}
  }
  /// Sensor WGS84 latitude at startTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_SENLAT, Some(0.0)).unwrap()}
  }
  /// Sensor WGS84 longitude at startTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -180 to 180 degrees (negative values south of equator).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_SENLON, Some(0.0)).unwrap()}
  }
  /// Sensor altitude at startTime (if mobile/onorbit) in kilometers.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senalt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_SENALT, Some(0.0)).unwrap()}
  }
  /// Cartesian X position of the observing mobile/onorbit sensor at startTime, in kilometers, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senx(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_SENX, Some(0.0)).unwrap()}
  }
  /// Cartesian Y position of the observing mobile/onorbit sensor at startTime, in kilometers, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn seny(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_SENY, Some(0.0)).unwrap()}
  }
  /// Cartesian Z position of the observing mobile/onorbit sensor at startTime, in kilometers, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senz(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_SENZ, Some(0.0)).unwrap()}
  }
  /// Cartesian X velocity of the observing mobile/onorbit sensor at startTime, in kilometers per second, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senvelx(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_SENVELX, Some(0.0)).unwrap()}
  }
  /// Cartesian Y velocity of the observing mobile/onorbit sensor at startTime, in kilometers per second, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senvely(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_SENVELY, Some(0.0)).unwrap()}
  }
  /// Cartesian Z velocity of the observing mobile/onorbit sensor at startTime, in kilometers per second, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senvelz(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_SENVELZ, Some(0.0)).unwrap()}
  }
  /// ID of the UDL Elset of the Space Object under observation.
  /// Example: /// Example: REF-ELSET-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idElset(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_IDELSET, None)}
  }
  /// Observation set detection start time in ISO 8601 UTC with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn startTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_STARTTIME, None)}
  }
  /// Observation set detection end time in ISO 8601 UTC with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn endTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_ENDTIME, None)}
  }
  /// The number of observation records in the set.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numObs(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOIObservationSet_Full::VT_NUMOBS, Some(0)).unwrap()}
  }
  /// Observation type (OPTICAL, RADAR).
  /// Example: /// Example: OPTICAL
  /// Constraints: Minimum length = 1, Maximum length = 24
  #[inline]
  pub fn type_(&self) -> SOIObservationSet_Full_type_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SOIObservationSet_Full_type_Enum>(SOIObservationSet_Full::VT_TYPE_, Some(SOIObservationSet_Full_type_Enum::OPTICAL)).unwrap()}
  }
  /// Polar angle of the gimbal/mount at observation set detection start time in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polarAngleStart(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_POLARANGLESTART, Some(0.0)).unwrap()}
  }
  /// Polar angle of the gimbal/mount at observation set detection end time in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polarAngleEnd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_POLARANGLEEND, Some(0.0)).unwrap()}
  }
  /// The reference frame of the observation measurements. If the referenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn referenceFrame(&self) -> SOIObservationSet_Full_referenceFrame_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SOIObservationSet_Full_referenceFrame_Enum>(SOIObservationSet_Full::VT_REFERENCEFRAME, Some(SOIObservationSet_Full_referenceFrame_Enum::J2000)).unwrap()}
  }
  /// The reference frame of the observing sensor state. If the senReferenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn senReferenceFrame(&self) -> SOIObservationSet_Full_senReferenceFrame_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SOIObservationSet_Full_senReferenceFrame_Enum>(SOIObservationSet_Full::VT_SENREFERENCEFRAME, Some(SOIObservationSet_Full_senReferenceFrame_Enum::J2000)).unwrap()}
  }
  /// Line of sight declination at observation set detection start time. Specified in degrees, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed (e.g -30 to 130.0).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn losDeclinationStart(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_LOSDECLINATIONSTART, Some(0.0)).unwrap()}
  }
  /// Line of sight declination at observation set detection end time. Specified in degrees, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed (e.g -30 to 130.0).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn losDeclinationEnd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_LOSDECLINATIONEND, Some(0.0)).unwrap()}
  }
  /// Pointing angle of the Azimuth gimbal/mount at observation set detection start time. Specified in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pointingAngleAzStart(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_POINTINGANGLEAZSTART, Some(0.0)).unwrap()}
  }
  /// Pointing angle of the Azimuth gimbal/mount at observation set detection end time. Specified in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pointingAngleAzEnd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_POINTINGANGLEAZEND, Some(0.0)).unwrap()}
  }
  /// Pointing angle of the Elevation gimbal/mount at observation set detection start time. Specified in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pointingAngleElStart(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_POINTINGANGLEELSTART, Some(0.0)).unwrap()}
  }
  /// Pointing angle of the Elevation gimbal/mount at observation set detection end time. Specified in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pointingAngleElEnd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_POINTINGANGLEELEND, Some(0.0)).unwrap()}
  }
  /// Pixel array size (width) in pixels.
  /// Example: /// Example: 32
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pixelArrayWidth(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOIObservationSet_Full::VT_PIXELARRAYWIDTH, Some(0)).unwrap()}
  }
  /// Pixel array size (height) in pixels.
  /// Example: /// Example: 32
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pixelArrayHeight(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOIObservationSet_Full::VT_PIXELARRAYHEIGHT, Some(0)).unwrap()}
  }
  /// The value is the number of spectral filters used.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numSpectralFilters(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOIObservationSet_Full::VT_NUMSPECTRALFILTERS, Some(0)).unwrap()}
  }
  /// Array of the SpectralFilters keywords, must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.
  /// Example: /// Example: ['Keyword1', 'Keyword2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spectralFilters(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SOIObservationSet_Full::VT_SPECTRALFILTERS, None)}
  }
  /// Mode indicating telescope movement during collection (AUTOTRACK, MANUAL AUTOTRACK, MANUAL RATE TRACK, MANUAL SIDEREAL, SIDEREAL, RATE TRACK).
  /// Example: /// Example: RATE TRACK
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn collectionMode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_COLLECTIONMODE, None)}
  }
  /// The gain used during the collection, in units of photoelectrons per analog-to-digital unit (e-/ADU). If no gain is used, the value = 1.
  /// Example: /// Example: 234.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gain(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_GAIN, Some(0.0)).unwrap()}
  }
  /// The number of pixels binned horizontally.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn binningHoriz(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOIObservationSet_Full::VT_BINNINGHORIZ, Some(0)).unwrap()}
  }
  /// The number of pixels binned vertically.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn binningVert(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOIObservationSet_Full::VT_BINNINGVERT, Some(0)).unwrap()}
  }
  /// The in-band solar magnitude at 1 A.U.
  /// Example: /// Example: -26.91
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solarMag(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_SOLARMAG, Some(0.0)).unwrap()}
  }
  /// The minimum valid pixel value.
  /// Example: /// Example: 0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pixelMin(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOIObservationSet_Full::VT_PIXELMIN, Some(0)).unwrap()}
  }
  /// The maximum valid pixel value.
  /// Example: /// Example: 16383
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pixelMax(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOIObservationSet_Full::VT_PIXELMAX, Some(0)).unwrap()}
  }
  /// Software Version used to Capture, Process, and Deliver the data.
  /// Example: /// Example: GSV99/17-1
  /// Constraints: Minimum length = 0, Maximum length = 70
  #[inline]
  pub fn softwareVersion(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_SOFTWAREVERSION, None)}
  }
  /// Name of the target satellite.
  /// Example: /// Example: TITAN 3C TRANSTAGE R/B
  /// Constraints: Minimum length = 0, Maximum length = 70
  #[inline]
  pub fn satelliteName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_SATELLITENAME, None)}
  }
  /// Name of the Star Catalog used for photometry and astrometry.
  /// Example: /// Example: SSTRC5
  /// Constraints: Minimum length = 0, Maximum length = 70
  #[inline]
  pub fn starCatName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_STARCATNAME, None)}
  }
  /// Object Correlation Quality value. Measures how close the observed object's orbit is to matching an object in the catalog. The scale of this field may vary depending on provider. Users should consult the data provider to verify the meaning of the value (e.g. A value of 0.0 indicates a high/strong correlation, while a value closer to 1.0 indicates low/weak correlation).
  /// Example: /// Example: 0.327
  /// Constraints: No constraints specified.
  #[inline]
  pub fn corrQuality(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_CORRQUALITY, Some(0.0)).unwrap()}
  }
  /// Boolean indicating whether the target object was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn uct(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SOIObservationSet_Full::VT_UCT, Some(false)).unwrap()}
  }
  /// Key to indicate which, if any of, the pre/post photometer calibrations are valid for use when generating data for the EOSSA file. If the field is not populated, then the provided calibration data will be used when generating the EOSSA file (e.g. PRE, POST, BOTH, NONE).
  /// Example: /// Example: BOTH
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn validCalibrations(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_VALIDCALIBRATIONS, None)}
  }
  /// Type of calibration used by the Sensor (e.g. ALL SKY, DIFFERENTIAL, DEFAULT, NONE).
  /// Example: /// Example: ALL SKY
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn calibrationType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_CALIBRATIONTYPE, None)}
  }
  /// A threshold for percent of pixels that make up object signal that are beyond the saturation point for the sensor that are removed in the EOSSA file, in range of 0 to 1.
  /// Example: /// Example: 0.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn percentSatThreshold(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOIObservationSet_Full::VT_PERCENTSATTHRESHOLD, Some(0.0)).unwrap()}
  }
  /// Boolean indicating if any change event was detected, based on historical collection data for the object.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn changeDetected(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SOIObservationSet_Full::VT_CHANGEDETECTED, Some(false)).unwrap()}
  }
  /// Boolean indicating if a periodicity change event was detected, based on historical collection data for the object.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn periodicityChangeDetected(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SOIObservationSet_Full::VT_PERIODICITYCHANGEDETECTED, Some(false)).unwrap()}
  }
  /// Boolean indicating if a brightness variance change event was detected, based on historical collection data for the object.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn brightnessVarianceChangeDetected(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SOIObservationSet_Full::VT_BRIGHTNESSVARIANCECHANGEDETECTED, Some(false)).unwrap()}
  }
  /// Boolean indicating if a solar phase angle brightness change event was detected, based on historical collection data for the object.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solarPhaseAngleBrightnessChangeDetected(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SOIObservationSet_Full::VT_SOLARPHASEANGLEBRIGHTNESSCHANGEDETECTED, Some(false)).unwrap()}
  }
  /// Overall qualitative confidence assessment of change detection results (e.g. HIGH, MEDIUM, LOW).
  /// Example: /// Example: MEDIUM
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn changeConf(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_CHANGECONF, None)}
  }
  /// Qualitative Collection Density assessment, with respect to confidence of detecting a change event (e.g. HIGH, MEDIUM, LOW).
  /// Example: /// Example: MEDIUM
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn collectionDensityConf(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_COLLECTIONDENSITYCONF, None)}
  }
  /// Qualitative Periodicity Sampling assessment, with respect to confidence of detecting a change event (e.g. HIGH, MEDIUM, LOW).
  /// Example: /// Example: MEDIUM
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn periodicitySamplingConf(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_PERIODICITYSAMPLINGCONF, None)}
  }
  /// Qualitative assessment of the periodicity detection results from the Attitude and Shape Retrieval (ASR) Periodicity Assessment (PA) Tool (e.g. HIGH, MEDIUM, LOW).
  /// Example: /// Example: MEDIUM
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn periodicityDetectionConf(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_PERIODICITYDETECTIONCONF, None)}
  }
  /// Universally Unique collection ID. Mechanism to correlate Single Point Photometry (SPP) JSON files to images.
  /// Example: /// Example: b5133288-ab63-4b15-81f6-c7eec0cdb0c0
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn collectionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_COLLECTIONID, None)}
  }
  /// Array of SOI Calibrations associated with this SOIObservationSet.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn calibrations(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SOIObservationSet_Full::VT_CALIBRATIONS, None)}
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['TAG1', 'TAG2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SOIObservationSet_Full::VT_TAGS, None)}
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn transactionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_TRANSACTIONID, None)}
  }
  /// OpticalSOIObservations associated with this SOIObservationSet.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn opticalSOIObservationList(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SOIObservationSet_Full::VT_OPTICALSOIOBSERVATIONLIST, None)}
  }
  /// RadarSOIObservations associated with this RadarSOIObservationSet.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radarSOIObservationList(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SOIObservationSet_Full::VT_RADARSOIOBSERVATIONLIST, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_ORIGNETWORK, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOIObservationSet_Full::VT_SOURCEDL, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> SOIObservationSet_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SOIObservationSet_Full_dataMode_Enum>(SOIObservationSet_Full::VT_DATAMODE, Some(SOIObservationSet_Full_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SOIObservationSet_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msgCreateDate", Self::VT_MSGCREATEDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor", Self::VT_IDSENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId", Self::VT_ORIGSENSORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sensorAsId", Self::VT_SENSORASID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<f64>("senlat", Self::VT_SENLAT, false)?
     .visit_field::<f64>("senlon", Self::VT_SENLON, false)?
     .visit_field::<f64>("senalt", Self::VT_SENALT, false)?
     .visit_field::<f64>("senx", Self::VT_SENX, false)?
     .visit_field::<f64>("seny", Self::VT_SENY, false)?
     .visit_field::<f64>("senz", Self::VT_SENZ, false)?
     .visit_field::<f64>("senvelx", Self::VT_SENVELX, false)?
     .visit_field::<f64>("senvely", Self::VT_SENVELY, false)?
     .visit_field::<f64>("senvelz", Self::VT_SENVELZ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idElset", Self::VT_IDELSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("startTime", Self::VT_STARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endTime", Self::VT_ENDTIME, false)?
     .visit_field::<i32>("numObs", Self::VT_NUMOBS, false)?
     .visit_field::<SOIObservationSet_Full_type_Enum>("type_", Self::VT_TYPE_, false)?
     .visit_field::<f64>("polarAngleStart", Self::VT_POLARANGLESTART, false)?
     .visit_field::<f64>("polarAngleEnd", Self::VT_POLARANGLEEND, false)?
     .visit_field::<SOIObservationSet_Full_referenceFrame_Enum>("referenceFrame", Self::VT_REFERENCEFRAME, false)?
     .visit_field::<SOIObservationSet_Full_senReferenceFrame_Enum>("senReferenceFrame", Self::VT_SENREFERENCEFRAME, false)?
     .visit_field::<f64>("losDeclinationStart", Self::VT_LOSDECLINATIONSTART, false)?
     .visit_field::<f64>("losDeclinationEnd", Self::VT_LOSDECLINATIONEND, false)?
     .visit_field::<f64>("pointingAngleAzStart", Self::VT_POINTINGANGLEAZSTART, false)?
     .visit_field::<f64>("pointingAngleAzEnd", Self::VT_POINTINGANGLEAZEND, false)?
     .visit_field::<f64>("pointingAngleElStart", Self::VT_POINTINGANGLEELSTART, false)?
     .visit_field::<f64>("pointingAngleElEnd", Self::VT_POINTINGANGLEELEND, false)?
     .visit_field::<i32>("pixelArrayWidth", Self::VT_PIXELARRAYWIDTH, false)?
     .visit_field::<i32>("pixelArrayHeight", Self::VT_PIXELARRAYHEIGHT, false)?
     .visit_field::<i32>("numSpectralFilters", Self::VT_NUMSPECTRALFILTERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("spectralFilters", Self::VT_SPECTRALFILTERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("collectionMode", Self::VT_COLLECTIONMODE, false)?
     .visit_field::<f64>("gain", Self::VT_GAIN, false)?
     .visit_field::<i32>("binningHoriz", Self::VT_BINNINGHORIZ, false)?
     .visit_field::<i32>("binningVert", Self::VT_BINNINGVERT, false)?
     .visit_field::<f64>("solarMag", Self::VT_SOLARMAG, false)?
     .visit_field::<i32>("pixelMin", Self::VT_PIXELMIN, false)?
     .visit_field::<i32>("pixelMax", Self::VT_PIXELMAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("softwareVersion", Self::VT_SOFTWAREVERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("satelliteName", Self::VT_SATELLITENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("starCatName", Self::VT_STARCATNAME, false)?
     .visit_field::<f64>("corrQuality", Self::VT_CORRQUALITY, false)?
     .visit_field::<bool>("uct", Self::VT_UCT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("validCalibrations", Self::VT_VALIDCALIBRATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("calibrationType", Self::VT_CALIBRATIONTYPE, false)?
     .visit_field::<f64>("percentSatThreshold", Self::VT_PERCENTSATTHRESHOLD, false)?
     .visit_field::<bool>("changeDetected", Self::VT_CHANGEDETECTED, false)?
     .visit_field::<bool>("periodicityChangeDetected", Self::VT_PERIODICITYCHANGEDETECTED, false)?
     .visit_field::<bool>("brightnessVarianceChangeDetected", Self::VT_BRIGHTNESSVARIANCECHANGEDETECTED, false)?
     .visit_field::<bool>("solarPhaseAngleBrightnessChangeDetected", Self::VT_SOLARPHASEANGLEBRIGHTNESSCHANGEDETECTED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("changeConf", Self::VT_CHANGECONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("collectionDensityConf", Self::VT_COLLECTIONDENSITYCONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("periodicitySamplingConf", Self::VT_PERIODICITYSAMPLINGCONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("periodicityDetectionConf", Self::VT_PERIODICITYDETECTIONCONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("collectionId", Self::VT_COLLECTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("calibrations", Self::VT_CALIBRATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transactionId", Self::VT_TRANSACTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("opticalSOIObservationList", Self::VT_OPTICALSOIOBSERVATIONLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("radarSOIObservationList", Self::VT_RADARSOIOBSERVATIONLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .visit_field::<SOIObservationSet_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct SOIObservationSet_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgCreateDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sensorAsId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo: i32,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub senlat: f64,
    pub senlon: f64,
    pub senalt: f64,
    pub senx: f64,
    pub seny: f64,
    pub senz: f64,
    pub senvelx: f64,
    pub senvely: f64,
    pub senvelz: f64,
    pub idElset: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub numObs: i32,
    pub type_: SOIObservationSet_Full_type_Enum,
    pub polarAngleStart: f64,
    pub polarAngleEnd: f64,
    pub referenceFrame: SOIObservationSet_Full_referenceFrame_Enum,
    pub senReferenceFrame: SOIObservationSet_Full_senReferenceFrame_Enum,
    pub losDeclinationStart: f64,
    pub losDeclinationEnd: f64,
    pub pointingAngleAzStart: f64,
    pub pointingAngleAzEnd: f64,
    pub pointingAngleElStart: f64,
    pub pointingAngleElEnd: f64,
    pub pixelArrayWidth: i32,
    pub pixelArrayHeight: i32,
    pub numSpectralFilters: i32,
    pub spectralFilters: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub collectionMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gain: f64,
    pub binningHoriz: i32,
    pub binningVert: i32,
    pub solarMag: f64,
    pub pixelMin: i32,
    pub pixelMax: i32,
    pub softwareVersion: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satelliteName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub starCatName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub corrQuality: f64,
    pub uct: bool,
    pub validCalibrations: Option<flatbuffers::WIPOffset<&'a str>>,
    pub calibrationType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub percentSatThreshold: f64,
    pub changeDetected: bool,
    pub periodicityChangeDetected: bool,
    pub brightnessVarianceChangeDetected: bool,
    pub solarPhaseAngleBrightnessChangeDetected: bool,
    pub changeConf: Option<flatbuffers::WIPOffset<&'a str>>,
    pub collectionDensityConf: Option<flatbuffers::WIPOffset<&'a str>>,
    pub periodicitySamplingConf: Option<flatbuffers::WIPOffset<&'a str>>,
    pub periodicityDetectionConf: Option<flatbuffers::WIPOffset<&'a str>>,
    pub collectionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub calibrations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub transactionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opticalSOIObservationList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub radarSOIObservationList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: SOIObservationSet_Full_dataMode_Enum,
}
impl<'a> Default for SOIObservationSet_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    SOIObservationSet_FullArgs {
      id: None,
      classificationMarking: None,
      msgCreateDate: None,
      idSensor: None,
      origSensorId: None,
      sensorAsId: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      senlat: 0.0,
      senlon: 0.0,
      senalt: 0.0,
      senx: 0.0,
      seny: 0.0,
      senz: 0.0,
      senvelx: 0.0,
      senvely: 0.0,
      senvelz: 0.0,
      idElset: None,
      startTime: None,
      endTime: None,
      numObs: 0,
      type_: SOIObservationSet_Full_type_Enum::OPTICAL,
      polarAngleStart: 0.0,
      polarAngleEnd: 0.0,
      referenceFrame: SOIObservationSet_Full_referenceFrame_Enum::J2000,
      senReferenceFrame: SOIObservationSet_Full_senReferenceFrame_Enum::J2000,
      losDeclinationStart: 0.0,
      losDeclinationEnd: 0.0,
      pointingAngleAzStart: 0.0,
      pointingAngleAzEnd: 0.0,
      pointingAngleElStart: 0.0,
      pointingAngleElEnd: 0.0,
      pixelArrayWidth: 0,
      pixelArrayHeight: 0,
      numSpectralFilters: 0,
      spectralFilters: None,
      collectionMode: None,
      gain: 0.0,
      binningHoriz: 0,
      binningVert: 0,
      solarMag: 0.0,
      pixelMin: 0,
      pixelMax: 0,
      softwareVersion: None,
      satelliteName: None,
      starCatName: None,
      corrQuality: 0.0,
      uct: false,
      validCalibrations: None,
      calibrationType: None,
      percentSatThreshold: 0.0,
      changeDetected: false,
      periodicityChangeDetected: false,
      brightnessVarianceChangeDetected: false,
      solarPhaseAngleBrightnessChangeDetected: false,
      changeConf: None,
      collectionDensityConf: None,
      periodicitySamplingConf: None,
      periodicityDetectionConf: None,
      collectionId: None,
      calibrations: None,
      tags: None,
      transactionId: None,
      opticalSOIObservationList: None,
      radarSOIObservationList: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      sourceDL: None,
      dataMode: SOIObservationSet_Full_dataMode_Enum::REAL,
    }
  }
}

pub struct SOIObservationSet_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SOIObservationSet_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_msgCreateDate(&mut self, msgCreateDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_MSGCREATEDATE, msgCreateDate);
  }
  #[inline]
  pub fn add_idSensor(&mut self, idSensor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_IDSENSOR, idSensor);
  }
  #[inline]
  pub fn add_origSensorId(&mut self, origSensorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_ORIGSENSORID, origSensorId);
  }
  #[inline]
  pub fn add_sensorAsId(&mut self, sensorAsId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_SENSORASID, sensorAsId);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(SOIObservationSet_Full::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_senlat(&mut self, senlat: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_SENLAT, senlat, 0.0);
  }
  #[inline]
  pub fn add_senlon(&mut self, senlon: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_SENLON, senlon, 0.0);
  }
  #[inline]
  pub fn add_senalt(&mut self, senalt: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_SENALT, senalt, 0.0);
  }
  #[inline]
  pub fn add_senx(&mut self, senx: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_SENX, senx, 0.0);
  }
  #[inline]
  pub fn add_seny(&mut self, seny: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_SENY, seny, 0.0);
  }
  #[inline]
  pub fn add_senz(&mut self, senz: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_SENZ, senz, 0.0);
  }
  #[inline]
  pub fn add_senvelx(&mut self, senvelx: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_SENVELX, senvelx, 0.0);
  }
  #[inline]
  pub fn add_senvely(&mut self, senvely: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_SENVELY, senvely, 0.0);
  }
  #[inline]
  pub fn add_senvelz(&mut self, senvelz: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_SENVELZ, senvelz, 0.0);
  }
  #[inline]
  pub fn add_idElset(&mut self, idElset: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_IDELSET, idElset);
  }
  #[inline]
  pub fn add_startTime(&mut self, startTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_STARTTIME, startTime);
  }
  #[inline]
  pub fn add_endTime(&mut self, endTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_ENDTIME, endTime);
  }
  #[inline]
  pub fn add_numObs(&mut self, numObs: i32) {
    self.fbb_.push_slot::<i32>(SOIObservationSet_Full::VT_NUMOBS, numObs, 0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: SOIObservationSet_Full_type_Enum) {
    self.fbb_.push_slot::<SOIObservationSet_Full_type_Enum>(SOIObservationSet_Full::VT_TYPE_, type_, SOIObservationSet_Full_type_Enum::OPTICAL);
  }
  #[inline]
  pub fn add_polarAngleStart(&mut self, polarAngleStart: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_POLARANGLESTART, polarAngleStart, 0.0);
  }
  #[inline]
  pub fn add_polarAngleEnd(&mut self, polarAngleEnd: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_POLARANGLEEND, polarAngleEnd, 0.0);
  }
  #[inline]
  pub fn add_referenceFrame(&mut self, referenceFrame: SOIObservationSet_Full_referenceFrame_Enum) {
    self.fbb_.push_slot::<SOIObservationSet_Full_referenceFrame_Enum>(SOIObservationSet_Full::VT_REFERENCEFRAME, referenceFrame, SOIObservationSet_Full_referenceFrame_Enum::J2000);
  }
  #[inline]
  pub fn add_senReferenceFrame(&mut self, senReferenceFrame: SOIObservationSet_Full_senReferenceFrame_Enum) {
    self.fbb_.push_slot::<SOIObservationSet_Full_senReferenceFrame_Enum>(SOIObservationSet_Full::VT_SENREFERENCEFRAME, senReferenceFrame, SOIObservationSet_Full_senReferenceFrame_Enum::J2000);
  }
  #[inline]
  pub fn add_losDeclinationStart(&mut self, losDeclinationStart: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_LOSDECLINATIONSTART, losDeclinationStart, 0.0);
  }
  #[inline]
  pub fn add_losDeclinationEnd(&mut self, losDeclinationEnd: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_LOSDECLINATIONEND, losDeclinationEnd, 0.0);
  }
  #[inline]
  pub fn add_pointingAngleAzStart(&mut self, pointingAngleAzStart: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_POINTINGANGLEAZSTART, pointingAngleAzStart, 0.0);
  }
  #[inline]
  pub fn add_pointingAngleAzEnd(&mut self, pointingAngleAzEnd: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_POINTINGANGLEAZEND, pointingAngleAzEnd, 0.0);
  }
  #[inline]
  pub fn add_pointingAngleElStart(&mut self, pointingAngleElStart: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_POINTINGANGLEELSTART, pointingAngleElStart, 0.0);
  }
  #[inline]
  pub fn add_pointingAngleElEnd(&mut self, pointingAngleElEnd: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_POINTINGANGLEELEND, pointingAngleElEnd, 0.0);
  }
  #[inline]
  pub fn add_pixelArrayWidth(&mut self, pixelArrayWidth: i32) {
    self.fbb_.push_slot::<i32>(SOIObservationSet_Full::VT_PIXELARRAYWIDTH, pixelArrayWidth, 0);
  }
  #[inline]
  pub fn add_pixelArrayHeight(&mut self, pixelArrayHeight: i32) {
    self.fbb_.push_slot::<i32>(SOIObservationSet_Full::VT_PIXELARRAYHEIGHT, pixelArrayHeight, 0);
  }
  #[inline]
  pub fn add_numSpectralFilters(&mut self, numSpectralFilters: i32) {
    self.fbb_.push_slot::<i32>(SOIObservationSet_Full::VT_NUMSPECTRALFILTERS, numSpectralFilters, 0);
  }
  #[inline]
  pub fn add_spectralFilters(&mut self, spectralFilters: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_SPECTRALFILTERS, spectralFilters);
  }
  #[inline]
  pub fn add_collectionMode(&mut self, collectionMode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_COLLECTIONMODE, collectionMode);
  }
  #[inline]
  pub fn add_gain(&mut self, gain: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_GAIN, gain, 0.0);
  }
  #[inline]
  pub fn add_binningHoriz(&mut self, binningHoriz: i32) {
    self.fbb_.push_slot::<i32>(SOIObservationSet_Full::VT_BINNINGHORIZ, binningHoriz, 0);
  }
  #[inline]
  pub fn add_binningVert(&mut self, binningVert: i32) {
    self.fbb_.push_slot::<i32>(SOIObservationSet_Full::VT_BINNINGVERT, binningVert, 0);
  }
  #[inline]
  pub fn add_solarMag(&mut self, solarMag: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_SOLARMAG, solarMag, 0.0);
  }
  #[inline]
  pub fn add_pixelMin(&mut self, pixelMin: i32) {
    self.fbb_.push_slot::<i32>(SOIObservationSet_Full::VT_PIXELMIN, pixelMin, 0);
  }
  #[inline]
  pub fn add_pixelMax(&mut self, pixelMax: i32) {
    self.fbb_.push_slot::<i32>(SOIObservationSet_Full::VT_PIXELMAX, pixelMax, 0);
  }
  #[inline]
  pub fn add_softwareVersion(&mut self, softwareVersion: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_SOFTWAREVERSION, softwareVersion);
  }
  #[inline]
  pub fn add_satelliteName(&mut self, satelliteName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_SATELLITENAME, satelliteName);
  }
  #[inline]
  pub fn add_starCatName(&mut self, starCatName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_STARCATNAME, starCatName);
  }
  #[inline]
  pub fn add_corrQuality(&mut self, corrQuality: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_CORRQUALITY, corrQuality, 0.0);
  }
  #[inline]
  pub fn add_uct(&mut self, uct: bool) {
    self.fbb_.push_slot::<bool>(SOIObservationSet_Full::VT_UCT, uct, false);
  }
  #[inline]
  pub fn add_validCalibrations(&mut self, validCalibrations: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_VALIDCALIBRATIONS, validCalibrations);
  }
  #[inline]
  pub fn add_calibrationType(&mut self, calibrationType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_CALIBRATIONTYPE, calibrationType);
  }
  #[inline]
  pub fn add_percentSatThreshold(&mut self, percentSatThreshold: f64) {
    self.fbb_.push_slot::<f64>(SOIObservationSet_Full::VT_PERCENTSATTHRESHOLD, percentSatThreshold, 0.0);
  }
  #[inline]
  pub fn add_changeDetected(&mut self, changeDetected: bool) {
    self.fbb_.push_slot::<bool>(SOIObservationSet_Full::VT_CHANGEDETECTED, changeDetected, false);
  }
  #[inline]
  pub fn add_periodicityChangeDetected(&mut self, periodicityChangeDetected: bool) {
    self.fbb_.push_slot::<bool>(SOIObservationSet_Full::VT_PERIODICITYCHANGEDETECTED, periodicityChangeDetected, false);
  }
  #[inline]
  pub fn add_brightnessVarianceChangeDetected(&mut self, brightnessVarianceChangeDetected: bool) {
    self.fbb_.push_slot::<bool>(SOIObservationSet_Full::VT_BRIGHTNESSVARIANCECHANGEDETECTED, brightnessVarianceChangeDetected, false);
  }
  #[inline]
  pub fn add_solarPhaseAngleBrightnessChangeDetected(&mut self, solarPhaseAngleBrightnessChangeDetected: bool) {
    self.fbb_.push_slot::<bool>(SOIObservationSet_Full::VT_SOLARPHASEANGLEBRIGHTNESSCHANGEDETECTED, solarPhaseAngleBrightnessChangeDetected, false);
  }
  #[inline]
  pub fn add_changeConf(&mut self, changeConf: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_CHANGECONF, changeConf);
  }
  #[inline]
  pub fn add_collectionDensityConf(&mut self, collectionDensityConf: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_COLLECTIONDENSITYCONF, collectionDensityConf);
  }
  #[inline]
  pub fn add_periodicitySamplingConf(&mut self, periodicitySamplingConf: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_PERIODICITYSAMPLINGCONF, periodicitySamplingConf);
  }
  #[inline]
  pub fn add_periodicityDetectionConf(&mut self, periodicityDetectionConf: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_PERIODICITYDETECTIONCONF, periodicityDetectionConf);
  }
  #[inline]
  pub fn add_collectionId(&mut self, collectionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_COLLECTIONID, collectionId);
  }
  #[inline]
  pub fn add_calibrations(&mut self, calibrations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_CALIBRATIONS, calibrations);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_transactionId(&mut self, transactionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_TRANSACTIONID, transactionId);
  }
  #[inline]
  pub fn add_opticalSOIObservationList(&mut self, opticalSOIObservationList: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_OPTICALSOIOBSERVATIONLIST, opticalSOIObservationList);
  }
  #[inline]
  pub fn add_radarSOIObservationList(&mut self, radarSOIObservationList: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_RADARSOIOBSERVATIONLIST, radarSOIObservationList);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOIObservationSet_Full::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: SOIObservationSet_Full_dataMode_Enum) {
    self.fbb_.push_slot::<SOIObservationSet_Full_dataMode_Enum>(SOIObservationSet_Full::VT_DATAMODE, dataMode, SOIObservationSet_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SOIObservationSet_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SOIObservationSet_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SOIObservationSet_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SOIObservationSet_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SOIObservationSet_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("msgCreateDate", &self.msgCreateDate());
      ds.field("idSensor", &self.idSensor());
      ds.field("origSensorId", &self.origSensorId());
      ds.field("sensorAsId", &self.sensorAsId());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("satNo", &self.satNo());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("senlat", &self.senlat());
      ds.field("senlon", &self.senlon());
      ds.field("senalt", &self.senalt());
      ds.field("senx", &self.senx());
      ds.field("seny", &self.seny());
      ds.field("senz", &self.senz());
      ds.field("senvelx", &self.senvelx());
      ds.field("senvely", &self.senvely());
      ds.field("senvelz", &self.senvelz());
      ds.field("idElset", &self.idElset());
      ds.field("startTime", &self.startTime());
      ds.field("endTime", &self.endTime());
      ds.field("numObs", &self.numObs());
      ds.field("type_", &self.type_());
      ds.field("polarAngleStart", &self.polarAngleStart());
      ds.field("polarAngleEnd", &self.polarAngleEnd());
      ds.field("referenceFrame", &self.referenceFrame());
      ds.field("senReferenceFrame", &self.senReferenceFrame());
      ds.field("losDeclinationStart", &self.losDeclinationStart());
      ds.field("losDeclinationEnd", &self.losDeclinationEnd());
      ds.field("pointingAngleAzStart", &self.pointingAngleAzStart());
      ds.field("pointingAngleAzEnd", &self.pointingAngleAzEnd());
      ds.field("pointingAngleElStart", &self.pointingAngleElStart());
      ds.field("pointingAngleElEnd", &self.pointingAngleElEnd());
      ds.field("pixelArrayWidth", &self.pixelArrayWidth());
      ds.field("pixelArrayHeight", &self.pixelArrayHeight());
      ds.field("numSpectralFilters", &self.numSpectralFilters());
      ds.field("spectralFilters", &self.spectralFilters());
      ds.field("collectionMode", &self.collectionMode());
      ds.field("gain", &self.gain());
      ds.field("binningHoriz", &self.binningHoriz());
      ds.field("binningVert", &self.binningVert());
      ds.field("solarMag", &self.solarMag());
      ds.field("pixelMin", &self.pixelMin());
      ds.field("pixelMax", &self.pixelMax());
      ds.field("softwareVersion", &self.softwareVersion());
      ds.field("satelliteName", &self.satelliteName());
      ds.field("starCatName", &self.starCatName());
      ds.field("corrQuality", &self.corrQuality());
      ds.field("uct", &self.uct());
      ds.field("validCalibrations", &self.validCalibrations());
      ds.field("calibrationType", &self.calibrationType());
      ds.field("percentSatThreshold", &self.percentSatThreshold());
      ds.field("changeDetected", &self.changeDetected());
      ds.field("periodicityChangeDetected", &self.periodicityChangeDetected());
      ds.field("brightnessVarianceChangeDetected", &self.brightnessVarianceChangeDetected());
      ds.field("solarPhaseAngleBrightnessChangeDetected", &self.solarPhaseAngleBrightnessChangeDetected());
      ds.field("changeConf", &self.changeConf());
      ds.field("collectionDensityConf", &self.collectionDensityConf());
      ds.field("periodicitySamplingConf", &self.periodicitySamplingConf());
      ds.field("periodicityDetectionConf", &self.periodicityDetectionConf());
      ds.field("collectionId", &self.collectionId());
      ds.field("calibrations", &self.calibrations());
      ds.field("tags", &self.tags());
      ds.field("transactionId", &self.transactionId());
      ds.field("opticalSOIObservationList", &self.opticalSOIObservationList());
      ds.field("radarSOIObservationList", &self.radarSOIObservationList());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("sourceDL", &self.sourceDL());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SOIObservationSet_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub msgCreateDate: Option<String>,
  pub idSensor: Option<String>,
  pub origSensorId: Option<String>,
  pub sensorAsId: Option<String>,
  pub idOnOrbit: Option<String>,
  pub satNo: i32,
  pub origObjectId: Option<String>,
  pub senlat: f64,
  pub senlon: f64,
  pub senalt: f64,
  pub senx: f64,
  pub seny: f64,
  pub senz: f64,
  pub senvelx: f64,
  pub senvely: f64,
  pub senvelz: f64,
  pub idElset: Option<String>,
  pub startTime: Option<String>,
  pub endTime: Option<String>,
  pub numObs: i32,
  pub type_: SOIObservationSet_Full_type_Enum,
  pub polarAngleStart: f64,
  pub polarAngleEnd: f64,
  pub referenceFrame: SOIObservationSet_Full_referenceFrame_Enum,
  pub senReferenceFrame: SOIObservationSet_Full_senReferenceFrame_Enum,
  pub losDeclinationStart: f64,
  pub losDeclinationEnd: f64,
  pub pointingAngleAzStart: f64,
  pub pointingAngleAzEnd: f64,
  pub pointingAngleElStart: f64,
  pub pointingAngleElEnd: f64,
  pub pixelArrayWidth: i32,
  pub pixelArrayHeight: i32,
  pub numSpectralFilters: i32,
  pub spectralFilters: Option<Vec<String>>,
  pub collectionMode: Option<String>,
  pub gain: f64,
  pub binningHoriz: i32,
  pub binningVert: i32,
  pub solarMag: f64,
  pub pixelMin: i32,
  pub pixelMax: i32,
  pub softwareVersion: Option<String>,
  pub satelliteName: Option<String>,
  pub starCatName: Option<String>,
  pub corrQuality: f64,
  pub uct: bool,
  pub validCalibrations: Option<String>,
  pub calibrationType: Option<String>,
  pub percentSatThreshold: f64,
  pub changeDetected: bool,
  pub periodicityChangeDetected: bool,
  pub brightnessVarianceChangeDetected: bool,
  pub solarPhaseAngleBrightnessChangeDetected: bool,
  pub changeConf: Option<String>,
  pub collectionDensityConf: Option<String>,
  pub periodicitySamplingConf: Option<String>,
  pub periodicityDetectionConf: Option<String>,
  pub collectionId: Option<String>,
  pub calibrations: Option<Vec<String>>,
  pub tags: Option<Vec<String>>,
  pub transactionId: Option<String>,
  pub opticalSOIObservationList: Option<Vec<String>>,
  pub radarSOIObservationList: Option<Vec<String>>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub sourceDL: Option<String>,
  pub dataMode: SOIObservationSet_Full_dataMode_Enum,
}
impl Default for SOIObservationSet_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      msgCreateDate: None,
      idSensor: None,
      origSensorId: None,
      sensorAsId: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      senlat: 0.0,
      senlon: 0.0,
      senalt: 0.0,
      senx: 0.0,
      seny: 0.0,
      senz: 0.0,
      senvelx: 0.0,
      senvely: 0.0,
      senvelz: 0.0,
      idElset: None,
      startTime: None,
      endTime: None,
      numObs: 0,
      type_: SOIObservationSet_Full_type_Enum::OPTICAL,
      polarAngleStart: 0.0,
      polarAngleEnd: 0.0,
      referenceFrame: SOIObservationSet_Full_referenceFrame_Enum::J2000,
      senReferenceFrame: SOIObservationSet_Full_senReferenceFrame_Enum::J2000,
      losDeclinationStart: 0.0,
      losDeclinationEnd: 0.0,
      pointingAngleAzStart: 0.0,
      pointingAngleAzEnd: 0.0,
      pointingAngleElStart: 0.0,
      pointingAngleElEnd: 0.0,
      pixelArrayWidth: 0,
      pixelArrayHeight: 0,
      numSpectralFilters: 0,
      spectralFilters: None,
      collectionMode: None,
      gain: 0.0,
      binningHoriz: 0,
      binningVert: 0,
      solarMag: 0.0,
      pixelMin: 0,
      pixelMax: 0,
      softwareVersion: None,
      satelliteName: None,
      starCatName: None,
      corrQuality: 0.0,
      uct: false,
      validCalibrations: None,
      calibrationType: None,
      percentSatThreshold: 0.0,
      changeDetected: false,
      periodicityChangeDetected: false,
      brightnessVarianceChangeDetected: false,
      solarPhaseAngleBrightnessChangeDetected: false,
      changeConf: None,
      collectionDensityConf: None,
      periodicitySamplingConf: None,
      periodicityDetectionConf: None,
      collectionId: None,
      calibrations: None,
      tags: None,
      transactionId: None,
      opticalSOIObservationList: None,
      radarSOIObservationList: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      sourceDL: None,
      dataMode: SOIObservationSet_Full_dataMode_Enum::REAL,
    }
  }
}
impl SOIObservationSet_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SOIObservationSet_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msgCreateDate = self.msgCreateDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor = self.idSensor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId = self.origSensorId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sensorAsId = self.sensorAsId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo = self.satNo;
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let senlat = self.senlat;
    let senlon = self.senlon;
    let senalt = self.senalt;
    let senx = self.senx;
    let seny = self.seny;
    let senz = self.senz;
    let senvelx = self.senvelx;
    let senvely = self.senvely;
    let senvelz = self.senvelz;
    let idElset = self.idElset.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let startTime = self.startTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let endTime = self.endTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let numObs = self.numObs;
    let type_ = self.type_;
    let polarAngleStart = self.polarAngleStart;
    let polarAngleEnd = self.polarAngleEnd;
    let referenceFrame = self.referenceFrame;
    let senReferenceFrame = self.senReferenceFrame;
    let losDeclinationStart = self.losDeclinationStart;
    let losDeclinationEnd = self.losDeclinationEnd;
    let pointingAngleAzStart = self.pointingAngleAzStart;
    let pointingAngleAzEnd = self.pointingAngleAzEnd;
    let pointingAngleElStart = self.pointingAngleElStart;
    let pointingAngleElEnd = self.pointingAngleElEnd;
    let pixelArrayWidth = self.pixelArrayWidth;
    let pixelArrayHeight = self.pixelArrayHeight;
    let numSpectralFilters = self.numSpectralFilters;
    let spectralFilters = self.spectralFilters.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let collectionMode = self.collectionMode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let gain = self.gain;
    let binningHoriz = self.binningHoriz;
    let binningVert = self.binningVert;
    let solarMag = self.solarMag;
    let pixelMin = self.pixelMin;
    let pixelMax = self.pixelMax;
    let softwareVersion = self.softwareVersion.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satelliteName = self.satelliteName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let starCatName = self.starCatName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let corrQuality = self.corrQuality;
    let uct = self.uct;
    let validCalibrations = self.validCalibrations.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let calibrationType = self.calibrationType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let percentSatThreshold = self.percentSatThreshold;
    let changeDetected = self.changeDetected;
    let periodicityChangeDetected = self.periodicityChangeDetected;
    let brightnessVarianceChangeDetected = self.brightnessVarianceChangeDetected;
    let solarPhaseAngleBrightnessChangeDetected = self.solarPhaseAngleBrightnessChangeDetected;
    let changeConf = self.changeConf.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let collectionDensityConf = self.collectionDensityConf.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let periodicitySamplingConf = self.periodicitySamplingConf.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let periodicityDetectionConf = self.periodicityDetectionConf.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let collectionId = self.collectionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let calibrations = self.calibrations.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let transactionId = self.transactionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let opticalSOIObservationList = self.opticalSOIObservationList.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let radarSOIObservationList = self.radarSOIObservationList.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    SOIObservationSet_Full::create(_fbb, &SOIObservationSet_FullArgs{
      id,
      classificationMarking,
      msgCreateDate,
      idSensor,
      origSensorId,
      sensorAsId,
      idOnOrbit,
      satNo,
      origObjectId,
      senlat,
      senlon,
      senalt,
      senx,
      seny,
      senz,
      senvelx,
      senvely,
      senvelz,
      idElset,
      startTime,
      endTime,
      numObs,
      type_,
      polarAngleStart,
      polarAngleEnd,
      referenceFrame,
      senReferenceFrame,
      losDeclinationStart,
      losDeclinationEnd,
      pointingAngleAzStart,
      pointingAngleAzEnd,
      pointingAngleElStart,
      pointingAngleElEnd,
      pixelArrayWidth,
      pixelArrayHeight,
      numSpectralFilters,
      spectralFilters,
      collectionMode,
      gain,
      binningHoriz,
      binningVert,
      solarMag,
      pixelMin,
      pixelMax,
      softwareVersion,
      satelliteName,
      starCatName,
      corrQuality,
      uct,
      validCalibrations,
      calibrationType,
      percentSatThreshold,
      changeDetected,
      periodicityChangeDetected,
      brightnessVarianceChangeDetected,
      solarPhaseAngleBrightnessChangeDetected,
      changeConf,
      collectionDensityConf,
      periodicitySamplingConf,
      periodicityDetectionConf,
      collectionId,
      calibrations,
      tags,
      transactionId,
      opticalSOIObservationList,
      radarSOIObservationList,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      sourceDL,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SOIObservationSet_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_soiobservation_set_full_unchecked`.
pub fn root_as_soiobservation_set_full(buf: &[u8]) -> Result<SOIObservationSet_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SOIObservationSet_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SOIObservationSet_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_soiobservation_set_full_unchecked`.
pub fn size_prefixed_root_as_soiobservation_set_full(buf: &[u8]) -> Result<SOIObservationSet_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SOIObservationSet_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SOIObservationSet_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_soiobservation_set_full_unchecked`.
pub fn root_as_soiobservation_set_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SOIObservationSet_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SOIObservationSet_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SOIObservationSet_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_soiobservation_set_full_unchecked`.
pub fn size_prefixed_root_as_soiobservation_set_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SOIObservationSet_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SOIObservationSet_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SOIObservationSet_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SOIObservationSet_Full`.
pub unsafe fn root_as_soiobservation_set_full_unchecked(buf: &[u8]) -> SOIObservationSet_Full {
  flatbuffers::root_unchecked::<SOIObservationSet_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SOIObservationSet_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SOIObservationSet_Full`.
pub unsafe fn size_prefixed_root_as_soiobservation_set_full_unchecked(buf: &[u8]) -> SOIObservationSet_Full {
  flatbuffers::size_prefixed_root_unchecked::<SOIObservationSet_Full>(buf)
}
pub const SOIOBSERVATION_SET_FULL_IDENTIFIER: &str = "SOIO";

#[inline]
pub fn soiobservation_set_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SOIOBSERVATION_SET_FULL_IDENTIFIER, false)
}

#[inline]
pub fn soiobservation_set_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SOIOBSERVATION_SET_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_soiobservation_set_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<SOIObservationSet_Full<'a>>) {
  fbb.finish(root, Some(SOIOBSERVATION_SET_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_soiobservation_set_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<SOIObservationSet_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(SOIOBSERVATION_SET_FULL_IDENTIFIER));
}
