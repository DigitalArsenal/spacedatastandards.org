// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STATE_VECTOR_FULL_REFERENCE_FRAME_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STATE_VECTOR_FULL_REFERENCE_FRAME_ENUM: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STATE_VECTOR_FULL_REFERENCE_FRAME_ENUM: [StateVector_Full_referenceFrame_Enum; 6] = [
  StateVector_Full_referenceFrame_Enum::J2000,
  StateVector_Full_referenceFrame_Enum::EFG_TDR,
  StateVector_Full_referenceFrame_Enum::ECR_ECEF,
  StateVector_Full_referenceFrame_Enum::TEME,
  StateVector_Full_referenceFrame_Enum::ITRF,
  StateVector_Full_referenceFrame_Enum::GCRF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct StateVector_Full_referenceFrame_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl StateVector_Full_referenceFrame_Enum {
  /// No description available.
  pub const J2000: Self = Self(0);
  /// No description available.
  pub const EFG_TDR: Self = Self(1);
  /// No description available.
  pub const ECR_ECEF: Self = Self(2);
  /// No description available.
  pub const TEME: Self = Self(3);
  /// No description available.
  pub const ITRF: Self = Self(4);
  /// No description available.
  pub const GCRF: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::J2000,
    Self::EFG_TDR,
    Self::ECR_ECEF,
    Self::TEME,
    Self::ITRF,
    Self::GCRF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::J2000 => Some("J2000"),
      Self::EFG_TDR => Some("EFG_TDR"),
      Self::ECR_ECEF => Some("ECR_ECEF"),
      Self::TEME => Some("TEME"),
      Self::ITRF => Some("ITRF"),
      Self::GCRF => Some("GCRF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for StateVector_Full_referenceFrame_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for StateVector_Full_referenceFrame_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for StateVector_Full_referenceFrame_Enum {
    type Output = StateVector_Full_referenceFrame_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for StateVector_Full_referenceFrame_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for StateVector_Full_referenceFrame_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for StateVector_Full_referenceFrame_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STATE_VECTOR_FULL_COV_REFERENCE_FRAME_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STATE_VECTOR_FULL_COV_REFERENCE_FRAME_ENUM: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STATE_VECTOR_FULL_COV_REFERENCE_FRAME_ENUM: [StateVector_Full_covReferenceFrame_Enum; 2] = [
  StateVector_Full_covReferenceFrame_Enum::J2000,
  StateVector_Full_covReferenceFrame_Enum::UVW,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct StateVector_Full_covReferenceFrame_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl StateVector_Full_covReferenceFrame_Enum {
  /// No description available.
  pub const J2000: Self = Self(0);
  /// No description available.
  pub const UVW: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::J2000,
    Self::UVW,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::J2000 => Some("J2000"),
      Self::UVW => Some("UVW"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for StateVector_Full_covReferenceFrame_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for StateVector_Full_covReferenceFrame_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for StateVector_Full_covReferenceFrame_Enum {
    type Output = StateVector_Full_covReferenceFrame_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for StateVector_Full_covReferenceFrame_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for StateVector_Full_covReferenceFrame_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for StateVector_Full_covReferenceFrame_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STATE_VECTOR_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STATE_VECTOR_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STATE_VECTOR_FULL_DATA_MODE_ENUM: [StateVector_Full_dataMode_Enum; 4] = [
  StateVector_Full_dataMode_Enum::REAL,
  StateVector_Full_dataMode_Enum::TEST,
  StateVector_Full_dataMode_Enum::SIMULATED,
  StateVector_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct StateVector_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl StateVector_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for StateVector_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for StateVector_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for StateVector_Full_dataMode_Enum {
    type Output = StateVector_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for StateVector_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for StateVector_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for StateVector_Full_dataMode_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STATE_VECTOR_FULL_SOURCED_DATA_TYPES_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STATE_VECTOR_FULL_SOURCED_DATA_TYPES_ENUM: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STATE_VECTOR_FULL_SOURCED_DATA_TYPES_ENUM: [StateVector_Full_sourcedDataTypes_Enum; 6] = [
  StateVector_Full_sourcedDataTypes_Enum::EO,
  StateVector_Full_sourcedDataTypes_Enum::RADAR,
  StateVector_Full_sourcedDataTypes_Enum::RF,
  StateVector_Full_sourcedDataTypes_Enum::DOA,
  StateVector_Full_sourcedDataTypes_Enum::ELSET,
  StateVector_Full_sourcedDataTypes_Enum::SV,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct StateVector_Full_sourcedDataTypes_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl StateVector_Full_sourcedDataTypes_Enum {
  /// No description available.
  pub const EO: Self = Self(0);
  /// No description available.
  pub const RADAR: Self = Self(1);
  /// No description available.
  pub const RF: Self = Self(2);
  /// No description available.
  pub const DOA: Self = Self(3);
  /// No description available.
  pub const ELSET: Self = Self(4);
  /// No description available.
  pub const SV: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EO,
    Self::RADAR,
    Self::RF,
    Self::DOA,
    Self::ELSET,
    Self::SV,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::EO => Some("EO"),
      Self::RADAR => Some("RADAR"),
      Self::RF => Some("RF"),
      Self::DOA => Some("DOA"),
      Self::ELSET => Some("ELSET"),
      Self::SV => Some("SV"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for StateVector_Full_sourcedDataTypes_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for StateVector_Full_sourcedDataTypes_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for StateVector_Full_sourcedDataTypes_Enum {
    type Output = StateVector_Full_sourcedDataTypes_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for StateVector_Full_sourcedDataTypes_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for StateVector_Full_sourcedDataTypes_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for StateVector_Full_sourcedDataTypes_Enum {}
pub enum StateVector_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Discover' tab in the storefront to confirm coordinate frames by data provider.
pub struct StateVector_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StateVector_Full<'a> {
  type Inner = StateVector_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StateVector_Full<'a> {
  pub const VT_IDSTATEVECTOR: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_EPOCH: flatbuffers::VOffsetT = 8;
  pub const VT_PEDIGREE: flatbuffers::VOffsetT = 10;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 12;
  pub const VT_SATNO: flatbuffers::VOffsetT = 14;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 16;
  pub const VT_IDORBITDETERMINATION: flatbuffers::VOffsetT = 18;
  pub const VT_UCT: flatbuffers::VOffsetT = 20;
  pub const VT_XPOS: flatbuffers::VOffsetT = 22;
  pub const VT_YPOS: flatbuffers::VOffsetT = 24;
  pub const VT_ZPOS: flatbuffers::VOffsetT = 26;
  pub const VT_XVEL: flatbuffers::VOffsetT = 28;
  pub const VT_YVEL: flatbuffers::VOffsetT = 30;
  pub const VT_ZVEL: flatbuffers::VOffsetT = 32;
  pub const VT_REFERENCEFRAME: flatbuffers::VOffsetT = 34;
  pub const VT_COV: flatbuffers::VOffsetT = 36;
  pub const VT_COVREFERENCEFRAME: flatbuffers::VOffsetT = 38;
  pub const VT_COVMETHOD: flatbuffers::VOffsetT = 40;
  pub const VT_EQCOV: flatbuffers::VOffsetT = 42;
  pub const VT_XPOSALT1: flatbuffers::VOffsetT = 44;
  pub const VT_YPOSALT1: flatbuffers::VOffsetT = 46;
  pub const VT_ZPOSALT1: flatbuffers::VOffsetT = 48;
  pub const VT_XVELALT1: flatbuffers::VOffsetT = 50;
  pub const VT_YVELALT1: flatbuffers::VOffsetT = 52;
  pub const VT_ZVELALT1: flatbuffers::VOffsetT = 54;
  pub const VT_ALT1REFERENCEFRAME: flatbuffers::VOffsetT = 56;
  pub const VT_XPOSALT2: flatbuffers::VOffsetT = 58;
  pub const VT_YPOSALT2: flatbuffers::VOffsetT = 60;
  pub const VT_ZPOSALT2: flatbuffers::VOffsetT = 62;
  pub const VT_XVELALT2: flatbuffers::VOffsetT = 64;
  pub const VT_YVELALT2: flatbuffers::VOffsetT = 66;
  pub const VT_ZVELALT2: flatbuffers::VOffsetT = 68;
  pub const VT_ALT2REFERENCEFRAME: flatbuffers::VOffsetT = 70;
  pub const VT_POSUNC: flatbuffers::VOffsetT = 72;
  pub const VT_VELUNC: flatbuffers::VOffsetT = 74;
  pub const VT_MASS: flatbuffers::VOffsetT = 76;
  pub const VT_AREA: flatbuffers::VOffsetT = 78;
  pub const VT_SOLARRADPRESSCOEFF: flatbuffers::VOffsetT = 80;
  pub const VT_DRAGCOEFF: flatbuffers::VOffsetT = 82;
  pub const VT_DRAGAREA: flatbuffers::VOffsetT = 84;
  pub const VT_REVNO: flatbuffers::VOffsetT = 86;
  pub const VT_GEOPOTENTIALMODEL: flatbuffers::VOffsetT = 88;
  pub const VT_DRAGMODEL: flatbuffers::VOffsetT = 90;
  pub const VT_LUNARSOLAR: flatbuffers::VOffsetT = 92;
  pub const VT_SOLARRADPRESS: flatbuffers::VOffsetT = 94;
  pub const VT_SRPAREA: flatbuffers::VOffsetT = 96;
  pub const VT_SOLIDEARTHTIDES: flatbuffers::VOffsetT = 98;
  pub const VT_INTRACKTHRUST: flatbuffers::VOffsetT = 100;
  pub const VT_BDOT: flatbuffers::VOffsetT = 102;
  pub const VT_EDR: flatbuffers::VOffsetT = 104;
  pub const VT_THRUSTACCEL: flatbuffers::VOffsetT = 106;
  pub const VT_CMOFFSET: flatbuffers::VOffsetT = 108;
  pub const VT_LASTOBSTART: flatbuffers::VOffsetT = 110;
  pub const VT_LASTOBEND: flatbuffers::VOffsetT = 112;
  pub const VT_OBSAVAILABLE: flatbuffers::VOffsetT = 114;
  pub const VT_OBSUSED: flatbuffers::VOffsetT = 116;
  pub const VT_TRACKSAVAIL: flatbuffers::VOffsetT = 118;
  pub const VT_TRACKSUSED: flatbuffers::VOffsetT = 120;
  pub const VT_RECODSPAN: flatbuffers::VOffsetT = 122;
  pub const VT_ACTUALODSPAN: flatbuffers::VOffsetT = 124;
  pub const VT_RESIDUALSACC: flatbuffers::VOffsetT = 126;
  pub const VT_SOLARFLUXF10: flatbuffers::VOffsetT = 128;
  pub const VT_SOLARFLUXF10AVG: flatbuffers::VOffsetT = 130;
  pub const VT_SOLARFLUXAPAVG: flatbuffers::VOffsetT = 132;
  pub const VT_TAIUTC: flatbuffers::VOffsetT = 134;
  pub const VT_UT1UTC: flatbuffers::VOffsetT = 136;
  pub const VT_UT1RATE: flatbuffers::VOffsetT = 138;
  pub const VT_POLARMOTIONX: flatbuffers::VOffsetT = 140;
  pub const VT_POLARMOTIONY: flatbuffers::VOffsetT = 142;
  pub const VT_IAU1980TERMS: flatbuffers::VOffsetT = 144;
  pub const VT_LEAPSECONDTIME: flatbuffers::VOffsetT = 146;
  pub const VT_INTEGRATORMODE: flatbuffers::VOffsetT = 148;
  pub const VT_PARTIALS: flatbuffers::VOffsetT = 150;
  pub const VT_STEPMODE: flatbuffers::VOffsetT = 152;
  pub const VT_FIXEDSTEP: flatbuffers::VOffsetT = 154;
  pub const VT_STEPSIZESELECTION: flatbuffers::VOffsetT = 156;
  pub const VT_STEPSIZE: flatbuffers::VOffsetT = 158;
  pub const VT_ERRORCONTROL: flatbuffers::VOffsetT = 160;
  pub const VT_SIGMAPOSUVW: flatbuffers::VOffsetT = 162;
  pub const VT_SIGMAVELUVW: flatbuffers::VOffsetT = 164;
  pub const VT_RMS: flatbuffers::VOffsetT = 166;
  pub const VT_EFFECTIVEFROM: flatbuffers::VOffsetT = 168;
  pub const VT_EFFECTIVEUNTIL: flatbuffers::VOffsetT = 170;
  pub const VT_RAWFILEURI: flatbuffers::VOffsetT = 172;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 174;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 176;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 178;
  pub const VT_TAGS: flatbuffers::VOffsetT = 180;
  pub const VT_ALGORITHM: flatbuffers::VOffsetT = 182;
  pub const VT_SOURCEDDATA: flatbuffers::VOffsetT = 184;
  pub const VT_SOURCEDDATATYPES: flatbuffers::VOffsetT = 186;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 188;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 190;
  pub const VT_ONORBIT: flatbuffers::VOffsetT = 192;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 194;
  pub const VT_TRANSACTIONID: flatbuffers::VOffsetT = 196;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 198;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 200;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StateVector_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StateVector_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<StateVector_Full<'bldr>> {
    let mut builder = StateVector_FullBuilder::new(_fbb);
    builder.add_rms(args.rms);
    builder.add_errorControl(args.errorControl);
    builder.add_stepSize(args.stepSize);
    builder.add_polarMotionY(args.polarMotionY);
    builder.add_polarMotionX(args.polarMotionX);
    builder.add_ut1Rate(args.ut1Rate);
    builder.add_ut1Utc(args.ut1Utc);
    builder.add_taiUtc(args.taiUtc);
    builder.add_solarFluxAPAvg(args.solarFluxAPAvg);
    builder.add_solarFluxF10Avg(args.solarFluxF10Avg);
    builder.add_solarFluxF10(args.solarFluxF10);
    builder.add_residualsAcc(args.residualsAcc);
    builder.add_actualODSpan(args.actualODSpan);
    builder.add_recODSpan(args.recODSpan);
    builder.add_cmOffset(args.cmOffset);
    builder.add_thrustAccel(args.thrustAccel);
    builder.add_edr(args.edr);
    builder.add_bDot(args.bDot);
    builder.add_srpArea(args.srpArea);
    builder.add_dragArea(args.dragArea);
    builder.add_dragCoeff(args.dragCoeff);
    builder.add_solarRadPressCoeff(args.solarRadPressCoeff);
    builder.add_area(args.area);
    builder.add_mass(args.mass);
    builder.add_velUnc(args.velUnc);
    builder.add_posUnc(args.posUnc);
    builder.add_zvelAlt2(args.zvelAlt2);
    builder.add_yvelAlt2(args.yvelAlt2);
    builder.add_xvelAlt2(args.xvelAlt2);
    builder.add_zposAlt2(args.zposAlt2);
    builder.add_yposAlt2(args.yposAlt2);
    builder.add_xposAlt2(args.xposAlt2);
    builder.add_zvelAlt1(args.zvelAlt1);
    builder.add_yvelAlt1(args.yvelAlt1);
    builder.add_xvelAlt1(args.xvelAlt1);
    builder.add_zposAlt1(args.zposAlt1);
    builder.add_yposAlt1(args.yposAlt1);
    builder.add_xposAlt1(args.xposAlt1);
    builder.add_zvel(args.zvel);
    builder.add_yvel(args.yvel);
    builder.add_xvel(args.xvel);
    builder.add_zpos(args.zpos);
    builder.add_ypos(args.ypos);
    builder.add_xpos(args.xpos);
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.transactionId { builder.add_transactionId(x); }
    if let Some(x) = args.descriptor { builder.add_descriptor(x); }
    if let Some(x) = args.onOrbit { builder.add_onOrbit(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.sourcedData { builder.add_sourcedData(x); }
    if let Some(x) = args.algorithm { builder.add_algorithm(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.rawFileURI { builder.add_rawFileURI(x); }
    if let Some(x) = args.effectiveUntil { builder.add_effectiveUntil(x); }
    if let Some(x) = args.effectiveFrom { builder.add_effectiveFrom(x); }
    if let Some(x) = args.sigmaVelUVW { builder.add_sigmaVelUVW(x); }
    if let Some(x) = args.sigmaPosUVW { builder.add_sigmaPosUVW(x); }
    if let Some(x) = args.stepSizeSelection { builder.add_stepSizeSelection(x); }
    if let Some(x) = args.stepMode { builder.add_stepMode(x); }
    if let Some(x) = args.partials { builder.add_partials(x); }
    if let Some(x) = args.integratorMode { builder.add_integratorMode(x); }
    if let Some(x) = args.leapSecondTime { builder.add_leapSecondTime(x); }
    builder.add_iau1980Terms(args.iau1980Terms);
    builder.add_tracksUsed(args.tracksUsed);
    builder.add_tracksAvail(args.tracksAvail);
    builder.add_obsUsed(args.obsUsed);
    builder.add_obsAvailable(args.obsAvailable);
    if let Some(x) = args.lastObEnd { builder.add_lastObEnd(x); }
    if let Some(x) = args.lastObStart { builder.add_lastObStart(x); }
    if let Some(x) = args.dragModel { builder.add_dragModel(x); }
    if let Some(x) = args.geopotentialModel { builder.add_geopotentialModel(x); }
    builder.add_revNo(args.revNo);
    if let Some(x) = args.alt2ReferenceFrame { builder.add_alt2ReferenceFrame(x); }
    if let Some(x) = args.alt1ReferenceFrame { builder.add_alt1ReferenceFrame(x); }
    if let Some(x) = args.eqCov { builder.add_eqCov(x); }
    if let Some(x) = args.covMethod { builder.add_covMethod(x); }
    if let Some(x) = args.cov { builder.add_cov(x); }
    if let Some(x) = args.idOrbitDetermination { builder.add_idOrbitDetermination(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.pedigree { builder.add_pedigree(x); }
    if let Some(x) = args.epoch { builder.add_epoch(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.idStateVector { builder.add_idStateVector(x); }
    builder.add_sourcedDataTypes(args.sourcedDataTypes);
    builder.add_dataMode(args.dataMode);
    builder.add_fixedStep(args.fixedStep);
    builder.add_inTrackThrust(args.inTrackThrust);
    builder.add_solidEarthTides(args.solidEarthTides);
    builder.add_solarRadPress(args.solarRadPress);
    builder.add_lunarSolar(args.lunarSolar);
    builder.add_covReferenceFrame(args.covReferenceFrame);
    builder.add_referenceFrame(args.referenceFrame);
    builder.add_uct(args.uct);
    builder.finish()
  }

  pub fn unpack(&self) -> StateVector_FullT {
    let idStateVector = self.idStateVector().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let epoch = self.epoch().map(|x| {
      x.to_string()
    });
    let pedigree = self.pedigree().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let satNo = self.satNo();
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let idOrbitDetermination = self.idOrbitDetermination().map(|x| {
      x.to_string()
    });
    let uct = self.uct();
    let xpos = self.xpos();
    let ypos = self.ypos();
    let zpos = self.zpos();
    let xvel = self.xvel();
    let yvel = self.yvel();
    let zvel = self.zvel();
    let referenceFrame = self.referenceFrame();
    let cov = self.cov().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let covReferenceFrame = self.covReferenceFrame();
    let covMethod = self.covMethod().map(|x| {
      x.to_string()
    });
    let eqCov = self.eqCov().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let xposAlt1 = self.xposAlt1();
    let yposAlt1 = self.yposAlt1();
    let zposAlt1 = self.zposAlt1();
    let xvelAlt1 = self.xvelAlt1();
    let yvelAlt1 = self.yvelAlt1();
    let zvelAlt1 = self.zvelAlt1();
    let alt1ReferenceFrame = self.alt1ReferenceFrame().map(|x| {
      x.to_string()
    });
    let xposAlt2 = self.xposAlt2();
    let yposAlt2 = self.yposAlt2();
    let zposAlt2 = self.zposAlt2();
    let xvelAlt2 = self.xvelAlt2();
    let yvelAlt2 = self.yvelAlt2();
    let zvelAlt2 = self.zvelAlt2();
    let alt2ReferenceFrame = self.alt2ReferenceFrame().map(|x| {
      x.to_string()
    });
    let posUnc = self.posUnc();
    let velUnc = self.velUnc();
    let mass = self.mass();
    let area = self.area();
    let solarRadPressCoeff = self.solarRadPressCoeff();
    let dragCoeff = self.dragCoeff();
    let dragArea = self.dragArea();
    let revNo = self.revNo();
    let geopotentialModel = self.geopotentialModel().map(|x| {
      x.to_string()
    });
    let dragModel = self.dragModel().map(|x| {
      x.to_string()
    });
    let lunarSolar = self.lunarSolar();
    let solarRadPress = self.solarRadPress();
    let srpArea = self.srpArea();
    let solidEarthTides = self.solidEarthTides();
    let inTrackThrust = self.inTrackThrust();
    let bDot = self.bDot();
    let edr = self.edr();
    let thrustAccel = self.thrustAccel();
    let cmOffset = self.cmOffset();
    let lastObStart = self.lastObStart().map(|x| {
      x.to_string()
    });
    let lastObEnd = self.lastObEnd().map(|x| {
      x.to_string()
    });
    let obsAvailable = self.obsAvailable();
    let obsUsed = self.obsUsed();
    let tracksAvail = self.tracksAvail();
    let tracksUsed = self.tracksUsed();
    let recODSpan = self.recODSpan();
    let actualODSpan = self.actualODSpan();
    let residualsAcc = self.residualsAcc();
    let solarFluxF10 = self.solarFluxF10();
    let solarFluxF10Avg = self.solarFluxF10Avg();
    let solarFluxAPAvg = self.solarFluxAPAvg();
    let taiUtc = self.taiUtc();
    let ut1Utc = self.ut1Utc();
    let ut1Rate = self.ut1Rate();
    let polarMotionX = self.polarMotionX();
    let polarMotionY = self.polarMotionY();
    let iau1980Terms = self.iau1980Terms();
    let leapSecondTime = self.leapSecondTime().map(|x| {
      x.to_string()
    });
    let integratorMode = self.integratorMode().map(|x| {
      x.to_string()
    });
    let partials = self.partials().map(|x| {
      x.to_string()
    });
    let stepMode = self.stepMode().map(|x| {
      x.to_string()
    });
    let fixedStep = self.fixedStep();
    let stepSizeSelection = self.stepSizeSelection().map(|x| {
      x.to_string()
    });
    let stepSize = self.stepSize();
    let errorControl = self.errorControl();
    let sigmaPosUVW = self.sigmaPosUVW().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let sigmaVelUVW = self.sigmaVelUVW().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let rms = self.rms();
    let effectiveFrom = self.effectiveFrom().map(|x| {
      x.to_string()
    });
    let effectiveUntil = self.effectiveUntil().map(|x| {
      x.to_string()
    });
    let rawFileURI = self.rawFileURI().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let tags = self.tags().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let algorithm = self.algorithm().map(|x| {
      x.to_string()
    });
    let sourcedData = self.sourcedData().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let sourcedDataTypes = self.sourcedDataTypes();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let onOrbit = self.onOrbit().map(|x| {
      x.to_string()
    });
    let descriptor = self.descriptor().map(|x| {
      x.to_string()
    });
    let transactionId = self.transactionId().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    StateVector_FullT {
      idStateVector,
      classificationMarking,
      epoch,
      pedigree,
      idOnOrbit,
      satNo,
      origObjectId,
      idOrbitDetermination,
      uct,
      xpos,
      ypos,
      zpos,
      xvel,
      yvel,
      zvel,
      referenceFrame,
      cov,
      covReferenceFrame,
      covMethod,
      eqCov,
      xposAlt1,
      yposAlt1,
      zposAlt1,
      xvelAlt1,
      yvelAlt1,
      zvelAlt1,
      alt1ReferenceFrame,
      xposAlt2,
      yposAlt2,
      zposAlt2,
      xvelAlt2,
      yvelAlt2,
      zvelAlt2,
      alt2ReferenceFrame,
      posUnc,
      velUnc,
      mass,
      area,
      solarRadPressCoeff,
      dragCoeff,
      dragArea,
      revNo,
      geopotentialModel,
      dragModel,
      lunarSolar,
      solarRadPress,
      srpArea,
      solidEarthTides,
      inTrackThrust,
      bDot,
      edr,
      thrustAccel,
      cmOffset,
      lastObStart,
      lastObEnd,
      obsAvailable,
      obsUsed,
      tracksAvail,
      tracksUsed,
      recODSpan,
      actualODSpan,
      residualsAcc,
      solarFluxF10,
      solarFluxF10Avg,
      solarFluxAPAvg,
      taiUtc,
      ut1Utc,
      ut1Rate,
      polarMotionX,
      polarMotionY,
      iau1980Terms,
      leapSecondTime,
      integratorMode,
      partials,
      stepMode,
      fixedStep,
      stepSizeSelection,
      stepSize,
      errorControl,
      sigmaPosUVW,
      sigmaVelUVW,
      rms,
      effectiveFrom,
      effectiveUntil,
      rawFileURI,
      source,
      origin,
      dataMode,
      tags,
      algorithm,
      sourcedData,
      sourcedDataTypes,
      createdAt,
      createdBy,
      onOrbit,
      descriptor,
      transactionId,
      origNetwork,
      sourceDL,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: STATEVECTOR-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn idStateVector(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_IDSTATEVECTOR, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Time of validity for state vector in ISO 8601 UTC datetime format, with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn epoch(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_EPOCH, None)}
  }
  /// The pedigree of state vector, or methods used for its generation to include state update/orbit determination, propagation from another state, or a state from a calibration satellite (e.g. ORBIT_UPDATE, PROPAGATION, CALIBRATION, CONJUNCTION, FLIGHT_PLAN).
  /// Example: /// Example: CONJUNCTION
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn pedigree(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_PEDIGREE, None)}
  }
  /// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_IDONORBIT, None)}
  }
  /// Satellite/Catalog number of the target OnOrbit object.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StateVector_Full::VT_SATNO, Some(0)).unwrap()}
  }
  /// Optional identifier provided by state vector source to indicate the target onorbit object of this state vector. This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_ORIGOBJECTID, None)}
  }
  /// Unique identifier of the OD solution record that produced this state vector. This ID can be used to obtain additional information on an OrbitDetermination object using the 'get by ID' operation (e.g. /udl/orbitdetermination/{id}). For example, the OrbitDetermination with idOrbitDetermination = abc would be queries as /udl/orbitdetermination/abc.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOrbitDetermination(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_IDORBITDETERMINATION, None)}
  }
  /// Boolean indicating this state vector was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn uct(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StateVector_Full::VT_UCT, Some(false)).unwrap()}
  }
  /// Cartesian X position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: -1118.577381
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xpos(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_XPOS, Some(0.0)).unwrap()}
  }
  /// Cartesian Y position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 3026.231084
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ypos(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_YPOS, Some(0.0)).unwrap()}
  }
  /// Cartesian Z position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 6167.831808
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zpos(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_ZPOS, Some(0.0)).unwrap()}
  }
  /// Cartesian X velocity of target, in kilometers/second, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: -4.25242784
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xvel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_XVEL, Some(0.0)).unwrap()}
  }
  /// Cartesian Y velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 5.291107434
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yvel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_YVEL, Some(0.0)).unwrap()}
  }
  /// Cartesian Z velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: -3.356493869
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zvel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_ZVEL, Some(0.0)).unwrap()}
  }
  /// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn referenceFrame(&self) -> StateVector_Full_referenceFrame_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StateVector_Full_referenceFrame_Enum>(StateVector_Full::VT_REFERENCEFRAME, Some(StateVector_Full_referenceFrame_Enum::J2000)).unwrap()}
  }
  /// Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.  If the covReferenceFrame is null it is assumed to be J2000.
  /// The array values (1-21) represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR&nbsp;&nbsp;
  /// x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
  /// y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3
  /// z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6
  /// x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;10
  /// y'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
  /// z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;
  /// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
  /// If additional covariance terms are included for DRAG, SRP, and/or THRUST, the matrix can be extended with the following order of elements:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR
  /// DRG&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;23&nbsp;&nbsp;24&nbsp;&nbsp;25&nbsp;&nbsp;26&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;
  /// SRP&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;30&nbsp;&nbsp;31&nbsp;&nbsp;32&nbsp;&nbsp;33&nbsp;&nbsp;&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;
  /// THR&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;38&nbsp;&nbsp;39&nbsp;&nbsp;40&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45&nbsp;
  /// Example: /// Example: [1.1, 2.2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cov(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StateVector_Full::VT_COV, None)}
  }
  /// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn covReferenceFrame(&self) -> StateVector_Full_covReferenceFrame_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StateVector_Full_covReferenceFrame_Enum>(StateVector_Full::VT_COVREFERENCEFRAME, Some(StateVector_Full_covReferenceFrame_Enum::J2000)).unwrap()}
  }
  /// The method used to generate the covariance during the orbit determination (OD) that produced the state vector, or whether an arbitrary, non-calculated default value was used (CALCULATED, DEFAULT).
  /// Example: /// Example: CALCULATED
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn covMethod(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_COVMETHOD, None)}
  }
  /// The covariance matrix values represent the lower triangular half of the covariance matrix in terms of equinoctial elements.&nbsp; The size of the covariance matrix is dynamic.&nbsp; The values are outputted in order across each row, i.e.:
  /// 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5
  /// 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp; 10
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// 51&nbsp; 52&nbsp; 53&nbsp; 54&nbsp; 55
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// The ordering of values is as follows:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Af&nbsp;&nbsp; Ag&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp; N&nbsp;&nbsp; Chi&nbsp; Psi&nbsp;&nbsp; B&nbsp;&nbsp; BDOT AGOM&nbsp; T&nbsp;&nbsp; C1&nbsp;&nbsp; C2&nbsp; ...
  /// Af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
  /// Ag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3
  /// L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 6
  /// N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 10
  /// Chi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; 12&nbsp;&nbsp; 13&nbsp;&nbsp; 14&nbsp;&nbsp; 15
  /// Psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 17&nbsp;&nbsp; 18&nbsp;&nbsp; 19&nbsp;&nbsp; 20&nbsp;&nbsp; 21
  /// B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 23&nbsp;&nbsp; 24 &nbsp;&nbsp;25&nbsp;&nbsp; 26&nbsp;&nbsp; 27&nbsp;&nbsp; 28
  /// BDOT&nbsp;&nbsp; 29&nbsp;&nbsp; 30&nbsp;&nbsp; 31&nbsp;&nbsp; 32&nbsp;&nbsp; 33&nbsp;&nbsp; 34&nbsp;&nbsp; 35&nbsp;&nbsp; 36
  /// AGOM&nbsp; 37&nbsp;&nbsp; 38&nbsp;&nbsp; 39&nbsp;&nbsp; 40&nbsp;&nbsp; 41&nbsp;&nbsp; 42&nbsp;&nbsp; 43&nbsp;&nbsp; 44&nbsp;&nbsp; 45
  /// T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;&nbsp; 47&nbsp;&nbsp; 48&nbsp;&nbsp; 49&nbsp;&nbsp; 50&nbsp;&nbsp; 51&nbsp;&nbsp; 52&nbsp;&nbsp; 53&nbsp;&nbsp; 54&nbsp;&nbsp; 55
  /// C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 56&nbsp;&nbsp; 57&nbsp;&nbsp; 58&nbsp;&nbsp; 59&nbsp;&nbsp; 60&nbsp;&nbsp; 61&nbsp;&nbsp; 62&nbsp;&nbsp; 63&nbsp;&nbsp; 64&nbsp;&nbsp; 65&nbsp;&nbsp; 66
  /// C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67&nbsp;&nbsp; 68&nbsp;&nbsp; 69&nbsp;&nbsp; 70&nbsp;&nbsp; 71&nbsp; &nbsp;72&nbsp;&nbsp; 73&nbsp;&nbsp; 74&nbsp;&nbsp; 75&nbsp;&nbsp; 76&nbsp;&nbsp; 77&nbsp;&nbsp; 78
  /// :
  /// :
  /// where C1, C2, etc, are the "consider parameters" that may be added to the covariance matrix.&nbsp; The covariance matrix will be as large as the last element/model parameter needed.&nbsp; In other words, if the DC solved for all 6 elements plus AGOM, the covariance matrix will be 9x9 (and the rows for B and BDOT will be all zeros).&nbsp; If the covariance matrix is unavailable, the size will be set to 0x0, and no data will follow.&nbsp; The cov field should contain only the lower left triangle values from top left down to bottom right, in order.
  /// Example: /// Example: [1.1, 2.2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn eqCov(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StateVector_Full::VT_EQCOV, None)}
  }
  /// Cartesian X position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -1145.688502
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xposAlt1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_XPOSALT1, Some(0.0)).unwrap()}
  }
  /// Cartesian Y position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 3020.729572
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yposAlt1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_YPOSALT1, Some(0.0)).unwrap()}
  }
  /// Cartesian Z position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 6165.55187
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zposAlt1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_ZPOSALT1, Some(0.0)).unwrap()}
  }
  /// Cartesian X velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -4.270832252
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xvelAlt1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_XVELALT1, Some(0.0)).unwrap()}
  }
  /// Cartesian Y velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 5.27074276
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yvelAlt1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_YVELALT1, Some(0.0)).unwrap()}
  }
  /// Cartesian Z velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -3.365155181
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zvelAlt1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_ZVELALT1, Some(0.0)).unwrap()}
  }
  /// The reference frame of the alternate1 (Alt1) cartesian orbital state.
  /// Example: /// Example: TEME
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn alt1ReferenceFrame(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_ALT1REFERENCEFRAME, None)}
  }
  /// Cartesian X position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -1456.915926
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xposAlt2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_XPOSALT2, Some(0.0)).unwrap()}
  }
  /// Cartesian Y position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -2883.540406
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yposAlt2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_YPOSALT2, Some(0.0)).unwrap()}
  }
  /// Cartesian Z position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 6165.55187
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zposAlt2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_ZPOSALT2, Some(0.0)).unwrap()}
  }
  /// Cartesian X velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -1.219814294
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xvelAlt2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_XVELALT2, Some(0.0)).unwrap()}
  }
  /// Cartesian Y velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -6.602080212
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yvelAlt2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_YVELALT2, Some(0.0)).unwrap()}
  }
  /// Cartesian Z velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -3.365155181
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zvelAlt2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_ZVELALT2, Some(0.0)).unwrap()}
  }
  /// The reference frame of the alternate2 (Alt2) cartesian orbital state.
  /// Example: /// Example: EFG/TDR
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn alt2ReferenceFrame(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_ALT2REFERENCEFRAME, None)}
  }
  /// One sigma position uncertainty, in kilometers.
  /// Example: /// Example: 0.333399744452
  /// Constraints: No constraints specified.
  #[inline]
  pub fn posUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_POSUNC, Some(0.0)).unwrap()}
  }
  /// One sigma velocity uncertainty, in kilometers/second.
  /// Example: /// Example: 4e-06
  /// Constraints: No constraints specified.
  #[inline]
  pub fn velUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_VELUNC, Some(0.0)).unwrap()}
  }
  /// The mass of the object, in kilograms.
  /// Example: /// Example: 164.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_MASS, Some(0.0)).unwrap()}
  }
  /// The actual area of the object at it's largest cross-section, expressed in meters^2.
  /// Example: /// Example: 5.065
  /// Constraints: No constraints specified.
  #[inline]
  pub fn area(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_AREA, Some(0.0)).unwrap()}
  }
  /// Area-to-mass ratio coefficient for solar radiation pressure.
  /// Example: /// Example: 0.0244394
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solarRadPressCoeff(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_SOLARRADPRESSCOEFF, Some(0.0)).unwrap()}
  }
  /// Area-to-mass ratio coefficient for atmospheric ballistic drag (m2/kg).
  /// Example: /// Example: 0.0224391269775
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dragCoeff(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_DRAGCOEFF, Some(0.0)).unwrap()}
  }
  /// The effective area of the object exposed to atmospheric drag, expressed in meters^2.
  /// Example: /// Example: 4.739
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dragArea(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_DRAGAREA, Some(0.0)).unwrap()}
  }
  /// Epoch revolution number.
  /// Example: /// Example: 7205
  /// Constraints: No constraints specified.
  #[inline]
  pub fn revNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StateVector_Full::VT_REVNO, Some(0)).unwrap()}
  }
  /// Geopotential model used for this vector (e.g. EGM-96, WGS-84, WGS-72, JGM-2, or GEM-T3), including mm degree zonals, nn degree/order tesserals. E.g. EGM-96 24Z,24T.
  /// Example: /// Example: EGM-96
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn geopotentialModel(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_GEOPOTENTIALMODEL, None)}
  }
  /// The Drag Model used for this vector (e.g. HARRIS-PRIESTER, JAC70, JBH09, MSIS90, NONE, etc.).
  /// Example: /// Example: JAC70
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn dragModel(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_DRAGMODEL, None)}
  }
  /// Boolean indicating use of lunar/solar perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lunarSolar(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StateVector_Full::VT_LUNARSOLAR, Some(false)).unwrap()}
  }
  /// Boolean indicating use of solar radiation pressure perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solarRadPress(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StateVector_Full::VT_SOLARRADPRESS, Some(false)).unwrap()}
  }
  /// The effective area of the object exposed to solar radiation pressure, expressed in meters^2.
  /// Example: /// Example: 4.311
  /// Constraints: No constraints specified.
  #[inline]
  pub fn srpArea(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_SRPAREA, Some(0.0)).unwrap()}
  }
  /// Boolean indicating use of solid earth tide perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solidEarthTides(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StateVector_Full::VT_SOLIDEARTHTIDES, Some(false)).unwrap()}
  }
  /// Boolean indicating use of in-track thrust perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn inTrackThrust(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StateVector_Full::VT_INTRACKTHRUST, Some(false)).unwrap()}
  }
  /// First derivative of drag/ballistic coefficient (m2/kg-s).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bDot(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_BDOT, Some(0.0)).unwrap()}
  }
  /// Model parameter value for energy dissipation rate (EDR) (w/kg).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn edr(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_EDR, Some(0.0)).unwrap()}
  }
  /// Model parameter value for thrust acceleration (m/s2).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn thrustAccel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_THRUSTACCEL, Some(0.0)).unwrap()}
  }
  /// Model parameter value for center of mass offset (m).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cmOffset(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_CMOFFSET, Some(0.0)).unwrap()}
  }
  /// The start of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
  /// Example: /// Example: 2022-11-09T11:20:21.247192Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lastObStart(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_LASTOBSTART, None)}
  }
  /// The end of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
  /// Example: /// Example: 2022-11-09T11:20:21.247192Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lastObEnd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_LASTOBEND, None)}
  }
  /// The number of observations available for the OD of the object.
  /// Example: /// Example: 376
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obsAvailable(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StateVector_Full::VT_OBSAVAILABLE, Some(0)).unwrap()}
  }
  /// The number of observations accepted for the OD of the object.
  /// Example: /// Example: 374
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obsUsed(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StateVector_Full::VT_OBSUSED, Some(0)).unwrap()}
  }
  /// The number of sensor tracks available for the OD of the object.
  /// Example: /// Example: 163
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tracksAvail(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StateVector_Full::VT_TRACKSAVAIL, Some(0)).unwrap()}
  }
  /// The number of sensor tracks accepted for the OD of the object.
  /// Example: /// Example: 163
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tracksUsed(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StateVector_Full::VT_TRACKSUSED, Some(0)).unwrap()}
  }
  /// The recommended OD time span calculated for the object, expressed in days.
  /// Example: /// Example: 3.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn recODSpan(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_RECODSPAN, Some(0.0)).unwrap()}
  }
  /// The actual time span used for the OD of the object, expressed in days.
  /// Example: /// Example: 3.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn actualODSpan(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_ACTUALODSPAN, Some(0.0)).unwrap()}
  }
  /// The percentage of residuals accepted in the OD of the object.
  /// Example: /// Example: 99.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn residualsAcc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_RESIDUALSACC, Some(0.0)).unwrap()}
  }
  /// F10 (10.7 cm) solar flux value.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solarFluxF10(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_SOLARFLUXF10, Some(0.0)).unwrap()}
  }
  /// F10 (10.7 cm) solar flux 81-day average value.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solarFluxF10Avg(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_SOLARFLUXF10AVG, Some(0.0)).unwrap()}
  }
  /// Average solar flux geomagnetic index.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solarFluxAPAvg(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_SOLARFLUXAPAVG, Some(0.0)).unwrap()}
  }
  /// TAI (Temps Atomique International) minus UTC (Universal Time Coordinates) offset in seconds.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taiUtc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_TAIUTC, Some(0.0)).unwrap()}
  }
  /// Universal Time-1 (UT1) minus UTC offset, in seconds.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ut1Utc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_UT1UTC, Some(0.0)).unwrap()}
  }
  /// Rate of change of UT1 (milliseconds/day) - first derivative of ut1Utc.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ut1Rate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_UT1RATE, Some(0.0)).unwrap()}
  }
  /// Polar Wander Motion X (arc seconds).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polarMotionX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_POLARMOTIONX, Some(0.0)).unwrap()}
  }
  /// Polar Wander Motion Y (arc seconds).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polarMotionY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_POLARMOTIONY, Some(0.0)).unwrap()}
  }
  /// Number of terms used in the IAU 1980 nutation model (4, 50, or 106).
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn iau1980Terms(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(StateVector_Full::VT_IAU1980TERMS, Some(0)).unwrap()}
  }
  /// Time of the next leap second after epoch in ISO 8601 UTC time. If the next leap second is not known, the time of the previous leap second is used.
  /// Example: /// Example: 2021-01-01T01:01:01.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn leapSecondTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_LEAPSECONDTIME, None)}
  }
  /// Integrator Mode.
  /// Example: /// Example: integratorMode
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn integratorMode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_INTEGRATORMODE, None)}
  }
  /// Type of partial derivatives used (ANALYTIC, FULL NUM, or FAST NUM).
  /// Example: /// Example: ANALYTIC
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn partials(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_PARTIALS, None)}
  }
  /// Integrator step mode (AUTO, TIME, or S).
  /// Example: /// Example: AUTO
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn stepMode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_STEPMODE, None)}
  }
  /// Boolean indicating use of fixed step size for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fixedStep(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StateVector_Full::VT_FIXEDSTEP, Some(false)).unwrap()}
  }
  /// Initial step size selection (AUTO or MANUAL).
  /// Example: /// Example: AUTO
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn stepSizeSelection(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_STEPSIZESELECTION, None)}
  }
  /// Initial integration step size (seconds).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stepSize(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_STEPSIZE, Some(0.0)).unwrap()}
  }
  /// Integrator error control.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn errorControl(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_ERRORCONTROL, Some(0.0)).unwrap()}
  }
  /// Array containing the standard deviation of error in target object position, U, V and W direction respectively (km).
  /// Example: /// Example: [1.23, 4.56]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sigmaPosUVW(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StateVector_Full::VT_SIGMAPOSUVW, None)}
  }
  /// Array containing the standard deviation of error in target object velocity, U, V and W direction respectively (km/sec).
  /// Example: /// Example: [1.23, 4.56]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sigmaVelUVW(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StateVector_Full::VT_SIGMAVELUVW, None)}
  }
  /// The Weighted Root Mean Squared (RMS) of the differential correction on the target object that produced this vector.  WRMS is a quality indicator of the state vector update, with a value of 1.00 being optimal.  WRMS applies to Batch Least Squares (BLS) processes.
  /// Example: /// Example: 0.991
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rms(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StateVector_Full::VT_RMS, Some(0.0)).unwrap()}
  }
  /// Start time at which this state vector was the 'current' state vector for its satellite.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn effectiveFrom(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_EFFECTIVEFROM, None)}
  }
  /// End time at which this state vector was no longer the 'current' state vector for its satellite.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn effectiveUntil(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_EFFECTIVEUNTIL, None)}
  }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  /// Example: /// Example: rawFileURI
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn rawFileURI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_RAWFILEURI, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> StateVector_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StateVector_Full_dataMode_Enum>(StateVector_Full::VT_DATAMODE, Some(StateVector_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['TAG1', 'TAG2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StateVector_Full::VT_TAGS, None)}
  }
  /// Optional algorithm used to produce this record.
  /// Example: /// Example: SAMPLE_ALGORITHM
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn algorithm(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_ALGORITHM, None)}
  }
  /// Optional array of UDL data (observation) UUIDs used to build this state vector. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
  /// Example: /// Example: ['DATA1', 'DATA2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sourcedData(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StateVector_Full::VT_SOURCEDDATA, None)}
  }
  /// Optional array of UDL observation data types used to build this state vector (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
  /// Example: /// Example: ['RADAR']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sourcedDataTypes(&self) -> StateVector_Full_sourcedDataTypes_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StateVector_Full_sourcedDataTypes_Enum>(StateVector_Full::VT_SOURCEDDATATYPES, Some(StateVector_Full_sourcedDataTypes_Enum::EO)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_CREATEDBY, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn onOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_ONORBIT, None)}
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: descriptor
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn descriptor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_DESCRIPTOR, None)}
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: transactionId
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn transactionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_TRANSACTIONID, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_ORIGNETWORK, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateVector_Full::VT_SOURCEDL, None)}
  }
}

impl flatbuffers::Verifiable for StateVector_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idStateVector", Self::VT_IDSTATEVECTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("epoch", Self::VT_EPOCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pedigree", Self::VT_PEDIGREE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOrbitDetermination", Self::VT_IDORBITDETERMINATION, false)?
     .visit_field::<bool>("uct", Self::VT_UCT, false)?
     .visit_field::<f64>("xpos", Self::VT_XPOS, false)?
     .visit_field::<f64>("ypos", Self::VT_YPOS, false)?
     .visit_field::<f64>("zpos", Self::VT_ZPOS, false)?
     .visit_field::<f64>("xvel", Self::VT_XVEL, false)?
     .visit_field::<f64>("yvel", Self::VT_YVEL, false)?
     .visit_field::<f64>("zvel", Self::VT_ZVEL, false)?
     .visit_field::<StateVector_Full_referenceFrame_Enum>("referenceFrame", Self::VT_REFERENCEFRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("cov", Self::VT_COV, false)?
     .visit_field::<StateVector_Full_covReferenceFrame_Enum>("covReferenceFrame", Self::VT_COVREFERENCEFRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("covMethod", Self::VT_COVMETHOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("eqCov", Self::VT_EQCOV, false)?
     .visit_field::<f64>("xposAlt1", Self::VT_XPOSALT1, false)?
     .visit_field::<f64>("yposAlt1", Self::VT_YPOSALT1, false)?
     .visit_field::<f64>("zposAlt1", Self::VT_ZPOSALT1, false)?
     .visit_field::<f64>("xvelAlt1", Self::VT_XVELALT1, false)?
     .visit_field::<f64>("yvelAlt1", Self::VT_YVELALT1, false)?
     .visit_field::<f64>("zvelAlt1", Self::VT_ZVELALT1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alt1ReferenceFrame", Self::VT_ALT1REFERENCEFRAME, false)?
     .visit_field::<f64>("xposAlt2", Self::VT_XPOSALT2, false)?
     .visit_field::<f64>("yposAlt2", Self::VT_YPOSALT2, false)?
     .visit_field::<f64>("zposAlt2", Self::VT_ZPOSALT2, false)?
     .visit_field::<f64>("xvelAlt2", Self::VT_XVELALT2, false)?
     .visit_field::<f64>("yvelAlt2", Self::VT_YVELALT2, false)?
     .visit_field::<f64>("zvelAlt2", Self::VT_ZVELALT2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alt2ReferenceFrame", Self::VT_ALT2REFERENCEFRAME, false)?
     .visit_field::<f64>("posUnc", Self::VT_POSUNC, false)?
     .visit_field::<f64>("velUnc", Self::VT_VELUNC, false)?
     .visit_field::<f64>("mass", Self::VT_MASS, false)?
     .visit_field::<f64>("area", Self::VT_AREA, false)?
     .visit_field::<f64>("solarRadPressCoeff", Self::VT_SOLARRADPRESSCOEFF, false)?
     .visit_field::<f64>("dragCoeff", Self::VT_DRAGCOEFF, false)?
     .visit_field::<f64>("dragArea", Self::VT_DRAGAREA, false)?
     .visit_field::<i32>("revNo", Self::VT_REVNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("geopotentialModel", Self::VT_GEOPOTENTIALMODEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dragModel", Self::VT_DRAGMODEL, false)?
     .visit_field::<bool>("lunarSolar", Self::VT_LUNARSOLAR, false)?
     .visit_field::<bool>("solarRadPress", Self::VT_SOLARRADPRESS, false)?
     .visit_field::<f64>("srpArea", Self::VT_SRPAREA, false)?
     .visit_field::<bool>("solidEarthTides", Self::VT_SOLIDEARTHTIDES, false)?
     .visit_field::<bool>("inTrackThrust", Self::VT_INTRACKTHRUST, false)?
     .visit_field::<f64>("bDot", Self::VT_BDOT, false)?
     .visit_field::<f64>("edr", Self::VT_EDR, false)?
     .visit_field::<f64>("thrustAccel", Self::VT_THRUSTACCEL, false)?
     .visit_field::<f64>("cmOffset", Self::VT_CMOFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastObStart", Self::VT_LASTOBSTART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastObEnd", Self::VT_LASTOBEND, false)?
     .visit_field::<i32>("obsAvailable", Self::VT_OBSAVAILABLE, false)?
     .visit_field::<i32>("obsUsed", Self::VT_OBSUSED, false)?
     .visit_field::<i32>("tracksAvail", Self::VT_TRACKSAVAIL, false)?
     .visit_field::<i32>("tracksUsed", Self::VT_TRACKSUSED, false)?
     .visit_field::<f64>("recODSpan", Self::VT_RECODSPAN, false)?
     .visit_field::<f64>("actualODSpan", Self::VT_ACTUALODSPAN, false)?
     .visit_field::<f64>("residualsAcc", Self::VT_RESIDUALSACC, false)?
     .visit_field::<f64>("solarFluxF10", Self::VT_SOLARFLUXF10, false)?
     .visit_field::<f64>("solarFluxF10Avg", Self::VT_SOLARFLUXF10AVG, false)?
     .visit_field::<f64>("solarFluxAPAvg", Self::VT_SOLARFLUXAPAVG, false)?
     .visit_field::<f64>("taiUtc", Self::VT_TAIUTC, false)?
     .visit_field::<f64>("ut1Utc", Self::VT_UT1UTC, false)?
     .visit_field::<f64>("ut1Rate", Self::VT_UT1RATE, false)?
     .visit_field::<f64>("polarMotionX", Self::VT_POLARMOTIONX, false)?
     .visit_field::<f64>("polarMotionY", Self::VT_POLARMOTIONY, false)?
     .visit_field::<i32>("iau1980Terms", Self::VT_IAU1980TERMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("leapSecondTime", Self::VT_LEAPSECONDTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("integratorMode", Self::VT_INTEGRATORMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("partials", Self::VT_PARTIALS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stepMode", Self::VT_STEPMODE, false)?
     .visit_field::<bool>("fixedStep", Self::VT_FIXEDSTEP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stepSizeSelection", Self::VT_STEPSIZESELECTION, false)?
     .visit_field::<f64>("stepSize", Self::VT_STEPSIZE, false)?
     .visit_field::<f64>("errorControl", Self::VT_ERRORCONTROL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("sigmaPosUVW", Self::VT_SIGMAPOSUVW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("sigmaVelUVW", Self::VT_SIGMAVELUVW, false)?
     .visit_field::<f64>("rms", Self::VT_RMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("effectiveFrom", Self::VT_EFFECTIVEFROM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("effectiveUntil", Self::VT_EFFECTIVEUNTIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawFileURI", Self::VT_RAWFILEURI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<StateVector_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("algorithm", Self::VT_ALGORITHM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("sourcedData", Self::VT_SOURCEDDATA, false)?
     .visit_field::<StateVector_Full_sourcedDataTypes_Enum>("sourcedDataTypes", Self::VT_SOURCEDDATATYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("onOrbit", Self::VT_ONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("descriptor", Self::VT_DESCRIPTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transactionId", Self::VT_TRANSACTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .finish();
    Ok(())
  }
}
pub struct StateVector_FullArgs<'a> {
    pub idStateVector: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub epoch: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pedigree: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo: i32,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOrbitDetermination: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uct: bool,
    pub xpos: f64,
    pub ypos: f64,
    pub zpos: f64,
    pub xvel: f64,
    pub yvel: f64,
    pub zvel: f64,
    pub referenceFrame: StateVector_Full_referenceFrame_Enum,
    pub cov: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub covReferenceFrame: StateVector_Full_covReferenceFrame_Enum,
    pub covMethod: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eqCov: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub xposAlt1: f64,
    pub yposAlt1: f64,
    pub zposAlt1: f64,
    pub xvelAlt1: f64,
    pub yvelAlt1: f64,
    pub zvelAlt1: f64,
    pub alt1ReferenceFrame: Option<flatbuffers::WIPOffset<&'a str>>,
    pub xposAlt2: f64,
    pub yposAlt2: f64,
    pub zposAlt2: f64,
    pub xvelAlt2: f64,
    pub yvelAlt2: f64,
    pub zvelAlt2: f64,
    pub alt2ReferenceFrame: Option<flatbuffers::WIPOffset<&'a str>>,
    pub posUnc: f64,
    pub velUnc: f64,
    pub mass: f64,
    pub area: f64,
    pub solarRadPressCoeff: f64,
    pub dragCoeff: f64,
    pub dragArea: f64,
    pub revNo: i32,
    pub geopotentialModel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dragModel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lunarSolar: bool,
    pub solarRadPress: bool,
    pub srpArea: f64,
    pub solidEarthTides: bool,
    pub inTrackThrust: bool,
    pub bDot: f64,
    pub edr: f64,
    pub thrustAccel: f64,
    pub cmOffset: f64,
    pub lastObStart: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lastObEnd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obsAvailable: i32,
    pub obsUsed: i32,
    pub tracksAvail: i32,
    pub tracksUsed: i32,
    pub recODSpan: f64,
    pub actualODSpan: f64,
    pub residualsAcc: f64,
    pub solarFluxF10: f64,
    pub solarFluxF10Avg: f64,
    pub solarFluxAPAvg: f64,
    pub taiUtc: f64,
    pub ut1Utc: f64,
    pub ut1Rate: f64,
    pub polarMotionX: f64,
    pub polarMotionY: f64,
    pub iau1980Terms: i32,
    pub leapSecondTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub integratorMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub partials: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stepMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fixedStep: bool,
    pub stepSizeSelection: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stepSize: f64,
    pub errorControl: f64,
    pub sigmaPosUVW: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub sigmaVelUVW: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub rms: f64,
    pub effectiveFrom: Option<flatbuffers::WIPOffset<&'a str>>,
    pub effectiveUntil: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rawFileURI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: StateVector_Full_dataMode_Enum,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub algorithm: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourcedData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub sourcedDataTypes: StateVector_Full_sourcedDataTypes_Enum,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub onOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub descriptor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transactionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StateVector_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    StateVector_FullArgs {
      idStateVector: None,
      classificationMarking: None,
      epoch: None,
      pedigree: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      idOrbitDetermination: None,
      uct: false,
      xpos: 0.0,
      ypos: 0.0,
      zpos: 0.0,
      xvel: 0.0,
      yvel: 0.0,
      zvel: 0.0,
      referenceFrame: StateVector_Full_referenceFrame_Enum::J2000,
      cov: None,
      covReferenceFrame: StateVector_Full_covReferenceFrame_Enum::J2000,
      covMethod: None,
      eqCov: None,
      xposAlt1: 0.0,
      yposAlt1: 0.0,
      zposAlt1: 0.0,
      xvelAlt1: 0.0,
      yvelAlt1: 0.0,
      zvelAlt1: 0.0,
      alt1ReferenceFrame: None,
      xposAlt2: 0.0,
      yposAlt2: 0.0,
      zposAlt2: 0.0,
      xvelAlt2: 0.0,
      yvelAlt2: 0.0,
      zvelAlt2: 0.0,
      alt2ReferenceFrame: None,
      posUnc: 0.0,
      velUnc: 0.0,
      mass: 0.0,
      area: 0.0,
      solarRadPressCoeff: 0.0,
      dragCoeff: 0.0,
      dragArea: 0.0,
      revNo: 0,
      geopotentialModel: None,
      dragModel: None,
      lunarSolar: false,
      solarRadPress: false,
      srpArea: 0.0,
      solidEarthTides: false,
      inTrackThrust: false,
      bDot: 0.0,
      edr: 0.0,
      thrustAccel: 0.0,
      cmOffset: 0.0,
      lastObStart: None,
      lastObEnd: None,
      obsAvailable: 0,
      obsUsed: 0,
      tracksAvail: 0,
      tracksUsed: 0,
      recODSpan: 0.0,
      actualODSpan: 0.0,
      residualsAcc: 0.0,
      solarFluxF10: 0.0,
      solarFluxF10Avg: 0.0,
      solarFluxAPAvg: 0.0,
      taiUtc: 0.0,
      ut1Utc: 0.0,
      ut1Rate: 0.0,
      polarMotionX: 0.0,
      polarMotionY: 0.0,
      iau1980Terms: 0,
      leapSecondTime: None,
      integratorMode: None,
      partials: None,
      stepMode: None,
      fixedStep: false,
      stepSizeSelection: None,
      stepSize: 0.0,
      errorControl: 0.0,
      sigmaPosUVW: None,
      sigmaVelUVW: None,
      rms: 0.0,
      effectiveFrom: None,
      effectiveUntil: None,
      rawFileURI: None,
      source: None,
      origin: None,
      dataMode: StateVector_Full_dataMode_Enum::REAL,
      tags: None,
      algorithm: None,
      sourcedData: None,
      sourcedDataTypes: StateVector_Full_sourcedDataTypes_Enum::EO,
      createdAt: None,
      createdBy: None,
      onOrbit: None,
      descriptor: None,
      transactionId: None,
      origNetwork: None,
      sourceDL: None,
    }
  }
}

pub struct StateVector_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StateVector_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_idStateVector(&mut self, idStateVector: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_IDSTATEVECTOR, idStateVector);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_epoch(&mut self, epoch: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_EPOCH, epoch);
  }
  #[inline]
  pub fn add_pedigree(&mut self, pedigree: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_PEDIGREE, pedigree);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(StateVector_Full::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_idOrbitDetermination(&mut self, idOrbitDetermination: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_IDORBITDETERMINATION, idOrbitDetermination);
  }
  #[inline]
  pub fn add_uct(&mut self, uct: bool) {
    self.fbb_.push_slot::<bool>(StateVector_Full::VT_UCT, uct, false);
  }
  #[inline]
  pub fn add_xpos(&mut self, xpos: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_XPOS, xpos, 0.0);
  }
  #[inline]
  pub fn add_ypos(&mut self, ypos: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_YPOS, ypos, 0.0);
  }
  #[inline]
  pub fn add_zpos(&mut self, zpos: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_ZPOS, zpos, 0.0);
  }
  #[inline]
  pub fn add_xvel(&mut self, xvel: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_XVEL, xvel, 0.0);
  }
  #[inline]
  pub fn add_yvel(&mut self, yvel: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_YVEL, yvel, 0.0);
  }
  #[inline]
  pub fn add_zvel(&mut self, zvel: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_ZVEL, zvel, 0.0);
  }
  #[inline]
  pub fn add_referenceFrame(&mut self, referenceFrame: StateVector_Full_referenceFrame_Enum) {
    self.fbb_.push_slot::<StateVector_Full_referenceFrame_Enum>(StateVector_Full::VT_REFERENCEFRAME, referenceFrame, StateVector_Full_referenceFrame_Enum::J2000);
  }
  #[inline]
  pub fn add_cov(&mut self, cov: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_COV, cov);
  }
  #[inline]
  pub fn add_covReferenceFrame(&mut self, covReferenceFrame: StateVector_Full_covReferenceFrame_Enum) {
    self.fbb_.push_slot::<StateVector_Full_covReferenceFrame_Enum>(StateVector_Full::VT_COVREFERENCEFRAME, covReferenceFrame, StateVector_Full_covReferenceFrame_Enum::J2000);
  }
  #[inline]
  pub fn add_covMethod(&mut self, covMethod: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_COVMETHOD, covMethod);
  }
  #[inline]
  pub fn add_eqCov(&mut self, eqCov: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_EQCOV, eqCov);
  }
  #[inline]
  pub fn add_xposAlt1(&mut self, xposAlt1: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_XPOSALT1, xposAlt1, 0.0);
  }
  #[inline]
  pub fn add_yposAlt1(&mut self, yposAlt1: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_YPOSALT1, yposAlt1, 0.0);
  }
  #[inline]
  pub fn add_zposAlt1(&mut self, zposAlt1: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_ZPOSALT1, zposAlt1, 0.0);
  }
  #[inline]
  pub fn add_xvelAlt1(&mut self, xvelAlt1: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_XVELALT1, xvelAlt1, 0.0);
  }
  #[inline]
  pub fn add_yvelAlt1(&mut self, yvelAlt1: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_YVELALT1, yvelAlt1, 0.0);
  }
  #[inline]
  pub fn add_zvelAlt1(&mut self, zvelAlt1: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_ZVELALT1, zvelAlt1, 0.0);
  }
  #[inline]
  pub fn add_alt1ReferenceFrame(&mut self, alt1ReferenceFrame: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_ALT1REFERENCEFRAME, alt1ReferenceFrame);
  }
  #[inline]
  pub fn add_xposAlt2(&mut self, xposAlt2: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_XPOSALT2, xposAlt2, 0.0);
  }
  #[inline]
  pub fn add_yposAlt2(&mut self, yposAlt2: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_YPOSALT2, yposAlt2, 0.0);
  }
  #[inline]
  pub fn add_zposAlt2(&mut self, zposAlt2: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_ZPOSALT2, zposAlt2, 0.0);
  }
  #[inline]
  pub fn add_xvelAlt2(&mut self, xvelAlt2: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_XVELALT2, xvelAlt2, 0.0);
  }
  #[inline]
  pub fn add_yvelAlt2(&mut self, yvelAlt2: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_YVELALT2, yvelAlt2, 0.0);
  }
  #[inline]
  pub fn add_zvelAlt2(&mut self, zvelAlt2: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_ZVELALT2, zvelAlt2, 0.0);
  }
  #[inline]
  pub fn add_alt2ReferenceFrame(&mut self, alt2ReferenceFrame: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_ALT2REFERENCEFRAME, alt2ReferenceFrame);
  }
  #[inline]
  pub fn add_posUnc(&mut self, posUnc: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_POSUNC, posUnc, 0.0);
  }
  #[inline]
  pub fn add_velUnc(&mut self, velUnc: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_VELUNC, velUnc, 0.0);
  }
  #[inline]
  pub fn add_mass(&mut self, mass: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_MASS, mass, 0.0);
  }
  #[inline]
  pub fn add_area(&mut self, area: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_AREA, area, 0.0);
  }
  #[inline]
  pub fn add_solarRadPressCoeff(&mut self, solarRadPressCoeff: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_SOLARRADPRESSCOEFF, solarRadPressCoeff, 0.0);
  }
  #[inline]
  pub fn add_dragCoeff(&mut self, dragCoeff: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_DRAGCOEFF, dragCoeff, 0.0);
  }
  #[inline]
  pub fn add_dragArea(&mut self, dragArea: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_DRAGAREA, dragArea, 0.0);
  }
  #[inline]
  pub fn add_revNo(&mut self, revNo: i32) {
    self.fbb_.push_slot::<i32>(StateVector_Full::VT_REVNO, revNo, 0);
  }
  #[inline]
  pub fn add_geopotentialModel(&mut self, geopotentialModel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_GEOPOTENTIALMODEL, geopotentialModel);
  }
  #[inline]
  pub fn add_dragModel(&mut self, dragModel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_DRAGMODEL, dragModel);
  }
  #[inline]
  pub fn add_lunarSolar(&mut self, lunarSolar: bool) {
    self.fbb_.push_slot::<bool>(StateVector_Full::VT_LUNARSOLAR, lunarSolar, false);
  }
  #[inline]
  pub fn add_solarRadPress(&mut self, solarRadPress: bool) {
    self.fbb_.push_slot::<bool>(StateVector_Full::VT_SOLARRADPRESS, solarRadPress, false);
  }
  #[inline]
  pub fn add_srpArea(&mut self, srpArea: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_SRPAREA, srpArea, 0.0);
  }
  #[inline]
  pub fn add_solidEarthTides(&mut self, solidEarthTides: bool) {
    self.fbb_.push_slot::<bool>(StateVector_Full::VT_SOLIDEARTHTIDES, solidEarthTides, false);
  }
  #[inline]
  pub fn add_inTrackThrust(&mut self, inTrackThrust: bool) {
    self.fbb_.push_slot::<bool>(StateVector_Full::VT_INTRACKTHRUST, inTrackThrust, false);
  }
  #[inline]
  pub fn add_bDot(&mut self, bDot: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_BDOT, bDot, 0.0);
  }
  #[inline]
  pub fn add_edr(&mut self, edr: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_EDR, edr, 0.0);
  }
  #[inline]
  pub fn add_thrustAccel(&mut self, thrustAccel: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_THRUSTACCEL, thrustAccel, 0.0);
  }
  #[inline]
  pub fn add_cmOffset(&mut self, cmOffset: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_CMOFFSET, cmOffset, 0.0);
  }
  #[inline]
  pub fn add_lastObStart(&mut self, lastObStart: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_LASTOBSTART, lastObStart);
  }
  #[inline]
  pub fn add_lastObEnd(&mut self, lastObEnd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_LASTOBEND, lastObEnd);
  }
  #[inline]
  pub fn add_obsAvailable(&mut self, obsAvailable: i32) {
    self.fbb_.push_slot::<i32>(StateVector_Full::VT_OBSAVAILABLE, obsAvailable, 0);
  }
  #[inline]
  pub fn add_obsUsed(&mut self, obsUsed: i32) {
    self.fbb_.push_slot::<i32>(StateVector_Full::VT_OBSUSED, obsUsed, 0);
  }
  #[inline]
  pub fn add_tracksAvail(&mut self, tracksAvail: i32) {
    self.fbb_.push_slot::<i32>(StateVector_Full::VT_TRACKSAVAIL, tracksAvail, 0);
  }
  #[inline]
  pub fn add_tracksUsed(&mut self, tracksUsed: i32) {
    self.fbb_.push_slot::<i32>(StateVector_Full::VT_TRACKSUSED, tracksUsed, 0);
  }
  #[inline]
  pub fn add_recODSpan(&mut self, recODSpan: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_RECODSPAN, recODSpan, 0.0);
  }
  #[inline]
  pub fn add_actualODSpan(&mut self, actualODSpan: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_ACTUALODSPAN, actualODSpan, 0.0);
  }
  #[inline]
  pub fn add_residualsAcc(&mut self, residualsAcc: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_RESIDUALSACC, residualsAcc, 0.0);
  }
  #[inline]
  pub fn add_solarFluxF10(&mut self, solarFluxF10: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_SOLARFLUXF10, solarFluxF10, 0.0);
  }
  #[inline]
  pub fn add_solarFluxF10Avg(&mut self, solarFluxF10Avg: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_SOLARFLUXF10AVG, solarFluxF10Avg, 0.0);
  }
  #[inline]
  pub fn add_solarFluxAPAvg(&mut self, solarFluxAPAvg: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_SOLARFLUXAPAVG, solarFluxAPAvg, 0.0);
  }
  #[inline]
  pub fn add_taiUtc(&mut self, taiUtc: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_TAIUTC, taiUtc, 0.0);
  }
  #[inline]
  pub fn add_ut1Utc(&mut self, ut1Utc: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_UT1UTC, ut1Utc, 0.0);
  }
  #[inline]
  pub fn add_ut1Rate(&mut self, ut1Rate: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_UT1RATE, ut1Rate, 0.0);
  }
  #[inline]
  pub fn add_polarMotionX(&mut self, polarMotionX: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_POLARMOTIONX, polarMotionX, 0.0);
  }
  #[inline]
  pub fn add_polarMotionY(&mut self, polarMotionY: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_POLARMOTIONY, polarMotionY, 0.0);
  }
  #[inline]
  pub fn add_iau1980Terms(&mut self, iau1980Terms: i32) {
    self.fbb_.push_slot::<i32>(StateVector_Full::VT_IAU1980TERMS, iau1980Terms, 0);
  }
  #[inline]
  pub fn add_leapSecondTime(&mut self, leapSecondTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_LEAPSECONDTIME, leapSecondTime);
  }
  #[inline]
  pub fn add_integratorMode(&mut self, integratorMode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_INTEGRATORMODE, integratorMode);
  }
  #[inline]
  pub fn add_partials(&mut self, partials: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_PARTIALS, partials);
  }
  #[inline]
  pub fn add_stepMode(&mut self, stepMode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_STEPMODE, stepMode);
  }
  #[inline]
  pub fn add_fixedStep(&mut self, fixedStep: bool) {
    self.fbb_.push_slot::<bool>(StateVector_Full::VT_FIXEDSTEP, fixedStep, false);
  }
  #[inline]
  pub fn add_stepSizeSelection(&mut self, stepSizeSelection: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_STEPSIZESELECTION, stepSizeSelection);
  }
  #[inline]
  pub fn add_stepSize(&mut self, stepSize: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_STEPSIZE, stepSize, 0.0);
  }
  #[inline]
  pub fn add_errorControl(&mut self, errorControl: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_ERRORCONTROL, errorControl, 0.0);
  }
  #[inline]
  pub fn add_sigmaPosUVW(&mut self, sigmaPosUVW: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_SIGMAPOSUVW, sigmaPosUVW);
  }
  #[inline]
  pub fn add_sigmaVelUVW(&mut self, sigmaVelUVW: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_SIGMAVELUVW, sigmaVelUVW);
  }
  #[inline]
  pub fn add_rms(&mut self, rms: f64) {
    self.fbb_.push_slot::<f64>(StateVector_Full::VT_RMS, rms, 0.0);
  }
  #[inline]
  pub fn add_effectiveFrom(&mut self, effectiveFrom: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_EFFECTIVEFROM, effectiveFrom);
  }
  #[inline]
  pub fn add_effectiveUntil(&mut self, effectiveUntil: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_EFFECTIVEUNTIL, effectiveUntil);
  }
  #[inline]
  pub fn add_rawFileURI(&mut self, rawFileURI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_RAWFILEURI, rawFileURI);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: StateVector_Full_dataMode_Enum) {
    self.fbb_.push_slot::<StateVector_Full_dataMode_Enum>(StateVector_Full::VT_DATAMODE, dataMode, StateVector_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_algorithm(&mut self, algorithm: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_ALGORITHM, algorithm);
  }
  #[inline]
  pub fn add_sourcedData(&mut self, sourcedData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_SOURCEDDATA, sourcedData);
  }
  #[inline]
  pub fn add_sourcedDataTypes(&mut self, sourcedDataTypes: StateVector_Full_sourcedDataTypes_Enum) {
    self.fbb_.push_slot::<StateVector_Full_sourcedDataTypes_Enum>(StateVector_Full::VT_SOURCEDDATATYPES, sourcedDataTypes, StateVector_Full_sourcedDataTypes_Enum::EO);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_onOrbit(&mut self, onOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_ONORBIT, onOrbit);
  }
  #[inline]
  pub fn add_descriptor(&mut self, descriptor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_DESCRIPTOR, descriptor);
  }
  #[inline]
  pub fn add_transactionId(&mut self, transactionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_TRANSACTIONID, transactionId);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateVector_Full::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StateVector_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StateVector_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StateVector_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StateVector_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StateVector_Full");
      ds.field("idStateVector", &self.idStateVector());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("epoch", &self.epoch());
      ds.field("pedigree", &self.pedigree());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("satNo", &self.satNo());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("idOrbitDetermination", &self.idOrbitDetermination());
      ds.field("uct", &self.uct());
      ds.field("xpos", &self.xpos());
      ds.field("ypos", &self.ypos());
      ds.field("zpos", &self.zpos());
      ds.field("xvel", &self.xvel());
      ds.field("yvel", &self.yvel());
      ds.field("zvel", &self.zvel());
      ds.field("referenceFrame", &self.referenceFrame());
      ds.field("cov", &self.cov());
      ds.field("covReferenceFrame", &self.covReferenceFrame());
      ds.field("covMethod", &self.covMethod());
      ds.field("eqCov", &self.eqCov());
      ds.field("xposAlt1", &self.xposAlt1());
      ds.field("yposAlt1", &self.yposAlt1());
      ds.field("zposAlt1", &self.zposAlt1());
      ds.field("xvelAlt1", &self.xvelAlt1());
      ds.field("yvelAlt1", &self.yvelAlt1());
      ds.field("zvelAlt1", &self.zvelAlt1());
      ds.field("alt1ReferenceFrame", &self.alt1ReferenceFrame());
      ds.field("xposAlt2", &self.xposAlt2());
      ds.field("yposAlt2", &self.yposAlt2());
      ds.field("zposAlt2", &self.zposAlt2());
      ds.field("xvelAlt2", &self.xvelAlt2());
      ds.field("yvelAlt2", &self.yvelAlt2());
      ds.field("zvelAlt2", &self.zvelAlt2());
      ds.field("alt2ReferenceFrame", &self.alt2ReferenceFrame());
      ds.field("posUnc", &self.posUnc());
      ds.field("velUnc", &self.velUnc());
      ds.field("mass", &self.mass());
      ds.field("area", &self.area());
      ds.field("solarRadPressCoeff", &self.solarRadPressCoeff());
      ds.field("dragCoeff", &self.dragCoeff());
      ds.field("dragArea", &self.dragArea());
      ds.field("revNo", &self.revNo());
      ds.field("geopotentialModel", &self.geopotentialModel());
      ds.field("dragModel", &self.dragModel());
      ds.field("lunarSolar", &self.lunarSolar());
      ds.field("solarRadPress", &self.solarRadPress());
      ds.field("srpArea", &self.srpArea());
      ds.field("solidEarthTides", &self.solidEarthTides());
      ds.field("inTrackThrust", &self.inTrackThrust());
      ds.field("bDot", &self.bDot());
      ds.field("edr", &self.edr());
      ds.field("thrustAccel", &self.thrustAccel());
      ds.field("cmOffset", &self.cmOffset());
      ds.field("lastObStart", &self.lastObStart());
      ds.field("lastObEnd", &self.lastObEnd());
      ds.field("obsAvailable", &self.obsAvailable());
      ds.field("obsUsed", &self.obsUsed());
      ds.field("tracksAvail", &self.tracksAvail());
      ds.field("tracksUsed", &self.tracksUsed());
      ds.field("recODSpan", &self.recODSpan());
      ds.field("actualODSpan", &self.actualODSpan());
      ds.field("residualsAcc", &self.residualsAcc());
      ds.field("solarFluxF10", &self.solarFluxF10());
      ds.field("solarFluxF10Avg", &self.solarFluxF10Avg());
      ds.field("solarFluxAPAvg", &self.solarFluxAPAvg());
      ds.field("taiUtc", &self.taiUtc());
      ds.field("ut1Utc", &self.ut1Utc());
      ds.field("ut1Rate", &self.ut1Rate());
      ds.field("polarMotionX", &self.polarMotionX());
      ds.field("polarMotionY", &self.polarMotionY());
      ds.field("iau1980Terms", &self.iau1980Terms());
      ds.field("leapSecondTime", &self.leapSecondTime());
      ds.field("integratorMode", &self.integratorMode());
      ds.field("partials", &self.partials());
      ds.field("stepMode", &self.stepMode());
      ds.field("fixedStep", &self.fixedStep());
      ds.field("stepSizeSelection", &self.stepSizeSelection());
      ds.field("stepSize", &self.stepSize());
      ds.field("errorControl", &self.errorControl());
      ds.field("sigmaPosUVW", &self.sigmaPosUVW());
      ds.field("sigmaVelUVW", &self.sigmaVelUVW());
      ds.field("rms", &self.rms());
      ds.field("effectiveFrom", &self.effectiveFrom());
      ds.field("effectiveUntil", &self.effectiveUntil());
      ds.field("rawFileURI", &self.rawFileURI());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("tags", &self.tags());
      ds.field("algorithm", &self.algorithm());
      ds.field("sourcedData", &self.sourcedData());
      ds.field("sourcedDataTypes", &self.sourcedDataTypes());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("onOrbit", &self.onOrbit());
      ds.field("descriptor", &self.descriptor());
      ds.field("transactionId", &self.transactionId());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("sourceDL", &self.sourceDL());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct StateVector_FullT {
  pub idStateVector: Option<String>,
  pub classificationMarking: Option<String>,
  pub epoch: Option<String>,
  pub pedigree: Option<String>,
  pub idOnOrbit: Option<String>,
  pub satNo: i32,
  pub origObjectId: Option<String>,
  pub idOrbitDetermination: Option<String>,
  pub uct: bool,
  pub xpos: f64,
  pub ypos: f64,
  pub zpos: f64,
  pub xvel: f64,
  pub yvel: f64,
  pub zvel: f64,
  pub referenceFrame: StateVector_Full_referenceFrame_Enum,
  pub cov: Option<Vec<String>>,
  pub covReferenceFrame: StateVector_Full_covReferenceFrame_Enum,
  pub covMethod: Option<String>,
  pub eqCov: Option<Vec<String>>,
  pub xposAlt1: f64,
  pub yposAlt1: f64,
  pub zposAlt1: f64,
  pub xvelAlt1: f64,
  pub yvelAlt1: f64,
  pub zvelAlt1: f64,
  pub alt1ReferenceFrame: Option<String>,
  pub xposAlt2: f64,
  pub yposAlt2: f64,
  pub zposAlt2: f64,
  pub xvelAlt2: f64,
  pub yvelAlt2: f64,
  pub zvelAlt2: f64,
  pub alt2ReferenceFrame: Option<String>,
  pub posUnc: f64,
  pub velUnc: f64,
  pub mass: f64,
  pub area: f64,
  pub solarRadPressCoeff: f64,
  pub dragCoeff: f64,
  pub dragArea: f64,
  pub revNo: i32,
  pub geopotentialModel: Option<String>,
  pub dragModel: Option<String>,
  pub lunarSolar: bool,
  pub solarRadPress: bool,
  pub srpArea: f64,
  pub solidEarthTides: bool,
  pub inTrackThrust: bool,
  pub bDot: f64,
  pub edr: f64,
  pub thrustAccel: f64,
  pub cmOffset: f64,
  pub lastObStart: Option<String>,
  pub lastObEnd: Option<String>,
  pub obsAvailable: i32,
  pub obsUsed: i32,
  pub tracksAvail: i32,
  pub tracksUsed: i32,
  pub recODSpan: f64,
  pub actualODSpan: f64,
  pub residualsAcc: f64,
  pub solarFluxF10: f64,
  pub solarFluxF10Avg: f64,
  pub solarFluxAPAvg: f64,
  pub taiUtc: f64,
  pub ut1Utc: f64,
  pub ut1Rate: f64,
  pub polarMotionX: f64,
  pub polarMotionY: f64,
  pub iau1980Terms: i32,
  pub leapSecondTime: Option<String>,
  pub integratorMode: Option<String>,
  pub partials: Option<String>,
  pub stepMode: Option<String>,
  pub fixedStep: bool,
  pub stepSizeSelection: Option<String>,
  pub stepSize: f64,
  pub errorControl: f64,
  pub sigmaPosUVW: Option<Vec<String>>,
  pub sigmaVelUVW: Option<Vec<String>>,
  pub rms: f64,
  pub effectiveFrom: Option<String>,
  pub effectiveUntil: Option<String>,
  pub rawFileURI: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: StateVector_Full_dataMode_Enum,
  pub tags: Option<Vec<String>>,
  pub algorithm: Option<String>,
  pub sourcedData: Option<Vec<String>>,
  pub sourcedDataTypes: StateVector_Full_sourcedDataTypes_Enum,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub onOrbit: Option<String>,
  pub descriptor: Option<String>,
  pub transactionId: Option<String>,
  pub origNetwork: Option<String>,
  pub sourceDL: Option<String>,
}
impl Default for StateVector_FullT {
  fn default() -> Self {
    Self {
      idStateVector: None,
      classificationMarking: None,
      epoch: None,
      pedigree: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      idOrbitDetermination: None,
      uct: false,
      xpos: 0.0,
      ypos: 0.0,
      zpos: 0.0,
      xvel: 0.0,
      yvel: 0.0,
      zvel: 0.0,
      referenceFrame: StateVector_Full_referenceFrame_Enum::J2000,
      cov: None,
      covReferenceFrame: StateVector_Full_covReferenceFrame_Enum::J2000,
      covMethod: None,
      eqCov: None,
      xposAlt1: 0.0,
      yposAlt1: 0.0,
      zposAlt1: 0.0,
      xvelAlt1: 0.0,
      yvelAlt1: 0.0,
      zvelAlt1: 0.0,
      alt1ReferenceFrame: None,
      xposAlt2: 0.0,
      yposAlt2: 0.0,
      zposAlt2: 0.0,
      xvelAlt2: 0.0,
      yvelAlt2: 0.0,
      zvelAlt2: 0.0,
      alt2ReferenceFrame: None,
      posUnc: 0.0,
      velUnc: 0.0,
      mass: 0.0,
      area: 0.0,
      solarRadPressCoeff: 0.0,
      dragCoeff: 0.0,
      dragArea: 0.0,
      revNo: 0,
      geopotentialModel: None,
      dragModel: None,
      lunarSolar: false,
      solarRadPress: false,
      srpArea: 0.0,
      solidEarthTides: false,
      inTrackThrust: false,
      bDot: 0.0,
      edr: 0.0,
      thrustAccel: 0.0,
      cmOffset: 0.0,
      lastObStart: None,
      lastObEnd: None,
      obsAvailable: 0,
      obsUsed: 0,
      tracksAvail: 0,
      tracksUsed: 0,
      recODSpan: 0.0,
      actualODSpan: 0.0,
      residualsAcc: 0.0,
      solarFluxF10: 0.0,
      solarFluxF10Avg: 0.0,
      solarFluxAPAvg: 0.0,
      taiUtc: 0.0,
      ut1Utc: 0.0,
      ut1Rate: 0.0,
      polarMotionX: 0.0,
      polarMotionY: 0.0,
      iau1980Terms: 0,
      leapSecondTime: None,
      integratorMode: None,
      partials: None,
      stepMode: None,
      fixedStep: false,
      stepSizeSelection: None,
      stepSize: 0.0,
      errorControl: 0.0,
      sigmaPosUVW: None,
      sigmaVelUVW: None,
      rms: 0.0,
      effectiveFrom: None,
      effectiveUntil: None,
      rawFileURI: None,
      source: None,
      origin: None,
      dataMode: StateVector_Full_dataMode_Enum::REAL,
      tags: None,
      algorithm: None,
      sourcedData: None,
      sourcedDataTypes: StateVector_Full_sourcedDataTypes_Enum::EO,
      createdAt: None,
      createdBy: None,
      onOrbit: None,
      descriptor: None,
      transactionId: None,
      origNetwork: None,
      sourceDL: None,
    }
  }
}
impl StateVector_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<StateVector_Full<'b>> {
    let idStateVector = self.idStateVector.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let epoch = self.epoch.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pedigree = self.pedigree.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo = self.satNo;
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOrbitDetermination = self.idOrbitDetermination.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let uct = self.uct;
    let xpos = self.xpos;
    let ypos = self.ypos;
    let zpos = self.zpos;
    let xvel = self.xvel;
    let yvel = self.yvel;
    let zvel = self.zvel;
    let referenceFrame = self.referenceFrame;
    let cov = self.cov.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let covReferenceFrame = self.covReferenceFrame;
    let covMethod = self.covMethod.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eqCov = self.eqCov.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let xposAlt1 = self.xposAlt1;
    let yposAlt1 = self.yposAlt1;
    let zposAlt1 = self.zposAlt1;
    let xvelAlt1 = self.xvelAlt1;
    let yvelAlt1 = self.yvelAlt1;
    let zvelAlt1 = self.zvelAlt1;
    let alt1ReferenceFrame = self.alt1ReferenceFrame.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let xposAlt2 = self.xposAlt2;
    let yposAlt2 = self.yposAlt2;
    let zposAlt2 = self.zposAlt2;
    let xvelAlt2 = self.xvelAlt2;
    let yvelAlt2 = self.yvelAlt2;
    let zvelAlt2 = self.zvelAlt2;
    let alt2ReferenceFrame = self.alt2ReferenceFrame.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let posUnc = self.posUnc;
    let velUnc = self.velUnc;
    let mass = self.mass;
    let area = self.area;
    let solarRadPressCoeff = self.solarRadPressCoeff;
    let dragCoeff = self.dragCoeff;
    let dragArea = self.dragArea;
    let revNo = self.revNo;
    let geopotentialModel = self.geopotentialModel.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dragModel = self.dragModel.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lunarSolar = self.lunarSolar;
    let solarRadPress = self.solarRadPress;
    let srpArea = self.srpArea;
    let solidEarthTides = self.solidEarthTides;
    let inTrackThrust = self.inTrackThrust;
    let bDot = self.bDot;
    let edr = self.edr;
    let thrustAccel = self.thrustAccel;
    let cmOffset = self.cmOffset;
    let lastObStart = self.lastObStart.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lastObEnd = self.lastObEnd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let obsAvailable = self.obsAvailable;
    let obsUsed = self.obsUsed;
    let tracksAvail = self.tracksAvail;
    let tracksUsed = self.tracksUsed;
    let recODSpan = self.recODSpan;
    let actualODSpan = self.actualODSpan;
    let residualsAcc = self.residualsAcc;
    let solarFluxF10 = self.solarFluxF10;
    let solarFluxF10Avg = self.solarFluxF10Avg;
    let solarFluxAPAvg = self.solarFluxAPAvg;
    let taiUtc = self.taiUtc;
    let ut1Utc = self.ut1Utc;
    let ut1Rate = self.ut1Rate;
    let polarMotionX = self.polarMotionX;
    let polarMotionY = self.polarMotionY;
    let iau1980Terms = self.iau1980Terms;
    let leapSecondTime = self.leapSecondTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let integratorMode = self.integratorMode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let partials = self.partials.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stepMode = self.stepMode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let fixedStep = self.fixedStep;
    let stepSizeSelection = self.stepSizeSelection.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stepSize = self.stepSize;
    let errorControl = self.errorControl;
    let sigmaPosUVW = self.sigmaPosUVW.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let sigmaVelUVW = self.sigmaVelUVW.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let rms = self.rms;
    let effectiveFrom = self.effectiveFrom.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let effectiveUntil = self.effectiveUntil.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rawFileURI = self.rawFileURI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let algorithm = self.algorithm.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourcedData = self.sourcedData.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let sourcedDataTypes = self.sourcedDataTypes;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let onOrbit = self.onOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let descriptor = self.descriptor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let transactionId = self.transactionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    StateVector_Full::create(_fbb, &StateVector_FullArgs{
      idStateVector,
      classificationMarking,
      epoch,
      pedigree,
      idOnOrbit,
      satNo,
      origObjectId,
      idOrbitDetermination,
      uct,
      xpos,
      ypos,
      zpos,
      xvel,
      yvel,
      zvel,
      referenceFrame,
      cov,
      covReferenceFrame,
      covMethod,
      eqCov,
      xposAlt1,
      yposAlt1,
      zposAlt1,
      xvelAlt1,
      yvelAlt1,
      zvelAlt1,
      alt1ReferenceFrame,
      xposAlt2,
      yposAlt2,
      zposAlt2,
      xvelAlt2,
      yvelAlt2,
      zvelAlt2,
      alt2ReferenceFrame,
      posUnc,
      velUnc,
      mass,
      area,
      solarRadPressCoeff,
      dragCoeff,
      dragArea,
      revNo,
      geopotentialModel,
      dragModel,
      lunarSolar,
      solarRadPress,
      srpArea,
      solidEarthTides,
      inTrackThrust,
      bDot,
      edr,
      thrustAccel,
      cmOffset,
      lastObStart,
      lastObEnd,
      obsAvailable,
      obsUsed,
      tracksAvail,
      tracksUsed,
      recODSpan,
      actualODSpan,
      residualsAcc,
      solarFluxF10,
      solarFluxF10Avg,
      solarFluxAPAvg,
      taiUtc,
      ut1Utc,
      ut1Rate,
      polarMotionX,
      polarMotionY,
      iau1980Terms,
      leapSecondTime,
      integratorMode,
      partials,
      stepMode,
      fixedStep,
      stepSizeSelection,
      stepSize,
      errorControl,
      sigmaPosUVW,
      sigmaVelUVW,
      rms,
      effectiveFrom,
      effectiveUntil,
      rawFileURI,
      source,
      origin,
      dataMode,
      tags,
      algorithm,
      sourcedData,
      sourcedDataTypes,
      createdAt,
      createdBy,
      onOrbit,
      descriptor,
      transactionId,
      origNetwork,
      sourceDL,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `StateVector_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_state_vector_full_unchecked`.
pub fn root_as_state_vector_full(buf: &[u8]) -> Result<StateVector_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<StateVector_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `StateVector_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_state_vector_full_unchecked`.
pub fn size_prefixed_root_as_state_vector_full(buf: &[u8]) -> Result<StateVector_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<StateVector_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `StateVector_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_state_vector_full_unchecked`.
pub fn root_as_state_vector_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<StateVector_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<StateVector_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `StateVector_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_state_vector_full_unchecked`.
pub fn size_prefixed_root_as_state_vector_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<StateVector_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<StateVector_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a StateVector_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `StateVector_Full`.
pub unsafe fn root_as_state_vector_full_unchecked(buf: &[u8]) -> StateVector_Full {
  flatbuffers::root_unchecked::<StateVector_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed StateVector_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `StateVector_Full`.
pub unsafe fn size_prefixed_root_as_state_vector_full_unchecked(buf: &[u8]) -> StateVector_Full {
  flatbuffers::size_prefixed_root_unchecked::<StateVector_Full>(buf)
}
pub const STATE_VECTOR_FULL_IDENTIFIER: &str = "STAT";

#[inline]
pub fn state_vector_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, STATE_VECTOR_FULL_IDENTIFIER, false)
}

#[inline]
pub fn state_vector_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, STATE_VECTOR_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_state_vector_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<StateVector_Full<'a>>) {
  fbb.finish(root, Some(STATE_VECTOR_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_state_vector_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<StateVector_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(STATE_VECTOR_FULL_IDENTIFIER));
}
