// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum GNSSObservation_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Information for Global Navigation Satellite Systems (GNSS) Observations collected from GNSS receivers, including the specific GNSS sat from which each signal was received, and the observation codes of each observation in the record. Each GNSS Observation is associated with a GNSS Observation Set record containing data which applies to all observations in the set, including observation time, receiver location, and Dilution of Precision (DOP) values. Users can Reference RINEX 3+ documentation for further information concerning many of the standards and conventions for GNSS observations.
pub struct GNSSObservation_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GNSSObservation_Abridged<'a> {
  type Inner = GNSSObservation_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GNSSObservation_Abridged<'a> {
  pub const VT_GNSSSATID: flatbuffers::VOffsetT = 4;
  pub const VT_TRACKINGSTATUS: flatbuffers::VOffsetT = 6;
  pub const VT_AGCSTATE: flatbuffers::VOffsetT = 8;
  pub const VT_OBSCODESET: flatbuffers::VOffsetT = 10;
  pub const VT_OB: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GNSSObservation_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GNSSObservation_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<GNSSObservation_Abridged<'bldr>> {
    let mut builder = GNSSObservation_AbridgedBuilder::new(_fbb);
    if let Some(x) = args.ob { builder.add_ob(x); }
    if let Some(x) = args.obsCodeSet { builder.add_obsCodeSet(x); }
    builder.add_agcState(args.agcState);
    builder.add_trackingStatus(args.trackingStatus);
    if let Some(x) = args.gnssSatId { builder.add_gnssSatId(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GNSSObservation_AbridgedT {
    let gnssSatId = self.gnssSatId().map(|x| {
      x.to_string()
    });
    let trackingStatus = self.trackingStatus();
    let agcState = self.agcState();
    let obsCodeSet = self.obsCodeSet().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ob = self.ob().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    GNSSObservation_AbridgedT {
      gnssSatId,
      trackingStatus,
      agcState,
      obsCodeSet,
      ob,
    }
  }

  /// RINEX 3+ compliant GNSS System and Satellite Identifier (represented as SNN, where S is the system code, and NN is the satellite identifier) associated with this observation:
  /// G - GPS (NN = PRN)
  /// R - GLONASS (NN = Slot Number)
  /// S - SBAS Payload (NN = PRN-100)
  /// E - Galileo (NN = PRN)
  /// C - BeiDou (NN = PRN)
  /// J - QZSS (NN = PRN - 1923)
  /// I - IRNSS (NN = PRN)
  /// Example: /// Example: GEJ
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn gnssSatId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservation_Abridged::VT_GNSSSATID, None)}
  }
  /// Status of the GNSS receiver signal. Status options are 0, 1 or 2 (0 being the best).
  /// Example: /// Example: 0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trackingStatus(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GNSSObservation_Abridged::VT_TRACKINGSTATUS, Some(0)).unwrap()}
  }
  /// GNSS Automatic Gain Control State.
  /// Example: /// Example: 20
  /// Constraints: No constraints specified.
  #[inline]
  pub fn agcState(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GNSSObservation_Abridged::VT_AGCSTATE, Some(0)).unwrap()}
  }
  /// The observation code set that applies to this observation record.  Reference RINEX 3+ for further information concerning observation code set conventions.
  /// Example: /// Example: ['S1C', 'C1C', 'C1D']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obsCodeSet(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservation_Abridged::VT_OBSCODESET, None)}
  }
  /// Array of observation(s).  The ob array must be the same length as the obsCodeSet.  Pseudorange (C) is expressed meters, carrier phase (L) in cycles,  doppler (D) in Hz where + values indicate approaching sats, and signal strength C/No (S) in dB-Hz.
  /// Example: /// Example: [42.1, 1000.0, 0.9]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ob(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservation_Abridged::VT_OB, None)}
  }
}

impl flatbuffers::Verifiable for GNSSObservation_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("gnssSatId", Self::VT_GNSSSATID, false)?
     .visit_field::<i32>("trackingStatus", Self::VT_TRACKINGSTATUS, false)?
     .visit_field::<i32>("agcState", Self::VT_AGCSTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("obsCodeSet", Self::VT_OBSCODESET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ob", Self::VT_OB, false)?
     .finish();
    Ok(())
  }
}
pub struct GNSSObservation_AbridgedArgs<'a> {
    pub gnssSatId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trackingStatus: i32,
    pub agcState: i32,
    pub obsCodeSet: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ob: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for GNSSObservation_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    GNSSObservation_AbridgedArgs {
      gnssSatId: None,
      trackingStatus: 0,
      agcState: 0,
      obsCodeSet: None,
      ob: None,
    }
  }
}

pub struct GNSSObservation_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GNSSObservation_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_gnssSatId(&mut self, gnssSatId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservation_Abridged::VT_GNSSSATID, gnssSatId);
  }
  #[inline]
  pub fn add_trackingStatus(&mut self, trackingStatus: i32) {
    self.fbb_.push_slot::<i32>(GNSSObservation_Abridged::VT_TRACKINGSTATUS, trackingStatus, 0);
  }
  #[inline]
  pub fn add_agcState(&mut self, agcState: i32) {
    self.fbb_.push_slot::<i32>(GNSSObservation_Abridged::VT_AGCSTATE, agcState, 0);
  }
  #[inline]
  pub fn add_obsCodeSet(&mut self, obsCodeSet: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservation_Abridged::VT_OBSCODESET, obsCodeSet);
  }
  #[inline]
  pub fn add_ob(&mut self, ob: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservation_Abridged::VT_OB, ob);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GNSSObservation_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GNSSObservation_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GNSSObservation_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GNSSObservation_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GNSSObservation_Abridged");
      ds.field("gnssSatId", &self.gnssSatId());
      ds.field("trackingStatus", &self.trackingStatus());
      ds.field("agcState", &self.agcState());
      ds.field("obsCodeSet", &self.obsCodeSet());
      ds.field("ob", &self.ob());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GNSSObservation_AbridgedT {
  pub gnssSatId: Option<String>,
  pub trackingStatus: i32,
  pub agcState: i32,
  pub obsCodeSet: Option<Vec<String>>,
  pub ob: Option<Vec<String>>,
}
impl Default for GNSSObservation_AbridgedT {
  fn default() -> Self {
    Self {
      gnssSatId: None,
      trackingStatus: 0,
      agcState: 0,
      obsCodeSet: None,
      ob: None,
    }
  }
}
impl GNSSObservation_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GNSSObservation_Abridged<'b>> {
    let gnssSatId = self.gnssSatId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trackingStatus = self.trackingStatus;
    let agcState = self.agcState;
    let obsCodeSet = self.obsCodeSet.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ob = self.ob.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    GNSSObservation_Abridged::create(_fbb, &GNSSObservation_AbridgedArgs{
      gnssSatId,
      trackingStatus,
      agcState,
      obsCodeSet,
      ob,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `GNSSObservation_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gnssobservation_abridged_unchecked`.
pub fn root_as_gnssobservation_abridged(buf: &[u8]) -> Result<GNSSObservation_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<GNSSObservation_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `GNSSObservation_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_gnssobservation_abridged_unchecked`.
pub fn size_prefixed_root_as_gnssobservation_abridged(buf: &[u8]) -> Result<GNSSObservation_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<GNSSObservation_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `GNSSObservation_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gnssobservation_abridged_unchecked`.
pub fn root_as_gnssobservation_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GNSSObservation_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<GNSSObservation_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `GNSSObservation_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gnssobservation_abridged_unchecked`.
pub fn size_prefixed_root_as_gnssobservation_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GNSSObservation_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<GNSSObservation_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a GNSSObservation_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `GNSSObservation_Abridged`.
pub unsafe fn root_as_gnssobservation_abridged_unchecked(buf: &[u8]) -> GNSSObservation_Abridged {
  flatbuffers::root_unchecked::<GNSSObservation_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed GNSSObservation_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `GNSSObservation_Abridged`.
pub unsafe fn size_prefixed_root_as_gnssobservation_abridged_unchecked(buf: &[u8]) -> GNSSObservation_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<GNSSObservation_Abridged>(buf)
}
pub const GNSSOBSERVATION_ABRIDGED_IDENTIFIER: &str = "GNSS";

#[inline]
pub fn gnssobservation_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GNSSOBSERVATION_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn gnssobservation_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GNSSOBSERVATION_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_gnssobservation_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<GNSSObservation_Abridged<'a>>) {
  fbb.finish(root, Some(GNSSOBSERVATION_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_gnssobservation_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<GNSSObservation_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(GNSSOBSERVATION_ABRIDGED_IDENTIFIER));
}
