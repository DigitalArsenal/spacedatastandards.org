// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LOGISTICS_SUPPORT_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LOGISTICS_SUPPORT_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LOGISTICS_SUPPORT_ABRIDGED_DATA_MODE_ENUM: [LogisticsSupport_Abridged_dataMode_Enum; 4] = [
  LogisticsSupport_Abridged_dataMode_Enum::REAL,
  LogisticsSupport_Abridged_dataMode_Enum::TEST,
  LogisticsSupport_Abridged_dataMode_Enum::SIMULATED,
  LogisticsSupport_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LogisticsSupport_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl LogisticsSupport_Abridged_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LogisticsSupport_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LogisticsSupport_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LogisticsSupport_Abridged_dataMode_Enum {
    type Output = LogisticsSupport_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LogisticsSupport_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LogisticsSupport_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LogisticsSupport_Abridged_dataMode_Enum {}
pub enum LogisticsSupport_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Comprehensive logistical details concerning the planned support of maintenance operations required by an aircraft, including transportation information, supplies coordination, and service personnel.
pub struct LogisticsSupport_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogisticsSupport_Abridged<'a> {
  type Inner = LogisticsSupport_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogisticsSupport_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_EXTSYSTEMID: flatbuffers::VOffsetT = 8;
  pub const VT_TAILNUMBER: flatbuffers::VOffsetT = 10;
  pub const VT_AIRCRAFTMDS: flatbuffers::VOffsetT = 12;
  pub const VT_CURRICAO: flatbuffers::VOffsetT = 14;
  pub const VT_SUPPICAO: flatbuffers::VOffsetT = 16;
  pub const VT_RPTCREATEDTIME: flatbuffers::VOffsetT = 18;
  pub const VT_RPTCLOSEDTIME: flatbuffers::VOffsetT = 20;
  pub const VT_METIME: flatbuffers::VOffsetT = 22;
  pub const VT_MCTIME: flatbuffers::VOffsetT = 24;
  pub const VT_LOGISTICACTION: flatbuffers::VOffsetT = 26;
  pub const VT_LOGISTICSRECORDID: flatbuffers::VOffsetT = 28;
  pub const VT_ETIC: flatbuffers::VOffsetT = 30;
  pub const VT_ETMC: flatbuffers::VOffsetT = 32;
  pub const VT_MAINTSTATUSCODE: flatbuffers::VOffsetT = 34;
  pub const VT_REOPENFLAG: flatbuffers::VOffsetT = 36;
  pub const VT_OWNER: flatbuffers::VOffsetT = 38;
  pub const VT_LOGISTICSREMARKS: flatbuffers::VOffsetT = 40;
  pub const VT_LOGISTICSDISCREPANCYINFOS: flatbuffers::VOffsetT = 42;
  pub const VT_LOGISTICSTRANSPORTATIONPLANS: flatbuffers::VOffsetT = 44;
  pub const VT_LOGISTICSSUPPORTITEMS: flatbuffers::VOffsetT = 46;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 48;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 50;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 52;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 54;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 56;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 58;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 60;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 62;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogisticsSupport_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LogisticsSupport_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<LogisticsSupport_Abridged<'bldr>> {
    let mut builder = LogisticsSupport_AbridgedBuilder::new(_fbb);
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.logisticsSupportItems { builder.add_logisticsSupportItems(x); }
    if let Some(x) = args.logisticsTransportationPlans { builder.add_logisticsTransportationPlans(x); }
    if let Some(x) = args.logisticsDiscrepancyInfos { builder.add_logisticsDiscrepancyInfos(x); }
    if let Some(x) = args.logisticsRemarks { builder.add_logisticsRemarks(x); }
    if let Some(x) = args.owner { builder.add_owner(x); }
    if let Some(x) = args.maintStatusCode { builder.add_maintStatusCode(x); }
    if let Some(x) = args.etmc { builder.add_etmc(x); }
    if let Some(x) = args.etic { builder.add_etic(x); }
    if let Some(x) = args.logisticsRecordId { builder.add_logisticsRecordId(x); }
    if let Some(x) = args.logisticAction { builder.add_logisticAction(x); }
    if let Some(x) = args.mcTime { builder.add_mcTime(x); }
    if let Some(x) = args.meTime { builder.add_meTime(x); }
    if let Some(x) = args.rptClosedTime { builder.add_rptClosedTime(x); }
    if let Some(x) = args.rptCreatedTime { builder.add_rptCreatedTime(x); }
    if let Some(x) = args.suppICAO { builder.add_suppICAO(x); }
    if let Some(x) = args.currICAO { builder.add_currICAO(x); }
    if let Some(x) = args.aircraftMDS { builder.add_aircraftMDS(x); }
    if let Some(x) = args.tailNumber { builder.add_tailNumber(x); }
    if let Some(x) = args.extSystemId { builder.add_extSystemId(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_reopenFlag(args.reopenFlag);
    builder.finish()
  }

  pub fn unpack(&self) -> LogisticsSupport_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let extSystemId = self.extSystemId().map(|x| {
      x.to_string()
    });
    let tailNumber = self.tailNumber().map(|x| {
      x.to_string()
    });
    let aircraftMDS = self.aircraftMDS().map(|x| {
      x.to_string()
    });
    let currICAO = self.currICAO().map(|x| {
      x.to_string()
    });
    let suppICAO = self.suppICAO().map(|x| {
      x.to_string()
    });
    let rptCreatedTime = self.rptCreatedTime().map(|x| {
      x.to_string()
    });
    let rptClosedTime = self.rptClosedTime().map(|x| {
      x.to_string()
    });
    let meTime = self.meTime().map(|x| {
      x.to_string()
    });
    let mcTime = self.mcTime().map(|x| {
      x.to_string()
    });
    let logisticAction = self.logisticAction().map(|x| {
      x.to_string()
    });
    let logisticsRecordId = self.logisticsRecordId().map(|x| {
      x.to_string()
    });
    let etic = self.etic().map(|x| {
      x.to_string()
    });
    let etmc = self.etmc().map(|x| {
      x.to_string()
    });
    let maintStatusCode = self.maintStatusCode().map(|x| {
      x.to_string()
    });
    let reopenFlag = self.reopenFlag();
    let owner = self.owner().map(|x| {
      x.to_string()
    });
    let logisticsRemarks = self.logisticsRemarks().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let logisticsDiscrepancyInfos = self.logisticsDiscrepancyInfos().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let logisticsTransportationPlans = self.logisticsTransportationPlans().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let logisticsSupportItems = self.logisticsSupportItems().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    LogisticsSupport_AbridgedT {
      id,
      classificationMarking,
      extSystemId,
      tailNumber,
      aircraftMDS,
      currICAO,
      suppICAO,
      rptCreatedTime,
      rptClosedTime,
      meTime,
      mcTime,
      logisticAction,
      logisticsRecordId,
      etic,
      etmc,
      maintStatusCode,
      reopenFlag,
      owner,
      logisticsRemarks,
      logisticsDiscrepancyInfos,
      logisticsTransportationPlans,
      logisticsSupportItems,
      origNetwork,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system if not provided on create operations.
  /// Example: /// Example: LOGISTICS-SUPPORT-DETAILS UUID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Optional system identifier from external systs. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: GDSSBL012307131347070165
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn extSystemId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_EXTSYSTEMID, None)}
  }
  /// The tail number of the aircraft that is the subject of this LogisticsSupportDetails record.
  /// Example: /// Example: 99290
  /// Constraints: Minimum length = 0, Maximum length = 7
  #[inline]
  pub fn tailNumber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_TAILNUMBER, None)}
  }
  /// The aircraft Model Design Series (MDS) designation (e.g. E-2C HAWKEYE, F-15 EAGLE, KC-130 HERCULES, etc.) of this aircraft. Intended as, but not constrained to, MIL-STD-6016 environment dependent specific type designations.
  /// Example: /// Example: CO17A
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn aircraftMDS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_AIRCRAFTMDS, None)}
  }
  /// The current ICAO of the aircraft that is the subject of this LogisticsSupportDetails record.
  /// Example: /// Example: KCOS
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn currICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_CURRICAO, None)}
  }
  /// The supplying ICAO of the aircraft that is the subject of this LogisticsSupportDetails record.
  /// Example: /// Example: KCOS
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn suppICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_SUPPICAO, None)}
  }
  /// The time this report was created, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-13T13:47:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rptCreatedTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_RPTCREATEDTIME, None)}
  }
  /// The time this report was closed, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-13T13:47:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rptClosedTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_RPTCLOSEDTIME, None)}
  }
  /// The time indicating when a given aircraft breaks for a mission essential reason. This datetime should be in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-13T13:47:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn meTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_METIME, None)}
  }
  /// The time indicating when all mission essential problems with a given aircraft have been fixed and is mission capable. This datetime should be in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-13T13:47:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mcTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_MCTIME, None)}
  }
  /// This field identifies the pacing event for bringing the aircraft to Mission Capable status.  It is used in calculating the Estimated Time Mission Capable (ETMC) value.  Acceptable values are WA (Will Advise), INW (In Work), P+hhh.h (where P=parts and hhh.h is the number of hours up to 999 plus tenths of hours), EQ+hhh.h (EQ=equipment), MRT+hhh.h (MRT=maintenance recovery team).
  /// Example: /// Example: WA
  /// Constraints: Minimum length = 0, Maximum length = 9
  #[inline]
  pub fn logisticAction(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_LOGISTICACTION, None)}
  }
  /// The identifier that represents a Logistics Master Record.
  /// Example: /// Example: L62017
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn logisticsRecordId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_LOGISTICSRECORDID, None)}
  }
  /// The estimated time mission capable for the aircraft, in ISO 8601 UCT format with millisecond precision. This is the estimated time when the aircraft is mission ready.
  /// Example: /// Example: 2023-07-13T13:47:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn etic(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_ETIC, None)}
  }
  /// Logistics estimated time mission capable.
  /// Example: /// Example: 2023-07-13T13:47:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn etmc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_ETMC, None)}
  }
  /// The maintenance status code of the aircraft which may be based on pilot descriptions or evaluation codes. Contact the source provider for details.
  /// Example: /// Example: NMCMU
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn maintStatusCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_MAINTSTATUSCODE, None)}
  }
  /// This is used to indicate whether a closed master record has been reopened.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn reopenFlag(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(LogisticsSupport_Abridged::VT_REOPENFLAG, Some(false)).unwrap()}
  }
  /// The organization that owns this logistics record.
  /// Example: /// Example: EXAMPLE_OWNER
  /// Constraints: Minimum length = 0, Maximum length = 250
  #[inline]
  pub fn owner(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_OWNER, None)}
  }
  /// Remarks associated with this LogisticsSupport record.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn logisticsRemarks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LogisticsSupport_Abridged::VT_LOGISTICSREMARKS, None)}
  }
  /// Discrepancy information associated with this LogisticsSupport record.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn logisticsDiscrepancyInfos(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LogisticsSupport_Abridged::VT_LOGISTICSDISCREPANCYINFOS, None)}
  }
  /// Transportation plans associated with this LogisticsSupport record, used to coordinate maintenance efforts.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn logisticsTransportationPlans(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LogisticsSupport_Abridged::VT_LOGISTICSTRANSPORTATIONPLANS, None)}
  }
  /// Support items associated with this LogisticsSupport record.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn logisticsSupportItems(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LogisticsSupport_Abridged::VT_LOGISTICSSUPPORTITEMS, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_ORIGNETWORK, None)}
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_CREATEDBY, None)}
  }
  /// Time the row was updated in the database, auto-populated by the system.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_UPDATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsSupport_Abridged::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> LogisticsSupport_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LogisticsSupport_Abridged_dataMode_Enum>(LogisticsSupport_Abridged::VT_DATAMODE, Some(LogisticsSupport_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LogisticsSupport_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("extSystemId", Self::VT_EXTSYSTEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tailNumber", Self::VT_TAILNUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("aircraftMDS", Self::VT_AIRCRAFTMDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currICAO", Self::VT_CURRICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("suppICAO", Self::VT_SUPPICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rptCreatedTime", Self::VT_RPTCREATEDTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rptClosedTime", Self::VT_RPTCLOSEDTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("meTime", Self::VT_METIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mcTime", Self::VT_MCTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("logisticAction", Self::VT_LOGISTICACTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("logisticsRecordId", Self::VT_LOGISTICSRECORDID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("etic", Self::VT_ETIC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("etmc", Self::VT_ETMC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("maintStatusCode", Self::VT_MAINTSTATUSCODE, false)?
     .visit_field::<bool>("reopenFlag", Self::VT_REOPENFLAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("owner", Self::VT_OWNER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("logisticsRemarks", Self::VT_LOGISTICSREMARKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("logisticsDiscrepancyInfos", Self::VT_LOGISTICSDISCREPANCYINFOS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("logisticsTransportationPlans", Self::VT_LOGISTICSTRANSPORTATIONPLANS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("logisticsSupportItems", Self::VT_LOGISTICSSUPPORTITEMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<LogisticsSupport_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct LogisticsSupport_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub extSystemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tailNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub aircraftMDS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub suppICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rptCreatedTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rptClosedTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub meTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mcTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub logisticAction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub logisticsRecordId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub etic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub etmc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maintStatusCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reopenFlag: bool,
    pub owner: Option<flatbuffers::WIPOffset<&'a str>>,
    pub logisticsRemarks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub logisticsDiscrepancyInfos: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub logisticsTransportationPlans: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub logisticsSupportItems: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: LogisticsSupport_Abridged_dataMode_Enum,
}
impl<'a> Default for LogisticsSupport_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    LogisticsSupport_AbridgedArgs {
      id: None,
      classificationMarking: None,
      extSystemId: None,
      tailNumber: None,
      aircraftMDS: None,
      currICAO: None,
      suppICAO: None,
      rptCreatedTime: None,
      rptClosedTime: None,
      meTime: None,
      mcTime: None,
      logisticAction: None,
      logisticsRecordId: None,
      etic: None,
      etmc: None,
      maintStatusCode: None,
      reopenFlag: false,
      owner: None,
      logisticsRemarks: None,
      logisticsDiscrepancyInfos: None,
      logisticsTransportationPlans: None,
      logisticsSupportItems: None,
      origNetwork: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      dataMode: LogisticsSupport_Abridged_dataMode_Enum::REAL,
    }
  }
}

pub struct LogisticsSupport_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LogisticsSupport_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_extSystemId(&mut self, extSystemId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_EXTSYSTEMID, extSystemId);
  }
  #[inline]
  pub fn add_tailNumber(&mut self, tailNumber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_TAILNUMBER, tailNumber);
  }
  #[inline]
  pub fn add_aircraftMDS(&mut self, aircraftMDS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_AIRCRAFTMDS, aircraftMDS);
  }
  #[inline]
  pub fn add_currICAO(&mut self, currICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_CURRICAO, currICAO);
  }
  #[inline]
  pub fn add_suppICAO(&mut self, suppICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_SUPPICAO, suppICAO);
  }
  #[inline]
  pub fn add_rptCreatedTime(&mut self, rptCreatedTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_RPTCREATEDTIME, rptCreatedTime);
  }
  #[inline]
  pub fn add_rptClosedTime(&mut self, rptClosedTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_RPTCLOSEDTIME, rptClosedTime);
  }
  #[inline]
  pub fn add_meTime(&mut self, meTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_METIME, meTime);
  }
  #[inline]
  pub fn add_mcTime(&mut self, mcTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_MCTIME, mcTime);
  }
  #[inline]
  pub fn add_logisticAction(&mut self, logisticAction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_LOGISTICACTION, logisticAction);
  }
  #[inline]
  pub fn add_logisticsRecordId(&mut self, logisticsRecordId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_LOGISTICSRECORDID, logisticsRecordId);
  }
  #[inline]
  pub fn add_etic(&mut self, etic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_ETIC, etic);
  }
  #[inline]
  pub fn add_etmc(&mut self, etmc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_ETMC, etmc);
  }
  #[inline]
  pub fn add_maintStatusCode(&mut self, maintStatusCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_MAINTSTATUSCODE, maintStatusCode);
  }
  #[inline]
  pub fn add_reopenFlag(&mut self, reopenFlag: bool) {
    self.fbb_.push_slot::<bool>(LogisticsSupport_Abridged::VT_REOPENFLAG, reopenFlag, false);
  }
  #[inline]
  pub fn add_owner(&mut self, owner: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_OWNER, owner);
  }
  #[inline]
  pub fn add_logisticsRemarks(&mut self, logisticsRemarks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_LOGISTICSREMARKS, logisticsRemarks);
  }
  #[inline]
  pub fn add_logisticsDiscrepancyInfos(&mut self, logisticsDiscrepancyInfos: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_LOGISTICSDISCREPANCYINFOS, logisticsDiscrepancyInfos);
  }
  #[inline]
  pub fn add_logisticsTransportationPlans(&mut self, logisticsTransportationPlans: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_LOGISTICSTRANSPORTATIONPLANS, logisticsTransportationPlans);
  }
  #[inline]
  pub fn add_logisticsSupportItems(&mut self, logisticsSupportItems: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_LOGISTICSSUPPORTITEMS, logisticsSupportItems);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsSupport_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: LogisticsSupport_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<LogisticsSupport_Abridged_dataMode_Enum>(LogisticsSupport_Abridged::VT_DATAMODE, dataMode, LogisticsSupport_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LogisticsSupport_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LogisticsSupport_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogisticsSupport_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogisticsSupport_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogisticsSupport_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("extSystemId", &self.extSystemId());
      ds.field("tailNumber", &self.tailNumber());
      ds.field("aircraftMDS", &self.aircraftMDS());
      ds.field("currICAO", &self.currICAO());
      ds.field("suppICAO", &self.suppICAO());
      ds.field("rptCreatedTime", &self.rptCreatedTime());
      ds.field("rptClosedTime", &self.rptClosedTime());
      ds.field("meTime", &self.meTime());
      ds.field("mcTime", &self.mcTime());
      ds.field("logisticAction", &self.logisticAction());
      ds.field("logisticsRecordId", &self.logisticsRecordId());
      ds.field("etic", &self.etic());
      ds.field("etmc", &self.etmc());
      ds.field("maintStatusCode", &self.maintStatusCode());
      ds.field("reopenFlag", &self.reopenFlag());
      ds.field("owner", &self.owner());
      ds.field("logisticsRemarks", &self.logisticsRemarks());
      ds.field("logisticsDiscrepancyInfos", &self.logisticsDiscrepancyInfos());
      ds.field("logisticsTransportationPlans", &self.logisticsTransportationPlans());
      ds.field("logisticsSupportItems", &self.logisticsSupportItems());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LogisticsSupport_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub extSystemId: Option<String>,
  pub tailNumber: Option<String>,
  pub aircraftMDS: Option<String>,
  pub currICAO: Option<String>,
  pub suppICAO: Option<String>,
  pub rptCreatedTime: Option<String>,
  pub rptClosedTime: Option<String>,
  pub meTime: Option<String>,
  pub mcTime: Option<String>,
  pub logisticAction: Option<String>,
  pub logisticsRecordId: Option<String>,
  pub etic: Option<String>,
  pub etmc: Option<String>,
  pub maintStatusCode: Option<String>,
  pub reopenFlag: bool,
  pub owner: Option<String>,
  pub logisticsRemarks: Option<Vec<String>>,
  pub logisticsDiscrepancyInfos: Option<Vec<String>>,
  pub logisticsTransportationPlans: Option<Vec<String>>,
  pub logisticsSupportItems: Option<Vec<String>>,
  pub origNetwork: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: LogisticsSupport_Abridged_dataMode_Enum,
}
impl Default for LogisticsSupport_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      extSystemId: None,
      tailNumber: None,
      aircraftMDS: None,
      currICAO: None,
      suppICAO: None,
      rptCreatedTime: None,
      rptClosedTime: None,
      meTime: None,
      mcTime: None,
      logisticAction: None,
      logisticsRecordId: None,
      etic: None,
      etmc: None,
      maintStatusCode: None,
      reopenFlag: false,
      owner: None,
      logisticsRemarks: None,
      logisticsDiscrepancyInfos: None,
      logisticsTransportationPlans: None,
      logisticsSupportItems: None,
      origNetwork: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      dataMode: LogisticsSupport_Abridged_dataMode_Enum::REAL,
    }
  }
}
impl LogisticsSupport_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<LogisticsSupport_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let extSystemId = self.extSystemId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tailNumber = self.tailNumber.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let aircraftMDS = self.aircraftMDS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let currICAO = self.currICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let suppICAO = self.suppICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rptCreatedTime = self.rptCreatedTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rptClosedTime = self.rptClosedTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let meTime = self.meTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mcTime = self.mcTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let logisticAction = self.logisticAction.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let logisticsRecordId = self.logisticsRecordId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let etic = self.etic.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let etmc = self.etmc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let maintStatusCode = self.maintStatusCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reopenFlag = self.reopenFlag;
    let owner = self.owner.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let logisticsRemarks = self.logisticsRemarks.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let logisticsDiscrepancyInfos = self.logisticsDiscrepancyInfos.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let logisticsTransportationPlans = self.logisticsTransportationPlans.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let logisticsSupportItems = self.logisticsSupportItems.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    LogisticsSupport_Abridged::create(_fbb, &LogisticsSupport_AbridgedArgs{
      id,
      classificationMarking,
      extSystemId,
      tailNumber,
      aircraftMDS,
      currICAO,
      suppICAO,
      rptCreatedTime,
      rptClosedTime,
      meTime,
      mcTime,
      logisticAction,
      logisticsRecordId,
      etic,
      etmc,
      maintStatusCode,
      reopenFlag,
      owner,
      logisticsRemarks,
      logisticsDiscrepancyInfos,
      logisticsTransportationPlans,
      logisticsSupportItems,
      origNetwork,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `LogisticsSupport_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_logistics_support_abridged_unchecked`.
pub fn root_as_logistics_support_abridged(buf: &[u8]) -> Result<LogisticsSupport_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<LogisticsSupport_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `LogisticsSupport_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_logistics_support_abridged_unchecked`.
pub fn size_prefixed_root_as_logistics_support_abridged(buf: &[u8]) -> Result<LogisticsSupport_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<LogisticsSupport_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `LogisticsSupport_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_logistics_support_abridged_unchecked`.
pub fn root_as_logistics_support_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LogisticsSupport_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<LogisticsSupport_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `LogisticsSupport_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_logistics_support_abridged_unchecked`.
pub fn size_prefixed_root_as_logistics_support_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LogisticsSupport_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<LogisticsSupport_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a LogisticsSupport_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `LogisticsSupport_Abridged`.
pub unsafe fn root_as_logistics_support_abridged_unchecked(buf: &[u8]) -> LogisticsSupport_Abridged {
  flatbuffers::root_unchecked::<LogisticsSupport_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed LogisticsSupport_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `LogisticsSupport_Abridged`.
pub unsafe fn size_prefixed_root_as_logistics_support_abridged_unchecked(buf: &[u8]) -> LogisticsSupport_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<LogisticsSupport_Abridged>(buf)
}
pub const LOGISTICS_SUPPORT_ABRIDGED_IDENTIFIER: &str = "LOGI";

#[inline]
pub fn logistics_support_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LOGISTICS_SUPPORT_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn logistics_support_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LOGISTICS_SUPPORT_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_logistics_support_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<LogisticsSupport_Abridged<'a>>) {
  fbb.finish(root, Some(LOGISTICS_SUPPORT_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_logistics_support_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<LogisticsSupport_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(LOGISTICS_SUPPORT_ABRIDGED_IDENTIFIER));
}
