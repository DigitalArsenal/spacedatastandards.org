// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AIRSPACE_CONTROL_ORDER_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AIRSPACE_CONTROL_ORDER_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AIRSPACE_CONTROL_ORDER_INGEST_DATA_MODE_ENUM: [AirspaceControlOrder_Ingest_dataMode_Enum; 4] = [
  AirspaceControlOrder_Ingest_dataMode_Enum::REAL,
  AirspaceControlOrder_Ingest_dataMode_Enum::TEST,
  AirspaceControlOrder_Ingest_dataMode_Enum::SIMULATED,
  AirspaceControlOrder_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AirspaceControlOrder_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AirspaceControlOrder_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AirspaceControlOrder_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AirspaceControlOrder_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AirspaceControlOrder_Ingest_dataMode_Enum {
    type Output = AirspaceControlOrder_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AirspaceControlOrder_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AirspaceControlOrder_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AirspaceControlOrder_Ingest_dataMode_Enum {}
pub enum AirspaceControlOrder_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Beta Version Airspace Control Order: Contains airspace coordination information and instructions that have been issued by an airspace control authority.
pub struct AirspaceControlOrder_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AirspaceControlOrder_Ingest<'a> {
  type Inner = AirspaceControlOrder_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AirspaceControlOrder_Ingest<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_RAWFILEURI: flatbuffers::VOffsetT = 8;
  pub const VT_OPEXNAME: flatbuffers::VOffsetT = 10;
  pub const VT_ORIGINATOR: flatbuffers::VOffsetT = 12;
  pub const VT_STARTTIME: flatbuffers::VOffsetT = 14;
  pub const VT_STOPTIME: flatbuffers::VOffsetT = 16;
  pub const VT_STOPQUALIFIER: flatbuffers::VOffsetT = 18;
  pub const VT_OPEXINFO: flatbuffers::VOffsetT = 20;
  pub const VT_OPEXINFOALT: flatbuffers::VOffsetT = 22;
  pub const VT_PLANORIGNUM: flatbuffers::VOffsetT = 24;
  pub const VT_SERIALNUM: flatbuffers::VOffsetT = 26;
  pub const VT_MONTH: flatbuffers::VOffsetT = 28;
  pub const VT_QUALIFIER: flatbuffers::VOffsetT = 30;
  pub const VT_QUALSN: flatbuffers::VOffsetT = 32;
  pub const VT_AREAOFVALIDITY: flatbuffers::VOffsetT = 34;
  pub const VT_ACOSERIALNUM: flatbuffers::VOffsetT = 36;
  pub const VT_GEODATUM: flatbuffers::VOffsetT = 38;
  pub const VT_ACOCOMMENTS: flatbuffers::VOffsetT = 40;
  pub const VT_AIRSPACECONTROLORDERREFERENCES: flatbuffers::VOffsetT = 42;
  pub const VT_AIRSPACECONTROLMEANSSTATUS: flatbuffers::VOffsetT = 44;
  pub const VT_UNDLNKTRK: flatbuffers::VOffsetT = 46;
  pub const VT_CLASSSOURCE: flatbuffers::VOffsetT = 48;
  pub const VT_CLASSREASON: flatbuffers::VOffsetT = 50;
  pub const VT_DOWNGRADEINSDATE: flatbuffers::VOffsetT = 52;
  pub const VT_DECLASSEXEMPTIONCODE: flatbuffers::VOffsetT = 54;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 56;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 58;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 60;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 62;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 64;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 66;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 68;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AirspaceControlOrder_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AirspaceControlOrder_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<AirspaceControlOrder_Ingest<'bldr>> {
    let mut builder = AirspaceControlOrder_IngestBuilder::new(_fbb);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.declassExemptionCode { builder.add_declassExemptionCode(x); }
    if let Some(x) = args.downgradeInsDate { builder.add_downgradeInsDate(x); }
    if let Some(x) = args.classReason { builder.add_classReason(x); }
    if let Some(x) = args.classSource { builder.add_classSource(x); }
    if let Some(x) = args.undLnkTrk { builder.add_undLnkTrk(x); }
    if let Some(x) = args.airspaceControlMeansStatus { builder.add_airspaceControlMeansStatus(x); }
    if let Some(x) = args.airspaceControlOrderReferences { builder.add_airspaceControlOrderReferences(x); }
    if let Some(x) = args.acoComments { builder.add_acoComments(x); }
    if let Some(x) = args.geoDatum { builder.add_geoDatum(x); }
    if let Some(x) = args.acoSerialNum { builder.add_acoSerialNum(x); }
    if let Some(x) = args.areaOfValidity { builder.add_areaOfValidity(x); }
    builder.add_qualSN(args.qualSN);
    if let Some(x) = args.qualifier { builder.add_qualifier(x); }
    if let Some(x) = args.month { builder.add_month(x); }
    if let Some(x) = args.serialNum { builder.add_serialNum(x); }
    if let Some(x) = args.planOrigNum { builder.add_planOrigNum(x); }
    if let Some(x) = args.opExInfoAlt { builder.add_opExInfoAlt(x); }
    if let Some(x) = args.opExInfo { builder.add_opExInfo(x); }
    if let Some(x) = args.stopQualifier { builder.add_stopQualifier(x); }
    if let Some(x) = args.stopTime { builder.add_stopTime(x); }
    if let Some(x) = args.startTime { builder.add_startTime(x); }
    if let Some(x) = args.originator { builder.add_originator(x); }
    if let Some(x) = args.opExName { builder.add_opExName(x); }
    if let Some(x) = args.rawFileURI { builder.add_rawFileURI(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> AirspaceControlOrder_IngestT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let rawFileURI = self.rawFileURI().map(|x| {
      x.to_string()
    });
    let opExName = self.opExName().map(|x| {
      x.to_string()
    });
    let originator = self.originator().map(|x| {
      x.to_string()
    });
    let startTime = self.startTime().map(|x| {
      x.to_string()
    });
    let stopTime = self.stopTime().map(|x| {
      x.to_string()
    });
    let stopQualifier = self.stopQualifier().map(|x| {
      x.to_string()
    });
    let opExInfo = self.opExInfo().map(|x| {
      x.to_string()
    });
    let opExInfoAlt = self.opExInfoAlt().map(|x| {
      x.to_string()
    });
    let planOrigNum = self.planOrigNum().map(|x| {
      x.to_string()
    });
    let serialNum = self.serialNum().map(|x| {
      x.to_string()
    });
    let month = self.month().map(|x| {
      x.to_string()
    });
    let qualifier = self.qualifier().map(|x| {
      x.to_string()
    });
    let qualSN = self.qualSN();
    let areaOfValidity = self.areaOfValidity().map(|x| {
      x.to_string()
    });
    let acoSerialNum = self.acoSerialNum().map(|x| {
      x.to_string()
    });
    let geoDatum = self.geoDatum().map(|x| {
      x.to_string()
    });
    let acoComments = self.acoComments().map(|x| {
      x.to_string()
    });
    let airspaceControlOrderReferences = self.airspaceControlOrderReferences().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let airspaceControlMeansStatus = self.airspaceControlMeansStatus().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let undLnkTrk = self.undLnkTrk().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let classSource = self.classSource().map(|x| {
      x.to_string()
    });
    let classReason = self.classReason().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let downgradeInsDate = self.downgradeInsDate().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let declassExemptionCode = self.declassExemptionCode().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    AirspaceControlOrder_IngestT {
      id,
      classificationMarking,
      rawFileURI,
      opExName,
      originator,
      startTime,
      stopTime,
      stopQualifier,
      opExInfo,
      opExInfoAlt,
      planOrigNum,
      serialNum,
      month,
      qualifier,
      qualSN,
      areaOfValidity,
      acoSerialNum,
      geoDatum,
      acoComments,
      airspaceControlOrderReferences,
      airspaceControlMeansStatus,
      undLnkTrk,
      classSource,
      classReason,
      downgradeInsDate,
      declassExemptionCode,
      createdAt,
      createdBy,
      sourceDL,
      source,
      origin,
      origNetwork,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system if not provided on create operations.
  /// Example: /// Example: c44b0a80-9fef-63d9-6267-79037fb93e4c
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  /// Example: /// Example: EXAMPLE URI
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn rawFileURI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_RAWFILEURI, None)}
  }
  /// Specifies the code name or nickname assigned to a joint exercise or plan to designate message traffic.
  /// Example: /// Example: DESERT WIND
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn opExName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_OPEXNAME, None)}
  }
  /// The originator of this reference.
  /// Example: /// Example: USCENTCOM
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn originator(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_ORIGINATOR, None)}
  }
  /// The start of the effective time period of this airspace control order, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-01-07T13:55:43.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn startTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_STARTTIME, None)}
  }
  /// The end of the effective time period of this airspace control order, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-01-08T13:55:43.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stopTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_STOPTIME, None)}
  }
  /// A qualifier for the end of the effective time period of this airspace control order, such as AFTER, ASOF, NLT, etc. Used with field stopTime to indicate a relative time.
  /// Example: /// Example: AFTER
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn stopQualifier(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_STOPQUALIFIER, None)}
  }
  /// Supplementary name that can be used to further identify exercise nicknames, or to provide the primary nickname of the option or the alternative of an operational plan.
  /// Example: /// Example: CONTROL
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn opExInfo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_OPEXINFO, None)}
  }
  /// The secondary supplementary nickname of the option or the alternative of the operational plan or order.
  /// Example: /// Example: ORANGE
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn opExInfoAlt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_OPEXINFOALT, None)}
  }
  /// The official identifier of the military establishment responsible for the operation plan and the identification number assigned to this plan.
  /// Example: /// Example: SACEUR 106
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn planOrigNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_PLANORIGNUM, None)}
  }
  /// The unique message identifier sequentially assigned by the originator.
  /// Example: /// Example: 1201003
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn serialNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_SERIALNUM, None)}
  }
  /// The month in which the message originated.
  /// Example: /// Example: OCT
  /// Constraints: Minimum length = 0, Maximum length = 12
  #[inline]
  pub fn month(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_MONTH, None)}
  }
  /// The qualifier which caveats the message status.
  /// Example: /// Example: CHG
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn qualifier(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_QUALIFIER, None)}
  }
  /// The serial number associated with the message qualifier.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn qualSN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirspaceControlOrder_Ingest::VT_QUALSN, Some(0)).unwrap()}
  }
  /// Name of the area of the command for which the ACO is valid.
  /// Example: /// Example: FORT BRAGG
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn areaOfValidity(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_AREAOFVALIDITY, None)}
  }
  /// The serial number of this airspace control order.
  /// Example: /// Example: 27B
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn acoSerialNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_ACOSERIALNUM, None)}
  }
  /// Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated.
  /// Example: /// Example: EUR-T
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn geoDatum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_GEODATUM, None)}
  }
  /// Free text information expressed in natural language.
  /// Example: /// Example: CHOKE POINTS
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn acoComments(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_ACOCOMMENTS, None)}
  }
  /// The airspaceControlReferences set provides both USMTF and non-USMTF references for this airspace control order.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn airspaceControlOrderReferences(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirspaceControlOrder_Ingest::VT_AIRSPACECONTROLORDERREFERENCES, None)}
  }
  /// Mandatory nested segment to report multiple airspace control means statuses within an ACOID.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn airspaceControlMeansStatus(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirspaceControlOrder_Ingest::VT_AIRSPACECONTROLMEANSSTATUS, None)}
  }
  /// Collection of unique link 16 identifier that will be assigned to a future airspace control means.
  /// Example: /// Example: ['A2467', 'A3466', 'AA232']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn undLnkTrk(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirspaceControlOrder_Ingest::VT_UNDLNKTRK, None)}
  }
  /// Markings defining the source material or the original classification authority for the ACO message.
  /// Example: /// Example: ORIG:USJFCOM
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn classSource(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_CLASSSOURCE, None)}
  }
  /// Mandatory if classSource uses the "IORIG" designator. Must be a REASON FOR CLASSIFICATION code.
  /// Example: /// Example: ['15C', '10C']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn classReason(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirspaceControlOrder_Ingest::VT_CLASSREASON, None)}
  }
  /// Markings providing the literal guidance or date for downgrading or declassifying the airspace control order. Manditory if declassExemptionCode is nul.
  /// Example: /// Example: ['NST:AT EXERCISE ENDEX', 'DATE:25NOV1997']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn downgradeInsDate(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirspaceControlOrder_Ingest::VT_DOWNGRADEINSDATE, None)}
  }
  /// Coded entries that provide justification for exemption from automatic downgrading or declassification of the airspace control order.
  /// Example: /// Example: ['X1', 'X2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn declassExemptionCode(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirspaceControlOrder_Ingest::VT_DECLASSEXEMPTIONCODE, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_CREATEDBY, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_SOURCEDL, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlOrder_Ingest::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> AirspaceControlOrder_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AirspaceControlOrder_Ingest_dataMode_Enum>(AirspaceControlOrder_Ingest::VT_DATAMODE, Some(AirspaceControlOrder_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AirspaceControlOrder_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawFileURI", Self::VT_RAWFILEURI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("opExName", Self::VT_OPEXNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("originator", Self::VT_ORIGINATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("startTime", Self::VT_STARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stopTime", Self::VT_STOPTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stopQualifier", Self::VT_STOPQUALIFIER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("opExInfo", Self::VT_OPEXINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("opExInfoAlt", Self::VT_OPEXINFOALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("planOrigNum", Self::VT_PLANORIGNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("serialNum", Self::VT_SERIALNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("month", Self::VT_MONTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("qualifier", Self::VT_QUALIFIER, false)?
     .visit_field::<i32>("qualSN", Self::VT_QUALSN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("areaOfValidity", Self::VT_AREAOFVALIDITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("acoSerialNum", Self::VT_ACOSERIALNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("geoDatum", Self::VT_GEODATUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("acoComments", Self::VT_ACOCOMMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("airspaceControlOrderReferences", Self::VT_AIRSPACECONTROLORDERREFERENCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("airspaceControlMeansStatus", Self::VT_AIRSPACECONTROLMEANSSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("undLnkTrk", Self::VT_UNDLNKTRK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classSource", Self::VT_CLASSSOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("classReason", Self::VT_CLASSREASON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("downgradeInsDate", Self::VT_DOWNGRADEINSDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("declassExemptionCode", Self::VT_DECLASSEXEMPTIONCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<AirspaceControlOrder_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct AirspaceControlOrder_IngestArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rawFileURI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opExName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub originator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stopTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stopQualifier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opExInfo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opExInfoAlt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub planOrigNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub serialNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub month: Option<flatbuffers::WIPOffset<&'a str>>,
    pub qualifier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub qualSN: i32,
    pub areaOfValidity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub acoSerialNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub geoDatum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub acoComments: Option<flatbuffers::WIPOffset<&'a str>>,
    pub airspaceControlOrderReferences: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub airspaceControlMeansStatus: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub undLnkTrk: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub classSource: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classReason: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub downgradeInsDate: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub declassExemptionCode: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: AirspaceControlOrder_Ingest_dataMode_Enum,
}
impl<'a> Default for AirspaceControlOrder_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    AirspaceControlOrder_IngestArgs {
      id: None,
      classificationMarking: None,
      rawFileURI: None,
      opExName: None,
      originator: None,
      startTime: None,
      stopTime: None,
      stopQualifier: None,
      opExInfo: None,
      opExInfoAlt: None,
      planOrigNum: None,
      serialNum: None,
      month: None,
      qualifier: None,
      qualSN: 0,
      areaOfValidity: None,
      acoSerialNum: None,
      geoDatum: None,
      acoComments: None,
      airspaceControlOrderReferences: None,
      airspaceControlMeansStatus: None,
      undLnkTrk: None,
      classSource: None,
      classReason: None,
      downgradeInsDate: None,
      declassExemptionCode: None,
      createdAt: None,
      createdBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: AirspaceControlOrder_Ingest_dataMode_Enum::REAL,
    }
  }
}

pub struct AirspaceControlOrder_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AirspaceControlOrder_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_rawFileURI(&mut self, rawFileURI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_RAWFILEURI, rawFileURI);
  }
  #[inline]
  pub fn add_opExName(&mut self, opExName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_OPEXNAME, opExName);
  }
  #[inline]
  pub fn add_originator(&mut self, originator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_ORIGINATOR, originator);
  }
  #[inline]
  pub fn add_startTime(&mut self, startTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_STARTTIME, startTime);
  }
  #[inline]
  pub fn add_stopTime(&mut self, stopTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_STOPTIME, stopTime);
  }
  #[inline]
  pub fn add_stopQualifier(&mut self, stopQualifier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_STOPQUALIFIER, stopQualifier);
  }
  #[inline]
  pub fn add_opExInfo(&mut self, opExInfo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_OPEXINFO, opExInfo);
  }
  #[inline]
  pub fn add_opExInfoAlt(&mut self, opExInfoAlt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_OPEXINFOALT, opExInfoAlt);
  }
  #[inline]
  pub fn add_planOrigNum(&mut self, planOrigNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_PLANORIGNUM, planOrigNum);
  }
  #[inline]
  pub fn add_serialNum(&mut self, serialNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_SERIALNUM, serialNum);
  }
  #[inline]
  pub fn add_month(&mut self, month: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_MONTH, month);
  }
  #[inline]
  pub fn add_qualifier(&mut self, qualifier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_QUALIFIER, qualifier);
  }
  #[inline]
  pub fn add_qualSN(&mut self, qualSN: i32) {
    self.fbb_.push_slot::<i32>(AirspaceControlOrder_Ingest::VT_QUALSN, qualSN, 0);
  }
  #[inline]
  pub fn add_areaOfValidity(&mut self, areaOfValidity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_AREAOFVALIDITY, areaOfValidity);
  }
  #[inline]
  pub fn add_acoSerialNum(&mut self, acoSerialNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_ACOSERIALNUM, acoSerialNum);
  }
  #[inline]
  pub fn add_geoDatum(&mut self, geoDatum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_GEODATUM, geoDatum);
  }
  #[inline]
  pub fn add_acoComments(&mut self, acoComments: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_ACOCOMMENTS, acoComments);
  }
  #[inline]
  pub fn add_airspaceControlOrderReferences(&mut self, airspaceControlOrderReferences: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_AIRSPACECONTROLORDERREFERENCES, airspaceControlOrderReferences);
  }
  #[inline]
  pub fn add_airspaceControlMeansStatus(&mut self, airspaceControlMeansStatus: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_AIRSPACECONTROLMEANSSTATUS, airspaceControlMeansStatus);
  }
  #[inline]
  pub fn add_undLnkTrk(&mut self, undLnkTrk: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_UNDLNKTRK, undLnkTrk);
  }
  #[inline]
  pub fn add_classSource(&mut self, classSource: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_CLASSSOURCE, classSource);
  }
  #[inline]
  pub fn add_classReason(&mut self, classReason: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_CLASSREASON, classReason);
  }
  #[inline]
  pub fn add_downgradeInsDate(&mut self, downgradeInsDate: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_DOWNGRADEINSDATE, downgradeInsDate);
  }
  #[inline]
  pub fn add_declassExemptionCode(&mut self, declassExemptionCode: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_DECLASSEXEMPTIONCODE, declassExemptionCode);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlOrder_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: AirspaceControlOrder_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<AirspaceControlOrder_Ingest_dataMode_Enum>(AirspaceControlOrder_Ingest::VT_DATAMODE, dataMode, AirspaceControlOrder_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AirspaceControlOrder_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AirspaceControlOrder_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AirspaceControlOrder_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AirspaceControlOrder_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AirspaceControlOrder_Ingest");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("rawFileURI", &self.rawFileURI());
      ds.field("opExName", &self.opExName());
      ds.field("originator", &self.originator());
      ds.field("startTime", &self.startTime());
      ds.field("stopTime", &self.stopTime());
      ds.field("stopQualifier", &self.stopQualifier());
      ds.field("opExInfo", &self.opExInfo());
      ds.field("opExInfoAlt", &self.opExInfoAlt());
      ds.field("planOrigNum", &self.planOrigNum());
      ds.field("serialNum", &self.serialNum());
      ds.field("month", &self.month());
      ds.field("qualifier", &self.qualifier());
      ds.field("qualSN", &self.qualSN());
      ds.field("areaOfValidity", &self.areaOfValidity());
      ds.field("acoSerialNum", &self.acoSerialNum());
      ds.field("geoDatum", &self.geoDatum());
      ds.field("acoComments", &self.acoComments());
      ds.field("airspaceControlOrderReferences", &self.airspaceControlOrderReferences());
      ds.field("airspaceControlMeansStatus", &self.airspaceControlMeansStatus());
      ds.field("undLnkTrk", &self.undLnkTrk());
      ds.field("classSource", &self.classSource());
      ds.field("classReason", &self.classReason());
      ds.field("downgradeInsDate", &self.downgradeInsDate());
      ds.field("declassExemptionCode", &self.declassExemptionCode());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("sourceDL", &self.sourceDL());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AirspaceControlOrder_IngestT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub rawFileURI: Option<String>,
  pub opExName: Option<String>,
  pub originator: Option<String>,
  pub startTime: Option<String>,
  pub stopTime: Option<String>,
  pub stopQualifier: Option<String>,
  pub opExInfo: Option<String>,
  pub opExInfoAlt: Option<String>,
  pub planOrigNum: Option<String>,
  pub serialNum: Option<String>,
  pub month: Option<String>,
  pub qualifier: Option<String>,
  pub qualSN: i32,
  pub areaOfValidity: Option<String>,
  pub acoSerialNum: Option<String>,
  pub geoDatum: Option<String>,
  pub acoComments: Option<String>,
  pub airspaceControlOrderReferences: Option<Vec<String>>,
  pub airspaceControlMeansStatus: Option<Vec<String>>,
  pub undLnkTrk: Option<Vec<String>>,
  pub classSource: Option<String>,
  pub classReason: Option<Vec<String>>,
  pub downgradeInsDate: Option<Vec<String>>,
  pub declassExemptionCode: Option<Vec<String>>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub sourceDL: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: AirspaceControlOrder_Ingest_dataMode_Enum,
}
impl Default for AirspaceControlOrder_IngestT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      rawFileURI: None,
      opExName: None,
      originator: None,
      startTime: None,
      stopTime: None,
      stopQualifier: None,
      opExInfo: None,
      opExInfoAlt: None,
      planOrigNum: None,
      serialNum: None,
      month: None,
      qualifier: None,
      qualSN: 0,
      areaOfValidity: None,
      acoSerialNum: None,
      geoDatum: None,
      acoComments: None,
      airspaceControlOrderReferences: None,
      airspaceControlMeansStatus: None,
      undLnkTrk: None,
      classSource: None,
      classReason: None,
      downgradeInsDate: None,
      declassExemptionCode: None,
      createdAt: None,
      createdBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: AirspaceControlOrder_Ingest_dataMode_Enum::REAL,
    }
  }
}
impl AirspaceControlOrder_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AirspaceControlOrder_Ingest<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rawFileURI = self.rawFileURI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let opExName = self.opExName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let originator = self.originator.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let startTime = self.startTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stopTime = self.stopTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stopQualifier = self.stopQualifier.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let opExInfo = self.opExInfo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let opExInfoAlt = self.opExInfoAlt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let planOrigNum = self.planOrigNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let serialNum = self.serialNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let month = self.month.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let qualifier = self.qualifier.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let qualSN = self.qualSN;
    let areaOfValidity = self.areaOfValidity.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let acoSerialNum = self.acoSerialNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let geoDatum = self.geoDatum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let acoComments = self.acoComments.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let airspaceControlOrderReferences = self.airspaceControlOrderReferences.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let airspaceControlMeansStatus = self.airspaceControlMeansStatus.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let undLnkTrk = self.undLnkTrk.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let classSource = self.classSource.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classReason = self.classReason.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let downgradeInsDate = self.downgradeInsDate.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let declassExemptionCode = self.declassExemptionCode.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    AirspaceControlOrder_Ingest::create(_fbb, &AirspaceControlOrder_IngestArgs{
      id,
      classificationMarking,
      rawFileURI,
      opExName,
      originator,
      startTime,
      stopTime,
      stopQualifier,
      opExInfo,
      opExInfoAlt,
      planOrigNum,
      serialNum,
      month,
      qualifier,
      qualSN,
      areaOfValidity,
      acoSerialNum,
      geoDatum,
      acoComments,
      airspaceControlOrderReferences,
      airspaceControlMeansStatus,
      undLnkTrk,
      classSource,
      classReason,
      downgradeInsDate,
      declassExemptionCode,
      createdAt,
      createdBy,
      sourceDL,
      source,
      origin,
      origNetwork,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AirspaceControlOrder_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airspace_control_order_ingest_unchecked`.
pub fn root_as_airspace_control_order_ingest(buf: &[u8]) -> Result<AirspaceControlOrder_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AirspaceControlOrder_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AirspaceControlOrder_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_airspace_control_order_ingest_unchecked`.
pub fn size_prefixed_root_as_airspace_control_order_ingest(buf: &[u8]) -> Result<AirspaceControlOrder_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AirspaceControlOrder_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AirspaceControlOrder_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airspace_control_order_ingest_unchecked`.
pub fn root_as_airspace_control_order_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirspaceControlOrder_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AirspaceControlOrder_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AirspaceControlOrder_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airspace_control_order_ingest_unchecked`.
pub fn size_prefixed_root_as_airspace_control_order_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirspaceControlOrder_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AirspaceControlOrder_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AirspaceControlOrder_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AirspaceControlOrder_Ingest`.
pub unsafe fn root_as_airspace_control_order_ingest_unchecked(buf: &[u8]) -> AirspaceControlOrder_Ingest {
  flatbuffers::root_unchecked::<AirspaceControlOrder_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AirspaceControlOrder_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AirspaceControlOrder_Ingest`.
pub unsafe fn size_prefixed_root_as_airspace_control_order_ingest_unchecked(buf: &[u8]) -> AirspaceControlOrder_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<AirspaceControlOrder_Ingest>(buf)
}
pub const AIRSPACE_CONTROL_ORDER_INGEST_IDENTIFIER: &str = "AIRS";

#[inline]
pub fn airspace_control_order_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRSPACE_CONTROL_ORDER_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn airspace_control_order_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRSPACE_CONTROL_ORDER_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_airspace_control_order_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AirspaceControlOrder_Ingest<'a>>) {
  fbb.finish(root, Some(AIRSPACE_CONTROL_ORDER_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_airspace_control_order_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AirspaceControlOrder_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(AIRSPACE_CONTROL_ORDER_INGEST_IDENTIFIER));
}
