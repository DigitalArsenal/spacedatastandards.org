// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AIRSPACE_CONTROL_MEANS_INGEST_CM_SHAPE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AIRSPACE_CONTROL_MEANS_INGEST_CM_SHAPE_ENUM: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AIRSPACE_CONTROL_MEANS_INGEST_CM_SHAPE_ENUM: [AirspaceControlMeans_Ingest_cmShape_Enum; 8] = [
  AirspaceControlMeans_Ingest_cmShape_Enum::POLYARC,
  AirspaceControlMeans_Ingest_cmShape_Enum::E1TRACK,
  AirspaceControlMeans_Ingest_cmShape_Enum::POLYGON,
  AirspaceControlMeans_Ingest_cmShape_Enum::CIRCLE,
  AirspaceControlMeans_Ingest_cmShape_Enum::CORRIDOR,
  AirspaceControlMeans_Ingest_cmShape_Enum::APOINT,
  AirspaceControlMeans_Ingest_cmShape_Enum::AORBIT,
  AirspaceControlMeans_Ingest_cmShape_Enum::GEOLINE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AirspaceControlMeans_Ingest_cmShape_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AirspaceControlMeans_Ingest_cmShape_Enum {
  /// No description available.
  pub const POLYARC: Self = Self(0);
  /// No description available.
  pub const E1TRACK: Self = Self(1);
  /// No description available.
  pub const POLYGON: Self = Self(2);
  /// No description available.
  pub const CIRCLE: Self = Self(3);
  /// No description available.
  pub const CORRIDOR: Self = Self(4);
  /// No description available.
  pub const APOINT: Self = Self(5);
  /// No description available.
  pub const AORBIT: Self = Self(6);
  /// No description available.
  pub const GEOLINE: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::POLYARC,
    Self::E1TRACK,
    Self::POLYGON,
    Self::CIRCLE,
    Self::CORRIDOR,
    Self::APOINT,
    Self::AORBIT,
    Self::GEOLINE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::POLYARC => Some("POLYARC"),
      Self::E1TRACK => Some("E1TRACK"),
      Self::POLYGON => Some("POLYGON"),
      Self::CIRCLE => Some("CIRCLE"),
      Self::CORRIDOR => Some("CORRIDOR"),
      Self::APOINT => Some("APOINT"),
      Self::AORBIT => Some("AORBIT"),
      Self::GEOLINE => Some("GEOLINE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AirspaceControlMeans_Ingest_cmShape_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AirspaceControlMeans_Ingest_cmShape_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AirspaceControlMeans_Ingest_cmShape_Enum {
    type Output = AirspaceControlMeans_Ingest_cmShape_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AirspaceControlMeans_Ingest_cmShape_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AirspaceControlMeans_Ingest_cmShape_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AirspaceControlMeans_Ingest_cmShape_Enum {}
pub enum AirspaceControlMeans_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// A conditional nested segment to report multiple airspace control means within a particular airspace control means status.
pub struct AirspaceControlMeans_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AirspaceControlMeans_Ingest<'a> {
  type Inner = AirspaceControlMeans_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AirspaceControlMeans_Ingest<'a> {
  pub const VT_CMTYPE: flatbuffers::VOffsetT = 4;
  pub const VT_CMID: flatbuffers::VOffsetT = 6;
  pub const VT_CMSHAPE: flatbuffers::VOffsetT = 8;
  pub const VT_USAGE: flatbuffers::VOffsetT = 10;
  pub const VT_LINK16ID: flatbuffers::VOffsetT = 12;
  pub const VT_TRANSALTITUDE: flatbuffers::VOffsetT = 14;
  pub const VT_GEODATUMALT: flatbuffers::VOffsetT = 16;
  pub const VT_COORD0: flatbuffers::VOffsetT = 18;
  pub const VT_COORD1: flatbuffers::VOffsetT = 20;
  pub const VT_BEARING0: flatbuffers::VOffsetT = 22;
  pub const VT_BEARING1: flatbuffers::VOffsetT = 24;
  pub const VT_RADMAG0: flatbuffers::VOffsetT = 26;
  pub const VT_RADMAG1: flatbuffers::VOffsetT = 28;
  pub const VT_RADMAGUNIT: flatbuffers::VOffsetT = 30;
  pub const VT_POLYCOORD: flatbuffers::VOffsetT = 32;
  pub const VT_TRACKLEG: flatbuffers::VOffsetT = 34;
  pub const VT_WIDTHLEFT: flatbuffers::VOffsetT = 36;
  pub const VT_WIDTHRIGHT: flatbuffers::VOffsetT = 38;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 40;
  pub const VT_WIDTHUNIT: flatbuffers::VOffsetT = 42;
  pub const VT_CORRWAYPOINTS: flatbuffers::VOffsetT = 44;
  pub const VT_ORBITALIGNMENT: flatbuffers::VOffsetT = 46;
  pub const VT_EFFVDIM: flatbuffers::VOffsetT = 48;
  pub const VT_AIRSPACETIMEPERIOD: flatbuffers::VOffsetT = 50;
  pub const VT_AIRSPACECONTROLPOINT: flatbuffers::VOffsetT = 52;
  pub const VT_CTRLAUTH: flatbuffers::VOffsetT = 54;
  pub const VT_CTRLAUTHFREQS: flatbuffers::VOffsetT = 56;
  pub const VT_GENTEXTIND: flatbuffers::VOffsetT = 58;
  pub const VT_FREETEXT: flatbuffers::VOffsetT = 60;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AirspaceControlMeans_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AirspaceControlMeans_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<AirspaceControlMeans_Ingest<'bldr>> {
    let mut builder = AirspaceControlMeans_IngestBuilder::new(_fbb);
    builder.add_width(args.width);
    builder.add_widthRight(args.widthRight);
    builder.add_widthLeft(args.widthLeft);
    builder.add_radMag1(args.radMag1);
    builder.add_radMag0(args.radMag0);
    builder.add_bearing1(args.bearing1);
    builder.add_bearing0(args.bearing0);
    if let Some(x) = args.freeText { builder.add_freeText(x); }
    if let Some(x) = args.genTextInd { builder.add_genTextInd(x); }
    if let Some(x) = args.ctrlAuthFreqs { builder.add_ctrlAuthFreqs(x); }
    if let Some(x) = args.ctrlAuth { builder.add_ctrlAuth(x); }
    if let Some(x) = args.airspaceControlPoint { builder.add_airspaceControlPoint(x); }
    if let Some(x) = args.airspaceTimePeriod { builder.add_airspaceTimePeriod(x); }
    if let Some(x) = args.effVDim { builder.add_effVDim(x); }
    if let Some(x) = args.orbitAlignment { builder.add_orbitAlignment(x); }
    if let Some(x) = args.corrWayPoints { builder.add_corrWayPoints(x); }
    if let Some(x) = args.widthUnit { builder.add_widthUnit(x); }
    builder.add_trackLeg(args.trackLeg);
    if let Some(x) = args.polyCoord { builder.add_polyCoord(x); }
    if let Some(x) = args.radMagUnit { builder.add_radMagUnit(x); }
    if let Some(x) = args.coord1 { builder.add_coord1(x); }
    if let Some(x) = args.coord0 { builder.add_coord0(x); }
    if let Some(x) = args.geoDatumAlt { builder.add_geoDatumAlt(x); }
    if let Some(x) = args.transAltitude { builder.add_transAltitude(x); }
    if let Some(x) = args.link16Id { builder.add_link16Id(x); }
    if let Some(x) = args.usage { builder.add_usage(x); }
    if let Some(x) = args.cmId { builder.add_cmId(x); }
    if let Some(x) = args.cmType { builder.add_cmType(x); }
    builder.add_cmShape(args.cmShape);
    builder.finish()
  }

  pub fn unpack(&self) -> AirspaceControlMeans_IngestT {
    let cmType = self.cmType().map(|x| {
      x.to_string()
    });
    let cmId = self.cmId().map(|x| {
      x.to_string()
    });
    let cmShape = self.cmShape();
    let usage = self.usage().map(|x| {
      x.to_string()
    });
    let link16Id = self.link16Id().map(|x| {
      x.to_string()
    });
    let transAltitude = self.transAltitude().map(|x| {
      x.to_string()
    });
    let geoDatumAlt = self.geoDatumAlt().map(|x| {
      x.to_string()
    });
    let coord0 = self.coord0().map(|x| {
      x.to_string()
    });
    let coord1 = self.coord1().map(|x| {
      x.to_string()
    });
    let bearing0 = self.bearing0();
    let bearing1 = self.bearing1();
    let radMag0 = self.radMag0();
    let radMag1 = self.radMag1();
    let radMagUnit = self.radMagUnit().map(|x| {
      x.to_string()
    });
    let polyCoord = self.polyCoord().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let trackLeg = self.trackLeg();
    let widthLeft = self.widthLeft();
    let widthRight = self.widthRight();
    let width = self.width();
    let widthUnit = self.widthUnit().map(|x| {
      x.to_string()
    });
    let corrWayPoints = self.corrWayPoints().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let orbitAlignment = self.orbitAlignment().map(|x| {
      x.to_string()
    });
    let effVDim = self.effVDim().map(|x| {
      x.to_string()
    });
    let airspaceTimePeriod = self.airspaceTimePeriod().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let airspaceControlPoint = self.airspaceControlPoint().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ctrlAuth = self.ctrlAuth().map(|x| {
      x.to_string()
    });
    let ctrlAuthFreqs = self.ctrlAuthFreqs().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let genTextInd = self.genTextInd().map(|x| {
      x.to_string()
    });
    let freeText = self.freeText().map(|x| {
      x.to_string()
    });
    AirspaceControlMeans_IngestT {
      cmType,
      cmId,
      cmShape,
      usage,
      link16Id,
      transAltitude,
      geoDatumAlt,
      coord0,
      coord1,
      bearing0,
      bearing1,
      radMag0,
      radMag1,
      radMagUnit,
      polyCoord,
      trackLeg,
      widthLeft,
      widthRight,
      width,
      widthUnit,
      corrWayPoints,
      orbitAlignment,
      effVDim,
      airspaceTimePeriod,
      airspaceControlPoint,
      ctrlAuth,
      ctrlAuthFreqs,
      genTextInd,
      freeText,
    }
  }

  /// The code for the type of airspace control means.
  /// Example: /// Example: ACM:ADAREA
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn cmType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_CMTYPE, None)}
  }
  /// Airspace control means name or designator.
  /// Example: /// Example: DESIG:C34
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn cmId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_CMID, None)}
  }
  /// Designates the geometric type that defines the airspace shape. One of CIRCLE, CORRIDOR, LINE, ORBIT, etc.
  /// Example: /// Example: POLYARC
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn cmShape(&self) -> AirspaceControlMeans_Ingest_cmShape_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AirspaceControlMeans_Ingest_cmShape_Enum>(AirspaceControlMeans_Ingest::VT_CMSHAPE, Some(AirspaceControlMeans_Ingest_cmShape_Enum::POLYARC)).unwrap()}
  }
  /// Designates the means by which a defined airspace control means is to be used.
  /// Example: /// Example: USE:AIRCOR
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn usage(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_USAGE, None)}
  }
  /// Unique Link 16 identifier assigned to the airspace control means.
  /// Example: /// Example: F3356
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn link16Id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_LINK16ID, None)}
  }
  /// The altitude at or below which the vertical position of an aircraft is controlled by reference to true altitude.
  /// Example: /// Example: 18000FT
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn transAltitude(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_TRANSALTITUDE, None)}
  }
  /// Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated, if different from the top level ACO datum.
  /// Example: /// Example: NAR
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn geoDatumAlt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_GEODATUMALT, None)}
  }
  /// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
  /// Example: /// Example: 152345N0505657E
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn coord0(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_COORD0, None)}
  }
  /// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
  /// Example: /// Example: 1523N05057E
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn coord1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_COORD1, None)}
  }
  /// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "beginning" radial bearing parameter.
  /// Example: /// Example: 330
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bearing0(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirspaceControlMeans_Ingest::VT_BEARING0, Some(0.0)).unwrap()}
  }
  /// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "ending" radial bearing parameter.
  /// Example: /// Example: 160
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bearing1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirspaceControlMeans_Ingest::VT_BEARING1, Some(0.0)).unwrap()}
  }
  /// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "inner" radial magnitude arc limit. If provided, the field radMagUnit is required.
  /// Example: /// Example: 30.04
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radMag0(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirspaceControlMeans_Ingest::VT_RADMAG0, Some(0.0)).unwrap()}
  }
  /// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "outer" radial magnitude arc limit. If provided, the field radMagUnit is required.
  /// Example: /// Example: 50.12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radMag1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirspaceControlMeans_Ingest::VT_RADMAG1, Some(0.0)).unwrap()}
  }
  /// Specifies the unit of length in which radial magnitudes are given. Use M for meters, KM for kilometers, or NM for nautical miles.
  /// Example: /// Example: NM
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn radMagUnit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_RADMAGUNIT, None)}
  }
  /// A set of geospatial coordinates specified in DMS (Degrees, Minutes, Seconds) format which determine the vertices of a one or two dimensional geospatial shape. When shape is set to "POLYARC" or "POLYGON," this field is required as applied in the construction of the area boundary. If cmShape is set to "COORIDOR" or "GEOLINE," this field is required and can be interpreted as an ordered set of points along a path in space.
  /// Example: /// Example: ['203632N0594256E', '155000N0594815E', '155000N0591343E']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polyCoord(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirspaceControlMeans_Ingest::VT_POLYCOORD, None)}
  }
  /// Index of a segment in an airtrack, which is defined by an ordered set of points.
  /// Example: /// Example: 99
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trackLeg(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirspaceControlMeans_Ingest::VT_TRACKLEG, Some(0)).unwrap()}
  }
  /// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the LEFT half-plane realtive to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the left of the track segment line. If provided, the field widthUnit is required.
  /// Example: /// Example: 5.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn widthLeft(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirspaceControlMeans_Ingest::VT_WIDTHLEFT, Some(0.0)).unwrap()}
  }
  /// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the RIGHT half-plane relative to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the right of the track segment line. If provided, the field widthUnit is required.
  /// Example: /// Example: 10.4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn widthRight(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirspaceControlMeans_Ingest::VT_WIDTHRIGHT, Some(0.0)).unwrap()}
  }
  /// Used to describe the "side to side" distance of a target, object or area. If cmShape is set to "CORRIDOR" or "AORBIT", this field is required and is mapped to the width parameter. If provided, the field widthUnit is required.
  /// Example: /// Example: 15.6
  /// Constraints: No constraints specified.
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirspaceControlMeans_Ingest::VT_WIDTH, Some(0.0)).unwrap()}
  }
  /// Specifies the unit of length for which widths are given. Use M for meters, KM for kilometers, or NM for nautical miles.
  /// Example: /// Example: KM
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn widthUnit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_WIDTHUNIT, None)}
  }
  /// An array of at least two alphanumeric symbols used to serially identify the corridor waypoints. If cmShape is set to "CORRIDOR," one of either corrWayPoints or polyCoord is required to specify the centerline of the corridor path.
  /// Example: /// Example: ['POB', 'RDU', 'IAD']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn corrWayPoints(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirspaceControlMeans_Ingest::VT_CORRWAYPOINTS, None)}
  }
  /// Orbit alignment look-up code. Can be C=Center, L=Left, R=Right.
  /// Example: /// Example: C
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn orbitAlignment(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_ORBITALIGNMENT, None)}
  }
  /// Description of the airspace vertical dimension.
  /// Example: /// Example: BRRA:GL-100AGL
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn effVDim(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_EFFVDIM, None)}
  }
  /// The timePeriod set describes the effective datetime for a given airspace control means.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn airspaceTimePeriod(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirspaceControlMeans_Ingest::VT_AIRSPACETIMEPERIOD, None)}
  }
  /// The controlPoint set describes any reference/controlling/rendevous point for a given airspace control means.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn airspaceControlPoint(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirspaceControlMeans_Ingest::VT_AIRSPACECONTROLPOINT, None)}
  }
  /// The commander responsible within a specified geographical area for the airspace control operation assigned to him.
  /// Example: /// Example: RHEIN MAIN CP
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn ctrlAuth(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_CTRLAUTH, None)}
  }
  /// The frequency for the airspace control authority. Can specify HZ, KHZ, MHZ, GHZ or a DESIG frequency designator code.
  /// Example: /// Example: ['125.25MHZ']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ctrlAuthFreqs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirspaceControlMeans_Ingest::VT_CTRLAUTHFREQS, None)}
  }
  /// Used to provide transit intstructions for the airspace control means.
  /// Example: /// Example: SITUATION
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn genTextInd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_GENTEXTIND, None)}
  }
  /// General informat detailing the transit instruction for the airspace control means.
  /// Example: /// Example: 1. CAPACITY: MDM TK, 50 VEHICLE CONVOY. 2. CHOKE POINTS: EXIT 5
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn freeText(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirspaceControlMeans_Ingest::VT_FREETEXT, None)}
  }
}

impl flatbuffers::Verifiable for AirspaceControlMeans_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cmType", Self::VT_CMTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cmId", Self::VT_CMID, false)?
     .visit_field::<AirspaceControlMeans_Ingest_cmShape_Enum>("cmShape", Self::VT_CMSHAPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("usage", Self::VT_USAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("link16Id", Self::VT_LINK16ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transAltitude", Self::VT_TRANSALTITUDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("geoDatumAlt", Self::VT_GEODATUMALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coord0", Self::VT_COORD0, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coord1", Self::VT_COORD1, false)?
     .visit_field::<f64>("bearing0", Self::VT_BEARING0, false)?
     .visit_field::<f64>("bearing1", Self::VT_BEARING1, false)?
     .visit_field::<f64>("radMag0", Self::VT_RADMAG0, false)?
     .visit_field::<f64>("radMag1", Self::VT_RADMAG1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("radMagUnit", Self::VT_RADMAGUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("polyCoord", Self::VT_POLYCOORD, false)?
     .visit_field::<i32>("trackLeg", Self::VT_TRACKLEG, false)?
     .visit_field::<f64>("widthLeft", Self::VT_WIDTHLEFT, false)?
     .visit_field::<f64>("widthRight", Self::VT_WIDTHRIGHT, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("widthUnit", Self::VT_WIDTHUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("corrWayPoints", Self::VT_CORRWAYPOINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("orbitAlignment", Self::VT_ORBITALIGNMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("effVDim", Self::VT_EFFVDIM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("airspaceTimePeriod", Self::VT_AIRSPACETIMEPERIOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("airspaceControlPoint", Self::VT_AIRSPACECONTROLPOINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ctrlAuth", Self::VT_CTRLAUTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ctrlAuthFreqs", Self::VT_CTRLAUTHFREQS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("genTextInd", Self::VT_GENTEXTIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("freeText", Self::VT_FREETEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct AirspaceControlMeans_IngestArgs<'a> {
    pub cmType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cmId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cmShape: AirspaceControlMeans_Ingest_cmShape_Enum,
    pub usage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub link16Id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transAltitude: Option<flatbuffers::WIPOffset<&'a str>>,
    pub geoDatumAlt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coord0: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coord1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bearing0: f64,
    pub bearing1: f64,
    pub radMag0: f64,
    pub radMag1: f64,
    pub radMagUnit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub polyCoord: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub trackLeg: i32,
    pub widthLeft: f64,
    pub widthRight: f64,
    pub width: f64,
    pub widthUnit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub corrWayPoints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub orbitAlignment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub effVDim: Option<flatbuffers::WIPOffset<&'a str>>,
    pub airspaceTimePeriod: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub airspaceControlPoint: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ctrlAuth: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ctrlAuthFreqs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub genTextInd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub freeText: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AirspaceControlMeans_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    AirspaceControlMeans_IngestArgs {
      cmType: None,
      cmId: None,
      cmShape: AirspaceControlMeans_Ingest_cmShape_Enum::POLYARC,
      usage: None,
      link16Id: None,
      transAltitude: None,
      geoDatumAlt: None,
      coord0: None,
      coord1: None,
      bearing0: 0.0,
      bearing1: 0.0,
      radMag0: 0.0,
      radMag1: 0.0,
      radMagUnit: None,
      polyCoord: None,
      trackLeg: 0,
      widthLeft: 0.0,
      widthRight: 0.0,
      width: 0.0,
      widthUnit: None,
      corrWayPoints: None,
      orbitAlignment: None,
      effVDim: None,
      airspaceTimePeriod: None,
      airspaceControlPoint: None,
      ctrlAuth: None,
      ctrlAuthFreqs: None,
      genTextInd: None,
      freeText: None,
    }
  }
}

pub struct AirspaceControlMeans_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AirspaceControlMeans_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_cmType(&mut self, cmType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_CMTYPE, cmType);
  }
  #[inline]
  pub fn add_cmId(&mut self, cmId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_CMID, cmId);
  }
  #[inline]
  pub fn add_cmShape(&mut self, cmShape: AirspaceControlMeans_Ingest_cmShape_Enum) {
    self.fbb_.push_slot::<AirspaceControlMeans_Ingest_cmShape_Enum>(AirspaceControlMeans_Ingest::VT_CMSHAPE, cmShape, AirspaceControlMeans_Ingest_cmShape_Enum::POLYARC);
  }
  #[inline]
  pub fn add_usage(&mut self, usage: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_USAGE, usage);
  }
  #[inline]
  pub fn add_link16Id(&mut self, link16Id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_LINK16ID, link16Id);
  }
  #[inline]
  pub fn add_transAltitude(&mut self, transAltitude: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_TRANSALTITUDE, transAltitude);
  }
  #[inline]
  pub fn add_geoDatumAlt(&mut self, geoDatumAlt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_GEODATUMALT, geoDatumAlt);
  }
  #[inline]
  pub fn add_coord0(&mut self, coord0: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_COORD0, coord0);
  }
  #[inline]
  pub fn add_coord1(&mut self, coord1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_COORD1, coord1);
  }
  #[inline]
  pub fn add_bearing0(&mut self, bearing0: f64) {
    self.fbb_.push_slot::<f64>(AirspaceControlMeans_Ingest::VT_BEARING0, bearing0, 0.0);
  }
  #[inline]
  pub fn add_bearing1(&mut self, bearing1: f64) {
    self.fbb_.push_slot::<f64>(AirspaceControlMeans_Ingest::VT_BEARING1, bearing1, 0.0);
  }
  #[inline]
  pub fn add_radMag0(&mut self, radMag0: f64) {
    self.fbb_.push_slot::<f64>(AirspaceControlMeans_Ingest::VT_RADMAG0, radMag0, 0.0);
  }
  #[inline]
  pub fn add_radMag1(&mut self, radMag1: f64) {
    self.fbb_.push_slot::<f64>(AirspaceControlMeans_Ingest::VT_RADMAG1, radMag1, 0.0);
  }
  #[inline]
  pub fn add_radMagUnit(&mut self, radMagUnit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_RADMAGUNIT, radMagUnit);
  }
  #[inline]
  pub fn add_polyCoord(&mut self, polyCoord: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_POLYCOORD, polyCoord);
  }
  #[inline]
  pub fn add_trackLeg(&mut self, trackLeg: i32) {
    self.fbb_.push_slot::<i32>(AirspaceControlMeans_Ingest::VT_TRACKLEG, trackLeg, 0);
  }
  #[inline]
  pub fn add_widthLeft(&mut self, widthLeft: f64) {
    self.fbb_.push_slot::<f64>(AirspaceControlMeans_Ingest::VT_WIDTHLEFT, widthLeft, 0.0);
  }
  #[inline]
  pub fn add_widthRight(&mut self, widthRight: f64) {
    self.fbb_.push_slot::<f64>(AirspaceControlMeans_Ingest::VT_WIDTHRIGHT, widthRight, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(AirspaceControlMeans_Ingest::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_widthUnit(&mut self, widthUnit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_WIDTHUNIT, widthUnit);
  }
  #[inline]
  pub fn add_corrWayPoints(&mut self, corrWayPoints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_CORRWAYPOINTS, corrWayPoints);
  }
  #[inline]
  pub fn add_orbitAlignment(&mut self, orbitAlignment: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_ORBITALIGNMENT, orbitAlignment);
  }
  #[inline]
  pub fn add_effVDim(&mut self, effVDim: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_EFFVDIM, effVDim);
  }
  #[inline]
  pub fn add_airspaceTimePeriod(&mut self, airspaceTimePeriod: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_AIRSPACETIMEPERIOD, airspaceTimePeriod);
  }
  #[inline]
  pub fn add_airspaceControlPoint(&mut self, airspaceControlPoint: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_AIRSPACECONTROLPOINT, airspaceControlPoint);
  }
  #[inline]
  pub fn add_ctrlAuth(&mut self, ctrlAuth: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_CTRLAUTH, ctrlAuth);
  }
  #[inline]
  pub fn add_ctrlAuthFreqs(&mut self, ctrlAuthFreqs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_CTRLAUTHFREQS, ctrlAuthFreqs);
  }
  #[inline]
  pub fn add_genTextInd(&mut self, genTextInd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_GENTEXTIND, genTextInd);
  }
  #[inline]
  pub fn add_freeText(&mut self, freeText: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirspaceControlMeans_Ingest::VT_FREETEXT, freeText);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AirspaceControlMeans_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AirspaceControlMeans_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AirspaceControlMeans_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AirspaceControlMeans_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AirspaceControlMeans_Ingest");
      ds.field("cmType", &self.cmType());
      ds.field("cmId", &self.cmId());
      ds.field("cmShape", &self.cmShape());
      ds.field("usage", &self.usage());
      ds.field("link16Id", &self.link16Id());
      ds.field("transAltitude", &self.transAltitude());
      ds.field("geoDatumAlt", &self.geoDatumAlt());
      ds.field("coord0", &self.coord0());
      ds.field("coord1", &self.coord1());
      ds.field("bearing0", &self.bearing0());
      ds.field("bearing1", &self.bearing1());
      ds.field("radMag0", &self.radMag0());
      ds.field("radMag1", &self.radMag1());
      ds.field("radMagUnit", &self.radMagUnit());
      ds.field("polyCoord", &self.polyCoord());
      ds.field("trackLeg", &self.trackLeg());
      ds.field("widthLeft", &self.widthLeft());
      ds.field("widthRight", &self.widthRight());
      ds.field("width", &self.width());
      ds.field("widthUnit", &self.widthUnit());
      ds.field("corrWayPoints", &self.corrWayPoints());
      ds.field("orbitAlignment", &self.orbitAlignment());
      ds.field("effVDim", &self.effVDim());
      ds.field("airspaceTimePeriod", &self.airspaceTimePeriod());
      ds.field("airspaceControlPoint", &self.airspaceControlPoint());
      ds.field("ctrlAuth", &self.ctrlAuth());
      ds.field("ctrlAuthFreqs", &self.ctrlAuthFreqs());
      ds.field("genTextInd", &self.genTextInd());
      ds.field("freeText", &self.freeText());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AirspaceControlMeans_IngestT {
  pub cmType: Option<String>,
  pub cmId: Option<String>,
  pub cmShape: AirspaceControlMeans_Ingest_cmShape_Enum,
  pub usage: Option<String>,
  pub link16Id: Option<String>,
  pub transAltitude: Option<String>,
  pub geoDatumAlt: Option<String>,
  pub coord0: Option<String>,
  pub coord1: Option<String>,
  pub bearing0: f64,
  pub bearing1: f64,
  pub radMag0: f64,
  pub radMag1: f64,
  pub radMagUnit: Option<String>,
  pub polyCoord: Option<Vec<String>>,
  pub trackLeg: i32,
  pub widthLeft: f64,
  pub widthRight: f64,
  pub width: f64,
  pub widthUnit: Option<String>,
  pub corrWayPoints: Option<Vec<String>>,
  pub orbitAlignment: Option<String>,
  pub effVDim: Option<String>,
  pub airspaceTimePeriod: Option<Vec<String>>,
  pub airspaceControlPoint: Option<Vec<String>>,
  pub ctrlAuth: Option<String>,
  pub ctrlAuthFreqs: Option<Vec<String>>,
  pub genTextInd: Option<String>,
  pub freeText: Option<String>,
}
impl Default for AirspaceControlMeans_IngestT {
  fn default() -> Self {
    Self {
      cmType: None,
      cmId: None,
      cmShape: AirspaceControlMeans_Ingest_cmShape_Enum::POLYARC,
      usage: None,
      link16Id: None,
      transAltitude: None,
      geoDatumAlt: None,
      coord0: None,
      coord1: None,
      bearing0: 0.0,
      bearing1: 0.0,
      radMag0: 0.0,
      radMag1: 0.0,
      radMagUnit: None,
      polyCoord: None,
      trackLeg: 0,
      widthLeft: 0.0,
      widthRight: 0.0,
      width: 0.0,
      widthUnit: None,
      corrWayPoints: None,
      orbitAlignment: None,
      effVDim: None,
      airspaceTimePeriod: None,
      airspaceControlPoint: None,
      ctrlAuth: None,
      ctrlAuthFreqs: None,
      genTextInd: None,
      freeText: None,
    }
  }
}
impl AirspaceControlMeans_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AirspaceControlMeans_Ingest<'b>> {
    let cmType = self.cmType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cmId = self.cmId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cmShape = self.cmShape;
    let usage = self.usage.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let link16Id = self.link16Id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let transAltitude = self.transAltitude.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let geoDatumAlt = self.geoDatumAlt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let coord0 = self.coord0.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let coord1 = self.coord1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let bearing0 = self.bearing0;
    let bearing1 = self.bearing1;
    let radMag0 = self.radMag0;
    let radMag1 = self.radMag1;
    let radMagUnit = self.radMagUnit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let polyCoord = self.polyCoord.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let trackLeg = self.trackLeg;
    let widthLeft = self.widthLeft;
    let widthRight = self.widthRight;
    let width = self.width;
    let widthUnit = self.widthUnit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let corrWayPoints = self.corrWayPoints.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let orbitAlignment = self.orbitAlignment.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let effVDim = self.effVDim.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let airspaceTimePeriod = self.airspaceTimePeriod.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let airspaceControlPoint = self.airspaceControlPoint.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ctrlAuth = self.ctrlAuth.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ctrlAuthFreqs = self.ctrlAuthFreqs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let genTextInd = self.genTextInd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let freeText = self.freeText.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    AirspaceControlMeans_Ingest::create(_fbb, &AirspaceControlMeans_IngestArgs{
      cmType,
      cmId,
      cmShape,
      usage,
      link16Id,
      transAltitude,
      geoDatumAlt,
      coord0,
      coord1,
      bearing0,
      bearing1,
      radMag0,
      radMag1,
      radMagUnit,
      polyCoord,
      trackLeg,
      widthLeft,
      widthRight,
      width,
      widthUnit,
      corrWayPoints,
      orbitAlignment,
      effVDim,
      airspaceTimePeriod,
      airspaceControlPoint,
      ctrlAuth,
      ctrlAuthFreqs,
      genTextInd,
      freeText,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AirspaceControlMeans_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airspace_control_means_ingest_unchecked`.
pub fn root_as_airspace_control_means_ingest(buf: &[u8]) -> Result<AirspaceControlMeans_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AirspaceControlMeans_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AirspaceControlMeans_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_airspace_control_means_ingest_unchecked`.
pub fn size_prefixed_root_as_airspace_control_means_ingest(buf: &[u8]) -> Result<AirspaceControlMeans_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AirspaceControlMeans_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AirspaceControlMeans_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airspace_control_means_ingest_unchecked`.
pub fn root_as_airspace_control_means_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirspaceControlMeans_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AirspaceControlMeans_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AirspaceControlMeans_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airspace_control_means_ingest_unchecked`.
pub fn size_prefixed_root_as_airspace_control_means_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirspaceControlMeans_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AirspaceControlMeans_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AirspaceControlMeans_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AirspaceControlMeans_Ingest`.
pub unsafe fn root_as_airspace_control_means_ingest_unchecked(buf: &[u8]) -> AirspaceControlMeans_Ingest {
  flatbuffers::root_unchecked::<AirspaceControlMeans_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AirspaceControlMeans_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AirspaceControlMeans_Ingest`.
pub unsafe fn size_prefixed_root_as_airspace_control_means_ingest_unchecked(buf: &[u8]) -> AirspaceControlMeans_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<AirspaceControlMeans_Ingest>(buf)
}
pub const AIRSPACE_CONTROL_MEANS_INGEST_IDENTIFIER: &str = "AIRS";

#[inline]
pub fn airspace_control_means_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRSPACE_CONTROL_MEANS_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn airspace_control_means_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRSPACE_CONTROL_MEANS_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_airspace_control_means_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AirspaceControlMeans_Ingest<'a>>) {
  fbb.finish(root, Some(AIRSPACE_CONTROL_MEANS_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_airspace_control_means_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AirspaceControlMeans_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(AIRSPACE_CONTROL_MEANS_INGEST_IDENTIFIER));
}
