// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_LINK_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_LINK_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_LINK_FULL_DATA_MODE_ENUM: [DataLink_Full_dataMode_Enum; 4] = [
  DataLink_Full_dataMode_Enum::REAL,
  DataLink_Full_dataMode_Enum::TEST,
  DataLink_Full_dataMode_Enum::SIMULATED,
  DataLink_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataLink_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl DataLink_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataLink_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataLink_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataLink_Full_dataMode_Enum {
    type Output = DataLink_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataLink_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataLink_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataLink_Full_dataMode_Enum {}
pub enum DataLink_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Beta Version DataLink: Detailed instructions regarding the operations of data links.
pub struct DataLink_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataLink_Full<'a> {
  type Inner = DataLink_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DataLink_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_OPEXNAME: flatbuffers::VOffsetT = 8;
  pub const VT_ORIGINATOR: flatbuffers::VOffsetT = 10;
  pub const VT_STARTTIME: flatbuffers::VOffsetT = 12;
  pub const VT_STOPTIME: flatbuffers::VOffsetT = 14;
  pub const VT_STOPTIMEMOD: flatbuffers::VOffsetT = 16;
  pub const VT_PLANORIGNUM: flatbuffers::VOffsetT = 18;
  pub const VT_OPEXINFO: flatbuffers::VOffsetT = 20;
  pub const VT_OPEXINFOALT: flatbuffers::VOffsetT = 22;
  pub const VT_SERIALNUM: flatbuffers::VOffsetT = 24;
  pub const VT_MONTH: flatbuffers::VOffsetT = 26;
  pub const VT_QUALIFIER: flatbuffers::VOffsetT = 28;
  pub const VT_QUALSN: flatbuffers::VOffsetT = 30;
  pub const VT_REFERENCES: flatbuffers::VOffsetT = 32;
  pub const VT_CANXID: flatbuffers::VOffsetT = 34;
  pub const VT_CANXORIGINATOR: flatbuffers::VOffsetT = 36;
  pub const VT_CANXTS: flatbuffers::VOffsetT = 38;
  pub const VT_CANXSERIALNUM: flatbuffers::VOffsetT = 40;
  pub const VT_CANXSPECIALNOTATION: flatbuffers::VOffsetT = 42;
  pub const VT_CANXSICS: flatbuffers::VOffsetT = 44;
  pub const VT_POCNAME: flatbuffers::VOffsetT = 46;
  pub const VT_POCRANK: flatbuffers::VOffsetT = 48;
  pub const VT_POCCALLSIGN: flatbuffers::VOffsetT = 50;
  pub const VT_POCLOCNAME: flatbuffers::VOffsetT = 52;
  pub const VT_POCLAT: flatbuffers::VOffsetT = 54;
  pub const VT_POCLON: flatbuffers::VOffsetT = 56;
  pub const VT_POCNUMS: flatbuffers::VOffsetT = 58;
  pub const VT_GEODATUM: flatbuffers::VOffsetT = 60;
  pub const VT_REFPOINTS: flatbuffers::VOffsetT = 62;
  pub const VT_VOICECOORD: flatbuffers::VOffsetT = 64;
  pub const VT_SYSDEFAULTCODE: flatbuffers::VOffsetT = 66;
  pub const VT_WINSIZEMULT: flatbuffers::VOffsetT = 68;
  pub const VT_WINSIZEMIN: flatbuffers::VOffsetT = 70;
  pub const VT_MINTRACKQUAL: flatbuffers::VOffsetT = 72;
  pub const VT_MAXTRACKQUAL: flatbuffers::VOffsetT = 74;
  pub const VT_RESTRACKQUAL: flatbuffers::VOffsetT = 76;
  pub const VT_COURSEDIFF: flatbuffers::VOffsetT = 78;
  pub const VT_SPEEDDIFF: flatbuffers::VOffsetT = 80;
  pub const VT_ALTDIFF: flatbuffers::VOffsetT = 82;
  pub const VT_MINGEOPOSQUAL: flatbuffers::VOffsetT = 84;
  pub const VT_MAXGEOPOSQUAL: flatbuffers::VOffsetT = 86;
  pub const VT_DECORRWINMULT: flatbuffers::VOffsetT = 88;
  pub const VT_CONSECDECORR: flatbuffers::VOffsetT = 90;
  pub const VT_MULTIDUTY: flatbuffers::VOffsetT = 92;
  pub const VT_OPS: flatbuffers::VOffsetT = 94;
  pub const VT_JREUNITDES: flatbuffers::VOffsetT = 96;
  pub const VT_JRECALLSIGN: flatbuffers::VOffsetT = 98;
  pub const VT_JREPRIADD: flatbuffers::VOffsetT = 100;
  pub const VT_JRESECADD: flatbuffers::VOffsetT = 102;
  pub const VT_JREDETAILS: flatbuffers::VOffsetT = 104;
  pub const VT_SPECTRACKS: flatbuffers::VOffsetT = 106;
  pub const VT_NONLINKUNITDES: flatbuffers::VOffsetT = 108;
  pub const VT_TRACKNUMBLOCKLLS: flatbuffers::VOffsetT = 110;
  pub const VT_TRACKNUMBLOCKS: flatbuffers::VOffsetT = 112;
  pub const VT_MGMTCODE: flatbuffers::VOffsetT = 114;
  pub const VT_MGMTCODEMEANING: flatbuffers::VOffsetT = 116;
  pub const VT_ACKREQ: flatbuffers::VOffsetT = 118;
  pub const VT_ACKINSTUNITS: flatbuffers::VOffsetT = 120;
  pub const VT_CLASSSOURCE: flatbuffers::VOffsetT = 122;
  pub const VT_CLASSREASONS: flatbuffers::VOffsetT = 124;
  pub const VT_DECINSTDATES: flatbuffers::VOffsetT = 126;
  pub const VT_DECEXEMPTCODES: flatbuffers::VOffsetT = 128;
  pub const VT_REMARKS: flatbuffers::VOffsetT = 130;
  pub const VT_RAWFILEURI: flatbuffers::VOffsetT = 132;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 134;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 136;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 138;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 140;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 142;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 144;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 146;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 148;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 150;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataLink_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DataLink_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<DataLink_Full<'bldr>> {
    let mut builder = DataLink_FullBuilder::new(_fbb);
    builder.add_decorrWinMult(args.decorrWinMult);
    builder.add_winSizeMin(args.winSizeMin);
    builder.add_winSizeMult(args.winSizeMult);
    builder.add_pocLon(args.pocLon);
    builder.add_pocLat(args.pocLat);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.rawFileURI { builder.add_rawFileURI(x); }
    if let Some(x) = args.remarks { builder.add_remarks(x); }
    if let Some(x) = args.decExemptCodes { builder.add_decExemptCodes(x); }
    if let Some(x) = args.decInstDates { builder.add_decInstDates(x); }
    if let Some(x) = args.classReasons { builder.add_classReasons(x); }
    if let Some(x) = args.classSource { builder.add_classSource(x); }
    if let Some(x) = args.ackInstUnits { builder.add_ackInstUnits(x); }
    if let Some(x) = args.mgmtCodeMeaning { builder.add_mgmtCodeMeaning(x); }
    if let Some(x) = args.mgmtCode { builder.add_mgmtCode(x); }
    if let Some(x) = args.trackNumBlocks { builder.add_trackNumBlocks(x); }
    if let Some(x) = args.trackNumBlockLLs { builder.add_trackNumBlockLLs(x); }
    if let Some(x) = args.nonLinkUnitDes { builder.add_nonLinkUnitDes(x); }
    if let Some(x) = args.specTracks { builder.add_specTracks(x); }
    if let Some(x) = args.jreDetails { builder.add_jreDetails(x); }
    builder.add_jreSecAdd(args.jreSecAdd);
    builder.add_jrePriAdd(args.jrePriAdd);
    if let Some(x) = args.jreCallSign { builder.add_jreCallSign(x); }
    if let Some(x) = args.jreUnitDes { builder.add_jreUnitDes(x); }
    if let Some(x) = args.ops { builder.add_ops(x); }
    if let Some(x) = args.multiDuty { builder.add_multiDuty(x); }
    builder.add_consecDecorr(args.consecDecorr);
    builder.add_maxGeoPosQual(args.maxGeoPosQual);
    builder.add_minGeoPosQual(args.minGeoPosQual);
    builder.add_altDiff(args.altDiff);
    builder.add_speedDiff(args.speedDiff);
    builder.add_courseDiff(args.courseDiff);
    builder.add_resTrackQual(args.resTrackQual);
    builder.add_maxTrackQual(args.maxTrackQual);
    builder.add_minTrackQual(args.minTrackQual);
    if let Some(x) = args.sysDefaultCode { builder.add_sysDefaultCode(x); }
    if let Some(x) = args.voiceCoord { builder.add_voiceCoord(x); }
    if let Some(x) = args.refPoints { builder.add_refPoints(x); }
    if let Some(x) = args.geoDatum { builder.add_geoDatum(x); }
    if let Some(x) = args.pocNums { builder.add_pocNums(x); }
    if let Some(x) = args.pocLocName { builder.add_pocLocName(x); }
    if let Some(x) = args.pocCallSign { builder.add_pocCallSign(x); }
    if let Some(x) = args.pocRank { builder.add_pocRank(x); }
    if let Some(x) = args.pocName { builder.add_pocName(x); }
    if let Some(x) = args.canxSICs { builder.add_canxSICs(x); }
    if let Some(x) = args.canxSpecialNotation { builder.add_canxSpecialNotation(x); }
    if let Some(x) = args.canxSerialNum { builder.add_canxSerialNum(x); }
    if let Some(x) = args.canxTs { builder.add_canxTs(x); }
    if let Some(x) = args.canxOriginator { builder.add_canxOriginator(x); }
    if let Some(x) = args.canxId { builder.add_canxId(x); }
    if let Some(x) = args.references { builder.add_references(x); }
    builder.add_qualSN(args.qualSN);
    if let Some(x) = args.qualifier { builder.add_qualifier(x); }
    if let Some(x) = args.month { builder.add_month(x); }
    if let Some(x) = args.serialNum { builder.add_serialNum(x); }
    if let Some(x) = args.opExInfoAlt { builder.add_opExInfoAlt(x); }
    if let Some(x) = args.opExInfo { builder.add_opExInfo(x); }
    if let Some(x) = args.planOrigNum { builder.add_planOrigNum(x); }
    if let Some(x) = args.stopTimeMod { builder.add_stopTimeMod(x); }
    if let Some(x) = args.stopTime { builder.add_stopTime(x); }
    if let Some(x) = args.startTime { builder.add_startTime(x); }
    if let Some(x) = args.originator { builder.add_originator(x); }
    if let Some(x) = args.opExName { builder.add_opExName(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_ackReq(args.ackReq);
    builder.finish()
  }

  pub fn unpack(&self) -> DataLink_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let opExName = self.opExName().map(|x| {
      x.to_string()
    });
    let originator = self.originator().map(|x| {
      x.to_string()
    });
    let startTime = self.startTime().map(|x| {
      x.to_string()
    });
    let stopTime = self.stopTime().map(|x| {
      x.to_string()
    });
    let stopTimeMod = self.stopTimeMod().map(|x| {
      x.to_string()
    });
    let planOrigNum = self.planOrigNum().map(|x| {
      x.to_string()
    });
    let opExInfo = self.opExInfo().map(|x| {
      x.to_string()
    });
    let opExInfoAlt = self.opExInfoAlt().map(|x| {
      x.to_string()
    });
    let serialNum = self.serialNum().map(|x| {
      x.to_string()
    });
    let month = self.month().map(|x| {
      x.to_string()
    });
    let qualifier = self.qualifier().map(|x| {
      x.to_string()
    });
    let qualSN = self.qualSN();
    let references = self.references().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let canxId = self.canxId().map(|x| {
      x.to_string()
    });
    let canxOriginator = self.canxOriginator().map(|x| {
      x.to_string()
    });
    let canxTs = self.canxTs().map(|x| {
      x.to_string()
    });
    let canxSerialNum = self.canxSerialNum().map(|x| {
      x.to_string()
    });
    let canxSpecialNotation = self.canxSpecialNotation().map(|x| {
      x.to_string()
    });
    let canxSICs = self.canxSICs().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let pocName = self.pocName().map(|x| {
      x.to_string()
    });
    let pocRank = self.pocRank().map(|x| {
      x.to_string()
    });
    let pocCallSign = self.pocCallSign().map(|x| {
      x.to_string()
    });
    let pocLocName = self.pocLocName().map(|x| {
      x.to_string()
    });
    let pocLat = self.pocLat();
    let pocLon = self.pocLon();
    let pocNums = self.pocNums().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let geoDatum = self.geoDatum().map(|x| {
      x.to_string()
    });
    let refPoints = self.refPoints().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let voiceCoord = self.voiceCoord().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let sysDefaultCode = self.sysDefaultCode().map(|x| {
      x.to_string()
    });
    let winSizeMult = self.winSizeMult();
    let winSizeMin = self.winSizeMin();
    let minTrackQual = self.minTrackQual();
    let maxTrackQual = self.maxTrackQual();
    let resTrackQual = self.resTrackQual();
    let courseDiff = self.courseDiff();
    let speedDiff = self.speedDiff();
    let altDiff = self.altDiff();
    let minGeoPosQual = self.minGeoPosQual();
    let maxGeoPosQual = self.maxGeoPosQual();
    let decorrWinMult = self.decorrWinMult();
    let consecDecorr = self.consecDecorr();
    let multiDuty = self.multiDuty().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ops = self.ops().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let jreUnitDes = self.jreUnitDes().map(|x| {
      x.to_string()
    });
    let jreCallSign = self.jreCallSign().map(|x| {
      x.to_string()
    });
    let jrePriAdd = self.jrePriAdd();
    let jreSecAdd = self.jreSecAdd();
    let jreDetails = self.jreDetails().map(|x| {
      x.to_string()
    });
    let specTracks = self.specTracks().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let nonLinkUnitDes = self.nonLinkUnitDes().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let trackNumBlockLLs = self.trackNumBlockLLs().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let trackNumBlocks = self.trackNumBlocks().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let mgmtCode = self.mgmtCode().map(|x| {
      x.to_string()
    });
    let mgmtCodeMeaning = self.mgmtCodeMeaning().map(|x| {
      x.to_string()
    });
    let ackReq = self.ackReq();
    let ackInstUnits = self.ackInstUnits().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let classSource = self.classSource().map(|x| {
      x.to_string()
    });
    let classReasons = self.classReasons().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let decInstDates = self.decInstDates().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let decExemptCodes = self.decExemptCodes().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let remarks = self.remarks().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let rawFileURI = self.rawFileURI().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    DataLink_FullT {
      id,
      classificationMarking,
      opExName,
      originator,
      startTime,
      stopTime,
      stopTimeMod,
      planOrigNum,
      opExInfo,
      opExInfoAlt,
      serialNum,
      month,
      qualifier,
      qualSN,
      references,
      canxId,
      canxOriginator,
      canxTs,
      canxSerialNum,
      canxSpecialNotation,
      canxSICs,
      pocName,
      pocRank,
      pocCallSign,
      pocLocName,
      pocLat,
      pocLon,
      pocNums,
      geoDatum,
      refPoints,
      voiceCoord,
      sysDefaultCode,
      winSizeMult,
      winSizeMin,
      minTrackQual,
      maxTrackQual,
      resTrackQual,
      courseDiff,
      speedDiff,
      altDiff,
      minGeoPosQual,
      maxGeoPosQual,
      decorrWinMult,
      consecDecorr,
      multiDuty,
      ops,
      jreUnitDes,
      jreCallSign,
      jrePriAdd,
      jreSecAdd,
      jreDetails,
      specTracks,
      nonLinkUnitDes,
      trackNumBlockLLs,
      trackNumBlocks,
      mgmtCode,
      mgmtCodeMeaning,
      ackReq,
      ackInstUnits,
      classSource,
      classReasons,
      decInstDates,
      decExemptCodes,
      remarks,
      rawFileURI,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      sourceDL,
      source,
      origin,
      origNetwork,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system if not provided on create operations.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Specifies the unique operation or exercise name, nickname, or codeword assigned to a joint exercise or operation plan.
  /// Example: /// Example: DESERT WIND
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn opExName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_OPEXNAME, None)}
  }
  /// The identifier of the originator of this message.
  /// Example: /// Example: USCENTCOM
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn originator(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_ORIGINATOR, None)}
  }
  /// The start of the effective time period of this data link message, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-01-07T13:55:43.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn startTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_STARTTIME, None)}
  }
  /// The end of the effective time period of this data link message, in ISO 8601 UTC format with millisecond precision. This may be a relative stop time if used with stopTimeMod.
  /// Example: /// Example: 2024-01-08T13:55:43.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stopTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_STOPTIME, None)}
  }
  /// A qualifier for the end of the effective time period of this data link message, such as AFTER, ASOF, NLT, etc. Used with field stopTime to indicate a relative time.
  /// Example: /// Example: AFTER
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn stopTimeMod(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_STOPTIMEMOD, None)}
  }
  /// The official identifier of the military establishment responsible for the operation plan and the identification number assigned to this plan.
  /// Example: /// Example: SACEUR 106
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn planOrigNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_PLANORIGNUM, None)}
  }
  /// Provides an additional caveat further identifying the exercise or modifies the exercise nickname.
  /// Example: /// Example: CONTROL
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn opExInfo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_OPEXINFO, None)}
  }
  /// The secondary nickname of the option or the alternative of the operational plan or order.
  /// Example: /// Example: ORANGE
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn opExInfoAlt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_OPEXINFOALT, None)}
  }
  /// The unique message identifier assigned by the originator.
  /// Example: /// Example: 1201003
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn serialNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_SERIALNUM, None)}
  }
  /// The month in which this message originated.
  /// Example: /// Example: OCT
  /// Constraints: Minimum length = 0, Maximum length = 12
  #[inline]
  pub fn month(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_MONTH, None)}
  }
  /// The qualifier which caveats the message status such as AMP (Amplification), CHG (Change), etc.
  /// Example: /// Example: CHG
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn qualifier(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_QUALIFIER, None)}
  }
  /// The serial number associated with the message qualifier.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn qualSN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_QUALSN, Some(0)).unwrap()}
  }
  /// Collection of reference information. There can be 0 to many DataLinkReferences collections within the datalink service.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn references(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_REFERENCES, None)}
  }
  /// The identifier for this data link message cancellation.
  /// Example: /// Example: ABSTAT
  /// Constraints: Minimum length = 0, Maximum length = 20
  #[inline]
  pub fn canxId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_CANXID, None)}
  }
  /// The originator of this data link message cancellation.
  /// Example: /// Example: 505 AOC
  /// Constraints: Minimum length = 0, Maximum length = 30
  #[inline]
  pub fn canxOriginator(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_CANXORIGINATOR, None)}
  }
  /// Timestamp of the data link message cancellation, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-01-07T13:55:43.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn canxTs(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_CANXTS, None)}
  }
  /// Serial number assigned to this data link message cancellation.
  /// Example: /// Example: ABC1234567
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn canxSerialNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_CANXSERIALNUM, None)}
  }
  /// Indicates any special actions, restrictions, guidance, or information relating to this data link message cancellation.
  /// Example: /// Example: PASEP
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn canxSpecialNotation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_CANXSPECIALNOTATION, None)}
  }
  /// Array of NATO Subject Indicator Codes (SIC) or filing numbers of this data link message or document being cancelled.
  /// Example: /// Example: ['RDU', 'X234BS']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn canxSICs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_CANXSICS, None)}
  }
  /// The name of the point of contact for this data link message.
  /// Example: /// Example: F. BURNS
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn pocName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_POCNAME, None)}
  }
  /// The rank or position of the point of contact for this data link message in a military or civilian organization.
  /// Example: /// Example: MAJ
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn pocRank(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_POCRANK, None)}
  }
  /// The unit identifier or call sign of the point of contact for this data link message.
  /// Example: /// Example: 4077 MASH
  /// Constraints: Minimum length = 0, Maximum length = 38
  #[inline]
  pub fn pocCallSign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_POCCALLSIGN, None)}
  }
  /// The location name of the point of contact for this data link message.
  /// Example: /// Example: CAMP SWAMPY
  /// Constraints: Minimum length = 0, Maximum length = 20
  #[inline]
  pub fn pocLocName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_POCLOCNAME, None)}
  }
  /// WGS84 latitude of the point of contact for this data link message, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pocLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DataLink_Full::VT_POCLAT, Some(0.0)).unwrap()}
  }
  /// WGS84 longitude of the point of contact for this data link message, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pocLon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DataLink_Full::VT_POCLON, Some(0.0)).unwrap()}
  }
  /// Array of telephone numbers, radio frequency values, or email addresses of the point of contact for this data link message.
  /// Example: /// Example: ['TEL:804-555-4142', 'TEL:804-867-5309']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pocNums(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_POCNUMS, None)}
  }
  /// The code for the point of reference from which the coordinates and networks are computed.
  /// Example: /// Example: EUR-T
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn geoDatum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_GEODATUM, None)}
  }
  /// Collection that identifies points of reference used in the establishment of the data links. There can be 1 to many DataLinkRefPoints collections within the datalink service.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn refPoints(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_REFPOINTS, None)}
  }
  /// Collection of information regarding the function, frequency, and priority of interface control and coordination nets for this data link message. There can be 1 to many DataLinkVoiceCoord collections within the datalink service.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn voiceCoord(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_VOICECOORD, None)}
  }
  /// Indicates the data terminal settings the system defaults to, either automatic correlation/decorrelation (AUTO) or manual (MAN).
  /// Example: /// Example: MAN
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn sysDefaultCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_SYSDEFAULTCODE, None)}
  }
  /// The correlation window size multiplier to stretch or reduce the window size. Required if sysDefaultCode field is "MAN". Allowable entries are 0.5 to 3.0 in increments of 0.1.
  /// Example: /// Example: 2.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn winSizeMult(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DataLink_Full::VT_WINSIZEMULT, Some(0.0)).unwrap()}
  }
  /// Number added to the basic window calculated from track qualities to ensure that windows still allow valid correlations. Required if sysDefaultCode field is "MAN". Allowable entries are 0.0 to 2.0 in increments of 0.25.
  /// Example: /// Example: 1.25
  /// Constraints: No constraints specified.
  #[inline]
  pub fn winSizeMin(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DataLink_Full::VT_WINSIZEMIN, Some(0.0)).unwrap()}
  }
  /// Track quality to prevent correlation windows from being unrealistically large. Required if sysDefaultCode field is "MAN". Allowable entries are integers from 3 to 7.
  /// Example: /// Example: 6
  /// Constraints: No constraints specified.
  #[inline]
  pub fn minTrackQual(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_MINTRACKQUAL, Some(0)).unwrap()}
  }
  /// Track quality to prevent correlation windows from being unrealistically small. Required if sysDefaultCode field is "MAN". Allowable entries are integers from 8 to 15.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxTrackQual(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_MAXTRACKQUAL, Some(0)).unwrap()}
  }
  /// Track quality to enter if too many duals involving low track quality tracks are occurring. Required if sysDefaultCode field is "MAN". Allowable entries are integers from 2 to 6.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn resTrackQual(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_RESTRACKQUAL, Some(0)).unwrap()}
  }
  /// Maximum difference between the reported course of the remote track and the calculated course of the local track. Required if sysDefaultCode field is "MAN". Allowable entries are 15 to 90 in increments of 15 degrees.
  /// Example: /// Example: 60
  /// Constraints: No constraints specified.
  #[inline]
  pub fn courseDiff(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_COURSEDIFF, Some(0)).unwrap()}
  }
  /// Maximum percentage the faster track speed may differ from the slower track speed. Required if sysDefaultCode field is "MAN". Allowable entries are 10 to 100 in increments of 10.
  /// Example: /// Example: 50
  /// Constraints: No constraints specified.
  #[inline]
  pub fn speedDiff(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_SPEEDDIFF, Some(0)).unwrap()}
  }
  /// Maximum altitude difference between two air tracks, in thousands of feet. Required if sysDefaultCode field is "MAN". Allowable entires are 5 to 50 in increments of 5000 feet.
  /// Example: /// Example: 20
  /// Constraints: No constraints specified.
  #[inline]
  pub fn altDiff(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_ALTDIFF, Some(0)).unwrap()}
  }
  /// Number used for minimum geodetic position quality. Required if sysDefaultCode field is "MAN". Allowable entries are integers from 1 to 5.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn minGeoPosQual(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_MINGEOPOSQUAL, Some(0)).unwrap()}
  }
  /// Number used for maximum geodetic position quality. Required if sysDefaultCode field is "MAN". Allowable entires are integers from 1 to 15.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxGeoPosQual(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_MAXGEOPOSQUAL, Some(0)).unwrap()}
  }
  /// Distance between the common and remote track is to exceed the applicable correlation window for the two tracks in order to be decorrelated. Required if sysDefaultCode field is "MAN". Allowable entries are 1.0 to 2.0 in increments of 0.1.
  /// Example: /// Example: 1.7
  /// Constraints: No constraints specified.
  #[inline]
  pub fn decorrWinMult(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DataLink_Full::VT_DECORRWINMULT, Some(0.0)).unwrap()}
  }
  /// Number of consecutive remote track reports that must meet the decorrelation criteria before the decorrelation is executed. Required if sysDefaultCode field is "MAN". Allowable entries are integers from 1 to 5.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn consecDecorr(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_CONSECDECORR, Some(0)).unwrap()}
  }
  /// Collection of contact and identification information for designated multilink coordinator duty assignments. There can be 0 to many DataLinkMultiDuty collections within the datalink service.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn multiDuty(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_MULTIDUTY, None)}
  }
  /// Collection of information describing the establishment and detailed operation of tactical data links. There can be 0 to many DataLinkOps collections within the datalink service.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ops(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_OPS, None)}
  }
  /// Designator of the unit for Joint Range Extension (JRE).
  /// Example: /// Example: CVN-72
  /// Constraints: Minimum length = 0, Maximum length = 30
  #[inline]
  pub fn jreUnitDes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_JREUNITDES, None)}
  }
  /// Call sign which identifies one or more communications facilities, commands, authorities, or activities for Joint Range Extension (JRE) units.
  /// Example: /// Example: CHARLIE ONE
  /// Constraints: Minimum length = 0, Maximum length = 38
  #[inline]
  pub fn jreCallSign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_JRECALLSIGN, None)}
  }
  /// Link-16 octal track number assigned as the primary JTIDS unit address.
  /// Example: /// Example: 71777
  /// Constraints: No constraints specified.
  #[inline]
  pub fn jrePriAdd(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_JREPRIADD, Some(0)).unwrap()}
  }
  /// Link-16 octal track number assigned as the secondary JTIDS unit address.
  /// Example: /// Example: 77771
  /// Constraints: No constraints specified.
  #[inline]
  pub fn jreSecAdd(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DataLink_Full::VT_JRESECADD, Some(0)).unwrap()}
  }
  /// Joint Range Extension (JRE) unit details.
  /// Example: /// Example: JRE details
  /// Constraints: Minimum length = 0, Maximum length = 3000
  #[inline]
  pub fn jreDetails(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_JREDETAILS, None)}
  }
  /// Collection of special track numbers used on the data links. There can be 0 to many DataLinkSpecTracks collections within the datalink service.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn specTracks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_SPECTRACKS, None)}
  }
  /// Array of non-link specific data unit designators.
  /// Example: /// Example: ['CS:GRAY GHOST', 'CS:WHITE WHALE']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn nonLinkUnitDes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_NONLINKUNITDES, None)}
  }
  /// Array of Link-16 octal track numbers used as the lower limit of a track block.
  /// Example: /// Example: [1234, 2345]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trackNumBlockLLs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_TRACKNUMBLOCKLLS, None)}
  }
  /// Array of defined ranges of Link-11/11B track numbers assigned to a participating unit or reporting unit.
  /// Example: /// Example: ['0200-0300', '0400-4412']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trackNumBlocks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_TRACKNUMBLOCKS, None)}
  }
  /// Data link management code word.
  /// Example: /// Example: VICTOR
  /// Constraints: Minimum length = 0, Maximum length = 15
  #[inline]
  pub fn mgmtCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_MGMTCODE, None)}
  }
  /// Data link management code word meaning.
  /// Example: /// Example: ORBIT AT POINT BRAVO
  /// Constraints: Minimum length = 0, Maximum length = 50
  #[inline]
  pub fn mgmtCodeMeaning(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_MGMTCODEMEANING, None)}
  }
  /// Flag Indicating if formal acknowledgement is required for the particular data link message being sent.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ackReq(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DataLink_Full::VT_ACKREQ, Some(false)).unwrap()}
  }
  /// Array of instructions for acknowledging and the force or units required to acknowledge the data link message being sent.
  /// Example: /// Example: ['AOC EXT 2345', '317 AW']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ackInstUnits(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_ACKINSTUNITS, None)}
  }
  /// Markings that define the source material or the original classification authority for this data link message.
  /// Example: /// Example: USJFCOM EXORD SOLID WASTE 98
  /// Constraints: Minimum length = 0, Maximum length = 55
  #[inline]
  pub fn classSource(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_CLASSSOURCE, None)}
  }
  /// Array of codes that indicate the reasons material is classified.
  /// Example: /// Example: ['15C', '15D']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn classReasons(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_CLASSREASONS, None)}
  }
  /// Array of markings that provide the literal guidance or dates for the downgrading or declassification of this data link message.
  /// Example: /// Example: ['AT EXERCISE ENDEX', 'DATE:25NOV1997']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn decInstDates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_DECINSTDATES, None)}
  }
  /// Array of codes that provide justification for exemption from automatic downgrading or declassification.
  /// Example: /// Example: ['X1', 'X2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn decExemptCodes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_DECEXEMPTCODES, None)}
  }
  /// Collection of remarks associated with this data link message.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn remarks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DataLink_Full::VT_REMARKS, None)}
  }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  /// Example: /// Example: Example URI
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn rawFileURI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_RAWFILEURI, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_CREATEDBY, None)}
  }
  /// Time the row was updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_UPDATEDBY, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_SOURCEDL, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DataLink_Full::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> DataLink_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DataLink_Full_dataMode_Enum>(DataLink_Full::VT_DATAMODE, Some(DataLink_Full_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DataLink_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("opExName", Self::VT_OPEXNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("originator", Self::VT_ORIGINATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("startTime", Self::VT_STARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stopTime", Self::VT_STOPTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stopTimeMod", Self::VT_STOPTIMEMOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("planOrigNum", Self::VT_PLANORIGNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("opExInfo", Self::VT_OPEXINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("opExInfoAlt", Self::VT_OPEXINFOALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("serialNum", Self::VT_SERIALNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("month", Self::VT_MONTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("qualifier", Self::VT_QUALIFIER, false)?
     .visit_field::<i32>("qualSN", Self::VT_QUALSN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("references", Self::VT_REFERENCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("canxId", Self::VT_CANXID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("canxOriginator", Self::VT_CANXORIGINATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("canxTs", Self::VT_CANXTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("canxSerialNum", Self::VT_CANXSERIALNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("canxSpecialNotation", Self::VT_CANXSPECIALNOTATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("canxSICs", Self::VT_CANXSICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pocName", Self::VT_POCNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pocRank", Self::VT_POCRANK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pocCallSign", Self::VT_POCCALLSIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pocLocName", Self::VT_POCLOCNAME, false)?
     .visit_field::<f64>("pocLat", Self::VT_POCLAT, false)?
     .visit_field::<f64>("pocLon", Self::VT_POCLON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("pocNums", Self::VT_POCNUMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("geoDatum", Self::VT_GEODATUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("refPoints", Self::VT_REFPOINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("voiceCoord", Self::VT_VOICECOORD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sysDefaultCode", Self::VT_SYSDEFAULTCODE, false)?
     .visit_field::<f64>("winSizeMult", Self::VT_WINSIZEMULT, false)?
     .visit_field::<f64>("winSizeMin", Self::VT_WINSIZEMIN, false)?
     .visit_field::<i32>("minTrackQual", Self::VT_MINTRACKQUAL, false)?
     .visit_field::<i32>("maxTrackQual", Self::VT_MAXTRACKQUAL, false)?
     .visit_field::<i32>("resTrackQual", Self::VT_RESTRACKQUAL, false)?
     .visit_field::<i32>("courseDiff", Self::VT_COURSEDIFF, false)?
     .visit_field::<i32>("speedDiff", Self::VT_SPEEDDIFF, false)?
     .visit_field::<i32>("altDiff", Self::VT_ALTDIFF, false)?
     .visit_field::<i32>("minGeoPosQual", Self::VT_MINGEOPOSQUAL, false)?
     .visit_field::<i32>("maxGeoPosQual", Self::VT_MAXGEOPOSQUAL, false)?
     .visit_field::<f64>("decorrWinMult", Self::VT_DECORRWINMULT, false)?
     .visit_field::<i32>("consecDecorr", Self::VT_CONSECDECORR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("multiDuty", Self::VT_MULTIDUTY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ops", Self::VT_OPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("jreUnitDes", Self::VT_JREUNITDES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("jreCallSign", Self::VT_JRECALLSIGN, false)?
     .visit_field::<i32>("jrePriAdd", Self::VT_JREPRIADD, false)?
     .visit_field::<i32>("jreSecAdd", Self::VT_JRESECADD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("jreDetails", Self::VT_JREDETAILS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("specTracks", Self::VT_SPECTRACKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("nonLinkUnitDes", Self::VT_NONLINKUNITDES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("trackNumBlockLLs", Self::VT_TRACKNUMBLOCKLLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("trackNumBlocks", Self::VT_TRACKNUMBLOCKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mgmtCode", Self::VT_MGMTCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mgmtCodeMeaning", Self::VT_MGMTCODEMEANING, false)?
     .visit_field::<bool>("ackReq", Self::VT_ACKREQ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ackInstUnits", Self::VT_ACKINSTUNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classSource", Self::VT_CLASSSOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("classReasons", Self::VT_CLASSREASONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("decInstDates", Self::VT_DECINSTDATES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("decExemptCodes", Self::VT_DECEXEMPTCODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("remarks", Self::VT_REMARKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawFileURI", Self::VT_RAWFILEURI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<DataLink_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct DataLink_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opExName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub originator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stopTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stopTimeMod: Option<flatbuffers::WIPOffset<&'a str>>,
    pub planOrigNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opExInfo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opExInfoAlt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub serialNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub month: Option<flatbuffers::WIPOffset<&'a str>>,
    pub qualifier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub qualSN: i32,
    pub references: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub canxId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canxOriginator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canxTs: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canxSerialNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canxSpecialNotation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canxSICs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub pocName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pocRank: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pocCallSign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pocLocName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pocLat: f64,
    pub pocLon: f64,
    pub pocNums: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub geoDatum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub refPoints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub voiceCoord: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub sysDefaultCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub winSizeMult: f64,
    pub winSizeMin: f64,
    pub minTrackQual: i32,
    pub maxTrackQual: i32,
    pub resTrackQual: i32,
    pub courseDiff: i32,
    pub speedDiff: i32,
    pub altDiff: i32,
    pub minGeoPosQual: i32,
    pub maxGeoPosQual: i32,
    pub decorrWinMult: f64,
    pub consecDecorr: i32,
    pub multiDuty: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ops: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub jreUnitDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub jreCallSign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub jrePriAdd: i32,
    pub jreSecAdd: i32,
    pub jreDetails: Option<flatbuffers::WIPOffset<&'a str>>,
    pub specTracks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub nonLinkUnitDes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub trackNumBlockLLs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub trackNumBlocks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub mgmtCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mgmtCodeMeaning: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ackReq: bool,
    pub ackInstUnits: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub classSource: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classReasons: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub decInstDates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub decExemptCodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub remarks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub rawFileURI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: DataLink_Full_dataMode_Enum,
}
impl<'a> Default for DataLink_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    DataLink_FullArgs {
      id: None,
      classificationMarking: None,
      opExName: None,
      originator: None,
      startTime: None,
      stopTime: None,
      stopTimeMod: None,
      planOrigNum: None,
      opExInfo: None,
      opExInfoAlt: None,
      serialNum: None,
      month: None,
      qualifier: None,
      qualSN: 0,
      references: None,
      canxId: None,
      canxOriginator: None,
      canxTs: None,
      canxSerialNum: None,
      canxSpecialNotation: None,
      canxSICs: None,
      pocName: None,
      pocRank: None,
      pocCallSign: None,
      pocLocName: None,
      pocLat: 0.0,
      pocLon: 0.0,
      pocNums: None,
      geoDatum: None,
      refPoints: None,
      voiceCoord: None,
      sysDefaultCode: None,
      winSizeMult: 0.0,
      winSizeMin: 0.0,
      minTrackQual: 0,
      maxTrackQual: 0,
      resTrackQual: 0,
      courseDiff: 0,
      speedDiff: 0,
      altDiff: 0,
      minGeoPosQual: 0,
      maxGeoPosQual: 0,
      decorrWinMult: 0.0,
      consecDecorr: 0,
      multiDuty: None,
      ops: None,
      jreUnitDes: None,
      jreCallSign: None,
      jrePriAdd: 0,
      jreSecAdd: 0,
      jreDetails: None,
      specTracks: None,
      nonLinkUnitDes: None,
      trackNumBlockLLs: None,
      trackNumBlocks: None,
      mgmtCode: None,
      mgmtCodeMeaning: None,
      ackReq: false,
      ackInstUnits: None,
      classSource: None,
      classReasons: None,
      decInstDates: None,
      decExemptCodes: None,
      remarks: None,
      rawFileURI: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: DataLink_Full_dataMode_Enum::REAL,
    }
  }
}

pub struct DataLink_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataLink_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_opExName(&mut self, opExName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_OPEXNAME, opExName);
  }
  #[inline]
  pub fn add_originator(&mut self, originator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_ORIGINATOR, originator);
  }
  #[inline]
  pub fn add_startTime(&mut self, startTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_STARTTIME, startTime);
  }
  #[inline]
  pub fn add_stopTime(&mut self, stopTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_STOPTIME, stopTime);
  }
  #[inline]
  pub fn add_stopTimeMod(&mut self, stopTimeMod: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_STOPTIMEMOD, stopTimeMod);
  }
  #[inline]
  pub fn add_planOrigNum(&mut self, planOrigNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_PLANORIGNUM, planOrigNum);
  }
  #[inline]
  pub fn add_opExInfo(&mut self, opExInfo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_OPEXINFO, opExInfo);
  }
  #[inline]
  pub fn add_opExInfoAlt(&mut self, opExInfoAlt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_OPEXINFOALT, opExInfoAlt);
  }
  #[inline]
  pub fn add_serialNum(&mut self, serialNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_SERIALNUM, serialNum);
  }
  #[inline]
  pub fn add_month(&mut self, month: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_MONTH, month);
  }
  #[inline]
  pub fn add_qualifier(&mut self, qualifier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_QUALIFIER, qualifier);
  }
  #[inline]
  pub fn add_qualSN(&mut self, qualSN: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_QUALSN, qualSN, 0);
  }
  #[inline]
  pub fn add_references(&mut self, references: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_REFERENCES, references);
  }
  #[inline]
  pub fn add_canxId(&mut self, canxId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_CANXID, canxId);
  }
  #[inline]
  pub fn add_canxOriginator(&mut self, canxOriginator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_CANXORIGINATOR, canxOriginator);
  }
  #[inline]
  pub fn add_canxTs(&mut self, canxTs: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_CANXTS, canxTs);
  }
  #[inline]
  pub fn add_canxSerialNum(&mut self, canxSerialNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_CANXSERIALNUM, canxSerialNum);
  }
  #[inline]
  pub fn add_canxSpecialNotation(&mut self, canxSpecialNotation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_CANXSPECIALNOTATION, canxSpecialNotation);
  }
  #[inline]
  pub fn add_canxSICs(&mut self, canxSICs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_CANXSICS, canxSICs);
  }
  #[inline]
  pub fn add_pocName(&mut self, pocName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_POCNAME, pocName);
  }
  #[inline]
  pub fn add_pocRank(&mut self, pocRank: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_POCRANK, pocRank);
  }
  #[inline]
  pub fn add_pocCallSign(&mut self, pocCallSign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_POCCALLSIGN, pocCallSign);
  }
  #[inline]
  pub fn add_pocLocName(&mut self, pocLocName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_POCLOCNAME, pocLocName);
  }
  #[inline]
  pub fn add_pocLat(&mut self, pocLat: f64) {
    self.fbb_.push_slot::<f64>(DataLink_Full::VT_POCLAT, pocLat, 0.0);
  }
  #[inline]
  pub fn add_pocLon(&mut self, pocLon: f64) {
    self.fbb_.push_slot::<f64>(DataLink_Full::VT_POCLON, pocLon, 0.0);
  }
  #[inline]
  pub fn add_pocNums(&mut self, pocNums: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_POCNUMS, pocNums);
  }
  #[inline]
  pub fn add_geoDatum(&mut self, geoDatum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_GEODATUM, geoDatum);
  }
  #[inline]
  pub fn add_refPoints(&mut self, refPoints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_REFPOINTS, refPoints);
  }
  #[inline]
  pub fn add_voiceCoord(&mut self, voiceCoord: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_VOICECOORD, voiceCoord);
  }
  #[inline]
  pub fn add_sysDefaultCode(&mut self, sysDefaultCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_SYSDEFAULTCODE, sysDefaultCode);
  }
  #[inline]
  pub fn add_winSizeMult(&mut self, winSizeMult: f64) {
    self.fbb_.push_slot::<f64>(DataLink_Full::VT_WINSIZEMULT, winSizeMult, 0.0);
  }
  #[inline]
  pub fn add_winSizeMin(&mut self, winSizeMin: f64) {
    self.fbb_.push_slot::<f64>(DataLink_Full::VT_WINSIZEMIN, winSizeMin, 0.0);
  }
  #[inline]
  pub fn add_minTrackQual(&mut self, minTrackQual: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_MINTRACKQUAL, minTrackQual, 0);
  }
  #[inline]
  pub fn add_maxTrackQual(&mut self, maxTrackQual: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_MAXTRACKQUAL, maxTrackQual, 0);
  }
  #[inline]
  pub fn add_resTrackQual(&mut self, resTrackQual: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_RESTRACKQUAL, resTrackQual, 0);
  }
  #[inline]
  pub fn add_courseDiff(&mut self, courseDiff: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_COURSEDIFF, courseDiff, 0);
  }
  #[inline]
  pub fn add_speedDiff(&mut self, speedDiff: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_SPEEDDIFF, speedDiff, 0);
  }
  #[inline]
  pub fn add_altDiff(&mut self, altDiff: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_ALTDIFF, altDiff, 0);
  }
  #[inline]
  pub fn add_minGeoPosQual(&mut self, minGeoPosQual: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_MINGEOPOSQUAL, minGeoPosQual, 0);
  }
  #[inline]
  pub fn add_maxGeoPosQual(&mut self, maxGeoPosQual: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_MAXGEOPOSQUAL, maxGeoPosQual, 0);
  }
  #[inline]
  pub fn add_decorrWinMult(&mut self, decorrWinMult: f64) {
    self.fbb_.push_slot::<f64>(DataLink_Full::VT_DECORRWINMULT, decorrWinMult, 0.0);
  }
  #[inline]
  pub fn add_consecDecorr(&mut self, consecDecorr: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_CONSECDECORR, consecDecorr, 0);
  }
  #[inline]
  pub fn add_multiDuty(&mut self, multiDuty: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_MULTIDUTY, multiDuty);
  }
  #[inline]
  pub fn add_ops(&mut self, ops: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_OPS, ops);
  }
  #[inline]
  pub fn add_jreUnitDes(&mut self, jreUnitDes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_JREUNITDES, jreUnitDes);
  }
  #[inline]
  pub fn add_jreCallSign(&mut self, jreCallSign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_JRECALLSIGN, jreCallSign);
  }
  #[inline]
  pub fn add_jrePriAdd(&mut self, jrePriAdd: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_JREPRIADD, jrePriAdd, 0);
  }
  #[inline]
  pub fn add_jreSecAdd(&mut self, jreSecAdd: i32) {
    self.fbb_.push_slot::<i32>(DataLink_Full::VT_JRESECADD, jreSecAdd, 0);
  }
  #[inline]
  pub fn add_jreDetails(&mut self, jreDetails: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_JREDETAILS, jreDetails);
  }
  #[inline]
  pub fn add_specTracks(&mut self, specTracks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_SPECTRACKS, specTracks);
  }
  #[inline]
  pub fn add_nonLinkUnitDes(&mut self, nonLinkUnitDes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_NONLINKUNITDES, nonLinkUnitDes);
  }
  #[inline]
  pub fn add_trackNumBlockLLs(&mut self, trackNumBlockLLs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_TRACKNUMBLOCKLLS, trackNumBlockLLs);
  }
  #[inline]
  pub fn add_trackNumBlocks(&mut self, trackNumBlocks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_TRACKNUMBLOCKS, trackNumBlocks);
  }
  #[inline]
  pub fn add_mgmtCode(&mut self, mgmtCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_MGMTCODE, mgmtCode);
  }
  #[inline]
  pub fn add_mgmtCodeMeaning(&mut self, mgmtCodeMeaning: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_MGMTCODEMEANING, mgmtCodeMeaning);
  }
  #[inline]
  pub fn add_ackReq(&mut self, ackReq: bool) {
    self.fbb_.push_slot::<bool>(DataLink_Full::VT_ACKREQ, ackReq, false);
  }
  #[inline]
  pub fn add_ackInstUnits(&mut self, ackInstUnits: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_ACKINSTUNITS, ackInstUnits);
  }
  #[inline]
  pub fn add_classSource(&mut self, classSource: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_CLASSSOURCE, classSource);
  }
  #[inline]
  pub fn add_classReasons(&mut self, classReasons: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_CLASSREASONS, classReasons);
  }
  #[inline]
  pub fn add_decInstDates(&mut self, decInstDates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_DECINSTDATES, decInstDates);
  }
  #[inline]
  pub fn add_decExemptCodes(&mut self, decExemptCodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_DECEXEMPTCODES, decExemptCodes);
  }
  #[inline]
  pub fn add_remarks(&mut self, remarks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_REMARKS, remarks);
  }
  #[inline]
  pub fn add_rawFileURI(&mut self, rawFileURI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_RAWFILEURI, rawFileURI);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataLink_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: DataLink_Full_dataMode_Enum) {
    self.fbb_.push_slot::<DataLink_Full_dataMode_Enum>(DataLink_Full::VT_DATAMODE, dataMode, DataLink_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataLink_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DataLink_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataLink_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataLink_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataLink_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("opExName", &self.opExName());
      ds.field("originator", &self.originator());
      ds.field("startTime", &self.startTime());
      ds.field("stopTime", &self.stopTime());
      ds.field("stopTimeMod", &self.stopTimeMod());
      ds.field("planOrigNum", &self.planOrigNum());
      ds.field("opExInfo", &self.opExInfo());
      ds.field("opExInfoAlt", &self.opExInfoAlt());
      ds.field("serialNum", &self.serialNum());
      ds.field("month", &self.month());
      ds.field("qualifier", &self.qualifier());
      ds.field("qualSN", &self.qualSN());
      ds.field("references", &self.references());
      ds.field("canxId", &self.canxId());
      ds.field("canxOriginator", &self.canxOriginator());
      ds.field("canxTs", &self.canxTs());
      ds.field("canxSerialNum", &self.canxSerialNum());
      ds.field("canxSpecialNotation", &self.canxSpecialNotation());
      ds.field("canxSICs", &self.canxSICs());
      ds.field("pocName", &self.pocName());
      ds.field("pocRank", &self.pocRank());
      ds.field("pocCallSign", &self.pocCallSign());
      ds.field("pocLocName", &self.pocLocName());
      ds.field("pocLat", &self.pocLat());
      ds.field("pocLon", &self.pocLon());
      ds.field("pocNums", &self.pocNums());
      ds.field("geoDatum", &self.geoDatum());
      ds.field("refPoints", &self.refPoints());
      ds.field("voiceCoord", &self.voiceCoord());
      ds.field("sysDefaultCode", &self.sysDefaultCode());
      ds.field("winSizeMult", &self.winSizeMult());
      ds.field("winSizeMin", &self.winSizeMin());
      ds.field("minTrackQual", &self.minTrackQual());
      ds.field("maxTrackQual", &self.maxTrackQual());
      ds.field("resTrackQual", &self.resTrackQual());
      ds.field("courseDiff", &self.courseDiff());
      ds.field("speedDiff", &self.speedDiff());
      ds.field("altDiff", &self.altDiff());
      ds.field("minGeoPosQual", &self.minGeoPosQual());
      ds.field("maxGeoPosQual", &self.maxGeoPosQual());
      ds.field("decorrWinMult", &self.decorrWinMult());
      ds.field("consecDecorr", &self.consecDecorr());
      ds.field("multiDuty", &self.multiDuty());
      ds.field("ops", &self.ops());
      ds.field("jreUnitDes", &self.jreUnitDes());
      ds.field("jreCallSign", &self.jreCallSign());
      ds.field("jrePriAdd", &self.jrePriAdd());
      ds.field("jreSecAdd", &self.jreSecAdd());
      ds.field("jreDetails", &self.jreDetails());
      ds.field("specTracks", &self.specTracks());
      ds.field("nonLinkUnitDes", &self.nonLinkUnitDes());
      ds.field("trackNumBlockLLs", &self.trackNumBlockLLs());
      ds.field("trackNumBlocks", &self.trackNumBlocks());
      ds.field("mgmtCode", &self.mgmtCode());
      ds.field("mgmtCodeMeaning", &self.mgmtCodeMeaning());
      ds.field("ackReq", &self.ackReq());
      ds.field("ackInstUnits", &self.ackInstUnits());
      ds.field("classSource", &self.classSource());
      ds.field("classReasons", &self.classReasons());
      ds.field("decInstDates", &self.decInstDates());
      ds.field("decExemptCodes", &self.decExemptCodes());
      ds.field("remarks", &self.remarks());
      ds.field("rawFileURI", &self.rawFileURI());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.field("sourceDL", &self.sourceDL());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DataLink_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub opExName: Option<String>,
  pub originator: Option<String>,
  pub startTime: Option<String>,
  pub stopTime: Option<String>,
  pub stopTimeMod: Option<String>,
  pub planOrigNum: Option<String>,
  pub opExInfo: Option<String>,
  pub opExInfoAlt: Option<String>,
  pub serialNum: Option<String>,
  pub month: Option<String>,
  pub qualifier: Option<String>,
  pub qualSN: i32,
  pub references: Option<Vec<String>>,
  pub canxId: Option<String>,
  pub canxOriginator: Option<String>,
  pub canxTs: Option<String>,
  pub canxSerialNum: Option<String>,
  pub canxSpecialNotation: Option<String>,
  pub canxSICs: Option<Vec<String>>,
  pub pocName: Option<String>,
  pub pocRank: Option<String>,
  pub pocCallSign: Option<String>,
  pub pocLocName: Option<String>,
  pub pocLat: f64,
  pub pocLon: f64,
  pub pocNums: Option<Vec<String>>,
  pub geoDatum: Option<String>,
  pub refPoints: Option<Vec<String>>,
  pub voiceCoord: Option<Vec<String>>,
  pub sysDefaultCode: Option<String>,
  pub winSizeMult: f64,
  pub winSizeMin: f64,
  pub minTrackQual: i32,
  pub maxTrackQual: i32,
  pub resTrackQual: i32,
  pub courseDiff: i32,
  pub speedDiff: i32,
  pub altDiff: i32,
  pub minGeoPosQual: i32,
  pub maxGeoPosQual: i32,
  pub decorrWinMult: f64,
  pub consecDecorr: i32,
  pub multiDuty: Option<Vec<String>>,
  pub ops: Option<Vec<String>>,
  pub jreUnitDes: Option<String>,
  pub jreCallSign: Option<String>,
  pub jrePriAdd: i32,
  pub jreSecAdd: i32,
  pub jreDetails: Option<String>,
  pub specTracks: Option<Vec<String>>,
  pub nonLinkUnitDes: Option<Vec<String>>,
  pub trackNumBlockLLs: Option<Vec<String>>,
  pub trackNumBlocks: Option<Vec<String>>,
  pub mgmtCode: Option<String>,
  pub mgmtCodeMeaning: Option<String>,
  pub ackReq: bool,
  pub ackInstUnits: Option<Vec<String>>,
  pub classSource: Option<String>,
  pub classReasons: Option<Vec<String>>,
  pub decInstDates: Option<Vec<String>>,
  pub decExemptCodes: Option<Vec<String>>,
  pub remarks: Option<Vec<String>>,
  pub rawFileURI: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
  pub sourceDL: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: DataLink_Full_dataMode_Enum,
}
impl Default for DataLink_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      opExName: None,
      originator: None,
      startTime: None,
      stopTime: None,
      stopTimeMod: None,
      planOrigNum: None,
      opExInfo: None,
      opExInfoAlt: None,
      serialNum: None,
      month: None,
      qualifier: None,
      qualSN: 0,
      references: None,
      canxId: None,
      canxOriginator: None,
      canxTs: None,
      canxSerialNum: None,
      canxSpecialNotation: None,
      canxSICs: None,
      pocName: None,
      pocRank: None,
      pocCallSign: None,
      pocLocName: None,
      pocLat: 0.0,
      pocLon: 0.0,
      pocNums: None,
      geoDatum: None,
      refPoints: None,
      voiceCoord: None,
      sysDefaultCode: None,
      winSizeMult: 0.0,
      winSizeMin: 0.0,
      minTrackQual: 0,
      maxTrackQual: 0,
      resTrackQual: 0,
      courseDiff: 0,
      speedDiff: 0,
      altDiff: 0,
      minGeoPosQual: 0,
      maxGeoPosQual: 0,
      decorrWinMult: 0.0,
      consecDecorr: 0,
      multiDuty: None,
      ops: None,
      jreUnitDes: None,
      jreCallSign: None,
      jrePriAdd: 0,
      jreSecAdd: 0,
      jreDetails: None,
      specTracks: None,
      nonLinkUnitDes: None,
      trackNumBlockLLs: None,
      trackNumBlocks: None,
      mgmtCode: None,
      mgmtCodeMeaning: None,
      ackReq: false,
      ackInstUnits: None,
      classSource: None,
      classReasons: None,
      decInstDates: None,
      decExemptCodes: None,
      remarks: None,
      rawFileURI: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: DataLink_Full_dataMode_Enum::REAL,
    }
  }
}
impl DataLink_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<DataLink_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let opExName = self.opExName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let originator = self.originator.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let startTime = self.startTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stopTime = self.stopTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stopTimeMod = self.stopTimeMod.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let planOrigNum = self.planOrigNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let opExInfo = self.opExInfo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let opExInfoAlt = self.opExInfoAlt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let serialNum = self.serialNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let month = self.month.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let qualifier = self.qualifier.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let qualSN = self.qualSN;
    let references = self.references.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let canxId = self.canxId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let canxOriginator = self.canxOriginator.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let canxTs = self.canxTs.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let canxSerialNum = self.canxSerialNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let canxSpecialNotation = self.canxSpecialNotation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let canxSICs = self.canxSICs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let pocName = self.pocName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pocRank = self.pocRank.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pocCallSign = self.pocCallSign.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pocLocName = self.pocLocName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pocLat = self.pocLat;
    let pocLon = self.pocLon;
    let pocNums = self.pocNums.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let geoDatum = self.geoDatum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let refPoints = self.refPoints.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let voiceCoord = self.voiceCoord.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let sysDefaultCode = self.sysDefaultCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let winSizeMult = self.winSizeMult;
    let winSizeMin = self.winSizeMin;
    let minTrackQual = self.minTrackQual;
    let maxTrackQual = self.maxTrackQual;
    let resTrackQual = self.resTrackQual;
    let courseDiff = self.courseDiff;
    let speedDiff = self.speedDiff;
    let altDiff = self.altDiff;
    let minGeoPosQual = self.minGeoPosQual;
    let maxGeoPosQual = self.maxGeoPosQual;
    let decorrWinMult = self.decorrWinMult;
    let consecDecorr = self.consecDecorr;
    let multiDuty = self.multiDuty.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ops = self.ops.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let jreUnitDes = self.jreUnitDes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let jreCallSign = self.jreCallSign.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let jrePriAdd = self.jrePriAdd;
    let jreSecAdd = self.jreSecAdd;
    let jreDetails = self.jreDetails.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let specTracks = self.specTracks.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let nonLinkUnitDes = self.nonLinkUnitDes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let trackNumBlockLLs = self.trackNumBlockLLs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let trackNumBlocks = self.trackNumBlocks.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let mgmtCode = self.mgmtCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mgmtCodeMeaning = self.mgmtCodeMeaning.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ackReq = self.ackReq;
    let ackInstUnits = self.ackInstUnits.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let classSource = self.classSource.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classReasons = self.classReasons.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let decInstDates = self.decInstDates.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let decExemptCodes = self.decExemptCodes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let remarks = self.remarks.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let rawFileURI = self.rawFileURI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    DataLink_Full::create(_fbb, &DataLink_FullArgs{
      id,
      classificationMarking,
      opExName,
      originator,
      startTime,
      stopTime,
      stopTimeMod,
      planOrigNum,
      opExInfo,
      opExInfoAlt,
      serialNum,
      month,
      qualifier,
      qualSN,
      references,
      canxId,
      canxOriginator,
      canxTs,
      canxSerialNum,
      canxSpecialNotation,
      canxSICs,
      pocName,
      pocRank,
      pocCallSign,
      pocLocName,
      pocLat,
      pocLon,
      pocNums,
      geoDatum,
      refPoints,
      voiceCoord,
      sysDefaultCode,
      winSizeMult,
      winSizeMin,
      minTrackQual,
      maxTrackQual,
      resTrackQual,
      courseDiff,
      speedDiff,
      altDiff,
      minGeoPosQual,
      maxGeoPosQual,
      decorrWinMult,
      consecDecorr,
      multiDuty,
      ops,
      jreUnitDes,
      jreCallSign,
      jrePriAdd,
      jreSecAdd,
      jreDetails,
      specTracks,
      nonLinkUnitDes,
      trackNumBlockLLs,
      trackNumBlocks,
      mgmtCode,
      mgmtCodeMeaning,
      ackReq,
      ackInstUnits,
      classSource,
      classReasons,
      decInstDates,
      decExemptCodes,
      remarks,
      rawFileURI,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      sourceDL,
      source,
      origin,
      origNetwork,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `DataLink_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_data_link_full_unchecked`.
pub fn root_as_data_link_full(buf: &[u8]) -> Result<DataLink_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<DataLink_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `DataLink_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_data_link_full_unchecked`.
pub fn size_prefixed_root_as_data_link_full(buf: &[u8]) -> Result<DataLink_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<DataLink_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `DataLink_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_data_link_full_unchecked`.
pub fn root_as_data_link_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<DataLink_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<DataLink_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `DataLink_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_data_link_full_unchecked`.
pub fn size_prefixed_root_as_data_link_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<DataLink_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<DataLink_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a DataLink_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `DataLink_Full`.
pub unsafe fn root_as_data_link_full_unchecked(buf: &[u8]) -> DataLink_Full {
  flatbuffers::root_unchecked::<DataLink_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed DataLink_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `DataLink_Full`.
pub unsafe fn size_prefixed_root_as_data_link_full_unchecked(buf: &[u8]) -> DataLink_Full {
  flatbuffers::size_prefixed_root_unchecked::<DataLink_Full>(buf)
}
pub const DATA_LINK_FULL_IDENTIFIER: &str = "DATA";

#[inline]
pub fn data_link_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, DATA_LINK_FULL_IDENTIFIER, false)
}

#[inline]
pub fn data_link_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, DATA_LINK_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_data_link_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<DataLink_Full<'a>>) {
  fbb.finish(root, Some(DATA_LINK_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_data_link_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<DataLink_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(DATA_LINK_FULL_IDENTIFIER));
}
