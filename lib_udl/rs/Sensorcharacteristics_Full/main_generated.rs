// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SENSORCHARACTERISTICS_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SENSORCHARACTERISTICS_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SENSORCHARACTERISTICS_FULL_DATA_MODE_ENUM: [Sensorcharacteristics_Full_dataMode_Enum; 4] = [
  Sensorcharacteristics_Full_dataMode_Enum::REAL,
  Sensorcharacteristics_Full_dataMode_Enum::TEST,
  Sensorcharacteristics_Full_dataMode_Enum::SIMULATED,
  Sensorcharacteristics_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Sensorcharacteristics_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Sensorcharacteristics_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Sensorcharacteristics_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Sensorcharacteristics_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Sensorcharacteristics_Full_dataMode_Enum {
    type Output = Sensorcharacteristics_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Sensorcharacteristics_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Sensorcharacteristics_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Sensorcharacteristics_Full_dataMode_Enum {}
pub enum Sensorcharacteristics_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Model representation of characteristics and capabilities of a sensor.
pub struct Sensorcharacteristics_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Sensorcharacteristics_Full<'a> {
  type Inner = Sensorcharacteristics_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Sensorcharacteristics_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_IDSENSOR: flatbuffers::VOffsetT = 6;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 8;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 10;
  pub const VT_AZIMUTHRATE: flatbuffers::VOffsetT = 12;
  pub const VT_ELEVATIONRATEGEOLM: flatbuffers::VOffsetT = 14;
  pub const VT_MINRANGELIMIT: flatbuffers::VOffsetT = 16;
  pub const VT_MAXRANGELIMIT: flatbuffers::VOffsetT = 18;
  pub const VT_LEFTCLOCKANGLE: flatbuffers::VOffsetT = 20;
  pub const VT_RIGHTCLOCKANGLE: flatbuffers::VOffsetT = 22;
  pub const VT_BORESIGHT: flatbuffers::VOffsetT = 24;
  pub const VT_BORESIGHTOFFANGLE: flatbuffers::VOffsetT = 26;
  pub const VT_NEGATIVERANGERATELIMIT: flatbuffers::VOffsetT = 28;
  pub const VT_POSITIVERANGERATELIMIT: flatbuffers::VOffsetT = 30;
  pub const VT_MAGNITUDELIMIT: flatbuffers::VOffsetT = 32;
  pub const VT_TRACKANGLE: flatbuffers::VOffsetT = 34;
  pub const VT_MINSIGNALNOISERATIO: flatbuffers::VOffsetT = 36;
  pub const VT_FANBEAMWIDTH: flatbuffers::VOffsetT = 38;
  pub const VT_TASKABLERANGE: flatbuffers::VOffsetT = 40;
  pub const VT_MAXOBSERVABLERANGE: flatbuffers::VOffsetT = 42;
  pub const VT_RADIOFREQUENCY: flatbuffers::VOffsetT = 44;
  pub const VT_RADARFREQUENCY: flatbuffers::VOffsetT = 46;
  pub const VT_TRANSMITPOWER: flatbuffers::VOffsetT = 48;
  pub const VT_HFOV: flatbuffers::VOffsetT = 50;
  pub const VT_VFOV: flatbuffers::VOffsetT = 52;
  pub const VT_HRESPIXELS: flatbuffers::VOffsetT = 54;
  pub const VT_VRESPIXELS: flatbuffers::VOffsetT = 56;
  pub const VT_BAND: flatbuffers::VOffsetT = 58;
  pub const VT_MAXDEVIATIONANGLE: flatbuffers::VOffsetT = 60;
  pub const VT_APERTURE: flatbuffers::VOffsetT = 62;
  pub const VT_LEFTGEOBELTLIMIT: flatbuffers::VOffsetT = 64;
  pub const VT_RIGHTGEOBELTLIMIT: flatbuffers::VOffsetT = 66;
  pub const VT_ASRSCANRATE: flatbuffers::VOffsetT = 68;
  pub const VT_K: flatbuffers::VOffsetT = 70;
  pub const VT_FOCALPOINT: flatbuffers::VOffsetT = 72;
  pub const VT_TOWERHEIGHT: flatbuffers::VOffsetT = 74;
  pub const VT_TRUENORTHCORRECTOR: flatbuffers::VOffsetT = 76;
  pub const VT_MAGDEC: flatbuffers::VOffsetT = 78;
  pub const VT_Z1MINRANGE: flatbuffers::VOffsetT = 80;
  pub const VT_Z2MINRANGE: flatbuffers::VOffsetT = 82;
  pub const VT_Z1MAXRANGE: flatbuffers::VOffsetT = 84;
  pub const VT_Z2MAXRANGE: flatbuffers::VOffsetT = 86;
  pub const VT_RADARMUR: flatbuffers::VOffsetT = 88;
  pub const VT_PROBFALSEALARM: flatbuffers::VOffsetT = 90;
  pub const VT_PRF: flatbuffers::VOffsetT = 92;
  pub const VT_RADARPULSEWIDTH: flatbuffers::VOffsetT = 94;
  pub const VT_NUMINTEGRATEDPULSES: flatbuffers::VOffsetT = 96;
  pub const VT_TRUETILT: flatbuffers::VOffsetT = 98;
  pub const VT_RADARMESSAGEFORMAT: flatbuffers::VOffsetT = 100;
  pub const VT_SYSTEMNOISETEMPERATURE: flatbuffers::VOffsetT = 102;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 104;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 106;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 108;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 110;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 112;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 114;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Sensorcharacteristics_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Sensorcharacteristics_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<Sensorcharacteristics_Full<'bldr>> {
    let mut builder = Sensorcharacteristics_FullBuilder::new(_fbb);
    builder.add_systemNoiseTemperature(args.systemNoiseTemperature);
    builder.add_trueTilt(args.trueTilt);
    builder.add_radarPulseWidth(args.radarPulseWidth);
    builder.add_prf(args.prf);
    builder.add_probFalseAlarm(args.probFalseAlarm);
    builder.add_radarMUR(args.radarMUR);
    builder.add_z2MaxRange(args.z2MaxRange);
    builder.add_z1MaxRange(args.z1MaxRange);
    builder.add_z2MinRange(args.z2MinRange);
    builder.add_z1MinRange(args.z1MinRange);
    builder.add_magDec(args.magDec);
    builder.add_towerHeight(args.towerHeight);
    builder.add_focalPoint(args.focalPoint);
    builder.add_k(args.k);
    builder.add_asrScanRate(args.asrScanRate);
    builder.add_rightGeoBeltLimit(args.rightGeoBeltLimit);
    builder.add_leftGeoBeltLimit(args.leftGeoBeltLimit);
    builder.add_aperture(args.aperture);
    builder.add_maxDeviationAngle(args.maxDeviationAngle);
    builder.add_vFOV(args.vFOV);
    builder.add_hFOV(args.hFOV);
    builder.add_transmitPower(args.transmitPower);
    builder.add_radarFrequency(args.radarFrequency);
    builder.add_radioFrequency(args.radioFrequency);
    builder.add_maxObservableRange(args.maxObservableRange);
    builder.add_taskableRange(args.taskableRange);
    builder.add_fanBeamWidth(args.fanBeamWidth);
    builder.add_minSignalNoiseRatio(args.minSignalNoiseRatio);
    builder.add_trackAngle(args.trackAngle);
    builder.add_magnitudeLimit(args.magnitudeLimit);
    builder.add_positiveRangeRateLimit(args.positiveRangeRateLimit);
    builder.add_negativeRangeRateLimit(args.negativeRangeRateLimit);
    builder.add_boresightOffAngle(args.boresightOffAngle);
    builder.add_boresight(args.boresight);
    builder.add_rightClockAngle(args.rightClockAngle);
    builder.add_leftClockAngle(args.leftClockAngle);
    builder.add_maxRangeLimit(args.maxRangeLimit);
    builder.add_minRangeLimit(args.minRangeLimit);
    builder.add_elevationRateGeolm(args.elevationRateGeolm);
    builder.add_azimuthRate(args.azimuthRate);
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.radarMessageFormat { builder.add_radarMessageFormat(x); }
    builder.add_numIntegratedPulses(args.numIntegratedPulses);
    builder.add_trueNorthCorrector(args.trueNorthCorrector);
    if let Some(x) = args.band { builder.add_band(x); }
    builder.add_vResPixels(args.vResPixels);
    builder.add_hResPixels(args.hResPixels);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.idSensor { builder.add_idSensor(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> Sensorcharacteristics_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let idSensor = self.idSensor().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let azimuthRate = self.azimuthRate();
    let elevationRateGeolm = self.elevationRateGeolm();
    let minRangeLimit = self.minRangeLimit();
    let maxRangeLimit = self.maxRangeLimit();
    let leftClockAngle = self.leftClockAngle();
    let rightClockAngle = self.rightClockAngle();
    let boresight = self.boresight();
    let boresightOffAngle = self.boresightOffAngle();
    let negativeRangeRateLimit = self.negativeRangeRateLimit();
    let positiveRangeRateLimit = self.positiveRangeRateLimit();
    let magnitudeLimit = self.magnitudeLimit();
    let trackAngle = self.trackAngle();
    let minSignalNoiseRatio = self.minSignalNoiseRatio();
    let fanBeamWidth = self.fanBeamWidth();
    let taskableRange = self.taskableRange();
    let maxObservableRange = self.maxObservableRange();
    let radioFrequency = self.radioFrequency();
    let radarFrequency = self.radarFrequency();
    let transmitPower = self.transmitPower();
    let hFOV = self.hFOV();
    let vFOV = self.vFOV();
    let hResPixels = self.hResPixels();
    let vResPixels = self.vResPixels();
    let band = self.band().map(|x| {
      x.to_string()
    });
    let maxDeviationAngle = self.maxDeviationAngle();
    let aperture = self.aperture();
    let leftGeoBeltLimit = self.leftGeoBeltLimit();
    let rightGeoBeltLimit = self.rightGeoBeltLimit();
    let asrScanRate = self.asrScanRate();
    let k = self.k();
    let focalPoint = self.focalPoint();
    let towerHeight = self.towerHeight();
    let trueNorthCorrector = self.trueNorthCorrector();
    let magDec = self.magDec();
    let z1MinRange = self.z1MinRange();
    let z2MinRange = self.z2MinRange();
    let z1MaxRange = self.z1MaxRange();
    let z2MaxRange = self.z2MaxRange();
    let radarMUR = self.radarMUR();
    let probFalseAlarm = self.probFalseAlarm();
    let prf = self.prf();
    let radarPulseWidth = self.radarPulseWidth();
    let numIntegratedPulses = self.numIntegratedPulses();
    let trueTilt = self.trueTilt();
    let radarMessageFormat = self.radarMessageFormat().map(|x| {
      x.to_string()
    });
    let systemNoiseTemperature = self.systemNoiseTemperature();
    let source = self.source().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    Sensorcharacteristics_FullT {
      id,
      idSensor,
      classificationMarking,
      origNetwork,
      azimuthRate,
      elevationRateGeolm,
      minRangeLimit,
      maxRangeLimit,
      leftClockAngle,
      rightClockAngle,
      boresight,
      boresightOffAngle,
      negativeRangeRateLimit,
      positiveRangeRateLimit,
      magnitudeLimit,
      trackAngle,
      minSignalNoiseRatio,
      fanBeamWidth,
      taskableRange,
      maxObservableRange,
      radioFrequency,
      radarFrequency,
      transmitPower,
      hFOV,
      vFOV,
      hResPixels,
      vResPixels,
      band,
      maxDeviationAngle,
      aperture,
      leftGeoBeltLimit,
      rightGeoBeltLimit,
      asrScanRate,
      k,
      focalPoint,
      towerHeight,
      trueNorthCorrector,
      magDec,
      z1MinRange,
      z2MinRange,
      z1MaxRange,
      z2MaxRange,
      radarMUR,
      probFalseAlarm,
      prf,
      radarPulseWidth,
      numIntegratedPulses,
      trueTilt,
      radarMessageFormat,
      systemNoiseTemperature,
      source,
      dataMode,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: SENSORCHARACTERISTICS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensorcharacteristics_Full::VT_ID, None)}
  }
  /// Unique identifier of the parent sensor.
  /// Example: /// Example: SENSOR-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn idSensor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensorcharacteristics_Full::VT_IDSENSOR, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensorcharacteristics_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensorcharacteristics_Full::VT_ORIGNETWORK, None)}
  }
  /// Azimuth rate acquisition limit (rad/min).
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn azimuthRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_AZIMUTHRATE, Some(0.0)).unwrap()}
  }
  /// Elevation rate acquisition limit (rad/min).
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevationRateGeolm(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_ELEVATIONRATEGEOLM, Some(0.0)).unwrap()}
  }
  /// Minimum range measurement capability of the sensor (km).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn minRangeLimit(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_MINRANGELIMIT, Some(0.0)).unwrap()}
  }
  /// Maximum observable range limit (km) -- sensor cannot acquire beyond this range.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxRangeLimit(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_MAXRANGELIMIT, Some(0.0)).unwrap()}
  }
  /// For Orbiting Sensors, First Card Azimuth limit #1 (left, deg).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn leftClockAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_LEFTCLOCKANGLE, Some(0.0)).unwrap()}
  }
  /// For Orbiting Sensors, First Card Azimuth limit #3 (left, deg).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rightClockAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_RIGHTCLOCKANGLE, Some(0.0)).unwrap()}
  }
  /// The angle of the center of a phased array sensor.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn boresight(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_BORESIGHT, Some(0.0)).unwrap()}
  }
  /// The number of degrees off of the boresight for the sensor (degrees).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn boresightOffAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_BORESIGHTOFFANGLE, Some(0.0)).unwrap()}
  }
  /// Negative Range-rate/relative velocity limit (km/sec).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn negativeRangeRateLimit(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_NEGATIVERANGERATELIMIT, Some(0.0)).unwrap()}
  }
  /// Positive Range-rate/relative velocity limit (km/sec).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn positiveRangeRateLimit(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_POSITIVERANGERATELIMIT, Some(0.0)).unwrap()}
  }
  /// Absolute magnitude acquisition limit for optical sensors.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn magnitudeLimit(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_MAGNITUDELIMIT, Some(0.0)).unwrap()}
  }
  /// Beginning track angle limit (rad). Track angle is the angle between the camera axis and the gimbal plane. Values range from 0 - PI/2.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trackAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_TRACKANGLE, Some(0.0)).unwrap()}
  }
  /// Signal to Noise Ratio (in db). The values for this range from 0.0 - + 99.99 dB.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn minSignalNoiseRatio(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_MINSIGNALNOISERATIO, Some(0.0)).unwrap()}
  }
  /// The beam width of a Sensor's Fan (range). The values for this range from (0.0 to PI).
  /// Example: /// Example: 3.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fanBeamWidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_FANBEAMWIDTH, Some(0.0)).unwrap()}
  }
  /// Maximum taskable range of the sensor (km).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taskableRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_TASKABLERANGE, Some(0.0)).unwrap()}
  }
  /// Maximum observable sensor range (km).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxObservableRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_MAXOBSERVABLERANGE, Some(0.0)).unwrap()}
  }
  /// Radio frequency (if sensor is RF).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radioFrequency(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_RADIOFREQUENCY, Some(0.0)).unwrap()}
  }
  /// Radar frequency of the sensor (if a radar sensor).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radarFrequency(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_RADARFREQUENCY, Some(0.0)).unwrap()}
  }
  /// Radar transmit power in Watts.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn transmitPower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_TRANSMITPOWER, Some(0.0)).unwrap()}
  }
  /// Horizontal field of view.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hFOV(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_HFOV, Some(0.0)).unwrap()}
  }
  /// Vertical field of view.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vFOV(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_VFOV, Some(0.0)).unwrap()}
  }
  /// Horizontal pixel resolution.
  /// Example: /// Example: 1000
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hResPixels(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Sensorcharacteristics_Full::VT_HRESPIXELS, Some(0)).unwrap()}
  }
  /// Vertical pixel resolution.
  /// Example: /// Example: 1000
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vResPixels(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Sensorcharacteristics_Full::VT_VRESPIXELS, Some(0)).unwrap()}
  }
  /// Sensor band.
  /// Example: /// Example: BAND
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn band(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensorcharacteristics_Full::VT_BAND, None)}
  }
  /// Max deviation angle of the sensor in degrees.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxDeviationAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_MAXDEVIATIONANGLE, Some(0.0)).unwrap()}
  }
  /// Optical sensor camera aperture.
  /// Example: /// Example: 2.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn aperture(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_APERTURE, Some(0.0)).unwrap()}
  }
  /// Leftmost GEO belt longitude limit for this sensor (if applicable).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn leftGeoBeltLimit(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_LEFTGEOBELTLIMIT, Some(0.0)).unwrap()}
  }
  /// Rightmost GEO belt longitude limit for this sensor (if applicable).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rightGeoBeltLimit(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_RIGHTGEOBELTLIMIT, Some(0.0)).unwrap()}
  }
  /// For ASR (Air Surveillance Radar) sensors, the scan (360 deg sweep) rate of the radar, in scans/minute.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn asrScanRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_ASRSCANRATE, Some(0.0)).unwrap()}
  }
  /// For radar based sensors, K-factor is a relative indicator of refractivity that infers the amount of radar beam bending due to atmosphere. (1<K<2).
  /// Example: /// Example: 1.4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn k(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_K, Some(0.0)).unwrap()}
  }
  /// For radar based sensors, the focal point elevation of the radar at the site, in meters.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn focalPoint(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_FOCALPOINT, Some(0.0)).unwrap()}
  }
  /// For tower sensors, the physical height of the sensor tower, in meters.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn towerHeight(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_TOWERHEIGHT, Some(0.0)).unwrap()}
  }
  /// True North correction for the sensor, in ACP (Azimunth Change Pulse) count.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trueNorthCorrector(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Sensorcharacteristics_Full::VT_TRUENORTHCORRECTOR, Some(0)).unwrap()}
  }
  /// Angle between magnetic north and true north at the sensor site, in degrees.
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn magDec(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_MAGDEC, Some(0.0)).unwrap()}
  }
  /// Peformance zone-1 minimum range, in km. Note that the zones apply only to the PSR/Search radars.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn z1MinRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_Z1MINRANGE, Some(0.0)).unwrap()}
  }
  /// Peformance zone-2 minimum range, in km. Note that the zones apply only to the PSR/Search radars.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn z2MinRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_Z2MINRANGE, Some(0.0)).unwrap()}
  }
  /// Peformance zone-1 maximum range, in km. Note that the zones apply only to the PSR/Search radars.
  /// Example: /// Example: 50.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn z1MaxRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_Z1MAXRANGE, Some(0.0)).unwrap()}
  }
  /// Peformance zone-2 maximum range, in km. Note that the zones apply only to the PSR/Search radars.
  /// Example: /// Example: 50.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn z2MaxRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_Z2MAXRANGE, Some(0.0)).unwrap()}
  }
  /// For radar based sensors, radar maximum unambiguous range, in km.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radarMUR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_RADARMUR, Some(0.0)).unwrap()}
  }
  /// For radar based sensors, probability of the indication of the presence of a radar target due to noise or interference.
  /// Example: /// Example: 0.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn probFalseAlarm(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_PROBFALSEALARM, Some(0.0)).unwrap()}
  }
  /// For radar based sensors, pulse repetition frequency, in Hz. Number of new pulses tranmistted per second.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn prf(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_PRF, Some(0.0)).unwrap()}
  }
  /// For radar based sensors, radar pulse width, in microseconds. The transmit time of a pulse.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radarPulseWidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_RADARPULSEWIDTH, Some(0.0)).unwrap()}
  }
  /// For radar based sensors, number of integrated pulses in a transmit cycle.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numIntegratedPulses(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Sensorcharacteristics_Full::VT_NUMINTEGRATEDPULSES, Some(0)).unwrap()}
  }
  /// Antenna true tilt, in degrees.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trueTilt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_TRUETILT, Some(0.0)).unwrap()}
  }
  /// Message data format transmitted by the sensor digitizer.
  /// Example: /// Example: DATA_FORMAT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn radarMessageFormat(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensorcharacteristics_Full::VT_RADARMESSAGEFORMAT, None)}
  }
  /// For radar based sensors, expression of the radar system noise, aggregated as an equivalent thermal noise value, in degrees Kelvin.
  /// Example: /// Example: 3.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn systemNoiseTemperature(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Sensorcharacteristics_Full::VT_SYSTEMNOISETEMPERATURE, Some(0.0)).unwrap()}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensorcharacteristics_Full::VT_SOURCE, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> Sensorcharacteristics_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Sensorcharacteristics_Full_dataMode_Enum>(Sensorcharacteristics_Full::VT_DATAMODE, Some(Sensorcharacteristics_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensorcharacteristics_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensorcharacteristics_Full::VT_CREATEDBY, None)}
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensorcharacteristics_Full::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensorcharacteristics_Full::VT_UPDATEDBY, None)}
  }
}

impl flatbuffers::Verifiable for Sensorcharacteristics_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor", Self::VT_IDSENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<f64>("azimuthRate", Self::VT_AZIMUTHRATE, false)?
     .visit_field::<f64>("elevationRateGeolm", Self::VT_ELEVATIONRATEGEOLM, false)?
     .visit_field::<f64>("minRangeLimit", Self::VT_MINRANGELIMIT, false)?
     .visit_field::<f64>("maxRangeLimit", Self::VT_MAXRANGELIMIT, false)?
     .visit_field::<f64>("leftClockAngle", Self::VT_LEFTCLOCKANGLE, false)?
     .visit_field::<f64>("rightClockAngle", Self::VT_RIGHTCLOCKANGLE, false)?
     .visit_field::<f64>("boresight", Self::VT_BORESIGHT, false)?
     .visit_field::<f64>("boresightOffAngle", Self::VT_BORESIGHTOFFANGLE, false)?
     .visit_field::<f64>("negativeRangeRateLimit", Self::VT_NEGATIVERANGERATELIMIT, false)?
     .visit_field::<f64>("positiveRangeRateLimit", Self::VT_POSITIVERANGERATELIMIT, false)?
     .visit_field::<f64>("magnitudeLimit", Self::VT_MAGNITUDELIMIT, false)?
     .visit_field::<f64>("trackAngle", Self::VT_TRACKANGLE, false)?
     .visit_field::<f64>("minSignalNoiseRatio", Self::VT_MINSIGNALNOISERATIO, false)?
     .visit_field::<f64>("fanBeamWidth", Self::VT_FANBEAMWIDTH, false)?
     .visit_field::<f64>("taskableRange", Self::VT_TASKABLERANGE, false)?
     .visit_field::<f64>("maxObservableRange", Self::VT_MAXOBSERVABLERANGE, false)?
     .visit_field::<f64>("radioFrequency", Self::VT_RADIOFREQUENCY, false)?
     .visit_field::<f64>("radarFrequency", Self::VT_RADARFREQUENCY, false)?
     .visit_field::<f64>("transmitPower", Self::VT_TRANSMITPOWER, false)?
     .visit_field::<f64>("hFOV", Self::VT_HFOV, false)?
     .visit_field::<f64>("vFOV", Self::VT_VFOV, false)?
     .visit_field::<i32>("hResPixels", Self::VT_HRESPIXELS, false)?
     .visit_field::<i32>("vResPixels", Self::VT_VRESPIXELS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("band", Self::VT_BAND, false)?
     .visit_field::<f64>("maxDeviationAngle", Self::VT_MAXDEVIATIONANGLE, false)?
     .visit_field::<f64>("aperture", Self::VT_APERTURE, false)?
     .visit_field::<f64>("leftGeoBeltLimit", Self::VT_LEFTGEOBELTLIMIT, false)?
     .visit_field::<f64>("rightGeoBeltLimit", Self::VT_RIGHTGEOBELTLIMIT, false)?
     .visit_field::<f64>("asrScanRate", Self::VT_ASRSCANRATE, false)?
     .visit_field::<f64>("k", Self::VT_K, false)?
     .visit_field::<f64>("focalPoint", Self::VT_FOCALPOINT, false)?
     .visit_field::<f64>("towerHeight", Self::VT_TOWERHEIGHT, false)?
     .visit_field::<i32>("trueNorthCorrector", Self::VT_TRUENORTHCORRECTOR, false)?
     .visit_field::<f64>("magDec", Self::VT_MAGDEC, false)?
     .visit_field::<f64>("z1MinRange", Self::VT_Z1MINRANGE, false)?
     .visit_field::<f64>("z2MinRange", Self::VT_Z2MINRANGE, false)?
     .visit_field::<f64>("z1MaxRange", Self::VT_Z1MAXRANGE, false)?
     .visit_field::<f64>("z2MaxRange", Self::VT_Z2MAXRANGE, false)?
     .visit_field::<f64>("radarMUR", Self::VT_RADARMUR, false)?
     .visit_field::<f64>("probFalseAlarm", Self::VT_PROBFALSEALARM, false)?
     .visit_field::<f64>("prf", Self::VT_PRF, false)?
     .visit_field::<f64>("radarPulseWidth", Self::VT_RADARPULSEWIDTH, false)?
     .visit_field::<i32>("numIntegratedPulses", Self::VT_NUMINTEGRATEDPULSES, false)?
     .visit_field::<f64>("trueTilt", Self::VT_TRUETILT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("radarMessageFormat", Self::VT_RADARMESSAGEFORMAT, false)?
     .visit_field::<f64>("systemNoiseTemperature", Self::VT_SYSTEMNOISETEMPERATURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<Sensorcharacteristics_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .finish();
    Ok(())
  }
}
pub struct Sensorcharacteristics_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub azimuthRate: f64,
    pub elevationRateGeolm: f64,
    pub minRangeLimit: f64,
    pub maxRangeLimit: f64,
    pub leftClockAngle: f64,
    pub rightClockAngle: f64,
    pub boresight: f64,
    pub boresightOffAngle: f64,
    pub negativeRangeRateLimit: f64,
    pub positiveRangeRateLimit: f64,
    pub magnitudeLimit: f64,
    pub trackAngle: f64,
    pub minSignalNoiseRatio: f64,
    pub fanBeamWidth: f64,
    pub taskableRange: f64,
    pub maxObservableRange: f64,
    pub radioFrequency: f64,
    pub radarFrequency: f64,
    pub transmitPower: f64,
    pub hFOV: f64,
    pub vFOV: f64,
    pub hResPixels: i32,
    pub vResPixels: i32,
    pub band: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maxDeviationAngle: f64,
    pub aperture: f64,
    pub leftGeoBeltLimit: f64,
    pub rightGeoBeltLimit: f64,
    pub asrScanRate: f64,
    pub k: f64,
    pub focalPoint: f64,
    pub towerHeight: f64,
    pub trueNorthCorrector: i32,
    pub magDec: f64,
    pub z1MinRange: f64,
    pub z2MinRange: f64,
    pub z1MaxRange: f64,
    pub z2MaxRange: f64,
    pub radarMUR: f64,
    pub probFalseAlarm: f64,
    pub prf: f64,
    pub radarPulseWidth: f64,
    pub numIntegratedPulses: i32,
    pub trueTilt: f64,
    pub radarMessageFormat: Option<flatbuffers::WIPOffset<&'a str>>,
    pub systemNoiseTemperature: f64,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: Sensorcharacteristics_Full_dataMode_Enum,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Sensorcharacteristics_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    Sensorcharacteristics_FullArgs {
      id: None,
      idSensor: None,
      classificationMarking: None,
      origNetwork: None,
      azimuthRate: 0.0,
      elevationRateGeolm: 0.0,
      minRangeLimit: 0.0,
      maxRangeLimit: 0.0,
      leftClockAngle: 0.0,
      rightClockAngle: 0.0,
      boresight: 0.0,
      boresightOffAngle: 0.0,
      negativeRangeRateLimit: 0.0,
      positiveRangeRateLimit: 0.0,
      magnitudeLimit: 0.0,
      trackAngle: 0.0,
      minSignalNoiseRatio: 0.0,
      fanBeamWidth: 0.0,
      taskableRange: 0.0,
      maxObservableRange: 0.0,
      radioFrequency: 0.0,
      radarFrequency: 0.0,
      transmitPower: 0.0,
      hFOV: 0.0,
      vFOV: 0.0,
      hResPixels: 0,
      vResPixels: 0,
      band: None,
      maxDeviationAngle: 0.0,
      aperture: 0.0,
      leftGeoBeltLimit: 0.0,
      rightGeoBeltLimit: 0.0,
      asrScanRate: 0.0,
      k: 0.0,
      focalPoint: 0.0,
      towerHeight: 0.0,
      trueNorthCorrector: 0,
      magDec: 0.0,
      z1MinRange: 0.0,
      z2MinRange: 0.0,
      z1MaxRange: 0.0,
      z2MaxRange: 0.0,
      radarMUR: 0.0,
      probFalseAlarm: 0.0,
      prf: 0.0,
      radarPulseWidth: 0.0,
      numIntegratedPulses: 0,
      trueTilt: 0.0,
      radarMessageFormat: None,
      systemNoiseTemperature: 0.0,
      source: None,
      dataMode: Sensorcharacteristics_Full_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
    }
  }
}

pub struct Sensorcharacteristics_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Sensorcharacteristics_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensorcharacteristics_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_idSensor(&mut self, idSensor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensorcharacteristics_Full::VT_IDSENSOR, idSensor);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensorcharacteristics_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensorcharacteristics_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_azimuthRate(&mut self, azimuthRate: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_AZIMUTHRATE, azimuthRate, 0.0);
  }
  #[inline]
  pub fn add_elevationRateGeolm(&mut self, elevationRateGeolm: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_ELEVATIONRATEGEOLM, elevationRateGeolm, 0.0);
  }
  #[inline]
  pub fn add_minRangeLimit(&mut self, minRangeLimit: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_MINRANGELIMIT, minRangeLimit, 0.0);
  }
  #[inline]
  pub fn add_maxRangeLimit(&mut self, maxRangeLimit: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_MAXRANGELIMIT, maxRangeLimit, 0.0);
  }
  #[inline]
  pub fn add_leftClockAngle(&mut self, leftClockAngle: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_LEFTCLOCKANGLE, leftClockAngle, 0.0);
  }
  #[inline]
  pub fn add_rightClockAngle(&mut self, rightClockAngle: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_RIGHTCLOCKANGLE, rightClockAngle, 0.0);
  }
  #[inline]
  pub fn add_boresight(&mut self, boresight: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_BORESIGHT, boresight, 0.0);
  }
  #[inline]
  pub fn add_boresightOffAngle(&mut self, boresightOffAngle: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_BORESIGHTOFFANGLE, boresightOffAngle, 0.0);
  }
  #[inline]
  pub fn add_negativeRangeRateLimit(&mut self, negativeRangeRateLimit: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_NEGATIVERANGERATELIMIT, negativeRangeRateLimit, 0.0);
  }
  #[inline]
  pub fn add_positiveRangeRateLimit(&mut self, positiveRangeRateLimit: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_POSITIVERANGERATELIMIT, positiveRangeRateLimit, 0.0);
  }
  #[inline]
  pub fn add_magnitudeLimit(&mut self, magnitudeLimit: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_MAGNITUDELIMIT, magnitudeLimit, 0.0);
  }
  #[inline]
  pub fn add_trackAngle(&mut self, trackAngle: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_TRACKANGLE, trackAngle, 0.0);
  }
  #[inline]
  pub fn add_minSignalNoiseRatio(&mut self, minSignalNoiseRatio: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_MINSIGNALNOISERATIO, minSignalNoiseRatio, 0.0);
  }
  #[inline]
  pub fn add_fanBeamWidth(&mut self, fanBeamWidth: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_FANBEAMWIDTH, fanBeamWidth, 0.0);
  }
  #[inline]
  pub fn add_taskableRange(&mut self, taskableRange: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_TASKABLERANGE, taskableRange, 0.0);
  }
  #[inline]
  pub fn add_maxObservableRange(&mut self, maxObservableRange: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_MAXOBSERVABLERANGE, maxObservableRange, 0.0);
  }
  #[inline]
  pub fn add_radioFrequency(&mut self, radioFrequency: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_RADIOFREQUENCY, radioFrequency, 0.0);
  }
  #[inline]
  pub fn add_radarFrequency(&mut self, radarFrequency: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_RADARFREQUENCY, radarFrequency, 0.0);
  }
  #[inline]
  pub fn add_transmitPower(&mut self, transmitPower: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_TRANSMITPOWER, transmitPower, 0.0);
  }
  #[inline]
  pub fn add_hFOV(&mut self, hFOV: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_HFOV, hFOV, 0.0);
  }
  #[inline]
  pub fn add_vFOV(&mut self, vFOV: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_VFOV, vFOV, 0.0);
  }
  #[inline]
  pub fn add_hResPixels(&mut self, hResPixels: i32) {
    self.fbb_.push_slot::<i32>(Sensorcharacteristics_Full::VT_HRESPIXELS, hResPixels, 0);
  }
  #[inline]
  pub fn add_vResPixels(&mut self, vResPixels: i32) {
    self.fbb_.push_slot::<i32>(Sensorcharacteristics_Full::VT_VRESPIXELS, vResPixels, 0);
  }
  #[inline]
  pub fn add_band(&mut self, band: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensorcharacteristics_Full::VT_BAND, band);
  }
  #[inline]
  pub fn add_maxDeviationAngle(&mut self, maxDeviationAngle: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_MAXDEVIATIONANGLE, maxDeviationAngle, 0.0);
  }
  #[inline]
  pub fn add_aperture(&mut self, aperture: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_APERTURE, aperture, 0.0);
  }
  #[inline]
  pub fn add_leftGeoBeltLimit(&mut self, leftGeoBeltLimit: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_LEFTGEOBELTLIMIT, leftGeoBeltLimit, 0.0);
  }
  #[inline]
  pub fn add_rightGeoBeltLimit(&mut self, rightGeoBeltLimit: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_RIGHTGEOBELTLIMIT, rightGeoBeltLimit, 0.0);
  }
  #[inline]
  pub fn add_asrScanRate(&mut self, asrScanRate: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_ASRSCANRATE, asrScanRate, 0.0);
  }
  #[inline]
  pub fn add_k(&mut self, k: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_K, k, 0.0);
  }
  #[inline]
  pub fn add_focalPoint(&mut self, focalPoint: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_FOCALPOINT, focalPoint, 0.0);
  }
  #[inline]
  pub fn add_towerHeight(&mut self, towerHeight: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_TOWERHEIGHT, towerHeight, 0.0);
  }
  #[inline]
  pub fn add_trueNorthCorrector(&mut self, trueNorthCorrector: i32) {
    self.fbb_.push_slot::<i32>(Sensorcharacteristics_Full::VT_TRUENORTHCORRECTOR, trueNorthCorrector, 0);
  }
  #[inline]
  pub fn add_magDec(&mut self, magDec: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_MAGDEC, magDec, 0.0);
  }
  #[inline]
  pub fn add_z1MinRange(&mut self, z1MinRange: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_Z1MINRANGE, z1MinRange, 0.0);
  }
  #[inline]
  pub fn add_z2MinRange(&mut self, z2MinRange: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_Z2MINRANGE, z2MinRange, 0.0);
  }
  #[inline]
  pub fn add_z1MaxRange(&mut self, z1MaxRange: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_Z1MAXRANGE, z1MaxRange, 0.0);
  }
  #[inline]
  pub fn add_z2MaxRange(&mut self, z2MaxRange: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_Z2MAXRANGE, z2MaxRange, 0.0);
  }
  #[inline]
  pub fn add_radarMUR(&mut self, radarMUR: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_RADARMUR, radarMUR, 0.0);
  }
  #[inline]
  pub fn add_probFalseAlarm(&mut self, probFalseAlarm: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_PROBFALSEALARM, probFalseAlarm, 0.0);
  }
  #[inline]
  pub fn add_prf(&mut self, prf: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_PRF, prf, 0.0);
  }
  #[inline]
  pub fn add_radarPulseWidth(&mut self, radarPulseWidth: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_RADARPULSEWIDTH, radarPulseWidth, 0.0);
  }
  #[inline]
  pub fn add_numIntegratedPulses(&mut self, numIntegratedPulses: i32) {
    self.fbb_.push_slot::<i32>(Sensorcharacteristics_Full::VT_NUMINTEGRATEDPULSES, numIntegratedPulses, 0);
  }
  #[inline]
  pub fn add_trueTilt(&mut self, trueTilt: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_TRUETILT, trueTilt, 0.0);
  }
  #[inline]
  pub fn add_radarMessageFormat(&mut self, radarMessageFormat: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensorcharacteristics_Full::VT_RADARMESSAGEFORMAT, radarMessageFormat);
  }
  #[inline]
  pub fn add_systemNoiseTemperature(&mut self, systemNoiseTemperature: f64) {
    self.fbb_.push_slot::<f64>(Sensorcharacteristics_Full::VT_SYSTEMNOISETEMPERATURE, systemNoiseTemperature, 0.0);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensorcharacteristics_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Sensorcharacteristics_Full_dataMode_Enum) {
    self.fbb_.push_slot::<Sensorcharacteristics_Full_dataMode_Enum>(Sensorcharacteristics_Full::VT_DATAMODE, dataMode, Sensorcharacteristics_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensorcharacteristics_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensorcharacteristics_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensorcharacteristics_Full::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensorcharacteristics_Full::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Sensorcharacteristics_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Sensorcharacteristics_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Sensorcharacteristics_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Sensorcharacteristics_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Sensorcharacteristics_Full");
      ds.field("id", &self.id());
      ds.field("idSensor", &self.idSensor());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("azimuthRate", &self.azimuthRate());
      ds.field("elevationRateGeolm", &self.elevationRateGeolm());
      ds.field("minRangeLimit", &self.minRangeLimit());
      ds.field("maxRangeLimit", &self.maxRangeLimit());
      ds.field("leftClockAngle", &self.leftClockAngle());
      ds.field("rightClockAngle", &self.rightClockAngle());
      ds.field("boresight", &self.boresight());
      ds.field("boresightOffAngle", &self.boresightOffAngle());
      ds.field("negativeRangeRateLimit", &self.negativeRangeRateLimit());
      ds.field("positiveRangeRateLimit", &self.positiveRangeRateLimit());
      ds.field("magnitudeLimit", &self.magnitudeLimit());
      ds.field("trackAngle", &self.trackAngle());
      ds.field("minSignalNoiseRatio", &self.minSignalNoiseRatio());
      ds.field("fanBeamWidth", &self.fanBeamWidth());
      ds.field("taskableRange", &self.taskableRange());
      ds.field("maxObservableRange", &self.maxObservableRange());
      ds.field("radioFrequency", &self.radioFrequency());
      ds.field("radarFrequency", &self.radarFrequency());
      ds.field("transmitPower", &self.transmitPower());
      ds.field("hFOV", &self.hFOV());
      ds.field("vFOV", &self.vFOV());
      ds.field("hResPixels", &self.hResPixels());
      ds.field("vResPixels", &self.vResPixels());
      ds.field("band", &self.band());
      ds.field("maxDeviationAngle", &self.maxDeviationAngle());
      ds.field("aperture", &self.aperture());
      ds.field("leftGeoBeltLimit", &self.leftGeoBeltLimit());
      ds.field("rightGeoBeltLimit", &self.rightGeoBeltLimit());
      ds.field("asrScanRate", &self.asrScanRate());
      ds.field("k", &self.k());
      ds.field("focalPoint", &self.focalPoint());
      ds.field("towerHeight", &self.towerHeight());
      ds.field("trueNorthCorrector", &self.trueNorthCorrector());
      ds.field("magDec", &self.magDec());
      ds.field("z1MinRange", &self.z1MinRange());
      ds.field("z2MinRange", &self.z2MinRange());
      ds.field("z1MaxRange", &self.z1MaxRange());
      ds.field("z2MaxRange", &self.z2MaxRange());
      ds.field("radarMUR", &self.radarMUR());
      ds.field("probFalseAlarm", &self.probFalseAlarm());
      ds.field("prf", &self.prf());
      ds.field("radarPulseWidth", &self.radarPulseWidth());
      ds.field("numIntegratedPulses", &self.numIntegratedPulses());
      ds.field("trueTilt", &self.trueTilt());
      ds.field("radarMessageFormat", &self.radarMessageFormat());
      ds.field("systemNoiseTemperature", &self.systemNoiseTemperature());
      ds.field("source", &self.source());
      ds.field("dataMode", &self.dataMode());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Sensorcharacteristics_FullT {
  pub id: Option<String>,
  pub idSensor: Option<String>,
  pub classificationMarking: Option<String>,
  pub origNetwork: Option<String>,
  pub azimuthRate: f64,
  pub elevationRateGeolm: f64,
  pub minRangeLimit: f64,
  pub maxRangeLimit: f64,
  pub leftClockAngle: f64,
  pub rightClockAngle: f64,
  pub boresight: f64,
  pub boresightOffAngle: f64,
  pub negativeRangeRateLimit: f64,
  pub positiveRangeRateLimit: f64,
  pub magnitudeLimit: f64,
  pub trackAngle: f64,
  pub minSignalNoiseRatio: f64,
  pub fanBeamWidth: f64,
  pub taskableRange: f64,
  pub maxObservableRange: f64,
  pub radioFrequency: f64,
  pub radarFrequency: f64,
  pub transmitPower: f64,
  pub hFOV: f64,
  pub vFOV: f64,
  pub hResPixels: i32,
  pub vResPixels: i32,
  pub band: Option<String>,
  pub maxDeviationAngle: f64,
  pub aperture: f64,
  pub leftGeoBeltLimit: f64,
  pub rightGeoBeltLimit: f64,
  pub asrScanRate: f64,
  pub k: f64,
  pub focalPoint: f64,
  pub towerHeight: f64,
  pub trueNorthCorrector: i32,
  pub magDec: f64,
  pub z1MinRange: f64,
  pub z2MinRange: f64,
  pub z1MaxRange: f64,
  pub z2MaxRange: f64,
  pub radarMUR: f64,
  pub probFalseAlarm: f64,
  pub prf: f64,
  pub radarPulseWidth: f64,
  pub numIntegratedPulses: i32,
  pub trueTilt: f64,
  pub radarMessageFormat: Option<String>,
  pub systemNoiseTemperature: f64,
  pub source: Option<String>,
  pub dataMode: Sensorcharacteristics_Full_dataMode_Enum,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
}
impl Default for Sensorcharacteristics_FullT {
  fn default() -> Self {
    Self {
      id: None,
      idSensor: None,
      classificationMarking: None,
      origNetwork: None,
      azimuthRate: 0.0,
      elevationRateGeolm: 0.0,
      minRangeLimit: 0.0,
      maxRangeLimit: 0.0,
      leftClockAngle: 0.0,
      rightClockAngle: 0.0,
      boresight: 0.0,
      boresightOffAngle: 0.0,
      negativeRangeRateLimit: 0.0,
      positiveRangeRateLimit: 0.0,
      magnitudeLimit: 0.0,
      trackAngle: 0.0,
      minSignalNoiseRatio: 0.0,
      fanBeamWidth: 0.0,
      taskableRange: 0.0,
      maxObservableRange: 0.0,
      radioFrequency: 0.0,
      radarFrequency: 0.0,
      transmitPower: 0.0,
      hFOV: 0.0,
      vFOV: 0.0,
      hResPixels: 0,
      vResPixels: 0,
      band: None,
      maxDeviationAngle: 0.0,
      aperture: 0.0,
      leftGeoBeltLimit: 0.0,
      rightGeoBeltLimit: 0.0,
      asrScanRate: 0.0,
      k: 0.0,
      focalPoint: 0.0,
      towerHeight: 0.0,
      trueNorthCorrector: 0,
      magDec: 0.0,
      z1MinRange: 0.0,
      z2MinRange: 0.0,
      z1MaxRange: 0.0,
      z2MaxRange: 0.0,
      radarMUR: 0.0,
      probFalseAlarm: 0.0,
      prf: 0.0,
      radarPulseWidth: 0.0,
      numIntegratedPulses: 0,
      trueTilt: 0.0,
      radarMessageFormat: None,
      systemNoiseTemperature: 0.0,
      source: None,
      dataMode: Sensorcharacteristics_Full_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
    }
  }
}
impl Sensorcharacteristics_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Sensorcharacteristics_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor = self.idSensor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let azimuthRate = self.azimuthRate;
    let elevationRateGeolm = self.elevationRateGeolm;
    let minRangeLimit = self.minRangeLimit;
    let maxRangeLimit = self.maxRangeLimit;
    let leftClockAngle = self.leftClockAngle;
    let rightClockAngle = self.rightClockAngle;
    let boresight = self.boresight;
    let boresightOffAngle = self.boresightOffAngle;
    let negativeRangeRateLimit = self.negativeRangeRateLimit;
    let positiveRangeRateLimit = self.positiveRangeRateLimit;
    let magnitudeLimit = self.magnitudeLimit;
    let trackAngle = self.trackAngle;
    let minSignalNoiseRatio = self.minSignalNoiseRatio;
    let fanBeamWidth = self.fanBeamWidth;
    let taskableRange = self.taskableRange;
    let maxObservableRange = self.maxObservableRange;
    let radioFrequency = self.radioFrequency;
    let radarFrequency = self.radarFrequency;
    let transmitPower = self.transmitPower;
    let hFOV = self.hFOV;
    let vFOV = self.vFOV;
    let hResPixels = self.hResPixels;
    let vResPixels = self.vResPixels;
    let band = self.band.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let maxDeviationAngle = self.maxDeviationAngle;
    let aperture = self.aperture;
    let leftGeoBeltLimit = self.leftGeoBeltLimit;
    let rightGeoBeltLimit = self.rightGeoBeltLimit;
    let asrScanRate = self.asrScanRate;
    let k = self.k;
    let focalPoint = self.focalPoint;
    let towerHeight = self.towerHeight;
    let trueNorthCorrector = self.trueNorthCorrector;
    let magDec = self.magDec;
    let z1MinRange = self.z1MinRange;
    let z2MinRange = self.z2MinRange;
    let z1MaxRange = self.z1MaxRange;
    let z2MaxRange = self.z2MaxRange;
    let radarMUR = self.radarMUR;
    let probFalseAlarm = self.probFalseAlarm;
    let prf = self.prf;
    let radarPulseWidth = self.radarPulseWidth;
    let numIntegratedPulses = self.numIntegratedPulses;
    let trueTilt = self.trueTilt;
    let radarMessageFormat = self.radarMessageFormat.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let systemNoiseTemperature = self.systemNoiseTemperature;
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Sensorcharacteristics_Full::create(_fbb, &Sensorcharacteristics_FullArgs{
      id,
      idSensor,
      classificationMarking,
      origNetwork,
      azimuthRate,
      elevationRateGeolm,
      minRangeLimit,
      maxRangeLimit,
      leftClockAngle,
      rightClockAngle,
      boresight,
      boresightOffAngle,
      negativeRangeRateLimit,
      positiveRangeRateLimit,
      magnitudeLimit,
      trackAngle,
      minSignalNoiseRatio,
      fanBeamWidth,
      taskableRange,
      maxObservableRange,
      radioFrequency,
      radarFrequency,
      transmitPower,
      hFOV,
      vFOV,
      hResPixels,
      vResPixels,
      band,
      maxDeviationAngle,
      aperture,
      leftGeoBeltLimit,
      rightGeoBeltLimit,
      asrScanRate,
      k,
      focalPoint,
      towerHeight,
      trueNorthCorrector,
      magDec,
      z1MinRange,
      z2MinRange,
      z1MaxRange,
      z2MaxRange,
      radarMUR,
      probFalseAlarm,
      prf,
      radarPulseWidth,
      numIntegratedPulses,
      trueTilt,
      radarMessageFormat,
      systemNoiseTemperature,
      source,
      dataMode,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Sensorcharacteristics_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sensorcharacteristics_full_unchecked`.
pub fn root_as_sensorcharacteristics_full(buf: &[u8]) -> Result<Sensorcharacteristics_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Sensorcharacteristics_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Sensorcharacteristics_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_sensorcharacteristics_full_unchecked`.
pub fn size_prefixed_root_as_sensorcharacteristics_full(buf: &[u8]) -> Result<Sensorcharacteristics_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Sensorcharacteristics_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Sensorcharacteristics_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sensorcharacteristics_full_unchecked`.
pub fn root_as_sensorcharacteristics_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Sensorcharacteristics_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Sensorcharacteristics_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Sensorcharacteristics_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sensorcharacteristics_full_unchecked`.
pub fn size_prefixed_root_as_sensorcharacteristics_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Sensorcharacteristics_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Sensorcharacteristics_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Sensorcharacteristics_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Sensorcharacteristics_Full`.
pub unsafe fn root_as_sensorcharacteristics_full_unchecked(buf: &[u8]) -> Sensorcharacteristics_Full {
  flatbuffers::root_unchecked::<Sensorcharacteristics_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Sensorcharacteristics_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Sensorcharacteristics_Full`.
pub unsafe fn size_prefixed_root_as_sensorcharacteristics_full_unchecked(buf: &[u8]) -> Sensorcharacteristics_Full {
  flatbuffers::size_prefixed_root_unchecked::<Sensorcharacteristics_Full>(buf)
}
pub const SENSORCHARACTERISTICS_FULL_IDENTIFIER: &str = "SENS";

#[inline]
pub fn sensorcharacteristics_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SENSORCHARACTERISTICS_FULL_IDENTIFIER, false)
}

#[inline]
pub fn sensorcharacteristics_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SENSORCHARACTERISTICS_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_sensorcharacteristics_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Sensorcharacteristics_Full<'a>>) {
  fbb.finish(root, Some(SENSORCHARACTERISTICS_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_sensorcharacteristics_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Sensorcharacteristics_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(SENSORCHARACTERISTICS_FULL_IDENTIFIER));
}
