// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TAIUTC_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TAIUTC_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TAIUTC_ABRIDGED_DATA_MODE_ENUM: [TAIUTC_Abridged_dataMode_Enum; 4] = [
  TAIUTC_Abridged_dataMode_Enum::REAL,
  TAIUTC_Abridged_dataMode_Enum::TEST,
  TAIUTC_Abridged_dataMode_Enum::SIMULATED,
  TAIUTC_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TAIUTC_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl TAIUTC_Abridged_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TAIUTC_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TAIUTC_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TAIUTC_Abridged_dataMode_Enum {
    type Output = TAIUTC_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TAIUTC_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TAIUTC_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TAIUTC_Abridged_dataMode_Enum {}
pub enum TAIUTC_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// International Atomic Time (TAI) is a statistical atomic time scale based on a large number of clocks operating at standards laboratories around the world that is maintained by the Bureau International des Poids et Mesures; its unit interval is exactly one SI second at sea level. The origin of TAI is such that UT1-TAI is approximately 0 (zero) on January 1, 1958. TAI is not adjusted for leap seconds. 
/// Coordinated Universal Time (UTC) is defined by the CCIR Recommendation 460-4 (1986). It differs from TAI by the total number of leap seconds, so that UT1-UTC stays smaller than 0.9s in absolute value.   The decision to introduce a leap second in UTC is the responsibility of the International Earth Rotation Service (IERS). According to the CCIR Recommendation, first preference is given to the opportunities at the end of December and June, and second preference to those at the end of March and September. Since the system was introduced in 1972, only dates in June and December have been used.  TAI is expressed in terms of UTC by the relation TAI = UTC + dAT, where  dAT is the total algebraic sum of leap seconds.
/// The first leap second was introduced on June 30, 1972. The historical list of leap seconds can be found in this table.
pub struct TAIUTC_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TAIUTC_Abridged<'a> {
  type Inner = TAIUTC_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TAIUTC_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_ADJUSTMENTDATE: flatbuffers::VOffsetT = 8;
  pub const VT_TAIUTC: flatbuffers::VOffsetT = 10;
  pub const VT_MULTIPLICATIONFACTOR: flatbuffers::VOffsetT = 12;
  pub const VT_RAWFILEURI: flatbuffers::VOffsetT = 14;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 16;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 18;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 20;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 22;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 24;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TAIUTC_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TAIUTC_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<TAIUTC_Abridged<'bldr>> {
    let mut builder = TAIUTC_AbridgedBuilder::new(_fbb);
    builder.add_multiplicationFactor(args.multiplicationFactor);
    builder.add_taiUTC(args.taiUTC);
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.rawFileURI { builder.add_rawFileURI(x); }
    if let Some(x) = args.adjustmentDate { builder.add_adjustmentDate(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> TAIUTC_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let adjustmentDate = self.adjustmentDate().map(|x| {
      x.to_string()
    });
    let taiUTC = self.taiUTC();
    let multiplicationFactor = self.multiplicationFactor();
    let rawFileURI = self.rawFileURI().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    TAIUTC_AbridgedT {
      id,
      classificationMarking,
      adjustmentDate,
      taiUTC,
      multiplicationFactor,
      rawFileURI,
      source,
      origin,
      origNetwork,
      dataMode,
      createdAt,
      createdBy,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: TAIUTC-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TAIUTC_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TAIUTC_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Effective date/time for the leap second adjustment.
  /// Example: /// Example: 2017-01-01T00:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn adjustmentDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TAIUTC_Abridged::VT_ADJUSTMENTDATE, None)}
  }
  /// Total/cumulative offset between TAI and UTC time as of adjustmentDate, in seconds.
  /// Example: /// Example: 1.422818
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taiUTC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TAIUTC_Abridged::VT_TAIUTC, Some(0.0)).unwrap()}
  }
  /// Multiplication factor of the leap second adjustment.
  /// Example: /// Example: 0.001296
  /// Constraints: No constraints specified.
  #[inline]
  pub fn multiplicationFactor(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TAIUTC_Abridged::VT_MULTIPLICATIONFACTOR, Some(0.0)).unwrap()}
  }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  /// Example: /// Example: /TAI/2019/01/22/4318471007562436-tai-utc.dat
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn rawFileURI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TAIUTC_Abridged::VT_RAWFILEURI, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TAIUTC_Abridged::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TAIUTC_Abridged::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TAIUTC_Abridged::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> TAIUTC_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TAIUTC_Abridged_dataMode_Enum>(TAIUTC_Abridged::VT_DATAMODE, Some(TAIUTC_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TAIUTC_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TAIUTC_Abridged::VT_CREATEDBY, None)}
  }
}

impl flatbuffers::Verifiable for TAIUTC_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("adjustmentDate", Self::VT_ADJUSTMENTDATE, false)?
     .visit_field::<f64>("taiUTC", Self::VT_TAIUTC, false)?
     .visit_field::<f64>("multiplicationFactor", Self::VT_MULTIPLICATIONFACTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawFileURI", Self::VT_RAWFILEURI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<TAIUTC_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .finish();
    Ok(())
  }
}
pub struct TAIUTC_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub adjustmentDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taiUTC: f64,
    pub multiplicationFactor: f64,
    pub rawFileURI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: TAIUTC_Abridged_dataMode_Enum,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TAIUTC_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    TAIUTC_AbridgedArgs {
      id: None,
      classificationMarking: None,
      adjustmentDate: None,
      taiUTC: 0.0,
      multiplicationFactor: 0.0,
      rawFileURI: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: TAIUTC_Abridged_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
    }
  }
}

pub struct TAIUTC_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TAIUTC_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TAIUTC_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TAIUTC_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_adjustmentDate(&mut self, adjustmentDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TAIUTC_Abridged::VT_ADJUSTMENTDATE, adjustmentDate);
  }
  #[inline]
  pub fn add_taiUTC(&mut self, taiUTC: f64) {
    self.fbb_.push_slot::<f64>(TAIUTC_Abridged::VT_TAIUTC, taiUTC, 0.0);
  }
  #[inline]
  pub fn add_multiplicationFactor(&mut self, multiplicationFactor: f64) {
    self.fbb_.push_slot::<f64>(TAIUTC_Abridged::VT_MULTIPLICATIONFACTOR, multiplicationFactor, 0.0);
  }
  #[inline]
  pub fn add_rawFileURI(&mut self, rawFileURI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TAIUTC_Abridged::VT_RAWFILEURI, rawFileURI);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TAIUTC_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TAIUTC_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TAIUTC_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: TAIUTC_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<TAIUTC_Abridged_dataMode_Enum>(TAIUTC_Abridged::VT_DATAMODE, dataMode, TAIUTC_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TAIUTC_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TAIUTC_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TAIUTC_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TAIUTC_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TAIUTC_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TAIUTC_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TAIUTC_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("adjustmentDate", &self.adjustmentDate());
      ds.field("taiUTC", &self.taiUTC());
      ds.field("multiplicationFactor", &self.multiplicationFactor());
      ds.field("rawFileURI", &self.rawFileURI());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TAIUTC_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub adjustmentDate: Option<String>,
  pub taiUTC: f64,
  pub multiplicationFactor: f64,
  pub rawFileURI: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: TAIUTC_Abridged_dataMode_Enum,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
}
impl Default for TAIUTC_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      adjustmentDate: None,
      taiUTC: 0.0,
      multiplicationFactor: 0.0,
      rawFileURI: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: TAIUTC_Abridged_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
    }
  }
}
impl TAIUTC_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TAIUTC_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let adjustmentDate = self.adjustmentDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taiUTC = self.taiUTC;
    let multiplicationFactor = self.multiplicationFactor;
    let rawFileURI = self.rawFileURI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    TAIUTC_Abridged::create(_fbb, &TAIUTC_AbridgedArgs{
      id,
      classificationMarking,
      adjustmentDate,
      taiUTC,
      multiplicationFactor,
      rawFileURI,
      source,
      origin,
      origNetwork,
      dataMode,
      createdAt,
      createdBy,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TAIUTC_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_taiutc_abridged_unchecked`.
pub fn root_as_taiutc_abridged(buf: &[u8]) -> Result<TAIUTC_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TAIUTC_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TAIUTC_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_taiutc_abridged_unchecked`.
pub fn size_prefixed_root_as_taiutc_abridged(buf: &[u8]) -> Result<TAIUTC_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TAIUTC_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TAIUTC_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_taiutc_abridged_unchecked`.
pub fn root_as_taiutc_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TAIUTC_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TAIUTC_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TAIUTC_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_taiutc_abridged_unchecked`.
pub fn size_prefixed_root_as_taiutc_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TAIUTC_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TAIUTC_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TAIUTC_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TAIUTC_Abridged`.
pub unsafe fn root_as_taiutc_abridged_unchecked(buf: &[u8]) -> TAIUTC_Abridged {
  flatbuffers::root_unchecked::<TAIUTC_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TAIUTC_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TAIUTC_Abridged`.
pub unsafe fn size_prefixed_root_as_taiutc_abridged_unchecked(buf: &[u8]) -> TAIUTC_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<TAIUTC_Abridged>(buf)
}
pub const TAIUTC_ABRIDGED_IDENTIFIER: &str = "TAIU";

#[inline]
pub fn taiutc_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TAIUTC_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn taiutc_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TAIUTC_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_taiutc_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<TAIUTC_Abridged<'a>>) {
  fbb.finish(root, Some(TAIUTC_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_taiutc_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<TAIUTC_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(TAIUTC_ABRIDGED_IDENTIFIER));
}
