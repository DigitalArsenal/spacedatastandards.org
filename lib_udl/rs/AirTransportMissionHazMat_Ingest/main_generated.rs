// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum AirTransportMissionHazMat_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Collection of Hazardous Material information associated with this Air Transport Mission.
pub struct AirTransportMissionHazMat_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AirTransportMissionHazMat_Ingest<'a> {
  type Inner = AirTransportMissionHazMat_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AirTransportMissionHazMat_Ingest<'a> {
  pub const VT_EXTHAZMATID: flatbuffers::VOffsetT = 4;
  pub const VT_ITEMNAME: flatbuffers::VOffsetT = 6;
  pub const VT_UNNUM: flatbuffers::VOffsetT = 8;
  pub const VT_PIECES: flatbuffers::VOffsetT = 10;
  pub const VT_WEIGHT: flatbuffers::VOffsetT = 12;
  pub const VT_NETEXPWT: flatbuffers::VOffsetT = 14;
  pub const VT_CLASSDIV: flatbuffers::VOffsetT = 16;
  pub const VT_CGC: flatbuffers::VOffsetT = 18;
  pub const VT_CGN: flatbuffers::VOffsetT = 20;
  pub const VT_APPLICABLENOTES: flatbuffers::VOffsetT = 22;
  pub const VT_ONITIN: flatbuffers::VOffsetT = 24;
  pub const VT_ONICAO: flatbuffers::VOffsetT = 26;
  pub const VT_OFFITIN: flatbuffers::VOffsetT = 28;
  pub const VT_OFFICAO: flatbuffers::VOffsetT = 30;
  pub const VT_PLANNED: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AirTransportMissionHazMat_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AirTransportMissionHazMat_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<AirTransportMissionHazMat_Ingest<'bldr>> {
    let mut builder = AirTransportMissionHazMat_IngestBuilder::new(_fbb);
    builder.add_classDiv(args.classDiv);
    builder.add_netExpWt(args.netExpWt);
    builder.add_weight(args.weight);
    if let Some(x) = args.planned { builder.add_planned(x); }
    if let Some(x) = args.offICAO { builder.add_offICAO(x); }
    builder.add_offItin(args.offItin);
    if let Some(x) = args.onICAO { builder.add_onICAO(x); }
    builder.add_onItin(args.onItin);
    if let Some(x) = args.applicableNotes { builder.add_applicableNotes(x); }
    if let Some(x) = args.cgn { builder.add_cgn(x); }
    if let Some(x) = args.cgc { builder.add_cgc(x); }
    builder.add_pieces(args.pieces);
    if let Some(x) = args.unNum { builder.add_unNum(x); }
    if let Some(x) = args.itemName { builder.add_itemName(x); }
    if let Some(x) = args.extHazMatId { builder.add_extHazMatId(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> AirTransportMissionHazMat_IngestT {
    let extHazMatId = self.extHazMatId().map(|x| {
      x.to_string()
    });
    let itemName = self.itemName().map(|x| {
      x.to_string()
    });
    let unNum = self.unNum().map(|x| {
      x.to_string()
    });
    let pieces = self.pieces();
    let weight = self.weight();
    let netExpWt = self.netExpWt();
    let classDiv = self.classDiv();
    let cgc = self.cgc().map(|x| {
      x.to_string()
    });
    let cgn = self.cgn().map(|x| {
      x.to_string()
    });
    let applicableNotes = self.applicableNotes().map(|x| {
      x.to_string()
    });
    let onItin = self.onItin();
    let onICAO = self.onICAO().map(|x| {
      x.to_string()
    });
    let offItin = self.offItin();
    let offICAO = self.offICAO().map(|x| {
      x.to_string()
    });
    let planned = self.planned().map(|x| {
      x.to_string()
    });
    AirTransportMissionHazMat_IngestT {
      extHazMatId,
      itemName,
      unNum,
      pieces,
      weight,
      netExpWt,
      classDiv,
      cgc,
      cgn,
      applicableNotes,
      onItin,
      onICAO,
      offItin,
      offICAO,
      planned,
    }
  }

  /// The hazMat identifier provided by the originating source.
  /// Example: /// Example: cb6289e0f38534e01291ab6421d42724
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn extHazMatId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirTransportMissionHazMat_Ingest::VT_EXTHAZMATID, None)}
  }
  /// United Nations proper shipping name of the hazardous material according to the Hazardous Materials Regulations issued by the U.S. Department of Transportation.
  /// Example: /// Example: LITHIUM METAL BATTERIES
  /// Constraints: Minimum length = 0, Maximum length = 1024
  #[inline]
  pub fn itemName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirTransportMissionHazMat_Ingest::VT_ITEMNAME, None)}
  }
  /// United Nations number or North America number that identifies hazardous materials according to the Hazardous Materials Regulations issued by the U.S. Department of Transportation.
  /// Example: /// Example: 0181
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn unNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirTransportMissionHazMat_Ingest::VT_UNNUM, None)}
  }
  /// Number of pieces of hazardous cargo.
  /// Example: /// Example: 29
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pieces(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirTransportMissionHazMat_Ingest::VT_PIECES, Some(0)).unwrap()}
  }
  /// Total weight of hazardous cargo, including non-explosive parts, in kilograms.
  /// Example: /// Example: 22.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn weight(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirTransportMissionHazMat_Ingest::VT_WEIGHT, Some(0.0)).unwrap()}
  }
  /// Net explosive weight of the hazardous material, in kilograms.
  /// Example: /// Example: 12.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn netExpWt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirTransportMissionHazMat_Ingest::VT_NETEXPWT, Some(0.0)).unwrap()}
  }
  /// Class and division of the hazardous material according to the Hazardous Materials Regulations issued by the U.S. Department of Transportation.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn classDiv(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirTransportMissionHazMat_Ingest::VT_CLASSDIV, Some(0.0)).unwrap()}
  }
  /// Compatibility group code used to specify the controls for the transportation and storage of hazardous materials according to the Hazardous Materials Regulations issued by the U.S. Department of Transportation.
  /// Example: /// Example: A
  /// Constraints: Minimum length = 0, Maximum length = 2
  #[inline]
  pub fn cgc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirTransportMissionHazMat_Ingest::VT_CGC, None)}
  }
  /// Comma delimited list of Note IDs for compatibility groups, specific to GDSS systems.
  /// Example: /// Example: 4,5,7,8
  /// Constraints: Minimum length = 0, Maximum length = 100
  #[inline]
  pub fn cgn(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirTransportMissionHazMat_Ingest::VT_CGN, None)}
  }
  /// Comma delimited list of Note IDs for Item Class Segregation groups, specific to GDSS systems.
  /// Example: /// Example: 11,12
  /// Constraints: Minimum length = 0, Maximum length = 100
  #[inline]
  pub fn applicableNotes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirTransportMissionHazMat_Ingest::VT_APPLICABLENOTES, None)}
  }
  /// Itinerary number that identifies where the hazardous material is loaded.
  /// Example: /// Example: 50
  /// Constraints: No constraints specified.
  #[inline]
  pub fn onItin(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirTransportMissionHazMat_Ingest::VT_ONITIN, Some(0)).unwrap()}
  }
  /// The International Civil Aviation Organization (ICAO) code of the site where the hazardous material is loaded.
  /// Example: /// Example: LIRQ
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn onICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirTransportMissionHazMat_Ingest::VT_ONICAO, None)}
  }
  /// Itinerary number that identifies where the hazardous material is unloaded.
  /// Example: /// Example: 300
  /// Constraints: No constraints specified.
  #[inline]
  pub fn offItin(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirTransportMissionHazMat_Ingest::VT_OFFITIN, Some(0)).unwrap()}
  }
  /// The International Civil Aviation Organization (ICAO) code of the site where the hazardous material is unloaded.
  /// Example: /// Example: MBPV
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn offICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirTransportMissionHazMat_Ingest::VT_OFFICAO, None)}
  }
  /// Flag indicating if hazardous material is associated with this air transport mission. Possible values are P (planned to be associated with the mission) or A (actually associated with the mission). Enum: [P, A].
  /// Example: /// Example: P
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn planned(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirTransportMissionHazMat_Ingest::VT_PLANNED, None)}
  }
}

impl flatbuffers::Verifiable for AirTransportMissionHazMat_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("extHazMatId", Self::VT_EXTHAZMATID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemName", Self::VT_ITEMNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unNum", Self::VT_UNNUM, false)?
     .visit_field::<i32>("pieces", Self::VT_PIECES, false)?
     .visit_field::<f64>("weight", Self::VT_WEIGHT, false)?
     .visit_field::<f64>("netExpWt", Self::VT_NETEXPWT, false)?
     .visit_field::<f64>("classDiv", Self::VT_CLASSDIV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cgc", Self::VT_CGC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cgn", Self::VT_CGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("applicableNotes", Self::VT_APPLICABLENOTES, false)?
     .visit_field::<i32>("onItin", Self::VT_ONITIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("onICAO", Self::VT_ONICAO, false)?
     .visit_field::<i32>("offItin", Self::VT_OFFITIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("offICAO", Self::VT_OFFICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("planned", Self::VT_PLANNED, false)?
     .finish();
    Ok(())
  }
}
pub struct AirTransportMissionHazMat_IngestArgs<'a> {
    pub extHazMatId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pieces: i32,
    pub weight: f64,
    pub netExpWt: f64,
    pub classDiv: f64,
    pub cgc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cgn: Option<flatbuffers::WIPOffset<&'a str>>,
    pub applicableNotes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub onItin: i32,
    pub onICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub offItin: i32,
    pub offICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub planned: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AirTransportMissionHazMat_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    AirTransportMissionHazMat_IngestArgs {
      extHazMatId: None,
      itemName: None,
      unNum: None,
      pieces: 0,
      weight: 0.0,
      netExpWt: 0.0,
      classDiv: 0.0,
      cgc: None,
      cgn: None,
      applicableNotes: None,
      onItin: 0,
      onICAO: None,
      offItin: 0,
      offICAO: None,
      planned: None,
    }
  }
}

pub struct AirTransportMissionHazMat_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AirTransportMissionHazMat_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_extHazMatId(&mut self, extHazMatId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirTransportMissionHazMat_Ingest::VT_EXTHAZMATID, extHazMatId);
  }
  #[inline]
  pub fn add_itemName(&mut self, itemName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirTransportMissionHazMat_Ingest::VT_ITEMNAME, itemName);
  }
  #[inline]
  pub fn add_unNum(&mut self, unNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirTransportMissionHazMat_Ingest::VT_UNNUM, unNum);
  }
  #[inline]
  pub fn add_pieces(&mut self, pieces: i32) {
    self.fbb_.push_slot::<i32>(AirTransportMissionHazMat_Ingest::VT_PIECES, pieces, 0);
  }
  #[inline]
  pub fn add_weight(&mut self, weight: f64) {
    self.fbb_.push_slot::<f64>(AirTransportMissionHazMat_Ingest::VT_WEIGHT, weight, 0.0);
  }
  #[inline]
  pub fn add_netExpWt(&mut self, netExpWt: f64) {
    self.fbb_.push_slot::<f64>(AirTransportMissionHazMat_Ingest::VT_NETEXPWT, netExpWt, 0.0);
  }
  #[inline]
  pub fn add_classDiv(&mut self, classDiv: f64) {
    self.fbb_.push_slot::<f64>(AirTransportMissionHazMat_Ingest::VT_CLASSDIV, classDiv, 0.0);
  }
  #[inline]
  pub fn add_cgc(&mut self, cgc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirTransportMissionHazMat_Ingest::VT_CGC, cgc);
  }
  #[inline]
  pub fn add_cgn(&mut self, cgn: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirTransportMissionHazMat_Ingest::VT_CGN, cgn);
  }
  #[inline]
  pub fn add_applicableNotes(&mut self, applicableNotes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirTransportMissionHazMat_Ingest::VT_APPLICABLENOTES, applicableNotes);
  }
  #[inline]
  pub fn add_onItin(&mut self, onItin: i32) {
    self.fbb_.push_slot::<i32>(AirTransportMissionHazMat_Ingest::VT_ONITIN, onItin, 0);
  }
  #[inline]
  pub fn add_onICAO(&mut self, onICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirTransportMissionHazMat_Ingest::VT_ONICAO, onICAO);
  }
  #[inline]
  pub fn add_offItin(&mut self, offItin: i32) {
    self.fbb_.push_slot::<i32>(AirTransportMissionHazMat_Ingest::VT_OFFITIN, offItin, 0);
  }
  #[inline]
  pub fn add_offICAO(&mut self, offICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirTransportMissionHazMat_Ingest::VT_OFFICAO, offICAO);
  }
  #[inline]
  pub fn add_planned(&mut self, planned: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirTransportMissionHazMat_Ingest::VT_PLANNED, planned);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AirTransportMissionHazMat_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AirTransportMissionHazMat_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AirTransportMissionHazMat_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AirTransportMissionHazMat_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AirTransportMissionHazMat_Ingest");
      ds.field("extHazMatId", &self.extHazMatId());
      ds.field("itemName", &self.itemName());
      ds.field("unNum", &self.unNum());
      ds.field("pieces", &self.pieces());
      ds.field("weight", &self.weight());
      ds.field("netExpWt", &self.netExpWt());
      ds.field("classDiv", &self.classDiv());
      ds.field("cgc", &self.cgc());
      ds.field("cgn", &self.cgn());
      ds.field("applicableNotes", &self.applicableNotes());
      ds.field("onItin", &self.onItin());
      ds.field("onICAO", &self.onICAO());
      ds.field("offItin", &self.offItin());
      ds.field("offICAO", &self.offICAO());
      ds.field("planned", &self.planned());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AirTransportMissionHazMat_IngestT {
  pub extHazMatId: Option<String>,
  pub itemName: Option<String>,
  pub unNum: Option<String>,
  pub pieces: i32,
  pub weight: f64,
  pub netExpWt: f64,
  pub classDiv: f64,
  pub cgc: Option<String>,
  pub cgn: Option<String>,
  pub applicableNotes: Option<String>,
  pub onItin: i32,
  pub onICAO: Option<String>,
  pub offItin: i32,
  pub offICAO: Option<String>,
  pub planned: Option<String>,
}
impl Default for AirTransportMissionHazMat_IngestT {
  fn default() -> Self {
    Self {
      extHazMatId: None,
      itemName: None,
      unNum: None,
      pieces: 0,
      weight: 0.0,
      netExpWt: 0.0,
      classDiv: 0.0,
      cgc: None,
      cgn: None,
      applicableNotes: None,
      onItin: 0,
      onICAO: None,
      offItin: 0,
      offICAO: None,
      planned: None,
    }
  }
}
impl AirTransportMissionHazMat_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AirTransportMissionHazMat_Ingest<'b>> {
    let extHazMatId = self.extHazMatId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let itemName = self.itemName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let unNum = self.unNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pieces = self.pieces;
    let weight = self.weight;
    let netExpWt = self.netExpWt;
    let classDiv = self.classDiv;
    let cgc = self.cgc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cgn = self.cgn.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let applicableNotes = self.applicableNotes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let onItin = self.onItin;
    let onICAO = self.onICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let offItin = self.offItin;
    let offICAO = self.offICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let planned = self.planned.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    AirTransportMissionHazMat_Ingest::create(_fbb, &AirTransportMissionHazMat_IngestArgs{
      extHazMatId,
      itemName,
      unNum,
      pieces,
      weight,
      netExpWt,
      classDiv,
      cgc,
      cgn,
      applicableNotes,
      onItin,
      onICAO,
      offItin,
      offICAO,
      planned,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AirTransportMissionHazMat_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_air_transport_mission_haz_mat_ingest_unchecked`.
pub fn root_as_air_transport_mission_haz_mat_ingest(buf: &[u8]) -> Result<AirTransportMissionHazMat_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AirTransportMissionHazMat_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AirTransportMissionHazMat_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_air_transport_mission_haz_mat_ingest_unchecked`.
pub fn size_prefixed_root_as_air_transport_mission_haz_mat_ingest(buf: &[u8]) -> Result<AirTransportMissionHazMat_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AirTransportMissionHazMat_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AirTransportMissionHazMat_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_air_transport_mission_haz_mat_ingest_unchecked`.
pub fn root_as_air_transport_mission_haz_mat_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirTransportMissionHazMat_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AirTransportMissionHazMat_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AirTransportMissionHazMat_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_air_transport_mission_haz_mat_ingest_unchecked`.
pub fn size_prefixed_root_as_air_transport_mission_haz_mat_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirTransportMissionHazMat_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AirTransportMissionHazMat_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AirTransportMissionHazMat_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AirTransportMissionHazMat_Ingest`.
pub unsafe fn root_as_air_transport_mission_haz_mat_ingest_unchecked(buf: &[u8]) -> AirTransportMissionHazMat_Ingest {
  flatbuffers::root_unchecked::<AirTransportMissionHazMat_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AirTransportMissionHazMat_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AirTransportMissionHazMat_Ingest`.
pub unsafe fn size_prefixed_root_as_air_transport_mission_haz_mat_ingest_unchecked(buf: &[u8]) -> AirTransportMissionHazMat_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<AirTransportMissionHazMat_Ingest>(buf)
}
pub const AIR_TRANSPORT_MISSION_HAZ_MAT_INGEST_IDENTIFIER: &str = "AIRT";

#[inline]
pub fn air_transport_mission_haz_mat_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIR_TRANSPORT_MISSION_HAZ_MAT_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn air_transport_mission_haz_mat_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIR_TRANSPORT_MISSION_HAZ_MAT_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_air_transport_mission_haz_mat_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AirTransportMissionHazMat_Ingest<'a>>) {
  fbb.finish(root, Some(AIR_TRANSPORT_MISSION_HAZ_MAT_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_air_transport_mission_haz_mat_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AirTransportMissionHazMat_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(AIR_TRANSPORT_MISSION_HAZ_MAT_INGEST_IDENTIFIER));
}
