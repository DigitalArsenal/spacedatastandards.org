// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANTENNA_DETAILS_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANTENNA_DETAILS_MODE_ENUM: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANTENNA_DETAILS_MODE_ENUM: [AntennaDetails_mode_Enum; 2] = [
  AntennaDetails_mode_Enum::TX,
  AntennaDetails_mode_Enum::RX,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AntennaDetails_mode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AntennaDetails_mode_Enum {
  /// No description available.
  pub const TX: Self = Self(0);
  /// No description available.
  pub const RX: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TX,
    Self::RX,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TX => Some("TX"),
      Self::RX => Some("RX"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AntennaDetails_mode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AntennaDetails_mode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AntennaDetails_mode_Enum {
    type Output = AntennaDetails_mode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AntennaDetails_mode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AntennaDetails_mode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AntennaDetails_mode_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANTENNA_DETAILS_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANTENNA_DETAILS_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANTENNA_DETAILS_DATA_MODE_ENUM: [AntennaDetails_dataMode_Enum; 4] = [
  AntennaDetails_dataMode_Enum::REAL,
  AntennaDetails_dataMode_Enum::TEST,
  AntennaDetails_dataMode_Enum::SIMULATED,
  AntennaDetails_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AntennaDetails_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AntennaDetails_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AntennaDetails_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AntennaDetails_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AntennaDetails_dataMode_Enum {
    type Output = AntennaDetails_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AntennaDetails_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AntennaDetails_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AntennaDetails_dataMode_Enum {}
pub enum AntennaDetailsOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Detailed information for a spacecraft communication antenna. One antenna may have multiple AntennaDetails records, compiled by various sources.
pub struct AntennaDetails<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AntennaDetails<'a> {
  type Inner = AntennaDetails<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AntennaDetails<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_IDANTENNA: flatbuffers::VOffsetT = 6;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 8;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 10;
  pub const VT_POSITION: flatbuffers::VOffsetT = 12;
  pub const VT_MODE: flatbuffers::VOffsetT = 14;
  pub const VT_STEERABLE: flatbuffers::VOffsetT = 16;
  pub const VT_BEAMFORMING: flatbuffers::VOffsetT = 18;
  pub const VT_MANUFACTURERORGID: flatbuffers::VOffsetT = 20;
  pub const VT_DIAMETER: flatbuffers::VOffsetT = 22;
  pub const VT_SIZE_: flatbuffers::VOffsetT = 24;
  pub const VT_STARTFREQUENCY: flatbuffers::VOffsetT = 26;
  pub const VT_ENDFREQUENCY: flatbuffers::VOffsetT = 28;
  pub const VT_BEAMWIDTH: flatbuffers::VOffsetT = 30;
  pub const VT_GAIN: flatbuffers::VOffsetT = 32;
  pub const VT_GAINTOLERANCE: flatbuffers::VOffsetT = 34;
  pub const VT_POLARIZATION: flatbuffers::VOffsetT = 36;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 38;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 40;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 42;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 44;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 46;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 48;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 50;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 52;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 54;
  pub const VT_TAGS: flatbuffers::VOffsetT = 56;
  pub const VT_MANUFACTURERORG: flatbuffers::VOffsetT = 58;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AntennaDetails { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AntennaDetailsArgs<'args>
  ) -> flatbuffers::WIPOffset<AntennaDetails<'bldr>> {
    let mut builder = AntennaDetailsBuilder::new(_fbb);
    builder.add_polarization(args.polarization);
    builder.add_gainTolerance(args.gainTolerance);
    builder.add_gain(args.gain);
    builder.add_beamwidth(args.beamwidth);
    builder.add_endFrequency(args.endFrequency);
    builder.add_startFrequency(args.startFrequency);
    builder.add_diameter(args.diameter);
    if let Some(x) = args.manufacturerOrg { builder.add_manufacturerOrg(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.size_ { builder.add_size_(x); }
    if let Some(x) = args.manufacturerOrgId { builder.add_manufacturerOrgId(x); }
    if let Some(x) = args.position { builder.add_position(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.idAntenna { builder.add_idAntenna(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_beamForming(args.beamForming);
    builder.add_steerable(args.steerable);
    builder.add_mode(args.mode);
    builder.finish()
  }

  pub fn unpack(&self) -> AntennaDetailsT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let idAntenna = self.idAntenna().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let position = self.position().map(|x| {
      x.to_string()
    });
    let mode = self.mode();
    let steerable = self.steerable();
    let beamForming = self.beamForming();
    let manufacturerOrgId = self.manufacturerOrgId().map(|x| {
      x.to_string()
    });
    let diameter = self.diameter();
    let size_ = self.size_().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let startFrequency = self.startFrequency();
    let endFrequency = self.endFrequency();
    let beamwidth = self.beamwidth();
    let gain = self.gain();
    let gainTolerance = self.gainTolerance();
    let polarization = self.polarization();
    let description = self.description().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let tags = self.tags().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let manufacturerOrg = self.manufacturerOrg().map(|x| {
      x.to_string()
    });
    AntennaDetailsT {
      id,
      idAntenna,
      classificationMarking,
      type_,
      position,
      mode,
      steerable,
      beamForming,
      manufacturerOrgId,
      diameter,
      size_,
      startFrequency,
      endFrequency,
      beamwidth,
      gain,
      gainTolerance,
      polarization,
      description,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      origNetwork,
      dataMode,
      tags,
      manufacturerOrg,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: ANTENNADETAILS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_ID, None)}
  }
  /// Unique identifier of the parent Antenna.
  /// Example: /// Example: ANTENNA-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn idAntenna(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_IDANTENNA, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Type of antenna (e.g. Reflector, Double Reflector, Shaped Reflector, Horn, Parabolic, etc.).
  /// Example: /// Example: Reflector
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_TYPE_, None)}
  }
  /// Antenna position (e.g. Top, Nadir, Side).
  /// Example: /// Example: Top
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn position(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_POSITION, None)}
  }
  /// Antenna mode (e.g. TX,RX).
  /// Example: /// Example: TX
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn mode(&self) -> AntennaDetails_mode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AntennaDetails_mode_Enum>(AntennaDetails::VT_MODE, Some(AntennaDetails_mode_Enum::TX)).unwrap()}
  }
  /// Boolean indicating if this antenna is steerable.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn steerable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AntennaDetails::VT_STEERABLE, Some(false)).unwrap()}
  }
  /// Boolean indicating if this is a beam forming antenna.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn beamForming(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AntennaDetails::VT_BEAMFORMING, Some(false)).unwrap()}
  }
  /// ID of the organization that manufactures the antenna.
  /// Example: /// Example: MANUFACTUREORG-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn manufacturerOrgId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_MANUFACTURERORGID, None)}
  }
  /// Antenna diameter in meters.
  /// Example: /// Example: 0.01
  /// Constraints: No constraints specified.
  #[inline]
  pub fn diameter(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AntennaDetails::VT_DIAMETER, Some(0.0)).unwrap()}
  }
  /// Array with 1-2 values specifying the length and width (for rectangular) and just length for dipole antennas in meters.
  /// Example: /// Example: [0.03, 0.05]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn size_(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AntennaDetails::VT_SIZE_, None)}
  }
  /// Antenna start of frequency range in Mhz.
  /// Example: /// Example: 2.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn startFrequency(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AntennaDetails::VT_STARTFREQUENCY, Some(0.0)).unwrap()}
  }
  /// Antenna end of frequency range in Mhz.
  /// Example: /// Example: 3.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn endFrequency(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AntennaDetails::VT_ENDFREQUENCY, Some(0.0)).unwrap()}
  }
  /// Array of angles between the half-power (-3 dB) points of the main lobe of the antenna, in degrees.
  /// Example: /// Example: 14.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn beamwidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AntennaDetails::VT_BEAMWIDTH, Some(0.0)).unwrap()}
  }
  /// Antenna maximum gain in dBi.
  /// Example: /// Example: 20.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gain(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AntennaDetails::VT_GAIN, Some(0.0)).unwrap()}
  }
  /// Antenna gain tolerance in dB.
  /// Example: /// Example: 5.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gainTolerance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AntennaDetails::VT_GAINTOLERANCE, Some(0.0)).unwrap()}
  }
  /// Antenna polarization in degrees.
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polarization(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AntennaDetails::VT_POLARIZATION, Some(0.0)).unwrap()}
  }
  /// Antenna description.
  /// Example: /// Example: Description of antenna A
  /// Constraints: Minimum length = 0, Maximum length = 512
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_DESCRIPTION, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_CREATEDBY, None)}
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_UPDATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> AntennaDetails_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AntennaDetails_dataMode_Enum>(AntennaDetails::VT_DATAMODE, Some(AntennaDetails_dataMode_Enum::REAL)).unwrap()}
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AntennaDetails::VT_TAGS, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn manufacturerOrg(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AntennaDetails::VT_MANUFACTURERORG, None)}
  }
}

impl flatbuffers::Verifiable for AntennaDetails<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idAntenna", Self::VT_IDANTENNA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("position", Self::VT_POSITION, false)?
     .visit_field::<AntennaDetails_mode_Enum>("mode", Self::VT_MODE, false)?
     .visit_field::<bool>("steerable", Self::VT_STEERABLE, false)?
     .visit_field::<bool>("beamForming", Self::VT_BEAMFORMING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("manufacturerOrgId", Self::VT_MANUFACTURERORGID, false)?
     .visit_field::<f64>("diameter", Self::VT_DIAMETER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("size_", Self::VT_SIZE_, false)?
     .visit_field::<f64>("startFrequency", Self::VT_STARTFREQUENCY, false)?
     .visit_field::<f64>("endFrequency", Self::VT_ENDFREQUENCY, false)?
     .visit_field::<f64>("beamwidth", Self::VT_BEAMWIDTH, false)?
     .visit_field::<f64>("gain", Self::VT_GAIN, false)?
     .visit_field::<f64>("gainTolerance", Self::VT_GAINTOLERANCE, false)?
     .visit_field::<f64>("polarization", Self::VT_POLARIZATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<AntennaDetails_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("manufacturerOrg", Self::VT_MANUFACTURERORG, false)?
     .finish();
    Ok(())
  }
}
pub struct AntennaDetailsArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idAntenna: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub position: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mode: AntennaDetails_mode_Enum,
    pub steerable: bool,
    pub beamForming: bool,
    pub manufacturerOrgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub diameter: f64,
    pub size_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub startFrequency: f64,
    pub endFrequency: f64,
    pub beamwidth: f64,
    pub gain: f64,
    pub gainTolerance: f64,
    pub polarization: f64,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: AntennaDetails_dataMode_Enum,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub manufacturerOrg: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AntennaDetailsArgs<'a> {
  #[inline]
  fn default() -> Self {
    AntennaDetailsArgs {
      id: None,
      idAntenna: None,
      classificationMarking: None,
      type_: None,
      position: None,
      mode: AntennaDetails_mode_Enum::TX,
      steerable: false,
      beamForming: false,
      manufacturerOrgId: None,
      diameter: 0.0,
      size_: None,
      startFrequency: 0.0,
      endFrequency: 0.0,
      beamwidth: 0.0,
      gain: 0.0,
      gainTolerance: 0.0,
      polarization: 0.0,
      description: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: AntennaDetails_dataMode_Enum::REAL,
      tags: None,
      manufacturerOrg: None,
    }
  }
}

pub struct AntennaDetailsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AntennaDetailsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_ID, id);
  }
  #[inline]
  pub fn add_idAntenna(&mut self, idAntenna: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_IDANTENNA, idAntenna);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_position(&mut self, position: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_POSITION, position);
  }
  #[inline]
  pub fn add_mode(&mut self, mode: AntennaDetails_mode_Enum) {
    self.fbb_.push_slot::<AntennaDetails_mode_Enum>(AntennaDetails::VT_MODE, mode, AntennaDetails_mode_Enum::TX);
  }
  #[inline]
  pub fn add_steerable(&mut self, steerable: bool) {
    self.fbb_.push_slot::<bool>(AntennaDetails::VT_STEERABLE, steerable, false);
  }
  #[inline]
  pub fn add_beamForming(&mut self, beamForming: bool) {
    self.fbb_.push_slot::<bool>(AntennaDetails::VT_BEAMFORMING, beamForming, false);
  }
  #[inline]
  pub fn add_manufacturerOrgId(&mut self, manufacturerOrgId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_MANUFACTURERORGID, manufacturerOrgId);
  }
  #[inline]
  pub fn add_diameter(&mut self, diameter: f64) {
    self.fbb_.push_slot::<f64>(AntennaDetails::VT_DIAMETER, diameter, 0.0);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_SIZE_, size_);
  }
  #[inline]
  pub fn add_startFrequency(&mut self, startFrequency: f64) {
    self.fbb_.push_slot::<f64>(AntennaDetails::VT_STARTFREQUENCY, startFrequency, 0.0);
  }
  #[inline]
  pub fn add_endFrequency(&mut self, endFrequency: f64) {
    self.fbb_.push_slot::<f64>(AntennaDetails::VT_ENDFREQUENCY, endFrequency, 0.0);
  }
  #[inline]
  pub fn add_beamwidth(&mut self, beamwidth: f64) {
    self.fbb_.push_slot::<f64>(AntennaDetails::VT_BEAMWIDTH, beamwidth, 0.0);
  }
  #[inline]
  pub fn add_gain(&mut self, gain: f64) {
    self.fbb_.push_slot::<f64>(AntennaDetails::VT_GAIN, gain, 0.0);
  }
  #[inline]
  pub fn add_gainTolerance(&mut self, gainTolerance: f64) {
    self.fbb_.push_slot::<f64>(AntennaDetails::VT_GAINTOLERANCE, gainTolerance, 0.0);
  }
  #[inline]
  pub fn add_polarization(&mut self, polarization: f64) {
    self.fbb_.push_slot::<f64>(AntennaDetails::VT_POLARIZATION, polarization, 0.0);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: AntennaDetails_dataMode_Enum) {
    self.fbb_.push_slot::<AntennaDetails_dataMode_Enum>(AntennaDetails::VT_DATAMODE, dataMode, AntennaDetails_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_manufacturerOrg(&mut self, manufacturerOrg: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AntennaDetails::VT_MANUFACTURERORG, manufacturerOrg);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AntennaDetailsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AntennaDetailsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AntennaDetails<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AntennaDetails<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AntennaDetails");
      ds.field("id", &self.id());
      ds.field("idAntenna", &self.idAntenna());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("type_", &self.type_());
      ds.field("position", &self.position());
      ds.field("mode", &self.mode());
      ds.field("steerable", &self.steerable());
      ds.field("beamForming", &self.beamForming());
      ds.field("manufacturerOrgId", &self.manufacturerOrgId());
      ds.field("diameter", &self.diameter());
      ds.field("size_", &self.size_());
      ds.field("startFrequency", &self.startFrequency());
      ds.field("endFrequency", &self.endFrequency());
      ds.field("beamwidth", &self.beamwidth());
      ds.field("gain", &self.gain());
      ds.field("gainTolerance", &self.gainTolerance());
      ds.field("polarization", &self.polarization());
      ds.field("description", &self.description());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.field("tags", &self.tags());
      ds.field("manufacturerOrg", &self.manufacturerOrg());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AntennaDetailsT {
  pub id: Option<String>,
  pub idAntenna: Option<String>,
  pub classificationMarking: Option<String>,
  pub type_: Option<String>,
  pub position: Option<String>,
  pub mode: AntennaDetails_mode_Enum,
  pub steerable: bool,
  pub beamForming: bool,
  pub manufacturerOrgId: Option<String>,
  pub diameter: f64,
  pub size_: Option<Vec<String>>,
  pub startFrequency: f64,
  pub endFrequency: f64,
  pub beamwidth: f64,
  pub gain: f64,
  pub gainTolerance: f64,
  pub polarization: f64,
  pub description: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: AntennaDetails_dataMode_Enum,
  pub tags: Option<Vec<String>>,
  pub manufacturerOrg: Option<String>,
}
impl Default for AntennaDetailsT {
  fn default() -> Self {
    Self {
      id: None,
      idAntenna: None,
      classificationMarking: None,
      type_: None,
      position: None,
      mode: AntennaDetails_mode_Enum::TX,
      steerable: false,
      beamForming: false,
      manufacturerOrgId: None,
      diameter: 0.0,
      size_: None,
      startFrequency: 0.0,
      endFrequency: 0.0,
      beamwidth: 0.0,
      gain: 0.0,
      gainTolerance: 0.0,
      polarization: 0.0,
      description: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: AntennaDetails_dataMode_Enum::REAL,
      tags: None,
      manufacturerOrg: None,
    }
  }
}
impl AntennaDetailsT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AntennaDetails<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idAntenna = self.idAntenna.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let position = self.position.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mode = self.mode;
    let steerable = self.steerable;
    let beamForming = self.beamForming;
    let manufacturerOrgId = self.manufacturerOrgId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let diameter = self.diameter;
    let size_ = self.size_.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let startFrequency = self.startFrequency;
    let endFrequency = self.endFrequency;
    let beamwidth = self.beamwidth;
    let gain = self.gain;
    let gainTolerance = self.gainTolerance;
    let polarization = self.polarization;
    let description = self.description.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let manufacturerOrg = self.manufacturerOrg.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    AntennaDetails::create(_fbb, &AntennaDetailsArgs{
      id,
      idAntenna,
      classificationMarking,
      type_,
      position,
      mode,
      steerable,
      beamForming,
      manufacturerOrgId,
      diameter,
      size_,
      startFrequency,
      endFrequency,
      beamwidth,
      gain,
      gainTolerance,
      polarization,
      description,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      origNetwork,
      dataMode,
      tags,
      manufacturerOrg,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AntennaDetails`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_antenna_details_unchecked`.
pub fn root_as_antenna_details(buf: &[u8]) -> Result<AntennaDetails, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AntennaDetails>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AntennaDetails` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_antenna_details_unchecked`.
pub fn size_prefixed_root_as_antenna_details(buf: &[u8]) -> Result<AntennaDetails, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AntennaDetails>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AntennaDetails` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_antenna_details_unchecked`.
pub fn root_as_antenna_details_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AntennaDetails<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AntennaDetails<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AntennaDetails` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_antenna_details_unchecked`.
pub fn size_prefixed_root_as_antenna_details_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AntennaDetails<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AntennaDetails<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AntennaDetails and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AntennaDetails`.
pub unsafe fn root_as_antenna_details_unchecked(buf: &[u8]) -> AntennaDetails {
  flatbuffers::root_unchecked::<AntennaDetails>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AntennaDetails and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AntennaDetails`.
pub unsafe fn size_prefixed_root_as_antenna_details_unchecked(buf: &[u8]) -> AntennaDetails {
  flatbuffers::size_prefixed_root_unchecked::<AntennaDetails>(buf)
}
pub const ANTENNA_DETAILS_IDENTIFIER: &str = "ANTE";

#[inline]
pub fn antenna_details_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ANTENNA_DETAILS_IDENTIFIER, false)
}

#[inline]
pub fn antenna_details_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ANTENNA_DETAILS_IDENTIFIER, true)
}

#[inline]
pub fn finish_antenna_details_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AntennaDetails<'a>>) {
  fbb.finish(root, Some(ANTENNA_DETAILS_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_antenna_details_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AntennaDetails<'a>>) {
  fbb.finish_size_prefixed(root, Some(ANTENNA_DETAILS_IDENTIFIER));
}
