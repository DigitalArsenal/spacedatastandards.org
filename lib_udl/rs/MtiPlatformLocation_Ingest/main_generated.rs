// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum MtiPlatformLocation_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Provides information pertaining to the location of the sensor platform during periods when the sensor is not collecting data. It shall be sent as required during periods in which the sensor is not collecting data, such as enroute to an orbit location, during a turn, or any other time at which platform location is required.
pub struct MtiPlatformLocation_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MtiPlatformLocation_Ingest<'a> {
  type Inner = MtiPlatformLocation_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MtiPlatformLocation_Ingest<'a> {
  pub const VT_L1: flatbuffers::VOffsetT = 4;
  pub const VT_L2: flatbuffers::VOffsetT = 6;
  pub const VT_L3: flatbuffers::VOffsetT = 8;
  pub const VT_L4: flatbuffers::VOffsetT = 10;
  pub const VT_L5: flatbuffers::VOffsetT = 12;
  pub const VT_L6: flatbuffers::VOffsetT = 14;
  pub const VT_L7: flatbuffers::VOffsetT = 16;
  pub const VT_PLATLOCTS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MtiPlatformLocation_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MtiPlatformLocation_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<MtiPlatformLocation_Ingest<'bldr>> {
    let mut builder = MtiPlatformLocation_IngestBuilder::new(_fbb);
    builder.add_l5(args.l5);
    builder.add_l3(args.l3);
    builder.add_l2(args.l2);
    builder.add_l1(args.l1);
    if let Some(x) = args.platlocts { builder.add_platlocts(x); }
    builder.add_l7(args.l7);
    builder.add_l6(args.l6);
    builder.add_l4(args.l4);
    builder.finish()
  }

  pub fn unpack(&self) -> MtiPlatformLocation_IngestT {
    let l1 = self.l1();
    let l2 = self.l2();
    let l3 = self.l3();
    let l4 = self.l4();
    let l5 = self.l5();
    let l6 = self.l6();
    let l7 = self.l7();
    let platlocts = self.platlocts().map(|x| {
      x.to_string()
    });
    MtiPlatformLocation_IngestT {
      l1,
      l2,
      l3,
      l4,
      l5,
      l6,
      l7,
      platlocts,
    }
  }

  /// Elapsed time, expressed in milliseconds, from midnight at the beginning of the day specified in the Reference Time fields of the Mission Segment to the time the report is prepared.
  /// Example: /// Example: 1234567890
  /// Constraints: No constraints specified.
  #[inline]
  pub fn l1(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MtiPlatformLocation_Ingest::VT_L1, Some(0)).unwrap()}
  }
  /// North-South position of the platform at the time the report is prepared, expressed as degrees North (positive) or South (negative) of the Equator.
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn l2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MtiPlatformLocation_Ingest::VT_L2, Some(0.0)).unwrap()}
  }
  /// East-West position of the platform at the time the report is prepared, expressed as degrees East (positive) from the Prime Meridian.
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn l3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MtiPlatformLocation_Ingest::VT_L3, Some(0.0)).unwrap()}
  }
  /// Altitude of the platform at the time the report is prepared, referenced to its position above the WGS-84 ellipsoid, in centimeters.
  /// Example: /// Example: 45
  /// Constraints: No constraints specified.
  #[inline]
  pub fn l4(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiPlatformLocation_Ingest::VT_L4, Some(0)).unwrap()}
  }
  /// Ground track of the platform at the time the report is prepared, expressed as the angle in degrees (clockwise) from True North.
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn l5(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MtiPlatformLocation_Ingest::VT_L5, Some(0.0)).unwrap()}
  }
  /// Ground speed of the platform at the time the report is prepared, expressed as millimeters per second.
  /// Example: /// Example: 50
  /// Constraints: No constraints specified.
  #[inline]
  pub fn l6(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiPlatformLocation_Ingest::VT_L6, Some(0)).unwrap()}
  }
  /// Velocity of the platform in the vertical direction, expressed as decimeters per second.
  /// Example: /// Example: 82
  /// Constraints: No constraints specified.
  #[inline]
  pub fn l7(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiPlatformLocation_Ingest::VT_L7, Some(0)).unwrap()}
  }
  /// Platform location timestamp in ISO8601 UTC format.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn platlocts(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MtiPlatformLocation_Ingest::VT_PLATLOCTS, None)}
  }
}

impl flatbuffers::Verifiable for MtiPlatformLocation_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("l1", Self::VT_L1, false)?
     .visit_field::<f64>("l2", Self::VT_L2, false)?
     .visit_field::<f64>("l3", Self::VT_L3, false)?
     .visit_field::<i32>("l4", Self::VT_L4, false)?
     .visit_field::<f64>("l5", Self::VT_L5, false)?
     .visit_field::<i32>("l6", Self::VT_L6, false)?
     .visit_field::<i32>("l7", Self::VT_L7, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("platlocts", Self::VT_PLATLOCTS, false)?
     .finish();
    Ok(())
  }
}
pub struct MtiPlatformLocation_IngestArgs<'a> {
    pub l1: i64,
    pub l2: f64,
    pub l3: f64,
    pub l4: i32,
    pub l5: f64,
    pub l6: i32,
    pub l7: i32,
    pub platlocts: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MtiPlatformLocation_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    MtiPlatformLocation_IngestArgs {
      l1: 0,
      l2: 0.0,
      l3: 0.0,
      l4: 0,
      l5: 0.0,
      l6: 0,
      l7: 0,
      platlocts: None,
    }
  }
}

pub struct MtiPlatformLocation_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MtiPlatformLocation_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_l1(&mut self, l1: i64) {
    self.fbb_.push_slot::<i64>(MtiPlatformLocation_Ingest::VT_L1, l1, 0);
  }
  #[inline]
  pub fn add_l2(&mut self, l2: f64) {
    self.fbb_.push_slot::<f64>(MtiPlatformLocation_Ingest::VT_L2, l2, 0.0);
  }
  #[inline]
  pub fn add_l3(&mut self, l3: f64) {
    self.fbb_.push_slot::<f64>(MtiPlatformLocation_Ingest::VT_L3, l3, 0.0);
  }
  #[inline]
  pub fn add_l4(&mut self, l4: i32) {
    self.fbb_.push_slot::<i32>(MtiPlatformLocation_Ingest::VT_L4, l4, 0);
  }
  #[inline]
  pub fn add_l5(&mut self, l5: f64) {
    self.fbb_.push_slot::<f64>(MtiPlatformLocation_Ingest::VT_L5, l5, 0.0);
  }
  #[inline]
  pub fn add_l6(&mut self, l6: i32) {
    self.fbb_.push_slot::<i32>(MtiPlatformLocation_Ingest::VT_L6, l6, 0);
  }
  #[inline]
  pub fn add_l7(&mut self, l7: i32) {
    self.fbb_.push_slot::<i32>(MtiPlatformLocation_Ingest::VT_L7, l7, 0);
  }
  #[inline]
  pub fn add_platlocts(&mut self, platlocts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MtiPlatformLocation_Ingest::VT_PLATLOCTS, platlocts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MtiPlatformLocation_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MtiPlatformLocation_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MtiPlatformLocation_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MtiPlatformLocation_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MtiPlatformLocation_Ingest");
      ds.field("l1", &self.l1());
      ds.field("l2", &self.l2());
      ds.field("l3", &self.l3());
      ds.field("l4", &self.l4());
      ds.field("l5", &self.l5());
      ds.field("l6", &self.l6());
      ds.field("l7", &self.l7());
      ds.field("platlocts", &self.platlocts());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MtiPlatformLocation_IngestT {
  pub l1: i64,
  pub l2: f64,
  pub l3: f64,
  pub l4: i32,
  pub l5: f64,
  pub l6: i32,
  pub l7: i32,
  pub platlocts: Option<String>,
}
impl Default for MtiPlatformLocation_IngestT {
  fn default() -> Self {
    Self {
      l1: 0,
      l2: 0.0,
      l3: 0.0,
      l4: 0,
      l5: 0.0,
      l6: 0,
      l7: 0,
      platlocts: None,
    }
  }
}
impl MtiPlatformLocation_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MtiPlatformLocation_Ingest<'b>> {
    let l1 = self.l1;
    let l2 = self.l2;
    let l3 = self.l3;
    let l4 = self.l4;
    let l5 = self.l5;
    let l6 = self.l6;
    let l7 = self.l7;
    let platlocts = self.platlocts.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    MtiPlatformLocation_Ingest::create(_fbb, &MtiPlatformLocation_IngestArgs{
      l1,
      l2,
      l3,
      l4,
      l5,
      l6,
      l7,
      platlocts,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `MtiPlatformLocation_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mti_platform_location_ingest_unchecked`.
pub fn root_as_mti_platform_location_ingest(buf: &[u8]) -> Result<MtiPlatformLocation_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MtiPlatformLocation_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MtiPlatformLocation_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_mti_platform_location_ingest_unchecked`.
pub fn size_prefixed_root_as_mti_platform_location_ingest(buf: &[u8]) -> Result<MtiPlatformLocation_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MtiPlatformLocation_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MtiPlatformLocation_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mti_platform_location_ingest_unchecked`.
pub fn root_as_mti_platform_location_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MtiPlatformLocation_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MtiPlatformLocation_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MtiPlatformLocation_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mti_platform_location_ingest_unchecked`.
pub fn size_prefixed_root_as_mti_platform_location_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MtiPlatformLocation_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MtiPlatformLocation_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MtiPlatformLocation_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MtiPlatformLocation_Ingest`.
pub unsafe fn root_as_mti_platform_location_ingest_unchecked(buf: &[u8]) -> MtiPlatformLocation_Ingest {
  flatbuffers::root_unchecked::<MtiPlatformLocation_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MtiPlatformLocation_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MtiPlatformLocation_Ingest`.
pub unsafe fn size_prefixed_root_as_mti_platform_location_ingest_unchecked(buf: &[u8]) -> MtiPlatformLocation_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<MtiPlatformLocation_Ingest>(buf)
}
pub const MTI_PLATFORM_LOCATION_INGEST_IDENTIFIER: &str = "MTIP";

#[inline]
pub fn mti_platform_location_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MTI_PLATFORM_LOCATION_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn mti_platform_location_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MTI_PLATFORM_LOCATION_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_mti_platform_location_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<MtiPlatformLocation_Ingest<'a>>) {
  fbb.finish(root, Some(MTI_PLATFORM_LOCATION_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_mti_platform_location_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<MtiPlatformLocation_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(MTI_PLATFORM_LOCATION_INGEST_IDENTIFIER));
}
