// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PERSONNEL_RECOVERY_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PERSONNEL_RECOVERY_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PERSONNEL_RECOVERY_INGEST_DATA_MODE_ENUM: [PersonnelRecovery_Ingest_dataMode_Enum; 4] = [
  PersonnelRecovery_Ingest_dataMode_Enum::REAL,
  PersonnelRecovery_Ingest_dataMode_Enum::TEST,
  PersonnelRecovery_Ingest_dataMode_Enum::SIMULATED,
  PersonnelRecovery_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PersonnelRecovery_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl PersonnelRecovery_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PersonnelRecovery_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PersonnelRecovery_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PersonnelRecovery_Ingest_dataMode_Enum {
    type Output = PersonnelRecovery_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PersonnelRecovery_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PersonnelRecovery_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PersonnelRecovery_Ingest_dataMode_Enum {}
pub enum PersonnelRecovery_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Provides information concerning search and rescue operations and other situations involving personnel recovery.
pub struct PersonnelRecovery_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PersonnelRecovery_Ingest<'a> {
  type Inner = PersonnelRecovery_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PersonnelRecovery_Ingest<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
  pub const VT_MSGTIME: flatbuffers::VOffsetT = 10;
  pub const VT_RECOVID: flatbuffers::VOffsetT = 12;
  pub const VT_IDWEATHERREPORT: flatbuffers::VOffsetT = 14;
  pub const VT_PICKUPLAT: flatbuffers::VOffsetT = 16;
  pub const VT_PICKUPLON: flatbuffers::VOffsetT = 18;
  pub const VT_PICKUPALT: flatbuffers::VOffsetT = 20;
  pub const VT_TERMIND: flatbuffers::VOffsetT = 22;
  pub const VT_AUTHSTATUS: flatbuffers::VOffsetT = 24;
  pub const VT_NUMPERSONS: flatbuffers::VOffsetT = 26;
  pub const VT_MILCLASS: flatbuffers::VOffsetT = 28;
  pub const VT_NATALLIANCE: flatbuffers::VOffsetT = 30;
  pub const VT_NATALLIANCE1: flatbuffers::VOffsetT = 32;
  pub const VT_IDENTITY: flatbuffers::VOffsetT = 34;
  pub const VT_COMMEQ1: flatbuffers::VOffsetT = 36;
  pub const VT_COMMEQ2: flatbuffers::VOffsetT = 38;
  pub const VT_COMMEQ3: flatbuffers::VOffsetT = 40;
  pub const VT_TXFREQ: flatbuffers::VOffsetT = 42;
  pub const VT_RXFREQ: flatbuffers::VOffsetT = 44;
  pub const VT_NUMNONAMBULATORY: flatbuffers::VOffsetT = 46;
  pub const VT_NUMAMBULATORY: flatbuffers::VOffsetT = 48;
  pub const VT_NUMAMBULATORYINJURED: flatbuffers::VOffsetT = 50;
  pub const VT_SURVIVORRADIO: flatbuffers::VOffsetT = 52;
  pub const VT_SURVIVORMESSAGES: flatbuffers::VOffsetT = 54;
  pub const VT_BEACONIND: flatbuffers::VOffsetT = 56;
  pub const VT_CALLSIGN: flatbuffers::VOffsetT = 58;
  pub const VT_TEXTMSG: flatbuffers::VOffsetT = 60;
  pub const VT_AUTHMETHOD: flatbuffers::VOffsetT = 62;
  pub const VT_OBJECTIVEAREAINFO: flatbuffers::VOffsetT = 64;
  pub const VT_EXECUTIONINFO: flatbuffers::VOffsetT = 66;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 68;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 70;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 72;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 74;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 76;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 78;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PersonnelRecovery_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PersonnelRecovery_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<PersonnelRecovery_Ingest<'bldr>> {
    let mut builder = PersonnelRecovery_IngestBuilder::new(_fbb);
    builder.add_rxFreq(args.rxFreq);
    builder.add_txFreq(args.txFreq);
    builder.add_pickupAlt(args.pickupAlt);
    builder.add_pickupLon(args.pickupLon);
    builder.add_pickupLat(args.pickupLat);
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.executionInfo { builder.add_executionInfo(x); }
    if let Some(x) = args.objectiveAreaInfo { builder.add_objectiveAreaInfo(x); }
    if let Some(x) = args.authMethod { builder.add_authMethod(x); }
    if let Some(x) = args.textMsg { builder.add_textMsg(x); }
    if let Some(x) = args.callSign { builder.add_callSign(x); }
    if let Some(x) = args.survivorMessages { builder.add_survivorMessages(x); }
    if let Some(x) = args.survivorRadio { builder.add_survivorRadio(x); }
    builder.add_numAmbulatoryInjured(args.numAmbulatoryInjured);
    builder.add_numAmbulatory(args.numAmbulatory);
    builder.add_numNonAmbulatory(args.numNonAmbulatory);
    if let Some(x) = args.commEq3 { builder.add_commEq3(x); }
    if let Some(x) = args.commEq2 { builder.add_commEq2(x); }
    if let Some(x) = args.commEq1 { builder.add_commEq1(x); }
    if let Some(x) = args.identity { builder.add_identity(x); }
    builder.add_natAlliance1(args.natAlliance1);
    builder.add_natAlliance(args.natAlliance);
    if let Some(x) = args.milClass { builder.add_milClass(x); }
    builder.add_numPersons(args.numPersons);
    if let Some(x) = args.authStatus { builder.add_authStatus(x); }
    if let Some(x) = args.idWeatherReport { builder.add_idWeatherReport(x); }
    if let Some(x) = args.recovId { builder.add_recovId(x); }
    if let Some(x) = args.msgTime { builder.add_msgTime(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_beaconInd(args.beaconInd);
    builder.add_termInd(args.termInd);
    builder.finish()
  }

  pub fn unpack(&self) -> PersonnelRecovery_IngestT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let msgTime = self.msgTime().map(|x| {
      x.to_string()
    });
    let recovId = self.recovId().map(|x| {
      x.to_string()
    });
    let idWeatherReport = self.idWeatherReport().map(|x| {
      x.to_string()
    });
    let pickupLat = self.pickupLat();
    let pickupLon = self.pickupLon();
    let pickupAlt = self.pickupAlt();
    let termInd = self.termInd();
    let authStatus = self.authStatus().map(|x| {
      x.to_string()
    });
    let numPersons = self.numPersons();
    let milClass = self.milClass().map(|x| {
      x.to_string()
    });
    let natAlliance = self.natAlliance();
    let natAlliance1 = self.natAlliance1();
    let identity = self.identity().map(|x| {
      x.to_string()
    });
    let commEq1 = self.commEq1().map(|x| {
      x.to_string()
    });
    let commEq2 = self.commEq2().map(|x| {
      x.to_string()
    });
    let commEq3 = self.commEq3().map(|x| {
      x.to_string()
    });
    let txFreq = self.txFreq();
    let rxFreq = self.rxFreq();
    let numNonAmbulatory = self.numNonAmbulatory();
    let numAmbulatory = self.numAmbulatory();
    let numAmbulatoryInjured = self.numAmbulatoryInjured();
    let survivorRadio = self.survivorRadio().map(|x| {
      x.to_string()
    });
    let survivorMessages = self.survivorMessages().map(|x| {
      x.to_string()
    });
    let beaconInd = self.beaconInd();
    let callSign = self.callSign().map(|x| {
      x.to_string()
    });
    let textMsg = self.textMsg().map(|x| {
      x.to_string()
    });
    let authMethod = self.authMethod().map(|x| {
      x.to_string()
    });
    let objectiveAreaInfo = self.objectiveAreaInfo().map(|x| {
      x.to_string()
    });
    let executionInfo = self.executionInfo().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    PersonnelRecovery_IngestT {
      id,
      classificationMarking,
      type_,
      msgTime,
      recovId,
      idWeatherReport,
      pickupLat,
      pickupLon,
      pickupAlt,
      termInd,
      authStatus,
      numPersons,
      milClass,
      natAlliance,
      natAlliance1,
      identity,
      commEq1,
      commEq2,
      commEq3,
      txFreq,
      rxFreq,
      numNonAmbulatory,
      numAmbulatory,
      numAmbulatoryInjured,
      survivorRadio,
      survivorMessages,
      beaconInd,
      callSign,
      textMsg,
      authMethod,
      objectiveAreaInfo,
      executionInfo,
      origNetwork,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: PERSONNEL_RECOVERY-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Specifies the type of incident resulting in a recovery or evacuation mission.  Intended as, but not constrained to, MIL-STD-6016 J6.1 Emergency Type (e.g. NO STATEMENT, DOWN AIRCRAFT, MAN IN WATER, DITCHING, BAILOUT, DISTRESSED VEHICLE, GROUND INCIDENT, MEDICAL, ISOLATED PERSONS, etc.).
  /// Example: /// Example: MEDICAL
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_TYPE_, None)}
  }
  /// Time stamp of the original personnel recovery message, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-10-15T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn msgTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_MSGTIME, None)}
  }
  /// UUID identifying the Personnel Recovery  mission, which should remain the same on subsequent posts related to the same recovery mission.
  /// Example: /// Example: RECOV-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn recovId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_RECOVID, None)}
  }
  /// Unique identifier of a weather report associated with this recovery.
  /// Example: /// Example: WEATHER_REPORT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idWeatherReport(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_IDWEATHERREPORT, None)}
  }
  /// WGS-84 latitude of the pickup location, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 75.1234
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pickupLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PersonnelRecovery_Ingest::VT_PICKUPLAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude of the pickup location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 175.1234
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pickupLon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PersonnelRecovery_Ingest::VT_PICKUPLON, Some(0.0)).unwrap()}
  }
  /// Altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a point height above ellipsoid, and negative values indicate a point eight below ellipsoid.
  /// Example: /// Example: 30.1234
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pickupAlt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PersonnelRecovery_Ingest::VT_PICKUPALT, Some(0.0)).unwrap()}
  }
  /// Flag indicating the cancellation of this recovery.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn termInd(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PersonnelRecovery_Ingest::VT_TERMIND, Some(false)).unwrap()}
  }
  /// The confirmation status of the isolated personnel identity. Intended as, but not constrained to, MIL-STD-6016 J6.1 Authentication Status, Isolated Personnel (NO STATEMENT, AUTHENTICATED, NOT AUTHENTICATED, AUTHENTICATED UNDER DURESS, NOT APPLICABLE):
  /// AUTHENTICATED:  Confirmed Friend
  /// NOT AUTHENTICATED: Unconfirmed status
  /// AUTHENTICATED UNDER DURESS:  Authentication comprised by hostiles.
  /// NOT APPLICABLE:  Authentication not required.
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn authStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_AUTHSTATUS, None)}
  }
  /// The count of persons requiring recovery.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numPersons(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PersonnelRecovery_Ingest::VT_NUMPERSONS, Some(0)).unwrap()}
  }
  /// The military classification of the personnel to be recovered. Intended as, but not constrained to, MIL-STD-6016 J6.1 Isolated Personnel Classification (NO STATEMENT, MILITARY, GOVERNMENT CIVILIAN, GOVERNMENT CONTRACTOR, CIVILIAN, MULTIPLE CLASSIFICATIONS).
  /// Example: /// Example: CIVILIAN
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn milClass(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_MILCLASS, None)}
  }
  /// The country of origin or political entity of an isolated person subject to rescue or evacuation. If natAlliance is set to 126, then natAlliance1 must be non 0. If natAlliance is any number other than 126, then natAlliance1 will be set to 0 regardless. Defined in MIL-STD-6016 J6.1 Nationality/Alliance isolated person(s).
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn natAlliance(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PersonnelRecovery_Ingest::VT_NATALLIANCE, Some(0)).unwrap()}
  }
  /// Extended country of origin or political entity of an isolated person subject to rescue or evacuation. Specify an entry here only if natAlliance is 126. Defined in MIL-STD-6016 J6.1 Nationality/Alliance isolated person(s), 1.
  /// Example: /// Example: 0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn natAlliance1(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PersonnelRecovery_Ingest::VT_NATALLIANCE1, Some(0)).unwrap()}
  }
  /// The survivor service identity (UNKNOWN MILITARY, UNKNOWN CIVILIAN, FRIEND MILITARY, FRIEND CIVIILIAN, NEUTRAL MILITARY, NEUTRAL CIVILIAN, HOSTILE MILITARY, HOSTILE CIVILIAN).
  /// Example: /// Example: NEUTRAL CIVILIAN
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn identity(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_IDENTITY, None)}
  }
  /// Survivor communications equipment.  Intended as, but not constrained to, MIL-STD-6016 J6.1 Communications Equipment, Isolated Personnel (NO STATEMENT, SURVIVAL RADIO, RADIO BEACON, EPLRS, SIGNAL MIRROR, SMOKE FLARE, IR SIGNALLING DEVICE, SIGNALLING PANEL, FRIENDLY FORCE TRACKER, GPS BEACON, LL PHONE, TACTICAL RADIO LOS, TACTICAL RADIO BLOS).
  /// Example: /// Example: LL PHONE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn commEq1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_COMMEQ1, None)}
  }
  /// Survivor communications equipment.  Intended as, but not constrained to, MIL-STD-6016 J6.1 Communications Equipment, Isolated Personnel (NO STATEMENT, SURVIVAL RADIO, RADIO BEACON, EPLRS, SIGNAL MIRROR, SMOKE FLARE, IR SIGNALLING DEVICE, SIGNALLING PANEL, FRIENDLY FORCE TRACKER, GPS BEACON, LL PHONE, TACTICAL RADIO LOS, TACTICAL RADIO BLOS).
  /// Example: /// Example: LL PHONE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn commEq2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_COMMEQ2, None)}
  }
  /// Survivor communications equipment.  Intended as, but not constrained to, MIL-STD-6016 J6.1 Communications Equipment, Isolated Personnel (NO STATEMENT, SURVIVAL RADIO, RADIO BEACON, EPLRS, SIGNAL MIRROR, SMOKE FLARE, IR SIGNALLING DEVICE, SIGNALLING PANEL, FRIENDLY FORCE TRACKER, GPS BEACON, LL PHONE, TACTICAL RADIO LOS, TACTICAL RADIO BLOS).
  /// Example: /// Example: LL PHONE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn commEq3(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_COMMEQ3, None)}
  }
  /// Transmit voice frequency in 5Hz increments.
  /// Example: /// Example: 5.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn txFreq(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PersonnelRecovery_Ingest::VT_TXFREQ, Some(0.0)).unwrap()}
  }
  /// Receive voice frequency in 5Hz increments. This field will auto populate with the txFreq value if the post element is null.
  /// Example: /// Example: 5.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rxFreq(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PersonnelRecovery_Ingest::VT_RXFREQ, Some(0.0)).unwrap()}
  }
  /// Number of littered personnel requiring recovery.
  /// Example: /// Example: 0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numNonAmbulatory(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PersonnelRecovery_Ingest::VT_NUMNONAMBULATORY, Some(0)).unwrap()}
  }
  /// Number of ambulatory personnel requiring recovery.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numAmbulatory(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PersonnelRecovery_Ingest::VT_NUMAMBULATORY, Some(0)).unwrap()}
  }
  /// Number of injured, but ambulatory, personnel requiring recovery.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numAmbulatoryInjured(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PersonnelRecovery_Ingest::VT_NUMAMBULATORYINJURED, Some(0)).unwrap()}
  }
  /// Survivor radio equipment. Intended as, but not constrained to, MIL-STD-6016 J6.1 Survivor Radio Type (NO STATEMENT, PRQ7SEL, PRC90, PRC112, PRC112B B1, PRC112C, PRC112D, PRC148 MBITR, PRC148 JEM, PRC149, PRC152, ACRPLB, OTHER).
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn survivorRadio(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_SURVIVORRADIO, None)}
  }
  /// Preloaded message conveying the situation confronting the isolated person(s). Intended as, but not constrained to, MIL-STD-6016 J6.1 Survivor Radio Messages (e.g. INJURED CANT MOVE NO KNOWN HOSTILES, INJURED CANT MOVE HOSTILES NEARBY, UNINJURED CANT MOVE HOSTILES NEARBY, UNINJURED NO KNOWN HOSTILES, INJURED LIMITED MOBILITY).
  /// Example: /// Example: UNINJURED CANT MOVE HOSTILES NEARBY
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn survivorMessages(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_SURVIVORMESSAGES, None)}
  }
  /// Flag indicating whether a radio identifier is reported.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn beaconInd(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PersonnelRecovery_Ingest::VT_BEACONIND, Some(false)).unwrap()}
  }
  /// The call sign of the personnel to be recovered.
  /// Example: /// Example: BADGER
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn callSign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_CALLSIGN, None)}
  }
  /// Additional specific messages received from survivor.
  /// Example: /// Example: Additional message from survivor.
  /// Constraints: Minimum length = 0, Maximum length = 1024
  #[inline]
  pub fn textMsg(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_TEXTMSG, None)}
  }
  /// Mechanism used to verify the survivors identity.
  /// Example: /// Example: PASSPORT
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn authMethod(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_AUTHMETHOD, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn objectiveAreaInfo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_OBJECTIVEAREAINFO, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn executionInfo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_EXECUTIONINFO, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_ORIGNETWORK, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonnelRecovery_Ingest::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> PersonnelRecovery_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PersonnelRecovery_Ingest_dataMode_Enum>(PersonnelRecovery_Ingest::VT_DATAMODE, Some(PersonnelRecovery_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PersonnelRecovery_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msgTime", Self::VT_MSGTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recovId", Self::VT_RECOVID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idWeatherReport", Self::VT_IDWEATHERREPORT, false)?
     .visit_field::<f64>("pickupLat", Self::VT_PICKUPLAT, false)?
     .visit_field::<f64>("pickupLon", Self::VT_PICKUPLON, false)?
     .visit_field::<f64>("pickupAlt", Self::VT_PICKUPALT, false)?
     .visit_field::<bool>("termInd", Self::VT_TERMIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("authStatus", Self::VT_AUTHSTATUS, false)?
     .visit_field::<i32>("numPersons", Self::VT_NUMPERSONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("milClass", Self::VT_MILCLASS, false)?
     .visit_field::<i32>("natAlliance", Self::VT_NATALLIANCE, false)?
     .visit_field::<i32>("natAlliance1", Self::VT_NATALLIANCE1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("identity", Self::VT_IDENTITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("commEq1", Self::VT_COMMEQ1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("commEq2", Self::VT_COMMEQ2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("commEq3", Self::VT_COMMEQ3, false)?
     .visit_field::<f64>("txFreq", Self::VT_TXFREQ, false)?
     .visit_field::<f64>("rxFreq", Self::VT_RXFREQ, false)?
     .visit_field::<i32>("numNonAmbulatory", Self::VT_NUMNONAMBULATORY, false)?
     .visit_field::<i32>("numAmbulatory", Self::VT_NUMAMBULATORY, false)?
     .visit_field::<i32>("numAmbulatoryInjured", Self::VT_NUMAMBULATORYINJURED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("survivorRadio", Self::VT_SURVIVORRADIO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("survivorMessages", Self::VT_SURVIVORMESSAGES, false)?
     .visit_field::<bool>("beaconInd", Self::VT_BEACONIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("callSign", Self::VT_CALLSIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("textMsg", Self::VT_TEXTMSG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("authMethod", Self::VT_AUTHMETHOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("objectiveAreaInfo", Self::VT_OBJECTIVEAREAINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("executionInfo", Self::VT_EXECUTIONINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<PersonnelRecovery_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct PersonnelRecovery_IngestArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recovId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idWeatherReport: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pickupLat: f64,
    pub pickupLon: f64,
    pub pickupAlt: f64,
    pub termInd: bool,
    pub authStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub numPersons: i32,
    pub milClass: Option<flatbuffers::WIPOffset<&'a str>>,
    pub natAlliance: i32,
    pub natAlliance1: i32,
    pub identity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub commEq1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub commEq2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub commEq3: Option<flatbuffers::WIPOffset<&'a str>>,
    pub txFreq: f64,
    pub rxFreq: f64,
    pub numNonAmbulatory: i32,
    pub numAmbulatory: i32,
    pub numAmbulatoryInjured: i32,
    pub survivorRadio: Option<flatbuffers::WIPOffset<&'a str>>,
    pub survivorMessages: Option<flatbuffers::WIPOffset<&'a str>>,
    pub beaconInd: bool,
    pub callSign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub textMsg: Option<flatbuffers::WIPOffset<&'a str>>,
    pub authMethod: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objectiveAreaInfo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub executionInfo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: PersonnelRecovery_Ingest_dataMode_Enum,
}
impl<'a> Default for PersonnelRecovery_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    PersonnelRecovery_IngestArgs {
      id: None,
      classificationMarking: None,
      type_: None,
      msgTime: None,
      recovId: None,
      idWeatherReport: None,
      pickupLat: 0.0,
      pickupLon: 0.0,
      pickupAlt: 0.0,
      termInd: false,
      authStatus: None,
      numPersons: 0,
      milClass: None,
      natAlliance: 0,
      natAlliance1: 0,
      identity: None,
      commEq1: None,
      commEq2: None,
      commEq3: None,
      txFreq: 0.0,
      rxFreq: 0.0,
      numNonAmbulatory: 0,
      numAmbulatory: 0,
      numAmbulatoryInjured: 0,
      survivorRadio: None,
      survivorMessages: None,
      beaconInd: false,
      callSign: None,
      textMsg: None,
      authMethod: None,
      objectiveAreaInfo: None,
      executionInfo: None,
      origNetwork: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: PersonnelRecovery_Ingest_dataMode_Enum::REAL,
    }
  }
}

pub struct PersonnelRecovery_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PersonnelRecovery_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_msgTime(&mut self, msgTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_MSGTIME, msgTime);
  }
  #[inline]
  pub fn add_recovId(&mut self, recovId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_RECOVID, recovId);
  }
  #[inline]
  pub fn add_idWeatherReport(&mut self, idWeatherReport: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_IDWEATHERREPORT, idWeatherReport);
  }
  #[inline]
  pub fn add_pickupLat(&mut self, pickupLat: f64) {
    self.fbb_.push_slot::<f64>(PersonnelRecovery_Ingest::VT_PICKUPLAT, pickupLat, 0.0);
  }
  #[inline]
  pub fn add_pickupLon(&mut self, pickupLon: f64) {
    self.fbb_.push_slot::<f64>(PersonnelRecovery_Ingest::VT_PICKUPLON, pickupLon, 0.0);
  }
  #[inline]
  pub fn add_pickupAlt(&mut self, pickupAlt: f64) {
    self.fbb_.push_slot::<f64>(PersonnelRecovery_Ingest::VT_PICKUPALT, pickupAlt, 0.0);
  }
  #[inline]
  pub fn add_termInd(&mut self, termInd: bool) {
    self.fbb_.push_slot::<bool>(PersonnelRecovery_Ingest::VT_TERMIND, termInd, false);
  }
  #[inline]
  pub fn add_authStatus(&mut self, authStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_AUTHSTATUS, authStatus);
  }
  #[inline]
  pub fn add_numPersons(&mut self, numPersons: i32) {
    self.fbb_.push_slot::<i32>(PersonnelRecovery_Ingest::VT_NUMPERSONS, numPersons, 0);
  }
  #[inline]
  pub fn add_milClass(&mut self, milClass: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_MILCLASS, milClass);
  }
  #[inline]
  pub fn add_natAlliance(&mut self, natAlliance: i32) {
    self.fbb_.push_slot::<i32>(PersonnelRecovery_Ingest::VT_NATALLIANCE, natAlliance, 0);
  }
  #[inline]
  pub fn add_natAlliance1(&mut self, natAlliance1: i32) {
    self.fbb_.push_slot::<i32>(PersonnelRecovery_Ingest::VT_NATALLIANCE1, natAlliance1, 0);
  }
  #[inline]
  pub fn add_identity(&mut self, identity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_IDENTITY, identity);
  }
  #[inline]
  pub fn add_commEq1(&mut self, commEq1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_COMMEQ1, commEq1);
  }
  #[inline]
  pub fn add_commEq2(&mut self, commEq2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_COMMEQ2, commEq2);
  }
  #[inline]
  pub fn add_commEq3(&mut self, commEq3: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_COMMEQ3, commEq3);
  }
  #[inline]
  pub fn add_txFreq(&mut self, txFreq: f64) {
    self.fbb_.push_slot::<f64>(PersonnelRecovery_Ingest::VT_TXFREQ, txFreq, 0.0);
  }
  #[inline]
  pub fn add_rxFreq(&mut self, rxFreq: f64) {
    self.fbb_.push_slot::<f64>(PersonnelRecovery_Ingest::VT_RXFREQ, rxFreq, 0.0);
  }
  #[inline]
  pub fn add_numNonAmbulatory(&mut self, numNonAmbulatory: i32) {
    self.fbb_.push_slot::<i32>(PersonnelRecovery_Ingest::VT_NUMNONAMBULATORY, numNonAmbulatory, 0);
  }
  #[inline]
  pub fn add_numAmbulatory(&mut self, numAmbulatory: i32) {
    self.fbb_.push_slot::<i32>(PersonnelRecovery_Ingest::VT_NUMAMBULATORY, numAmbulatory, 0);
  }
  #[inline]
  pub fn add_numAmbulatoryInjured(&mut self, numAmbulatoryInjured: i32) {
    self.fbb_.push_slot::<i32>(PersonnelRecovery_Ingest::VT_NUMAMBULATORYINJURED, numAmbulatoryInjured, 0);
  }
  #[inline]
  pub fn add_survivorRadio(&mut self, survivorRadio: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_SURVIVORRADIO, survivorRadio);
  }
  #[inline]
  pub fn add_survivorMessages(&mut self, survivorMessages: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_SURVIVORMESSAGES, survivorMessages);
  }
  #[inline]
  pub fn add_beaconInd(&mut self, beaconInd: bool) {
    self.fbb_.push_slot::<bool>(PersonnelRecovery_Ingest::VT_BEACONIND, beaconInd, false);
  }
  #[inline]
  pub fn add_callSign(&mut self, callSign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_CALLSIGN, callSign);
  }
  #[inline]
  pub fn add_textMsg(&mut self, textMsg: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_TEXTMSG, textMsg);
  }
  #[inline]
  pub fn add_authMethod(&mut self, authMethod: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_AUTHMETHOD, authMethod);
  }
  #[inline]
  pub fn add_objectiveAreaInfo(&mut self, objectiveAreaInfo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_OBJECTIVEAREAINFO, objectiveAreaInfo);
  }
  #[inline]
  pub fn add_executionInfo(&mut self, executionInfo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_EXECUTIONINFO, executionInfo);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonnelRecovery_Ingest::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: PersonnelRecovery_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<PersonnelRecovery_Ingest_dataMode_Enum>(PersonnelRecovery_Ingest::VT_DATAMODE, dataMode, PersonnelRecovery_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PersonnelRecovery_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PersonnelRecovery_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PersonnelRecovery_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PersonnelRecovery_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PersonnelRecovery_Ingest");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("type_", &self.type_());
      ds.field("msgTime", &self.msgTime());
      ds.field("recovId", &self.recovId());
      ds.field("idWeatherReport", &self.idWeatherReport());
      ds.field("pickupLat", &self.pickupLat());
      ds.field("pickupLon", &self.pickupLon());
      ds.field("pickupAlt", &self.pickupAlt());
      ds.field("termInd", &self.termInd());
      ds.field("authStatus", &self.authStatus());
      ds.field("numPersons", &self.numPersons());
      ds.field("milClass", &self.milClass());
      ds.field("natAlliance", &self.natAlliance());
      ds.field("natAlliance1", &self.natAlliance1());
      ds.field("identity", &self.identity());
      ds.field("commEq1", &self.commEq1());
      ds.field("commEq2", &self.commEq2());
      ds.field("commEq3", &self.commEq3());
      ds.field("txFreq", &self.txFreq());
      ds.field("rxFreq", &self.rxFreq());
      ds.field("numNonAmbulatory", &self.numNonAmbulatory());
      ds.field("numAmbulatory", &self.numAmbulatory());
      ds.field("numAmbulatoryInjured", &self.numAmbulatoryInjured());
      ds.field("survivorRadio", &self.survivorRadio());
      ds.field("survivorMessages", &self.survivorMessages());
      ds.field("beaconInd", &self.beaconInd());
      ds.field("callSign", &self.callSign());
      ds.field("textMsg", &self.textMsg());
      ds.field("authMethod", &self.authMethod());
      ds.field("objectiveAreaInfo", &self.objectiveAreaInfo());
      ds.field("executionInfo", &self.executionInfo());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PersonnelRecovery_IngestT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub type_: Option<String>,
  pub msgTime: Option<String>,
  pub recovId: Option<String>,
  pub idWeatherReport: Option<String>,
  pub pickupLat: f64,
  pub pickupLon: f64,
  pub pickupAlt: f64,
  pub termInd: bool,
  pub authStatus: Option<String>,
  pub numPersons: i32,
  pub milClass: Option<String>,
  pub natAlliance: i32,
  pub natAlliance1: i32,
  pub identity: Option<String>,
  pub commEq1: Option<String>,
  pub commEq2: Option<String>,
  pub commEq3: Option<String>,
  pub txFreq: f64,
  pub rxFreq: f64,
  pub numNonAmbulatory: i32,
  pub numAmbulatory: i32,
  pub numAmbulatoryInjured: i32,
  pub survivorRadio: Option<String>,
  pub survivorMessages: Option<String>,
  pub beaconInd: bool,
  pub callSign: Option<String>,
  pub textMsg: Option<String>,
  pub authMethod: Option<String>,
  pub objectiveAreaInfo: Option<String>,
  pub executionInfo: Option<String>,
  pub origNetwork: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: PersonnelRecovery_Ingest_dataMode_Enum,
}
impl Default for PersonnelRecovery_IngestT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      type_: None,
      msgTime: None,
      recovId: None,
      idWeatherReport: None,
      pickupLat: 0.0,
      pickupLon: 0.0,
      pickupAlt: 0.0,
      termInd: false,
      authStatus: None,
      numPersons: 0,
      milClass: None,
      natAlliance: 0,
      natAlliance1: 0,
      identity: None,
      commEq1: None,
      commEq2: None,
      commEq3: None,
      txFreq: 0.0,
      rxFreq: 0.0,
      numNonAmbulatory: 0,
      numAmbulatory: 0,
      numAmbulatoryInjured: 0,
      survivorRadio: None,
      survivorMessages: None,
      beaconInd: false,
      callSign: None,
      textMsg: None,
      authMethod: None,
      objectiveAreaInfo: None,
      executionInfo: None,
      origNetwork: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: PersonnelRecovery_Ingest_dataMode_Enum::REAL,
    }
  }
}
impl PersonnelRecovery_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PersonnelRecovery_Ingest<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msgTime = self.msgTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let recovId = self.recovId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idWeatherReport = self.idWeatherReport.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pickupLat = self.pickupLat;
    let pickupLon = self.pickupLon;
    let pickupAlt = self.pickupAlt;
    let termInd = self.termInd;
    let authStatus = self.authStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let numPersons = self.numPersons;
    let milClass = self.milClass.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let natAlliance = self.natAlliance;
    let natAlliance1 = self.natAlliance1;
    let identity = self.identity.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let commEq1 = self.commEq1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let commEq2 = self.commEq2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let commEq3 = self.commEq3.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let txFreq = self.txFreq;
    let rxFreq = self.rxFreq;
    let numNonAmbulatory = self.numNonAmbulatory;
    let numAmbulatory = self.numAmbulatory;
    let numAmbulatoryInjured = self.numAmbulatoryInjured;
    let survivorRadio = self.survivorRadio.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let survivorMessages = self.survivorMessages.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let beaconInd = self.beaconInd;
    let callSign = self.callSign.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let textMsg = self.textMsg.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let authMethod = self.authMethod.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let objectiveAreaInfo = self.objectiveAreaInfo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let executionInfo = self.executionInfo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    PersonnelRecovery_Ingest::create(_fbb, &PersonnelRecovery_IngestArgs{
      id,
      classificationMarking,
      type_,
      msgTime,
      recovId,
      idWeatherReport,
      pickupLat,
      pickupLon,
      pickupAlt,
      termInd,
      authStatus,
      numPersons,
      milClass,
      natAlliance,
      natAlliance1,
      identity,
      commEq1,
      commEq2,
      commEq3,
      txFreq,
      rxFreq,
      numNonAmbulatory,
      numAmbulatory,
      numAmbulatoryInjured,
      survivorRadio,
      survivorMessages,
      beaconInd,
      callSign,
      textMsg,
      authMethod,
      objectiveAreaInfo,
      executionInfo,
      origNetwork,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PersonnelRecovery_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_personnel_recovery_ingest_unchecked`.
pub fn root_as_personnel_recovery_ingest(buf: &[u8]) -> Result<PersonnelRecovery_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<PersonnelRecovery_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PersonnelRecovery_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_personnel_recovery_ingest_unchecked`.
pub fn size_prefixed_root_as_personnel_recovery_ingest(buf: &[u8]) -> Result<PersonnelRecovery_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<PersonnelRecovery_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PersonnelRecovery_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_personnel_recovery_ingest_unchecked`.
pub fn root_as_personnel_recovery_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PersonnelRecovery_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<PersonnelRecovery_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PersonnelRecovery_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_personnel_recovery_ingest_unchecked`.
pub fn size_prefixed_root_as_personnel_recovery_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PersonnelRecovery_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<PersonnelRecovery_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PersonnelRecovery_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PersonnelRecovery_Ingest`.
pub unsafe fn root_as_personnel_recovery_ingest_unchecked(buf: &[u8]) -> PersonnelRecovery_Ingest {
  flatbuffers::root_unchecked::<PersonnelRecovery_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PersonnelRecovery_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PersonnelRecovery_Ingest`.
pub unsafe fn size_prefixed_root_as_personnel_recovery_ingest_unchecked(buf: &[u8]) -> PersonnelRecovery_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<PersonnelRecovery_Ingest>(buf)
}
pub const PERSONNEL_RECOVERY_INGEST_IDENTIFIER: &str = "PERS";

#[inline]
pub fn personnel_recovery_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PERSONNEL_RECOVERY_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn personnel_recovery_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PERSONNEL_RECOVERY_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_personnel_recovery_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<PersonnelRecovery_Ingest<'a>>) {
  fbb.finish(root, Some(PERSONNEL_RECOVERY_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_personnel_recovery_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<PersonnelRecovery_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(PERSONNEL_RECOVERY_INGEST_IDENTIFIER));
}
