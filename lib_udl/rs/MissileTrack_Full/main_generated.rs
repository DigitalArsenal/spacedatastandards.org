// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MISSILE_TRACK_FULL_ENV_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MISSILE_TRACK_FULL_ENV_ENUM: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MISSILE_TRACK_FULL_ENV_ENUM: [MissileTrack_Full_env_Enum; 6] = [
  MissileTrack_Full_env_Enum::AIR,
  MissileTrack_Full_env_Enum::LAND,
  MissileTrack_Full_env_Enum::SPACE,
  MissileTrack_Full_env_Enum::SURFACE,
  MissileTrack_Full_env_Enum::SUBSURFACE,
  MissileTrack_Full_env_Enum::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MissileTrack_Full_env_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl MissileTrack_Full_env_Enum {
  /// Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
  pub const AIR: Self = Self(0);
  /// On the surface of dry land.
  pub const LAND: Self = Self(1);
  /// Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
  pub const SPACE: Self = Self(2);
  /// On the surface of a body of water.
  pub const SURFACE: Self = Self(3);
  /// Below the surface of a body of water.
  pub const SUBSURFACE: Self = Self(4);
  /// Environment is not known.
  pub const UNKNOWN: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AIR,
    Self::LAND,
    Self::SPACE,
    Self::SURFACE,
    Self::SUBSURFACE,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AIR => Some("AIR"),
      Self::LAND => Some("LAND"),
      Self::SPACE => Some("SPACE"),
      Self::SURFACE => Some("SURFACE"),
      Self::SUBSURFACE => Some("SUBSURFACE"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MissileTrack_Full_env_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MissileTrack_Full_env_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MissileTrack_Full_env_Enum {
    type Output = MissileTrack_Full_env_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MissileTrack_Full_env_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MissileTrack_Full_env_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MissileTrack_Full_env_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MISSILE_TRACK_FULL_OBJ_IDENT_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MISSILE_TRACK_FULL_OBJ_IDENT_ENUM: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MISSILE_TRACK_FULL_OBJ_IDENT_ENUM: [MissileTrack_Full_objIdent_Enum; 7] = [
  MissileTrack_Full_objIdent_Enum::ASSUMED_FRIEND,
  MissileTrack_Full_objIdent_Enum::FRIEND,
  MissileTrack_Full_objIdent_Enum::HOSTILE,
  MissileTrack_Full_objIdent_Enum::NEUTRAL,
  MissileTrack_Full_objIdent_Enum::PENDING,
  MissileTrack_Full_objIdent_Enum::SUSPECT,
  MissileTrack_Full_objIdent_Enum::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MissileTrack_Full_objIdent_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl MissileTrack_Full_objIdent_Enum {
  /// Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  pub const ASSUMED_FRIEND: Self = Self(0);
  /// Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  pub const FRIEND: Self = Self(1);
  /// Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  pub const HOSTILE: Self = Self(2);
  /// Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  pub const NEUTRAL: Self = Self(3);
  /// Track object which has not been evaluated.
  pub const PENDING: Self = Self(4);
  /// Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  pub const SUSPECT: Self = Self(5);
  /// Track object which has been evaluated and does not meet criteria for any standard identity.
  pub const UNKNOWN: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ASSUMED_FRIEND,
    Self::FRIEND,
    Self::HOSTILE,
    Self::NEUTRAL,
    Self::PENDING,
    Self::SUSPECT,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ASSUMED_FRIEND => Some("ASSUMED_FRIEND"),
      Self::FRIEND => Some("FRIEND"),
      Self::HOSTILE => Some("HOSTILE"),
      Self::NEUTRAL => Some("NEUTRAL"),
      Self::PENDING => Some("PENDING"),
      Self::SUSPECT => Some("SUSPECT"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MissileTrack_Full_objIdent_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MissileTrack_Full_objIdent_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MissileTrack_Full_objIdent_Enum {
    type Output = MissileTrack_Full_objIdent_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MissileTrack_Full_objIdent_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MissileTrack_Full_objIdent_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MissileTrack_Full_objIdent_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MISSILE_TRACK_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MISSILE_TRACK_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MISSILE_TRACK_FULL_DATA_MODE_ENUM: [MissileTrack_Full_dataMode_Enum; 4] = [
  MissileTrack_Full_dataMode_Enum::REAL,
  MissileTrack_Full_dataMode_Enum::TEST,
  MissileTrack_Full_dataMode_Enum::SIMULATED,
  MissileTrack_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MissileTrack_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl MissileTrack_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MissileTrack_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MissileTrack_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MissileTrack_Full_dataMode_Enum {
    type Output = MissileTrack_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MissileTrack_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MissileTrack_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MissileTrack_Full_dataMode_Enum {}
pub enum MissileTrack_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// These services provide operations for querying of all available missile track details and amplifying missile data. A missile track is a position and optionally a heading/velocity of an object across all environments at a particular timestamp. It also includes optional information regarding the identity/type of missile, impact location, launch location and other amplifying object data, if known.
pub struct MissileTrack_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MissileTrack_Full<'a> {
  type Inner = MissileTrack_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MissileTrack_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_MSGTYPE: flatbuffers::VOffsetT = 8;
  pub const VT_MSGSUBTYPE: flatbuffers::VOffsetT = 10;
  pub const VT_MSGCREATEDATE: flatbuffers::VOffsetT = 12;
  pub const VT_ENV: flatbuffers::VOffsetT = 14;
  pub const VT_OBJTYPE: flatbuffers::VOffsetT = 16;
  pub const VT_OBJTYPECONF: flatbuffers::VOffsetT = 18;
  pub const VT_OBJPLAT: flatbuffers::VOffsetT = 20;
  pub const VT_OBJIDENT: flatbuffers::VOffsetT = 22;
  pub const VT_SPACEAMP: flatbuffers::VOffsetT = 24;
  pub const VT_OBJACT: flatbuffers::VOffsetT = 26;
  pub const VT_SPACESPECTYPE: flatbuffers::VOffsetT = 28;
  pub const VT_ACFTSUBTYPE: flatbuffers::VOffsetT = 30;
  pub const VT_NAME: flatbuffers::VOffsetT = 32;
  pub const VT_CALLSIGN: flatbuffers::VOffsetT = 34;
  pub const VT_LOSTTRKIND: flatbuffers::VOffsetT = 36;
  pub const VT_TRACKID: flatbuffers::VOffsetT = 38;
  pub const VT_PARENTTRACKID: flatbuffers::VOffsetT = 40;
  pub const VT_MUIDSRCTRK: flatbuffers::VOffsetT = 42;
  pub const VT_MUIDSRC: flatbuffers::VOffsetT = 44;
  pub const VT_ALERT: flatbuffers::VOffsetT = 46;
  pub const VT_MSLSTATUS: flatbuffers::VOffsetT = 48;
  pub const VT_TS: flatbuffers::VOffsetT = 50;
  pub const VT_AOURPTTYPE: flatbuffers::VOffsetT = 52;
  pub const VT_AOURPTDATA: flatbuffers::VOffsetT = 54;
  pub const VT_CONTAINMENT: flatbuffers::VOffsetT = 56;
  pub const VT_TRKCONF: flatbuffers::VOffsetT = 58;
  pub const VT_TRKQUAL: flatbuffers::VOffsetT = 60;
  pub const VT_ANGELEV: flatbuffers::VOffsetT = 62;
  pub const VT_SENMODE: flatbuffers::VOffsetT = 64;
  pub const VT_INFOSOURCE: flatbuffers::VOffsetT = 66;
  pub const VT_BOOSTING: flatbuffers::VOffsetT = 68;
  pub const VT_POLARSINGLOCLAT: flatbuffers::VOffsetT = 70;
  pub const VT_POLARSINGLOCLON: flatbuffers::VOffsetT = 72;
  pub const VT_EMGIND: flatbuffers::VOffsetT = 74;
  pub const VT_DROPPTIND: flatbuffers::VOffsetT = 76;
  pub const VT_SPACEAMPCONF: flatbuffers::VOffsetT = 78;
  pub const VT_LAUNCHTIME: flatbuffers::VOffsetT = 80;
  pub const VT_LAUNCHLAT: flatbuffers::VOffsetT = 82;
  pub const VT_LAUNCHLON: flatbuffers::VOffsetT = 84;
  pub const VT_AZCORR: flatbuffers::VOffsetT = 86;
  pub const VT_BURNOUTALT: flatbuffers::VOffsetT = 88;
  pub const VT_LAUNCHAOUTYPE: flatbuffers::VOffsetT = 90;
  pub const VT_LAUNCHAOUDATA: flatbuffers::VOffsetT = 92;
  pub const VT_IMPACTTIME: flatbuffers::VOffsetT = 94;
  pub const VT_IMPACTLAT: flatbuffers::VOffsetT = 96;
  pub const VT_IMPACTLON: flatbuffers::VOffsetT = 98;
  pub const VT_IMPACTAOUTYPE: flatbuffers::VOffsetT = 100;
  pub const VT_IMPACTAOUDATA: flatbuffers::VOffsetT = 102;
  pub const VT_VECTORS: flatbuffers::VOffsetT = 104;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 106;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 108;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 110;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 112;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 114;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 116;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MissileTrack_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MissileTrack_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<MissileTrack_Full<'bldr>> {
    let mut builder = MissileTrack_FullBuilder::new(_fbb);
    builder.add_impactLon(args.impactLon);
    builder.add_impactLat(args.impactLat);
    builder.add_burnoutAlt(args.burnoutAlt);
    builder.add_azCorr(args.azCorr);
    builder.add_launchLon(args.launchLon);
    builder.add_launchLat(args.launchLat);
    builder.add_polarSingLocLon(args.polarSingLocLon);
    builder.add_polarSingLocLat(args.polarSingLocLat);
    builder.add_angElev(args.angElev);
    builder.add_trkConf(args.trkConf);
    builder.add_containment(args.containment);
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.vectors { builder.add_vectors(x); }
    if let Some(x) = args.impactAouData { builder.add_impactAouData(x); }
    if let Some(x) = args.impactAouType { builder.add_impactAouType(x); }
    if let Some(x) = args.impactTime { builder.add_impactTime(x); }
    if let Some(x) = args.launchAouData { builder.add_launchAouData(x); }
    if let Some(x) = args.launchAouType { builder.add_launchAouType(x); }
    if let Some(x) = args.launchTime { builder.add_launchTime(x); }
    builder.add_spaceAmpConf(args.spaceAmpConf);
    if let Some(x) = args.infoSource { builder.add_infoSource(x); }
    if let Some(x) = args.senMode { builder.add_senMode(x); }
    builder.add_trkQual(args.trkQual);
    if let Some(x) = args.aouRptData { builder.add_aouRptData(x); }
    if let Some(x) = args.aouRptType { builder.add_aouRptType(x); }
    if let Some(x) = args.ts { builder.add_ts(x); }
    if let Some(x) = args.mslStatus { builder.add_mslStatus(x); }
    if let Some(x) = args.alert { builder.add_alert(x); }
    if let Some(x) = args.muidSrc { builder.add_muidSrc(x); }
    if let Some(x) = args.muidSrcTrk { builder.add_muidSrcTrk(x); }
    if let Some(x) = args.parentTrackId { builder.add_parentTrackId(x); }
    if let Some(x) = args.trackId { builder.add_trackId(x); }
    if let Some(x) = args.callSign { builder.add_callSign(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.acftSubType { builder.add_acftSubType(x); }
    if let Some(x) = args.spaceSpecType { builder.add_spaceSpecType(x); }
    if let Some(x) = args.objAct { builder.add_objAct(x); }
    if let Some(x) = args.spaceAmp { builder.add_spaceAmp(x); }
    if let Some(x) = args.objPlat { builder.add_objPlat(x); }
    builder.add_objTypeConf(args.objTypeConf);
    if let Some(x) = args.objType { builder.add_objType(x); }
    if let Some(x) = args.msgCreateDate { builder.add_msgCreateDate(x); }
    if let Some(x) = args.msgSubType { builder.add_msgSubType(x); }
    if let Some(x) = args.msgType { builder.add_msgType(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_dropPtInd(args.dropPtInd);
    builder.add_emgInd(args.emgInd);
    builder.add_boosting(args.boosting);
    builder.add_lostTrkInd(args.lostTrkInd);
    builder.add_objIdent(args.objIdent);
    builder.add_env(args.env);
    builder.finish()
  }

  pub fn unpack(&self) -> MissileTrack_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let msgType = self.msgType().map(|x| {
      x.to_string()
    });
    let msgSubType = self.msgSubType().map(|x| {
      x.to_string()
    });
    let msgCreateDate = self.msgCreateDate().map(|x| {
      x.to_string()
    });
    let env = self.env();
    let objType = self.objType().map(|x| {
      x.to_string()
    });
    let objTypeConf = self.objTypeConf();
    let objPlat = self.objPlat().map(|x| {
      x.to_string()
    });
    let objIdent = self.objIdent();
    let spaceAmp = self.spaceAmp().map(|x| {
      x.to_string()
    });
    let objAct = self.objAct().map(|x| {
      x.to_string()
    });
    let spaceSpecType = self.spaceSpecType().map(|x| {
      x.to_string()
    });
    let acftSubType = self.acftSubType().map(|x| {
      x.to_string()
    });
    let name = self.name().map(|x| {
      x.to_string()
    });
    let callSign = self.callSign().map(|x| {
      x.to_string()
    });
    let lostTrkInd = self.lostTrkInd();
    let trackId = self.trackId().map(|x| {
      x.to_string()
    });
    let parentTrackId = self.parentTrackId().map(|x| {
      x.to_string()
    });
    let muidSrcTrk = self.muidSrcTrk().map(|x| {
      x.to_string()
    });
    let muidSrc = self.muidSrc().map(|x| {
      x.to_string()
    });
    let alert = self.alert().map(|x| {
      x.to_string()
    });
    let mslStatus = self.mslStatus().map(|x| {
      x.to_string()
    });
    let ts = self.ts().map(|x| {
      x.to_string()
    });
    let aouRptType = self.aouRptType().map(|x| {
      x.to_string()
    });
    let aouRptData = self.aouRptData().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let containment = self.containment();
    let trkConf = self.trkConf();
    let trkQual = self.trkQual();
    let angElev = self.angElev();
    let senMode = self.senMode().map(|x| {
      x.to_string()
    });
    let infoSource = self.infoSource().map(|x| {
      x.to_string()
    });
    let boosting = self.boosting();
    let polarSingLocLat = self.polarSingLocLat();
    let polarSingLocLon = self.polarSingLocLon();
    let emgInd = self.emgInd();
    let dropPtInd = self.dropPtInd();
    let spaceAmpConf = self.spaceAmpConf();
    let launchTime = self.launchTime().map(|x| {
      x.to_string()
    });
    let launchLat = self.launchLat();
    let launchLon = self.launchLon();
    let azCorr = self.azCorr();
    let burnoutAlt = self.burnoutAlt();
    let launchAouType = self.launchAouType().map(|x| {
      x.to_string()
    });
    let launchAouData = self.launchAouData().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let impactTime = self.impactTime().map(|x| {
      x.to_string()
    });
    let impactLat = self.impactLat();
    let impactLon = self.impactLon();
    let impactAouType = self.impactAouType().map(|x| {
      x.to_string()
    });
    let impactAouData = self.impactAouData().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let vectors = self.vectors().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    MissileTrack_FullT {
      id,
      classificationMarking,
      msgType,
      msgSubType,
      msgCreateDate,
      env,
      objType,
      objTypeConf,
      objPlat,
      objIdent,
      spaceAmp,
      objAct,
      spaceSpecType,
      acftSubType,
      name,
      callSign,
      lostTrkInd,
      trackId,
      parentTrackId,
      muidSrcTrk,
      muidSrc,
      alert,
      mslStatus,
      ts,
      aouRptType,
      aouRptData,
      containment,
      trkConf,
      trkQual,
      angElev,
      senMode,
      infoSource,
      boosting,
      polarSingLocLat,
      polarSingLocLon,
      emgInd,
      dropPtInd,
      spaceAmpConf,
      launchTime,
      launchLat,
      launchLon,
      azCorr,
      burnoutAlt,
      launchAouType,
      launchAouData,
      impactTime,
      impactLat,
      impactLon,
      impactAouType,
      impactAouData,
      vectors,
      origNetwork,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system if not provided on create operations.
  /// Example: /// Example: MissileTrack_ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// The type of external message from which this request originated.
  /// Example: /// Example: MSG-TYPE
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn msgType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_MSGTYPE, None)}
  }
  /// The message subtype is a finer grain categorization of message types as many messages can contain a variety of data content within the same structure.  Examples include but are not limited to Initial, Final, Launch, Update, etc.  Users should consult the appropriate documentation, based on the message type, for the definitions of the subtypes that apply to that message.
  /// Example: /// Example: Update
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn msgSubType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_MSGSUBTYPE, None)}
  }
  /// The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-04-25T08:17:01.346Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn msgCreateDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_MSGCREATEDATE, None)}
  }
  /// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
  ///  AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///  LAND: On the surface of dry land.
  ///  SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///  SURFACE: On the surface of a body of water.
  ///  SUBSURFACE: Below the surface of a body of water.
  ///  UNKNOWN: Environment is not known.
  /// Example: /// Example: AIR
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn env(&self) -> MissileTrack_Full_env_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MissileTrack_Full_env_Enum>(MissileTrack_Full::VT_ENV, Some(MissileTrack_Full_env_Enum::AIR)).unwrap()}
  }
  /// The type of object to which this record refers. The object type may be updated in later records based on assessment of additional data.
  /// Example: /// Example: Ballistic
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn objType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_OBJTYPE, None)}
  }
  /// Confidence of the object type, 0-100.
  /// Example: /// Example: 90
  /// Constraints: No constraints specified.
  #[inline]
  pub fn objTypeConf(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissileTrack_Full::VT_OBJTYPECONF, Some(0)).unwrap()}
  }
  /// Space Platform field along with the Space Activity field further defines the identity of a Space track (examples: SATELLITE, WEAPON, PATROL). The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
  /// Example: /// Example: WEAPON
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn objPlat(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_OBJPLAT, None)}
  }
  /// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
  ///  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  ///  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  ///  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  ///  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  ///  PENDING: Track object which has not been evaluated.
  ///  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  ///  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
  /// Example: /// Example: FRIEND
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn objIdent(&self) -> MissileTrack_Full_objIdent_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MissileTrack_Full_objIdent_Enum>(MissileTrack_Full::VT_OBJIDENT, Some(MissileTrack_Full_objIdent_Enum::ASSUMED_FRIEND)).unwrap()}
  }
  /// Space amplification indicates additional information on the space environment being reported (examples: NUCLEAR WARHEAD, FUEL-AIR EXPLOSIVE WARHEAD, DEBRIS).
  /// Example: /// Example: NUCLEAR WARHEAD
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn spaceAmp(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_SPACEAMP, None)}
  }
  /// Space activity (examples: RECONNAISSANCE, ANTISPACE WARFARE, TELEVISION). The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.
  /// Example: /// Example: HOLDING
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn objAct(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_OBJACT, None)}
  }
  /// Specific type of point or track with an environment of space.
  /// Example: /// Example: SS-21_MOD_2_CRBM
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn spaceSpecType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_SPACESPECTYPE, None)}
  }
  /// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM. 
  /// &nbsp;SRBM - Short-Range Ballistic Missile
  /// &nbsp;MRBM - Medium-Range Ballistic Missile
  /// &nbsp;IRBM - Intermediate-Range Ballistic Missile
  /// &nbsp;LRBM - Long-Range Ballistic Missile
  /// &nbsp;ICBM - Intercontinental Ballistic Missile
  /// &nbsp;SLBM - Submarine-Launched Ballistic Missile.
  /// Example: /// Example: SLBM
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn acftSubType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_ACFTSUBTYPE, None)}
  }
  /// Track name.
  /// Example: /// Example: TRACK-NAME
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_NAME, None)}
  }
  /// The call sign currently assigned to the track object.
  /// Example: /// Example: Charlie
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn callSign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_CALLSIGN, None)}
  }
  /// Indicates whether or not the missile is considered lost.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lostTrkInd(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MissileTrack_Full::VT_LOSTTRKIND, Some(false)).unwrap()}
  }
  /// Track ID within the originating system.
  /// Example: /// Example: 102288
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn trackId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_TRACKID, None)}
  }
  /// Track ID of the parent track, within the originating system, from which the track was developed.
  /// Example: /// Example: 102288
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn parentTrackId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_PARENTTRACKID, None)}
  }
  /// Track ID for the source of the missile-unique identifier.
  /// Example: /// Example: MUID-SRC-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn muidSrcTrk(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_MUIDSRCTRK, None)}
  }
  /// Source of the missile-unique identifier (MUID).
  /// Example: /// Example: MUID-SRC
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn muidSrc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_MUIDSRC, None)}
  }
  /// A track may be designated as a non-alert track or an alert track.
  /// Examples include but are not limited to:
  /// &nbsp;Non-alert tracks – choose None (Blank).
  /// &nbsp;Alert tracks – enter the proper alert classification:
  /// &nbsp;HIT - High Interest Track
  /// &nbsp;TGT - Target
  /// &nbsp;SUS - Suspect Carrier
  /// &nbsp;NSP - Cleared Suspect.
  /// Example: /// Example: HIT
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn alert(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_ALERT, None)}
  }
  /// Missile status enumeration examples include but are not limited to:
  /// &nbsp;AT LAUNCH 
  /// &nbsp;AT OBSERVATION 
  /// &nbsp;FLYING 
  /// &nbsp;IMPACTED 
  /// &nbsp;LOST 
  /// &nbsp;STALE
  /// &nbsp;DEBRIS.
  /// Example: /// Example: AT LAUNCH
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn mslStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_MSLSTATUS, None)}
  }
  /// The receipt time of the data by the processing system, in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ts(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_TS, None)}
  }
  /// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 40
  #[inline]
  pub fn aouRptType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_AOURPTTYPE, None)}
  }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
  /// &nbsp;ELLIPSE:
  /// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
  /// &nbsp;&nbsp;a1 - semi-major axis in kilometers
  /// &nbsp;&nbsp;a2 - semi-minor axis in kilometers
  /// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
  /// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
  /// &nbsp;&nbsp;a1 - length of bearing box in kilometers
  /// &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
  /// &nbsp;OTHER (All other type values):
  /// &nbsp;&nbsp;brg - line of bearing in degrees true
  /// &nbsp;&nbsp;a1 - bearing error in degrees
  /// &nbsp;&nbsp;a2 - estimated range in kilometers.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn aouRptData(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MissileTrack_Full::VT_AOURPTDATA, None)}
  }
  /// The percentage of time that the estimated AoU will "cover" the true position of the track.
  /// Example: /// Example: 90.64
  /// Constraints: No constraints specified.
  #[inline]
  pub fn containment(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrack_Full::VT_CONTAINMENT, Some(0.0)).unwrap()}
  }
  /// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
  /// Example: /// Example: 0.95
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trkConf(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrack_Full::VT_TRKCONF, Some(0.0)).unwrap()}
  }
  /// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track, with higher values indicating higher track quality; i.e., lower errors in reported position.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trkQual(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissileTrack_Full::VT_TRKQUAL, Some(0)).unwrap()}
  }
  /// Angle of elevation/depression between observer and missile in degrees.
  /// Example: /// Example: 15.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn angElev(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrack_Full::VT_ANGELEV, Some(0.0)).unwrap()}
  }
  /// Last report type received from the sensor (for example, OBSBO = observation burnout).
  /// Example: /// Example: OBSBO
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn senMode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_SENMODE, None)}
  }
  /// Source code for source of information used to detect track.
  /// Example: /// Example: S1
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn infoSource(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_INFOSOURCE, None)}
  }
  /// Indicates whether or not the missile is currently in a state of boosting.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn boosting(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MissileTrack_Full::VT_BOOSTING, Some(false)).unwrap()}
  }
  /// Azimuth corridor reference point latitude.
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polarSingLocLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrack_Full::VT_POLARSINGLOCLAT, Some(0.0)).unwrap()}
  }
  /// Azimuth corridor reference point longitude.
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polarSingLocLon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrack_Full::VT_POLARSINGLOCLON, Some(0.0)).unwrap()}
  }
  /// Indicates whether or not a track has an emergency.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn emgInd(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MissileTrack_Full::VT_EMGIND, Some(false)).unwrap()}
  }
  /// The drop-point indicator setting.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dropPtInd(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MissileTrack_Full::VT_DROPPTIND, Some(false)).unwrap()}
  }
  /// Confidence level of the amplifying characteristics. Values range from 0 to 6.
  /// Example: /// Example: 6
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spaceAmpConf(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissileTrack_Full::VT_SPACEAMPCONF, Some(0)).unwrap()}
  }
  /// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_LAUNCHTIME, None)}
  }
  /// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrack_Full::VT_LAUNCHLAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchLon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrack_Full::VT_LAUNCHLON, Some(0.0)).unwrap()}
  }
  /// Missile azimuth corridor data.
  /// Example: /// Example: 12.876
  /// Constraints: No constraints specified.
  #[inline]
  pub fn azCorr(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrack_Full::VT_AZCORR, Some(0.0)).unwrap()}
  }
  /// Track point burnout altitude relative to WGS-84 ellipsoid, in kilometers.
  /// Example: /// Example: 30567.452
  /// Constraints: No constraints specified.
  #[inline]
  pub fn burnoutAlt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrack_Full::VT_BURNOUTALT, Some(0.0)).unwrap()}
  }
  /// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 40
  #[inline]
  pub fn launchAouType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_LAUNCHAOUTYPE, None)}
  }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
  /// &nbsp;ELLIPSE:
  /// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
  /// &nbsp;&nbsp;a1 - semi-major axis in kilometers
  /// &nbsp;&nbsp;a2 - semi-minor axis in kilometers
  /// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
  /// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
  /// &nbsp;&nbsp;a1 - length of bearing box in kilometers
  /// &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
  /// &nbsp;OTHER (All other type values):
  /// &nbsp;&nbsp;brg - line of bearing in degrees true
  /// &nbsp;&nbsp;a1 - bearing error in degrees
  /// &nbsp;&nbsp;a2 - estimated range in kilometers.
  /// Example: /// Example: [1.23, 2.34, 3.45]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn launchAouData(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MissileTrack_Full::VT_LAUNCHAOUDATA, None)}
  }
  /// Estimated time of impact timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn impactTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_IMPACTTIME, None)}
  }
  /// WGS-84 latitude of the missile object impact point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  #[inline]
  pub fn impactLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrack_Full::VT_IMPACTLAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude of the missile object impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  #[inline]
  pub fn impactLon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrack_Full::VT_IMPACTLON, Some(0.0)).unwrap()}
  }
  /// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 40
  #[inline]
  pub fn impactAouType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_IMPACTAOUTYPE, None)}
  }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
  /// &nbsp;ELLIPSE:
  /// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
  /// &nbsp;&nbsp;a1 - semi-major axis in kilometers
  /// &nbsp;&nbsp;a2 - semi-minor axis in kilometers
  /// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
  /// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
  /// &nbsp;&nbsp;a1 - length of bearing box in kilometers
  /// &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
  /// &nbsp;OTHER (All other type values):
  /// &nbsp;&nbsp;brg - line of bearing in degrees true
  /// &nbsp;&nbsp;a1 - bearing error in degrees
  /// &nbsp;&nbsp;a2 - estimated range in kilometers.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn impactAouData(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MissileTrack_Full::VT_IMPACTAOUDATA, None)}
  }
  /// Array of MissileTrackVector objects. Missile track vectors are cartesian vectors of position, velocity, and acceleration that, together with their time, 'epoch', uniquely determine the trajectory of the missile. ECEF is the preferred coordinate frame but in some cases data may be in another frame as specified by 'referenceFrame', depending on the provider.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vectors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MissileTrack_Full::VT_VECTORS, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_ORIGNETWORK, None)}
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2021-02-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrack_Full::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> MissileTrack_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MissileTrack_Full_dataMode_Enum>(MissileTrack_Full::VT_DATAMODE, Some(MissileTrack_Full_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MissileTrack_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msgType", Self::VT_MSGTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msgSubType", Self::VT_MSGSUBTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msgCreateDate", Self::VT_MSGCREATEDATE, false)?
     .visit_field::<MissileTrack_Full_env_Enum>("env", Self::VT_ENV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("objType", Self::VT_OBJTYPE, false)?
     .visit_field::<i32>("objTypeConf", Self::VT_OBJTYPECONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("objPlat", Self::VT_OBJPLAT, false)?
     .visit_field::<MissileTrack_Full_objIdent_Enum>("objIdent", Self::VT_OBJIDENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("spaceAmp", Self::VT_SPACEAMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("objAct", Self::VT_OBJACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("spaceSpecType", Self::VT_SPACESPECTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("acftSubType", Self::VT_ACFTSUBTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("callSign", Self::VT_CALLSIGN, false)?
     .visit_field::<bool>("lostTrkInd", Self::VT_LOSTTRKIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trackId", Self::VT_TRACKID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("parentTrackId", Self::VT_PARENTTRACKID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("muidSrcTrk", Self::VT_MUIDSRCTRK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("muidSrc", Self::VT_MUIDSRC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alert", Self::VT_ALERT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mslStatus", Self::VT_MSLSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ts", Self::VT_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("aouRptType", Self::VT_AOURPTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("aouRptData", Self::VT_AOURPTDATA, false)?
     .visit_field::<f64>("containment", Self::VT_CONTAINMENT, false)?
     .visit_field::<f64>("trkConf", Self::VT_TRKCONF, false)?
     .visit_field::<i32>("trkQual", Self::VT_TRKQUAL, false)?
     .visit_field::<f64>("angElev", Self::VT_ANGELEV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("senMode", Self::VT_SENMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("infoSource", Self::VT_INFOSOURCE, false)?
     .visit_field::<bool>("boosting", Self::VT_BOOSTING, false)?
     .visit_field::<f64>("polarSingLocLat", Self::VT_POLARSINGLOCLAT, false)?
     .visit_field::<f64>("polarSingLocLon", Self::VT_POLARSINGLOCLON, false)?
     .visit_field::<bool>("emgInd", Self::VT_EMGIND, false)?
     .visit_field::<bool>("dropPtInd", Self::VT_DROPPTIND, false)?
     .visit_field::<i32>("spaceAmpConf", Self::VT_SPACEAMPCONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("launchTime", Self::VT_LAUNCHTIME, false)?
     .visit_field::<f64>("launchLat", Self::VT_LAUNCHLAT, false)?
     .visit_field::<f64>("launchLon", Self::VT_LAUNCHLON, false)?
     .visit_field::<f64>("azCorr", Self::VT_AZCORR, false)?
     .visit_field::<f64>("burnoutAlt", Self::VT_BURNOUTALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("launchAouType", Self::VT_LAUNCHAOUTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("launchAouData", Self::VT_LAUNCHAOUDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("impactTime", Self::VT_IMPACTTIME, false)?
     .visit_field::<f64>("impactLat", Self::VT_IMPACTLAT, false)?
     .visit_field::<f64>("impactLon", Self::VT_IMPACTLON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("impactAouType", Self::VT_IMPACTAOUTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("impactAouData", Self::VT_IMPACTAOUDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("vectors", Self::VT_VECTORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<MissileTrack_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct MissileTrack_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgSubType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgCreateDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub env: MissileTrack_Full_env_Enum,
    pub objType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objTypeConf: i32,
    pub objPlat: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objIdent: MissileTrack_Full_objIdent_Enum,
    pub spaceAmp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objAct: Option<flatbuffers::WIPOffset<&'a str>>,
    pub spaceSpecType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub acftSubType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub callSign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lostTrkInd: bool,
    pub trackId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub parentTrackId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub muidSrcTrk: Option<flatbuffers::WIPOffset<&'a str>>,
    pub muidSrc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub alert: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mslStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub aouRptType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub aouRptData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub containment: f64,
    pub trkConf: f64,
    pub trkQual: i32,
    pub angElev: f64,
    pub senMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub infoSource: Option<flatbuffers::WIPOffset<&'a str>>,
    pub boosting: bool,
    pub polarSingLocLat: f64,
    pub polarSingLocLon: f64,
    pub emgInd: bool,
    pub dropPtInd: bool,
    pub spaceAmpConf: i32,
    pub launchTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub launchLat: f64,
    pub launchLon: f64,
    pub azCorr: f64,
    pub burnoutAlt: f64,
    pub launchAouType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub launchAouData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub impactTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub impactLat: f64,
    pub impactLon: f64,
    pub impactAouType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub impactAouData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub vectors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: MissileTrack_Full_dataMode_Enum,
}
impl<'a> Default for MissileTrack_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    MissileTrack_FullArgs {
      id: None,
      classificationMarking: None,
      msgType: None,
      msgSubType: None,
      msgCreateDate: None,
      env: MissileTrack_Full_env_Enum::AIR,
      objType: None,
      objTypeConf: 0,
      objPlat: None,
      objIdent: MissileTrack_Full_objIdent_Enum::ASSUMED_FRIEND,
      spaceAmp: None,
      objAct: None,
      spaceSpecType: None,
      acftSubType: None,
      name: None,
      callSign: None,
      lostTrkInd: false,
      trackId: None,
      parentTrackId: None,
      muidSrcTrk: None,
      muidSrc: None,
      alert: None,
      mslStatus: None,
      ts: None,
      aouRptType: None,
      aouRptData: None,
      containment: 0.0,
      trkConf: 0.0,
      trkQual: 0,
      angElev: 0.0,
      senMode: None,
      infoSource: None,
      boosting: false,
      polarSingLocLat: 0.0,
      polarSingLocLon: 0.0,
      emgInd: false,
      dropPtInd: false,
      spaceAmpConf: 0,
      launchTime: None,
      launchLat: 0.0,
      launchLon: 0.0,
      azCorr: 0.0,
      burnoutAlt: 0.0,
      launchAouType: None,
      launchAouData: None,
      impactTime: None,
      impactLat: 0.0,
      impactLon: 0.0,
      impactAouType: None,
      impactAouData: None,
      vectors: None,
      origNetwork: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: MissileTrack_Full_dataMode_Enum::REAL,
    }
  }
}

pub struct MissileTrack_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MissileTrack_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_msgType(&mut self, msgType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_MSGTYPE, msgType);
  }
  #[inline]
  pub fn add_msgSubType(&mut self, msgSubType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_MSGSUBTYPE, msgSubType);
  }
  #[inline]
  pub fn add_msgCreateDate(&mut self, msgCreateDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_MSGCREATEDATE, msgCreateDate);
  }
  #[inline]
  pub fn add_env(&mut self, env: MissileTrack_Full_env_Enum) {
    self.fbb_.push_slot::<MissileTrack_Full_env_Enum>(MissileTrack_Full::VT_ENV, env, MissileTrack_Full_env_Enum::AIR);
  }
  #[inline]
  pub fn add_objType(&mut self, objType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_OBJTYPE, objType);
  }
  #[inline]
  pub fn add_objTypeConf(&mut self, objTypeConf: i32) {
    self.fbb_.push_slot::<i32>(MissileTrack_Full::VT_OBJTYPECONF, objTypeConf, 0);
  }
  #[inline]
  pub fn add_objPlat(&mut self, objPlat: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_OBJPLAT, objPlat);
  }
  #[inline]
  pub fn add_objIdent(&mut self, objIdent: MissileTrack_Full_objIdent_Enum) {
    self.fbb_.push_slot::<MissileTrack_Full_objIdent_Enum>(MissileTrack_Full::VT_OBJIDENT, objIdent, MissileTrack_Full_objIdent_Enum::ASSUMED_FRIEND);
  }
  #[inline]
  pub fn add_spaceAmp(&mut self, spaceAmp: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_SPACEAMP, spaceAmp);
  }
  #[inline]
  pub fn add_objAct(&mut self, objAct: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_OBJACT, objAct);
  }
  #[inline]
  pub fn add_spaceSpecType(&mut self, spaceSpecType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_SPACESPECTYPE, spaceSpecType);
  }
  #[inline]
  pub fn add_acftSubType(&mut self, acftSubType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_ACFTSUBTYPE, acftSubType);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_NAME, name);
  }
  #[inline]
  pub fn add_callSign(&mut self, callSign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_CALLSIGN, callSign);
  }
  #[inline]
  pub fn add_lostTrkInd(&mut self, lostTrkInd: bool) {
    self.fbb_.push_slot::<bool>(MissileTrack_Full::VT_LOSTTRKIND, lostTrkInd, false);
  }
  #[inline]
  pub fn add_trackId(&mut self, trackId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_TRACKID, trackId);
  }
  #[inline]
  pub fn add_parentTrackId(&mut self, parentTrackId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_PARENTTRACKID, parentTrackId);
  }
  #[inline]
  pub fn add_muidSrcTrk(&mut self, muidSrcTrk: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_MUIDSRCTRK, muidSrcTrk);
  }
  #[inline]
  pub fn add_muidSrc(&mut self, muidSrc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_MUIDSRC, muidSrc);
  }
  #[inline]
  pub fn add_alert(&mut self, alert: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_ALERT, alert);
  }
  #[inline]
  pub fn add_mslStatus(&mut self, mslStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_MSLSTATUS, mslStatus);
  }
  #[inline]
  pub fn add_ts(&mut self, ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_TS, ts);
  }
  #[inline]
  pub fn add_aouRptType(&mut self, aouRptType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_AOURPTTYPE, aouRptType);
  }
  #[inline]
  pub fn add_aouRptData(&mut self, aouRptData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_AOURPTDATA, aouRptData);
  }
  #[inline]
  pub fn add_containment(&mut self, containment: f64) {
    self.fbb_.push_slot::<f64>(MissileTrack_Full::VT_CONTAINMENT, containment, 0.0);
  }
  #[inline]
  pub fn add_trkConf(&mut self, trkConf: f64) {
    self.fbb_.push_slot::<f64>(MissileTrack_Full::VT_TRKCONF, trkConf, 0.0);
  }
  #[inline]
  pub fn add_trkQual(&mut self, trkQual: i32) {
    self.fbb_.push_slot::<i32>(MissileTrack_Full::VT_TRKQUAL, trkQual, 0);
  }
  #[inline]
  pub fn add_angElev(&mut self, angElev: f64) {
    self.fbb_.push_slot::<f64>(MissileTrack_Full::VT_ANGELEV, angElev, 0.0);
  }
  #[inline]
  pub fn add_senMode(&mut self, senMode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_SENMODE, senMode);
  }
  #[inline]
  pub fn add_infoSource(&mut self, infoSource: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_INFOSOURCE, infoSource);
  }
  #[inline]
  pub fn add_boosting(&mut self, boosting: bool) {
    self.fbb_.push_slot::<bool>(MissileTrack_Full::VT_BOOSTING, boosting, false);
  }
  #[inline]
  pub fn add_polarSingLocLat(&mut self, polarSingLocLat: f64) {
    self.fbb_.push_slot::<f64>(MissileTrack_Full::VT_POLARSINGLOCLAT, polarSingLocLat, 0.0);
  }
  #[inline]
  pub fn add_polarSingLocLon(&mut self, polarSingLocLon: f64) {
    self.fbb_.push_slot::<f64>(MissileTrack_Full::VT_POLARSINGLOCLON, polarSingLocLon, 0.0);
  }
  #[inline]
  pub fn add_emgInd(&mut self, emgInd: bool) {
    self.fbb_.push_slot::<bool>(MissileTrack_Full::VT_EMGIND, emgInd, false);
  }
  #[inline]
  pub fn add_dropPtInd(&mut self, dropPtInd: bool) {
    self.fbb_.push_slot::<bool>(MissileTrack_Full::VT_DROPPTIND, dropPtInd, false);
  }
  #[inline]
  pub fn add_spaceAmpConf(&mut self, spaceAmpConf: i32) {
    self.fbb_.push_slot::<i32>(MissileTrack_Full::VT_SPACEAMPCONF, spaceAmpConf, 0);
  }
  #[inline]
  pub fn add_launchTime(&mut self, launchTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_LAUNCHTIME, launchTime);
  }
  #[inline]
  pub fn add_launchLat(&mut self, launchLat: f64) {
    self.fbb_.push_slot::<f64>(MissileTrack_Full::VT_LAUNCHLAT, launchLat, 0.0);
  }
  #[inline]
  pub fn add_launchLon(&mut self, launchLon: f64) {
    self.fbb_.push_slot::<f64>(MissileTrack_Full::VT_LAUNCHLON, launchLon, 0.0);
  }
  #[inline]
  pub fn add_azCorr(&mut self, azCorr: f64) {
    self.fbb_.push_slot::<f64>(MissileTrack_Full::VT_AZCORR, azCorr, 0.0);
  }
  #[inline]
  pub fn add_burnoutAlt(&mut self, burnoutAlt: f64) {
    self.fbb_.push_slot::<f64>(MissileTrack_Full::VT_BURNOUTALT, burnoutAlt, 0.0);
  }
  #[inline]
  pub fn add_launchAouType(&mut self, launchAouType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_LAUNCHAOUTYPE, launchAouType);
  }
  #[inline]
  pub fn add_launchAouData(&mut self, launchAouData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_LAUNCHAOUDATA, launchAouData);
  }
  #[inline]
  pub fn add_impactTime(&mut self, impactTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_IMPACTTIME, impactTime);
  }
  #[inline]
  pub fn add_impactLat(&mut self, impactLat: f64) {
    self.fbb_.push_slot::<f64>(MissileTrack_Full::VT_IMPACTLAT, impactLat, 0.0);
  }
  #[inline]
  pub fn add_impactLon(&mut self, impactLon: f64) {
    self.fbb_.push_slot::<f64>(MissileTrack_Full::VT_IMPACTLON, impactLon, 0.0);
  }
  #[inline]
  pub fn add_impactAouType(&mut self, impactAouType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_IMPACTAOUTYPE, impactAouType);
  }
  #[inline]
  pub fn add_impactAouData(&mut self, impactAouData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_IMPACTAOUDATA, impactAouData);
  }
  #[inline]
  pub fn add_vectors(&mut self, vectors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_VECTORS, vectors);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrack_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: MissileTrack_Full_dataMode_Enum) {
    self.fbb_.push_slot::<MissileTrack_Full_dataMode_Enum>(MissileTrack_Full::VT_DATAMODE, dataMode, MissileTrack_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MissileTrack_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MissileTrack_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MissileTrack_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MissileTrack_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MissileTrack_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("msgType", &self.msgType());
      ds.field("msgSubType", &self.msgSubType());
      ds.field("msgCreateDate", &self.msgCreateDate());
      ds.field("env", &self.env());
      ds.field("objType", &self.objType());
      ds.field("objTypeConf", &self.objTypeConf());
      ds.field("objPlat", &self.objPlat());
      ds.field("objIdent", &self.objIdent());
      ds.field("spaceAmp", &self.spaceAmp());
      ds.field("objAct", &self.objAct());
      ds.field("spaceSpecType", &self.spaceSpecType());
      ds.field("acftSubType", &self.acftSubType());
      ds.field("name", &self.name());
      ds.field("callSign", &self.callSign());
      ds.field("lostTrkInd", &self.lostTrkInd());
      ds.field("trackId", &self.trackId());
      ds.field("parentTrackId", &self.parentTrackId());
      ds.field("muidSrcTrk", &self.muidSrcTrk());
      ds.field("muidSrc", &self.muidSrc());
      ds.field("alert", &self.alert());
      ds.field("mslStatus", &self.mslStatus());
      ds.field("ts", &self.ts());
      ds.field("aouRptType", &self.aouRptType());
      ds.field("aouRptData", &self.aouRptData());
      ds.field("containment", &self.containment());
      ds.field("trkConf", &self.trkConf());
      ds.field("trkQual", &self.trkQual());
      ds.field("angElev", &self.angElev());
      ds.field("senMode", &self.senMode());
      ds.field("infoSource", &self.infoSource());
      ds.field("boosting", &self.boosting());
      ds.field("polarSingLocLat", &self.polarSingLocLat());
      ds.field("polarSingLocLon", &self.polarSingLocLon());
      ds.field("emgInd", &self.emgInd());
      ds.field("dropPtInd", &self.dropPtInd());
      ds.field("spaceAmpConf", &self.spaceAmpConf());
      ds.field("launchTime", &self.launchTime());
      ds.field("launchLat", &self.launchLat());
      ds.field("launchLon", &self.launchLon());
      ds.field("azCorr", &self.azCorr());
      ds.field("burnoutAlt", &self.burnoutAlt());
      ds.field("launchAouType", &self.launchAouType());
      ds.field("launchAouData", &self.launchAouData());
      ds.field("impactTime", &self.impactTime());
      ds.field("impactLat", &self.impactLat());
      ds.field("impactLon", &self.impactLon());
      ds.field("impactAouType", &self.impactAouType());
      ds.field("impactAouData", &self.impactAouData());
      ds.field("vectors", &self.vectors());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MissileTrack_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub msgType: Option<String>,
  pub msgSubType: Option<String>,
  pub msgCreateDate: Option<String>,
  pub env: MissileTrack_Full_env_Enum,
  pub objType: Option<String>,
  pub objTypeConf: i32,
  pub objPlat: Option<String>,
  pub objIdent: MissileTrack_Full_objIdent_Enum,
  pub spaceAmp: Option<String>,
  pub objAct: Option<String>,
  pub spaceSpecType: Option<String>,
  pub acftSubType: Option<String>,
  pub name: Option<String>,
  pub callSign: Option<String>,
  pub lostTrkInd: bool,
  pub trackId: Option<String>,
  pub parentTrackId: Option<String>,
  pub muidSrcTrk: Option<String>,
  pub muidSrc: Option<String>,
  pub alert: Option<String>,
  pub mslStatus: Option<String>,
  pub ts: Option<String>,
  pub aouRptType: Option<String>,
  pub aouRptData: Option<Vec<String>>,
  pub containment: f64,
  pub trkConf: f64,
  pub trkQual: i32,
  pub angElev: f64,
  pub senMode: Option<String>,
  pub infoSource: Option<String>,
  pub boosting: bool,
  pub polarSingLocLat: f64,
  pub polarSingLocLon: f64,
  pub emgInd: bool,
  pub dropPtInd: bool,
  pub spaceAmpConf: i32,
  pub launchTime: Option<String>,
  pub launchLat: f64,
  pub launchLon: f64,
  pub azCorr: f64,
  pub burnoutAlt: f64,
  pub launchAouType: Option<String>,
  pub launchAouData: Option<Vec<String>>,
  pub impactTime: Option<String>,
  pub impactLat: f64,
  pub impactLon: f64,
  pub impactAouType: Option<String>,
  pub impactAouData: Option<Vec<String>>,
  pub vectors: Option<Vec<String>>,
  pub origNetwork: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: MissileTrack_Full_dataMode_Enum,
}
impl Default for MissileTrack_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      msgType: None,
      msgSubType: None,
      msgCreateDate: None,
      env: MissileTrack_Full_env_Enum::AIR,
      objType: None,
      objTypeConf: 0,
      objPlat: None,
      objIdent: MissileTrack_Full_objIdent_Enum::ASSUMED_FRIEND,
      spaceAmp: None,
      objAct: None,
      spaceSpecType: None,
      acftSubType: None,
      name: None,
      callSign: None,
      lostTrkInd: false,
      trackId: None,
      parentTrackId: None,
      muidSrcTrk: None,
      muidSrc: None,
      alert: None,
      mslStatus: None,
      ts: None,
      aouRptType: None,
      aouRptData: None,
      containment: 0.0,
      trkConf: 0.0,
      trkQual: 0,
      angElev: 0.0,
      senMode: None,
      infoSource: None,
      boosting: false,
      polarSingLocLat: 0.0,
      polarSingLocLon: 0.0,
      emgInd: false,
      dropPtInd: false,
      spaceAmpConf: 0,
      launchTime: None,
      launchLat: 0.0,
      launchLon: 0.0,
      azCorr: 0.0,
      burnoutAlt: 0.0,
      launchAouType: None,
      launchAouData: None,
      impactTime: None,
      impactLat: 0.0,
      impactLon: 0.0,
      impactAouType: None,
      impactAouData: None,
      vectors: None,
      origNetwork: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: MissileTrack_Full_dataMode_Enum::REAL,
    }
  }
}
impl MissileTrack_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MissileTrack_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msgType = self.msgType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msgSubType = self.msgSubType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msgCreateDate = self.msgCreateDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let env = self.env;
    let objType = self.objType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let objTypeConf = self.objTypeConf;
    let objPlat = self.objPlat.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let objIdent = self.objIdent;
    let spaceAmp = self.spaceAmp.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let objAct = self.objAct.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let spaceSpecType = self.spaceSpecType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let acftSubType = self.acftSubType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let callSign = self.callSign.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lostTrkInd = self.lostTrkInd;
    let trackId = self.trackId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let parentTrackId = self.parentTrackId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let muidSrcTrk = self.muidSrcTrk.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let muidSrc = self.muidSrc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let alert = self.alert.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mslStatus = self.mslStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ts = self.ts.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let aouRptType = self.aouRptType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let aouRptData = self.aouRptData.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let containment = self.containment;
    let trkConf = self.trkConf;
    let trkQual = self.trkQual;
    let angElev = self.angElev;
    let senMode = self.senMode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let infoSource = self.infoSource.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let boosting = self.boosting;
    let polarSingLocLat = self.polarSingLocLat;
    let polarSingLocLon = self.polarSingLocLon;
    let emgInd = self.emgInd;
    let dropPtInd = self.dropPtInd;
    let spaceAmpConf = self.spaceAmpConf;
    let launchTime = self.launchTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let launchLat = self.launchLat;
    let launchLon = self.launchLon;
    let azCorr = self.azCorr;
    let burnoutAlt = self.burnoutAlt;
    let launchAouType = self.launchAouType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let launchAouData = self.launchAouData.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let impactTime = self.impactTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let impactLat = self.impactLat;
    let impactLon = self.impactLon;
    let impactAouType = self.impactAouType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let impactAouData = self.impactAouData.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let vectors = self.vectors.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    MissileTrack_Full::create(_fbb, &MissileTrack_FullArgs{
      id,
      classificationMarking,
      msgType,
      msgSubType,
      msgCreateDate,
      env,
      objType,
      objTypeConf,
      objPlat,
      objIdent,
      spaceAmp,
      objAct,
      spaceSpecType,
      acftSubType,
      name,
      callSign,
      lostTrkInd,
      trackId,
      parentTrackId,
      muidSrcTrk,
      muidSrc,
      alert,
      mslStatus,
      ts,
      aouRptType,
      aouRptData,
      containment,
      trkConf,
      trkQual,
      angElev,
      senMode,
      infoSource,
      boosting,
      polarSingLocLat,
      polarSingLocLon,
      emgInd,
      dropPtInd,
      spaceAmpConf,
      launchTime,
      launchLat,
      launchLon,
      azCorr,
      burnoutAlt,
      launchAouType,
      launchAouData,
      impactTime,
      impactLat,
      impactLon,
      impactAouType,
      impactAouData,
      vectors,
      origNetwork,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `MissileTrack_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_missile_track_full_unchecked`.
pub fn root_as_missile_track_full(buf: &[u8]) -> Result<MissileTrack_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MissileTrack_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MissileTrack_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_missile_track_full_unchecked`.
pub fn size_prefixed_root_as_missile_track_full(buf: &[u8]) -> Result<MissileTrack_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MissileTrack_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MissileTrack_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_missile_track_full_unchecked`.
pub fn root_as_missile_track_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MissileTrack_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MissileTrack_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MissileTrack_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_missile_track_full_unchecked`.
pub fn size_prefixed_root_as_missile_track_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MissileTrack_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MissileTrack_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MissileTrack_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MissileTrack_Full`.
pub unsafe fn root_as_missile_track_full_unchecked(buf: &[u8]) -> MissileTrack_Full {
  flatbuffers::root_unchecked::<MissileTrack_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MissileTrack_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MissileTrack_Full`.
pub unsafe fn size_prefixed_root_as_missile_track_full_unchecked(buf: &[u8]) -> MissileTrack_Full {
  flatbuffers::size_prefixed_root_unchecked::<MissileTrack_Full>(buf)
}
pub const MISSILE_TRACK_FULL_IDENTIFIER: &str = "MISS";

#[inline]
pub fn missile_track_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MISSILE_TRACK_FULL_IDENTIFIER, false)
}

#[inline]
pub fn missile_track_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MISSILE_TRACK_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_missile_track_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<MissileTrack_Full<'a>>) {
  fbb.finish(root, Some(MISSILE_TRACK_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_missile_track_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<MissileTrack_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(MISSILE_TRACK_FULL_IDENTIFIER));
}
