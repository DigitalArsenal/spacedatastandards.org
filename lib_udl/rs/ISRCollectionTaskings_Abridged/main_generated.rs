// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ISRCOLLECTION_TASKINGS_ABRIDGED_TYPE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ISRCOLLECTION_TASKINGS_ABRIDGED_TYPE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ISRCOLLECTION_TASKINGS_ABRIDGED_TYPE_ENUM: [ISRCollectionTaskings_Abridged_type_Enum; 4] = [
  ISRCollectionTaskings_Abridged_type_Enum::DELIBERATE,
  ISRCollectionTaskings_Abridged_type_Enum::DYNAMIC,
  ISRCollectionTaskings_Abridged_type_Enum::TRAINING,
  ISRCollectionTaskings_Abridged_type_Enum::TRANSIT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ISRCollectionTaskings_Abridged_type_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl ISRCollectionTaskings_Abridged_type_Enum {
  /// No description available.
  pub const DELIBERATE: Self = Self(0);
  /// No description available.
  pub const DYNAMIC: Self = Self(1);
  /// No description available.
  pub const TRAINING: Self = Self(2);
  /// No description available.
  pub const TRANSIT: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DELIBERATE,
    Self::DYNAMIC,
    Self::TRAINING,
    Self::TRANSIT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DELIBERATE => Some("DELIBERATE"),
      Self::DYNAMIC => Some("DYNAMIC"),
      Self::TRAINING => Some("TRAINING"),
      Self::TRANSIT => Some("TRANSIT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ISRCollectionTaskings_Abridged_type_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ISRCollectionTaskings_Abridged_type_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ISRCollectionTaskings_Abridged_type_Enum {
    type Output = ISRCollectionTaskings_Abridged_type_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ISRCollectionTaskings_Abridged_type_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ISRCollectionTaskings_Abridged_type_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ISRCollectionTaskings_Abridged_type_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ISRCOLLECTION_TASKINGS_ABRIDGED_COLLECTION_TYPE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ISRCOLLECTION_TASKINGS_ABRIDGED_COLLECTION_TYPE_ENUM: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ISRCOLLECTION_TASKINGS_ABRIDGED_COLLECTION_TYPE_ENUM: [ISRCollectionTaskings_Abridged_collectionType_Enum; 6] = [
  ISRCollectionTaskings_Abridged_collectionType_Enum::SIMULTANEOUS,
  ISRCollectionTaskings_Abridged_collectionType_Enum::SEQUENTIAL,
  ISRCollectionTaskings_Abridged_collectionType_Enum::OPERATIONALLY,
  ISRCollectionTaskings_Abridged_collectionType_Enum::DRIVEN,
  ISRCollectionTaskings_Abridged_collectionType_Enum::PRIORITY,
  ISRCollectionTaskings_Abridged_collectionType_Enum::ORDER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ISRCollectionTaskings_Abridged_collectionType_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl ISRCollectionTaskings_Abridged_collectionType_Enum {
  /// No description available.
  pub const SIMULTANEOUS: Self = Self(0);
  /// No description available.
  pub const SEQUENTIAL: Self = Self(1);
  /// No description available.
  pub const OPERATIONALLY: Self = Self(2);
  /// No description available.
  pub const DRIVEN: Self = Self(3);
  /// No description available.
  pub const PRIORITY: Self = Self(4);
  /// No description available.
  pub const ORDER: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SIMULTANEOUS,
    Self::SEQUENTIAL,
    Self::OPERATIONALLY,
    Self::DRIVEN,
    Self::PRIORITY,
    Self::ORDER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SIMULTANEOUS => Some("SIMULTANEOUS"),
      Self::SEQUENTIAL => Some("SEQUENTIAL"),
      Self::OPERATIONALLY => Some("OPERATIONALLY"),
      Self::DRIVEN => Some("DRIVEN"),
      Self::PRIORITY => Some("PRIORITY"),
      Self::ORDER => Some("ORDER"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ISRCollectionTaskings_Abridged_collectionType_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ISRCollectionTaskings_Abridged_collectionType_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ISRCollectionTaskings_Abridged_collectionType_Enum {
    type Output = ISRCollectionTaskings_Abridged_collectionType_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ISRCollectionTaskings_Abridged_collectionType_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ISRCollectionTaskings_Abridged_collectionType_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ISRCollectionTaskings_Abridged_collectionType_Enum {}
pub enum ISRCollectionTaskings_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Individual taskings to complete the mission.
pub struct ISRCollectionTaskings_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ISRCollectionTaskings_Abridged<'a> {
  type Inner = ISRCollectionTaskings_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ISRCollectionTaskings_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_COLLECTIONTYPE: flatbuffers::VOffsetT = 8;
  pub const VT_TASKINGAOR: flatbuffers::VOffsetT = 10;
  pub const VT_EIGHTLINE: flatbuffers::VOffsetT = 12;
  pub const VT_TASKINGPRIMARYINTELDISCIPLINE: flatbuffers::VOffsetT = 14;
  pub const VT_TASKINGPRIMARYSUBCATEGORY: flatbuffers::VOffsetT = 16;
  pub const VT_TASKINGSECONDARYINTELDISCIPLINE: flatbuffers::VOffsetT = 18;
  pub const VT_TASKINGSECONDARYSUBCATEGORY: flatbuffers::VOffsetT = 20;
  pub const VT_TASKINGROLE: flatbuffers::VOffsetT = 22;
  pub const VT_TASKINGOPERATION: flatbuffers::VOffsetT = 24;
  pub const VT_TASKINGPRIORITY: flatbuffers::VOffsetT = 26;
  pub const VT_TASKINGSUPPORTEDUNIT: flatbuffers::VOffsetT = 28;
  pub const VT_TASKINGEMPHASIS: flatbuffers::VOffsetT = 30;
  pub const VT_TASKINGRETASKTIME: flatbuffers::VOffsetT = 32;
  pub const VT_TASKINGSTARTPOINTLAT: flatbuffers::VOffsetT = 34;
  pub const VT_TASKINGSTARTPOINTLONG: flatbuffers::VOffsetT = 36;
  pub const VT_TASKINGCOLLECTIONAREA: flatbuffers::VOffsetT = 38;
  pub const VT_TASKINGJOA: flatbuffers::VOffsetT = 40;
  pub const VT_TASKINGSYNCMATRIXBIN: flatbuffers::VOffsetT = 42;
  pub const VT_TASKINGCOUNTRY: flatbuffers::VOffsetT = 44;
  pub const VT_TASKINGREGION: flatbuffers::VOffsetT = 46;
  pub const VT_TASKINGSUBREGION: flatbuffers::VOffsetT = 48;
  pub const VT_SROTRACK: flatbuffers::VOffsetT = 50;
  pub const VT_SPECIALCOMGUIDANCE: flatbuffers::VOffsetT = 52;
  pub const VT_COLLECTIONPERIODS: flatbuffers::VOffsetT = 54;
  pub const VT_TASKINGCOLLECTIONREQUIREMENTS: flatbuffers::VOffsetT = 56;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ISRCollectionTaskings_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ISRCollectionTaskings_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<ISRCollectionTaskings_Abridged<'bldr>> {
    let mut builder = ISRCollectionTaskings_AbridgedBuilder::new(_fbb);
    builder.add_taskingStartPointLong(args.taskingStartPointLong);
    builder.add_taskingStartPointLat(args.taskingStartPointLat);
    builder.add_taskingPriority(args.taskingPriority);
    if let Some(x) = args.taskingCollectionRequirements { builder.add_taskingCollectionRequirements(x); }
    if let Some(x) = args.collectionPeriods { builder.add_collectionPeriods(x); }
    if let Some(x) = args.specialComGuidance { builder.add_specialComGuidance(x); }
    if let Some(x) = args.sroTrack { builder.add_sroTrack(x); }
    if let Some(x) = args.taskingSubRegion { builder.add_taskingSubRegion(x); }
    if let Some(x) = args.taskingRegion { builder.add_taskingRegion(x); }
    if let Some(x) = args.taskingCountry { builder.add_taskingCountry(x); }
    if let Some(x) = args.taskingSyncMatrixBin { builder.add_taskingSyncMatrixBin(x); }
    if let Some(x) = args.taskingJoa { builder.add_taskingJoa(x); }
    if let Some(x) = args.taskingCollectionArea { builder.add_taskingCollectionArea(x); }
    if let Some(x) = args.taskingRetaskTime { builder.add_taskingRetaskTime(x); }
    if let Some(x) = args.taskingEmphasis { builder.add_taskingEmphasis(x); }
    if let Some(x) = args.taskingSupportedUnit { builder.add_taskingSupportedUnit(x); }
    if let Some(x) = args.taskingOperation { builder.add_taskingOperation(x); }
    if let Some(x) = args.taskingRole { builder.add_taskingRole(x); }
    if let Some(x) = args.taskingSecondarySubCategory { builder.add_taskingSecondarySubCategory(x); }
    if let Some(x) = args.taskingSecondaryIntelDiscipline { builder.add_taskingSecondaryIntelDiscipline(x); }
    if let Some(x) = args.taskingPrimarySubCategory { builder.add_taskingPrimarySubCategory(x); }
    if let Some(x) = args.taskingPrimaryIntelDiscipline { builder.add_taskingPrimaryIntelDiscipline(x); }
    if let Some(x) = args.eightLine { builder.add_eightLine(x); }
    if let Some(x) = args.taskingAOR { builder.add_taskingAOR(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_collectionType(args.collectionType);
    builder.add_type_(args.type_);
    builder.finish()
  }

  pub fn unpack(&self) -> ISRCollectionTaskings_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let type_ = self.type_();
    let collectionType = self.collectionType();
    let taskingAOR = self.taskingAOR().map(|x| {
      x.to_string()
    });
    let eightLine = self.eightLine().map(|x| {
      x.to_string()
    });
    let taskingPrimaryIntelDiscipline = self.taskingPrimaryIntelDiscipline().map(|x| {
      x.to_string()
    });
    let taskingPrimarySubCategory = self.taskingPrimarySubCategory().map(|x| {
      x.to_string()
    });
    let taskingSecondaryIntelDiscipline = self.taskingSecondaryIntelDiscipline().map(|x| {
      x.to_string()
    });
    let taskingSecondarySubCategory = self.taskingSecondarySubCategory().map(|x| {
      x.to_string()
    });
    let taskingRole = self.taskingRole().map(|x| {
      x.to_string()
    });
    let taskingOperation = self.taskingOperation().map(|x| {
      x.to_string()
    });
    let taskingPriority = self.taskingPriority();
    let taskingSupportedUnit = self.taskingSupportedUnit().map(|x| {
      x.to_string()
    });
    let taskingEmphasis = self.taskingEmphasis().map(|x| {
      x.to_string()
    });
    let taskingRetaskTime = self.taskingRetaskTime().map(|x| {
      x.to_string()
    });
    let taskingStartPointLat = self.taskingStartPointLat();
    let taskingStartPointLong = self.taskingStartPointLong();
    let taskingCollectionArea = self.taskingCollectionArea().map(|x| {
      x.to_string()
    });
    let taskingJoa = self.taskingJoa().map(|x| {
      x.to_string()
    });
    let taskingSyncMatrixBin = self.taskingSyncMatrixBin().map(|x| {
      x.to_string()
    });
    let taskingCountry = self.taskingCountry().map(|x| {
      x.to_string()
    });
    let taskingRegion = self.taskingRegion().map(|x| {
      x.to_string()
    });
    let taskingSubRegion = self.taskingSubRegion().map(|x| {
      x.to_string()
    });
    let sroTrack = self.sroTrack().map(|x| {
      x.to_string()
    });
    let specialComGuidance = self.specialComGuidance().map(|x| {
      x.to_string()
    });
    let collectionPeriods = self.collectionPeriods().map(|x| {
      x.to_string()
    });
    let taskingCollectionRequirements = self.taskingCollectionRequirements().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    ISRCollectionTaskings_AbridgedT {
      id,
      type_,
      collectionType,
      taskingAOR,
      eightLine,
      taskingPrimaryIntelDiscipline,
      taskingPrimarySubCategory,
      taskingSecondaryIntelDiscipline,
      taskingSecondarySubCategory,
      taskingRole,
      taskingOperation,
      taskingPriority,
      taskingSupportedUnit,
      taskingEmphasis,
      taskingRetaskTime,
      taskingStartPointLat,
      taskingStartPointLong,
      taskingCollectionArea,
      taskingJoa,
      taskingSyncMatrixBin,
      taskingCountry,
      taskingRegion,
      taskingSubRegion,
      sroTrack,
      specialComGuidance,
      collectionPeriods,
      taskingCollectionRequirements,
    }
  }

  /// Tasking Unique Identifier.
  /// Example: /// Example: ISRCOLLECTIONTASKINGS-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_ID, None)}
  }
  /// Type of tasking.
  /// Example: /// Example: Deliberate
  /// Constraints: Minimum length = 1, Maximum length = 16
  #[inline]
  pub fn type_(&self) -> ISRCollectionTaskings_Abridged_type_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ISRCollectionTaskings_Abridged_type_Enum>(ISRCollectionTaskings_Abridged::VT_TYPE_, Some(ISRCollectionTaskings_Abridged_type_Enum::DELIBERATE)).unwrap()}
  }
  /// Type of collection tasked.
  /// Example: /// Example: Simultaneous
  /// Constraints: Minimum length = 1, Maximum length = 16
  #[inline]
  pub fn collectionType(&self) -> ISRCollectionTaskings_Abridged_collectionType_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ISRCollectionTaskings_Abridged_collectionType_Enum>(ISRCollectionTaskings_Abridged::VT_COLLECTIONTYPE, Some(ISRCollectionTaskings_Abridged_collectionType_Enum::SIMULTANEOUS)).unwrap()}
  }
  /// Human readable definition of this taskings Area Of Responsibility.
  /// Example: /// Example: Kandahar
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingAOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGAOR, None)}
  }
  /// Eight line.
  /// Example: /// Example: No example provided.
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn eightLine(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_EIGHTLINE, None)}
  }
  /// Primary type of intelligence to be collected during the mission.
  /// Example: /// Example: Sig
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingPrimaryIntelDiscipline(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGPRIMARYINTELDISCIPLINE, None)}
  }
  /// Sub category of primary intelligence to be collected.
  /// Example: /// Example: FMV
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingPrimarySubCategory(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGPRIMARYSUBCATEGORY, None)}
  }
  /// Type of tasking intelligence to be collected second.
  /// Example: /// Example: Intelligence_2
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingSecondaryIntelDiscipline(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGSECONDARYINTELDISCIPLINE, None)}
  }
  /// Mission sub category for secondary intelligence discipline to be collected.
  /// Example: /// Example: Convoy
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingSecondarySubCategory(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGSECONDARYSUBCATEGORY, None)}
  }
  /// What is the primary objective(Role) of this task.
  /// Example: /// Example: Provide Targeting of Lead Vehicle
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingRole(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGROLE, None)}
  }
  /// Tasking operation name.
  /// Example: /// Example: OP-HONEY-BADGER
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingOperation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGOPERATION, None)}
  }
  /// Tasking Priority (1-n).
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taskingPriority(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ISRCollectionTaskings_Abridged::VT_TASKINGPRIORITY, Some(0.0)).unwrap()}
  }
  /// Military Base to transmit the dissemination of this data.
  /// Example: /// Example: ENVOYS
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingSupportedUnit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGSUPPORTEDUNIT, None)}
  }
  /// Tasking emphasis.
  /// Example: /// Example: EMPHASIS
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingEmphasis(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGEMPHASIS, None)}
  }
  /// Time of retasking, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-01-19T01:01:15.001Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taskingRetaskTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGRETASKTIME, None)}
  }
  /// WGS-84 latitude of the start position, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taskingStartPointLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ISRCollectionTaskings_Abridged::VT_TASKINGSTARTPOINTLAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude of the start position, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taskingStartPointLong(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ISRCollectionTaskings_Abridged::VT_TASKINGSTARTPOINTLONG, Some(0.0)).unwrap()}
  }
  /// Tasking geographical collection area.
  /// Example: /// Example: AREA
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taskingCollectionArea(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGCOLLECTIONAREA, None)}
  }
  /// Joint Operations Area.
  /// Example: /// Example: AREA
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingJoa(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGJOA, None)}
  }
  /// A synchronization matrix is used to organize the logistics synchronization process during a mission.
  /// Example: /// Example: MATRIX
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingSyncMatrixBin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGSYNCMATRIXBIN, None)}
  }
  /// Country code of the tasking.  A Country may represent countries, multi-national consortiums, and international organizations.
  /// Example: /// Example: CODE
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn taskingCountry(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGCOUNTRY, None)}
  }
  /// Region of the tasking.
  /// Example: /// Example: REGION
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingRegion(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGREGION, None)}
  }
  /// Subregion of the tasking.
  /// Example: /// Example: SUBREGION
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn taskingSubRegion(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_TASKINGSUBREGION, None)}
  }
  /// Value of the Sensitive Reconnaissance Operations Track.
  /// Example: /// Example: SRO
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn sroTrack(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_SROTRACK, None)}
  }
  /// Free text field for the user to specify special instructions needed for this collection.
  /// Example: /// Example: TEXT
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn specialComGuidance(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_SPECIALCOMGUIDANCE, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn collectionPeriods(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionTaskings_Abridged::VT_COLLECTIONPERIODS, None)}
  }
  /// Tasking desired collection requirements.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taskingCollectionRequirements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ISRCollectionTaskings_Abridged::VT_TASKINGCOLLECTIONREQUIREMENTS, None)}
  }
}

impl flatbuffers::Verifiable for ISRCollectionTaskings_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<ISRCollectionTaskings_Abridged_type_Enum>("type_", Self::VT_TYPE_, false)?
     .visit_field::<ISRCollectionTaskings_Abridged_collectionType_Enum>("collectionType", Self::VT_COLLECTIONTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingAOR", Self::VT_TASKINGAOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eightLine", Self::VT_EIGHTLINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingPrimaryIntelDiscipline", Self::VT_TASKINGPRIMARYINTELDISCIPLINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingPrimarySubCategory", Self::VT_TASKINGPRIMARYSUBCATEGORY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingSecondaryIntelDiscipline", Self::VT_TASKINGSECONDARYINTELDISCIPLINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingSecondarySubCategory", Self::VT_TASKINGSECONDARYSUBCATEGORY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingRole", Self::VT_TASKINGROLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingOperation", Self::VT_TASKINGOPERATION, false)?
     .visit_field::<f64>("taskingPriority", Self::VT_TASKINGPRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingSupportedUnit", Self::VT_TASKINGSUPPORTEDUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingEmphasis", Self::VT_TASKINGEMPHASIS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingRetaskTime", Self::VT_TASKINGRETASKTIME, false)?
     .visit_field::<f64>("taskingStartPointLat", Self::VT_TASKINGSTARTPOINTLAT, false)?
     .visit_field::<f64>("taskingStartPointLong", Self::VT_TASKINGSTARTPOINTLONG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingCollectionArea", Self::VT_TASKINGCOLLECTIONAREA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingJoa", Self::VT_TASKINGJOA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingSyncMatrixBin", Self::VT_TASKINGSYNCMATRIXBIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingCountry", Self::VT_TASKINGCOUNTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingRegion", Self::VT_TASKINGREGION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskingSubRegion", Self::VT_TASKINGSUBREGION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sroTrack", Self::VT_SROTRACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("specialComGuidance", Self::VT_SPECIALCOMGUIDANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("collectionPeriods", Self::VT_COLLECTIONPERIODS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("taskingCollectionRequirements", Self::VT_TASKINGCOLLECTIONREQUIREMENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct ISRCollectionTaskings_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: ISRCollectionTaskings_Abridged_type_Enum,
    pub collectionType: ISRCollectionTaskings_Abridged_collectionType_Enum,
    pub taskingAOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eightLine: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingPrimaryIntelDiscipline: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingPrimarySubCategory: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingSecondaryIntelDiscipline: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingSecondarySubCategory: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingRole: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingOperation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingPriority: f64,
    pub taskingSupportedUnit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingEmphasis: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingRetaskTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingStartPointLat: f64,
    pub taskingStartPointLong: f64,
    pub taskingCollectionArea: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingJoa: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingSyncMatrixBin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingCountry: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingRegion: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingSubRegion: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sroTrack: Option<flatbuffers::WIPOffset<&'a str>>,
    pub specialComGuidance: Option<flatbuffers::WIPOffset<&'a str>>,
    pub collectionPeriods: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskingCollectionRequirements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ISRCollectionTaskings_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    ISRCollectionTaskings_AbridgedArgs {
      id: None,
      type_: ISRCollectionTaskings_Abridged_type_Enum::DELIBERATE,
      collectionType: ISRCollectionTaskings_Abridged_collectionType_Enum::SIMULTANEOUS,
      taskingAOR: None,
      eightLine: None,
      taskingPrimaryIntelDiscipline: None,
      taskingPrimarySubCategory: None,
      taskingSecondaryIntelDiscipline: None,
      taskingSecondarySubCategory: None,
      taskingRole: None,
      taskingOperation: None,
      taskingPriority: 0.0,
      taskingSupportedUnit: None,
      taskingEmphasis: None,
      taskingRetaskTime: None,
      taskingStartPointLat: 0.0,
      taskingStartPointLong: 0.0,
      taskingCollectionArea: None,
      taskingJoa: None,
      taskingSyncMatrixBin: None,
      taskingCountry: None,
      taskingRegion: None,
      taskingSubRegion: None,
      sroTrack: None,
      specialComGuidance: None,
      collectionPeriods: None,
      taskingCollectionRequirements: None,
    }
  }
}

pub struct ISRCollectionTaskings_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ISRCollectionTaskings_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: ISRCollectionTaskings_Abridged_type_Enum) {
    self.fbb_.push_slot::<ISRCollectionTaskings_Abridged_type_Enum>(ISRCollectionTaskings_Abridged::VT_TYPE_, type_, ISRCollectionTaskings_Abridged_type_Enum::DELIBERATE);
  }
  #[inline]
  pub fn add_collectionType(&mut self, collectionType: ISRCollectionTaskings_Abridged_collectionType_Enum) {
    self.fbb_.push_slot::<ISRCollectionTaskings_Abridged_collectionType_Enum>(ISRCollectionTaskings_Abridged::VT_COLLECTIONTYPE, collectionType, ISRCollectionTaskings_Abridged_collectionType_Enum::SIMULTANEOUS);
  }
  #[inline]
  pub fn add_taskingAOR(&mut self, taskingAOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGAOR, taskingAOR);
  }
  #[inline]
  pub fn add_eightLine(&mut self, eightLine: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_EIGHTLINE, eightLine);
  }
  #[inline]
  pub fn add_taskingPrimaryIntelDiscipline(&mut self, taskingPrimaryIntelDiscipline: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGPRIMARYINTELDISCIPLINE, taskingPrimaryIntelDiscipline);
  }
  #[inline]
  pub fn add_taskingPrimarySubCategory(&mut self, taskingPrimarySubCategory: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGPRIMARYSUBCATEGORY, taskingPrimarySubCategory);
  }
  #[inline]
  pub fn add_taskingSecondaryIntelDiscipline(&mut self, taskingSecondaryIntelDiscipline: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGSECONDARYINTELDISCIPLINE, taskingSecondaryIntelDiscipline);
  }
  #[inline]
  pub fn add_taskingSecondarySubCategory(&mut self, taskingSecondarySubCategory: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGSECONDARYSUBCATEGORY, taskingSecondarySubCategory);
  }
  #[inline]
  pub fn add_taskingRole(&mut self, taskingRole: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGROLE, taskingRole);
  }
  #[inline]
  pub fn add_taskingOperation(&mut self, taskingOperation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGOPERATION, taskingOperation);
  }
  #[inline]
  pub fn add_taskingPriority(&mut self, taskingPriority: f64) {
    self.fbb_.push_slot::<f64>(ISRCollectionTaskings_Abridged::VT_TASKINGPRIORITY, taskingPriority, 0.0);
  }
  #[inline]
  pub fn add_taskingSupportedUnit(&mut self, taskingSupportedUnit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGSUPPORTEDUNIT, taskingSupportedUnit);
  }
  #[inline]
  pub fn add_taskingEmphasis(&mut self, taskingEmphasis: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGEMPHASIS, taskingEmphasis);
  }
  #[inline]
  pub fn add_taskingRetaskTime(&mut self, taskingRetaskTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGRETASKTIME, taskingRetaskTime);
  }
  #[inline]
  pub fn add_taskingStartPointLat(&mut self, taskingStartPointLat: f64) {
    self.fbb_.push_slot::<f64>(ISRCollectionTaskings_Abridged::VT_TASKINGSTARTPOINTLAT, taskingStartPointLat, 0.0);
  }
  #[inline]
  pub fn add_taskingStartPointLong(&mut self, taskingStartPointLong: f64) {
    self.fbb_.push_slot::<f64>(ISRCollectionTaskings_Abridged::VT_TASKINGSTARTPOINTLONG, taskingStartPointLong, 0.0);
  }
  #[inline]
  pub fn add_taskingCollectionArea(&mut self, taskingCollectionArea: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGCOLLECTIONAREA, taskingCollectionArea);
  }
  #[inline]
  pub fn add_taskingJoa(&mut self, taskingJoa: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGJOA, taskingJoa);
  }
  #[inline]
  pub fn add_taskingSyncMatrixBin(&mut self, taskingSyncMatrixBin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGSYNCMATRIXBIN, taskingSyncMatrixBin);
  }
  #[inline]
  pub fn add_taskingCountry(&mut self, taskingCountry: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGCOUNTRY, taskingCountry);
  }
  #[inline]
  pub fn add_taskingRegion(&mut self, taskingRegion: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGREGION, taskingRegion);
  }
  #[inline]
  pub fn add_taskingSubRegion(&mut self, taskingSubRegion: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGSUBREGION, taskingSubRegion);
  }
  #[inline]
  pub fn add_sroTrack(&mut self, sroTrack: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_SROTRACK, sroTrack);
  }
  #[inline]
  pub fn add_specialComGuidance(&mut self, specialComGuidance: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_SPECIALCOMGUIDANCE, specialComGuidance);
  }
  #[inline]
  pub fn add_collectionPeriods(&mut self, collectionPeriods: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_COLLECTIONPERIODS, collectionPeriods);
  }
  #[inline]
  pub fn add_taskingCollectionRequirements(&mut self, taskingCollectionRequirements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionTaskings_Abridged::VT_TASKINGCOLLECTIONREQUIREMENTS, taskingCollectionRequirements);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ISRCollectionTaskings_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ISRCollectionTaskings_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ISRCollectionTaskings_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ISRCollectionTaskings_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ISRCollectionTaskings_Abridged");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.field("collectionType", &self.collectionType());
      ds.field("taskingAOR", &self.taskingAOR());
      ds.field("eightLine", &self.eightLine());
      ds.field("taskingPrimaryIntelDiscipline", &self.taskingPrimaryIntelDiscipline());
      ds.field("taskingPrimarySubCategory", &self.taskingPrimarySubCategory());
      ds.field("taskingSecondaryIntelDiscipline", &self.taskingSecondaryIntelDiscipline());
      ds.field("taskingSecondarySubCategory", &self.taskingSecondarySubCategory());
      ds.field("taskingRole", &self.taskingRole());
      ds.field("taskingOperation", &self.taskingOperation());
      ds.field("taskingPriority", &self.taskingPriority());
      ds.field("taskingSupportedUnit", &self.taskingSupportedUnit());
      ds.field("taskingEmphasis", &self.taskingEmphasis());
      ds.field("taskingRetaskTime", &self.taskingRetaskTime());
      ds.field("taskingStartPointLat", &self.taskingStartPointLat());
      ds.field("taskingStartPointLong", &self.taskingStartPointLong());
      ds.field("taskingCollectionArea", &self.taskingCollectionArea());
      ds.field("taskingJoa", &self.taskingJoa());
      ds.field("taskingSyncMatrixBin", &self.taskingSyncMatrixBin());
      ds.field("taskingCountry", &self.taskingCountry());
      ds.field("taskingRegion", &self.taskingRegion());
      ds.field("taskingSubRegion", &self.taskingSubRegion());
      ds.field("sroTrack", &self.sroTrack());
      ds.field("specialComGuidance", &self.specialComGuidance());
      ds.field("collectionPeriods", &self.collectionPeriods());
      ds.field("taskingCollectionRequirements", &self.taskingCollectionRequirements());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ISRCollectionTaskings_AbridgedT {
  pub id: Option<String>,
  pub type_: ISRCollectionTaskings_Abridged_type_Enum,
  pub collectionType: ISRCollectionTaskings_Abridged_collectionType_Enum,
  pub taskingAOR: Option<String>,
  pub eightLine: Option<String>,
  pub taskingPrimaryIntelDiscipline: Option<String>,
  pub taskingPrimarySubCategory: Option<String>,
  pub taskingSecondaryIntelDiscipline: Option<String>,
  pub taskingSecondarySubCategory: Option<String>,
  pub taskingRole: Option<String>,
  pub taskingOperation: Option<String>,
  pub taskingPriority: f64,
  pub taskingSupportedUnit: Option<String>,
  pub taskingEmphasis: Option<String>,
  pub taskingRetaskTime: Option<String>,
  pub taskingStartPointLat: f64,
  pub taskingStartPointLong: f64,
  pub taskingCollectionArea: Option<String>,
  pub taskingJoa: Option<String>,
  pub taskingSyncMatrixBin: Option<String>,
  pub taskingCountry: Option<String>,
  pub taskingRegion: Option<String>,
  pub taskingSubRegion: Option<String>,
  pub sroTrack: Option<String>,
  pub specialComGuidance: Option<String>,
  pub collectionPeriods: Option<String>,
  pub taskingCollectionRequirements: Option<Vec<String>>,
}
impl Default for ISRCollectionTaskings_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      type_: ISRCollectionTaskings_Abridged_type_Enum::DELIBERATE,
      collectionType: ISRCollectionTaskings_Abridged_collectionType_Enum::SIMULTANEOUS,
      taskingAOR: None,
      eightLine: None,
      taskingPrimaryIntelDiscipline: None,
      taskingPrimarySubCategory: None,
      taskingSecondaryIntelDiscipline: None,
      taskingSecondarySubCategory: None,
      taskingRole: None,
      taskingOperation: None,
      taskingPriority: 0.0,
      taskingSupportedUnit: None,
      taskingEmphasis: None,
      taskingRetaskTime: None,
      taskingStartPointLat: 0.0,
      taskingStartPointLong: 0.0,
      taskingCollectionArea: None,
      taskingJoa: None,
      taskingSyncMatrixBin: None,
      taskingCountry: None,
      taskingRegion: None,
      taskingSubRegion: None,
      sroTrack: None,
      specialComGuidance: None,
      collectionPeriods: None,
      taskingCollectionRequirements: None,
    }
  }
}
impl ISRCollectionTaskings_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ISRCollectionTaskings_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_;
    let collectionType = self.collectionType;
    let taskingAOR = self.taskingAOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eightLine = self.eightLine.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingPrimaryIntelDiscipline = self.taskingPrimaryIntelDiscipline.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingPrimarySubCategory = self.taskingPrimarySubCategory.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingSecondaryIntelDiscipline = self.taskingSecondaryIntelDiscipline.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingSecondarySubCategory = self.taskingSecondarySubCategory.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingRole = self.taskingRole.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingOperation = self.taskingOperation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingPriority = self.taskingPriority;
    let taskingSupportedUnit = self.taskingSupportedUnit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingEmphasis = self.taskingEmphasis.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingRetaskTime = self.taskingRetaskTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingStartPointLat = self.taskingStartPointLat;
    let taskingStartPointLong = self.taskingStartPointLong;
    let taskingCollectionArea = self.taskingCollectionArea.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingJoa = self.taskingJoa.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingSyncMatrixBin = self.taskingSyncMatrixBin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingCountry = self.taskingCountry.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingRegion = self.taskingRegion.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingSubRegion = self.taskingSubRegion.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sroTrack = self.sroTrack.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let specialComGuidance = self.specialComGuidance.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let collectionPeriods = self.collectionPeriods.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskingCollectionRequirements = self.taskingCollectionRequirements.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    ISRCollectionTaskings_Abridged::create(_fbb, &ISRCollectionTaskings_AbridgedArgs{
      id,
      type_,
      collectionType,
      taskingAOR,
      eightLine,
      taskingPrimaryIntelDiscipline,
      taskingPrimarySubCategory,
      taskingSecondaryIntelDiscipline,
      taskingSecondarySubCategory,
      taskingRole,
      taskingOperation,
      taskingPriority,
      taskingSupportedUnit,
      taskingEmphasis,
      taskingRetaskTime,
      taskingStartPointLat,
      taskingStartPointLong,
      taskingCollectionArea,
      taskingJoa,
      taskingSyncMatrixBin,
      taskingCountry,
      taskingRegion,
      taskingSubRegion,
      sroTrack,
      specialComGuidance,
      collectionPeriods,
      taskingCollectionRequirements,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ISRCollectionTaskings_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_isrcollection_taskings_abridged_unchecked`.
pub fn root_as_isrcollection_taskings_abridged(buf: &[u8]) -> Result<ISRCollectionTaskings_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ISRCollectionTaskings_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ISRCollectionTaskings_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_isrcollection_taskings_abridged_unchecked`.
pub fn size_prefixed_root_as_isrcollection_taskings_abridged(buf: &[u8]) -> Result<ISRCollectionTaskings_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ISRCollectionTaskings_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ISRCollectionTaskings_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_isrcollection_taskings_abridged_unchecked`.
pub fn root_as_isrcollection_taskings_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ISRCollectionTaskings_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ISRCollectionTaskings_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ISRCollectionTaskings_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_isrcollection_taskings_abridged_unchecked`.
pub fn size_prefixed_root_as_isrcollection_taskings_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ISRCollectionTaskings_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ISRCollectionTaskings_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ISRCollectionTaskings_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ISRCollectionTaskings_Abridged`.
pub unsafe fn root_as_isrcollection_taskings_abridged_unchecked(buf: &[u8]) -> ISRCollectionTaskings_Abridged {
  flatbuffers::root_unchecked::<ISRCollectionTaskings_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ISRCollectionTaskings_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ISRCollectionTaskings_Abridged`.
pub unsafe fn size_prefixed_root_as_isrcollection_taskings_abridged_unchecked(buf: &[u8]) -> ISRCollectionTaskings_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<ISRCollectionTaskings_Abridged>(buf)
}
pub const ISRCOLLECTION_TASKINGS_ABRIDGED_IDENTIFIER: &str = "ISRC";

#[inline]
pub fn isrcollection_taskings_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ISRCOLLECTION_TASKINGS_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn isrcollection_taskings_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ISRCOLLECTION_TASKINGS_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_isrcollection_taskings_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ISRCollectionTaskings_Abridged<'a>>) {
  fbb.finish(root, Some(ISRCOLLECTION_TASKINGS_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_isrcollection_taskings_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ISRCollectionTaskings_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(ISRCOLLECTION_TASKINGS_ABRIDGED_IDENTIFIER));
}
