// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum EvacMedication_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Medication specifics.
pub struct EvacMedication_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EvacMedication_Abridged<'a> {
  type Inner = EvacMedication_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EvacMedication_Abridged<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_BODYPART: flatbuffers::VOffsetT = 6;
  pub const VT_DOSE: flatbuffers::VOffsetT = 8;
  pub const VT_ADMINROUTE: flatbuffers::VOffsetT = 10;
  pub const VT_TIME: flatbuffers::VOffsetT = 12;
  pub const VT_COMMENTS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EvacMedication_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EvacMedication_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<EvacMedication_Abridged<'bldr>> {
    let mut builder = EvacMedication_AbridgedBuilder::new(_fbb);
    if let Some(x) = args.comments { builder.add_comments(x); }
    if let Some(x) = args.time { builder.add_time(x); }
    if let Some(x) = args.adminRoute { builder.add_adminRoute(x); }
    if let Some(x) = args.dose { builder.add_dose(x); }
    if let Some(x) = args.bodyPart { builder.add_bodyPart(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EvacMedication_AbridgedT {
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let bodyPart = self.bodyPart().map(|x| {
      x.to_string()
    });
    let dose = self.dose().map(|x| {
      x.to_string()
    });
    let adminRoute = self.adminRoute().map(|x| {
      x.to_string()
    });
    let time = self.time().map(|x| {
      x.to_string()
    });
    let comments = self.comments().map(|x| {
      x.to_string()
    });
    EvacMedication_AbridgedT {
      type_,
      bodyPart,
      dose,
      adminRoute,
      time,
      comments,
    }
  }

  /// The type of medication administered.   Intended as, but not constrained to, K07.1 Medication Enumeration (CEFOTETAN, ABRASION, ABX, AMOXILOXACIN, ANALGESIC, COLLOID, CRYOPECIPITATES, CRYSTALLOID, EPINEPHRINE, ERTAPENEM, FENTANYL, HEXTEND, LACTATED RINGERS, MOBIC, MORPHINE, NARCOTIC, NS, PENICILLIN, PLASMA, PLATELETS, PRBC, TYLENOL, WHOLE BLOOD MT).
  /// Example: /// Example: TYLENOL
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacMedication_Abridged::VT_TYPE_, None)}
  }
  /// Body part location or body part referenced for medication. Intended as, but not constrained to, K07.1 Body Location Enumeration (e.g. ANKLE LEFT BACK, ANKLE LEFT FRONT, ANKLE RIGHT BACK, ANKLE RIGHT FRONT, ARM LEFT BACK, ARM LEFT ELBOW BACK, ARM LEFT ELBOW FRONT, ARM LEFT FRONT, ARM LEFT LOWER BACK, etc.).
  /// Example: /// Example: ARM LEFT BACK
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn bodyPart(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacMedication_Abridged::VT_BODYPART, None)}
  }
  /// Quantity of medicine or drug administered or recommended to be taken at a particular time.
  /// Example: /// Example: 800mg
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn dose(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacMedication_Abridged::VT_DOSE, None)}
  }
  /// Route of medication delivery (e.g. INJECTION, ORAL, etc.).
  /// Example: /// Example: ORAL
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn adminRoute(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacMedication_Abridged::VT_ADMINROUTE, None)}
  }
  /// The time that the medication was administered in ISO 8601 UTC format.
  /// Example: /// Example: 2021-10-15T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn time(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacMedication_Abridged::VT_TIME, None)}
  }
  /// Additional comments on the patient's medication information.
  /// Example: /// Example: Comments on the patient's medication information.
  /// Constraints: Minimum length = 0, Maximum length = 1024
  #[inline]
  pub fn comments(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacMedication_Abridged::VT_COMMENTS, None)}
  }
}

impl flatbuffers::Verifiable for EvacMedication_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bodyPart", Self::VT_BODYPART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dose", Self::VT_DOSE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("adminRoute", Self::VT_ADMINROUTE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("time", Self::VT_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("comments", Self::VT_COMMENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct EvacMedication_AbridgedArgs<'a> {
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bodyPart: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dose: Option<flatbuffers::WIPOffset<&'a str>>,
    pub adminRoute: Option<flatbuffers::WIPOffset<&'a str>>,
    pub time: Option<flatbuffers::WIPOffset<&'a str>>,
    pub comments: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EvacMedication_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    EvacMedication_AbridgedArgs {
      type_: None,
      bodyPart: None,
      dose: None,
      adminRoute: None,
      time: None,
      comments: None,
    }
  }
}

pub struct EvacMedication_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EvacMedication_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacMedication_Abridged::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_bodyPart(&mut self, bodyPart: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacMedication_Abridged::VT_BODYPART, bodyPart);
  }
  #[inline]
  pub fn add_dose(&mut self, dose: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacMedication_Abridged::VT_DOSE, dose);
  }
  #[inline]
  pub fn add_adminRoute(&mut self, adminRoute: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacMedication_Abridged::VT_ADMINROUTE, adminRoute);
  }
  #[inline]
  pub fn add_time(&mut self, time: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacMedication_Abridged::VT_TIME, time);
  }
  #[inline]
  pub fn add_comments(&mut self, comments: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacMedication_Abridged::VT_COMMENTS, comments);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EvacMedication_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EvacMedication_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EvacMedication_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EvacMedication_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EvacMedication_Abridged");
      ds.field("type_", &self.type_());
      ds.field("bodyPart", &self.bodyPart());
      ds.field("dose", &self.dose());
      ds.field("adminRoute", &self.adminRoute());
      ds.field("time", &self.time());
      ds.field("comments", &self.comments());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EvacMedication_AbridgedT {
  pub type_: Option<String>,
  pub bodyPart: Option<String>,
  pub dose: Option<String>,
  pub adminRoute: Option<String>,
  pub time: Option<String>,
  pub comments: Option<String>,
}
impl Default for EvacMedication_AbridgedT {
  fn default() -> Self {
    Self {
      type_: None,
      bodyPart: None,
      dose: None,
      adminRoute: None,
      time: None,
      comments: None,
    }
  }
}
impl EvacMedication_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EvacMedication_Abridged<'b>> {
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let bodyPart = self.bodyPart.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dose = self.dose.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let adminRoute = self.adminRoute.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let time = self.time.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let comments = self.comments.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    EvacMedication_Abridged::create(_fbb, &EvacMedication_AbridgedArgs{
      type_,
      bodyPart,
      dose,
      adminRoute,
      time,
      comments,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EvacMedication_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evac_medication_abridged_unchecked`.
pub fn root_as_evac_medication_abridged(buf: &[u8]) -> Result<EvacMedication_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EvacMedication_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EvacMedication_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_evac_medication_abridged_unchecked`.
pub fn size_prefixed_root_as_evac_medication_abridged(buf: &[u8]) -> Result<EvacMedication_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EvacMedication_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EvacMedication_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evac_medication_abridged_unchecked`.
pub fn root_as_evac_medication_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EvacMedication_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EvacMedication_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EvacMedication_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evac_medication_abridged_unchecked`.
pub fn size_prefixed_root_as_evac_medication_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EvacMedication_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EvacMedication_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EvacMedication_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EvacMedication_Abridged`.
pub unsafe fn root_as_evac_medication_abridged_unchecked(buf: &[u8]) -> EvacMedication_Abridged {
  flatbuffers::root_unchecked::<EvacMedication_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EvacMedication_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EvacMedication_Abridged`.
pub unsafe fn size_prefixed_root_as_evac_medication_abridged_unchecked(buf: &[u8]) -> EvacMedication_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<EvacMedication_Abridged>(buf)
}
pub const EVAC_MEDICATION_ABRIDGED_IDENTIFIER: &str = "EVAC";

#[inline]
pub fn evac_medication_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EVAC_MEDICATION_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn evac_medication_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EVAC_MEDICATION_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_evac_medication_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<EvacMedication_Abridged<'a>>) {
  fbb.finish(root, Some(EVAC_MEDICATION_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_evac_medication_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<EvacMedication_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(EVAC_MEDICATION_ABRIDGED_IDENTIFIER));
}
