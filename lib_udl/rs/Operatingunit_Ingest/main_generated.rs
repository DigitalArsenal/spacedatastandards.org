// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_OPERATINGUNIT_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_OPERATINGUNIT_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATINGUNIT_INGEST_DATA_MODE_ENUM: [Operatingunit_Ingest_dataMode_Enum; 4] = [
  Operatingunit_Ingest_dataMode_Enum::REAL,
  Operatingunit_Ingest_dataMode_Enum::TEST,
  Operatingunit_Ingest_dataMode_Enum::SIMULATED,
  Operatingunit_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Operatingunit_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Operatingunit_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Operatingunit_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Operatingunit_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Operatingunit_Ingest_dataMode_Enum {
    type Output = Operatingunit_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Operatingunit_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Operatingunit_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Operatingunit_Ingest_dataMode_Enum {}
pub enum Operatingunit_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Model representation of a unit or organization which operates or controls an space-related Entity such as an on-orbit payload, a sensor, etc.  A contact may belong to an organization.
pub struct Operatingunit_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Operatingunit_Ingest<'a> {
  type Inner = Operatingunit_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Operatingunit_Ingest<'a> {
  pub const VT_IDOPERATINGUNIT: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_ALTOPERATINGUNITID: flatbuffers::VOffsetT = 8;
  pub const VT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 12;
  pub const VT_IDLOCATION: flatbuffers::VOffsetT = 14;
  pub const VT_IDCONTACT: flatbuffers::VOffsetT = 16;
  pub const VT_IDORGANIZATION: flatbuffers::VOffsetT = 18;
  pub const VT_UNITIDENTIFIER: flatbuffers::VOffsetT = 20;
  pub const VT_COUNTRYCODE: flatbuffers::VOffsetT = 22;
  pub const VT_ALTCOUNTRYCODE: flatbuffers::VOffsetT = 24;
  pub const VT_WAC: flatbuffers::VOffsetT = 26;
  pub const VT_OPERSTATUS: flatbuffers::VOffsetT = 28;
  pub const VT_CONDITION: flatbuffers::VOffsetT = 30;
  pub const VT_CONDITIONAVAIL: flatbuffers::VOffsetT = 32;
  pub const VT_EVAL: flatbuffers::VOffsetT = 34;
  pub const VT_FPA: flatbuffers::VOffsetT = 36;
  pub const VT_IDENT: flatbuffers::VOffsetT = 38;
  pub const VT_ALLEGIANCE: flatbuffers::VOffsetT = 40;
  pub const VT_ALTALLEGIANCE: flatbuffers::VOffsetT = 42;
  pub const VT_LOCNAME: flatbuffers::VOffsetT = 44;
  pub const VT_LOCREASON: flatbuffers::VOffsetT = 46;
  pub const VT_FORCE: flatbuffers::VOffsetT = 48;
  pub const VT_FORCENAME: flatbuffers::VOffsetT = 50;
  pub const VT_FUNCTROLE: flatbuffers::VOffsetT = 52;
  pub const VT_MSNPRIMARY: flatbuffers::VOffsetT = 54;
  pub const VT_MSNPRIMARYSPECIALTY: flatbuffers::VOffsetT = 56;
  pub const VT_MASTERUNIT: flatbuffers::VOffsetT = 58;
  pub const VT_STYLIZEDUNIT: flatbuffers::VOffsetT = 60;
  pub const VT_DIVCAT: flatbuffers::VOffsetT = 62;
  pub const VT_ECHELON: flatbuffers::VOffsetT = 64;
  pub const VT_ECHELONTIER: flatbuffers::VOffsetT = 66;
  pub const VT_FLEETID: flatbuffers::VOffsetT = 68;
  pub const VT_DEPLOYSTATUS: flatbuffers::VOffsetT = 70;
  pub const VT_FLAGFLOWN: flatbuffers::VOffsetT = 72;
  pub const VT_COORDDATUM: flatbuffers::VOffsetT = 74;
  pub const VT_COORD: flatbuffers::VOffsetT = 76;
  pub const VT_COORDDERIVACC: flatbuffers::VOffsetT = 78;
  pub const VT_LAT: flatbuffers::VOffsetT = 80;
  pub const VT_LON: flatbuffers::VOffsetT = 82;
  pub const VT_ELEVMSL: flatbuffers::VOffsetT = 84;
  pub const VT_ELEVMSLCONFLVL: flatbuffers::VOffsetT = 86;
  pub const VT_ELEVMSLDERIVACC: flatbuffers::VOffsetT = 88;
  pub const VT_GEOIDALMSLSEP: flatbuffers::VOffsetT = 90;
  pub const VT_MILGRIDSYS: flatbuffers::VOffsetT = 92;
  pub const VT_MILGRID: flatbuffers::VOffsetT = 94;
  pub const VT_UTM: flatbuffers::VOffsetT = 96;
  pub const VT_AIRDEFAREA: flatbuffers::VOffsetT = 98;
  pub const VT_POLSUBDIV: flatbuffers::VOffsetT = 100;
  pub const VT_SYMCODE: flatbuffers::VOffsetT = 102;
  pub const VT_CLASSRATING: flatbuffers::VOffsetT = 104;
  pub const VT_RECSTATUS: flatbuffers::VOffsetT = 106;
  pub const VT_REVIEWDATE: flatbuffers::VOffsetT = 108;
  pub const VT_RESPROD: flatbuffers::VOffsetT = 110;
  pub const VT_REFERENCEDOC: flatbuffers::VOffsetT = 112;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 114;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 116;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 118;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 120;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 122;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Operatingunit_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Operatingunit_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<Operatingunit_Ingest<'bldr>> {
    let mut builder = Operatingunit_IngestBuilder::new(_fbb);
    builder.add_geoidalMslSep(args.geoidalMslSep);
    builder.add_elevMslDerivAcc(args.elevMslDerivAcc);
    builder.add_elevMsl(args.elevMsl);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    builder.add_coordDerivAcc(args.coordDerivAcc);
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.referenceDoc { builder.add_referenceDoc(x); }
    if let Some(x) = args.resProd { builder.add_resProd(x); }
    if let Some(x) = args.reviewDate { builder.add_reviewDate(x); }
    if let Some(x) = args.recStatus { builder.add_recStatus(x); }
    if let Some(x) = args.classRating { builder.add_classRating(x); }
    if let Some(x) = args.symCode { builder.add_symCode(x); }
    if let Some(x) = args.polSubdiv { builder.add_polSubdiv(x); }
    if let Some(x) = args.airDefArea { builder.add_airDefArea(x); }
    if let Some(x) = args.utm { builder.add_utm(x); }
    if let Some(x) = args.milGrid { builder.add_milGrid(x); }
    if let Some(x) = args.milGridSys { builder.add_milGridSys(x); }
    builder.add_elevMslConfLvl(args.elevMslConfLvl);
    if let Some(x) = args.coord { builder.add_coord(x); }
    if let Some(x) = args.coordDatum { builder.add_coordDatum(x); }
    if let Some(x) = args.flagFlown { builder.add_flagFlown(x); }
    if let Some(x) = args.deployStatus { builder.add_deployStatus(x); }
    if let Some(x) = args.fleetId { builder.add_fleetId(x); }
    if let Some(x) = args.echelonTier { builder.add_echelonTier(x); }
    if let Some(x) = args.echelon { builder.add_echelon(x); }
    if let Some(x) = args.divCat { builder.add_divCat(x); }
    if let Some(x) = args.msnPrimarySpecialty { builder.add_msnPrimarySpecialty(x); }
    if let Some(x) = args.msnPrimary { builder.add_msnPrimary(x); }
    if let Some(x) = args.functRole { builder.add_functRole(x); }
    if let Some(x) = args.forceName { builder.add_forceName(x); }
    if let Some(x) = args.force { builder.add_force(x); }
    if let Some(x) = args.locReason { builder.add_locReason(x); }
    if let Some(x) = args.locName { builder.add_locName(x); }
    if let Some(x) = args.altAllegiance { builder.add_altAllegiance(x); }
    if let Some(x) = args.allegiance { builder.add_allegiance(x); }
    if let Some(x) = args.ident { builder.add_ident(x); }
    if let Some(x) = args.fpa { builder.add_fpa(x); }
    builder.add_eval(args.eval);
    if let Some(x) = args.conditionAvail { builder.add_conditionAvail(x); }
    if let Some(x) = args.condition { builder.add_condition(x); }
    if let Some(x) = args.operStatus { builder.add_operStatus(x); }
    if let Some(x) = args.wac { builder.add_wac(x); }
    if let Some(x) = args.altCountryCode { builder.add_altCountryCode(x); }
    if let Some(x) = args.countryCode { builder.add_countryCode(x); }
    if let Some(x) = args.unitIdentifier { builder.add_unitIdentifier(x); }
    if let Some(x) = args.idOrganization { builder.add_idOrganization(x); }
    if let Some(x) = args.idContact { builder.add_idContact(x); }
    if let Some(x) = args.idLocation { builder.add_idLocation(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.altOperatingUnitId { builder.add_altOperatingUnitId(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.idOperatingUnit { builder.add_idOperatingUnit(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_stylizedUnit(args.stylizedUnit);
    builder.add_masterUnit(args.masterUnit);
    builder.finish()
  }

  pub fn unpack(&self) -> Operatingunit_IngestT {
    let idOperatingUnit = self.idOperatingUnit().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let altOperatingUnitId = self.altOperatingUnitId().map(|x| {
      x.to_string()
    });
    let name = self.name().map(|x| {
      x.to_string()
    });
    let description = self.description().map(|x| {
      x.to_string()
    });
    let idLocation = self.idLocation().map(|x| {
      x.to_string()
    });
    let idContact = self.idContact().map(|x| {
      x.to_string()
    });
    let idOrganization = self.idOrganization().map(|x| {
      x.to_string()
    });
    let unitIdentifier = self.unitIdentifier().map(|x| {
      x.to_string()
    });
    let countryCode = self.countryCode().map(|x| {
      x.to_string()
    });
    let altCountryCode = self.altCountryCode().map(|x| {
      x.to_string()
    });
    let wac = self.wac().map(|x| {
      x.to_string()
    });
    let operStatus = self.operStatus().map(|x| {
      x.to_string()
    });
    let condition = self.condition().map(|x| {
      x.to_string()
    });
    let conditionAvail = self.conditionAvail().map(|x| {
      x.to_string()
    });
    let eval = self.eval();
    let fpa = self.fpa().map(|x| {
      x.to_string()
    });
    let ident = self.ident().map(|x| {
      x.to_string()
    });
    let allegiance = self.allegiance().map(|x| {
      x.to_string()
    });
    let altAllegiance = self.altAllegiance().map(|x| {
      x.to_string()
    });
    let locName = self.locName().map(|x| {
      x.to_string()
    });
    let locReason = self.locReason().map(|x| {
      x.to_string()
    });
    let force = self.force().map(|x| {
      x.to_string()
    });
    let forceName = self.forceName().map(|x| {
      x.to_string()
    });
    let functRole = self.functRole().map(|x| {
      x.to_string()
    });
    let msnPrimary = self.msnPrimary().map(|x| {
      x.to_string()
    });
    let msnPrimarySpecialty = self.msnPrimarySpecialty().map(|x| {
      x.to_string()
    });
    let masterUnit = self.masterUnit();
    let stylizedUnit = self.stylizedUnit();
    let divCat = self.divCat().map(|x| {
      x.to_string()
    });
    let echelon = self.echelon().map(|x| {
      x.to_string()
    });
    let echelonTier = self.echelonTier().map(|x| {
      x.to_string()
    });
    let fleetId = self.fleetId().map(|x| {
      x.to_string()
    });
    let deployStatus = self.deployStatus().map(|x| {
      x.to_string()
    });
    let flagFlown = self.flagFlown().map(|x| {
      x.to_string()
    });
    let coordDatum = self.coordDatum().map(|x| {
      x.to_string()
    });
    let coord = self.coord().map(|x| {
      x.to_string()
    });
    let coordDerivAcc = self.coordDerivAcc();
    let lat = self.lat();
    let lon = self.lon();
    let elevMsl = self.elevMsl();
    let elevMslConfLvl = self.elevMslConfLvl();
    let elevMslDerivAcc = self.elevMslDerivAcc();
    let geoidalMslSep = self.geoidalMslSep();
    let milGridSys = self.milGridSys().map(|x| {
      x.to_string()
    });
    let milGrid = self.milGrid().map(|x| {
      x.to_string()
    });
    let utm = self.utm().map(|x| {
      x.to_string()
    });
    let airDefArea = self.airDefArea().map(|x| {
      x.to_string()
    });
    let polSubdiv = self.polSubdiv().map(|x| {
      x.to_string()
    });
    let symCode = self.symCode().map(|x| {
      x.to_string()
    });
    let classRating = self.classRating().map(|x| {
      x.to_string()
    });
    let recStatus = self.recStatus().map(|x| {
      x.to_string()
    });
    let reviewDate = self.reviewDate().map(|x| {
      x.to_string()
    });
    let resProd = self.resProd().map(|x| {
      x.to_string()
    });
    let referenceDoc = self.referenceDoc().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    Operatingunit_IngestT {
      idOperatingUnit,
      classificationMarking,
      altOperatingUnitId,
      name,
      description,
      idLocation,
      idContact,
      idOrganization,
      unitIdentifier,
      countryCode,
      altCountryCode,
      wac,
      operStatus,
      condition,
      conditionAvail,
      eval,
      fpa,
      ident,
      allegiance,
      altAllegiance,
      locName,
      locReason,
      force,
      forceName,
      functRole,
      msnPrimary,
      msnPrimarySpecialty,
      masterUnit,
      stylizedUnit,
      divCat,
      echelon,
      echelonTier,
      fleetId,
      deployStatus,
      flagFlown,
      coordDatum,
      coord,
      coordDerivAcc,
      lat,
      lon,
      elevMsl,
      elevMslConfLvl,
      elevMslDerivAcc,
      geoidalMslSep,
      milGridSys,
      milGrid,
      utm,
      airDefArea,
      polSubdiv,
      symCode,
      classRating,
      recStatus,
      reviewDate,
      resProd,
      referenceDoc,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: OPERATINGUNIT-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn idOperatingUnit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_IDOPERATINGUNIT, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the operating unit record from the originating system.
  /// Example: /// Example: 32100000000021
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn altOperatingUnitId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_ALTOPERATINGUNITID, None)}
  }
  /// Name of the operating unit.
  /// Example: /// Example: SOME_NAME
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_NAME, None)}
  }
  /// Description of the operating unit.
  /// Example: /// Example: Description of unit
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_DESCRIPTION, None)}
  }
  /// Unique identifier of the location record for this operating unit.
  /// Example: /// Example: LOCATION-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idLocation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_IDLOCATION, None)}
  }
  /// Unique identifier of the contact for this operating unit.
  /// Example: /// Example: CONTACT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idContact(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_IDCONTACT, None)}
  }
  /// Unique identifier of the organization record for this operating unit.
  /// Example: /// Example: ORGANIZATION-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOrganization(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_IDORGANIZATION, None)}
  }
  /// An optional identifier for this operating unit that may be composed from items such as the originating organization, allegiance, one-up number, etc.
  /// Example: /// Example: AZXAZ12345
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn unitIdentifier(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_UNITIDENTIFIER, None)}
  }
  /// The DoD Standard country code designator for the country or political entity to which the operating unit geographic coordinates reside . This field will be set to "OTHR" if the source value does not match a UDL country code value (ISO-3166-ALPHA-2).
  /// Example: /// Example: IQ
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn countryCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_COUNTRYCODE, None)}
  }
  /// Specifies an alternate country code if the data provider code is not part of an official Country Code standard such as ISO-3166 or FIPS. This field will be set to the value provided by the source and should be used for all Queries specifying a Country Code.
  /// Example: /// Example: IZ
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn altCountryCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_ALTCOUNTRYCODE, None)}
  }
  /// World Aeronautical Chart identifier for the area in which a designated operating unit is located.
  /// Example: /// Example: 0427
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn wac(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_WAC, None)}
  }
  /// The Degree to which an operating unit is ready to perform the overall operational mission(s) for which it was organized and equipped.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: OPR
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn operStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_OPERSTATUS, None)}
  }
  /// The physical manner of being or state of existence of the operating unit.  A physical condition that must be considered in the determining of a course of action.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: RDY
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn condition(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_CONDITION, None)}
  }
  /// Availability of the operating unit relative to its condition.  Indicates the reason the operating unit is not fully operational.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: A
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn conditionAvail(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_CONDITIONAVAIL, None)}
  }
  /// The Intelligence Confidence Level or the Reliability/degree of confidence that the analyst has assigned to the data within this record. The numerical range is from 1 to 9 with 1 representing the highest confidence level.
  /// Example: /// Example: 7
  /// Constraints: No constraints specified.
  #[inline]
  pub fn eval(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Operatingunit_Ingest::VT_EVAL, Some(0)).unwrap()}
  }
  /// Functional Production Area (FPA) under the Shared Production Program (SPP). Producers are defined per country per FPA.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: EOB
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn fpa(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_FPA, None)}
  }
  /// Estimated identity of the Site (ASSUMED FRIEND, FRIEND, HOSTILE, FAKER, JOKER, NEUTRAL, PENDING, SUSPECT, UNKNOWN): 
  /// ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  /// FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  /// HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  /// FAKER: Friendly track, object, or entity acting as an exercise hostile.
  /// JOKER: Friendly track, object, or entity acting as an exercise suspect.
  /// NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  /// PENDING: Track object which has not been evaluated.
  /// SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  /// UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
  /// Example: /// Example: FRIEND
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn ident(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_IDENT, None)}
  }
  /// The DoD Standard country code designator for the country or political entity to which the operating unit owes its allegiance.  This field will be set to "OTHR" if the source value does not match a UDL country code value (ISO-3166-ALPHA-2).
  /// Example: /// Example: OTHR
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn allegiance(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_ALLEGIANCE, None)}
  }
  /// Specifies an alternate allegiance code if the data provider code is not part of an official Country Code standard such as ISO-3166 or FIPS. This field will be set to the value provided by the source and should be used for all Queries specifying allegiance.
  /// Example: /// Example: HL
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn altAllegiance(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_ALTALLEGIANCE, None)}
  }
  /// Location name for the coordinates.
  /// Example: /// Example: LOCATION_NAME
  /// Constraints: Minimum length = 0, Maximum length = 54
  #[inline]
  pub fn locName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_LOCNAME, None)}
  }
  /// Indicates the reason that the operating unit is at that location.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: GR
  /// Constraints: Minimum length = 0, Maximum length = 9
  #[inline]
  pub fn locReason(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_LOCREASON, None)}
  }
  /// An aggregation of military units within a single service (i.e., ARMY, AIR FORCE, etc.) which operates under a single authority to accomplish a common mission. The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: NV
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn force(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_FORCE, None)}
  }
  /// The specific name for a given force.  For example, Force = ADF (Air Defense Force) and Force Name = Army Air Defense Force.
  /// Example: /// Example: FORCE-NAME
  /// Constraints: Minimum length = 0, Maximum length = 54
  #[inline]
  pub fn forceName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_FORCENAME, None)}
  }
  /// Principal combat-related role that an operating unit is organized, structured and equipped to perform.  Or, the specialized military or paramilitary branch in which an individual serves, their specialization.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: MIL
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn functRole(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_FUNCTROLE, None)}
  }
  /// Indicates the principal type of mission that an operating unit is organized and equipped to perform.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: W6
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn msnPrimary(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_MSNPRIMARY, None)}
  }
  /// Indicates the principal specialty type of mission that an operating unit is organized and equipped to perform.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: QK
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn msnPrimarySpecialty(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_MSNPRIMARYSPECIALTY, None)}
  }
  /// This field contains a value indicating whether the record is a master unit record (True) or a detail record (False).  Master records contain basic information that does not change over time for each unit that has been selected to be projected.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn masterUnit(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Operatingunit_Ingest::VT_MASTERUNIT, Some(false)).unwrap()}
  }
  /// This field contains a value indicating whether the record is a stylized operating unit record (True) or a regular operating unit  record (False).  A stylized operating unit is a type of operating unit with one set of equipment that can be assigned to one or more superiors.  A stylized operating unit is generally useful for lower echelon operating units where the number of operating units and types of equipment are equal for multiple organizations.  In lieu of creating unique operating unit records for each operating unit, a template is created for the operating unit and its equipment.  This template enables the user to assign the operating unit to multiple organizations.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stylizedUnit(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Operatingunit_Ingest::VT_STYLIZEDUNIT, Some(false)).unwrap()}
  }
  /// Combat status of a divisional or equivalent operating unit.  Currently, this data element applies only to operating units of the Former Soviet Union.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: 5
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn divCat(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_DIVCAT, None)}
  }
  /// Organizational level of the operating unit.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: SHIP
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn echelon(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_ECHELON, None)}
  }
  /// Indicates the major group or level to which an echelon belongs.   The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: 68
  /// Constraints: Minimum length = 0, Maximum length = 2
  #[inline]
  pub fn echelonTier(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_ECHELONTIER, None)}
  }
  /// Naval fleet to which an operating unit is assigned.   The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: A
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn fleetId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_FLEETID, None)}
  }
  /// A code describing the amount of operating unit participation in a deployment.   The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: ND
  /// Constraints: Minimum length = 0, Maximum length = 2
  #[inline]
  pub fn deployStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_DEPLOYSTATUS, None)}
  }
  /// The country code of the observed flag flown.
  /// Example: /// Example: IZ
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn flagFlown(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_FLAGFLOWN, None)}
  }
  /// A mathematical model of the earth used to calculate coordinates on a map.  US Forces use the World Geodetic System 1984 (WGS 84), but also use maps by allied countries with local datums.  The datum must be specified to ensure accuracy of coordinates.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: WGS
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn coordDatum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_COORDDATUM, None)}
  }
  /// "Indicates any of the magnitudes that serve to define the position of a point by reference to a fixed figure, system of lines, etc.
  /// Pos. 1-2.  Latitude Degrees     [00-90]
  /// Pos. 3-4.  Latitude Minutes     [00-59]
  /// Pos. 5-6.  Latitude Seconds     [00-59]
  /// Pos. 7-9.  Latitude Thousandths Of Seconds   [000-999]  
  /// Pos. 10. Latitude Hemisphere       [NS] 
  /// Pos. 11-13. Longitude Degrees     [00-180] 
  /// Pos. 14-15. Longitude Minutes     [00-59] 
  /// Pos. 16-17. Longitude Seconds     [00-59] 
  /// Pos. 18-20. Longitude Thousandths Of Seconds      [000-999]
  /// Pos. 21. Longitude Hemisphere     [EW]
  /// Pos. 1-21.  Unknown Latitude and Unknown Longitude [000000000U000000000U]]".
  /// Example: /// Example: 340000000N0430000000E
  /// Constraints: Minimum length = 0, Maximum length = 21
  #[inline]
  pub fn coord(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_COORD, None)}
  }
  /// Indicates the plus or minus error assessed against the method used to derive the coordinate.
  /// Example: /// Example: 12.345
  /// Constraints: No constraints specified.
  #[inline]
  pub fn coordDerivAcc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Operatingunit_Ingest::VT_COORDDERIVACC, Some(0.0)).unwrap()}
  }
  /// WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Operatingunit_Ingest::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Operatingunit_Ingest::VT_LON, Some(0.0)).unwrap()}
  }
  /// Ground elevation of the geographic coordinates referenced to (above or below) Mean Sea Level (MSL) vertical datum.
  /// Example: /// Example: 123.45
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevMsl(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Operatingunit_Ingest::VT_ELEVMSL, Some(0.0)).unwrap()}
  }
  /// Indicates the confidence level expressed as a percent that a specific geometric spatial element, ELEVATION_MSL linear accuracy, has been vertically positioned to within a specified vertical accuracy.
  /// Example: /// Example: 50
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevMslConfLvl(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Operatingunit_Ingest::VT_ELEVMSLCONFLVL, Some(0)).unwrap()}
  }
  /// Indicates the plus or minus error assessed against the method used to derive the elevation.
  /// Example: /// Example: 12.34
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevMslDerivAcc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Operatingunit_Ingest::VT_ELEVMSLDERIVACC, Some(0.0)).unwrap()}
  }
  /// The distance between Mean Sea Level and a referenced ellipsoid.
  /// Example: /// Example: 12.34
  /// Constraints: No constraints specified.
  #[inline]
  pub fn geoidalMslSep(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Operatingunit_Ingest::VT_GEOIDALMSLSEP, Some(0.0)).unwrap()}
  }
  /// "Indicates the grid system used in the development of the milGrid coordinates. Values are:
  /// UPS - Universal Polar System
  /// UTM - Universal Transverse Mercator".
  /// Example: /// Example: UTM
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn milGridSys(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_MILGRIDSYS, None)}
  }
  /// The Military Grid Reference System is the geocoordinate standard used by NATO militaries for locating points on Earth. The MGRS is derived from the Universal Transverse Mercator (UTM) grid system and the Universal Polar Stereographic (UPS) grid system, but uses a different labeling convention. The MGRS is used as geocode for the entire Earth. Example of an milgrid coordinate, or grid reference, would be 4QFJ12345678, which consists of three parts:
  /// 4Q (grid zone designator, GZD)
  /// FJ (the 100,000-meter square identifier)
  /// 12345678 (numerical location; easting is 1234 and northing is 5678, in this case specifying a location with 10 m resolution).
  /// Example: /// Example: 4QFJ12345678
  /// Constraints: Minimum length = 0, Maximum length = 15
  #[inline]
  pub fn milGrid(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_MILGRID, None)}
  }
  /// Universal Transverse Mercator (UTM) grid coordinates.
  /// Pos. 1-2, UTM Zone Column   [01-60
  /// Pos. 3, UTM Zone Row   [C-HJ-NP-X]
  /// Pos. 4, UTM False Easting   [0-9]
  /// Pos. 5-9, UTM Meter Easting    [0-9][0-9][0-9][0-9][0-9]
  /// Pos. 10-11, UTM False Northing    [0-9][0-9]
  /// Pos. 12-16, UTM Meter Northing    [0-9][0-9][0-9][0-9][0-9].
  /// Example: /// Example: 19P4390691376966
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn utm(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_UTM, None)}
  }
  /// Air Defense District (ADD) or Air Defense Area (ADA) in which the geographic coordinates reside.
  /// Example: /// Example: AL006
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn airDefArea(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_AIRDEFAREA, None)}
  }
  /// Political subdivision in which the geographic coordinates reside.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: IZ07
  /// Constraints: Minimum length = 0, Maximum length = 7
  #[inline]
  pub fn polSubdiv(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_POLSUBDIV, None)}
  }
  /// A standard scheme for symbol coding enabling the transfer, display and use of symbols and graphics among information systems, as per MIL-STD 2525B, and supported by the element AFFILIATION.
  /// Example: /// Example: SOGPU----------
  /// Constraints: Minimum length = 0, Maximum length = 15
  #[inline]
  pub fn symCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_SYMCODE, None)}
  }
  /// Indicates the importance of the operating unit to the OES or MIR system.  This data element is restricted to update by DIA (DB-4). Valid values are:
  /// 0 - Does not meet criteria above
  /// 1 - Primary importance to system
  /// 2 - Secondary importance to system
  /// 3 - Tertiary importance to system
  /// O - Other. Explain in Remarks.
  /// Example: /// Example: 1
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn classRating(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_CLASSRATING, None)}
  }
  /// Validity and currency of the data in the record to be used in conjunction with the other elements in the record as defined by SOPs. Values are:
  /// A - Active
  /// I - Inactive
  /// K - Acknowledged
  /// L - Local
  /// Q - A nominated (NOM) or Data Change Request (DCR) record
  /// R - Production reduced by CMD decision
  /// W - Working Record.
  /// Example: /// Example: A
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn recStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_RECSTATUS, None)}
  }
  /// Date on which the data in the record was last reviewed by the responsible analyst for accuracy and currency.  This date cannot be greater than the current date.
  /// Example: /// Example: 2008-06-10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn reviewDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_REVIEWDATE, None)}
  }
  /// Responsible Producer - Organization that is responsible for the maintenance of the record.
  /// Example: /// Example: RT
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn resProd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_RESPROD, None)}
  }
  /// The reference documentiation that specifies the usage and enumerations contained in this record. If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: Provider Reference Documentation
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn referenceDoc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_REFERENCEDOC, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operatingunit_Ingest::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> Operatingunit_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Operatingunit_Ingest_dataMode_Enum>(Operatingunit_Ingest::VT_DATAMODE, Some(Operatingunit_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Operatingunit_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOperatingUnit", Self::VT_IDOPERATINGUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altOperatingUnitId", Self::VT_ALTOPERATINGUNITID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idLocation", Self::VT_IDLOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idContact", Self::VT_IDCONTACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOrganization", Self::VT_IDORGANIZATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unitIdentifier", Self::VT_UNITIDENTIFIER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("countryCode", Self::VT_COUNTRYCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altCountryCode", Self::VT_ALTCOUNTRYCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("wac", Self::VT_WAC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("operStatus", Self::VT_OPERSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("condition", Self::VT_CONDITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("conditionAvail", Self::VT_CONDITIONAVAIL, false)?
     .visit_field::<i32>("eval", Self::VT_EVAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fpa", Self::VT_FPA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ident", Self::VT_IDENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("allegiance", Self::VT_ALLEGIANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altAllegiance", Self::VT_ALTALLEGIANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("locName", Self::VT_LOCNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("locReason", Self::VT_LOCREASON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("force", Self::VT_FORCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("forceName", Self::VT_FORCENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("functRole", Self::VT_FUNCTROLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msnPrimary", Self::VT_MSNPRIMARY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msnPrimarySpecialty", Self::VT_MSNPRIMARYSPECIALTY, false)?
     .visit_field::<bool>("masterUnit", Self::VT_MASTERUNIT, false)?
     .visit_field::<bool>("stylizedUnit", Self::VT_STYLIZEDUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("divCat", Self::VT_DIVCAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("echelon", Self::VT_ECHELON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("echelonTier", Self::VT_ECHELONTIER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fleetId", Self::VT_FLEETID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("deployStatus", Self::VT_DEPLOYSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("flagFlown", Self::VT_FLAGFLOWN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coordDatum", Self::VT_COORDDATUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coord", Self::VT_COORD, false)?
     .visit_field::<f64>("coordDerivAcc", Self::VT_COORDDERIVACC, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<f64>("elevMsl", Self::VT_ELEVMSL, false)?
     .visit_field::<i32>("elevMslConfLvl", Self::VT_ELEVMSLCONFLVL, false)?
     .visit_field::<f64>("elevMslDerivAcc", Self::VT_ELEVMSLDERIVACC, false)?
     .visit_field::<f64>("geoidalMslSep", Self::VT_GEOIDALMSLSEP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("milGridSys", Self::VT_MILGRIDSYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("milGrid", Self::VT_MILGRID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("utm", Self::VT_UTM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("airDefArea", Self::VT_AIRDEFAREA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("polSubdiv", Self::VT_POLSUBDIV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("symCode", Self::VT_SYMCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classRating", Self::VT_CLASSRATING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recStatus", Self::VT_RECSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reviewDate", Self::VT_REVIEWDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("resProd", Self::VT_RESPROD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("referenceDoc", Self::VT_REFERENCEDOC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<Operatingunit_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct Operatingunit_IngestArgs<'a> {
    pub idOperatingUnit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altOperatingUnitId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idLocation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idContact: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOrganization: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unitIdentifier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub countryCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altCountryCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub wac: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub condition: Option<flatbuffers::WIPOffset<&'a str>>,
    pub conditionAvail: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eval: i32,
    pub fpa: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ident: Option<flatbuffers::WIPOffset<&'a str>>,
    pub allegiance: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altAllegiance: Option<flatbuffers::WIPOffset<&'a str>>,
    pub locName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub locReason: Option<flatbuffers::WIPOffset<&'a str>>,
    pub force: Option<flatbuffers::WIPOffset<&'a str>>,
    pub forceName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functRole: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msnPrimary: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msnPrimarySpecialty: Option<flatbuffers::WIPOffset<&'a str>>,
    pub masterUnit: bool,
    pub stylizedUnit: bool,
    pub divCat: Option<flatbuffers::WIPOffset<&'a str>>,
    pub echelon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub echelonTier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fleetId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub deployStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub flagFlown: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coordDatum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coord: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coordDerivAcc: f64,
    pub lat: f64,
    pub lon: f64,
    pub elevMsl: f64,
    pub elevMslConfLvl: i32,
    pub elevMslDerivAcc: f64,
    pub geoidalMslSep: f64,
    pub milGridSys: Option<flatbuffers::WIPOffset<&'a str>>,
    pub milGrid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub utm: Option<flatbuffers::WIPOffset<&'a str>>,
    pub airDefArea: Option<flatbuffers::WIPOffset<&'a str>>,
    pub polSubdiv: Option<flatbuffers::WIPOffset<&'a str>>,
    pub symCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classRating: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reviewDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub resProd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub referenceDoc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: Operatingunit_Ingest_dataMode_Enum,
}
impl<'a> Default for Operatingunit_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    Operatingunit_IngestArgs {
      idOperatingUnit: None,
      classificationMarking: None,
      altOperatingUnitId: None,
      name: None,
      description: None,
      idLocation: None,
      idContact: None,
      idOrganization: None,
      unitIdentifier: None,
      countryCode: None,
      altCountryCode: None,
      wac: None,
      operStatus: None,
      condition: None,
      conditionAvail: None,
      eval: 0,
      fpa: None,
      ident: None,
      allegiance: None,
      altAllegiance: None,
      locName: None,
      locReason: None,
      force: None,
      forceName: None,
      functRole: None,
      msnPrimary: None,
      msnPrimarySpecialty: None,
      masterUnit: false,
      stylizedUnit: false,
      divCat: None,
      echelon: None,
      echelonTier: None,
      fleetId: None,
      deployStatus: None,
      flagFlown: None,
      coordDatum: None,
      coord: None,
      coordDerivAcc: 0.0,
      lat: 0.0,
      lon: 0.0,
      elevMsl: 0.0,
      elevMslConfLvl: 0,
      elevMslDerivAcc: 0.0,
      geoidalMslSep: 0.0,
      milGridSys: None,
      milGrid: None,
      utm: None,
      airDefArea: None,
      polSubdiv: None,
      symCode: None,
      classRating: None,
      recStatus: None,
      reviewDate: None,
      resProd: None,
      referenceDoc: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: Operatingunit_Ingest_dataMode_Enum::REAL,
    }
  }
}

pub struct Operatingunit_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Operatingunit_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_idOperatingUnit(&mut self, idOperatingUnit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_IDOPERATINGUNIT, idOperatingUnit);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_altOperatingUnitId(&mut self, altOperatingUnitId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_ALTOPERATINGUNITID, altOperatingUnitId);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_NAME, name);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_idLocation(&mut self, idLocation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_IDLOCATION, idLocation);
  }
  #[inline]
  pub fn add_idContact(&mut self, idContact: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_IDCONTACT, idContact);
  }
  #[inline]
  pub fn add_idOrganization(&mut self, idOrganization: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_IDORGANIZATION, idOrganization);
  }
  #[inline]
  pub fn add_unitIdentifier(&mut self, unitIdentifier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_UNITIDENTIFIER, unitIdentifier);
  }
  #[inline]
  pub fn add_countryCode(&mut self, countryCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_COUNTRYCODE, countryCode);
  }
  #[inline]
  pub fn add_altCountryCode(&mut self, altCountryCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_ALTCOUNTRYCODE, altCountryCode);
  }
  #[inline]
  pub fn add_wac(&mut self, wac: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_WAC, wac);
  }
  #[inline]
  pub fn add_operStatus(&mut self, operStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_OPERSTATUS, operStatus);
  }
  #[inline]
  pub fn add_condition(&mut self, condition: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_CONDITION, condition);
  }
  #[inline]
  pub fn add_conditionAvail(&mut self, conditionAvail: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_CONDITIONAVAIL, conditionAvail);
  }
  #[inline]
  pub fn add_eval(&mut self, eval: i32) {
    self.fbb_.push_slot::<i32>(Operatingunit_Ingest::VT_EVAL, eval, 0);
  }
  #[inline]
  pub fn add_fpa(&mut self, fpa: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_FPA, fpa);
  }
  #[inline]
  pub fn add_ident(&mut self, ident: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_IDENT, ident);
  }
  #[inline]
  pub fn add_allegiance(&mut self, allegiance: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_ALLEGIANCE, allegiance);
  }
  #[inline]
  pub fn add_altAllegiance(&mut self, altAllegiance: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_ALTALLEGIANCE, altAllegiance);
  }
  #[inline]
  pub fn add_locName(&mut self, locName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_LOCNAME, locName);
  }
  #[inline]
  pub fn add_locReason(&mut self, locReason: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_LOCREASON, locReason);
  }
  #[inline]
  pub fn add_force(&mut self, force: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_FORCE, force);
  }
  #[inline]
  pub fn add_forceName(&mut self, forceName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_FORCENAME, forceName);
  }
  #[inline]
  pub fn add_functRole(&mut self, functRole: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_FUNCTROLE, functRole);
  }
  #[inline]
  pub fn add_msnPrimary(&mut self, msnPrimary: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_MSNPRIMARY, msnPrimary);
  }
  #[inline]
  pub fn add_msnPrimarySpecialty(&mut self, msnPrimarySpecialty: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_MSNPRIMARYSPECIALTY, msnPrimarySpecialty);
  }
  #[inline]
  pub fn add_masterUnit(&mut self, masterUnit: bool) {
    self.fbb_.push_slot::<bool>(Operatingunit_Ingest::VT_MASTERUNIT, masterUnit, false);
  }
  #[inline]
  pub fn add_stylizedUnit(&mut self, stylizedUnit: bool) {
    self.fbb_.push_slot::<bool>(Operatingunit_Ingest::VT_STYLIZEDUNIT, stylizedUnit, false);
  }
  #[inline]
  pub fn add_divCat(&mut self, divCat: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_DIVCAT, divCat);
  }
  #[inline]
  pub fn add_echelon(&mut self, echelon: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_ECHELON, echelon);
  }
  #[inline]
  pub fn add_echelonTier(&mut self, echelonTier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_ECHELONTIER, echelonTier);
  }
  #[inline]
  pub fn add_fleetId(&mut self, fleetId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_FLEETID, fleetId);
  }
  #[inline]
  pub fn add_deployStatus(&mut self, deployStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_DEPLOYSTATUS, deployStatus);
  }
  #[inline]
  pub fn add_flagFlown(&mut self, flagFlown: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_FLAGFLOWN, flagFlown);
  }
  #[inline]
  pub fn add_coordDatum(&mut self, coordDatum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_COORDDATUM, coordDatum);
  }
  #[inline]
  pub fn add_coord(&mut self, coord: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_COORD, coord);
  }
  #[inline]
  pub fn add_coordDerivAcc(&mut self, coordDerivAcc: f64) {
    self.fbb_.push_slot::<f64>(Operatingunit_Ingest::VT_COORDDERIVACC, coordDerivAcc, 0.0);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(Operatingunit_Ingest::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(Operatingunit_Ingest::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_elevMsl(&mut self, elevMsl: f64) {
    self.fbb_.push_slot::<f64>(Operatingunit_Ingest::VT_ELEVMSL, elevMsl, 0.0);
  }
  #[inline]
  pub fn add_elevMslConfLvl(&mut self, elevMslConfLvl: i32) {
    self.fbb_.push_slot::<i32>(Operatingunit_Ingest::VT_ELEVMSLCONFLVL, elevMslConfLvl, 0);
  }
  #[inline]
  pub fn add_elevMslDerivAcc(&mut self, elevMslDerivAcc: f64) {
    self.fbb_.push_slot::<f64>(Operatingunit_Ingest::VT_ELEVMSLDERIVACC, elevMslDerivAcc, 0.0);
  }
  #[inline]
  pub fn add_geoidalMslSep(&mut self, geoidalMslSep: f64) {
    self.fbb_.push_slot::<f64>(Operatingunit_Ingest::VT_GEOIDALMSLSEP, geoidalMslSep, 0.0);
  }
  #[inline]
  pub fn add_milGridSys(&mut self, milGridSys: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_MILGRIDSYS, milGridSys);
  }
  #[inline]
  pub fn add_milGrid(&mut self, milGrid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_MILGRID, milGrid);
  }
  #[inline]
  pub fn add_utm(&mut self, utm: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_UTM, utm);
  }
  #[inline]
  pub fn add_airDefArea(&mut self, airDefArea: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_AIRDEFAREA, airDefArea);
  }
  #[inline]
  pub fn add_polSubdiv(&mut self, polSubdiv: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_POLSUBDIV, polSubdiv);
  }
  #[inline]
  pub fn add_symCode(&mut self, symCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_SYMCODE, symCode);
  }
  #[inline]
  pub fn add_classRating(&mut self, classRating: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_CLASSRATING, classRating);
  }
  #[inline]
  pub fn add_recStatus(&mut self, recStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_RECSTATUS, recStatus);
  }
  #[inline]
  pub fn add_reviewDate(&mut self, reviewDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_REVIEWDATE, reviewDate);
  }
  #[inline]
  pub fn add_resProd(&mut self, resProd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_RESPROD, resProd);
  }
  #[inline]
  pub fn add_referenceDoc(&mut self, referenceDoc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_REFERENCEDOC, referenceDoc);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operatingunit_Ingest::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Operatingunit_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<Operatingunit_Ingest_dataMode_Enum>(Operatingunit_Ingest::VT_DATAMODE, dataMode, Operatingunit_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Operatingunit_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Operatingunit_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Operatingunit_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Operatingunit_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Operatingunit_Ingest");
      ds.field("idOperatingUnit", &self.idOperatingUnit());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("altOperatingUnitId", &self.altOperatingUnitId());
      ds.field("name", &self.name());
      ds.field("description", &self.description());
      ds.field("idLocation", &self.idLocation());
      ds.field("idContact", &self.idContact());
      ds.field("idOrganization", &self.idOrganization());
      ds.field("unitIdentifier", &self.unitIdentifier());
      ds.field("countryCode", &self.countryCode());
      ds.field("altCountryCode", &self.altCountryCode());
      ds.field("wac", &self.wac());
      ds.field("operStatus", &self.operStatus());
      ds.field("condition", &self.condition());
      ds.field("conditionAvail", &self.conditionAvail());
      ds.field("eval", &self.eval());
      ds.field("fpa", &self.fpa());
      ds.field("ident", &self.ident());
      ds.field("allegiance", &self.allegiance());
      ds.field("altAllegiance", &self.altAllegiance());
      ds.field("locName", &self.locName());
      ds.field("locReason", &self.locReason());
      ds.field("force", &self.force());
      ds.field("forceName", &self.forceName());
      ds.field("functRole", &self.functRole());
      ds.field("msnPrimary", &self.msnPrimary());
      ds.field("msnPrimarySpecialty", &self.msnPrimarySpecialty());
      ds.field("masterUnit", &self.masterUnit());
      ds.field("stylizedUnit", &self.stylizedUnit());
      ds.field("divCat", &self.divCat());
      ds.field("echelon", &self.echelon());
      ds.field("echelonTier", &self.echelonTier());
      ds.field("fleetId", &self.fleetId());
      ds.field("deployStatus", &self.deployStatus());
      ds.field("flagFlown", &self.flagFlown());
      ds.field("coordDatum", &self.coordDatum());
      ds.field("coord", &self.coord());
      ds.field("coordDerivAcc", &self.coordDerivAcc());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("elevMsl", &self.elevMsl());
      ds.field("elevMslConfLvl", &self.elevMslConfLvl());
      ds.field("elevMslDerivAcc", &self.elevMslDerivAcc());
      ds.field("geoidalMslSep", &self.geoidalMslSep());
      ds.field("milGridSys", &self.milGridSys());
      ds.field("milGrid", &self.milGrid());
      ds.field("utm", &self.utm());
      ds.field("airDefArea", &self.airDefArea());
      ds.field("polSubdiv", &self.polSubdiv());
      ds.field("symCode", &self.symCode());
      ds.field("classRating", &self.classRating());
      ds.field("recStatus", &self.recStatus());
      ds.field("reviewDate", &self.reviewDate());
      ds.field("resProd", &self.resProd());
      ds.field("referenceDoc", &self.referenceDoc());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Operatingunit_IngestT {
  pub idOperatingUnit: Option<String>,
  pub classificationMarking: Option<String>,
  pub altOperatingUnitId: Option<String>,
  pub name: Option<String>,
  pub description: Option<String>,
  pub idLocation: Option<String>,
  pub idContact: Option<String>,
  pub idOrganization: Option<String>,
  pub unitIdentifier: Option<String>,
  pub countryCode: Option<String>,
  pub altCountryCode: Option<String>,
  pub wac: Option<String>,
  pub operStatus: Option<String>,
  pub condition: Option<String>,
  pub conditionAvail: Option<String>,
  pub eval: i32,
  pub fpa: Option<String>,
  pub ident: Option<String>,
  pub allegiance: Option<String>,
  pub altAllegiance: Option<String>,
  pub locName: Option<String>,
  pub locReason: Option<String>,
  pub force: Option<String>,
  pub forceName: Option<String>,
  pub functRole: Option<String>,
  pub msnPrimary: Option<String>,
  pub msnPrimarySpecialty: Option<String>,
  pub masterUnit: bool,
  pub stylizedUnit: bool,
  pub divCat: Option<String>,
  pub echelon: Option<String>,
  pub echelonTier: Option<String>,
  pub fleetId: Option<String>,
  pub deployStatus: Option<String>,
  pub flagFlown: Option<String>,
  pub coordDatum: Option<String>,
  pub coord: Option<String>,
  pub coordDerivAcc: f64,
  pub lat: f64,
  pub lon: f64,
  pub elevMsl: f64,
  pub elevMslConfLvl: i32,
  pub elevMslDerivAcc: f64,
  pub geoidalMslSep: f64,
  pub milGridSys: Option<String>,
  pub milGrid: Option<String>,
  pub utm: Option<String>,
  pub airDefArea: Option<String>,
  pub polSubdiv: Option<String>,
  pub symCode: Option<String>,
  pub classRating: Option<String>,
  pub recStatus: Option<String>,
  pub reviewDate: Option<String>,
  pub resProd: Option<String>,
  pub referenceDoc: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: Operatingunit_Ingest_dataMode_Enum,
}
impl Default for Operatingunit_IngestT {
  fn default() -> Self {
    Self {
      idOperatingUnit: None,
      classificationMarking: None,
      altOperatingUnitId: None,
      name: None,
      description: None,
      idLocation: None,
      idContact: None,
      idOrganization: None,
      unitIdentifier: None,
      countryCode: None,
      altCountryCode: None,
      wac: None,
      operStatus: None,
      condition: None,
      conditionAvail: None,
      eval: 0,
      fpa: None,
      ident: None,
      allegiance: None,
      altAllegiance: None,
      locName: None,
      locReason: None,
      force: None,
      forceName: None,
      functRole: None,
      msnPrimary: None,
      msnPrimarySpecialty: None,
      masterUnit: false,
      stylizedUnit: false,
      divCat: None,
      echelon: None,
      echelonTier: None,
      fleetId: None,
      deployStatus: None,
      flagFlown: None,
      coordDatum: None,
      coord: None,
      coordDerivAcc: 0.0,
      lat: 0.0,
      lon: 0.0,
      elevMsl: 0.0,
      elevMslConfLvl: 0,
      elevMslDerivAcc: 0.0,
      geoidalMslSep: 0.0,
      milGridSys: None,
      milGrid: None,
      utm: None,
      airDefArea: None,
      polSubdiv: None,
      symCode: None,
      classRating: None,
      recStatus: None,
      reviewDate: None,
      resProd: None,
      referenceDoc: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: Operatingunit_Ingest_dataMode_Enum::REAL,
    }
  }
}
impl Operatingunit_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Operatingunit_Ingest<'b>> {
    let idOperatingUnit = self.idOperatingUnit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altOperatingUnitId = self.altOperatingUnitId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let description = self.description.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idLocation = self.idLocation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idContact = self.idContact.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOrganization = self.idOrganization.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let unitIdentifier = self.unitIdentifier.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let countryCode = self.countryCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altCountryCode = self.altCountryCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let wac = self.wac.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let operStatus = self.operStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let condition = self.condition.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let conditionAvail = self.conditionAvail.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eval = self.eval;
    let fpa = self.fpa.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ident = self.ident.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let allegiance = self.allegiance.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altAllegiance = self.altAllegiance.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let locName = self.locName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let locReason = self.locReason.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let force = self.force.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let forceName = self.forceName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let functRole = self.functRole.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msnPrimary = self.msnPrimary.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msnPrimarySpecialty = self.msnPrimarySpecialty.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let masterUnit = self.masterUnit;
    let stylizedUnit = self.stylizedUnit;
    let divCat = self.divCat.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let echelon = self.echelon.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let echelonTier = self.echelonTier.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let fleetId = self.fleetId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let deployStatus = self.deployStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let flagFlown = self.flagFlown.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let coordDatum = self.coordDatum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let coord = self.coord.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let coordDerivAcc = self.coordDerivAcc;
    let lat = self.lat;
    let lon = self.lon;
    let elevMsl = self.elevMsl;
    let elevMslConfLvl = self.elevMslConfLvl;
    let elevMslDerivAcc = self.elevMslDerivAcc;
    let geoidalMslSep = self.geoidalMslSep;
    let milGridSys = self.milGridSys.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let milGrid = self.milGrid.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let utm = self.utm.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let airDefArea = self.airDefArea.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let polSubdiv = self.polSubdiv.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let symCode = self.symCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classRating = self.classRating.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let recStatus = self.recStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reviewDate = self.reviewDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let resProd = self.resProd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let referenceDoc = self.referenceDoc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    Operatingunit_Ingest::create(_fbb, &Operatingunit_IngestArgs{
      idOperatingUnit,
      classificationMarking,
      altOperatingUnitId,
      name,
      description,
      idLocation,
      idContact,
      idOrganization,
      unitIdentifier,
      countryCode,
      altCountryCode,
      wac,
      operStatus,
      condition,
      conditionAvail,
      eval,
      fpa,
      ident,
      allegiance,
      altAllegiance,
      locName,
      locReason,
      force,
      forceName,
      functRole,
      msnPrimary,
      msnPrimarySpecialty,
      masterUnit,
      stylizedUnit,
      divCat,
      echelon,
      echelonTier,
      fleetId,
      deployStatus,
      flagFlown,
      coordDatum,
      coord,
      coordDerivAcc,
      lat,
      lon,
      elevMsl,
      elevMslConfLvl,
      elevMslDerivAcc,
      geoidalMslSep,
      milGridSys,
      milGrid,
      utm,
      airDefArea,
      polSubdiv,
      symCode,
      classRating,
      recStatus,
      reviewDate,
      resProd,
      referenceDoc,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Operatingunit_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_operatingunit_ingest_unchecked`.
pub fn root_as_operatingunit_ingest(buf: &[u8]) -> Result<Operatingunit_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Operatingunit_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Operatingunit_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_operatingunit_ingest_unchecked`.
pub fn size_prefixed_root_as_operatingunit_ingest(buf: &[u8]) -> Result<Operatingunit_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Operatingunit_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Operatingunit_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_operatingunit_ingest_unchecked`.
pub fn root_as_operatingunit_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Operatingunit_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Operatingunit_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Operatingunit_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_operatingunit_ingest_unchecked`.
pub fn size_prefixed_root_as_operatingunit_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Operatingunit_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Operatingunit_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Operatingunit_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Operatingunit_Ingest`.
pub unsafe fn root_as_operatingunit_ingest_unchecked(buf: &[u8]) -> Operatingunit_Ingest {
  flatbuffers::root_unchecked::<Operatingunit_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Operatingunit_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Operatingunit_Ingest`.
pub unsafe fn size_prefixed_root_as_operatingunit_ingest_unchecked(buf: &[u8]) -> Operatingunit_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<Operatingunit_Ingest>(buf)
}
pub const OPERATINGUNIT_INGEST_IDENTIFIER: &str = "OPER";

#[inline]
pub fn operatingunit_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OPERATINGUNIT_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn operatingunit_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OPERATINGUNIT_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_operatingunit_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Operatingunit_Ingest<'a>>) {
  fbb.finish(root, Some(OPERATINGUNIT_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_operatingunit_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Operatingunit_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(OPERATINGUNIT_INGEST_IDENTIFIER));
}
