// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_WEATHER_REPORT_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_WEATHER_REPORT_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_WEATHER_REPORT_ABRIDGED_DATA_MODE_ENUM: [WeatherReport_Abridged_dataMode_Enum; 4] = [
  WeatherReport_Abridged_dataMode_Enum::REAL,
  WeatherReport_Abridged_dataMode_Enum::TEST,
  WeatherReport_Abridged_dataMode_Enum::SIMULATED,
  WeatherReport_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct WeatherReport_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl WeatherReport_Abridged_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for WeatherReport_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for WeatherReport_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for WeatherReport_Abridged_dataMode_Enum {
    type Output = WeatherReport_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for WeatherReport_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for WeatherReport_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for WeatherReport_Abridged_dataMode_Enum {}
pub enum WeatherReport_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// These services provide for posting and querying Weather Over Target information. The information contained within describes the current weather conditions over a target area or region to include navigational considerations such as altimeter settings, visibility, cloud heights etc.
pub struct WeatherReport_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WeatherReport_Abridged<'a> {
  type Inner = WeatherReport_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WeatherReport_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDSENSOR: flatbuffers::VOffsetT = 8;
  pub const VT_ORIGSENSORID: flatbuffers::VOffsetT = 10;
  pub const VT_WEATHERID: flatbuffers::VOffsetT = 12;
  pub const VT_IDGROUNDIMAGERY: flatbuffers::VOffsetT = 14;
  pub const VT_IDSITE: flatbuffers::VOffsetT = 16;
  pub const VT_IDAIRFIELD: flatbuffers::VOffsetT = 18;
  pub const VT_ICAO: flatbuffers::VOffsetT = 20;
  pub const VT_EXTERNALID: flatbuffers::VOffsetT = 22;
  pub const VT_EXTERNALLOCATIONID: flatbuffers::VOffsetT = 24;
  pub const VT_REPORTTYPE: flatbuffers::VOffsetT = 26;
  pub const VT_OBTIME: flatbuffers::VOffsetT = 28;
  pub const VT_FORECASTSTARTTIME: flatbuffers::VOffsetT = 30;
  pub const VT_FORECASTENDTIME: flatbuffers::VOffsetT = 32;
  pub const VT_LAT: flatbuffers::VOffsetT = 34;
  pub const VT_LON: flatbuffers::VOffsetT = 36;
  pub const VT_ALT: flatbuffers::VOffsetT = 38;
  pub const VT_GEOPOTENTIALALT: flatbuffers::VOffsetT = 40;
  pub const VT_DATALEVEL: flatbuffers::VOffsetT = 42;
  pub const VT_ATEXT: flatbuffers::VOffsetT = 44;
  pub const VT_AGJSON: flatbuffers::VOffsetT = 46;
  pub const VT_ATYPE: flatbuffers::VOffsetT = 48;
  pub const VT_ANDIMS: flatbuffers::VOffsetT = 50;
  pub const VT_ASRID: flatbuffers::VOffsetT = 52;
  pub const VT_WINDSPD: flatbuffers::VOffsetT = 54;
  pub const VT_WINDSPDAVG: flatbuffers::VOffsetT = 56;
  pub const VT_WINDGUST: flatbuffers::VOffsetT = 58;
  pub const VT_WINDGUST10: flatbuffers::VOffsetT = 60;
  pub const VT_VSHEAR: flatbuffers::VOffsetT = 62;
  pub const VT_HSHEAR: flatbuffers::VOffsetT = 64;
  pub const VT_RADVEL: flatbuffers::VOffsetT = 66;
  pub const VT_RADVELBEAM1: flatbuffers::VOffsetT = 68;
  pub const VT_RADVELBEAM2: flatbuffers::VOffsetT = 70;
  pub const VT_RADVELBEAM3: flatbuffers::VOffsetT = 72;
  pub const VT_RADVELBEAM4: flatbuffers::VOffsetT = 74;
  pub const VT_RADVELBEAM5: flatbuffers::VOffsetT = 76;
  pub const VT_WINDDIR: flatbuffers::VOffsetT = 78;
  pub const VT_WINDDIRAVG: flatbuffers::VOffsetT = 80;
  pub const VT_WINDDIRPEAK: flatbuffers::VOffsetT = 82;
  pub const VT_WINDDIRPEAK10: flatbuffers::VOffsetT = 84;
  pub const VT_WINDCHILL: flatbuffers::VOffsetT = 86;
  pub const VT_DIRDEV: flatbuffers::VOffsetT = 88;
  pub const VT_WINDVAR: flatbuffers::VOffsetT = 90;
  pub const VT_WINDCOV: flatbuffers::VOffsetT = 92;
  pub const VT_CLOUDCOVER: flatbuffers::VOffsetT = 94;
  pub const VT_CLOUDHGHT: flatbuffers::VOffsetT = 96;
  pub const VT_ACTWEATHER: flatbuffers::VOffsetT = 98;
  pub const VT_WEATHERDESC: flatbuffers::VOffsetT = 100;
  pub const VT_WEATHERINT: flatbuffers::VOffsetT = 102;
  pub const VT_RAWMETAR: flatbuffers::VOffsetT = 104;
  pub const VT_RAWTAF: flatbuffers::VOffsetT = 106;
  pub const VT_QNH: flatbuffers::VOffsetT = 108;
  pub const VT_VISIBILITY: flatbuffers::VOffsetT = 110;
  pub const VT_TEMPERATURE: flatbuffers::VOffsetT = 112;
  pub const VT_SOILTEMP: flatbuffers::VOffsetT = 114;
  pub const VT_BARPRESS: flatbuffers::VOffsetT = 116;
  pub const VT_PRECIPRATE: flatbuffers::VOffsetT = 118;
  pub const VT_RAINHOUR: flatbuffers::VOffsetT = 120;
  pub const VT_SOLARRAD: flatbuffers::VOffsetT = 122;
  pub const VT_DIFRAD: flatbuffers::VOffsetT = 124;
  pub const VT_REFRAD: flatbuffers::VOffsetT = 126;
  pub const VT_SENLAT: flatbuffers::VOffsetT = 128;
  pub const VT_SENLON: flatbuffers::VOffsetT = 130;
  pub const VT_SENALT: flatbuffers::VOffsetT = 132;
  pub const VT_DEWPOINT: flatbuffers::VOffsetT = 134;
  pub const VT_RELHUMIDITY: flatbuffers::VOffsetT = 136;
  pub const VT_INDEXREFRACTION: flatbuffers::VOffsetT = 138;
  pub const VT_SOILMOISTURE: flatbuffers::VOffsetT = 140;
  pub const VT_SURROUNDINGWEATHER: flatbuffers::VOffsetT = 142;
  pub const VT_WEATHERAMP: flatbuffers::VOffsetT = 144;
  pub const VT_CONTRAILHGHTLOWER: flatbuffers::VOffsetT = 146;
  pub const VT_CONTRAILHGHTUPPER: flatbuffers::VOffsetT = 148;
  pub const VT_ICINGUPPERLIMIT: flatbuffers::VOffsetT = 150;
  pub const VT_ICINGLOWERLIMIT: flatbuffers::VOffsetT = 152;
  pub const VT_ENROUTEWEATHER: flatbuffers::VOffsetT = 154;
  pub const VT_CCEVENT: flatbuffers::VOffsetT = 156;
  pub const VT_SRCTYPS: flatbuffers::VOffsetT = 158;
  pub const VT_SRCIDS: flatbuffers::VOffsetT = 160;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 162;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 164;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 166;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 168;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 170;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 172;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WeatherReport_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WeatherReport_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<WeatherReport_Abridged<'bldr>> {
    let mut builder = WeatherReport_AbridgedBuilder::new(_fbb);
    builder.add_icingLowerLimit(args.icingLowerLimit);
    builder.add_icingUpperLimit(args.icingUpperLimit);
    builder.add_contrailHghtUpper(args.contrailHghtUpper);
    builder.add_contrailHghtLower(args.contrailHghtLower);
    builder.add_soilMoisture(args.soilMoisture);
    builder.add_indexRefraction(args.indexRefraction);
    builder.add_relHumidity(args.relHumidity);
    builder.add_dewPoint(args.dewPoint);
    builder.add_senalt(args.senalt);
    builder.add_senlon(args.senlon);
    builder.add_senlat(args.senlat);
    builder.add_refRad(args.refRad);
    builder.add_difRad(args.difRad);
    builder.add_solarRad(args.solarRad);
    builder.add_rainHour(args.rainHour);
    builder.add_precipRate(args.precipRate);
    builder.add_barPress(args.barPress);
    builder.add_soilTemp(args.soilTemp);
    builder.add_temperature(args.temperature);
    builder.add_visibility(args.visibility);
    builder.add_qnh(args.qnh);
    builder.add_dirDev(args.dirDev);
    builder.add_windChill(args.windChill);
    builder.add_windDirPeak10(args.windDirPeak10);
    builder.add_windDirPeak(args.windDirPeak);
    builder.add_windDirAvg(args.windDirAvg);
    builder.add_windDir(args.windDir);
    builder.add_radVelBeam5(args.radVelBeam5);
    builder.add_radVelBeam4(args.radVelBeam4);
    builder.add_radVelBeam3(args.radVelBeam3);
    builder.add_radVelBeam2(args.radVelBeam2);
    builder.add_radVelBeam1(args.radVelBeam1);
    builder.add_radVel(args.radVel);
    builder.add_hshear(args.hshear);
    builder.add_vshear(args.vshear);
    builder.add_windGust10(args.windGust10);
    builder.add_windGust(args.windGust);
    builder.add_windSpdAvg(args.windSpdAvg);
    builder.add_windSpd(args.windSpd);
    builder.add_geoPotentialAlt(args.geoPotentialAlt);
    builder.add_alt(args.alt);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.srcIds { builder.add_srcIds(x); }
    if let Some(x) = args.srcTyps { builder.add_srcTyps(x); }
    if let Some(x) = args.enRouteWeather { builder.add_enRouteWeather(x); }
    if let Some(x) = args.weatherAmp { builder.add_weatherAmp(x); }
    if let Some(x) = args.surroundingWeather { builder.add_surroundingWeather(x); }
    if let Some(x) = args.rawTAF { builder.add_rawTAF(x); }
    if let Some(x) = args.rawMETAR { builder.add_rawMETAR(x); }
    if let Some(x) = args.weatherInt { builder.add_weatherInt(x); }
    if let Some(x) = args.weatherDesc { builder.add_weatherDesc(x); }
    if let Some(x) = args.actWeather { builder.add_actWeather(x); }
    if let Some(x) = args.cloudHght { builder.add_cloudHght(x); }
    if let Some(x) = args.cloudCover { builder.add_cloudCover(x); }
    if let Some(x) = args.windCov { builder.add_windCov(x); }
    builder.add_asrid(args.asrid);
    builder.add_andims(args.andims);
    if let Some(x) = args.atype { builder.add_atype(x); }
    if let Some(x) = args.agjson { builder.add_agjson(x); }
    if let Some(x) = args.atext { builder.add_atext(x); }
    if let Some(x) = args.dataLevel { builder.add_dataLevel(x); }
    if let Some(x) = args.forecastEndTime { builder.add_forecastEndTime(x); }
    if let Some(x) = args.forecastStartTime { builder.add_forecastStartTime(x); }
    if let Some(x) = args.obTime { builder.add_obTime(x); }
    if let Some(x) = args.reportType { builder.add_reportType(x); }
    if let Some(x) = args.externalLocationId { builder.add_externalLocationId(x); }
    if let Some(x) = args.externalId { builder.add_externalId(x); }
    if let Some(x) = args.icao { builder.add_icao(x); }
    if let Some(x) = args.idAirfield { builder.add_idAirfield(x); }
    if let Some(x) = args.idSite { builder.add_idSite(x); }
    if let Some(x) = args.idGroundImagery { builder.add_idGroundImagery(x); }
    if let Some(x) = args.weatherId { builder.add_weatherId(x); }
    if let Some(x) = args.origSensorId { builder.add_origSensorId(x); }
    if let Some(x) = args.idSensor { builder.add_idSensor(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_ccEvent(args.ccEvent);
    builder.add_windVar(args.windVar);
    builder.finish()
  }

  pub fn unpack(&self) -> WeatherReport_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idSensor = self.idSensor().map(|x| {
      x.to_string()
    });
    let origSensorId = self.origSensorId().map(|x| {
      x.to_string()
    });
    let weatherId = self.weatherId().map(|x| {
      x.to_string()
    });
    let idGroundImagery = self.idGroundImagery().map(|x| {
      x.to_string()
    });
    let idSite = self.idSite().map(|x| {
      x.to_string()
    });
    let idAirfield = self.idAirfield().map(|x| {
      x.to_string()
    });
    let icao = self.icao().map(|x| {
      x.to_string()
    });
    let externalId = self.externalId().map(|x| {
      x.to_string()
    });
    let externalLocationId = self.externalLocationId().map(|x| {
      x.to_string()
    });
    let reportType = self.reportType().map(|x| {
      x.to_string()
    });
    let obTime = self.obTime().map(|x| {
      x.to_string()
    });
    let forecastStartTime = self.forecastStartTime().map(|x| {
      x.to_string()
    });
    let forecastEndTime = self.forecastEndTime().map(|x| {
      x.to_string()
    });
    let lat = self.lat();
    let lon = self.lon();
    let alt = self.alt();
    let geoPotentialAlt = self.geoPotentialAlt();
    let dataLevel = self.dataLevel().map(|x| {
      x.to_string()
    });
    let atext = self.atext().map(|x| {
      x.to_string()
    });
    let agjson = self.agjson().map(|x| {
      x.to_string()
    });
    let atype = self.atype().map(|x| {
      x.to_string()
    });
    let andims = self.andims();
    let asrid = self.asrid();
    let windSpd = self.windSpd();
    let windSpdAvg = self.windSpdAvg();
    let windGust = self.windGust();
    let windGust10 = self.windGust10();
    let vshear = self.vshear();
    let hshear = self.hshear();
    let radVel = self.radVel();
    let radVelBeam1 = self.radVelBeam1();
    let radVelBeam2 = self.radVelBeam2();
    let radVelBeam3 = self.radVelBeam3();
    let radVelBeam4 = self.radVelBeam4();
    let radVelBeam5 = self.radVelBeam5();
    let windDir = self.windDir();
    let windDirAvg = self.windDirAvg();
    let windDirPeak = self.windDirPeak();
    let windDirPeak10 = self.windDirPeak10();
    let windChill = self.windChill();
    let dirDev = self.dirDev();
    let windVar = self.windVar();
    let windCov = self.windCov().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let cloudCover = self.cloudCover().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let cloudHght = self.cloudHght().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let actWeather = self.actWeather().map(|x| {
      x.to_string()
    });
    let weatherDesc = self.weatherDesc().map(|x| {
      x.to_string()
    });
    let weatherInt = self.weatherInt().map(|x| {
      x.to_string()
    });
    let rawMETAR = self.rawMETAR().map(|x| {
      x.to_string()
    });
    let rawTAF = self.rawTAF().map(|x| {
      x.to_string()
    });
    let qnh = self.qnh();
    let visibility = self.visibility();
    let temperature = self.temperature();
    let soilTemp = self.soilTemp();
    let barPress = self.barPress();
    let precipRate = self.precipRate();
    let rainHour = self.rainHour();
    let solarRad = self.solarRad();
    let difRad = self.difRad();
    let refRad = self.refRad();
    let senlat = self.senlat();
    let senlon = self.senlon();
    let senalt = self.senalt();
    let dewPoint = self.dewPoint();
    let relHumidity = self.relHumidity();
    let indexRefraction = self.indexRefraction();
    let soilMoisture = self.soilMoisture();
    let surroundingWeather = self.surroundingWeather().map(|x| {
      x.to_string()
    });
    let weatherAmp = self.weatherAmp().map(|x| {
      x.to_string()
    });
    let contrailHghtLower = self.contrailHghtLower();
    let contrailHghtUpper = self.contrailHghtUpper();
    let icingUpperLimit = self.icingUpperLimit();
    let icingLowerLimit = self.icingLowerLimit();
    let enRouteWeather = self.enRouteWeather().map(|x| {
      x.to_string()
    });
    let ccEvent = self.ccEvent();
    let srcTyps = self.srcTyps().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let srcIds = self.srcIds().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    WeatherReport_AbridgedT {
      id,
      classificationMarking,
      idSensor,
      origSensorId,
      weatherId,
      idGroundImagery,
      idSite,
      idAirfield,
      icao,
      externalId,
      externalLocationId,
      reportType,
      obTime,
      forecastStartTime,
      forecastEndTime,
      lat,
      lon,
      alt,
      geoPotentialAlt,
      dataLevel,
      atext,
      agjson,
      atype,
      andims,
      asrid,
      windSpd,
      windSpdAvg,
      windGust,
      windGust10,
      vshear,
      hshear,
      radVel,
      radVelBeam1,
      radVelBeam2,
      radVelBeam3,
      radVelBeam4,
      radVelBeam5,
      windDir,
      windDirAvg,
      windDirPeak,
      windDirPeak10,
      windChill,
      dirDev,
      windVar,
      windCov,
      cloudCover,
      cloudHght,
      actWeather,
      weatherDesc,
      weatherInt,
      rawMETAR,
      rawTAF,
      qnh,
      visibility,
      temperature,
      soilTemp,
      barPress,
      precipRate,
      rainHour,
      solarRad,
      difRad,
      refRad,
      senlat,
      senlon,
      senalt,
      dewPoint,
      relHumidity,
      indexRefraction,
      soilMoisture,
      surroundingWeather,
      weatherAmp,
      contrailHghtLower,
      contrailHghtUpper,
      icingUpperLimit,
      icingLowerLimit,
      enRouteWeather,
      ccEvent,
      srcTyps,
      srcIds,
      origNetwork,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: WEATHER-REPORT-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the sensor making the weather measurement.
  /// Example: /// Example: 0129f577-e04c-441e-65ca-0a04a750bed9
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_IDSENSOR, None)}
  }
  /// Optional identifier provided by the record source. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origSensorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_ORIGSENSORID, None)}
  }
  /// Identifier of the weather over target, which should remain the same on subsequent Weather Over Target records.
  /// Example: /// Example: WEATHER-ID
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn weatherId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_WEATHERID, None)}
  }
  /// Identifier of the ground imagery associated for this weather over target report.
  /// Example: /// Example: GROUND-IMAGERY-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idGroundImagery(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_IDGROUNDIMAGERY, None)}
  }
  /// Identifier of the Site that is associated with this weather report.
  /// Example: /// Example: AIRFIELD-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSite(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_IDSITE, None)}
  }
  /// Identifier of the Airfield associated with this weather report.
  /// Example: /// Example: 8fb38d6d-a3de-45dd-8974-4e3ed73e9449
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idAirfield(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_IDAIRFIELD, None)}
  }
  /// The International Civil Aviation Organization (ICAO) code of the airfield associated with this weather report.
  /// Example: /// Example: KAFF
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn icao(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_ICAO, None)}
  }
  /// Optional observation or forecast ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: GDSSMB022408301601304517
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn externalId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_EXTERNALID, None)}
  }
  /// Optional location ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: TMDS060AD4OG03CC
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn externalLocationId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_EXTERNALLOCATIONID, None)}
  }
  /// Identifies the type of weather report (e.g. OBSERVATION, FORECAST, etc.).
  /// Example: /// Example: FORECAST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn reportType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_REPORTTYPE, None)}
  }
  /// Datetime when a weather observation was made or forecast was issued in ISO 8601 UTC datetime format with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_OBTIME, None)}
  }
  /// Valid start time of a weather forecast in ISO 8601 UTC datetime format with millisecond precision.
  /// Example: /// Example: 2024-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn forecastStartTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_FORECASTSTARTTIME, None)}
  }
  /// Valid end time of a weather forecast in ISO 8601 UTC datetime format with millisecond precision.
  /// Example: /// Example: 2024-01-01T18:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn forecastEndTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_FORECASTENDTIME, None)}
  }
  /// The central WGS-84 latitude of the weather report, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 56.12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_LAT, Some(0.0)).unwrap()}
  }
  /// The central WGS-84 longitude of the weather report, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: -156.6
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_LON, Some(0.0)).unwrap()}
  }
  /// Point height above ellipsoid (WGS-84), in meters.
  /// Example: /// Example: 123.12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn alt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_ALT, Some(0.0)).unwrap()}
  }
  /// Altitude of a pressure surface in the atmosphere above mean sea level, in meters.
  /// Example: /// Example: 1000.0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn geoPotentialAlt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_GEOPOTENTIALALT, Some(0.0)).unwrap()}
  }
  /// Specific pressures or heights where measurements are taken, labeled as either MANDATORY or SIGNIFICANT levels. Mandatory levels are at particular pressures at geopotential heights. Significant levels are at particular geometric heights.
  /// Example: /// Example: MANDATORY
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn dataLevel(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_DATALEVEL, None)}
  }
  /// Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
  /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  /// Constraints: No constraints specified.
  #[inline]
  pub fn atext(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_ATEXT, None)}
  }
  /// Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
  /// Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
  /// Constraints: No constraints specified.
  #[inline]
  pub fn agjson(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_AGJSON, None)}
  }
  /// Type of region as projected on the ground.
  /// Example: /// Example: ST_Polygon
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn atype(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_ATYPE, None)}
  }
  /// Number of dimensions of the geometry depicted by region.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn andims(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(WeatherReport_Abridged::VT_ANDIMS, Some(0)).unwrap()}
  }
  /// Geographical spatial_ref_sys for region.
  /// Example: /// Example: 4326
  /// Constraints: No constraints specified.
  #[inline]
  pub fn asrid(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(WeatherReport_Abridged::VT_ASRID, Some(0)).unwrap()}
  }
  /// Expresses the speed of the wind in meters/second.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn windSpd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_WINDSPD, Some(0.0)).unwrap()}
  }
  /// Average wind speed over a 1 minute period, in meters/second.
  /// Example: /// Example: 12.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn windSpdAvg(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_WINDSPDAVG, Some(0.0)).unwrap()}
  }
  /// Expresses the max gust speed of the wind, in meters/second.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn windGust(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_WINDGUST, Some(0.0)).unwrap()}
  }
  /// Expresses the max gust speed of the wind recorded in a 10 minute period, in meters/second.
  /// Example: /// Example: 13.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn windGust10(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_WINDGUST10, Some(0.0)).unwrap()}
  }
  /// The change in wind speed between two different altitudes divided by the vertical distance between them, in units of 1/sec.
  /// Example: /// Example: 3.8
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vshear(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_VSHEAR, Some(0.0)).unwrap()}
  }
  /// The change in wind speed between two different lateral positions at a given altitude divided by the horizontal distance between them, in units of 1/sec.
  /// Example: /// Example: 3.8
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hshear(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_HSHEAR, Some(0.0)).unwrap()}
  }
  /// Average radial velocity of wind as measured by radar with multi-beam configurations. Radial velocity is the component of wind velocity moving directly toward or away from a sensor's radar beam, in meters per second. Values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar).
  /// Example: /// Example: -0.04
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radVel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_RADVEL, Some(0.0)).unwrap()}
  }
  /// Component of wind velocity moving directly toward or away from radar beam 1, in meters per second. Radial velocity values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar). The beam number designation is defined by the data source.
  /// Example: /// Example: 4.4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radVelBeam1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_RADVELBEAM1, Some(0.0)).unwrap()}
  }
  /// Component of wind velocity moving directly toward or away from radar beam 2, in meters per second. Radial velocity values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar). The beam number designation is defined by the data source.
  /// Example: /// Example: -0.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radVelBeam2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_RADVELBEAM2, Some(0.0)).unwrap()}
  }
  /// Component of wind velocity moving directly toward or away from radar beam 3, in meters per second. Radial velocity values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar). The beam number designation is defined by the data source.
  /// Example: /// Example: -0.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radVelBeam3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_RADVELBEAM3, Some(0.0)).unwrap()}
  }
  /// Component of wind velocity moving directly toward or away from radar beam 4, in meters per second. Radial velocity values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar). The beam number designation is defined by the data source.
  /// Example: /// Example: 11.4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radVelBeam4(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_RADVELBEAM4, Some(0.0)).unwrap()}
  }
  /// Component of wind velocity moving directly toward or away from radar beam 5, in meters per second. Radial velocity values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar). The beam number designation is defined by the data source.
  /// Example: /// Example: 4.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radVelBeam5(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_RADVELBEAM5, Some(0.0)).unwrap()}
  }
  /// Direction the wind is blowing, in degrees clockwise from true north.
  /// Example: /// Example: 75.1234
  /// Constraints: No constraints specified.
  #[inline]
  pub fn windDir(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_WINDDIR, Some(0.0)).unwrap()}
  }
  /// Average wind direction over a 1 minute period, in degrees clockwise from true north.
  /// Example: /// Example: 57.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn windDirAvg(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_WINDDIRAVG, Some(0.0)).unwrap()}
  }
  /// Wind direction corresponding to the peak wind speed during a 1 minute period, in degrees clockwise from true north.
  /// Example: /// Example: 78.4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn windDirPeak(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_WINDDIRPEAK, Some(0.0)).unwrap()}
  }
  /// Wind direction corresponding to the peak wind speed during a 10 minute period, in degrees clockwise from true north.
  /// Example: /// Example: 44.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn windDirPeak10(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_WINDDIRPEAK10, Some(0.0)).unwrap()}
  }
  /// The perceived temperature in degrees C.
  /// Example: /// Example: 15.6
  /// Constraints: No constraints specified.
  #[inline]
  pub fn windChill(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_WINDCHILL, Some(0.0)).unwrap()}
  }
  /// The difference in wind direction recorded over a period of time, in degrees.
  /// Example: /// Example: 9.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dirDev(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_DIRDEV, Some(0.0)).unwrap()}
  }
  /// Boolean describing whether or not the wind direction and/or speed is variable.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn windVar(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WeatherReport_Abridged::VT_WINDVAR, Some(false)).unwrap()}
  }
  /// Covariance matrix, in knots and second based units.  The array values represent the lower triangular half of the covariance matrix. The size of the covariance matrix is 2x2.  The covariance elements are position dependent within the array with values ordered as follows:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y
  /// x&nbsp;&nbsp;&nbsp;&nbsp;1
  /// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
  /// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
  /// Example: /// Example: [1.1, 2.2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn windCov(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(WeatherReport_Abridged::VT_WINDCOV, None)}
  }
  /// Array of cloud cover descriptions - each element can be maximum of 16 characters long. Intended as, but not constrained to, MIL-STD-6016 cloud cover designations (e.g. SKY CLEAR, SCATTERED, BROKEN, OVERCAST, SKY OBSCURED). Each element of the array corresponds to the elements in the cloudHght array specified respectively.
  /// Example: /// Example: ['OVERCAST', 'BROKEN']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cloudCover(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(WeatherReport_Abridged::VT_CLOUDCOVER, None)}
  }
  /// Array of cloud base heights in meters described by the cloudHght array. Each element of the array corresponds to the elements in the cloudCover array specified respectively.
  /// Example: /// Example: [1.2, 2.2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cloudHght(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(WeatherReport_Abridged::VT_CLOUDHGHT, None)}
  }
  /// Describes the actual weather at position. Intended as, but not constrained to, MIL-STD-6016 actual weather (e.g. NO STATEMENT, NO SIGNIFICANT WEATHER, DRIZZLE, RAIN, SNOW, SNOW GRAINS, DIAMOND DUST, ICE PELLETS, HAIL, SMALL HAIL, MIST, FOG, SMOKE, VOLCANIC ASH, WIDESPREAD DUST, SAND, HAZE, WELL DEVELOPED DUST, SQUALLS, FUNNEL CLOUDS, SANDSTORM, DUSTSTORM, LOW CLOUDS, CLOUDY, GROUND FOG, DUST, HEAVY RAIN, THUNDERSTORMS AWT, HEAVY THUNDERSTORMS, HURRICANE TYPHOON CYCLONE, TROPICAL STORM, TORNADO, HIGH WINDS, LIGHTNING, FREEZING DRIZZLE, FREEZING RAIN, HEAVY SNOW, ICING, SNOW OR RAIN AND SNOW MIXED, SHOWERS, CLEAR).
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn actWeather(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_ACTWEATHER, None)}
  }
  /// Used in conjunction with actWeather and weatherInt. Intended as, but not constrained to, MIL-STD-6016 actual weather descriptor (e.g. NO STATEMENT, SHALLOW, PATCHES, LOW DRIFTING, BLOWING, SHOWERS, THUNDERSTORMS, SUPERCOOLED).
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn weatherDesc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_WEATHERDESC, None)}
  }
  /// Weather Intensity. Used in conjunction with actWeather and weatherDesc. Intended as, but not constrained to, MIL-STD-6016 weather intensity (e.g. NO STATEMENT, LIGHT, MODERATE, HEAVY, IN VICINITY).
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn weatherInt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_WEATHERINT, None)}
  }
  /// The Raw Meteorological Aerodrome Report (METAR) string.
  /// Example: /// Example: KXYZ 241456Z 19012G20KT 10SM FEW120 SCT200 BKN250 26/M04 A2981 RMK AO2 PK WND 19026/1420 SLP068 T02611039 51015
  /// Constraints: Minimum length = 0, Maximum length = 512
  #[inline]
  pub fn rawMETAR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_RAWMETAR, None)}
  }
  /// Terminal Aerodrome Forecast (TAF) containing detailed weather predictions for a specific airport or aerodrome.
  /// Example: /// Example: KXYZ 051730Z 0518/0624 31008KT 3SM -SHRA BKN020 FM052300 30006KT 5SM -SHRA OVC030 PROB30 0604/0606 VRB20G35KT 1SM TSRA BKN015CB FM060600 25010KT 4SM -SHRA OVC050 TEMPO 0608/0611 2SM -SHRA OVC030 RMK NXT FCST BY 00Z=
  /// Constraints: Minimum length = 0, Maximum length = 1024
  #[inline]
  pub fn rawTAF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_RAWTAF, None)}
  }
  /// Altimeter set to read zero at mean sea level in kilopascals.
  /// Example: /// Example: 1234.456
  /// Constraints: No constraints specified.
  #[inline]
  pub fn qnh(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_QNH, Some(0.0)).unwrap()}
  }
  /// Visual distance in meters.
  /// Example: /// Example: 1234.456
  /// Constraints: No constraints specified.
  #[inline]
  pub fn visibility(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_VISIBILITY, Some(0.0)).unwrap()}
  }
  /// The measurement of air temperature in degrees C.
  /// Example: /// Example: 23.45
  /// Constraints: No constraints specified.
  #[inline]
  pub fn temperature(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_TEMPERATURE, Some(0.0)).unwrap()}
  }
  /// The measurement of soil temperature in degrees C.
  /// Example: /// Example: 22.4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn soilTemp(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_SOILTEMP, Some(0.0)).unwrap()}
  }
  /// The measurement of air pressure in the atmosphere in kilopascals.
  /// Example: /// Example: 101.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn barPress(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_BARPRESS, Some(0.0)).unwrap()}
  }
  /// The speed at which water is being applied to a specific area in millimeters per hour.
  /// Example: /// Example: 3.4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn precipRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_PRECIPRATE, Some(0.0)).unwrap()}
  }
  /// The amount of rain that has fallen in the past hour, in centimeters.
  /// Example: /// Example: 1.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rainHour(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_RAINHOUR, Some(0.0)).unwrap()}
  }
  /// The power per unit area received from the Sun in the form of electromagnetic radiation as measured in the wavelength range of the measuring instrument. The solar irradiance is measured in watt per square meter (W/m2).
  /// Example: /// Example: 1234.456
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solarRad(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_SOLARRAD, Some(0.0)).unwrap()}
  }
  /// The amount of radiation that reaches earth's surface after being scattered by the atmosphere, in Watts per square meter.
  /// Example: /// Example: 234.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn difRad(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_DIFRAD, Some(0.0)).unwrap()}
  }
  /// The amount of radiation that changes direction as a function of atmospheric density, in Watts per square meter.
  /// Example: /// Example: 56.7
  /// Constraints: No constraints specified.
  #[inline]
  pub fn refRad(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_REFRAD, Some(0.0)).unwrap()}
  }
  /// Sensor WGS84 latitude at obTime in degrees. -90 to 90 degrees (negative values south of equator). This includes pilot reports or other means of weather observation.
  /// Example: /// Example: 12.456
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_SENLAT, Some(0.0)).unwrap()}
  }
  /// Sensor WGS84 longitude at obTime in degrees. -180 to 180 degrees (negative values west of Prime Meridian). This includes pilot reports or other means of weather observation.
  /// Example: /// Example: 123.456
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_SENLON, Some(0.0)).unwrap()}
  }
  /// Sensor altitude at obTime in km. This includes pilot reports or other means of weather observation.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senalt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_SENALT, Some(0.0)).unwrap()}
  }
  /// The temperature at which air is saturated with water vapor, in degrees C.
  /// Example: /// Example: 15.6
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dewPoint(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_DEWPOINT, Some(0.0)).unwrap()}
  }
  /// The percentage of water vapor in the atmosphere.
  /// Example: /// Example: 34.456
  /// Constraints: No constraints specified.
  #[inline]
  pub fn relHumidity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_RELHUMIDITY, Some(0.0)).unwrap()}
  }
  /// An indication of how much the atmosphere refracts light.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn indexRefraction(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_INDEXREFRACTION, Some(0.0)).unwrap()}
  }
  /// The volumetric percentage of soil water contained in a given volume of soil.
  /// Example: /// Example: 3.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn soilMoisture(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_SOILMOISTURE, Some(0.0)).unwrap()}
  }
  /// Describes in which direction (if any) that better weather conditions exist. Intended as, but not constrained to, MIL-STD-6016 surrounding weather designations (e.g. NO STATEMENT, BETTER TO NORTH, BETTER TO EAST, BETTER TO SOUTH, BETTER TO WEST).
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn surroundingWeather(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_SURROUNDINGWEATHER, None)}
  }
  /// Amplifies the actual weather being reported. Intended as, but not constrained to, MIL-STD-6016 weather amplification designations (e.g. NO STATEMENT, NO SCATTERED BROKEN MEDIUM CLOUD, SCATTERED BROKEN MEDIUM CLOUDS, GUSTY WINDS AT SERVICE, FOG IN VALLEYS, HIGHER TERRAIN OBSCURED, SURFACE CONDITIONS VARIABLE, SURFACE WIND NE, SURFACE WIND SE, SURFACE WIND SW, SURFACE WIND NW, PRESENCE OF CUMULONIMBUS).
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn weatherAmp(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_WEATHERAMP, None)}
  }
  /// Reports the lowest altitude at which contrails are occurring, in meters.
  /// Example: /// Example: 123.123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn contrailHghtLower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_CONTRAILHGHTLOWER, Some(0.0)).unwrap()}
  }
  /// Reports the highest altitude at which contrails are occurring, in meters.
  /// Example: /// Example: 123.123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn contrailHghtUpper(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_CONTRAILHGHTUPPER, Some(0.0)).unwrap()}
  }
  /// Reports the highest altitude at which icing or freezing rain is occurring, in meters.
  /// Example: /// Example: 123.123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn icingUpperLimit(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_ICINGUPPERLIMIT, Some(0.0)).unwrap()}
  }
  /// Reports the lowest altitude at which icing or freezing rain is occurring, in meters.
  /// Example: /// Example: 123.123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn icingLowerLimit(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(WeatherReport_Abridged::VT_ICINGLOWERLIMIT, Some(0.0)).unwrap()}
  }
  /// Describes the flight conditions in route to the target  (NO STATEMENT, MAINLY IFR, MAINLY VFR, THUNDERSTORMS).
  /// MAINLY IFR:&nbsp;&nbsp;Predominantly Instrument Flight Rules.
  /// MAINLY VFR:&nbsp;&nbsp;Predominantly Visual Flight Rules.
  /// THUNDERSTORMS:&nbsp;&nbsp;Thunderstorms expected in route.
  /// Example: /// Example: THUNDERSTORMS
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn enRouteWeather(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_ENROUTEWEATHER, None)}
  }
  /// Flag indicating detection of a cloud-to-cloud lightning event.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ccEvent(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WeatherReport_Abridged::VT_CCEVENT, Some(false)).unwrap()}
  }
  /// Array of UDL record types (SENSOR, WEATHERDATA) that are related to this WeatherReport record. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
  /// Example: /// Example: ['SENSOR', 'WEATHERDATA']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn srcTyps(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(WeatherReport_Abridged::VT_SRCTYPS, None)}
  }
  /// Array of UUID(s) of the UDL data record(s) that are related to this WeatherReport record. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
  /// Example: /// Example: ['e609a90d-4059-4043-9f1a-fd7b49a3e1d0', 'c739fcdb-c0c9-43c0-97b6-bfc80d0ffd52']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn srcIds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(WeatherReport_Abridged::VT_SRCIDS, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_ORIGNETWORK, None)}
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherReport_Abridged::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> WeatherReport_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<WeatherReport_Abridged_dataMode_Enum>(WeatherReport_Abridged::VT_DATAMODE, Some(WeatherReport_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for WeatherReport_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor", Self::VT_IDSENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId", Self::VT_ORIGSENSORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("weatherId", Self::VT_WEATHERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idGroundImagery", Self::VT_IDGROUNDIMAGERY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSite", Self::VT_IDSITE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idAirfield", Self::VT_IDAIRFIELD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("icao", Self::VT_ICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("externalId", Self::VT_EXTERNALID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("externalLocationId", Self::VT_EXTERNALLOCATIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reportType", Self::VT_REPORTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("obTime", Self::VT_OBTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("forecastStartTime", Self::VT_FORECASTSTARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("forecastEndTime", Self::VT_FORECASTENDTIME, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<f64>("alt", Self::VT_ALT, false)?
     .visit_field::<f64>("geoPotentialAlt", Self::VT_GEOPOTENTIALALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dataLevel", Self::VT_DATALEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("atext", Self::VT_ATEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("agjson", Self::VT_AGJSON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("atype", Self::VT_ATYPE, false)?
     .visit_field::<i32>("andims", Self::VT_ANDIMS, false)?
     .visit_field::<i32>("asrid", Self::VT_ASRID, false)?
     .visit_field::<f64>("windSpd", Self::VT_WINDSPD, false)?
     .visit_field::<f64>("windSpdAvg", Self::VT_WINDSPDAVG, false)?
     .visit_field::<f64>("windGust", Self::VT_WINDGUST, false)?
     .visit_field::<f64>("windGust10", Self::VT_WINDGUST10, false)?
     .visit_field::<f64>("vshear", Self::VT_VSHEAR, false)?
     .visit_field::<f64>("hshear", Self::VT_HSHEAR, false)?
     .visit_field::<f64>("radVel", Self::VT_RADVEL, false)?
     .visit_field::<f64>("radVelBeam1", Self::VT_RADVELBEAM1, false)?
     .visit_field::<f64>("radVelBeam2", Self::VT_RADVELBEAM2, false)?
     .visit_field::<f64>("radVelBeam3", Self::VT_RADVELBEAM3, false)?
     .visit_field::<f64>("radVelBeam4", Self::VT_RADVELBEAM4, false)?
     .visit_field::<f64>("radVelBeam5", Self::VT_RADVELBEAM5, false)?
     .visit_field::<f64>("windDir", Self::VT_WINDDIR, false)?
     .visit_field::<f64>("windDirAvg", Self::VT_WINDDIRAVG, false)?
     .visit_field::<f64>("windDirPeak", Self::VT_WINDDIRPEAK, false)?
     .visit_field::<f64>("windDirPeak10", Self::VT_WINDDIRPEAK10, false)?
     .visit_field::<f64>("windChill", Self::VT_WINDCHILL, false)?
     .visit_field::<f64>("dirDev", Self::VT_DIRDEV, false)?
     .visit_field::<bool>("windVar", Self::VT_WINDVAR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("windCov", Self::VT_WINDCOV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("cloudCover", Self::VT_CLOUDCOVER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("cloudHght", Self::VT_CLOUDHGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("actWeather", Self::VT_ACTWEATHER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("weatherDesc", Self::VT_WEATHERDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("weatherInt", Self::VT_WEATHERINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawMETAR", Self::VT_RAWMETAR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawTAF", Self::VT_RAWTAF, false)?
     .visit_field::<f64>("qnh", Self::VT_QNH, false)?
     .visit_field::<f64>("visibility", Self::VT_VISIBILITY, false)?
     .visit_field::<f64>("temperature", Self::VT_TEMPERATURE, false)?
     .visit_field::<f64>("soilTemp", Self::VT_SOILTEMP, false)?
     .visit_field::<f64>("barPress", Self::VT_BARPRESS, false)?
     .visit_field::<f64>("precipRate", Self::VT_PRECIPRATE, false)?
     .visit_field::<f64>("rainHour", Self::VT_RAINHOUR, false)?
     .visit_field::<f64>("solarRad", Self::VT_SOLARRAD, false)?
     .visit_field::<f64>("difRad", Self::VT_DIFRAD, false)?
     .visit_field::<f64>("refRad", Self::VT_REFRAD, false)?
     .visit_field::<f64>("senlat", Self::VT_SENLAT, false)?
     .visit_field::<f64>("senlon", Self::VT_SENLON, false)?
     .visit_field::<f64>("senalt", Self::VT_SENALT, false)?
     .visit_field::<f64>("dewPoint", Self::VT_DEWPOINT, false)?
     .visit_field::<f64>("relHumidity", Self::VT_RELHUMIDITY, false)?
     .visit_field::<f64>("indexRefraction", Self::VT_INDEXREFRACTION, false)?
     .visit_field::<f64>("soilMoisture", Self::VT_SOILMOISTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("surroundingWeather", Self::VT_SURROUNDINGWEATHER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("weatherAmp", Self::VT_WEATHERAMP, false)?
     .visit_field::<f64>("contrailHghtLower", Self::VT_CONTRAILHGHTLOWER, false)?
     .visit_field::<f64>("contrailHghtUpper", Self::VT_CONTRAILHGHTUPPER, false)?
     .visit_field::<f64>("icingUpperLimit", Self::VT_ICINGUPPERLIMIT, false)?
     .visit_field::<f64>("icingLowerLimit", Self::VT_ICINGLOWERLIMIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("enRouteWeather", Self::VT_ENROUTEWEATHER, false)?
     .visit_field::<bool>("ccEvent", Self::VT_CCEVENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("srcTyps", Self::VT_SRCTYPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("srcIds", Self::VT_SRCIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<WeatherReport_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct WeatherReport_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idGroundImagery: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSite: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idAirfield: Option<flatbuffers::WIPOffset<&'a str>>,
    pub icao: Option<flatbuffers::WIPOffset<&'a str>>,
    pub externalId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub externalLocationId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reportType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub forecastStartTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub forecastEndTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lat: f64,
    pub lon: f64,
    pub alt: f64,
    pub geoPotentialAlt: f64,
    pub dataLevel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub atext: Option<flatbuffers::WIPOffset<&'a str>>,
    pub agjson: Option<flatbuffers::WIPOffset<&'a str>>,
    pub atype: Option<flatbuffers::WIPOffset<&'a str>>,
    pub andims: i32,
    pub asrid: i32,
    pub windSpd: f64,
    pub windSpdAvg: f64,
    pub windGust: f64,
    pub windGust10: f64,
    pub vshear: f64,
    pub hshear: f64,
    pub radVel: f64,
    pub radVelBeam1: f64,
    pub radVelBeam2: f64,
    pub radVelBeam3: f64,
    pub radVelBeam4: f64,
    pub radVelBeam5: f64,
    pub windDir: f64,
    pub windDirAvg: f64,
    pub windDirPeak: f64,
    pub windDirPeak10: f64,
    pub windChill: f64,
    pub dirDev: f64,
    pub windVar: bool,
    pub windCov: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub cloudCover: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub cloudHght: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub actWeather: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherInt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rawMETAR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rawTAF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub qnh: f64,
    pub visibility: f64,
    pub temperature: f64,
    pub soilTemp: f64,
    pub barPress: f64,
    pub precipRate: f64,
    pub rainHour: f64,
    pub solarRad: f64,
    pub difRad: f64,
    pub refRad: f64,
    pub senlat: f64,
    pub senlon: f64,
    pub senalt: f64,
    pub dewPoint: f64,
    pub relHumidity: f64,
    pub indexRefraction: f64,
    pub soilMoisture: f64,
    pub surroundingWeather: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weatherAmp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub contrailHghtLower: f64,
    pub contrailHghtUpper: f64,
    pub icingUpperLimit: f64,
    pub icingLowerLimit: f64,
    pub enRouteWeather: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ccEvent: bool,
    pub srcTyps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub srcIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: WeatherReport_Abridged_dataMode_Enum,
}
impl<'a> Default for WeatherReport_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    WeatherReport_AbridgedArgs {
      id: None,
      classificationMarking: None,
      idSensor: None,
      origSensorId: None,
      weatherId: None,
      idGroundImagery: None,
      idSite: None,
      idAirfield: None,
      icao: None,
      externalId: None,
      externalLocationId: None,
      reportType: None,
      obTime: None,
      forecastStartTime: None,
      forecastEndTime: None,
      lat: 0.0,
      lon: 0.0,
      alt: 0.0,
      geoPotentialAlt: 0.0,
      dataLevel: None,
      atext: None,
      agjson: None,
      atype: None,
      andims: 0,
      asrid: 0,
      windSpd: 0.0,
      windSpdAvg: 0.0,
      windGust: 0.0,
      windGust10: 0.0,
      vshear: 0.0,
      hshear: 0.0,
      radVel: 0.0,
      radVelBeam1: 0.0,
      radVelBeam2: 0.0,
      radVelBeam3: 0.0,
      radVelBeam4: 0.0,
      radVelBeam5: 0.0,
      windDir: 0.0,
      windDirAvg: 0.0,
      windDirPeak: 0.0,
      windDirPeak10: 0.0,
      windChill: 0.0,
      dirDev: 0.0,
      windVar: false,
      windCov: None,
      cloudCover: None,
      cloudHght: None,
      actWeather: None,
      weatherDesc: None,
      weatherInt: None,
      rawMETAR: None,
      rawTAF: None,
      qnh: 0.0,
      visibility: 0.0,
      temperature: 0.0,
      soilTemp: 0.0,
      barPress: 0.0,
      precipRate: 0.0,
      rainHour: 0.0,
      solarRad: 0.0,
      difRad: 0.0,
      refRad: 0.0,
      senlat: 0.0,
      senlon: 0.0,
      senalt: 0.0,
      dewPoint: 0.0,
      relHumidity: 0.0,
      indexRefraction: 0.0,
      soilMoisture: 0.0,
      surroundingWeather: None,
      weatherAmp: None,
      contrailHghtLower: 0.0,
      contrailHghtUpper: 0.0,
      icingUpperLimit: 0.0,
      icingLowerLimit: 0.0,
      enRouteWeather: None,
      ccEvent: false,
      srcTyps: None,
      srcIds: None,
      origNetwork: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: WeatherReport_Abridged_dataMode_Enum::REAL,
    }
  }
}

pub struct WeatherReport_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WeatherReport_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idSensor(&mut self, idSensor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_IDSENSOR, idSensor);
  }
  #[inline]
  pub fn add_origSensorId(&mut self, origSensorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_ORIGSENSORID, origSensorId);
  }
  #[inline]
  pub fn add_weatherId(&mut self, weatherId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_WEATHERID, weatherId);
  }
  #[inline]
  pub fn add_idGroundImagery(&mut self, idGroundImagery: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_IDGROUNDIMAGERY, idGroundImagery);
  }
  #[inline]
  pub fn add_idSite(&mut self, idSite: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_IDSITE, idSite);
  }
  #[inline]
  pub fn add_idAirfield(&mut self, idAirfield: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_IDAIRFIELD, idAirfield);
  }
  #[inline]
  pub fn add_icao(&mut self, icao: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_ICAO, icao);
  }
  #[inline]
  pub fn add_externalId(&mut self, externalId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_EXTERNALID, externalId);
  }
  #[inline]
  pub fn add_externalLocationId(&mut self, externalLocationId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_EXTERNALLOCATIONID, externalLocationId);
  }
  #[inline]
  pub fn add_reportType(&mut self, reportType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_REPORTTYPE, reportType);
  }
  #[inline]
  pub fn add_obTime(&mut self, obTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_OBTIME, obTime);
  }
  #[inline]
  pub fn add_forecastStartTime(&mut self, forecastStartTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_FORECASTSTARTTIME, forecastStartTime);
  }
  #[inline]
  pub fn add_forecastEndTime(&mut self, forecastEndTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_FORECASTENDTIME, forecastEndTime);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_alt(&mut self, alt: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_ALT, alt, 0.0);
  }
  #[inline]
  pub fn add_geoPotentialAlt(&mut self, geoPotentialAlt: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_GEOPOTENTIALALT, geoPotentialAlt, 0.0);
  }
  #[inline]
  pub fn add_dataLevel(&mut self, dataLevel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_DATALEVEL, dataLevel);
  }
  #[inline]
  pub fn add_atext(&mut self, atext: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_ATEXT, atext);
  }
  #[inline]
  pub fn add_agjson(&mut self, agjson: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_AGJSON, agjson);
  }
  #[inline]
  pub fn add_atype(&mut self, atype: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_ATYPE, atype);
  }
  #[inline]
  pub fn add_andims(&mut self, andims: i32) {
    self.fbb_.push_slot::<i32>(WeatherReport_Abridged::VT_ANDIMS, andims, 0);
  }
  #[inline]
  pub fn add_asrid(&mut self, asrid: i32) {
    self.fbb_.push_slot::<i32>(WeatherReport_Abridged::VT_ASRID, asrid, 0);
  }
  #[inline]
  pub fn add_windSpd(&mut self, windSpd: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_WINDSPD, windSpd, 0.0);
  }
  #[inline]
  pub fn add_windSpdAvg(&mut self, windSpdAvg: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_WINDSPDAVG, windSpdAvg, 0.0);
  }
  #[inline]
  pub fn add_windGust(&mut self, windGust: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_WINDGUST, windGust, 0.0);
  }
  #[inline]
  pub fn add_windGust10(&mut self, windGust10: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_WINDGUST10, windGust10, 0.0);
  }
  #[inline]
  pub fn add_vshear(&mut self, vshear: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_VSHEAR, vshear, 0.0);
  }
  #[inline]
  pub fn add_hshear(&mut self, hshear: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_HSHEAR, hshear, 0.0);
  }
  #[inline]
  pub fn add_radVel(&mut self, radVel: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_RADVEL, radVel, 0.0);
  }
  #[inline]
  pub fn add_radVelBeam1(&mut self, radVelBeam1: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_RADVELBEAM1, radVelBeam1, 0.0);
  }
  #[inline]
  pub fn add_radVelBeam2(&mut self, radVelBeam2: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_RADVELBEAM2, radVelBeam2, 0.0);
  }
  #[inline]
  pub fn add_radVelBeam3(&mut self, radVelBeam3: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_RADVELBEAM3, radVelBeam3, 0.0);
  }
  #[inline]
  pub fn add_radVelBeam4(&mut self, radVelBeam4: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_RADVELBEAM4, radVelBeam4, 0.0);
  }
  #[inline]
  pub fn add_radVelBeam5(&mut self, radVelBeam5: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_RADVELBEAM5, radVelBeam5, 0.0);
  }
  #[inline]
  pub fn add_windDir(&mut self, windDir: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_WINDDIR, windDir, 0.0);
  }
  #[inline]
  pub fn add_windDirAvg(&mut self, windDirAvg: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_WINDDIRAVG, windDirAvg, 0.0);
  }
  #[inline]
  pub fn add_windDirPeak(&mut self, windDirPeak: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_WINDDIRPEAK, windDirPeak, 0.0);
  }
  #[inline]
  pub fn add_windDirPeak10(&mut self, windDirPeak10: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_WINDDIRPEAK10, windDirPeak10, 0.0);
  }
  #[inline]
  pub fn add_windChill(&mut self, windChill: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_WINDCHILL, windChill, 0.0);
  }
  #[inline]
  pub fn add_dirDev(&mut self, dirDev: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_DIRDEV, dirDev, 0.0);
  }
  #[inline]
  pub fn add_windVar(&mut self, windVar: bool) {
    self.fbb_.push_slot::<bool>(WeatherReport_Abridged::VT_WINDVAR, windVar, false);
  }
  #[inline]
  pub fn add_windCov(&mut self, windCov: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_WINDCOV, windCov);
  }
  #[inline]
  pub fn add_cloudCover(&mut self, cloudCover: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_CLOUDCOVER, cloudCover);
  }
  #[inline]
  pub fn add_cloudHght(&mut self, cloudHght: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_CLOUDHGHT, cloudHght);
  }
  #[inline]
  pub fn add_actWeather(&mut self, actWeather: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_ACTWEATHER, actWeather);
  }
  #[inline]
  pub fn add_weatherDesc(&mut self, weatherDesc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_WEATHERDESC, weatherDesc);
  }
  #[inline]
  pub fn add_weatherInt(&mut self, weatherInt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_WEATHERINT, weatherInt);
  }
  #[inline]
  pub fn add_rawMETAR(&mut self, rawMETAR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_RAWMETAR, rawMETAR);
  }
  #[inline]
  pub fn add_rawTAF(&mut self, rawTAF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_RAWTAF, rawTAF);
  }
  #[inline]
  pub fn add_qnh(&mut self, qnh: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_QNH, qnh, 0.0);
  }
  #[inline]
  pub fn add_visibility(&mut self, visibility: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_VISIBILITY, visibility, 0.0);
  }
  #[inline]
  pub fn add_temperature(&mut self, temperature: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_TEMPERATURE, temperature, 0.0);
  }
  #[inline]
  pub fn add_soilTemp(&mut self, soilTemp: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_SOILTEMP, soilTemp, 0.0);
  }
  #[inline]
  pub fn add_barPress(&mut self, barPress: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_BARPRESS, barPress, 0.0);
  }
  #[inline]
  pub fn add_precipRate(&mut self, precipRate: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_PRECIPRATE, precipRate, 0.0);
  }
  #[inline]
  pub fn add_rainHour(&mut self, rainHour: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_RAINHOUR, rainHour, 0.0);
  }
  #[inline]
  pub fn add_solarRad(&mut self, solarRad: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_SOLARRAD, solarRad, 0.0);
  }
  #[inline]
  pub fn add_difRad(&mut self, difRad: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_DIFRAD, difRad, 0.0);
  }
  #[inline]
  pub fn add_refRad(&mut self, refRad: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_REFRAD, refRad, 0.0);
  }
  #[inline]
  pub fn add_senlat(&mut self, senlat: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_SENLAT, senlat, 0.0);
  }
  #[inline]
  pub fn add_senlon(&mut self, senlon: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_SENLON, senlon, 0.0);
  }
  #[inline]
  pub fn add_senalt(&mut self, senalt: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_SENALT, senalt, 0.0);
  }
  #[inline]
  pub fn add_dewPoint(&mut self, dewPoint: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_DEWPOINT, dewPoint, 0.0);
  }
  #[inline]
  pub fn add_relHumidity(&mut self, relHumidity: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_RELHUMIDITY, relHumidity, 0.0);
  }
  #[inline]
  pub fn add_indexRefraction(&mut self, indexRefraction: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_INDEXREFRACTION, indexRefraction, 0.0);
  }
  #[inline]
  pub fn add_soilMoisture(&mut self, soilMoisture: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_SOILMOISTURE, soilMoisture, 0.0);
  }
  #[inline]
  pub fn add_surroundingWeather(&mut self, surroundingWeather: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_SURROUNDINGWEATHER, surroundingWeather);
  }
  #[inline]
  pub fn add_weatherAmp(&mut self, weatherAmp: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_WEATHERAMP, weatherAmp);
  }
  #[inline]
  pub fn add_contrailHghtLower(&mut self, contrailHghtLower: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_CONTRAILHGHTLOWER, contrailHghtLower, 0.0);
  }
  #[inline]
  pub fn add_contrailHghtUpper(&mut self, contrailHghtUpper: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_CONTRAILHGHTUPPER, contrailHghtUpper, 0.0);
  }
  #[inline]
  pub fn add_icingUpperLimit(&mut self, icingUpperLimit: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_ICINGUPPERLIMIT, icingUpperLimit, 0.0);
  }
  #[inline]
  pub fn add_icingLowerLimit(&mut self, icingLowerLimit: f64) {
    self.fbb_.push_slot::<f64>(WeatherReport_Abridged::VT_ICINGLOWERLIMIT, icingLowerLimit, 0.0);
  }
  #[inline]
  pub fn add_enRouteWeather(&mut self, enRouteWeather: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_ENROUTEWEATHER, enRouteWeather);
  }
  #[inline]
  pub fn add_ccEvent(&mut self, ccEvent: bool) {
    self.fbb_.push_slot::<bool>(WeatherReport_Abridged::VT_CCEVENT, ccEvent, false);
  }
  #[inline]
  pub fn add_srcTyps(&mut self, srcTyps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_SRCTYPS, srcTyps);
  }
  #[inline]
  pub fn add_srcIds(&mut self, srcIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_SRCIDS, srcIds);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherReport_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: WeatherReport_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<WeatherReport_Abridged_dataMode_Enum>(WeatherReport_Abridged::VT_DATAMODE, dataMode, WeatherReport_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WeatherReport_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WeatherReport_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WeatherReport_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WeatherReport_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WeatherReport_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idSensor", &self.idSensor());
      ds.field("origSensorId", &self.origSensorId());
      ds.field("weatherId", &self.weatherId());
      ds.field("idGroundImagery", &self.idGroundImagery());
      ds.field("idSite", &self.idSite());
      ds.field("idAirfield", &self.idAirfield());
      ds.field("icao", &self.icao());
      ds.field("externalId", &self.externalId());
      ds.field("externalLocationId", &self.externalLocationId());
      ds.field("reportType", &self.reportType());
      ds.field("obTime", &self.obTime());
      ds.field("forecastStartTime", &self.forecastStartTime());
      ds.field("forecastEndTime", &self.forecastEndTime());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("alt", &self.alt());
      ds.field("geoPotentialAlt", &self.geoPotentialAlt());
      ds.field("dataLevel", &self.dataLevel());
      ds.field("atext", &self.atext());
      ds.field("agjson", &self.agjson());
      ds.field("atype", &self.atype());
      ds.field("andims", &self.andims());
      ds.field("asrid", &self.asrid());
      ds.field("windSpd", &self.windSpd());
      ds.field("windSpdAvg", &self.windSpdAvg());
      ds.field("windGust", &self.windGust());
      ds.field("windGust10", &self.windGust10());
      ds.field("vshear", &self.vshear());
      ds.field("hshear", &self.hshear());
      ds.field("radVel", &self.radVel());
      ds.field("radVelBeam1", &self.radVelBeam1());
      ds.field("radVelBeam2", &self.radVelBeam2());
      ds.field("radVelBeam3", &self.radVelBeam3());
      ds.field("radVelBeam4", &self.radVelBeam4());
      ds.field("radVelBeam5", &self.radVelBeam5());
      ds.field("windDir", &self.windDir());
      ds.field("windDirAvg", &self.windDirAvg());
      ds.field("windDirPeak", &self.windDirPeak());
      ds.field("windDirPeak10", &self.windDirPeak10());
      ds.field("windChill", &self.windChill());
      ds.field("dirDev", &self.dirDev());
      ds.field("windVar", &self.windVar());
      ds.field("windCov", &self.windCov());
      ds.field("cloudCover", &self.cloudCover());
      ds.field("cloudHght", &self.cloudHght());
      ds.field("actWeather", &self.actWeather());
      ds.field("weatherDesc", &self.weatherDesc());
      ds.field("weatherInt", &self.weatherInt());
      ds.field("rawMETAR", &self.rawMETAR());
      ds.field("rawTAF", &self.rawTAF());
      ds.field("qnh", &self.qnh());
      ds.field("visibility", &self.visibility());
      ds.field("temperature", &self.temperature());
      ds.field("soilTemp", &self.soilTemp());
      ds.field("barPress", &self.barPress());
      ds.field("precipRate", &self.precipRate());
      ds.field("rainHour", &self.rainHour());
      ds.field("solarRad", &self.solarRad());
      ds.field("difRad", &self.difRad());
      ds.field("refRad", &self.refRad());
      ds.field("senlat", &self.senlat());
      ds.field("senlon", &self.senlon());
      ds.field("senalt", &self.senalt());
      ds.field("dewPoint", &self.dewPoint());
      ds.field("relHumidity", &self.relHumidity());
      ds.field("indexRefraction", &self.indexRefraction());
      ds.field("soilMoisture", &self.soilMoisture());
      ds.field("surroundingWeather", &self.surroundingWeather());
      ds.field("weatherAmp", &self.weatherAmp());
      ds.field("contrailHghtLower", &self.contrailHghtLower());
      ds.field("contrailHghtUpper", &self.contrailHghtUpper());
      ds.field("icingUpperLimit", &self.icingUpperLimit());
      ds.field("icingLowerLimit", &self.icingLowerLimit());
      ds.field("enRouteWeather", &self.enRouteWeather());
      ds.field("ccEvent", &self.ccEvent());
      ds.field("srcTyps", &self.srcTyps());
      ds.field("srcIds", &self.srcIds());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct WeatherReport_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idSensor: Option<String>,
  pub origSensorId: Option<String>,
  pub weatherId: Option<String>,
  pub idGroundImagery: Option<String>,
  pub idSite: Option<String>,
  pub idAirfield: Option<String>,
  pub icao: Option<String>,
  pub externalId: Option<String>,
  pub externalLocationId: Option<String>,
  pub reportType: Option<String>,
  pub obTime: Option<String>,
  pub forecastStartTime: Option<String>,
  pub forecastEndTime: Option<String>,
  pub lat: f64,
  pub lon: f64,
  pub alt: f64,
  pub geoPotentialAlt: f64,
  pub dataLevel: Option<String>,
  pub atext: Option<String>,
  pub agjson: Option<String>,
  pub atype: Option<String>,
  pub andims: i32,
  pub asrid: i32,
  pub windSpd: f64,
  pub windSpdAvg: f64,
  pub windGust: f64,
  pub windGust10: f64,
  pub vshear: f64,
  pub hshear: f64,
  pub radVel: f64,
  pub radVelBeam1: f64,
  pub radVelBeam2: f64,
  pub radVelBeam3: f64,
  pub radVelBeam4: f64,
  pub radVelBeam5: f64,
  pub windDir: f64,
  pub windDirAvg: f64,
  pub windDirPeak: f64,
  pub windDirPeak10: f64,
  pub windChill: f64,
  pub dirDev: f64,
  pub windVar: bool,
  pub windCov: Option<Vec<String>>,
  pub cloudCover: Option<Vec<String>>,
  pub cloudHght: Option<Vec<String>>,
  pub actWeather: Option<String>,
  pub weatherDesc: Option<String>,
  pub weatherInt: Option<String>,
  pub rawMETAR: Option<String>,
  pub rawTAF: Option<String>,
  pub qnh: f64,
  pub visibility: f64,
  pub temperature: f64,
  pub soilTemp: f64,
  pub barPress: f64,
  pub precipRate: f64,
  pub rainHour: f64,
  pub solarRad: f64,
  pub difRad: f64,
  pub refRad: f64,
  pub senlat: f64,
  pub senlon: f64,
  pub senalt: f64,
  pub dewPoint: f64,
  pub relHumidity: f64,
  pub indexRefraction: f64,
  pub soilMoisture: f64,
  pub surroundingWeather: Option<String>,
  pub weatherAmp: Option<String>,
  pub contrailHghtLower: f64,
  pub contrailHghtUpper: f64,
  pub icingUpperLimit: f64,
  pub icingLowerLimit: f64,
  pub enRouteWeather: Option<String>,
  pub ccEvent: bool,
  pub srcTyps: Option<Vec<String>>,
  pub srcIds: Option<Vec<String>>,
  pub origNetwork: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: WeatherReport_Abridged_dataMode_Enum,
}
impl Default for WeatherReport_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idSensor: None,
      origSensorId: None,
      weatherId: None,
      idGroundImagery: None,
      idSite: None,
      idAirfield: None,
      icao: None,
      externalId: None,
      externalLocationId: None,
      reportType: None,
      obTime: None,
      forecastStartTime: None,
      forecastEndTime: None,
      lat: 0.0,
      lon: 0.0,
      alt: 0.0,
      geoPotentialAlt: 0.0,
      dataLevel: None,
      atext: None,
      agjson: None,
      atype: None,
      andims: 0,
      asrid: 0,
      windSpd: 0.0,
      windSpdAvg: 0.0,
      windGust: 0.0,
      windGust10: 0.0,
      vshear: 0.0,
      hshear: 0.0,
      radVel: 0.0,
      radVelBeam1: 0.0,
      radVelBeam2: 0.0,
      radVelBeam3: 0.0,
      radVelBeam4: 0.0,
      radVelBeam5: 0.0,
      windDir: 0.0,
      windDirAvg: 0.0,
      windDirPeak: 0.0,
      windDirPeak10: 0.0,
      windChill: 0.0,
      dirDev: 0.0,
      windVar: false,
      windCov: None,
      cloudCover: None,
      cloudHght: None,
      actWeather: None,
      weatherDesc: None,
      weatherInt: None,
      rawMETAR: None,
      rawTAF: None,
      qnh: 0.0,
      visibility: 0.0,
      temperature: 0.0,
      soilTemp: 0.0,
      barPress: 0.0,
      precipRate: 0.0,
      rainHour: 0.0,
      solarRad: 0.0,
      difRad: 0.0,
      refRad: 0.0,
      senlat: 0.0,
      senlon: 0.0,
      senalt: 0.0,
      dewPoint: 0.0,
      relHumidity: 0.0,
      indexRefraction: 0.0,
      soilMoisture: 0.0,
      surroundingWeather: None,
      weatherAmp: None,
      contrailHghtLower: 0.0,
      contrailHghtUpper: 0.0,
      icingUpperLimit: 0.0,
      icingLowerLimit: 0.0,
      enRouteWeather: None,
      ccEvent: false,
      srcTyps: None,
      srcIds: None,
      origNetwork: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: WeatherReport_Abridged_dataMode_Enum::REAL,
    }
  }
}
impl WeatherReport_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<WeatherReport_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor = self.idSensor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId = self.origSensorId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let weatherId = self.weatherId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idGroundImagery = self.idGroundImagery.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSite = self.idSite.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idAirfield = self.idAirfield.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let icao = self.icao.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let externalId = self.externalId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let externalLocationId = self.externalLocationId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reportType = self.reportType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let obTime = self.obTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let forecastStartTime = self.forecastStartTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let forecastEndTime = self.forecastEndTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lat = self.lat;
    let lon = self.lon;
    let alt = self.alt;
    let geoPotentialAlt = self.geoPotentialAlt;
    let dataLevel = self.dataLevel.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let atext = self.atext.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let agjson = self.agjson.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let atype = self.atype.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let andims = self.andims;
    let asrid = self.asrid;
    let windSpd = self.windSpd;
    let windSpdAvg = self.windSpdAvg;
    let windGust = self.windGust;
    let windGust10 = self.windGust10;
    let vshear = self.vshear;
    let hshear = self.hshear;
    let radVel = self.radVel;
    let radVelBeam1 = self.radVelBeam1;
    let radVelBeam2 = self.radVelBeam2;
    let radVelBeam3 = self.radVelBeam3;
    let radVelBeam4 = self.radVelBeam4;
    let radVelBeam5 = self.radVelBeam5;
    let windDir = self.windDir;
    let windDirAvg = self.windDirAvg;
    let windDirPeak = self.windDirPeak;
    let windDirPeak10 = self.windDirPeak10;
    let windChill = self.windChill;
    let dirDev = self.dirDev;
    let windVar = self.windVar;
    let windCov = self.windCov.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let cloudCover = self.cloudCover.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let cloudHght = self.cloudHght.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let actWeather = self.actWeather.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let weatherDesc = self.weatherDesc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let weatherInt = self.weatherInt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rawMETAR = self.rawMETAR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rawTAF = self.rawTAF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let qnh = self.qnh;
    let visibility = self.visibility;
    let temperature = self.temperature;
    let soilTemp = self.soilTemp;
    let barPress = self.barPress;
    let precipRate = self.precipRate;
    let rainHour = self.rainHour;
    let solarRad = self.solarRad;
    let difRad = self.difRad;
    let refRad = self.refRad;
    let senlat = self.senlat;
    let senlon = self.senlon;
    let senalt = self.senalt;
    let dewPoint = self.dewPoint;
    let relHumidity = self.relHumidity;
    let indexRefraction = self.indexRefraction;
    let soilMoisture = self.soilMoisture;
    let surroundingWeather = self.surroundingWeather.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let weatherAmp = self.weatherAmp.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let contrailHghtLower = self.contrailHghtLower;
    let contrailHghtUpper = self.contrailHghtUpper;
    let icingUpperLimit = self.icingUpperLimit;
    let icingLowerLimit = self.icingLowerLimit;
    let enRouteWeather = self.enRouteWeather.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ccEvent = self.ccEvent;
    let srcTyps = self.srcTyps.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let srcIds = self.srcIds.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    WeatherReport_Abridged::create(_fbb, &WeatherReport_AbridgedArgs{
      id,
      classificationMarking,
      idSensor,
      origSensorId,
      weatherId,
      idGroundImagery,
      idSite,
      idAirfield,
      icao,
      externalId,
      externalLocationId,
      reportType,
      obTime,
      forecastStartTime,
      forecastEndTime,
      lat,
      lon,
      alt,
      geoPotentialAlt,
      dataLevel,
      atext,
      agjson,
      atype,
      andims,
      asrid,
      windSpd,
      windSpdAvg,
      windGust,
      windGust10,
      vshear,
      hshear,
      radVel,
      radVelBeam1,
      radVelBeam2,
      radVelBeam3,
      radVelBeam4,
      radVelBeam5,
      windDir,
      windDirAvg,
      windDirPeak,
      windDirPeak10,
      windChill,
      dirDev,
      windVar,
      windCov,
      cloudCover,
      cloudHght,
      actWeather,
      weatherDesc,
      weatherInt,
      rawMETAR,
      rawTAF,
      qnh,
      visibility,
      temperature,
      soilTemp,
      barPress,
      precipRate,
      rainHour,
      solarRad,
      difRad,
      refRad,
      senlat,
      senlon,
      senalt,
      dewPoint,
      relHumidity,
      indexRefraction,
      soilMoisture,
      surroundingWeather,
      weatherAmp,
      contrailHghtLower,
      contrailHghtUpper,
      icingUpperLimit,
      icingLowerLimit,
      enRouteWeather,
      ccEvent,
      srcTyps,
      srcIds,
      origNetwork,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `WeatherReport_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_weather_report_abridged_unchecked`.
pub fn root_as_weather_report_abridged(buf: &[u8]) -> Result<WeatherReport_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<WeatherReport_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `WeatherReport_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_weather_report_abridged_unchecked`.
pub fn size_prefixed_root_as_weather_report_abridged(buf: &[u8]) -> Result<WeatherReport_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<WeatherReport_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `WeatherReport_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_weather_report_abridged_unchecked`.
pub fn root_as_weather_report_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<WeatherReport_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<WeatherReport_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `WeatherReport_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_weather_report_abridged_unchecked`.
pub fn size_prefixed_root_as_weather_report_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<WeatherReport_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<WeatherReport_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a WeatherReport_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `WeatherReport_Abridged`.
pub unsafe fn root_as_weather_report_abridged_unchecked(buf: &[u8]) -> WeatherReport_Abridged {
  flatbuffers::root_unchecked::<WeatherReport_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed WeatherReport_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `WeatherReport_Abridged`.
pub unsafe fn size_prefixed_root_as_weather_report_abridged_unchecked(buf: &[u8]) -> WeatherReport_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<WeatherReport_Abridged>(buf)
}
pub const WEATHER_REPORT_ABRIDGED_IDENTIFIER: &str = "WEAT";

#[inline]
pub fn weather_report_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, WEATHER_REPORT_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn weather_report_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, WEATHER_REPORT_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_weather_report_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<WeatherReport_Abridged<'a>>) {
  fbb.finish(root, Some(WEATHER_REPORT_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_weather_report_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<WeatherReport_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(WEATHER_REPORT_ABRIDGED_IDENTIFIER));
}
