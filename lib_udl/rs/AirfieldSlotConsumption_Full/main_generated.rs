// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AIRFIELD_SLOT_CONSUMPTION_FULL_STATUS_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AIRFIELD_SLOT_CONSUMPTION_FULL_STATUS_ENUM: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AIRFIELD_SLOT_CONSUMPTION_FULL_STATUS_ENUM: [AirfieldSlotConsumption_Full_status_Enum; 5] = [
  AirfieldSlotConsumption_Full_status_Enum::REQUESTED,
  AirfieldSlotConsumption_Full_status_Enum::APPROVED,
  AirfieldSlotConsumption_Full_status_Enum::DENIED,
  AirfieldSlotConsumption_Full_status_Enum::BLOCKED,
  AirfieldSlotConsumption_Full_status_Enum::OTHER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AirfieldSlotConsumption_Full_status_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AirfieldSlotConsumption_Full_status_Enum {
  /// No description available.
  pub const REQUESTED: Self = Self(0);
  /// No description available.
  pub const APPROVED: Self = Self(1);
  /// No description available.
  pub const DENIED: Self = Self(2);
  /// No description available.
  pub const BLOCKED: Self = Self(3);
  /// No description available.
  pub const OTHER: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REQUESTED,
    Self::APPROVED,
    Self::DENIED,
    Self::BLOCKED,
    Self::OTHER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REQUESTED => Some("REQUESTED"),
      Self::APPROVED => Some("APPROVED"),
      Self::DENIED => Some("DENIED"),
      Self::BLOCKED => Some("BLOCKED"),
      Self::OTHER => Some("OTHER"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AirfieldSlotConsumption_Full_status_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AirfieldSlotConsumption_Full_status_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AirfieldSlotConsumption_Full_status_Enum {
    type Output = AirfieldSlotConsumption_Full_status_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AirfieldSlotConsumption_Full_status_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AirfieldSlotConsumption_Full_status_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AirfieldSlotConsumption_Full_status_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AIRFIELD_SLOT_CONSUMPTION_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AIRFIELD_SLOT_CONSUMPTION_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AIRFIELD_SLOT_CONSUMPTION_FULL_DATA_MODE_ENUM: [AirfieldSlotConsumption_Full_dataMode_Enum; 4] = [
  AirfieldSlotConsumption_Full_dataMode_Enum::REAL,
  AirfieldSlotConsumption_Full_dataMode_Enum::TEST,
  AirfieldSlotConsumption_Full_dataMode_Enum::SIMULATED,
  AirfieldSlotConsumption_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AirfieldSlotConsumption_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AirfieldSlotConsumption_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AirfieldSlotConsumption_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AirfieldSlotConsumption_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AirfieldSlotConsumption_Full_dataMode_Enum {
    type Output = AirfieldSlotConsumption_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AirfieldSlotConsumption_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AirfieldSlotConsumption_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AirfieldSlotConsumption_Full_dataMode_Enum {}
pub enum AirfieldSlotConsumption_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Airfield slot use data. Contains the dynamic data associated with the status and use of specific airfield slots.
pub struct AirfieldSlotConsumption_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AirfieldSlotConsumption_Full<'a> {
  type Inner = AirfieldSlotConsumption_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AirfieldSlotConsumption_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDAIRFIELDSLOT: flatbuffers::VOffsetT = 8;
  pub const VT_STATUS: flatbuffers::VOffsetT = 10;
  pub const VT_OCCUPIED: flatbuffers::VOffsetT = 12;
  pub const VT_CONSUMER: flatbuffers::VOffsetT = 14;
  pub const VT_OCCAIRCRAFTMDS: flatbuffers::VOffsetT = 16;
  pub const VT_OCCTAILNUMBER: flatbuffers::VOffsetT = 18;
  pub const VT_CALLSIGNS: flatbuffers::VOffsetT = 20;
  pub const VT_MISSIONID: flatbuffers::VOffsetT = 22;
  pub const VT_NUMAIRCRAFT: flatbuffers::VOffsetT = 24;
  pub const VT_OCCSTARTTIME: flatbuffers::VOffsetT = 26;
  pub const VT_RESAIRCRAFTMDS: flatbuffers::VOffsetT = 28;
  pub const VT_RESTAILNUMBER: flatbuffers::VOffsetT = 30;
  pub const VT_RESTYPE: flatbuffers::VOffsetT = 32;
  pub const VT_RESREASON: flatbuffers::VOffsetT = 34;
  pub const VT_RESMISSIONID: flatbuffers::VOffsetT = 36;
  pub const VT_STARTTIME: flatbuffers::VOffsetT = 38;
  pub const VT_ENDTIME: flatbuffers::VOffsetT = 40;
  pub const VT_TARGETTIME: flatbuffers::VOffsetT = 42;
  pub const VT_IDARRSORTIE: flatbuffers::VOffsetT = 44;
  pub const VT_IDDEPSORTIE: flatbuffers::VOffsetT = 46;
  pub const VT_ALTARRSORTIEID: flatbuffers::VOffsetT = 48;
  pub const VT_ALTDEPSORTIEID: flatbuffers::VOffsetT = 50;
  pub const VT_REQCOMMENT: flatbuffers::VOffsetT = 52;
  pub const VT_APPCOMMENT: flatbuffers::VOffsetT = 54;
  pub const VT_REQORG: flatbuffers::VOffsetT = 56;
  pub const VT_REQINITIALS: flatbuffers::VOffsetT = 58;
  pub const VT_APPORG: flatbuffers::VOffsetT = 60;
  pub const VT_APPINITIALS: flatbuffers::VOffsetT = 62;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 64;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 66;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 68;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 70;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 72;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 74;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 76;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 78;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 80;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AirfieldSlotConsumption_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AirfieldSlotConsumption_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<AirfieldSlotConsumption_Full<'bldr>> {
    let mut builder = AirfieldSlotConsumption_FullBuilder::new(_fbb);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.appInitials { builder.add_appInitials(x); }
    if let Some(x) = args.appOrg { builder.add_appOrg(x); }
    if let Some(x) = args.reqInitials { builder.add_reqInitials(x); }
    if let Some(x) = args.reqOrg { builder.add_reqOrg(x); }
    if let Some(x) = args.appComment { builder.add_appComment(x); }
    if let Some(x) = args.reqComment { builder.add_reqComment(x); }
    if let Some(x) = args.altDepSortieId { builder.add_altDepSortieId(x); }
    if let Some(x) = args.altArrSortieId { builder.add_altArrSortieId(x); }
    if let Some(x) = args.idDepSortie { builder.add_idDepSortie(x); }
    if let Some(x) = args.idArrSortie { builder.add_idArrSortie(x); }
    if let Some(x) = args.targetTime { builder.add_targetTime(x); }
    if let Some(x) = args.endTime { builder.add_endTime(x); }
    if let Some(x) = args.startTime { builder.add_startTime(x); }
    if let Some(x) = args.resMissionId { builder.add_resMissionId(x); }
    if let Some(x) = args.resReason { builder.add_resReason(x); }
    if let Some(x) = args.resType { builder.add_resType(x); }
    if let Some(x) = args.resTailNumber { builder.add_resTailNumber(x); }
    if let Some(x) = args.resAircraftMDS { builder.add_resAircraftMDS(x); }
    if let Some(x) = args.occStartTime { builder.add_occStartTime(x); }
    builder.add_numAircraft(args.numAircraft);
    if let Some(x) = args.missionId { builder.add_missionId(x); }
    if let Some(x) = args.callSigns { builder.add_callSigns(x); }
    if let Some(x) = args.occTailNumber { builder.add_occTailNumber(x); }
    if let Some(x) = args.occAircraftMDS { builder.add_occAircraftMDS(x); }
    if let Some(x) = args.consumer { builder.add_consumer(x); }
    if let Some(x) = args.idAirfieldSlot { builder.add_idAirfieldSlot(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_occupied(args.occupied);
    builder.add_status(args.status);
    builder.finish()
  }

  pub fn unpack(&self) -> AirfieldSlotConsumption_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idAirfieldSlot = self.idAirfieldSlot().map(|x| {
      x.to_string()
    });
    let status = self.status();
    let occupied = self.occupied();
    let consumer = self.consumer().map(|x| {
      x.to_string()
    });
    let occAircraftMDS = self.occAircraftMDS().map(|x| {
      x.to_string()
    });
    let occTailNumber = self.occTailNumber().map(|x| {
      x.to_string()
    });
    let callSigns = self.callSigns().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let missionId = self.missionId().map(|x| {
      x.to_string()
    });
    let numAircraft = self.numAircraft();
    let occStartTime = self.occStartTime().map(|x| {
      x.to_string()
    });
    let resAircraftMDS = self.resAircraftMDS().map(|x| {
      x.to_string()
    });
    let resTailNumber = self.resTailNumber().map(|x| {
      x.to_string()
    });
    let resType = self.resType().map(|x| {
      x.to_string()
    });
    let resReason = self.resReason().map(|x| {
      x.to_string()
    });
    let resMissionId = self.resMissionId().map(|x| {
      x.to_string()
    });
    let startTime = self.startTime().map(|x| {
      x.to_string()
    });
    let endTime = self.endTime().map(|x| {
      x.to_string()
    });
    let targetTime = self.targetTime().map(|x| {
      x.to_string()
    });
    let idArrSortie = self.idArrSortie().map(|x| {
      x.to_string()
    });
    let idDepSortie = self.idDepSortie().map(|x| {
      x.to_string()
    });
    let altArrSortieId = self.altArrSortieId().map(|x| {
      x.to_string()
    });
    let altDepSortieId = self.altDepSortieId().map(|x| {
      x.to_string()
    });
    let reqComment = self.reqComment().map(|x| {
      x.to_string()
    });
    let appComment = self.appComment().map(|x| {
      x.to_string()
    });
    let reqOrg = self.reqOrg().map(|x| {
      x.to_string()
    });
    let reqInitials = self.reqInitials().map(|x| {
      x.to_string()
    });
    let appOrg = self.appOrg().map(|x| {
      x.to_string()
    });
    let appInitials = self.appInitials().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    AirfieldSlotConsumption_FullT {
      id,
      classificationMarking,
      idAirfieldSlot,
      status,
      occupied,
      consumer,
      occAircraftMDS,
      occTailNumber,
      callSigns,
      missionId,
      numAircraft,
      occStartTime,
      resAircraftMDS,
      resTailNumber,
      resType,
      resReason,
      resMissionId,
      startTime,
      endTime,
      targetTime,
      idArrSortie,
      idDepSortie,
      altArrSortieId,
      altDepSortieId,
      reqComment,
      appComment,
      reqOrg,
      reqInitials,
      appOrg,
      appInitials,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      sourceDL,
      source,
      origin,
      origNetwork,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: be831d39-1822-da9f-7ace-6cc5643397dc
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the airfield slot for which this slot consumption record is referencing.
  /// Example: /// Example: 3136498f-2969-3535-1432-e984b2e2e686
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn idAirfieldSlot(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_IDAIRFIELDSLOT, None)}
  }
  /// Current status of this slot (REQUESTED / APPROVED / DENIED / BLOCKED / OTHER).
  /// Example: /// Example: APPROVED
  /// Constraints: Minimum length = 0, Maximum length = 9
  #[inline]
  pub fn status(&self) -> AirfieldSlotConsumption_Full_status_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AirfieldSlotConsumption_Full_status_Enum>(AirfieldSlotConsumption_Full::VT_STATUS, Some(AirfieldSlotConsumption_Full_status_Enum::REQUESTED)).unwrap()}
  }
  /// Flag indicating if the slot is occupied.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn occupied(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AirfieldSlotConsumption_Full::VT_OCCUPIED, Some(false)).unwrap()}
  }
  /// Identifying name of the aircraft using this slot. Names are often Prior Permission Required (PPR) numbers or other similar human-readable identifiers.
  /// Example: /// Example: APRON1-230401001
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn consumer(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_CONSUMER, None)}
  }
  /// The aircraft Model Design Series designation of the aircraft occupying this slot.
  /// Example: /// Example: C017A
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn occAircraftMDS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_OCCAIRCRAFTMDS, None)}
  }
  /// The tail number of the aircraft occupying this slot.
  /// Example: /// Example: N702JG
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn occTailNumber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_OCCTAILNUMBER, None)}
  }
  /// Array of call signs of the aircraft using this slot.
  /// Example: /// Example: ['RCH123', 'ABC123', 'LLS442']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn callSigns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirfieldSlotConsumption_Full::VT_CALLSIGNS, None)}
  }
  /// Mission identifier using this slot according to Mobility Air Forces (MAF) Encode/Decode procedures.
  /// Example: /// Example: AJM123456123
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn missionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_MISSIONID, None)}
  }
  /// Number of aircraft using this slot for this time.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numAircraft(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldSlotConsumption_Full::VT_NUMAIRCRAFT, Some(0)).unwrap()}
  }
  /// Time the aircraft began occupying this slot, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-01-01T01:01:03.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn occStartTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_OCCSTARTTIME, None)}
  }
  /// The aircraft Model Design Series designation of the aircraft this slot is reserved for.
  /// Example: /// Example: C017A
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn resAircraftMDS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_RESAIRCRAFTMDS, None)}
  }
  /// The tail number of the aircraft this slot is reserved for.
  /// Example: /// Example: N702JG
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn resTailNumber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_RESTAILNUMBER, None)}
  }
  /// Indicates the type of reservation (e.g. M for Mission, A for Aircraft, O for Other).
  /// Example: /// Example: M
  /// Constraints: Minimum length = 0, Maximum length = 2
  #[inline]
  pub fn resType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_RESTYPE, None)}
  }
  /// The reason the slot reservation was made.
  /// Example: /// Example: Maintenance needed
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn resReason(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_RESREASON, None)}
  }
  /// Mission identifier reserving this slot according to Mobility Air Forces (MAF) Encode/Decode procedures.
  /// Example: /// Example: AJM123456123
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn resMissionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_RESMISSIONID, None)}
  }
  /// The start of the slot window, in ISO 8601 UTC format.
  /// Example: /// Example: 2023-01-01T01:01:01.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn startTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_STARTTIME, None)}
  }
  /// The end of the slot window, in ISO 8601 UTC format.
  /// Example: /// Example: 2023-01-01T01:01:01.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn endTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_ENDTIME, None)}
  }
  /// The desired time for aircraft action such as landing, take off, parking, etc., in ISO 8601 UTC format.
  /// Example: /// Example: 2023-01-01T01:01:01.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn targetTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_TARGETTIME, None)}
  }
  /// Unique identifier of the sortie arriving at the slot start time.
  /// Example: /// Example: be831d39-1822-da9f-7ace-6cc5643397dc
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idArrSortie(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_IDARRSORTIE, None)}
  }
  /// Unique identifier of the sortie departing at the slot end time.
  /// Example: /// Example: 1e6edeec-72e9-aaec-d33c-51147cb5ffdd
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idDepSortie(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_IDDEPSORTIE, None)}
  }
  /// Alternate identifier of the sortie arriving at the slot start time provided by the source.
  /// Example: /// Example: ALT-SORTIE-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn altArrSortieId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_ALTARRSORTIEID, None)}
  }
  /// Alternate identifier of the sortie departing at the slot end time provided by the source.
  /// Example: /// Example: ALT-SORTIE-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn altDepSortieId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_ALTDEPSORTIEID, None)}
  }
  /// Comments from the requester.
  /// Example: /// Example: Sorry for the late notice.
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn reqComment(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_REQCOMMENT, None)}
  }
  /// Comments from the approver.
  /// Example: /// Example: The request was denied due to inoperable fuel pumps.
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn appComment(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_APPCOMMENT, None)}
  }
  /// Short name of the organization requesting use of this slot.
  /// Example: /// Example: TACC
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn reqOrg(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_REQORG, None)}
  }
  /// Initials of the person requesting the use of this slot. Use SYSTEM if this request is auto-generated by an auto-planning system.
  /// Example: /// Example: CB
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn reqInitials(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_REQINITIALS, None)}
  }
  /// Short name of the organization approving the use of this slot.
  /// Example: /// Example: KCHS/BOPS
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn appOrg(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_APPORG, None)}
  }
  /// Initials of the person approving the use of this slot. Use SYSTEM if auto-approved without human involvement.
  /// Example: /// Example: CB
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn appInitials(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_APPINITIALS, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_CREATEDBY, None)}
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_UPDATEDBY, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_SOURCEDL, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldSlotConsumption_Full::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> AirfieldSlotConsumption_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AirfieldSlotConsumption_Full_dataMode_Enum>(AirfieldSlotConsumption_Full::VT_DATAMODE, Some(AirfieldSlotConsumption_Full_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AirfieldSlotConsumption_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idAirfieldSlot", Self::VT_IDAIRFIELDSLOT, false)?
     .visit_field::<AirfieldSlotConsumption_Full_status_Enum>("status", Self::VT_STATUS, false)?
     .visit_field::<bool>("occupied", Self::VT_OCCUPIED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("consumer", Self::VT_CONSUMER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("occAircraftMDS", Self::VT_OCCAIRCRAFTMDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("occTailNumber", Self::VT_OCCTAILNUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("callSigns", Self::VT_CALLSIGNS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("missionId", Self::VT_MISSIONID, false)?
     .visit_field::<i32>("numAircraft", Self::VT_NUMAIRCRAFT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("occStartTime", Self::VT_OCCSTARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("resAircraftMDS", Self::VT_RESAIRCRAFTMDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("resTailNumber", Self::VT_RESTAILNUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("resType", Self::VT_RESTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("resReason", Self::VT_RESREASON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("resMissionId", Self::VT_RESMISSIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("startTime", Self::VT_STARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endTime", Self::VT_ENDTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("targetTime", Self::VT_TARGETTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idArrSortie", Self::VT_IDARRSORTIE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idDepSortie", Self::VT_IDDEPSORTIE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altArrSortieId", Self::VT_ALTARRSORTIEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altDepSortieId", Self::VT_ALTDEPSORTIEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reqComment", Self::VT_REQCOMMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("appComment", Self::VT_APPCOMMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reqOrg", Self::VT_REQORG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reqInitials", Self::VT_REQINITIALS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("appOrg", Self::VT_APPORG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("appInitials", Self::VT_APPINITIALS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<AirfieldSlotConsumption_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct AirfieldSlotConsumption_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idAirfieldSlot: Option<flatbuffers::WIPOffset<&'a str>>,
    pub status: AirfieldSlotConsumption_Full_status_Enum,
    pub occupied: bool,
    pub consumer: Option<flatbuffers::WIPOffset<&'a str>>,
    pub occAircraftMDS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub occTailNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub callSigns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub missionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub numAircraft: i32,
    pub occStartTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub resAircraftMDS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub resTailNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub resType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub resReason: Option<flatbuffers::WIPOffset<&'a str>>,
    pub resMissionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub targetTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idArrSortie: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idDepSortie: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altArrSortieId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altDepSortieId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reqComment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub appComment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reqOrg: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reqInitials: Option<flatbuffers::WIPOffset<&'a str>>,
    pub appOrg: Option<flatbuffers::WIPOffset<&'a str>>,
    pub appInitials: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: AirfieldSlotConsumption_Full_dataMode_Enum,
}
impl<'a> Default for AirfieldSlotConsumption_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    AirfieldSlotConsumption_FullArgs {
      id: None,
      classificationMarking: None,
      idAirfieldSlot: None,
      status: AirfieldSlotConsumption_Full_status_Enum::REQUESTED,
      occupied: false,
      consumer: None,
      occAircraftMDS: None,
      occTailNumber: None,
      callSigns: None,
      missionId: None,
      numAircraft: 0,
      occStartTime: None,
      resAircraftMDS: None,
      resTailNumber: None,
      resType: None,
      resReason: None,
      resMissionId: None,
      startTime: None,
      endTime: None,
      targetTime: None,
      idArrSortie: None,
      idDepSortie: None,
      altArrSortieId: None,
      altDepSortieId: None,
      reqComment: None,
      appComment: None,
      reqOrg: None,
      reqInitials: None,
      appOrg: None,
      appInitials: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: AirfieldSlotConsumption_Full_dataMode_Enum::REAL,
    }
  }
}

pub struct AirfieldSlotConsumption_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AirfieldSlotConsumption_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idAirfieldSlot(&mut self, idAirfieldSlot: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_IDAIRFIELDSLOT, idAirfieldSlot);
  }
  #[inline]
  pub fn add_status(&mut self, status: AirfieldSlotConsumption_Full_status_Enum) {
    self.fbb_.push_slot::<AirfieldSlotConsumption_Full_status_Enum>(AirfieldSlotConsumption_Full::VT_STATUS, status, AirfieldSlotConsumption_Full_status_Enum::REQUESTED);
  }
  #[inline]
  pub fn add_occupied(&mut self, occupied: bool) {
    self.fbb_.push_slot::<bool>(AirfieldSlotConsumption_Full::VT_OCCUPIED, occupied, false);
  }
  #[inline]
  pub fn add_consumer(&mut self, consumer: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_CONSUMER, consumer);
  }
  #[inline]
  pub fn add_occAircraftMDS(&mut self, occAircraftMDS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_OCCAIRCRAFTMDS, occAircraftMDS);
  }
  #[inline]
  pub fn add_occTailNumber(&mut self, occTailNumber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_OCCTAILNUMBER, occTailNumber);
  }
  #[inline]
  pub fn add_callSigns(&mut self, callSigns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_CALLSIGNS, callSigns);
  }
  #[inline]
  pub fn add_missionId(&mut self, missionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_MISSIONID, missionId);
  }
  #[inline]
  pub fn add_numAircraft(&mut self, numAircraft: i32) {
    self.fbb_.push_slot::<i32>(AirfieldSlotConsumption_Full::VT_NUMAIRCRAFT, numAircraft, 0);
  }
  #[inline]
  pub fn add_occStartTime(&mut self, occStartTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_OCCSTARTTIME, occStartTime);
  }
  #[inline]
  pub fn add_resAircraftMDS(&mut self, resAircraftMDS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_RESAIRCRAFTMDS, resAircraftMDS);
  }
  #[inline]
  pub fn add_resTailNumber(&mut self, resTailNumber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_RESTAILNUMBER, resTailNumber);
  }
  #[inline]
  pub fn add_resType(&mut self, resType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_RESTYPE, resType);
  }
  #[inline]
  pub fn add_resReason(&mut self, resReason: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_RESREASON, resReason);
  }
  #[inline]
  pub fn add_resMissionId(&mut self, resMissionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_RESMISSIONID, resMissionId);
  }
  #[inline]
  pub fn add_startTime(&mut self, startTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_STARTTIME, startTime);
  }
  #[inline]
  pub fn add_endTime(&mut self, endTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_ENDTIME, endTime);
  }
  #[inline]
  pub fn add_targetTime(&mut self, targetTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_TARGETTIME, targetTime);
  }
  #[inline]
  pub fn add_idArrSortie(&mut self, idArrSortie: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_IDARRSORTIE, idArrSortie);
  }
  #[inline]
  pub fn add_idDepSortie(&mut self, idDepSortie: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_IDDEPSORTIE, idDepSortie);
  }
  #[inline]
  pub fn add_altArrSortieId(&mut self, altArrSortieId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_ALTARRSORTIEID, altArrSortieId);
  }
  #[inline]
  pub fn add_altDepSortieId(&mut self, altDepSortieId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_ALTDEPSORTIEID, altDepSortieId);
  }
  #[inline]
  pub fn add_reqComment(&mut self, reqComment: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_REQCOMMENT, reqComment);
  }
  #[inline]
  pub fn add_appComment(&mut self, appComment: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_APPCOMMENT, appComment);
  }
  #[inline]
  pub fn add_reqOrg(&mut self, reqOrg: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_REQORG, reqOrg);
  }
  #[inline]
  pub fn add_reqInitials(&mut self, reqInitials: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_REQINITIALS, reqInitials);
  }
  #[inline]
  pub fn add_appOrg(&mut self, appOrg: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_APPORG, appOrg);
  }
  #[inline]
  pub fn add_appInitials(&mut self, appInitials: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_APPINITIALS, appInitials);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldSlotConsumption_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: AirfieldSlotConsumption_Full_dataMode_Enum) {
    self.fbb_.push_slot::<AirfieldSlotConsumption_Full_dataMode_Enum>(AirfieldSlotConsumption_Full::VT_DATAMODE, dataMode, AirfieldSlotConsumption_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AirfieldSlotConsumption_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AirfieldSlotConsumption_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AirfieldSlotConsumption_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AirfieldSlotConsumption_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AirfieldSlotConsumption_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idAirfieldSlot", &self.idAirfieldSlot());
      ds.field("status", &self.status());
      ds.field("occupied", &self.occupied());
      ds.field("consumer", &self.consumer());
      ds.field("occAircraftMDS", &self.occAircraftMDS());
      ds.field("occTailNumber", &self.occTailNumber());
      ds.field("callSigns", &self.callSigns());
      ds.field("missionId", &self.missionId());
      ds.field("numAircraft", &self.numAircraft());
      ds.field("occStartTime", &self.occStartTime());
      ds.field("resAircraftMDS", &self.resAircraftMDS());
      ds.field("resTailNumber", &self.resTailNumber());
      ds.field("resType", &self.resType());
      ds.field("resReason", &self.resReason());
      ds.field("resMissionId", &self.resMissionId());
      ds.field("startTime", &self.startTime());
      ds.field("endTime", &self.endTime());
      ds.field("targetTime", &self.targetTime());
      ds.field("idArrSortie", &self.idArrSortie());
      ds.field("idDepSortie", &self.idDepSortie());
      ds.field("altArrSortieId", &self.altArrSortieId());
      ds.field("altDepSortieId", &self.altDepSortieId());
      ds.field("reqComment", &self.reqComment());
      ds.field("appComment", &self.appComment());
      ds.field("reqOrg", &self.reqOrg());
      ds.field("reqInitials", &self.reqInitials());
      ds.field("appOrg", &self.appOrg());
      ds.field("appInitials", &self.appInitials());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.field("sourceDL", &self.sourceDL());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AirfieldSlotConsumption_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idAirfieldSlot: Option<String>,
  pub status: AirfieldSlotConsumption_Full_status_Enum,
  pub occupied: bool,
  pub consumer: Option<String>,
  pub occAircraftMDS: Option<String>,
  pub occTailNumber: Option<String>,
  pub callSigns: Option<Vec<String>>,
  pub missionId: Option<String>,
  pub numAircraft: i32,
  pub occStartTime: Option<String>,
  pub resAircraftMDS: Option<String>,
  pub resTailNumber: Option<String>,
  pub resType: Option<String>,
  pub resReason: Option<String>,
  pub resMissionId: Option<String>,
  pub startTime: Option<String>,
  pub endTime: Option<String>,
  pub targetTime: Option<String>,
  pub idArrSortie: Option<String>,
  pub idDepSortie: Option<String>,
  pub altArrSortieId: Option<String>,
  pub altDepSortieId: Option<String>,
  pub reqComment: Option<String>,
  pub appComment: Option<String>,
  pub reqOrg: Option<String>,
  pub reqInitials: Option<String>,
  pub appOrg: Option<String>,
  pub appInitials: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
  pub sourceDL: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: AirfieldSlotConsumption_Full_dataMode_Enum,
}
impl Default for AirfieldSlotConsumption_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idAirfieldSlot: None,
      status: AirfieldSlotConsumption_Full_status_Enum::REQUESTED,
      occupied: false,
      consumer: None,
      occAircraftMDS: None,
      occTailNumber: None,
      callSigns: None,
      missionId: None,
      numAircraft: 0,
      occStartTime: None,
      resAircraftMDS: None,
      resTailNumber: None,
      resType: None,
      resReason: None,
      resMissionId: None,
      startTime: None,
      endTime: None,
      targetTime: None,
      idArrSortie: None,
      idDepSortie: None,
      altArrSortieId: None,
      altDepSortieId: None,
      reqComment: None,
      appComment: None,
      reqOrg: None,
      reqInitials: None,
      appOrg: None,
      appInitials: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: AirfieldSlotConsumption_Full_dataMode_Enum::REAL,
    }
  }
}
impl AirfieldSlotConsumption_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AirfieldSlotConsumption_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idAirfieldSlot = self.idAirfieldSlot.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let status = self.status;
    let occupied = self.occupied;
    let consumer = self.consumer.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let occAircraftMDS = self.occAircraftMDS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let occTailNumber = self.occTailNumber.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let callSigns = self.callSigns.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let missionId = self.missionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let numAircraft = self.numAircraft;
    let occStartTime = self.occStartTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let resAircraftMDS = self.resAircraftMDS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let resTailNumber = self.resTailNumber.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let resType = self.resType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let resReason = self.resReason.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let resMissionId = self.resMissionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let startTime = self.startTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let endTime = self.endTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let targetTime = self.targetTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idArrSortie = self.idArrSortie.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idDepSortie = self.idDepSortie.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altArrSortieId = self.altArrSortieId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altDepSortieId = self.altDepSortieId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reqComment = self.reqComment.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let appComment = self.appComment.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reqOrg = self.reqOrg.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reqInitials = self.reqInitials.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let appOrg = self.appOrg.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let appInitials = self.appInitials.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    AirfieldSlotConsumption_Full::create(_fbb, &AirfieldSlotConsumption_FullArgs{
      id,
      classificationMarking,
      idAirfieldSlot,
      status,
      occupied,
      consumer,
      occAircraftMDS,
      occTailNumber,
      callSigns,
      missionId,
      numAircraft,
      occStartTime,
      resAircraftMDS,
      resTailNumber,
      resType,
      resReason,
      resMissionId,
      startTime,
      endTime,
      targetTime,
      idArrSortie,
      idDepSortie,
      altArrSortieId,
      altDepSortieId,
      reqComment,
      appComment,
      reqOrg,
      reqInitials,
      appOrg,
      appInitials,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      sourceDL,
      source,
      origin,
      origNetwork,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AirfieldSlotConsumption_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airfield_slot_consumption_full_unchecked`.
pub fn root_as_airfield_slot_consumption_full(buf: &[u8]) -> Result<AirfieldSlotConsumption_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AirfieldSlotConsumption_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AirfieldSlotConsumption_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_airfield_slot_consumption_full_unchecked`.
pub fn size_prefixed_root_as_airfield_slot_consumption_full(buf: &[u8]) -> Result<AirfieldSlotConsumption_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AirfieldSlotConsumption_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AirfieldSlotConsumption_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airfield_slot_consumption_full_unchecked`.
pub fn root_as_airfield_slot_consumption_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirfieldSlotConsumption_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AirfieldSlotConsumption_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AirfieldSlotConsumption_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airfield_slot_consumption_full_unchecked`.
pub fn size_prefixed_root_as_airfield_slot_consumption_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirfieldSlotConsumption_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AirfieldSlotConsumption_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AirfieldSlotConsumption_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AirfieldSlotConsumption_Full`.
pub unsafe fn root_as_airfield_slot_consumption_full_unchecked(buf: &[u8]) -> AirfieldSlotConsumption_Full {
  flatbuffers::root_unchecked::<AirfieldSlotConsumption_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AirfieldSlotConsumption_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AirfieldSlotConsumption_Full`.
pub unsafe fn size_prefixed_root_as_airfield_slot_consumption_full_unchecked(buf: &[u8]) -> AirfieldSlotConsumption_Full {
  flatbuffers::size_prefixed_root_unchecked::<AirfieldSlotConsumption_Full>(buf)
}
pub const AIRFIELD_SLOT_CONSUMPTION_FULL_IDENTIFIER: &str = "AIRF";

#[inline]
pub fn airfield_slot_consumption_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRFIELD_SLOT_CONSUMPTION_FULL_IDENTIFIER, false)
}

#[inline]
pub fn airfield_slot_consumption_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRFIELD_SLOT_CONSUMPTION_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_airfield_slot_consumption_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AirfieldSlotConsumption_Full<'a>>) {
  fbb.finish(root, Some(AIRFIELD_SLOT_CONSUMPTION_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_airfield_slot_consumption_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AirfieldSlotConsumption_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(AIRFIELD_SLOT_CONSUMPTION_FULL_IDENTIFIER));
}
