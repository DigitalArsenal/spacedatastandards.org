// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GNSSOBSERVATION_SET_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GNSSOBSERVATION_SET_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GNSSOBSERVATION_SET_FULL_DATA_MODE_ENUM: [GNSSObservationSet_Full_dataMode_Enum; 4] = [
  GNSSObservationSet_Full_dataMode_Enum::REAL,
  GNSSObservationSet_Full_dataMode_Enum::TEST,
  GNSSObservationSet_Full_dataMode_Enum::SIMULATED,
  GNSSObservationSet_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GNSSObservationSet_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl GNSSObservationSet_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GNSSObservationSet_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GNSSObservationSet_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GNSSObservationSet_Full_dataMode_Enum {
    type Output = GNSSObservationSet_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GNSSObservationSet_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GNSSObservationSet_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GNSSObservationSet_Full_dataMode_Enum {}
pub enum GNSSObservationSet_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Set of GNSSObservation data.
pub struct GNSSObservationSet_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GNSSObservationSet_Full<'a> {
  type Inner = GNSSObservationSet_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GNSSObservationSet_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_MARKERTYPE: flatbuffers::VOffsetT = 8;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 10;
  pub const VT_SATNO: flatbuffers::VOffsetT = 12;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 14;
  pub const VT_TS: flatbuffers::VOffsetT = 16;
  pub const VT_OUTAGE: flatbuffers::VOffsetT = 18;
  pub const VT_GDOP: flatbuffers::VOffsetT = 20;
  pub const VT_HDOP: flatbuffers::VOffsetT = 22;
  pub const VT_PDOP: flatbuffers::VOffsetT = 24;
  pub const VT_TDOP: flatbuffers::VOffsetT = 26;
  pub const VT_VDOP: flatbuffers::VOffsetT = 28;
  pub const VT_ESID: flatbuffers::VOffsetT = 30;
  pub const VT_RECEIVER: flatbuffers::VOffsetT = 32;
  pub const VT_BORESIGHT: flatbuffers::VOffsetT = 34;
  pub const VT_QUAT: flatbuffers::VOffsetT = 36;
  pub const VT_LAT: flatbuffers::VOffsetT = 38;
  pub const VT_LON: flatbuffers::VOffsetT = 40;
  pub const VT_ALT: flatbuffers::VOffsetT = 42;
  pub const VT_SATVELOCITY: flatbuffers::VOffsetT = 44;
  pub const VT_OBSCODES: flatbuffers::VOffsetT = 46;
  pub const VT_TRACKINGSTATUS: flatbuffers::VOffsetT = 48;
  pub const VT_NAVIGATIONSTATUS: flatbuffers::VOffsetT = 50;
  pub const VT_AGCSTATE: flatbuffers::VOffsetT = 52;
  pub const VT_SRCTYPS: flatbuffers::VOffsetT = 54;
  pub const VT_SRCIDS: flatbuffers::VOffsetT = 56;
  pub const VT_TAGS: flatbuffers::VOffsetT = 58;
  pub const VT_TRANSACTIONID: flatbuffers::VOffsetT = 60;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 62;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 64;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 66;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 68;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 70;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 72;
  pub const VT_GNSSOBSERVATIONLIST: flatbuffers::VOffsetT = 74;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GNSSObservationSet_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GNSSObservationSet_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<GNSSObservationSet_Full<'bldr>> {
    let mut builder = GNSSObservationSet_FullBuilder::new(_fbb);
    builder.add_alt(args.alt);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    builder.add_vDop(args.vDop);
    builder.add_tDop(args.tDop);
    builder.add_pDop(args.pDop);
    builder.add_hDop(args.hDop);
    builder.add_gDop(args.gDop);
    if let Some(x) = args.gnssObservationList { builder.add_gnssObservationList(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.transactionId { builder.add_transactionId(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.srcIds { builder.add_srcIds(x); }
    if let Some(x) = args.srcTyps { builder.add_srcTyps(x); }
    builder.add_agcState(args.agcState);
    if let Some(x) = args.navigationStatus { builder.add_navigationStatus(x); }
    builder.add_trackingStatus(args.trackingStatus);
    if let Some(x) = args.obsCodes { builder.add_obsCodes(x); }
    if let Some(x) = args.satVelocity { builder.add_satVelocity(x); }
    if let Some(x) = args.quat { builder.add_quat(x); }
    if let Some(x) = args.boresight { builder.add_boresight(x); }
    if let Some(x) = args.receiver { builder.add_receiver(x); }
    if let Some(x) = args.esId { builder.add_esId(x); }
    builder.add_outage(args.outage);
    if let Some(x) = args.ts { builder.add_ts(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.markerType { builder.add_markerType(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> GNSSObservationSet_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let markerType = self.markerType().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let satNo = self.satNo();
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let ts = self.ts().map(|x| {
      x.to_string()
    });
    let outage = self.outage();
    let gDop = self.gDop();
    let hDop = self.hDop();
    let pDop = self.pDop();
    let tDop = self.tDop();
    let vDop = self.vDop();
    let esId = self.esId().map(|x| {
      x.to_string()
    });
    let receiver = self.receiver().map(|x| {
      x.to_string()
    });
    let boresight = self.boresight().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let quat = self.quat().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let lat = self.lat();
    let lon = self.lon();
    let alt = self.alt();
    let satVelocity = self.satVelocity().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let obsCodes = self.obsCodes().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let trackingStatus = self.trackingStatus();
    let navigationStatus = self.navigationStatus().map(|x| {
      x.to_string()
    });
    let agcState = self.agcState();
    let srcTyps = self.srcTyps().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let srcIds = self.srcIds().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let tags = self.tags().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let transactionId = self.transactionId().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let gnssObservationList = self.gnssObservationList().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    GNSSObservationSet_FullT {
      id,
      classificationMarking,
      markerType,
      idOnOrbit,
      satNo,
      origObjectId,
      ts,
      outage,
      gDop,
      hDop,
      pDop,
      tDop,
      vDop,
      esId,
      receiver,
      boresight,
      quat,
      lat,
      lon,
      alt,
      satVelocity,
      obsCodes,
      trackingStatus,
      navigationStatus,
      agcState,
      srcTyps,
      srcIds,
      tags,
      transactionId,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      origNetwork,
      gnssObservationList,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: GNSSObSet-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// The marker type of the observing receiver (AIRBORNE, ANIMAL, BALLISTIC, FIXED BUOY, FLOATING BUOY, FLOATING ICE, GEODETIC, GLACIER, GROUNDCRAFT, HUMAN, NON GEODETIC, NON PHYSICAL, SPACEBORNE, WATERCRAFT).  Reference RINEX 3+ for further information concerning marker types.
  /// Example: /// Example: SPACEBORNE
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn markerType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_MARKERTYPE, None)}
  }
  /// Unique identifier of the primary satellite on-orbit object.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_IDONORBIT, None)}
  }
  /// Satellite/catalog number of the target on-orbit object.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GNSSObservationSet_Full::VT_SATNO, Some(0)).unwrap()}
  }
  /// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_ORIGOBJECTID, None)}
  }
  /// Observation Time, in ISO8601 UTC format with microsecond precision.  This timestamp applies to all observations within the set.
  /// Example: /// Example: 2022-01-01T00:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ts(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_TS, None)}
  }
  /// Time, in seconds, that the receiver has been unable to compute a GNSS fix.
  /// Example: /// Example: 200
  /// Constraints: No constraints specified.
  #[inline]
  pub fn outage(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GNSSObservationSet_Full::VT_OUTAGE, Some(0)).unwrap()}
  }
  /// Geometric Dilution of Precision.
  /// Example: /// Example: 0.33
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gDop(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GNSSObservationSet_Full::VT_GDOP, Some(0.0)).unwrap()}
  }
  /// Horizontal Dilution of Precision.
  /// Example: /// Example: 0.03
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hDop(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GNSSObservationSet_Full::VT_HDOP, Some(0.0)).unwrap()}
  }
  /// Position Dilution of Precision.
  /// Example: /// Example: 0.002
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pDop(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GNSSObservationSet_Full::VT_PDOP, Some(0.0)).unwrap()}
  }
  /// Time Dilution of Precision.
  /// Example: /// Example: 0.05
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tDop(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GNSSObservationSet_Full::VT_TDOP, Some(0.0)).unwrap()}
  }
  /// Vertical Dilution of Precision.
  /// Example: /// Example: 0.03
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vDop(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GNSSObservationSet_Full::VT_VDOP, Some(0.0)).unwrap()}
  }
  /// Unique identifier of the parent Ephemeris Set, if this data is correlated with an Ephemeris.  If reporting for a spacecraft with multiple onboard GNSS receivers, this ID may be associated with multiple GNSS Observation records if each receiver is synced to the ephemeris points.
  /// Example: /// Example: ES-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn esId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_ESID, None)}
  }
  /// The number or ID of the GNSS receiver associated with this data.  Each GNSS Observation Set is associated with only one receiver.  If reporting for multiple receivers a separate set should be generated for each.  A null value is assumed to indicate that only one receiver is present, or reported.
  /// Example: /// Example: RECEIVER-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn receiver(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_RECEIVER, None)}
  }
  /// unit vector of the outward facing direction of the receiver boresight in a body-fixed coordinate system.
  /// Example: /// Example: [1.23, 3.23]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn boresight(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservationSet_Full::VT_BORESIGHT, None)}
  }
  /// The quaternion describing the rotation of the body-fixed frame used for this system into the local geodetic frame, at observation time (ts). The array element order convention is scalar component first, followed by the three vector components. For a vector u in the body-fixed frame, the corresponding vector u' in the geodetic frame should satisfy u' = quq*, where q is this quaternion.
  /// Example: /// Example: [0.03, 0.02, 0.01, 0.012]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn quat(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservationSet_Full::VT_QUAT, None)}
  }
  /// WGS-84 spacecraft latitude sub-point at observation time (ts), represented as -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 32.021
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GNSSObservationSet_Full::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 spacecraft longitude sub-point at observation time (ts), represented as -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 125.123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GNSSObservationSet_Full::VT_LON, Some(0.0)).unwrap()}
  }
  /// Spacecraft altitude at observation time (ts), expressed in kilometers above WGS-84 ellipsoid.
  /// Example: /// Example: 200
  /// Constraints: No constraints specified.
  #[inline]
  pub fn alt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GNSSObservationSet_Full::VT_ALT, Some(0.0)).unwrap()}
  }
  /// Three element array, expressing the ECI J2K spacecraft velocity components, in km/second, at observation time (ts).  The array element order is [xvel, yvel, zvel].
  /// Example: /// Example: [2.03, 0.003, 0.12]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satVelocity(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservationSet_Full::VT_SATVELOCITY, None)}
  }
  /// Array of the strings containing the individual observation code sets that are contained within this GNSS Observation set.  Each string is a three-character representation of the measurement type, the channel, and the coding, in compliance with the RINEX 3+ standard (Pseudorange (C), Carrier Phase (L), Doppler (D), Signal Strength C/No (S), or Channel Number (X)).  See the GNSS Observation ob field for the units of measure associated with each observation type.
  /// Example: /// Example: ['ACL']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obsCodes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservationSet_Full::VT_OBSCODES, None)}
  }
  /// Status of the GNSS receiver signal. Status options are 0, 1 or 2 (0 being the best).
  /// Example: /// Example: 0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trackingStatus(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GNSSObservationSet_Full::VT_TRACKINGSTATUS, Some(0)).unwrap()}
  }
  /// The current navigation status as defined by the data source. In general the navigation status specifies whether the signal is normal, degraded, or unavailable. For status value definitions please reach out to data source provider.
  /// Example: /// Example: degraded
  /// Constraints: No constraints specified.
  #[inline]
  pub fn navigationStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_NAVIGATIONSTATUS, None)}
  }
  /// GNSS Automatic Gain Control State.
  /// Example: /// Example: 20
  /// Constraints: No constraints specified.
  #[inline]
  pub fn agcState(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GNSSObservationSet_Full::VT_AGCSTATE, Some(0)).unwrap()}
  }
  /// Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this GNSS Observation Set. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
  /// Example: /// Example: ['SV', 'SV']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn srcTyps(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservationSet_Full::VT_SRCTYPS, None)}
  }
  /// Array of UUIDs of the UDL data records that are related to this GNSS Observation Set. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object (e.g. /udl/statevector/{uuid}).
  /// Example: /// Example: ['SV_ID', 'SV_ID']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn srcIds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservationSet_Full::VT_SRCIDS, None)}
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['TAG1', 'TAG2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservationSet_Full::VT_TAGS, None)}
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn transactionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_TRANSACTIONID, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> GNSSObservationSet_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GNSSObservationSet_Full_dataMode_Enum>(GNSSObservationSet_Full::VT_DATAMODE, Some(GNSSObservationSet_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservationSet_Full::VT_ORIGNETWORK, None)}
  }
  /// GNSSObservations associated with this GNSSObservationSet.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gnssObservationList(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservationSet_Full::VT_GNSSOBSERVATIONLIST, None)}
  }
}

impl flatbuffers::Verifiable for GNSSObservationSet_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("markerType", Self::VT_MARKERTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ts", Self::VT_TS, false)?
     .visit_field::<i32>("outage", Self::VT_OUTAGE, false)?
     .visit_field::<f64>("gDop", Self::VT_GDOP, false)?
     .visit_field::<f64>("hDop", Self::VT_HDOP, false)?
     .visit_field::<f64>("pDop", Self::VT_PDOP, false)?
     .visit_field::<f64>("tDop", Self::VT_TDOP, false)?
     .visit_field::<f64>("vDop", Self::VT_VDOP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("esId", Self::VT_ESID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("receiver", Self::VT_RECEIVER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("boresight", Self::VT_BORESIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("quat", Self::VT_QUAT, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<f64>("alt", Self::VT_ALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("satVelocity", Self::VT_SATVELOCITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("obsCodes", Self::VT_OBSCODES, false)?
     .visit_field::<i32>("trackingStatus", Self::VT_TRACKINGSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("navigationStatus", Self::VT_NAVIGATIONSTATUS, false)?
     .visit_field::<i32>("agcState", Self::VT_AGCSTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("srcTyps", Self::VT_SRCTYPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("srcIds", Self::VT_SRCIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transactionId", Self::VT_TRANSACTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<GNSSObservationSet_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("gnssObservationList", Self::VT_GNSSOBSERVATIONLIST, false)?
     .finish();
    Ok(())
  }
}
pub struct GNSSObservationSet_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub markerType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo: i32,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub outage: i32,
    pub gDop: f64,
    pub hDop: f64,
    pub pDop: f64,
    pub tDop: f64,
    pub vDop: f64,
    pub esId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub receiver: Option<flatbuffers::WIPOffset<&'a str>>,
    pub boresight: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub quat: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub lat: f64,
    pub lon: f64,
    pub alt: f64,
    pub satVelocity: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub obsCodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub trackingStatus: i32,
    pub navigationStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub agcState: i32,
    pub srcTyps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub srcIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub transactionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: GNSSObservationSet_Full_dataMode_Enum,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gnssObservationList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for GNSSObservationSet_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    GNSSObservationSet_FullArgs {
      id: None,
      classificationMarking: None,
      markerType: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      ts: None,
      outage: 0,
      gDop: 0.0,
      hDop: 0.0,
      pDop: 0.0,
      tDop: 0.0,
      vDop: 0.0,
      esId: None,
      receiver: None,
      boresight: None,
      quat: None,
      lat: 0.0,
      lon: 0.0,
      alt: 0.0,
      satVelocity: None,
      obsCodes: None,
      trackingStatus: 0,
      navigationStatus: None,
      agcState: 0,
      srcTyps: None,
      srcIds: None,
      tags: None,
      transactionId: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: GNSSObservationSet_Full_dataMode_Enum::REAL,
      origNetwork: None,
      gnssObservationList: None,
    }
  }
}

pub struct GNSSObservationSet_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GNSSObservationSet_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_markerType(&mut self, markerType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_MARKERTYPE, markerType);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(GNSSObservationSet_Full::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_ts(&mut self, ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_TS, ts);
  }
  #[inline]
  pub fn add_outage(&mut self, outage: i32) {
    self.fbb_.push_slot::<i32>(GNSSObservationSet_Full::VT_OUTAGE, outage, 0);
  }
  #[inline]
  pub fn add_gDop(&mut self, gDop: f64) {
    self.fbb_.push_slot::<f64>(GNSSObservationSet_Full::VT_GDOP, gDop, 0.0);
  }
  #[inline]
  pub fn add_hDop(&mut self, hDop: f64) {
    self.fbb_.push_slot::<f64>(GNSSObservationSet_Full::VT_HDOP, hDop, 0.0);
  }
  #[inline]
  pub fn add_pDop(&mut self, pDop: f64) {
    self.fbb_.push_slot::<f64>(GNSSObservationSet_Full::VT_PDOP, pDop, 0.0);
  }
  #[inline]
  pub fn add_tDop(&mut self, tDop: f64) {
    self.fbb_.push_slot::<f64>(GNSSObservationSet_Full::VT_TDOP, tDop, 0.0);
  }
  #[inline]
  pub fn add_vDop(&mut self, vDop: f64) {
    self.fbb_.push_slot::<f64>(GNSSObservationSet_Full::VT_VDOP, vDop, 0.0);
  }
  #[inline]
  pub fn add_esId(&mut self, esId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_ESID, esId);
  }
  #[inline]
  pub fn add_receiver(&mut self, receiver: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_RECEIVER, receiver);
  }
  #[inline]
  pub fn add_boresight(&mut self, boresight: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_BORESIGHT, boresight);
  }
  #[inline]
  pub fn add_quat(&mut self, quat: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_QUAT, quat);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(GNSSObservationSet_Full::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(GNSSObservationSet_Full::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_alt(&mut self, alt: f64) {
    self.fbb_.push_slot::<f64>(GNSSObservationSet_Full::VT_ALT, alt, 0.0);
  }
  #[inline]
  pub fn add_satVelocity(&mut self, satVelocity: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_SATVELOCITY, satVelocity);
  }
  #[inline]
  pub fn add_obsCodes(&mut self, obsCodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_OBSCODES, obsCodes);
  }
  #[inline]
  pub fn add_trackingStatus(&mut self, trackingStatus: i32) {
    self.fbb_.push_slot::<i32>(GNSSObservationSet_Full::VT_TRACKINGSTATUS, trackingStatus, 0);
  }
  #[inline]
  pub fn add_navigationStatus(&mut self, navigationStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_NAVIGATIONSTATUS, navigationStatus);
  }
  #[inline]
  pub fn add_agcState(&mut self, agcState: i32) {
    self.fbb_.push_slot::<i32>(GNSSObservationSet_Full::VT_AGCSTATE, agcState, 0);
  }
  #[inline]
  pub fn add_srcTyps(&mut self, srcTyps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_SRCTYPS, srcTyps);
  }
  #[inline]
  pub fn add_srcIds(&mut self, srcIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_SRCIDS, srcIds);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_transactionId(&mut self, transactionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_TRANSACTIONID, transactionId);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: GNSSObservationSet_Full_dataMode_Enum) {
    self.fbb_.push_slot::<GNSSObservationSet_Full_dataMode_Enum>(GNSSObservationSet_Full::VT_DATAMODE, dataMode, GNSSObservationSet_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_gnssObservationList(&mut self, gnssObservationList: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservationSet_Full::VT_GNSSOBSERVATIONLIST, gnssObservationList);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GNSSObservationSet_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GNSSObservationSet_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GNSSObservationSet_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GNSSObservationSet_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GNSSObservationSet_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("markerType", &self.markerType());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("satNo", &self.satNo());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("ts", &self.ts());
      ds.field("outage", &self.outage());
      ds.field("gDop", &self.gDop());
      ds.field("hDop", &self.hDop());
      ds.field("pDop", &self.pDop());
      ds.field("tDop", &self.tDop());
      ds.field("vDop", &self.vDop());
      ds.field("esId", &self.esId());
      ds.field("receiver", &self.receiver());
      ds.field("boresight", &self.boresight());
      ds.field("quat", &self.quat());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("alt", &self.alt());
      ds.field("satVelocity", &self.satVelocity());
      ds.field("obsCodes", &self.obsCodes());
      ds.field("trackingStatus", &self.trackingStatus());
      ds.field("navigationStatus", &self.navigationStatus());
      ds.field("agcState", &self.agcState());
      ds.field("srcTyps", &self.srcTyps());
      ds.field("srcIds", &self.srcIds());
      ds.field("tags", &self.tags());
      ds.field("transactionId", &self.transactionId());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("gnssObservationList", &self.gnssObservationList());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GNSSObservationSet_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub markerType: Option<String>,
  pub idOnOrbit: Option<String>,
  pub satNo: i32,
  pub origObjectId: Option<String>,
  pub ts: Option<String>,
  pub outage: i32,
  pub gDop: f64,
  pub hDop: f64,
  pub pDop: f64,
  pub tDop: f64,
  pub vDop: f64,
  pub esId: Option<String>,
  pub receiver: Option<String>,
  pub boresight: Option<Vec<String>>,
  pub quat: Option<Vec<String>>,
  pub lat: f64,
  pub lon: f64,
  pub alt: f64,
  pub satVelocity: Option<Vec<String>>,
  pub obsCodes: Option<Vec<String>>,
  pub trackingStatus: i32,
  pub navigationStatus: Option<String>,
  pub agcState: i32,
  pub srcTyps: Option<Vec<String>>,
  pub srcIds: Option<Vec<String>>,
  pub tags: Option<Vec<String>>,
  pub transactionId: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: GNSSObservationSet_Full_dataMode_Enum,
  pub origNetwork: Option<String>,
  pub gnssObservationList: Option<Vec<String>>,
}
impl Default for GNSSObservationSet_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      markerType: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      ts: None,
      outage: 0,
      gDop: 0.0,
      hDop: 0.0,
      pDop: 0.0,
      tDop: 0.0,
      vDop: 0.0,
      esId: None,
      receiver: None,
      boresight: None,
      quat: None,
      lat: 0.0,
      lon: 0.0,
      alt: 0.0,
      satVelocity: None,
      obsCodes: None,
      trackingStatus: 0,
      navigationStatus: None,
      agcState: 0,
      srcTyps: None,
      srcIds: None,
      tags: None,
      transactionId: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: GNSSObservationSet_Full_dataMode_Enum::REAL,
      origNetwork: None,
      gnssObservationList: None,
    }
  }
}
impl GNSSObservationSet_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GNSSObservationSet_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let markerType = self.markerType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo = self.satNo;
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ts = self.ts.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let outage = self.outage;
    let gDop = self.gDop;
    let hDop = self.hDop;
    let pDop = self.pDop;
    let tDop = self.tDop;
    let vDop = self.vDop;
    let esId = self.esId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let receiver = self.receiver.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let boresight = self.boresight.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let quat = self.quat.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let lat = self.lat;
    let lon = self.lon;
    let alt = self.alt;
    let satVelocity = self.satVelocity.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let obsCodes = self.obsCodes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let trackingStatus = self.trackingStatus;
    let navigationStatus = self.navigationStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let agcState = self.agcState;
    let srcTyps = self.srcTyps.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let srcIds = self.srcIds.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let transactionId = self.transactionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let gnssObservationList = self.gnssObservationList.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    GNSSObservationSet_Full::create(_fbb, &GNSSObservationSet_FullArgs{
      id,
      classificationMarking,
      markerType,
      idOnOrbit,
      satNo,
      origObjectId,
      ts,
      outage,
      gDop,
      hDop,
      pDop,
      tDop,
      vDop,
      esId,
      receiver,
      boresight,
      quat,
      lat,
      lon,
      alt,
      satVelocity,
      obsCodes,
      trackingStatus,
      navigationStatus,
      agcState,
      srcTyps,
      srcIds,
      tags,
      transactionId,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      origNetwork,
      gnssObservationList,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `GNSSObservationSet_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gnssobservation_set_full_unchecked`.
pub fn root_as_gnssobservation_set_full(buf: &[u8]) -> Result<GNSSObservationSet_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<GNSSObservationSet_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `GNSSObservationSet_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_gnssobservation_set_full_unchecked`.
pub fn size_prefixed_root_as_gnssobservation_set_full(buf: &[u8]) -> Result<GNSSObservationSet_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<GNSSObservationSet_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `GNSSObservationSet_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gnssobservation_set_full_unchecked`.
pub fn root_as_gnssobservation_set_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GNSSObservationSet_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<GNSSObservationSet_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `GNSSObservationSet_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gnssobservation_set_full_unchecked`.
pub fn size_prefixed_root_as_gnssobservation_set_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GNSSObservationSet_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<GNSSObservationSet_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a GNSSObservationSet_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `GNSSObservationSet_Full`.
pub unsafe fn root_as_gnssobservation_set_full_unchecked(buf: &[u8]) -> GNSSObservationSet_Full {
  flatbuffers::root_unchecked::<GNSSObservationSet_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed GNSSObservationSet_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `GNSSObservationSet_Full`.
pub unsafe fn size_prefixed_root_as_gnssobservation_set_full_unchecked(buf: &[u8]) -> GNSSObservationSet_Full {
  flatbuffers::size_prefixed_root_unchecked::<GNSSObservationSet_Full>(buf)
}
pub const GNSSOBSERVATION_SET_FULL_IDENTIFIER: &str = "GNSS";

#[inline]
pub fn gnssobservation_set_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GNSSOBSERVATION_SET_FULL_IDENTIFIER, false)
}

#[inline]
pub fn gnssobservation_set_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GNSSOBSERVATION_SET_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_gnssobservation_set_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<GNSSObservationSet_Full<'a>>) {
  fbb.finish(root, Some(GNSSOBSERVATION_SET_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_gnssobservation_set_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<GNSSObservationSet_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(GNSSOBSERVATION_SET_FULL_IDENTIFIER));
}
