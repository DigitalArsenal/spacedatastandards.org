// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_HAZARD_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_HAZARD_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_HAZARD_INGEST_DATA_MODE_ENUM: [Hazard_Ingest_dataMode_Enum; 4] = [
  Hazard_Ingest_dataMode_Enum::REAL,
  Hazard_Ingest_dataMode_Enum::TEST,
  Hazard_Ingest_dataMode_Enum::SIMULATED,
  Hazard_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Hazard_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Hazard_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Hazard_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Hazard_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Hazard_Ingest_dataMode_Enum {
    type Output = Hazard_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Hazard_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Hazard_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Hazard_Ingest_dataMode_Enum {}
pub enum Hazard_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Hazard contains information concerning the exposure of a geographic area to a Chemical, Biological, Radiological, or Nuclear (CBRN) contaminant. The Hazard schema includes the detection time and type of contamination as well as optional information regarding specific material properties, the extent of contamination, and identification of affected regions.
pub struct Hazard_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Hazard_Ingest<'a> {
  type Inner = Hazard_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Hazard_Ingest<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_DETECTTYPE: flatbuffers::VOffsetT = 8;
  pub const VT_DETECTTIME: flatbuffers::VOffsetT = 10;
  pub const VT_HARMFUL: flatbuffers::VOffsetT = 12;
  pub const VT_ALARMS: flatbuffers::VOffsetT = 14;
  pub const VT_ALARMVALUES: flatbuffers::VOffsetT = 16;
  pub const VT_READINGS: flatbuffers::VOffsetT = 18;
  pub const VT_READINGUNITS: flatbuffers::VOffsetT = 20;
  pub const VT_READINGVALUES: flatbuffers::VOffsetT = 22;
  pub const VT_MATTYPE: flatbuffers::VOffsetT = 24;
  pub const VT_MATCLASS: flatbuffers::VOffsetT = 26;
  pub const VT_MATNAME: flatbuffers::VOffsetT = 28;
  pub const VT_MATCAT: flatbuffers::VOffsetT = 30;
  pub const VT_CASRN: flatbuffers::VOffsetT = 32;
  pub const VT_PPM: flatbuffers::VOffsetT = 34;
  pub const VT_DENSITY: flatbuffers::VOffsetT = 36;
  pub const VT_RADCTRN: flatbuffers::VOffsetT = 38;
  pub const VT_GBAR: flatbuffers::VOffsetT = 40;
  pub const VT_HBAR: flatbuffers::VOffsetT = 42;
  pub const VT_Z: flatbuffers::VOffsetT = 44;
  pub const VT_A: flatbuffers::VOffsetT = 46;
  pub const VT_BOTTLEID: flatbuffers::VOffsetT = 48;
  pub const VT_CHANNEL: flatbuffers::VOffsetT = 50;
  pub const VT_DURATION: flatbuffers::VOffsetT = 52;
  pub const VT_ACTIVITY: flatbuffers::VOffsetT = 54;
  pub const VT_DEP: flatbuffers::VOffsetT = 56;
  pub const VT_DEPCTRN: flatbuffers::VOffsetT = 58;
  pub const VT_MASSFRAC: flatbuffers::VOffsetT = 60;
  pub const VT_DOSE: flatbuffers::VOffsetT = 62;
  pub const VT_CTRNTIME: flatbuffers::VOffsetT = 64;
  pub const VT_DOSERATE: flatbuffers::VOffsetT = 66;
  pub const VT_IDPOI: flatbuffers::VOffsetT = 68;
  pub const VT_IDTRACK: flatbuffers::VOffsetT = 70;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 72;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 74;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 76;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 78;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 80;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 82;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Hazard_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Hazard_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<Hazard_Ingest<'bldr>> {
    let mut builder = Hazard_IngestBuilder::new(_fbb);
    builder.add_doseRate(args.doseRate);
    builder.add_ctrnTime(args.ctrnTime);
    builder.add_dose(args.dose);
    builder.add_massFrac(args.massFrac);
    builder.add_depCtrn(args.depCtrn);
    builder.add_dep(args.dep);
    builder.add_activity(args.activity);
    builder.add_hBar(args.hBar);
    builder.add_gBar(args.gBar);
    builder.add_radCtrn(args.radCtrn);
    builder.add_density(args.density);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.idTrack { builder.add_idTrack(x); }
    if let Some(x) = args.idPOI { builder.add_idPOI(x); }
    builder.add_duration(args.duration);
    if let Some(x) = args.channel { builder.add_channel(x); }
    if let Some(x) = args.bottleId { builder.add_bottleId(x); }
    builder.add_a(args.a);
    builder.add_z(args.z);
    builder.add_ppm(args.ppm);
    if let Some(x) = args.casRN { builder.add_casRN(x); }
    builder.add_matCat(args.matCat);
    if let Some(x) = args.matName { builder.add_matName(x); }
    if let Some(x) = args.matClass { builder.add_matClass(x); }
    if let Some(x) = args.matType { builder.add_matType(x); }
    if let Some(x) = args.readingValues { builder.add_readingValues(x); }
    if let Some(x) = args.readingUnits { builder.add_readingUnits(x); }
    if let Some(x) = args.readings { builder.add_readings(x); }
    if let Some(x) = args.alarmValues { builder.add_alarmValues(x); }
    if let Some(x) = args.alarms { builder.add_alarms(x); }
    if let Some(x) = args.detectTime { builder.add_detectTime(x); }
    if let Some(x) = args.detectType { builder.add_detectType(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_harmful(args.harmful);
    builder.finish()
  }

  pub fn unpack(&self) -> Hazard_IngestT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let detectType = self.detectType().map(|x| {
      x.to_string()
    });
    let detectTime = self.detectTime().map(|x| {
      x.to_string()
    });
    let harmful = self.harmful();
    let alarms = self.alarms().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let alarmValues = self.alarmValues().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let readings = self.readings().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let readingUnits = self.readingUnits().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let readingValues = self.readingValues().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let matType = self.matType().map(|x| {
      x.to_string()
    });
    let matClass = self.matClass().map(|x| {
      x.to_string()
    });
    let matName = self.matName().map(|x| {
      x.to_string()
    });
    let matCat = self.matCat();
    let casRN = self.casRN().map(|x| {
      x.to_string()
    });
    let ppm = self.ppm();
    let density = self.density();
    let radCtrn = self.radCtrn();
    let gBar = self.gBar();
    let hBar = self.hBar();
    let z = self.z();
    let a = self.a();
    let bottleId = self.bottleId().map(|x| {
      x.to_string()
    });
    let channel = self.channel().map(|x| {
      x.to_string()
    });
    let duration = self.duration();
    let activity = self.activity();
    let dep = self.dep();
    let depCtrn = self.depCtrn();
    let massFrac = self.massFrac();
    let dose = self.dose();
    let ctrnTime = self.ctrnTime();
    let doseRate = self.doseRate();
    let idPOI = self.idPOI().map(|x| {
      x.to_string()
    });
    let idTrack = self.idTrack().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    Hazard_IngestT {
      id,
      classificationMarking,
      detectType,
      detectTime,
      harmful,
      alarms,
      alarmValues,
      readings,
      readingUnits,
      readingValues,
      matType,
      matClass,
      matName,
      matCat,
      casRN,
      ppm,
      density,
      radCtrn,
      gBar,
      hBar,
      z,
      a,
      bottleId,
      channel,
      duration,
      activity,
      dep,
      depCtrn,
      massFrac,
      dose,
      ctrnTime,
      doseRate,
      idPOI,
      idTrack,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: HAZARD-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// The type of hazard (Chemical, Biological, Radiological, Nuclear) detect associated with this record.
  /// Example: /// Example: Chemical
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn detectType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_DETECTTYPE, None)}
  }
  /// The detect time, in ISO 8601 UTC format, with millisecond precision.
  /// Example: /// Example: 2022-03-07T14:51:39.653Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn detectTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_DETECTTIME, None)}
  }
  /// Flag indicating whether this detection is harmful to humans.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn harmful(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Hazard_Ingest::VT_HARMFUL, Some(false)).unwrap()}
  }
  /// Array of the specific alarms associated with this detection. The alarms and alarmValues arrays must contain the same number of elements.
  /// Example: /// Example: ['Alarm1', 'Alarm2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn alarms(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Hazard_Ingest::VT_ALARMS, None)}
  }
  /// Array of the values that correspond to each of the alarms contained in alarms. The alarms and alarmValues arrays must contain the same number of elements.
  /// Example: /// Example: [2.7, 2.9]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn alarmValues(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Hazard_Ingest::VT_ALARMVALUES, None)}
  }
  /// Array of the specific readings associated with this detection. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
  /// Example: /// Example: ['Rad1', 'Rad2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn readings(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Hazard_Ingest::VT_READINGS, None)}
  }
  /// Array of the units that correspond to each of the readingValues. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
  /// Example: /// Example: ['Gray', 'Gray']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn readingUnits(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Hazard_Ingest::VT_READINGUNITS, None)}
  }
  /// Array of the values that correspond to each of the readings contained in readings. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
  /// Example: /// Example: [107.2, 124.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn readingValues(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Hazard_Ingest::VT_READINGVALUES, None)}
  }
  /// The specific material type (MT) or MT Code involved in this detection, when applicable. The material type is generally associated with radiological and/or nuclear detections. For further information, reference Nuclear Materials Management and Safeguards System (NMMSS) Users Guide Rev. 2.1.
  /// Example: /// Example: 21
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn matType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_MATTYPE, None)}
  }
  /// The specific Material Class for the material associated with this detect. The material class is generally associated with chemical and biological detections.
  /// Example: /// Example: Nerve Agent
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn matClass(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_MATCLASS, None)}
  }
  /// The material common name associated with this detection.
  /// Example: /// Example: VX
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn matName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_MATNAME, None)}
  }
  /// The Radiological Category (1 - 5) which applies to the material associated with this detection, according to the following definitions: 
  /// Category 1: If not safely or securely managed, would be likely to cause permanent injury to a person who handled them or was otherwise in contact with them for more than a few minutes. It would probably be fatal to be close to this amount of unshielded material for a period of a few minutes to an hour. 
  /// Category 2: If not safely or securely managed, could cause permanent injury to a person who handled them or was otherwise in contact with them for a short time (minutes to hours). It could possibly be fatal to be close to this amount of unshielded radioactive material for a period of hours to days. 
  /// Category 3: If not safely or securely managed, could cause permanent injury to a person who handled them or was otherwise in contact with them for hours. It could possibly - although it is unlikely to be - fatal to be close to this amount of unshielded radioactive material for a period of days to weeks. 
  /// Category 4: If not safely managed or securely protected, could possibly cause temporary injury to someone who handled them or was otherwise in contact with or close to them for a period of many weeks, though this is unlikely. It is very unlikely anyone would be permanently injured by this amount of radioactive material. 
  /// Category 5: Cannot cause permanent injury. This category applies to x-ray fluorescence devices and electron capture devices.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn matCat(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Hazard_Ingest::VT_MATCAT, Some(0)).unwrap()}
  }
  /// The CAS Registry Number, also referred to as CAS Number or CAS RN, associated with the this detection. The CAS Number is a unique numerical identifier assigned by the Chemical Abstracts Service (CAS), to every chemical substance described in the open scientific literature. It includes organic and inorganic compounds, minerals, isotopes, alloys, mixtures, and nonstructurable materials (UVCBs, substances of unknown or variable composition, complex reaction products, or biological origin). For further information, reference https://www.cas.org/cas-data/cas-registry.
  /// Example: /// Example: 64-17-5
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn casRN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_CASRN, None)}
  }
  /// Measure of the concentration of the material associated with this detection, in parts per million (units of contaminant mass per million parts of total mass).
  /// Example: /// Example: 27129
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ppm(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Hazard_Ingest::VT_PPM, Some(0)).unwrap()}
  }
  /// Measure of density of the material associated with this detection, in kg/m^3.
  /// Example: /// Example: 18900.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn density(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Hazard_Ingest::VT_DENSITY, Some(0.0)).unwrap()}
  }
  /// Measure of radioactive concentration of the material associated with this detection, in becquerels/m^3. One becquerel (Bq) is equal to one nuclear decay per second.
  /// Example: /// Example: 1.31
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radCtrn(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Hazard_Ingest::VT_RADCTRN, Some(0.0)).unwrap()}
  }
  /// Chemical Agent Monitor (CAM) G-type agent measurement, in number of display bars. In G-mode, CAMs monitor for G-series nerve agents.
  /// Example: /// Example: 2.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gBar(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Hazard_Ingest::VT_GBAR, Some(0.0)).unwrap()}
  }
  /// Chemical Agent Monitor (CAM) H-type agent measurement, in number of display bars. In H-mode, CAMs monitor for blister agents.
  /// Example: /// Example: 3.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hBar(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Hazard_Ingest::VT_HBAR, Some(0.0)).unwrap()}
  }
  /// The Atomic Number of the material associated with this detection.
  /// Example: /// Example: 92
  /// Constraints: No constraints specified.
  #[inline]
  pub fn z(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Hazard_Ingest::VT_Z, Some(0)).unwrap()}
  }
  /// The (rounded) Mass Number of the material associated with this detection. The rounded value is the mass number of the most abundant isotope of the element.
  /// Example: /// Example: 238
  /// Constraints: No constraints specified.
  #[inline]
  pub fn a(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Hazard_Ingest::VT_A, Some(0)).unwrap()}
  }
  /// The specific bottle ID associated with this detection.
  /// Example: /// Example: 6264
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn bottleId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_BOTTLEID, None)}
  }
  /// The applicable channel involved in this biological material detection (e.g. Digestive, Eyes, Respiratory, Skin, etc.) .
  /// Example: /// Example: Skin
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn channel(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_CHANNEL, None)}
  }
  /// The known or projected hazard duration, in seconds, associated with this material detection.
  /// Example: /// Example: 14400
  /// Constraints: No constraints specified.
  #[inline]
  pub fn duration(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Hazard_Ingest::VT_DURATION, Some(0)).unwrap()}
  }
  /// The radioactivity measurement of the material associated with this detection, in becquerels (Bq). One becquerel (Bq) is equal to one nuclear decay per second.
  /// Example: /// Example: 120.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn activity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Hazard_Ingest::VT_ACTIVITY, Some(0.0)).unwrap()}
  }
  /// The deposition measurement of the contaminant to surface area, in kg/m^2.
  /// Example: /// Example: 1.084
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dep(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Hazard_Ingest::VT_DEP, Some(0.0)).unwrap()}
  }
  /// The deposition concentration of the contaminant to surface area, in becquerels/m^2.
  /// Example: /// Example: 86.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn depCtrn(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Hazard_Ingest::VT_DEPCTRN, Some(0.0)).unwrap()}
  }
  /// Ratio of the chemical substance mass to the total mass of the mixture.
  /// Example: /// Example: 0.029
  /// Constraints: No constraints specified.
  #[inline]
  pub fn massFrac(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Hazard_Ingest::VT_MASSFRAC, Some(0.0)).unwrap()}
  }
  /// The dose associated with this detection, in gray. Dose is the measure of the energy deposited in matter by ionizing radiation per unit mass. One gray is defined as one Joule of energy absorbed per kilogram of matter.
  /// Example: /// Example: 1.12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dose(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Hazard_Ingest::VT_DOSE, Some(0.0)).unwrap()}
  }
  /// The concentration time, in (kg/sec)/m^3, associated with this material detection.
  /// Example: /// Example: 1.077
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ctrnTime(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Hazard_Ingest::VT_CTRNTIME, Some(0.0)).unwrap()}
  }
  /// The dose rate associated with this detection, in gray/sec. One gray is defined as one Joule of energy absorbed per kilogram of matter.
  /// Example: /// Example: 1.0000001865
  /// Constraints: No constraints specified.
  #[inline]
  pub fn doseRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Hazard_Ingest::VT_DOSERATE, Some(0.0)).unwrap()}
  }
  /// ID of the Point of Interest (POI) record related to this hazard record.
  /// Example: /// Example: POI-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idPOI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_IDPOI, None)}
  }
  /// ID of the Track record related to this hazard record.
  /// Example: /// Example: TRACK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idTrack(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_IDTRACK, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Hazard_Ingest::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> Hazard_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Hazard_Ingest_dataMode_Enum>(Hazard_Ingest::VT_DATAMODE, Some(Hazard_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Hazard_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("detectType", Self::VT_DETECTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("detectTime", Self::VT_DETECTTIME, false)?
     .visit_field::<bool>("harmful", Self::VT_HARMFUL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("alarms", Self::VT_ALARMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("alarmValues", Self::VT_ALARMVALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("readings", Self::VT_READINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("readingUnits", Self::VT_READINGUNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("readingValues", Self::VT_READINGVALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("matType", Self::VT_MATTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("matClass", Self::VT_MATCLASS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("matName", Self::VT_MATNAME, false)?
     .visit_field::<i32>("matCat", Self::VT_MATCAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("casRN", Self::VT_CASRN, false)?
     .visit_field::<i32>("ppm", Self::VT_PPM, false)?
     .visit_field::<f64>("density", Self::VT_DENSITY, false)?
     .visit_field::<f64>("radCtrn", Self::VT_RADCTRN, false)?
     .visit_field::<f64>("gBar", Self::VT_GBAR, false)?
     .visit_field::<f64>("hBar", Self::VT_HBAR, false)?
     .visit_field::<i32>("z", Self::VT_Z, false)?
     .visit_field::<i32>("a", Self::VT_A, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bottleId", Self::VT_BOTTLEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("channel", Self::VT_CHANNEL, false)?
     .visit_field::<i32>("duration", Self::VT_DURATION, false)?
     .visit_field::<f64>("activity", Self::VT_ACTIVITY, false)?
     .visit_field::<f64>("dep", Self::VT_DEP, false)?
     .visit_field::<f64>("depCtrn", Self::VT_DEPCTRN, false)?
     .visit_field::<f64>("massFrac", Self::VT_MASSFRAC, false)?
     .visit_field::<f64>("dose", Self::VT_DOSE, false)?
     .visit_field::<f64>("ctrnTime", Self::VT_CTRNTIME, false)?
     .visit_field::<f64>("doseRate", Self::VT_DOSERATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idPOI", Self::VT_IDPOI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idTrack", Self::VT_IDTRACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<Hazard_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct Hazard_IngestArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub detectType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub detectTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub harmful: bool,
    pub alarms: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub alarmValues: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub readings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub readingUnits: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub readingValues: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub matType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub matClass: Option<flatbuffers::WIPOffset<&'a str>>,
    pub matName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub matCat: i32,
    pub casRN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ppm: i32,
    pub density: f64,
    pub radCtrn: f64,
    pub gBar: f64,
    pub hBar: f64,
    pub z: i32,
    pub a: i32,
    pub bottleId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub channel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub duration: i32,
    pub activity: f64,
    pub dep: f64,
    pub depCtrn: f64,
    pub massFrac: f64,
    pub dose: f64,
    pub ctrnTime: f64,
    pub doseRate: f64,
    pub idPOI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idTrack: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: Hazard_Ingest_dataMode_Enum,
}
impl<'a> Default for Hazard_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    Hazard_IngestArgs {
      id: None,
      classificationMarking: None,
      detectType: None,
      detectTime: None,
      harmful: false,
      alarms: None,
      alarmValues: None,
      readings: None,
      readingUnits: None,
      readingValues: None,
      matType: None,
      matClass: None,
      matName: None,
      matCat: 0,
      casRN: None,
      ppm: 0,
      density: 0.0,
      radCtrn: 0.0,
      gBar: 0.0,
      hBar: 0.0,
      z: 0,
      a: 0,
      bottleId: None,
      channel: None,
      duration: 0,
      activity: 0.0,
      dep: 0.0,
      depCtrn: 0.0,
      massFrac: 0.0,
      dose: 0.0,
      ctrnTime: 0.0,
      doseRate: 0.0,
      idPOI: None,
      idTrack: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: Hazard_Ingest_dataMode_Enum::REAL,
    }
  }
}

pub struct Hazard_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Hazard_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_detectType(&mut self, detectType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_DETECTTYPE, detectType);
  }
  #[inline]
  pub fn add_detectTime(&mut self, detectTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_DETECTTIME, detectTime);
  }
  #[inline]
  pub fn add_harmful(&mut self, harmful: bool) {
    self.fbb_.push_slot::<bool>(Hazard_Ingest::VT_HARMFUL, harmful, false);
  }
  #[inline]
  pub fn add_alarms(&mut self, alarms: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_ALARMS, alarms);
  }
  #[inline]
  pub fn add_alarmValues(&mut self, alarmValues: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_ALARMVALUES, alarmValues);
  }
  #[inline]
  pub fn add_readings(&mut self, readings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_READINGS, readings);
  }
  #[inline]
  pub fn add_readingUnits(&mut self, readingUnits: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_READINGUNITS, readingUnits);
  }
  #[inline]
  pub fn add_readingValues(&mut self, readingValues: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_READINGVALUES, readingValues);
  }
  #[inline]
  pub fn add_matType(&mut self, matType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_MATTYPE, matType);
  }
  #[inline]
  pub fn add_matClass(&mut self, matClass: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_MATCLASS, matClass);
  }
  #[inline]
  pub fn add_matName(&mut self, matName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_MATNAME, matName);
  }
  #[inline]
  pub fn add_matCat(&mut self, matCat: i32) {
    self.fbb_.push_slot::<i32>(Hazard_Ingest::VT_MATCAT, matCat, 0);
  }
  #[inline]
  pub fn add_casRN(&mut self, casRN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_CASRN, casRN);
  }
  #[inline]
  pub fn add_ppm(&mut self, ppm: i32) {
    self.fbb_.push_slot::<i32>(Hazard_Ingest::VT_PPM, ppm, 0);
  }
  #[inline]
  pub fn add_density(&mut self, density: f64) {
    self.fbb_.push_slot::<f64>(Hazard_Ingest::VT_DENSITY, density, 0.0);
  }
  #[inline]
  pub fn add_radCtrn(&mut self, radCtrn: f64) {
    self.fbb_.push_slot::<f64>(Hazard_Ingest::VT_RADCTRN, radCtrn, 0.0);
  }
  #[inline]
  pub fn add_gBar(&mut self, gBar: f64) {
    self.fbb_.push_slot::<f64>(Hazard_Ingest::VT_GBAR, gBar, 0.0);
  }
  #[inline]
  pub fn add_hBar(&mut self, hBar: f64) {
    self.fbb_.push_slot::<f64>(Hazard_Ingest::VT_HBAR, hBar, 0.0);
  }
  #[inline]
  pub fn add_z(&mut self, z: i32) {
    self.fbb_.push_slot::<i32>(Hazard_Ingest::VT_Z, z, 0);
  }
  #[inline]
  pub fn add_a(&mut self, a: i32) {
    self.fbb_.push_slot::<i32>(Hazard_Ingest::VT_A, a, 0);
  }
  #[inline]
  pub fn add_bottleId(&mut self, bottleId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_BOTTLEID, bottleId);
  }
  #[inline]
  pub fn add_channel(&mut self, channel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_CHANNEL, channel);
  }
  #[inline]
  pub fn add_duration(&mut self, duration: i32) {
    self.fbb_.push_slot::<i32>(Hazard_Ingest::VT_DURATION, duration, 0);
  }
  #[inline]
  pub fn add_activity(&mut self, activity: f64) {
    self.fbb_.push_slot::<f64>(Hazard_Ingest::VT_ACTIVITY, activity, 0.0);
  }
  #[inline]
  pub fn add_dep(&mut self, dep: f64) {
    self.fbb_.push_slot::<f64>(Hazard_Ingest::VT_DEP, dep, 0.0);
  }
  #[inline]
  pub fn add_depCtrn(&mut self, depCtrn: f64) {
    self.fbb_.push_slot::<f64>(Hazard_Ingest::VT_DEPCTRN, depCtrn, 0.0);
  }
  #[inline]
  pub fn add_massFrac(&mut self, massFrac: f64) {
    self.fbb_.push_slot::<f64>(Hazard_Ingest::VT_MASSFRAC, massFrac, 0.0);
  }
  #[inline]
  pub fn add_dose(&mut self, dose: f64) {
    self.fbb_.push_slot::<f64>(Hazard_Ingest::VT_DOSE, dose, 0.0);
  }
  #[inline]
  pub fn add_ctrnTime(&mut self, ctrnTime: f64) {
    self.fbb_.push_slot::<f64>(Hazard_Ingest::VT_CTRNTIME, ctrnTime, 0.0);
  }
  #[inline]
  pub fn add_doseRate(&mut self, doseRate: f64) {
    self.fbb_.push_slot::<f64>(Hazard_Ingest::VT_DOSERATE, doseRate, 0.0);
  }
  #[inline]
  pub fn add_idPOI(&mut self, idPOI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_IDPOI, idPOI);
  }
  #[inline]
  pub fn add_idTrack(&mut self, idTrack: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_IDTRACK, idTrack);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hazard_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Hazard_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<Hazard_Ingest_dataMode_Enum>(Hazard_Ingest::VT_DATAMODE, dataMode, Hazard_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Hazard_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Hazard_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Hazard_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Hazard_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Hazard_Ingest");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("detectType", &self.detectType());
      ds.field("detectTime", &self.detectTime());
      ds.field("harmful", &self.harmful());
      ds.field("alarms", &self.alarms());
      ds.field("alarmValues", &self.alarmValues());
      ds.field("readings", &self.readings());
      ds.field("readingUnits", &self.readingUnits());
      ds.field("readingValues", &self.readingValues());
      ds.field("matType", &self.matType());
      ds.field("matClass", &self.matClass());
      ds.field("matName", &self.matName());
      ds.field("matCat", &self.matCat());
      ds.field("casRN", &self.casRN());
      ds.field("ppm", &self.ppm());
      ds.field("density", &self.density());
      ds.field("radCtrn", &self.radCtrn());
      ds.field("gBar", &self.gBar());
      ds.field("hBar", &self.hBar());
      ds.field("z", &self.z());
      ds.field("a", &self.a());
      ds.field("bottleId", &self.bottleId());
      ds.field("channel", &self.channel());
      ds.field("duration", &self.duration());
      ds.field("activity", &self.activity());
      ds.field("dep", &self.dep());
      ds.field("depCtrn", &self.depCtrn());
      ds.field("massFrac", &self.massFrac());
      ds.field("dose", &self.dose());
      ds.field("ctrnTime", &self.ctrnTime());
      ds.field("doseRate", &self.doseRate());
      ds.field("idPOI", &self.idPOI());
      ds.field("idTrack", &self.idTrack());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Hazard_IngestT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub detectType: Option<String>,
  pub detectTime: Option<String>,
  pub harmful: bool,
  pub alarms: Option<Vec<String>>,
  pub alarmValues: Option<Vec<String>>,
  pub readings: Option<Vec<String>>,
  pub readingUnits: Option<Vec<String>>,
  pub readingValues: Option<Vec<String>>,
  pub matType: Option<String>,
  pub matClass: Option<String>,
  pub matName: Option<String>,
  pub matCat: i32,
  pub casRN: Option<String>,
  pub ppm: i32,
  pub density: f64,
  pub radCtrn: f64,
  pub gBar: f64,
  pub hBar: f64,
  pub z: i32,
  pub a: i32,
  pub bottleId: Option<String>,
  pub channel: Option<String>,
  pub duration: i32,
  pub activity: f64,
  pub dep: f64,
  pub depCtrn: f64,
  pub massFrac: f64,
  pub dose: f64,
  pub ctrnTime: f64,
  pub doseRate: f64,
  pub idPOI: Option<String>,
  pub idTrack: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: Hazard_Ingest_dataMode_Enum,
}
impl Default for Hazard_IngestT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      detectType: None,
      detectTime: None,
      harmful: false,
      alarms: None,
      alarmValues: None,
      readings: None,
      readingUnits: None,
      readingValues: None,
      matType: None,
      matClass: None,
      matName: None,
      matCat: 0,
      casRN: None,
      ppm: 0,
      density: 0.0,
      radCtrn: 0.0,
      gBar: 0.0,
      hBar: 0.0,
      z: 0,
      a: 0,
      bottleId: None,
      channel: None,
      duration: 0,
      activity: 0.0,
      dep: 0.0,
      depCtrn: 0.0,
      massFrac: 0.0,
      dose: 0.0,
      ctrnTime: 0.0,
      doseRate: 0.0,
      idPOI: None,
      idTrack: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: Hazard_Ingest_dataMode_Enum::REAL,
    }
  }
}
impl Hazard_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Hazard_Ingest<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let detectType = self.detectType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let detectTime = self.detectTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let harmful = self.harmful;
    let alarms = self.alarms.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let alarmValues = self.alarmValues.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let readings = self.readings.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let readingUnits = self.readingUnits.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let readingValues = self.readingValues.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let matType = self.matType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let matClass = self.matClass.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let matName = self.matName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let matCat = self.matCat;
    let casRN = self.casRN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ppm = self.ppm;
    let density = self.density;
    let radCtrn = self.radCtrn;
    let gBar = self.gBar;
    let hBar = self.hBar;
    let z = self.z;
    let a = self.a;
    let bottleId = self.bottleId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let channel = self.channel.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let duration = self.duration;
    let activity = self.activity;
    let dep = self.dep;
    let depCtrn = self.depCtrn;
    let massFrac = self.massFrac;
    let dose = self.dose;
    let ctrnTime = self.ctrnTime;
    let doseRate = self.doseRate;
    let idPOI = self.idPOI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idTrack = self.idTrack.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    Hazard_Ingest::create(_fbb, &Hazard_IngestArgs{
      id,
      classificationMarking,
      detectType,
      detectTime,
      harmful,
      alarms,
      alarmValues,
      readings,
      readingUnits,
      readingValues,
      matType,
      matClass,
      matName,
      matCat,
      casRN,
      ppm,
      density,
      radCtrn,
      gBar,
      hBar,
      z,
      a,
      bottleId,
      channel,
      duration,
      activity,
      dep,
      depCtrn,
      massFrac,
      dose,
      ctrnTime,
      doseRate,
      idPOI,
      idTrack,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Hazard_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_hazard_ingest_unchecked`.
pub fn root_as_hazard_ingest(buf: &[u8]) -> Result<Hazard_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Hazard_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Hazard_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_hazard_ingest_unchecked`.
pub fn size_prefixed_root_as_hazard_ingest(buf: &[u8]) -> Result<Hazard_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Hazard_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Hazard_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_hazard_ingest_unchecked`.
pub fn root_as_hazard_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Hazard_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Hazard_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Hazard_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_hazard_ingest_unchecked`.
pub fn size_prefixed_root_as_hazard_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Hazard_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Hazard_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Hazard_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Hazard_Ingest`.
pub unsafe fn root_as_hazard_ingest_unchecked(buf: &[u8]) -> Hazard_Ingest {
  flatbuffers::root_unchecked::<Hazard_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Hazard_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Hazard_Ingest`.
pub unsafe fn size_prefixed_root_as_hazard_ingest_unchecked(buf: &[u8]) -> Hazard_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<Hazard_Ingest>(buf)
}
pub const HAZARD_INGEST_IDENTIFIER: &str = "HAZA";

#[inline]
pub fn hazard_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, HAZARD_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn hazard_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, HAZARD_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_hazard_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Hazard_Ingest<'a>>) {
  fbb.finish(root, Some(HAZARD_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_hazard_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Hazard_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(HAZARD_INGEST_IDENTIFIER));
}
