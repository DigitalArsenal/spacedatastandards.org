// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LINK_STATUS_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LINK_STATUS_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LINK_STATUS_INGEST_DATA_MODE_ENUM: [LinkStatus_Ingest_dataMode_Enum; 4] = [
  LinkStatus_Ingest_dataMode_Enum::REAL,
  LinkStatus_Ingest_dataMode_Enum::TEST,
  LinkStatus_Ingest_dataMode_Enum::SIMULATED,
  LinkStatus_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LinkStatus_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl LinkStatus_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LinkStatus_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LinkStatus_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LinkStatus_Ingest_dataMode_Enum {
    type Output = LinkStatus_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LinkStatus_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LinkStatus_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LinkStatus_Ingest_dataMode_Enum {}
pub enum LinkStatus_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Captures link status.
pub struct LinkStatus_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LinkStatus_Ingest<'a> {
  type Inner = LinkStatus_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LinkStatus_Ingest<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDONORBIT1: flatbuffers::VOffsetT = 8;
  pub const VT_IDONORBIT2: flatbuffers::VOffsetT = 10;
  pub const VT_LINKSTARTTIME: flatbuffers::VOffsetT = 12;
  pub const VT_LINKSTOPTIME: flatbuffers::VOffsetT = 14;
  pub const VT_CONSTELLATION: flatbuffers::VOffsetT = 16;
  pub const VT_LINKNAME: flatbuffers::VOffsetT = 18;
  pub const VT_LINKTYPE: flatbuffers::VOffsetT = 20;
  pub const VT_BAND: flatbuffers::VOffsetT = 22;
  pub const VT_IDBEAM1: flatbuffers::VOffsetT = 24;
  pub const VT_ENDPOINT1NAME: flatbuffers::VOffsetT = 26;
  pub const VT_ENDPOINT1LAT: flatbuffers::VOffsetT = 28;
  pub const VT_ENDPOINT1LON: flatbuffers::VOffsetT = 30;
  pub const VT_IDBEAM2: flatbuffers::VOffsetT = 32;
  pub const VT_ENDPOINT2NAME: flatbuffers::VOffsetT = 34;
  pub const VT_ENDPOINT2LAT: flatbuffers::VOffsetT = 36;
  pub const VT_ENDPOINT2LON: flatbuffers::VOffsetT = 38;
  pub const VT_DATARATE1TO2: flatbuffers::VOffsetT = 40;
  pub const VT_DATARATE2TO1: flatbuffers::VOffsetT = 42;
  pub const VT_LINKSTATE: flatbuffers::VOffsetT = 44;
  pub const VT_SYSCAP: flatbuffers::VOffsetT = 46;
  pub const VT_OPSCAP: flatbuffers::VOffsetT = 48;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 50;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 52;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 54;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 56;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 58;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 60;
  pub const VT_SATNO1: flatbuffers::VOffsetT = 62;
  pub const VT_SATNO2: flatbuffers::VOffsetT = 64;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LinkStatus_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LinkStatus_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<LinkStatus_Ingest<'bldr>> {
    let mut builder = LinkStatus_IngestBuilder::new(_fbb);
    builder.add_dataRate2To1(args.dataRate2To1);
    builder.add_dataRate1To2(args.dataRate1To2);
    builder.add_endPoint2Lon(args.endPoint2Lon);
    builder.add_endPoint2Lat(args.endPoint2Lat);
    builder.add_endPoint1Lon(args.endPoint1Lon);
    builder.add_endPoint1Lat(args.endPoint1Lat);
    builder.add_satNo2(args.satNo2);
    builder.add_satNo1(args.satNo1);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.opsCap { builder.add_opsCap(x); }
    if let Some(x) = args.sysCap { builder.add_sysCap(x); }
    if let Some(x) = args.linkState { builder.add_linkState(x); }
    if let Some(x) = args.endPoint2Name { builder.add_endPoint2Name(x); }
    if let Some(x) = args.idBeam2 { builder.add_idBeam2(x); }
    if let Some(x) = args.endPoint1Name { builder.add_endPoint1Name(x); }
    if let Some(x) = args.idBeam1 { builder.add_idBeam1(x); }
    if let Some(x) = args.band { builder.add_band(x); }
    if let Some(x) = args.linkType { builder.add_linkType(x); }
    if let Some(x) = args.linkName { builder.add_linkName(x); }
    if let Some(x) = args.constellation { builder.add_constellation(x); }
    if let Some(x) = args.linkStopTime { builder.add_linkStopTime(x); }
    if let Some(x) = args.linkStartTime { builder.add_linkStartTime(x); }
    if let Some(x) = args.idOnOrbit2 { builder.add_idOnOrbit2(x); }
    if let Some(x) = args.idOnOrbit1 { builder.add_idOnOrbit1(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> LinkStatus_IngestT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idOnOrbit1 = self.idOnOrbit1().map(|x| {
      x.to_string()
    });
    let idOnOrbit2 = self.idOnOrbit2().map(|x| {
      x.to_string()
    });
    let linkStartTime = self.linkStartTime().map(|x| {
      x.to_string()
    });
    let linkStopTime = self.linkStopTime().map(|x| {
      x.to_string()
    });
    let constellation = self.constellation().map(|x| {
      x.to_string()
    });
    let linkName = self.linkName().map(|x| {
      x.to_string()
    });
    let linkType = self.linkType().map(|x| {
      x.to_string()
    });
    let band = self.band().map(|x| {
      x.to_string()
    });
    let idBeam1 = self.idBeam1().map(|x| {
      x.to_string()
    });
    let endPoint1Name = self.endPoint1Name().map(|x| {
      x.to_string()
    });
    let endPoint1Lat = self.endPoint1Lat();
    let endPoint1Lon = self.endPoint1Lon();
    let idBeam2 = self.idBeam2().map(|x| {
      x.to_string()
    });
    let endPoint2Name = self.endPoint2Name().map(|x| {
      x.to_string()
    });
    let endPoint2Lat = self.endPoint2Lat();
    let endPoint2Lon = self.endPoint2Lon();
    let dataRate1To2 = self.dataRate1To2();
    let dataRate2To1 = self.dataRate2To1();
    let linkState = self.linkState().map(|x| {
      x.to_string()
    });
    let sysCap = self.sysCap().map(|x| {
      x.to_string()
    });
    let opsCap = self.opsCap().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let satNo1 = self.satNo1();
    let satNo2 = self.satNo2();
    LinkStatus_IngestT {
      id,
      classificationMarking,
      idOnOrbit1,
      idOnOrbit2,
      linkStartTime,
      linkStopTime,
      constellation,
      linkName,
      linkType,
      band,
      idBeam1,
      endPoint1Name,
      endPoint1Lat,
      endPoint1Lon,
      idBeam2,
      endPoint2Name,
      endPoint2Lat,
      endPoint2Lon,
      dataRate1To2,
      dataRate2To1,
      linkState,
      sysCap,
      opsCap,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      dataMode,
      satNo1,
      satNo2,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: LINKSTATUS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique ID of the on-orbit satellite (Sat-1) forming the link.  A null value for idOnOrbit1 indicates that the link is formed over a LEO/MEO constellation.
  /// Example: /// Example: REF-ONORBIT1-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_IDONORBIT1, None)}
  }
  /// Unique ID of the on-orbit satellite (Sat-2) forming the link.  A null value for idOnOrbit2 indicates either a link employing only Sat-1 or a link formed over a LEO/MEO constellation.
  /// Example: /// Example: REF-ONORBIT2-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_IDONORBIT2, None)}
  }
  /// The link establishment time, or the time that the link becomes available for use, in ISO8601 UTC format.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn linkStartTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_LINKSTARTTIME, None)}
  }
  /// The link termination time, or the time that the link becomes unavailable for use, in ISO8601 UTC format.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn linkStopTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_LINKSTOPTIME, None)}
  }
  /// The constellation name if the link is established over a LEO/MEO constellation.  In this case, idOnOrbit1 and idOnOrbit2 will be null.
  /// Example: /// Example: Fornax
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn constellation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_CONSTELLATION, None)}
  }
  /// The name or description of the link.
  /// Example: /// Example: Example description
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn linkName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_LINKNAME, None)}
  }
  /// The type of the link.
  /// Example: /// Example: Example link
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn linkType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_LINKTYPE, None)}
  }
  /// The RF band employed by the link (e.g. MIL-KA, COM-KA, X-BAND, C-BAND, etc.).
  /// Example: /// Example: MIL-KA
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn band(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_BAND, None)}
  }
  /// The ID of beam-1 forming the link.  In the case of two sat link, beam-1 corresponds to Sat-1.
  /// Example: /// Example: REF-BEAM1-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idBeam1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_IDBEAM1, None)}
  }
  /// The name or description of link endpoint-1, corresponding to beam-1.
  /// Example: /// Example: Example endpoint
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn endPoint1Name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_ENDPOINT1NAME, None)}
  }
  /// Latitude of link endpoint-1, WGS-84 in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn endPoint1Lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LinkStatus_Ingest::VT_ENDPOINT1LAT, Some(0.0)).unwrap()}
  }
  /// Longitude of link endpoint-1, WGS-84 longitude in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 80.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn endPoint1Lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LinkStatus_Ingest::VT_ENDPOINT1LON, Some(0.0)).unwrap()}
  }
  /// The ID of beam-2 forming the link.  In the case of two sat link, beam-2 corresponds to Sat-2.
  /// Example: /// Example: REF-BEAM2-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idBeam2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_IDBEAM2, None)}
  }
  /// The name or description of link endpoint-2, corresponding to beam-2.
  /// Example: /// Example: Example description
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn endPoint2Name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_ENDPOINT2NAME, None)}
  }
  /// Latitude of link endpoint-2, WGS-84 in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn endPoint2Lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LinkStatus_Ingest::VT_ENDPOINT2LAT, Some(0.0)).unwrap()}
  }
  /// Longitude of link endpoint-2, WGS-84 longitude in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 80.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn endPoint2Lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LinkStatus_Ingest::VT_ENDPOINT2LON, Some(0.0)).unwrap()}
  }
  /// The endpoint-1 to endpoint-2 data rate, in kbps.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dataRate1To2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LinkStatus_Ingest::VT_DATARATE1TO2, Some(0.0)).unwrap()}
  }
  /// The endpoint-2 to endpoint-1 data rate, in kbps.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dataRate2To1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LinkStatus_Ingest::VT_DATARATE2TO1, Some(0.0)).unwrap()}
  }
  /// The state of the link (e.g. OK, DEGRADED-WEATHER, DEGRADED-EMI, etc.).
  /// Example: /// Example: DEGRADED-WEATHER
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn linkState(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_LINKSTATE, None)}
  }
  /// The SYSCAP mission status of the system(s) forming the link.
  /// Example: /// Example: Example status
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn sysCap(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_SYSCAP, None)}
  }
  /// The OPSCAP mission status of the system(s) forming the link.
  /// Example: /// Example: Example status
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn opsCap(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_OPSCAP, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkStatus_Ingest::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> LinkStatus_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LinkStatus_Ingest_dataMode_Enum>(LinkStatus_Ingest::VT_DATAMODE, Some(LinkStatus_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
  /// Satellite/catalog number of the target on-orbit primary object.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo1(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LinkStatus_Ingest::VT_SATNO1, Some(0)).unwrap()}
  }
  /// Satellite/catalog number of the target on-orbit secondary object.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo2(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LinkStatus_Ingest::VT_SATNO2, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LinkStatus_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit1", Self::VT_IDONORBIT1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit2", Self::VT_IDONORBIT2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("linkStartTime", Self::VT_LINKSTARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("linkStopTime", Self::VT_LINKSTOPTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("constellation", Self::VT_CONSTELLATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("linkName", Self::VT_LINKNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("linkType", Self::VT_LINKTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("band", Self::VT_BAND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idBeam1", Self::VT_IDBEAM1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endPoint1Name", Self::VT_ENDPOINT1NAME, false)?
     .visit_field::<f64>("endPoint1Lat", Self::VT_ENDPOINT1LAT, false)?
     .visit_field::<f64>("endPoint1Lon", Self::VT_ENDPOINT1LON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idBeam2", Self::VT_IDBEAM2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endPoint2Name", Self::VT_ENDPOINT2NAME, false)?
     .visit_field::<f64>("endPoint2Lat", Self::VT_ENDPOINT2LAT, false)?
     .visit_field::<f64>("endPoint2Lon", Self::VT_ENDPOINT2LON, false)?
     .visit_field::<f64>("dataRate1To2", Self::VT_DATARATE1TO2, false)?
     .visit_field::<f64>("dataRate2To1", Self::VT_DATARATE2TO1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("linkState", Self::VT_LINKSTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sysCap", Self::VT_SYSCAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("opsCap", Self::VT_OPSCAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<LinkStatus_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<i32>("satNo1", Self::VT_SATNO1, false)?
     .visit_field::<i32>("satNo2", Self::VT_SATNO2, false)?
     .finish();
    Ok(())
  }
}
pub struct LinkStatus_IngestArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub linkStartTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub linkStopTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub constellation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub linkName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub linkType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub band: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idBeam1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endPoint1Name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endPoint1Lat: f64,
    pub endPoint1Lon: f64,
    pub idBeam2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endPoint2Name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endPoint2Lat: f64,
    pub endPoint2Lon: f64,
    pub dataRate1To2: f64,
    pub dataRate2To1: f64,
    pub linkState: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sysCap: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opsCap: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: LinkStatus_Ingest_dataMode_Enum,
    pub satNo1: i32,
    pub satNo2: i32,
}
impl<'a> Default for LinkStatus_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    LinkStatus_IngestArgs {
      id: None,
      classificationMarking: None,
      idOnOrbit1: None,
      idOnOrbit2: None,
      linkStartTime: None,
      linkStopTime: None,
      constellation: None,
      linkName: None,
      linkType: None,
      band: None,
      idBeam1: None,
      endPoint1Name: None,
      endPoint1Lat: 0.0,
      endPoint1Lon: 0.0,
      idBeam2: None,
      endPoint2Name: None,
      endPoint2Lat: 0.0,
      endPoint2Lon: 0.0,
      dataRate1To2: 0.0,
      dataRate2To1: 0.0,
      linkState: None,
      sysCap: None,
      opsCap: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: LinkStatus_Ingest_dataMode_Enum::REAL,
      satNo1: 0,
      satNo2: 0,
    }
  }
}

pub struct LinkStatus_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LinkStatus_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idOnOrbit1(&mut self, idOnOrbit1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_IDONORBIT1, idOnOrbit1);
  }
  #[inline]
  pub fn add_idOnOrbit2(&mut self, idOnOrbit2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_IDONORBIT2, idOnOrbit2);
  }
  #[inline]
  pub fn add_linkStartTime(&mut self, linkStartTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_LINKSTARTTIME, linkStartTime);
  }
  #[inline]
  pub fn add_linkStopTime(&mut self, linkStopTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_LINKSTOPTIME, linkStopTime);
  }
  #[inline]
  pub fn add_constellation(&mut self, constellation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_CONSTELLATION, constellation);
  }
  #[inline]
  pub fn add_linkName(&mut self, linkName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_LINKNAME, linkName);
  }
  #[inline]
  pub fn add_linkType(&mut self, linkType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_LINKTYPE, linkType);
  }
  #[inline]
  pub fn add_band(&mut self, band: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_BAND, band);
  }
  #[inline]
  pub fn add_idBeam1(&mut self, idBeam1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_IDBEAM1, idBeam1);
  }
  #[inline]
  pub fn add_endPoint1Name(&mut self, endPoint1Name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_ENDPOINT1NAME, endPoint1Name);
  }
  #[inline]
  pub fn add_endPoint1Lat(&mut self, endPoint1Lat: f64) {
    self.fbb_.push_slot::<f64>(LinkStatus_Ingest::VT_ENDPOINT1LAT, endPoint1Lat, 0.0);
  }
  #[inline]
  pub fn add_endPoint1Lon(&mut self, endPoint1Lon: f64) {
    self.fbb_.push_slot::<f64>(LinkStatus_Ingest::VT_ENDPOINT1LON, endPoint1Lon, 0.0);
  }
  #[inline]
  pub fn add_idBeam2(&mut self, idBeam2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_IDBEAM2, idBeam2);
  }
  #[inline]
  pub fn add_endPoint2Name(&mut self, endPoint2Name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_ENDPOINT2NAME, endPoint2Name);
  }
  #[inline]
  pub fn add_endPoint2Lat(&mut self, endPoint2Lat: f64) {
    self.fbb_.push_slot::<f64>(LinkStatus_Ingest::VT_ENDPOINT2LAT, endPoint2Lat, 0.0);
  }
  #[inline]
  pub fn add_endPoint2Lon(&mut self, endPoint2Lon: f64) {
    self.fbb_.push_slot::<f64>(LinkStatus_Ingest::VT_ENDPOINT2LON, endPoint2Lon, 0.0);
  }
  #[inline]
  pub fn add_dataRate1To2(&mut self, dataRate1To2: f64) {
    self.fbb_.push_slot::<f64>(LinkStatus_Ingest::VT_DATARATE1TO2, dataRate1To2, 0.0);
  }
  #[inline]
  pub fn add_dataRate2To1(&mut self, dataRate2To1: f64) {
    self.fbb_.push_slot::<f64>(LinkStatus_Ingest::VT_DATARATE2TO1, dataRate2To1, 0.0);
  }
  #[inline]
  pub fn add_linkState(&mut self, linkState: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_LINKSTATE, linkState);
  }
  #[inline]
  pub fn add_sysCap(&mut self, sysCap: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_SYSCAP, sysCap);
  }
  #[inline]
  pub fn add_opsCap(&mut self, opsCap: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_OPSCAP, opsCap);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkStatus_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: LinkStatus_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<LinkStatus_Ingest_dataMode_Enum>(LinkStatus_Ingest::VT_DATAMODE, dataMode, LinkStatus_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_satNo1(&mut self, satNo1: i32) {
    self.fbb_.push_slot::<i32>(LinkStatus_Ingest::VT_SATNO1, satNo1, 0);
  }
  #[inline]
  pub fn add_satNo2(&mut self, satNo2: i32) {
    self.fbb_.push_slot::<i32>(LinkStatus_Ingest::VT_SATNO2, satNo2, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LinkStatus_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LinkStatus_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LinkStatus_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LinkStatus_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LinkStatus_Ingest");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idOnOrbit1", &self.idOnOrbit1());
      ds.field("idOnOrbit2", &self.idOnOrbit2());
      ds.field("linkStartTime", &self.linkStartTime());
      ds.field("linkStopTime", &self.linkStopTime());
      ds.field("constellation", &self.constellation());
      ds.field("linkName", &self.linkName());
      ds.field("linkType", &self.linkType());
      ds.field("band", &self.band());
      ds.field("idBeam1", &self.idBeam1());
      ds.field("endPoint1Name", &self.endPoint1Name());
      ds.field("endPoint1Lat", &self.endPoint1Lat());
      ds.field("endPoint1Lon", &self.endPoint1Lon());
      ds.field("idBeam2", &self.idBeam2());
      ds.field("endPoint2Name", &self.endPoint2Name());
      ds.field("endPoint2Lat", &self.endPoint2Lat());
      ds.field("endPoint2Lon", &self.endPoint2Lon());
      ds.field("dataRate1To2", &self.dataRate1To2());
      ds.field("dataRate2To1", &self.dataRate2To1());
      ds.field("linkState", &self.linkState());
      ds.field("sysCap", &self.sysCap());
      ds.field("opsCap", &self.opsCap());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.field("satNo1", &self.satNo1());
      ds.field("satNo2", &self.satNo2());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LinkStatus_IngestT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idOnOrbit1: Option<String>,
  pub idOnOrbit2: Option<String>,
  pub linkStartTime: Option<String>,
  pub linkStopTime: Option<String>,
  pub constellation: Option<String>,
  pub linkName: Option<String>,
  pub linkType: Option<String>,
  pub band: Option<String>,
  pub idBeam1: Option<String>,
  pub endPoint1Name: Option<String>,
  pub endPoint1Lat: f64,
  pub endPoint1Lon: f64,
  pub idBeam2: Option<String>,
  pub endPoint2Name: Option<String>,
  pub endPoint2Lat: f64,
  pub endPoint2Lon: f64,
  pub dataRate1To2: f64,
  pub dataRate2To1: f64,
  pub linkState: Option<String>,
  pub sysCap: Option<String>,
  pub opsCap: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: LinkStatus_Ingest_dataMode_Enum,
  pub satNo1: i32,
  pub satNo2: i32,
}
impl Default for LinkStatus_IngestT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idOnOrbit1: None,
      idOnOrbit2: None,
      linkStartTime: None,
      linkStopTime: None,
      constellation: None,
      linkName: None,
      linkType: None,
      band: None,
      idBeam1: None,
      endPoint1Name: None,
      endPoint1Lat: 0.0,
      endPoint1Lon: 0.0,
      idBeam2: None,
      endPoint2Name: None,
      endPoint2Lat: 0.0,
      endPoint2Lon: 0.0,
      dataRate1To2: 0.0,
      dataRate2To1: 0.0,
      linkState: None,
      sysCap: None,
      opsCap: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: LinkStatus_Ingest_dataMode_Enum::REAL,
      satNo1: 0,
      satNo2: 0,
    }
  }
}
impl LinkStatus_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<LinkStatus_Ingest<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit1 = self.idOnOrbit1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit2 = self.idOnOrbit2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let linkStartTime = self.linkStartTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let linkStopTime = self.linkStopTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let constellation = self.constellation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let linkName = self.linkName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let linkType = self.linkType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let band = self.band.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idBeam1 = self.idBeam1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let endPoint1Name = self.endPoint1Name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let endPoint1Lat = self.endPoint1Lat;
    let endPoint1Lon = self.endPoint1Lon;
    let idBeam2 = self.idBeam2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let endPoint2Name = self.endPoint2Name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let endPoint2Lat = self.endPoint2Lat;
    let endPoint2Lon = self.endPoint2Lon;
    let dataRate1To2 = self.dataRate1To2;
    let dataRate2To1 = self.dataRate2To1;
    let linkState = self.linkState.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sysCap = self.sysCap.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let opsCap = self.opsCap.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let satNo1 = self.satNo1;
    let satNo2 = self.satNo2;
    LinkStatus_Ingest::create(_fbb, &LinkStatus_IngestArgs{
      id,
      classificationMarking,
      idOnOrbit1,
      idOnOrbit2,
      linkStartTime,
      linkStopTime,
      constellation,
      linkName,
      linkType,
      band,
      idBeam1,
      endPoint1Name,
      endPoint1Lat,
      endPoint1Lon,
      idBeam2,
      endPoint2Name,
      endPoint2Lat,
      endPoint2Lon,
      dataRate1To2,
      dataRate2To1,
      linkState,
      sysCap,
      opsCap,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      dataMode,
      satNo1,
      satNo2,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `LinkStatus_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_link_status_ingest_unchecked`.
pub fn root_as_link_status_ingest(buf: &[u8]) -> Result<LinkStatus_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<LinkStatus_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `LinkStatus_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_link_status_ingest_unchecked`.
pub fn size_prefixed_root_as_link_status_ingest(buf: &[u8]) -> Result<LinkStatus_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<LinkStatus_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `LinkStatus_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_link_status_ingest_unchecked`.
pub fn root_as_link_status_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LinkStatus_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<LinkStatus_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `LinkStatus_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_link_status_ingest_unchecked`.
pub fn size_prefixed_root_as_link_status_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LinkStatus_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<LinkStatus_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a LinkStatus_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `LinkStatus_Ingest`.
pub unsafe fn root_as_link_status_ingest_unchecked(buf: &[u8]) -> LinkStatus_Ingest {
  flatbuffers::root_unchecked::<LinkStatus_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed LinkStatus_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `LinkStatus_Ingest`.
pub unsafe fn size_prefixed_root_as_link_status_ingest_unchecked(buf: &[u8]) -> LinkStatus_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<LinkStatus_Ingest>(buf)
}
pub const LINK_STATUS_INGEST_IDENTIFIER: &str = "LINK";

#[inline]
pub fn link_status_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LINK_STATUS_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn link_status_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LINK_STATUS_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_link_status_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<LinkStatus_Ingest<'a>>) {
  fbb.finish(root, Some(LINK_STATUS_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_link_status_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<LinkStatus_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(LINK_STATUS_INGEST_IDENTIFIER));
}
