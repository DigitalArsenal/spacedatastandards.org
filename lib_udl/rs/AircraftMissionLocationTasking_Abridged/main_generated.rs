// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum AircraftMissionLocationTasking_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Collection of aircraft mission location information for this aircraft mission tasking.
pub struct AircraftMissionLocationTasking_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AircraftMissionLocationTasking_Abridged<'a> {
  type Inner = AircraftMissionLocationTasking_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AircraftMissionLocationTasking_Abridged<'a> {
  pub const VT_STARTTIME: flatbuffers::VOffsetT = 4;
  pub const VT_ENDTIME: flatbuffers::VOffsetT = 6;
  pub const VT_MSNLOCNAME: flatbuffers::VOffsetT = 8;
  pub const VT_ALT: flatbuffers::VOffsetT = 10;
  pub const VT_AIRMSNPRI: flatbuffers::VOffsetT = 12;
  pub const VT_AREAGEORAD: flatbuffers::VOffsetT = 14;
  pub const VT_MSNLOCPTNAME: flatbuffers::VOffsetT = 16;
  pub const VT_MSNLOCPTLAT: flatbuffers::VOffsetT = 18;
  pub const VT_MSNLOCPTLON: flatbuffers::VOffsetT = 20;
  pub const VT_MSNLOCPTBART: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AircraftMissionLocationTasking_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AircraftMissionLocationTasking_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<AircraftMissionLocationTasking_Abridged<'bldr>> {
    let mut builder = AircraftMissionLocationTasking_AbridgedBuilder::new(_fbb);
    builder.add_msnLocPtLon(args.msnLocPtLon);
    builder.add_msnLocPtLat(args.msnLocPtLat);
    if let Some(x) = args.msnLocPtBarT { builder.add_msnLocPtBarT(x); }
    if let Some(x) = args.msnLocPtName { builder.add_msnLocPtName(x); }
    builder.add_areaGeoRad(args.areaGeoRad);
    if let Some(x) = args.airMsnPri { builder.add_airMsnPri(x); }
    builder.add_alt(args.alt);
    if let Some(x) = args.msnLocName { builder.add_msnLocName(x); }
    if let Some(x) = args.endTime { builder.add_endTime(x); }
    if let Some(x) = args.startTime { builder.add_startTime(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> AircraftMissionLocationTasking_AbridgedT {
    let startTime = self.startTime().map(|x| {
      x.to_string()
    });
    let endTime = self.endTime().map(|x| {
      x.to_string()
    });
    let msnLocName = self.msnLocName().map(|x| {
      x.to_string()
    });
    let alt = self.alt();
    let airMsnPri = self.airMsnPri().map(|x| {
      x.to_string()
    });
    let areaGeoRad = self.areaGeoRad();
    let msnLocPtName = self.msnLocPtName().map(|x| {
      x.to_string()
    });
    let msnLocPtLat = self.msnLocPtLat();
    let msnLocPtLon = self.msnLocPtLon();
    let msnLocPtBarT = self.msnLocPtBarT().map(|x| {
      x.to_string()
    });
    AircraftMissionLocationTasking_AbridgedT {
      startTime,
      endTime,
      msnLocName,
      alt,
      airMsnPri,
      areaGeoRad,
      msnLocPtName,
      msnLocPtLat,
      msnLocPtLon,
      msnLocPtBarT,
    }
  }

  /// The start time of this mission in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2021-10-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn startTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftMissionLocationTasking_Abridged::VT_STARTTIME, None)}
  }
  /// The end time of this mission in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2021-10-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn endTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftMissionLocationTasking_Abridged::VT_ENDTIME, None)}
  }
  /// The name that identifies the location at which this mission is to be performed. This can be the name of a general target area, orbit, cap point, station, etc.
  /// Example: /// Example: KLSV
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn msnLocName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftMissionLocationTasking_Abridged::VT_MSNLOCNAME, None)}
  }
  /// The altitude for this mission represented as hundreds of feet above MSL.
  /// Example: /// Example: 210
  /// Constraints: No constraints specified.
  #[inline]
  pub fn alt(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AircraftMissionLocationTasking_Abridged::VT_ALT, Some(0)).unwrap()}
  }
  /// The code for the priority assigned to this mission.
  /// Example: /// Example: 1A
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn airMsnPri(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftMissionLocationTasking_Abridged::VT_AIRMSNPRI, None)}
  }
  /// The radius of the circle around the location being reported in feet.
  /// Example: /// Example: 1000
  /// Constraints: No constraints specified.
  #[inline]
  pub fn areaGeoRad(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AircraftMissionLocationTasking_Abridged::VT_AREAGEORAD, Some(0)).unwrap()}
  }
  /// The location name for this mission.
  /// Example: /// Example: PT ALFA
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn msnLocPtName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftMissionLocationTasking_Abridged::VT_MSNLOCPTNAME, None)}
  }
  /// WGS-84 latitude of the mission location, in degrees. -90 to 90 degrees (negative values south of equator) for this tasked air mission.
  /// Example: /// Example: 35.123
  /// Constraints: No constraints specified.
  #[inline]
  pub fn msnLocPtLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AircraftMissionLocationTasking_Abridged::VT_MSNLOCPTLAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude of the mission location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian) for this tasked air mission.
  /// Example: /// Example: 79.01
  /// Constraints: No constraints specified.
  #[inline]
  pub fn msnLocPtLon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AircraftMissionLocationTasking_Abridged::VT_MSNLOCPTLON, Some(0.0)).unwrap()}
  }
  /// The alpha-numeric specified location for this mission specified as a bearing angle in degrees relative to true north and a range in nautical miles (NM).
  /// Example: /// Example: 330T-PT ALFA-50NM
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn msnLocPtBarT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftMissionLocationTasking_Abridged::VT_MSNLOCPTBART, None)}
  }
}

impl flatbuffers::Verifiable for AircraftMissionLocationTasking_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("startTime", Self::VT_STARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endTime", Self::VT_ENDTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msnLocName", Self::VT_MSNLOCNAME, false)?
     .visit_field::<i32>("alt", Self::VT_ALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("airMsnPri", Self::VT_AIRMSNPRI, false)?
     .visit_field::<i32>("areaGeoRad", Self::VT_AREAGEORAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msnLocPtName", Self::VT_MSNLOCPTNAME, false)?
     .visit_field::<f64>("msnLocPtLat", Self::VT_MSNLOCPTLAT, false)?
     .visit_field::<f64>("msnLocPtLon", Self::VT_MSNLOCPTLON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msnLocPtBarT", Self::VT_MSNLOCPTBART, false)?
     .finish();
    Ok(())
  }
}
pub struct AircraftMissionLocationTasking_AbridgedArgs<'a> {
    pub startTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msnLocName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub alt: i32,
    pub airMsnPri: Option<flatbuffers::WIPOffset<&'a str>>,
    pub areaGeoRad: i32,
    pub msnLocPtName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msnLocPtLat: f64,
    pub msnLocPtLon: f64,
    pub msnLocPtBarT: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AircraftMissionLocationTasking_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    AircraftMissionLocationTasking_AbridgedArgs {
      startTime: None,
      endTime: None,
      msnLocName: None,
      alt: 0,
      airMsnPri: None,
      areaGeoRad: 0,
      msnLocPtName: None,
      msnLocPtLat: 0.0,
      msnLocPtLon: 0.0,
      msnLocPtBarT: None,
    }
  }
}

pub struct AircraftMissionLocationTasking_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AircraftMissionLocationTasking_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_startTime(&mut self, startTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftMissionLocationTasking_Abridged::VT_STARTTIME, startTime);
  }
  #[inline]
  pub fn add_endTime(&mut self, endTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftMissionLocationTasking_Abridged::VT_ENDTIME, endTime);
  }
  #[inline]
  pub fn add_msnLocName(&mut self, msnLocName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftMissionLocationTasking_Abridged::VT_MSNLOCNAME, msnLocName);
  }
  #[inline]
  pub fn add_alt(&mut self, alt: i32) {
    self.fbb_.push_slot::<i32>(AircraftMissionLocationTasking_Abridged::VT_ALT, alt, 0);
  }
  #[inline]
  pub fn add_airMsnPri(&mut self, airMsnPri: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftMissionLocationTasking_Abridged::VT_AIRMSNPRI, airMsnPri);
  }
  #[inline]
  pub fn add_areaGeoRad(&mut self, areaGeoRad: i32) {
    self.fbb_.push_slot::<i32>(AircraftMissionLocationTasking_Abridged::VT_AREAGEORAD, areaGeoRad, 0);
  }
  #[inline]
  pub fn add_msnLocPtName(&mut self, msnLocPtName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftMissionLocationTasking_Abridged::VT_MSNLOCPTNAME, msnLocPtName);
  }
  #[inline]
  pub fn add_msnLocPtLat(&mut self, msnLocPtLat: f64) {
    self.fbb_.push_slot::<f64>(AircraftMissionLocationTasking_Abridged::VT_MSNLOCPTLAT, msnLocPtLat, 0.0);
  }
  #[inline]
  pub fn add_msnLocPtLon(&mut self, msnLocPtLon: f64) {
    self.fbb_.push_slot::<f64>(AircraftMissionLocationTasking_Abridged::VT_MSNLOCPTLON, msnLocPtLon, 0.0);
  }
  #[inline]
  pub fn add_msnLocPtBarT(&mut self, msnLocPtBarT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftMissionLocationTasking_Abridged::VT_MSNLOCPTBART, msnLocPtBarT);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AircraftMissionLocationTasking_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AircraftMissionLocationTasking_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AircraftMissionLocationTasking_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AircraftMissionLocationTasking_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AircraftMissionLocationTasking_Abridged");
      ds.field("startTime", &self.startTime());
      ds.field("endTime", &self.endTime());
      ds.field("msnLocName", &self.msnLocName());
      ds.field("alt", &self.alt());
      ds.field("airMsnPri", &self.airMsnPri());
      ds.field("areaGeoRad", &self.areaGeoRad());
      ds.field("msnLocPtName", &self.msnLocPtName());
      ds.field("msnLocPtLat", &self.msnLocPtLat());
      ds.field("msnLocPtLon", &self.msnLocPtLon());
      ds.field("msnLocPtBarT", &self.msnLocPtBarT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AircraftMissionLocationTasking_AbridgedT {
  pub startTime: Option<String>,
  pub endTime: Option<String>,
  pub msnLocName: Option<String>,
  pub alt: i32,
  pub airMsnPri: Option<String>,
  pub areaGeoRad: i32,
  pub msnLocPtName: Option<String>,
  pub msnLocPtLat: f64,
  pub msnLocPtLon: f64,
  pub msnLocPtBarT: Option<String>,
}
impl Default for AircraftMissionLocationTasking_AbridgedT {
  fn default() -> Self {
    Self {
      startTime: None,
      endTime: None,
      msnLocName: None,
      alt: 0,
      airMsnPri: None,
      areaGeoRad: 0,
      msnLocPtName: None,
      msnLocPtLat: 0.0,
      msnLocPtLon: 0.0,
      msnLocPtBarT: None,
    }
  }
}
impl AircraftMissionLocationTasking_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AircraftMissionLocationTasking_Abridged<'b>> {
    let startTime = self.startTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let endTime = self.endTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msnLocName = self.msnLocName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let alt = self.alt;
    let airMsnPri = self.airMsnPri.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let areaGeoRad = self.areaGeoRad;
    let msnLocPtName = self.msnLocPtName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msnLocPtLat = self.msnLocPtLat;
    let msnLocPtLon = self.msnLocPtLon;
    let msnLocPtBarT = self.msnLocPtBarT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    AircraftMissionLocationTasking_Abridged::create(_fbb, &AircraftMissionLocationTasking_AbridgedArgs{
      startTime,
      endTime,
      msnLocName,
      alt,
      airMsnPri,
      areaGeoRad,
      msnLocPtName,
      msnLocPtLat,
      msnLocPtLon,
      msnLocPtBarT,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AircraftMissionLocationTasking_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_aircraft_mission_location_tasking_abridged_unchecked`.
pub fn root_as_aircraft_mission_location_tasking_abridged(buf: &[u8]) -> Result<AircraftMissionLocationTasking_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AircraftMissionLocationTasking_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AircraftMissionLocationTasking_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_aircraft_mission_location_tasking_abridged_unchecked`.
pub fn size_prefixed_root_as_aircraft_mission_location_tasking_abridged(buf: &[u8]) -> Result<AircraftMissionLocationTasking_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AircraftMissionLocationTasking_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AircraftMissionLocationTasking_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_aircraft_mission_location_tasking_abridged_unchecked`.
pub fn root_as_aircraft_mission_location_tasking_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AircraftMissionLocationTasking_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AircraftMissionLocationTasking_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AircraftMissionLocationTasking_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_aircraft_mission_location_tasking_abridged_unchecked`.
pub fn size_prefixed_root_as_aircraft_mission_location_tasking_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AircraftMissionLocationTasking_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AircraftMissionLocationTasking_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AircraftMissionLocationTasking_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AircraftMissionLocationTasking_Abridged`.
pub unsafe fn root_as_aircraft_mission_location_tasking_abridged_unchecked(buf: &[u8]) -> AircraftMissionLocationTasking_Abridged {
  flatbuffers::root_unchecked::<AircraftMissionLocationTasking_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AircraftMissionLocationTasking_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AircraftMissionLocationTasking_Abridged`.
pub unsafe fn size_prefixed_root_as_aircraft_mission_location_tasking_abridged_unchecked(buf: &[u8]) -> AircraftMissionLocationTasking_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<AircraftMissionLocationTasking_Abridged>(buf)
}
pub const AIRCRAFT_MISSION_LOCATION_TASKING_ABRIDGED_IDENTIFIER: &str = "AIRC";

#[inline]
pub fn aircraft_mission_location_tasking_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRCRAFT_MISSION_LOCATION_TASKING_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn aircraft_mission_location_tasking_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRCRAFT_MISSION_LOCATION_TASKING_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_aircraft_mission_location_tasking_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AircraftMissionLocationTasking_Abridged<'a>>) {
  fbb.finish(root, Some(AIRCRAFT_MISSION_LOCATION_TASKING_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_aircraft_mission_location_tasking_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AircraftMissionLocationTasking_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(AIRCRAFT_MISSION_LOCATION_TASKING_ABRIDGED_IDENTIFIER));
}
