// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum LogisticsTransportationPlans_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Transportation plans associated with this LogisticsSupport record, used to coordinate maintenance efforts.
pub struct LogisticsTransportationPlans_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogisticsTransportationPlans_Ingest<'a> {
  type Inner = LogisticsTransportationPlans_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogisticsTransportationPlans_Ingest<'a> {
  pub const VT_PLANSNUMBER: flatbuffers::VOffsetT = 4;
  pub const VT_MISSIONCHANGE: flatbuffers::VOffsetT = 6;
  pub const VT_PLANDEFINITION: flatbuffers::VOffsetT = 8;
  pub const VT_STATUSCODE: flatbuffers::VOffsetT = 10;
  pub const VT_COORDINATOR: flatbuffers::VOffsetT = 12;
  pub const VT_COORDINATORUNIT: flatbuffers::VOffsetT = 14;
  pub const VT_ORIGINICAO: flatbuffers::VOffsetT = 16;
  pub const VT_ESTDEPTIME: flatbuffers::VOffsetT = 18;
  pub const VT_ESTARRTIME: flatbuffers::VOffsetT = 20;
  pub const VT_DESTINATIONICAO: flatbuffers::VOffsetT = 22;
  pub const VT_LOGISTICMASTERRECORDID: flatbuffers::VOffsetT = 24;
  pub const VT_TPTAILNUMBER: flatbuffers::VOffsetT = 26;
  pub const VT_TPAIRCRAFTMDS: flatbuffers::VOffsetT = 28;
  pub const VT_MAJCOM: flatbuffers::VOffsetT = 30;
  pub const VT_APPROXARRTIME: flatbuffers::VOffsetT = 32;
  pub const VT_DURATION: flatbuffers::VOffsetT = 34;
  pub const VT_ACTDEPTIME: flatbuffers::VOffsetT = 36;
  pub const VT_CLOSEDDATE: flatbuffers::VOffsetT = 38;
  pub const VT_CANCELLEDDATE: flatbuffers::VOffsetT = 40;
  pub const VT_AIRCRAFTSTATUS: flatbuffers::VOffsetT = 42;
  pub const VT_NUMENROUTESTOPS: flatbuffers::VOffsetT = 44;
  pub const VT_SERIALNUMBER: flatbuffers::VOffsetT = 46;
  pub const VT_NUMTRANSLOADS: flatbuffers::VOffsetT = 48;
  pub const VT_LASTCHANGEDDATE: flatbuffers::VOffsetT = 50;
  pub const VT_LOGISTICSSEGMENTS: flatbuffers::VOffsetT = 52;
  pub const VT_LOGISTICSTRANSPORTATIONPLANSREMARKS: flatbuffers::VOffsetT = 54;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogisticsTransportationPlans_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LogisticsTransportationPlans_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<LogisticsTransportationPlans_Ingest<'bldr>> {
    let mut builder = LogisticsTransportationPlans_IngestBuilder::new(_fbb);
    if let Some(x) = args.logisticsTransportationPlansRemarks { builder.add_logisticsTransportationPlansRemarks(x); }
    if let Some(x) = args.logisticsSegments { builder.add_logisticsSegments(x); }
    if let Some(x) = args.lastChangedDate { builder.add_lastChangedDate(x); }
    builder.add_numTransLoads(args.numTransLoads);
    if let Some(x) = args.serialNumber { builder.add_serialNumber(x); }
    builder.add_numEnrouteStops(args.numEnrouteStops);
    if let Some(x) = args.aircraftStatus { builder.add_aircraftStatus(x); }
    if let Some(x) = args.cancelledDate { builder.add_cancelledDate(x); }
    if let Some(x) = args.closedDate { builder.add_closedDate(x); }
    if let Some(x) = args.actDepTime { builder.add_actDepTime(x); }
    if let Some(x) = args.duration { builder.add_duration(x); }
    if let Some(x) = args.approxArrTime { builder.add_approxArrTime(x); }
    if let Some(x) = args.majcom { builder.add_majcom(x); }
    if let Some(x) = args.tpAircraftMDS { builder.add_tpAircraftMDS(x); }
    if let Some(x) = args.tpTailNumber { builder.add_tpTailNumber(x); }
    if let Some(x) = args.logisticMasterRecordId { builder.add_logisticMasterRecordId(x); }
    if let Some(x) = args.destinationICAO { builder.add_destinationICAO(x); }
    if let Some(x) = args.estArrTime { builder.add_estArrTime(x); }
    if let Some(x) = args.estDepTime { builder.add_estDepTime(x); }
    if let Some(x) = args.originICAO { builder.add_originICAO(x); }
    if let Some(x) = args.coordinatorUnit { builder.add_coordinatorUnit(x); }
    if let Some(x) = args.coordinator { builder.add_coordinator(x); }
    if let Some(x) = args.statusCode { builder.add_statusCode(x); }
    if let Some(x) = args.planDefinition { builder.add_planDefinition(x); }
    if let Some(x) = args.plansNumber { builder.add_plansNumber(x); }
    builder.add_missionChange(args.missionChange);
    builder.finish()
  }

  pub fn unpack(&self) -> LogisticsTransportationPlans_IngestT {
    let plansNumber = self.plansNumber().map(|x| {
      x.to_string()
    });
    let missionChange = self.missionChange();
    let planDefinition = self.planDefinition().map(|x| {
      x.to_string()
    });
    let statusCode = self.statusCode().map(|x| {
      x.to_string()
    });
    let coordinator = self.coordinator().map(|x| {
      x.to_string()
    });
    let coordinatorUnit = self.coordinatorUnit().map(|x| {
      x.to_string()
    });
    let originICAO = self.originICAO().map(|x| {
      x.to_string()
    });
    let estDepTime = self.estDepTime().map(|x| {
      x.to_string()
    });
    let estArrTime = self.estArrTime().map(|x| {
      x.to_string()
    });
    let destinationICAO = self.destinationICAO().map(|x| {
      x.to_string()
    });
    let logisticMasterRecordId = self.logisticMasterRecordId().map(|x| {
      x.to_string()
    });
    let tpTailNumber = self.tpTailNumber().map(|x| {
      x.to_string()
    });
    let tpAircraftMDS = self.tpAircraftMDS().map(|x| {
      x.to_string()
    });
    let majcom = self.majcom().map(|x| {
      x.to_string()
    });
    let approxArrTime = self.approxArrTime().map(|x| {
      x.to_string()
    });
    let duration = self.duration().map(|x| {
      x.to_string()
    });
    let actDepTime = self.actDepTime().map(|x| {
      x.to_string()
    });
    let closedDate = self.closedDate().map(|x| {
      x.to_string()
    });
    let cancelledDate = self.cancelledDate().map(|x| {
      x.to_string()
    });
    let aircraftStatus = self.aircraftStatus().map(|x| {
      x.to_string()
    });
    let numEnrouteStops = self.numEnrouteStops();
    let serialNumber = self.serialNumber().map(|x| {
      x.to_string()
    });
    let numTransLoads = self.numTransLoads();
    let lastChangedDate = self.lastChangedDate().map(|x| {
      x.to_string()
    });
    let logisticsSegments = self.logisticsSegments().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let logisticsTransportationPlansRemarks = self.logisticsTransportationPlansRemarks().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    LogisticsTransportationPlans_IngestT {
      plansNumber,
      missionChange,
      planDefinition,
      statusCode,
      coordinator,
      coordinatorUnit,
      originICAO,
      estDepTime,
      estArrTime,
      destinationICAO,
      logisticMasterRecordId,
      tpTailNumber,
      tpAircraftMDS,
      majcom,
      approxArrTime,
      duration,
      actDepTime,
      closedDate,
      cancelledDate,
      aircraftStatus,
      numEnrouteStops,
      serialNumber,
      numTransLoads,
      lastChangedDate,
      logisticsSegments,
      logisticsTransportationPlansRemarks,
    }
  }

  /// System generated reference id for the transportation plan.  Format: TXXXXXNNNN  T - Transportation, Sequence Number, Node Id.
  /// Example: /// Example: T89002
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn plansNumber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_PLANSNUMBER, None)}
  }
  /// Indicates whether there have been changes to changes to ICAOs, estArrTime, or estDepTime since this Transportation Plan was last edited.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn missionChange(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(LogisticsTransportationPlans_Ingest::VT_MISSIONCHANGE, Some(false)).unwrap()}
  }
  /// Defines the transporation plan as either a deployment or redeployment.
  /// Example: /// Example: DEPLOY
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn planDefinition(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_PLANDEFINITION, None)}
  }
  /// Transporation Coordination status code. Cancel, Send to APCC, working, agree, disapprove or blank.
  /// Example: /// Example: N
  /// Constraints: Minimum length = 1, Maximum length = 1
  #[inline]
  pub fn statusCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_STATUSCODE, None)}
  }
  /// The AMS username of the operator who alters the coordination status.  Automatically captured by the system.
  /// Example: /// Example: SMITH, JOHN
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn coordinator(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_COORDINATOR, None)}
  }
  /// The AMS user unit_id of the operator who alters the coordination status.  Automatically captured by the system from table AMS_USER.
  /// Example: /// Example: TACC
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn coordinatorUnit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_COORDINATORUNIT, None)}
  }
  /// The origin location.
  /// Example: /// Example: KATL
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn originICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_ORIGINICAO, None)}
  }
  /// ETD of the first segment, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-15T14:25:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn estDepTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_ESTDEPTIME, None)}
  }
  /// ETA of the final segment, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-15T14:25:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn estArrTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_ESTARRTIME, None)}
  }
  /// Destination location ICAO.
  /// Example: /// Example: YBCS
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn destinationICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_DESTINATIONICAO, None)}
  }
  /// The identifier that represents a Logistics Master Record.
  /// Example: /// Example: L62126
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn logisticMasterRecordId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_LOGISTICMASTERRECORDID, None)}
  }
  /// Contains the tail number displayed by GDSS2.
  /// Example: /// Example: 99209
  /// Constraints: Minimum length = 0, Maximum length = 7
  #[inline]
  pub fn tpTailNumber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_TPTAILNUMBER, None)}
  }
  /// The aircraft Model Design Series (MDS) designation (e.g. E-2C HAWKEYE, F-15 EAGLE, KC-130 HERCULES, etc.) of this aircraft. Intended as, but not constrained to, MIL-STD-6016 environment dependent specific type designations.
  /// Example: /// Example: C17A
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn tpAircraftMDS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_TPAIRCRAFTMDS, None)}
  }
  /// The major command for the current unit.
  /// Example: /// Example: HQAMC
  /// Constraints: Minimum length = 0, Maximum length = 250
  #[inline]
  pub fn majcom(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_MAJCOM, None)}
  }
  /// Approximate time of arrival of final segement, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-14T20:37:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn approxArrTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_APPROXARRTIME, None)}
  }
  /// Transportation plan duration, expressed in the format MMM:SS.
  /// Example: /// Example: 086:20
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn duration(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_DURATION, None)}
  }
  /// Actual time of departure of first segment, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-14T19:37:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn actDepTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_ACTDEPTIME, None)}
  }
  /// GC. LGTP_CLSD_DT.  GD2:  Date when the transportation plan was closed, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-14T20:37:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn closedDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_CLOSEDDATE, None)}
  }
  /// GC. LGTP_CANX_DT.  GD2: Date when the transportation plan was cancelled, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-14T20:37:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cancelledDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_CANCELLEDDATE, None)}
  }
  /// These are the initial maintenance values entered based on the pilot descriptions or the official maintenance evaluation code.
  /// Example: /// Example: NMCMU
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn aircraftStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_AIRCRAFTSTATUS, None)}
  }
  /// Transportation plan enroute stops.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numEnrouteStops(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LogisticsTransportationPlans_Ingest::VT_NUMENROUTESTOPS, Some(0)).unwrap()}
  }
  /// GDSS2 uses an 8 character serial number to uniquely identify the aircraft and MDS combination. This is a portion of the full manufacturer serial number.
  /// Example: /// Example: 9009209
  /// Constraints: Minimum length = 0, Maximum length = 30
  #[inline]
  pub fn serialNumber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_SERIALNUMBER, None)}
  }
  /// The number of transloads for this Transportation Plan.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numTransLoads(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LogisticsTransportationPlans_Ingest::VT_NUMTRANSLOADS, Some(0)).unwrap()}
  }
  /// Last time transportation plan was updated, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-14T20:37:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lastChangedDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogisticsTransportationPlans_Ingest::VT_LASTCHANGEDDATE, None)}
  }
  /// The transportation segments associated with this transportation plan.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn logisticsSegments(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LogisticsTransportationPlans_Ingest::VT_LOGISTICSSEGMENTS, None)}
  }
  /// Remarks associated with this transportation plan.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn logisticsTransportationPlansRemarks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LogisticsTransportationPlans_Ingest::VT_LOGISTICSTRANSPORTATIONPLANSREMARKS, None)}
  }
}

impl flatbuffers::Verifiable for LogisticsTransportationPlans_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("plansNumber", Self::VT_PLANSNUMBER, false)?
     .visit_field::<bool>("missionChange", Self::VT_MISSIONCHANGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("planDefinition", Self::VT_PLANDEFINITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("statusCode", Self::VT_STATUSCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coordinator", Self::VT_COORDINATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coordinatorUnit", Self::VT_COORDINATORUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("originICAO", Self::VT_ORIGINICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("estDepTime", Self::VT_ESTDEPTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("estArrTime", Self::VT_ESTARRTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("destinationICAO", Self::VT_DESTINATIONICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("logisticMasterRecordId", Self::VT_LOGISTICMASTERRECORDID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tpTailNumber", Self::VT_TPTAILNUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tpAircraftMDS", Self::VT_TPAIRCRAFTMDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("majcom", Self::VT_MAJCOM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("approxArrTime", Self::VT_APPROXARRTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("duration", Self::VT_DURATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("actDepTime", Self::VT_ACTDEPTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("closedDate", Self::VT_CLOSEDDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cancelledDate", Self::VT_CANCELLEDDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("aircraftStatus", Self::VT_AIRCRAFTSTATUS, false)?
     .visit_field::<i32>("numEnrouteStops", Self::VT_NUMENROUTESTOPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("serialNumber", Self::VT_SERIALNUMBER, false)?
     .visit_field::<i32>("numTransLoads", Self::VT_NUMTRANSLOADS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastChangedDate", Self::VT_LASTCHANGEDDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("logisticsSegments", Self::VT_LOGISTICSSEGMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("logisticsTransportationPlansRemarks", Self::VT_LOGISTICSTRANSPORTATIONPLANSREMARKS, false)?
     .finish();
    Ok(())
  }
}
pub struct LogisticsTransportationPlans_IngestArgs<'a> {
    pub plansNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub missionChange: bool,
    pub planDefinition: Option<flatbuffers::WIPOffset<&'a str>>,
    pub statusCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coordinator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coordinatorUnit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub originICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub estDepTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub estArrTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub destinationICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub logisticMasterRecordId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tpTailNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tpAircraftMDS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub majcom: Option<flatbuffers::WIPOffset<&'a str>>,
    pub approxArrTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub duration: Option<flatbuffers::WIPOffset<&'a str>>,
    pub actDepTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub closedDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cancelledDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub aircraftStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub numEnrouteStops: i32,
    pub serialNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub numTransLoads: i32,
    pub lastChangedDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub logisticsSegments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub logisticsTransportationPlansRemarks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for LogisticsTransportationPlans_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    LogisticsTransportationPlans_IngestArgs {
      plansNumber: None,
      missionChange: false,
      planDefinition: None,
      statusCode: None,
      coordinator: None,
      coordinatorUnit: None,
      originICAO: None,
      estDepTime: None,
      estArrTime: None,
      destinationICAO: None,
      logisticMasterRecordId: None,
      tpTailNumber: None,
      tpAircraftMDS: None,
      majcom: None,
      approxArrTime: None,
      duration: None,
      actDepTime: None,
      closedDate: None,
      cancelledDate: None,
      aircraftStatus: None,
      numEnrouteStops: 0,
      serialNumber: None,
      numTransLoads: 0,
      lastChangedDate: None,
      logisticsSegments: None,
      logisticsTransportationPlansRemarks: None,
    }
  }
}

pub struct LogisticsTransportationPlans_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LogisticsTransportationPlans_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_plansNumber(&mut self, plansNumber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_PLANSNUMBER, plansNumber);
  }
  #[inline]
  pub fn add_missionChange(&mut self, missionChange: bool) {
    self.fbb_.push_slot::<bool>(LogisticsTransportationPlans_Ingest::VT_MISSIONCHANGE, missionChange, false);
  }
  #[inline]
  pub fn add_planDefinition(&mut self, planDefinition: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_PLANDEFINITION, planDefinition);
  }
  #[inline]
  pub fn add_statusCode(&mut self, statusCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_STATUSCODE, statusCode);
  }
  #[inline]
  pub fn add_coordinator(&mut self, coordinator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_COORDINATOR, coordinator);
  }
  #[inline]
  pub fn add_coordinatorUnit(&mut self, coordinatorUnit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_COORDINATORUNIT, coordinatorUnit);
  }
  #[inline]
  pub fn add_originICAO(&mut self, originICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_ORIGINICAO, originICAO);
  }
  #[inline]
  pub fn add_estDepTime(&mut self, estDepTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_ESTDEPTIME, estDepTime);
  }
  #[inline]
  pub fn add_estArrTime(&mut self, estArrTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_ESTARRTIME, estArrTime);
  }
  #[inline]
  pub fn add_destinationICAO(&mut self, destinationICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_DESTINATIONICAO, destinationICAO);
  }
  #[inline]
  pub fn add_logisticMasterRecordId(&mut self, logisticMasterRecordId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_LOGISTICMASTERRECORDID, logisticMasterRecordId);
  }
  #[inline]
  pub fn add_tpTailNumber(&mut self, tpTailNumber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_TPTAILNUMBER, tpTailNumber);
  }
  #[inline]
  pub fn add_tpAircraftMDS(&mut self, tpAircraftMDS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_TPAIRCRAFTMDS, tpAircraftMDS);
  }
  #[inline]
  pub fn add_majcom(&mut self, majcom: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_MAJCOM, majcom);
  }
  #[inline]
  pub fn add_approxArrTime(&mut self, approxArrTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_APPROXARRTIME, approxArrTime);
  }
  #[inline]
  pub fn add_duration(&mut self, duration: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_DURATION, duration);
  }
  #[inline]
  pub fn add_actDepTime(&mut self, actDepTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_ACTDEPTIME, actDepTime);
  }
  #[inline]
  pub fn add_closedDate(&mut self, closedDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_CLOSEDDATE, closedDate);
  }
  #[inline]
  pub fn add_cancelledDate(&mut self, cancelledDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_CANCELLEDDATE, cancelledDate);
  }
  #[inline]
  pub fn add_aircraftStatus(&mut self, aircraftStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_AIRCRAFTSTATUS, aircraftStatus);
  }
  #[inline]
  pub fn add_numEnrouteStops(&mut self, numEnrouteStops: i32) {
    self.fbb_.push_slot::<i32>(LogisticsTransportationPlans_Ingest::VT_NUMENROUTESTOPS, numEnrouteStops, 0);
  }
  #[inline]
  pub fn add_serialNumber(&mut self, serialNumber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_SERIALNUMBER, serialNumber);
  }
  #[inline]
  pub fn add_numTransLoads(&mut self, numTransLoads: i32) {
    self.fbb_.push_slot::<i32>(LogisticsTransportationPlans_Ingest::VT_NUMTRANSLOADS, numTransLoads, 0);
  }
  #[inline]
  pub fn add_lastChangedDate(&mut self, lastChangedDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_LASTCHANGEDDATE, lastChangedDate);
  }
  #[inline]
  pub fn add_logisticsSegments(&mut self, logisticsSegments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_LOGISTICSSEGMENTS, logisticsSegments);
  }
  #[inline]
  pub fn add_logisticsTransportationPlansRemarks(&mut self, logisticsTransportationPlansRemarks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogisticsTransportationPlans_Ingest::VT_LOGISTICSTRANSPORTATIONPLANSREMARKS, logisticsTransportationPlansRemarks);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LogisticsTransportationPlans_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LogisticsTransportationPlans_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogisticsTransportationPlans_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogisticsTransportationPlans_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogisticsTransportationPlans_Ingest");
      ds.field("plansNumber", &self.plansNumber());
      ds.field("missionChange", &self.missionChange());
      ds.field("planDefinition", &self.planDefinition());
      ds.field("statusCode", &self.statusCode());
      ds.field("coordinator", &self.coordinator());
      ds.field("coordinatorUnit", &self.coordinatorUnit());
      ds.field("originICAO", &self.originICAO());
      ds.field("estDepTime", &self.estDepTime());
      ds.field("estArrTime", &self.estArrTime());
      ds.field("destinationICAO", &self.destinationICAO());
      ds.field("logisticMasterRecordId", &self.logisticMasterRecordId());
      ds.field("tpTailNumber", &self.tpTailNumber());
      ds.field("tpAircraftMDS", &self.tpAircraftMDS());
      ds.field("majcom", &self.majcom());
      ds.field("approxArrTime", &self.approxArrTime());
      ds.field("duration", &self.duration());
      ds.field("actDepTime", &self.actDepTime());
      ds.field("closedDate", &self.closedDate());
      ds.field("cancelledDate", &self.cancelledDate());
      ds.field("aircraftStatus", &self.aircraftStatus());
      ds.field("numEnrouteStops", &self.numEnrouteStops());
      ds.field("serialNumber", &self.serialNumber());
      ds.field("numTransLoads", &self.numTransLoads());
      ds.field("lastChangedDate", &self.lastChangedDate());
      ds.field("logisticsSegments", &self.logisticsSegments());
      ds.field("logisticsTransportationPlansRemarks", &self.logisticsTransportationPlansRemarks());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LogisticsTransportationPlans_IngestT {
  pub plansNumber: Option<String>,
  pub missionChange: bool,
  pub planDefinition: Option<String>,
  pub statusCode: Option<String>,
  pub coordinator: Option<String>,
  pub coordinatorUnit: Option<String>,
  pub originICAO: Option<String>,
  pub estDepTime: Option<String>,
  pub estArrTime: Option<String>,
  pub destinationICAO: Option<String>,
  pub logisticMasterRecordId: Option<String>,
  pub tpTailNumber: Option<String>,
  pub tpAircraftMDS: Option<String>,
  pub majcom: Option<String>,
  pub approxArrTime: Option<String>,
  pub duration: Option<String>,
  pub actDepTime: Option<String>,
  pub closedDate: Option<String>,
  pub cancelledDate: Option<String>,
  pub aircraftStatus: Option<String>,
  pub numEnrouteStops: i32,
  pub serialNumber: Option<String>,
  pub numTransLoads: i32,
  pub lastChangedDate: Option<String>,
  pub logisticsSegments: Option<Vec<String>>,
  pub logisticsTransportationPlansRemarks: Option<Vec<String>>,
}
impl Default for LogisticsTransportationPlans_IngestT {
  fn default() -> Self {
    Self {
      plansNumber: None,
      missionChange: false,
      planDefinition: None,
      statusCode: None,
      coordinator: None,
      coordinatorUnit: None,
      originICAO: None,
      estDepTime: None,
      estArrTime: None,
      destinationICAO: None,
      logisticMasterRecordId: None,
      tpTailNumber: None,
      tpAircraftMDS: None,
      majcom: None,
      approxArrTime: None,
      duration: None,
      actDepTime: None,
      closedDate: None,
      cancelledDate: None,
      aircraftStatus: None,
      numEnrouteStops: 0,
      serialNumber: None,
      numTransLoads: 0,
      lastChangedDate: None,
      logisticsSegments: None,
      logisticsTransportationPlansRemarks: None,
    }
  }
}
impl LogisticsTransportationPlans_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<LogisticsTransportationPlans_Ingest<'b>> {
    let plansNumber = self.plansNumber.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let missionChange = self.missionChange;
    let planDefinition = self.planDefinition.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let statusCode = self.statusCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let coordinator = self.coordinator.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let coordinatorUnit = self.coordinatorUnit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let originICAO = self.originICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let estDepTime = self.estDepTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let estArrTime = self.estArrTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let destinationICAO = self.destinationICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let logisticMasterRecordId = self.logisticMasterRecordId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tpTailNumber = self.tpTailNumber.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tpAircraftMDS = self.tpAircraftMDS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let majcom = self.majcom.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let approxArrTime = self.approxArrTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let duration = self.duration.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let actDepTime = self.actDepTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let closedDate = self.closedDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cancelledDate = self.cancelledDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let aircraftStatus = self.aircraftStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let numEnrouteStops = self.numEnrouteStops;
    let serialNumber = self.serialNumber.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let numTransLoads = self.numTransLoads;
    let lastChangedDate = self.lastChangedDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let logisticsSegments = self.logisticsSegments.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let logisticsTransportationPlansRemarks = self.logisticsTransportationPlansRemarks.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    LogisticsTransportationPlans_Ingest::create(_fbb, &LogisticsTransportationPlans_IngestArgs{
      plansNumber,
      missionChange,
      planDefinition,
      statusCode,
      coordinator,
      coordinatorUnit,
      originICAO,
      estDepTime,
      estArrTime,
      destinationICAO,
      logisticMasterRecordId,
      tpTailNumber,
      tpAircraftMDS,
      majcom,
      approxArrTime,
      duration,
      actDepTime,
      closedDate,
      cancelledDate,
      aircraftStatus,
      numEnrouteStops,
      serialNumber,
      numTransLoads,
      lastChangedDate,
      logisticsSegments,
      logisticsTransportationPlansRemarks,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `LogisticsTransportationPlans_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_logistics_transportation_plans_ingest_unchecked`.
pub fn root_as_logistics_transportation_plans_ingest(buf: &[u8]) -> Result<LogisticsTransportationPlans_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<LogisticsTransportationPlans_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `LogisticsTransportationPlans_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_logistics_transportation_plans_ingest_unchecked`.
pub fn size_prefixed_root_as_logistics_transportation_plans_ingest(buf: &[u8]) -> Result<LogisticsTransportationPlans_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<LogisticsTransportationPlans_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `LogisticsTransportationPlans_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_logistics_transportation_plans_ingest_unchecked`.
pub fn root_as_logistics_transportation_plans_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LogisticsTransportationPlans_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<LogisticsTransportationPlans_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `LogisticsTransportationPlans_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_logistics_transportation_plans_ingest_unchecked`.
pub fn size_prefixed_root_as_logistics_transportation_plans_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LogisticsTransportationPlans_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<LogisticsTransportationPlans_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a LogisticsTransportationPlans_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `LogisticsTransportationPlans_Ingest`.
pub unsafe fn root_as_logistics_transportation_plans_ingest_unchecked(buf: &[u8]) -> LogisticsTransportationPlans_Ingest {
  flatbuffers::root_unchecked::<LogisticsTransportationPlans_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed LogisticsTransportationPlans_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `LogisticsTransportationPlans_Ingest`.
pub unsafe fn size_prefixed_root_as_logistics_transportation_plans_ingest_unchecked(buf: &[u8]) -> LogisticsTransportationPlans_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<LogisticsTransportationPlans_Ingest>(buf)
}
pub const LOGISTICS_TRANSPORTATION_PLANS_INGEST_IDENTIFIER: &str = "LOGI";

#[inline]
pub fn logistics_transportation_plans_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LOGISTICS_TRANSPORTATION_PLANS_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn logistics_transportation_plans_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LOGISTICS_TRANSPORTATION_PLANS_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_logistics_transportation_plans_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<LogisticsTransportationPlans_Ingest<'a>>) {
  fbb.finish(root, Some(LOGISTICS_TRANSPORTATION_PLANS_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_logistics_transportation_plans_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<LogisticsTransportationPlans_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(LOGISTICS_TRANSPORTATION_PLANS_INGEST_IDENTIFIER));
}
