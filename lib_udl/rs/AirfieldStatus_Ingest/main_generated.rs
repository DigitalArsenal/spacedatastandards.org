// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AIRFIELD_STATUS_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AIRFIELD_STATUS_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AIRFIELD_STATUS_INGEST_DATA_MODE_ENUM: [AirfieldStatus_Ingest_dataMode_Enum; 4] = [
  AirfieldStatus_Ingest_dataMode_Enum::REAL,
  AirfieldStatus_Ingest_dataMode_Enum::TEST,
  AirfieldStatus_Ingest_dataMode_Enum::SIMULATED,
  AirfieldStatus_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AirfieldStatus_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AirfieldStatus_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AirfieldStatus_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AirfieldStatus_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AirfieldStatus_Ingest_dataMode_Enum {
    type Output = AirfieldStatus_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AirfieldStatus_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AirfieldStatus_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AirfieldStatus_Ingest_dataMode_Enum {}
pub enum AirfieldStatus_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// The airfield status contains dynamic data of an airfield's capabilities.
pub struct AirfieldStatus_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AirfieldStatus_Ingest<'a> {
  type Inner = AirfieldStatus_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AirfieldStatus_Ingest<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDAIRFIELD: flatbuffers::VOffsetT = 8;
  pub const VT_ALTAIRFIELDID: flatbuffers::VOffsetT = 10;
  pub const VT_PASSENGERSERVICEMOG: flatbuffers::VOffsetT = 12;
  pub const VT_FLEETSERVICEMOG: flatbuffers::VOffsetT = 14;
  pub const VT_CARGOMOG: flatbuffers::VOffsetT = 16;
  pub const VT_FUELMOG: flatbuffers::VOffsetT = 18;
  pub const VT_FUELTYPES: flatbuffers::VOffsetT = 20;
  pub const VT_FUELQTYS: flatbuffers::VOffsetT = 22;
  pub const VT_MXMOG: flatbuffers::VOffsetT = 24;
  pub const VT_OPERATINGMOG: flatbuffers::VOffsetT = 26;
  pub const VT_NUMCOG: flatbuffers::VOffsetT = 28;
  pub const VT_WIDEWORKINGMOG: flatbuffers::VOffsetT = 30;
  pub const VT_WIDEPARKINGMOG: flatbuffers::VOffsetT = 32;
  pub const VT_NARROWWORKINGMOG: flatbuffers::VOffsetT = 34;
  pub const VT_NARROWPARKINGMOG: flatbuffers::VOffsetT = 36;
  pub const VT_MHETYPES: flatbuffers::VOffsetT = 38;
  pub const VT_MHEQTYS: flatbuffers::VOffsetT = 40;
  pub const VT_MEDCAP: flatbuffers::VOffsetT = 42;
  pub const VT_ARFFCAT: flatbuffers::VOffsetT = 44;
  pub const VT_GSETIME: flatbuffers::VOffsetT = 46;
  pub const VT_PRIRWYNUM: flatbuffers::VOffsetT = 48;
  pub const VT_RWYCONDREADING: flatbuffers::VOffsetT = 50;
  pub const VT_RWYFRICTIONFACTOR: flatbuffers::VOffsetT = 52;
  pub const VT_RWYMARKINGS: flatbuffers::VOffsetT = 54;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 56;
  pub const VT_PRIFREQ: flatbuffers::VOffsetT = 58;
  pub const VT_SLOTTYPESREQ: flatbuffers::VOffsetT = 60;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 62;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 64;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 66;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 68;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 70;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 72;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 74;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AirfieldStatus_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AirfieldStatus_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<AirfieldStatus_Ingest<'bldr>> {
    let mut builder = AirfieldStatus_IngestBuilder::new(_fbb);
    builder.add_priFreq(args.priFreq);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.slotTypesReq { builder.add_slotTypesReq(x); }
    if let Some(x) = args.message { builder.add_message(x); }
    if let Some(x) = args.rwyMarkings { builder.add_rwyMarkings(x); }
    builder.add_rwyFrictionFactor(args.rwyFrictionFactor);
    builder.add_rwyCondReading(args.rwyCondReading);
    if let Some(x) = args.priRwyNum { builder.add_priRwyNum(x); }
    builder.add_gseTime(args.gseTime);
    if let Some(x) = args.arffCat { builder.add_arffCat(x); }
    if let Some(x) = args.medCap { builder.add_medCap(x); }
    if let Some(x) = args.mheQtys { builder.add_mheQtys(x); }
    if let Some(x) = args.mheTypes { builder.add_mheTypes(x); }
    builder.add_narrowParkingMOG(args.narrowParkingMOG);
    builder.add_narrowWorkingMOG(args.narrowWorkingMOG);
    builder.add_wideParkingMOG(args.wideParkingMOG);
    builder.add_wideWorkingMOG(args.wideWorkingMOG);
    builder.add_numCOG(args.numCOG);
    builder.add_operatingMOG(args.operatingMOG);
    builder.add_mxMOG(args.mxMOG);
    if let Some(x) = args.fuelQtys { builder.add_fuelQtys(x); }
    if let Some(x) = args.fuelTypes { builder.add_fuelTypes(x); }
    builder.add_fuelMOG(args.fuelMOG);
    builder.add_cargoMOG(args.cargoMOG);
    builder.add_fleetServiceMOG(args.fleetServiceMOG);
    builder.add_passengerServiceMOG(args.passengerServiceMOG);
    if let Some(x) = args.altAirfieldId { builder.add_altAirfieldId(x); }
    if let Some(x) = args.idAirfield { builder.add_idAirfield(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> AirfieldStatus_IngestT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idAirfield = self.idAirfield().map(|x| {
      x.to_string()
    });
    let altAirfieldId = self.altAirfieldId().map(|x| {
      x.to_string()
    });
    let passengerServiceMOG = self.passengerServiceMOG();
    let fleetServiceMOG = self.fleetServiceMOG();
    let cargoMOG = self.cargoMOG();
    let fuelMOG = self.fuelMOG();
    let fuelTypes = self.fuelTypes().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let fuelQtys = self.fuelQtys().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let mxMOG = self.mxMOG();
    let operatingMOG = self.operatingMOG();
    let numCOG = self.numCOG();
    let wideWorkingMOG = self.wideWorkingMOG();
    let wideParkingMOG = self.wideParkingMOG();
    let narrowWorkingMOG = self.narrowWorkingMOG();
    let narrowParkingMOG = self.narrowParkingMOG();
    let mheTypes = self.mheTypes().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let mheQtys = self.mheQtys().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let medCap = self.medCap().map(|x| {
      x.to_string()
    });
    let arffCat = self.arffCat().map(|x| {
      x.to_string()
    });
    let gseTime = self.gseTime();
    let priRwyNum = self.priRwyNum().map(|x| {
      x.to_string()
    });
    let rwyCondReading = self.rwyCondReading();
    let rwyFrictionFactor = self.rwyFrictionFactor();
    let rwyMarkings = self.rwyMarkings().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let message = self.message().map(|x| {
      x.to_string()
    });
    let priFreq = self.priFreq();
    let slotTypesReq = self.slotTypesReq().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    AirfieldStatus_IngestT {
      id,
      classificationMarking,
      idAirfield,
      altAirfieldId,
      passengerServiceMOG,
      fleetServiceMOG,
      cargoMOG,
      fuelMOG,
      fuelTypes,
      fuelQtys,
      mxMOG,
      operatingMOG,
      numCOG,
      wideWorkingMOG,
      wideParkingMOG,
      narrowWorkingMOG,
      narrowParkingMOG,
      mheTypes,
      mheQtys,
      medCap,
      arffCat,
      gseTime,
      priRwyNum,
      rwyCondReading,
      rwyFrictionFactor,
      rwyMarkings,
      message,
      priFreq,
      slotTypesReq,
      createdAt,
      createdBy,
      sourceDL,
      source,
      origin,
      origNetwork,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: be831d39-1822-da9f-7ace-6cc5643397dc
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the Airfield for which this status is referencing.
  /// Example: /// Example: 3136498f-2969-3535-1432-e984b2e2e686
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn idAirfield(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_IDAIRFIELD, None)}
  }
  /// Alternate airfield identifier provided by the source.
  /// Example: /// Example: AIRFIELD-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn altAirfieldId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_ALTAIRFIELDID, None)}
  }
  /// Maximum on ground (MOG) number of high-reach/wide-body passenger aircraft that can be serviced simultaneously based on spacing and manpower at the time of status.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn passengerServiceMOG(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_PASSENGERSERVICEMOG, Some(0)).unwrap()}
  }
  /// Maximum on ground (MOG) number of fleet aircraft that can be serviced simultaneously based on spacing and manpower at the time of status.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fleetServiceMOG(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_FLEETSERVICEMOG, Some(0)).unwrap()}
  }
  /// Maximum on ground (MOG) number of high-reach/wide-body cargo aircraft that can be serviced simultaneously based on spacing and manpower at the time of status.
  /// Example: /// Example: 8
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cargoMOG(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_CARGOMOG, Some(0)).unwrap()}
  }
  /// Maximum on ground (MOG) number of aircraft that can be simultaneously refueled based on spacing and manpower at the time of status.
  /// Example: /// Example: 9
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fuelMOG(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_FUELMOG, Some(0)).unwrap()}
  }
  /// Array of fuel types available at the airfield. This array must be the same length as fuelQtys.
  /// Example: /// Example: ['JP-8', 'Jet A', 'AVGAS']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fuelTypes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirfieldStatus_Ingest::VT_FUELTYPES, None)}
  }
  /// Array of quantities for each fuel type at the airfield, in kilograms. The values in this array must correspond to the position index in fuelTypes. This array must be the same length as fuelTypes.
  /// Example: /// Example: [263083.6, 286674.9, 18143.69]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fuelQtys(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirfieldStatus_Ingest::VT_FUELQTYS, None)}
  }
  /// Maximum on ground (MOG) number of aircraft that can be simultaneously ground handled for standard maintenance based on spacing and manpower at the time of status.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mxMOG(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_MXMOG, Some(0)).unwrap()}
  }
  /// Maximum on ground (MOG) number of aircraft due to items not directly related to the airfield infrastructure or aircraft servicing capability based on spacing and manpower at the time of status.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn operatingMOG(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_OPERATINGMOG, Some(0)).unwrap()}
  }
  /// The number of aircraft that are currently on ground (COG) at the airfield.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numCOG(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_NUMCOG, Some(0)).unwrap()}
  }
  /// Maximum on ground (MOG) number of working wide-body aircraft based on spacing and manpower at the time of status.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn wideWorkingMOG(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_WIDEWORKINGMOG, Some(0)).unwrap()}
  }
  /// Maximum on ground (MOG) number of parking wide-body aircraft based on spacing and manpower at the time of status.
  /// Example: /// Example: 7
  /// Constraints: No constraints specified.
  #[inline]
  pub fn wideParkingMOG(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_WIDEPARKINGMOG, Some(0)).unwrap()}
  }
  /// Maximum on ground (MOG) number of working narrow-body aircraft based on spacing and manpower at the time of status.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn narrowWorkingMOG(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_NARROWWORKINGMOG, Some(0)).unwrap()}
  }
  /// Maximum on ground (MOG) number of parking narrow-body aircraft based on spacing and manpower at the time of status.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn narrowParkingMOG(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_NARROWPARKINGMOG, Some(0)).unwrap()}
  }
  /// Array of material handling equipment types at the airfield. This array must be the same length as mheQtys.
  /// Example: /// Example: ['30k', 'AT', '60k']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mheTypes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirfieldStatus_Ingest::VT_MHETYPES, None)}
  }
  /// Array of quantities for each material handling equipment types at the airfield. The values in this array must correspond to the position index in mheTypes. This array must be the same length as mheTypes.
  /// Example: /// Example: [1, 3, 1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mheQtys(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirfieldStatus_Ingest::VT_MHEQTYS, None)}
  }
  /// The level of medical support and capabilities available at the airfield.
  /// Example: /// Example: Large Field Hospital
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn medCap(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_MEDCAP, None)}
  }
  /// The category of aircraft rescue and fire fighting (ARFF) services that are currently available at the airfield. Entries should include  the code (FAA or ICAO) and the category.
  /// Example: /// Example: FAA-A
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn arffCat(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_ARFFCAT, None)}
  }
  /// The expected time to receive ground support equipment (e.g. power units, air units, cables, hoses, etc.), in minutes.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gseTime(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_GSETIME, Some(0)).unwrap()}
  }
  /// The number or ID of primary runway at the airfield.
  /// Example: /// Example: 35R
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn priRwyNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_PRIRWYNUM, None)}
  }
  /// The primary runway condition reading value used for determining runway braking action, from 0 to 26. A value of 0 indicates braking action is poor or non-existent, where a value of 26 indicates braking action is good.
  /// Example: /// Example: 23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rwyCondReading(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_RWYCONDREADING, Some(0)).unwrap()}
  }
  /// The primary runway friction factor which is dependent on the surface friction between the tires of the aircraft and the runway surface, from 0 to 100. A lower number indicates less friction and less braking response.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rwyFrictionFactor(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AirfieldStatus_Ingest::VT_RWYFRICTIONFACTOR, Some(0)).unwrap()}
  }
  /// Array of markings currently on the primary runway.
  /// Example: /// Example: ['Aiming Point', 'Threshold']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rwyMarkings(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirfieldStatus_Ingest::VT_RWYMARKINGS, None)}
  }
  /// Description of the current status of the airfield.
  /// Example: /// Example: Status message about the airfield.
  /// Constraints: Minimum length = 0, Maximum length = 1024
  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_MESSAGE, None)}
  }
  /// The primary frequency which the airfield is currently operating, in megahertz.
  /// Example: /// Example: 123.45
  /// Constraints: No constraints specified.
  #[inline]
  pub fn priFreq(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AirfieldStatus_Ingest::VT_PRIFREQ, Some(0.0)).unwrap()}
  }
  /// Array of slot types that an airfield requires a particular aircraft provide in order to consume a slot at this location.
  /// Example: /// Example: ['PARKING', 'WORKING', 'LANDING']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn slotTypesReq(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AirfieldStatus_Ingest::VT_SLOTTYPESREQ, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_CREATEDBY, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_SOURCEDL, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AirfieldStatus_Ingest::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> AirfieldStatus_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AirfieldStatus_Ingest_dataMode_Enum>(AirfieldStatus_Ingest::VT_DATAMODE, Some(AirfieldStatus_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AirfieldStatus_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idAirfield", Self::VT_IDAIRFIELD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altAirfieldId", Self::VT_ALTAIRFIELDID, false)?
     .visit_field::<i32>("passengerServiceMOG", Self::VT_PASSENGERSERVICEMOG, false)?
     .visit_field::<i32>("fleetServiceMOG", Self::VT_FLEETSERVICEMOG, false)?
     .visit_field::<i32>("cargoMOG", Self::VT_CARGOMOG, false)?
     .visit_field::<i32>("fuelMOG", Self::VT_FUELMOG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("fuelTypes", Self::VT_FUELTYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("fuelQtys", Self::VT_FUELQTYS, false)?
     .visit_field::<i32>("mxMOG", Self::VT_MXMOG, false)?
     .visit_field::<i32>("operatingMOG", Self::VT_OPERATINGMOG, false)?
     .visit_field::<i32>("numCOG", Self::VT_NUMCOG, false)?
     .visit_field::<i32>("wideWorkingMOG", Self::VT_WIDEWORKINGMOG, false)?
     .visit_field::<i32>("wideParkingMOG", Self::VT_WIDEPARKINGMOG, false)?
     .visit_field::<i32>("narrowWorkingMOG", Self::VT_NARROWWORKINGMOG, false)?
     .visit_field::<i32>("narrowParkingMOG", Self::VT_NARROWPARKINGMOG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("mheTypes", Self::VT_MHETYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("mheQtys", Self::VT_MHEQTYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("medCap", Self::VT_MEDCAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("arffCat", Self::VT_ARFFCAT, false)?
     .visit_field::<i32>("gseTime", Self::VT_GSETIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("priRwyNum", Self::VT_PRIRWYNUM, false)?
     .visit_field::<i32>("rwyCondReading", Self::VT_RWYCONDREADING, false)?
     .visit_field::<i32>("rwyFrictionFactor", Self::VT_RWYFRICTIONFACTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("rwyMarkings", Self::VT_RWYMARKINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .visit_field::<f64>("priFreq", Self::VT_PRIFREQ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("slotTypesReq", Self::VT_SLOTTYPESREQ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<AirfieldStatus_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct AirfieldStatus_IngestArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idAirfield: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altAirfieldId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub passengerServiceMOG: i32,
    pub fleetServiceMOG: i32,
    pub cargoMOG: i32,
    pub fuelMOG: i32,
    pub fuelTypes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub fuelQtys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub mxMOG: i32,
    pub operatingMOG: i32,
    pub numCOG: i32,
    pub wideWorkingMOG: i32,
    pub wideParkingMOG: i32,
    pub narrowWorkingMOG: i32,
    pub narrowParkingMOG: i32,
    pub mheTypes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub mheQtys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub medCap: Option<flatbuffers::WIPOffset<&'a str>>,
    pub arffCat: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gseTime: i32,
    pub priRwyNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rwyCondReading: i32,
    pub rwyFrictionFactor: i32,
    pub rwyMarkings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
    pub priFreq: f64,
    pub slotTypesReq: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: AirfieldStatus_Ingest_dataMode_Enum,
}
impl<'a> Default for AirfieldStatus_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    AirfieldStatus_IngestArgs {
      id: None,
      classificationMarking: None,
      idAirfield: None,
      altAirfieldId: None,
      passengerServiceMOG: 0,
      fleetServiceMOG: 0,
      cargoMOG: 0,
      fuelMOG: 0,
      fuelTypes: None,
      fuelQtys: None,
      mxMOG: 0,
      operatingMOG: 0,
      numCOG: 0,
      wideWorkingMOG: 0,
      wideParkingMOG: 0,
      narrowWorkingMOG: 0,
      narrowParkingMOG: 0,
      mheTypes: None,
      mheQtys: None,
      medCap: None,
      arffCat: None,
      gseTime: 0,
      priRwyNum: None,
      rwyCondReading: 0,
      rwyFrictionFactor: 0,
      rwyMarkings: None,
      message: None,
      priFreq: 0.0,
      slotTypesReq: None,
      createdAt: None,
      createdBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: AirfieldStatus_Ingest_dataMode_Enum::REAL,
    }
  }
}

pub struct AirfieldStatus_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AirfieldStatus_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idAirfield(&mut self, idAirfield: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_IDAIRFIELD, idAirfield);
  }
  #[inline]
  pub fn add_altAirfieldId(&mut self, altAirfieldId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_ALTAIRFIELDID, altAirfieldId);
  }
  #[inline]
  pub fn add_passengerServiceMOG(&mut self, passengerServiceMOG: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_PASSENGERSERVICEMOG, passengerServiceMOG, 0);
  }
  #[inline]
  pub fn add_fleetServiceMOG(&mut self, fleetServiceMOG: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_FLEETSERVICEMOG, fleetServiceMOG, 0);
  }
  #[inline]
  pub fn add_cargoMOG(&mut self, cargoMOG: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_CARGOMOG, cargoMOG, 0);
  }
  #[inline]
  pub fn add_fuelMOG(&mut self, fuelMOG: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_FUELMOG, fuelMOG, 0);
  }
  #[inline]
  pub fn add_fuelTypes(&mut self, fuelTypes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_FUELTYPES, fuelTypes);
  }
  #[inline]
  pub fn add_fuelQtys(&mut self, fuelQtys: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_FUELQTYS, fuelQtys);
  }
  #[inline]
  pub fn add_mxMOG(&mut self, mxMOG: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_MXMOG, mxMOG, 0);
  }
  #[inline]
  pub fn add_operatingMOG(&mut self, operatingMOG: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_OPERATINGMOG, operatingMOG, 0);
  }
  #[inline]
  pub fn add_numCOG(&mut self, numCOG: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_NUMCOG, numCOG, 0);
  }
  #[inline]
  pub fn add_wideWorkingMOG(&mut self, wideWorkingMOG: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_WIDEWORKINGMOG, wideWorkingMOG, 0);
  }
  #[inline]
  pub fn add_wideParkingMOG(&mut self, wideParkingMOG: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_WIDEPARKINGMOG, wideParkingMOG, 0);
  }
  #[inline]
  pub fn add_narrowWorkingMOG(&mut self, narrowWorkingMOG: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_NARROWWORKINGMOG, narrowWorkingMOG, 0);
  }
  #[inline]
  pub fn add_narrowParkingMOG(&mut self, narrowParkingMOG: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_NARROWPARKINGMOG, narrowParkingMOG, 0);
  }
  #[inline]
  pub fn add_mheTypes(&mut self, mheTypes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_MHETYPES, mheTypes);
  }
  #[inline]
  pub fn add_mheQtys(&mut self, mheQtys: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_MHEQTYS, mheQtys);
  }
  #[inline]
  pub fn add_medCap(&mut self, medCap: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_MEDCAP, medCap);
  }
  #[inline]
  pub fn add_arffCat(&mut self, arffCat: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_ARFFCAT, arffCat);
  }
  #[inline]
  pub fn add_gseTime(&mut self, gseTime: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_GSETIME, gseTime, 0);
  }
  #[inline]
  pub fn add_priRwyNum(&mut self, priRwyNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_PRIRWYNUM, priRwyNum);
  }
  #[inline]
  pub fn add_rwyCondReading(&mut self, rwyCondReading: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_RWYCONDREADING, rwyCondReading, 0);
  }
  #[inline]
  pub fn add_rwyFrictionFactor(&mut self, rwyFrictionFactor: i32) {
    self.fbb_.push_slot::<i32>(AirfieldStatus_Ingest::VT_RWYFRICTIONFACTOR, rwyFrictionFactor, 0);
  }
  #[inline]
  pub fn add_rwyMarkings(&mut self, rwyMarkings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_RWYMARKINGS, rwyMarkings);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_MESSAGE, message);
  }
  #[inline]
  pub fn add_priFreq(&mut self, priFreq: f64) {
    self.fbb_.push_slot::<f64>(AirfieldStatus_Ingest::VT_PRIFREQ, priFreq, 0.0);
  }
  #[inline]
  pub fn add_slotTypesReq(&mut self, slotTypesReq: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_SLOTTYPESREQ, slotTypesReq);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AirfieldStatus_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: AirfieldStatus_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<AirfieldStatus_Ingest_dataMode_Enum>(AirfieldStatus_Ingest::VT_DATAMODE, dataMode, AirfieldStatus_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AirfieldStatus_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AirfieldStatus_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AirfieldStatus_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AirfieldStatus_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AirfieldStatus_Ingest");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idAirfield", &self.idAirfield());
      ds.field("altAirfieldId", &self.altAirfieldId());
      ds.field("passengerServiceMOG", &self.passengerServiceMOG());
      ds.field("fleetServiceMOG", &self.fleetServiceMOG());
      ds.field("cargoMOG", &self.cargoMOG());
      ds.field("fuelMOG", &self.fuelMOG());
      ds.field("fuelTypes", &self.fuelTypes());
      ds.field("fuelQtys", &self.fuelQtys());
      ds.field("mxMOG", &self.mxMOG());
      ds.field("operatingMOG", &self.operatingMOG());
      ds.field("numCOG", &self.numCOG());
      ds.field("wideWorkingMOG", &self.wideWorkingMOG());
      ds.field("wideParkingMOG", &self.wideParkingMOG());
      ds.field("narrowWorkingMOG", &self.narrowWorkingMOG());
      ds.field("narrowParkingMOG", &self.narrowParkingMOG());
      ds.field("mheTypes", &self.mheTypes());
      ds.field("mheQtys", &self.mheQtys());
      ds.field("medCap", &self.medCap());
      ds.field("arffCat", &self.arffCat());
      ds.field("gseTime", &self.gseTime());
      ds.field("priRwyNum", &self.priRwyNum());
      ds.field("rwyCondReading", &self.rwyCondReading());
      ds.field("rwyFrictionFactor", &self.rwyFrictionFactor());
      ds.field("rwyMarkings", &self.rwyMarkings());
      ds.field("message", &self.message());
      ds.field("priFreq", &self.priFreq());
      ds.field("slotTypesReq", &self.slotTypesReq());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("sourceDL", &self.sourceDL());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AirfieldStatus_IngestT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idAirfield: Option<String>,
  pub altAirfieldId: Option<String>,
  pub passengerServiceMOG: i32,
  pub fleetServiceMOG: i32,
  pub cargoMOG: i32,
  pub fuelMOG: i32,
  pub fuelTypes: Option<Vec<String>>,
  pub fuelQtys: Option<Vec<String>>,
  pub mxMOG: i32,
  pub operatingMOG: i32,
  pub numCOG: i32,
  pub wideWorkingMOG: i32,
  pub wideParkingMOG: i32,
  pub narrowWorkingMOG: i32,
  pub narrowParkingMOG: i32,
  pub mheTypes: Option<Vec<String>>,
  pub mheQtys: Option<Vec<String>>,
  pub medCap: Option<String>,
  pub arffCat: Option<String>,
  pub gseTime: i32,
  pub priRwyNum: Option<String>,
  pub rwyCondReading: i32,
  pub rwyFrictionFactor: i32,
  pub rwyMarkings: Option<Vec<String>>,
  pub message: Option<String>,
  pub priFreq: f64,
  pub slotTypesReq: Option<Vec<String>>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub sourceDL: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: AirfieldStatus_Ingest_dataMode_Enum,
}
impl Default for AirfieldStatus_IngestT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idAirfield: None,
      altAirfieldId: None,
      passengerServiceMOG: 0,
      fleetServiceMOG: 0,
      cargoMOG: 0,
      fuelMOG: 0,
      fuelTypes: None,
      fuelQtys: None,
      mxMOG: 0,
      operatingMOG: 0,
      numCOG: 0,
      wideWorkingMOG: 0,
      wideParkingMOG: 0,
      narrowWorkingMOG: 0,
      narrowParkingMOG: 0,
      mheTypes: None,
      mheQtys: None,
      medCap: None,
      arffCat: None,
      gseTime: 0,
      priRwyNum: None,
      rwyCondReading: 0,
      rwyFrictionFactor: 0,
      rwyMarkings: None,
      message: None,
      priFreq: 0.0,
      slotTypesReq: None,
      createdAt: None,
      createdBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: AirfieldStatus_Ingest_dataMode_Enum::REAL,
    }
  }
}
impl AirfieldStatus_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AirfieldStatus_Ingest<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idAirfield = self.idAirfield.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altAirfieldId = self.altAirfieldId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let passengerServiceMOG = self.passengerServiceMOG;
    let fleetServiceMOG = self.fleetServiceMOG;
    let cargoMOG = self.cargoMOG;
    let fuelMOG = self.fuelMOG;
    let fuelTypes = self.fuelTypes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let fuelQtys = self.fuelQtys.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let mxMOG = self.mxMOG;
    let operatingMOG = self.operatingMOG;
    let numCOG = self.numCOG;
    let wideWorkingMOG = self.wideWorkingMOG;
    let wideParkingMOG = self.wideParkingMOG;
    let narrowWorkingMOG = self.narrowWorkingMOG;
    let narrowParkingMOG = self.narrowParkingMOG;
    let mheTypes = self.mheTypes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let mheQtys = self.mheQtys.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let medCap = self.medCap.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let arffCat = self.arffCat.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let gseTime = self.gseTime;
    let priRwyNum = self.priRwyNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rwyCondReading = self.rwyCondReading;
    let rwyFrictionFactor = self.rwyFrictionFactor;
    let rwyMarkings = self.rwyMarkings.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let message = self.message.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let priFreq = self.priFreq;
    let slotTypesReq = self.slotTypesReq.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    AirfieldStatus_Ingest::create(_fbb, &AirfieldStatus_IngestArgs{
      id,
      classificationMarking,
      idAirfield,
      altAirfieldId,
      passengerServiceMOG,
      fleetServiceMOG,
      cargoMOG,
      fuelMOG,
      fuelTypes,
      fuelQtys,
      mxMOG,
      operatingMOG,
      numCOG,
      wideWorkingMOG,
      wideParkingMOG,
      narrowWorkingMOG,
      narrowParkingMOG,
      mheTypes,
      mheQtys,
      medCap,
      arffCat,
      gseTime,
      priRwyNum,
      rwyCondReading,
      rwyFrictionFactor,
      rwyMarkings,
      message,
      priFreq,
      slotTypesReq,
      createdAt,
      createdBy,
      sourceDL,
      source,
      origin,
      origNetwork,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AirfieldStatus_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airfield_status_ingest_unchecked`.
pub fn root_as_airfield_status_ingest(buf: &[u8]) -> Result<AirfieldStatus_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AirfieldStatus_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AirfieldStatus_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_airfield_status_ingest_unchecked`.
pub fn size_prefixed_root_as_airfield_status_ingest(buf: &[u8]) -> Result<AirfieldStatus_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AirfieldStatus_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AirfieldStatus_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airfield_status_ingest_unchecked`.
pub fn root_as_airfield_status_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirfieldStatus_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AirfieldStatus_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AirfieldStatus_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_airfield_status_ingest_unchecked`.
pub fn size_prefixed_root_as_airfield_status_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AirfieldStatus_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AirfieldStatus_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AirfieldStatus_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AirfieldStatus_Ingest`.
pub unsafe fn root_as_airfield_status_ingest_unchecked(buf: &[u8]) -> AirfieldStatus_Ingest {
  flatbuffers::root_unchecked::<AirfieldStatus_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AirfieldStatus_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AirfieldStatus_Ingest`.
pub unsafe fn size_prefixed_root_as_airfield_status_ingest_unchecked(buf: &[u8]) -> AirfieldStatus_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<AirfieldStatus_Ingest>(buf)
}
pub const AIRFIELD_STATUS_INGEST_IDENTIFIER: &str = "AIRF";

#[inline]
pub fn airfield_status_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRFIELD_STATUS_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn airfield_status_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRFIELD_STATUS_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_airfield_status_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AirfieldStatus_Ingest<'a>>) {
  fbb.finish(root, Some(AIRFIELD_STATUS_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_airfield_status_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AirfieldStatus_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(AIRFIELD_STATUS_INGEST_IDENTIFIER));
}
