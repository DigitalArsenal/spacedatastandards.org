// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum ISRCollectionPOC_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Information about the Point of Contact (POC) for this ISR Collection.
pub struct ISRCollectionPOC_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ISRCollectionPOC_Abridged<'a> {
  type Inner = ISRCollectionPOC_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ISRCollectionPOC_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_CALLSIGN: flatbuffers::VOffsetT = 8;
  pub const VT_UNIT: flatbuffers::VOffsetT = 10;
  pub const VT_EMAIL: flatbuffers::VOffsetT = 12;
  pub const VT_PHONE: flatbuffers::VOffsetT = 14;
  pub const VT_RADIOFREQUENCY: flatbuffers::VOffsetT = 16;
  pub const VT_CHATSYSTEM: flatbuffers::VOffsetT = 18;
  pub const VT_CHATNAME: flatbuffers::VOffsetT = 20;
  pub const VT_NOTES: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ISRCollectionPOC_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ISRCollectionPOC_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<ISRCollectionPOC_Abridged<'bldr>> {
    let mut builder = ISRCollectionPOC_AbridgedBuilder::new(_fbb);
    builder.add_radioFrequency(args.radioFrequency);
    if let Some(x) = args.notes { builder.add_notes(x); }
    if let Some(x) = args.chatName { builder.add_chatName(x); }
    if let Some(x) = args.chatSystem { builder.add_chatSystem(x); }
    if let Some(x) = args.phone { builder.add_phone(x); }
    if let Some(x) = args.email { builder.add_email(x); }
    if let Some(x) = args.unit { builder.add_unit(x); }
    if let Some(x) = args.callsign { builder.add_callsign(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ISRCollectionPOC_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let name = self.name().map(|x| {
      x.to_string()
    });
    let callsign = self.callsign().map(|x| {
      x.to_string()
    });
    let unit = self.unit().map(|x| {
      x.to_string()
    });
    let email = self.email().map(|x| {
      x.to_string()
    });
    let phone = self.phone().map(|x| {
      x.to_string()
    });
    let radioFrequency = self.radioFrequency();
    let chatSystem = self.chatSystem().map(|x| {
      x.to_string()
    });
    let chatName = self.chatName().map(|x| {
      x.to_string()
    });
    let notes = self.notes().map(|x| {
      x.to_string()
    });
    ISRCollectionPOC_AbridgedT {
      id,
      name,
      callsign,
      unit,
      email,
      phone,
      radioFrequency,
      chatSystem,
      chatName,
      notes,
    }
  }

  /// Unique identifier of the collection requirement POC.
  /// Example: /// Example: ISRCOLLECTIONPOC-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionPOC_Abridged::VT_ID, None)}
  }
  /// Name of the POC.
  /// Example: /// Example: NAME
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionPOC_Abridged::VT_NAME, None)}
  }
  /// Callsign of the POC.
  /// Example: /// Example: CALLSIGN
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn callsign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionPOC_Abridged::VT_CALLSIGN, None)}
  }
  /// Unit the POC belongs to.
  /// Example: /// Example: UNIT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn unit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionPOC_Abridged::VT_UNIT, None)}
  }
  /// Email address of the POC.
  /// Example: /// Example: EMAIL
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn email(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionPOC_Abridged::VT_EMAIL, None)}
  }
  /// Phone number of the POC.
  /// Example: /// Example: PHONE
  /// Constraints: Minimum length = 0, Maximum length = 45
  #[inline]
  pub fn phone(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionPOC_Abridged::VT_PHONE, None)}
  }
  /// Radio Frequency the POC is on.
  /// Example: /// Example: 123.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn radioFrequency(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ISRCollectionPOC_Abridged::VT_RADIOFREQUENCY, Some(0.0)).unwrap()}
  }
  /// Chat system the POC is accessing.
  /// Example: /// Example: CHAT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn chatSystem(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionPOC_Abridged::VT_CHATSYSTEM, None)}
  }
  /// Chat name of the POC.
  /// Example: /// Example: CHAT_NAME
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn chatName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionPOC_Abridged::VT_CHATNAME, None)}
  }
  /// Amplifying notes about the POC.
  /// Example: /// Example: NOTES
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn notes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionPOC_Abridged::VT_NOTES, None)}
  }
}

impl flatbuffers::Verifiable for ISRCollectionPOC_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("callsign", Self::VT_CALLSIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unit", Self::VT_UNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("email", Self::VT_EMAIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("phone", Self::VT_PHONE, false)?
     .visit_field::<f64>("radioFrequency", Self::VT_RADIOFREQUENCY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("chatSystem", Self::VT_CHATSYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("chatName", Self::VT_CHATNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("notes", Self::VT_NOTES, false)?
     .finish();
    Ok(())
  }
}
pub struct ISRCollectionPOC_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub callsign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub email: Option<flatbuffers::WIPOffset<&'a str>>,
    pub phone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub radioFrequency: f64,
    pub chatSystem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chatName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub notes: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ISRCollectionPOC_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    ISRCollectionPOC_AbridgedArgs {
      id: None,
      name: None,
      callsign: None,
      unit: None,
      email: None,
      phone: None,
      radioFrequency: 0.0,
      chatSystem: None,
      chatName: None,
      notes: None,
    }
  }
}

pub struct ISRCollectionPOC_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ISRCollectionPOC_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionPOC_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionPOC_Abridged::VT_NAME, name);
  }
  #[inline]
  pub fn add_callsign(&mut self, callsign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionPOC_Abridged::VT_CALLSIGN, callsign);
  }
  #[inline]
  pub fn add_unit(&mut self, unit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionPOC_Abridged::VT_UNIT, unit);
  }
  #[inline]
  pub fn add_email(&mut self, email: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionPOC_Abridged::VT_EMAIL, email);
  }
  #[inline]
  pub fn add_phone(&mut self, phone: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionPOC_Abridged::VT_PHONE, phone);
  }
  #[inline]
  pub fn add_radioFrequency(&mut self, radioFrequency: f64) {
    self.fbb_.push_slot::<f64>(ISRCollectionPOC_Abridged::VT_RADIOFREQUENCY, radioFrequency, 0.0);
  }
  #[inline]
  pub fn add_chatSystem(&mut self, chatSystem: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionPOC_Abridged::VT_CHATSYSTEM, chatSystem);
  }
  #[inline]
  pub fn add_chatName(&mut self, chatName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionPOC_Abridged::VT_CHATNAME, chatName);
  }
  #[inline]
  pub fn add_notes(&mut self, notes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionPOC_Abridged::VT_NOTES, notes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ISRCollectionPOC_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ISRCollectionPOC_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ISRCollectionPOC_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ISRCollectionPOC_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ISRCollectionPOC_Abridged");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.field("callsign", &self.callsign());
      ds.field("unit", &self.unit());
      ds.field("email", &self.email());
      ds.field("phone", &self.phone());
      ds.field("radioFrequency", &self.radioFrequency());
      ds.field("chatSystem", &self.chatSystem());
      ds.field("chatName", &self.chatName());
      ds.field("notes", &self.notes());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ISRCollectionPOC_AbridgedT {
  pub id: Option<String>,
  pub name: Option<String>,
  pub callsign: Option<String>,
  pub unit: Option<String>,
  pub email: Option<String>,
  pub phone: Option<String>,
  pub radioFrequency: f64,
  pub chatSystem: Option<String>,
  pub chatName: Option<String>,
  pub notes: Option<String>,
}
impl Default for ISRCollectionPOC_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      name: None,
      callsign: None,
      unit: None,
      email: None,
      phone: None,
      radioFrequency: 0.0,
      chatSystem: None,
      chatName: None,
      notes: None,
    }
  }
}
impl ISRCollectionPOC_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ISRCollectionPOC_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let callsign = self.callsign.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let unit = self.unit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let email = self.email.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let phone = self.phone.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let radioFrequency = self.radioFrequency;
    let chatSystem = self.chatSystem.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let chatName = self.chatName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let notes = self.notes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ISRCollectionPOC_Abridged::create(_fbb, &ISRCollectionPOC_AbridgedArgs{
      id,
      name,
      callsign,
      unit,
      email,
      phone,
      radioFrequency,
      chatSystem,
      chatName,
      notes,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ISRCollectionPOC_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_isrcollection_poc_abridged_unchecked`.
pub fn root_as_isrcollection_poc_abridged(buf: &[u8]) -> Result<ISRCollectionPOC_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ISRCollectionPOC_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ISRCollectionPOC_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_isrcollection_poc_abridged_unchecked`.
pub fn size_prefixed_root_as_isrcollection_poc_abridged(buf: &[u8]) -> Result<ISRCollectionPOC_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ISRCollectionPOC_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ISRCollectionPOC_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_isrcollection_poc_abridged_unchecked`.
pub fn root_as_isrcollection_poc_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ISRCollectionPOC_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ISRCollectionPOC_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ISRCollectionPOC_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_isrcollection_poc_abridged_unchecked`.
pub fn size_prefixed_root_as_isrcollection_poc_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ISRCollectionPOC_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ISRCollectionPOC_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ISRCollectionPOC_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ISRCollectionPOC_Abridged`.
pub unsafe fn root_as_isrcollection_poc_abridged_unchecked(buf: &[u8]) -> ISRCollectionPOC_Abridged {
  flatbuffers::root_unchecked::<ISRCollectionPOC_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ISRCollectionPOC_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ISRCollectionPOC_Abridged`.
pub unsafe fn size_prefixed_root_as_isrcollection_poc_abridged_unchecked(buf: &[u8]) -> ISRCollectionPOC_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<ISRCollectionPOC_Abridged>(buf)
}
pub const ISRCOLLECTION_POC_ABRIDGED_IDENTIFIER: &str = "ISRC";

#[inline]
pub fn isrcollection_poc_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ISRCOLLECTION_POC_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn isrcollection_poc_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ISRCOLLECTION_POC_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_isrcollection_poc_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ISRCollectionPOC_Abridged<'a>>) {
  fbb.finish(root, Some(ISRCOLLECTION_POC_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_isrcollection_poc_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ISRCollectionPOC_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(ISRCOLLECTION_POC_ABRIDGED_IDENTIFIER));
}
