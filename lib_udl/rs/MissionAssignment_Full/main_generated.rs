// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MISSION_ASSIGNMENT_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MISSION_ASSIGNMENT_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MISSION_ASSIGNMENT_FULL_DATA_MODE_ENUM: [MissionAssignment_Full_dataMode_Enum; 4] = [
  MissionAssignment_Full_dataMode_Enum::REAL,
  MissionAssignment_Full_dataMode_Enum::TEST,
  MissionAssignment_Full_dataMode_Enum::SIMULATED,
  MissionAssignment_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MissionAssignment_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl MissionAssignment_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MissionAssignment_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MissionAssignment_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MissionAssignment_Full_dataMode_Enum {
    type Output = MissionAssignment_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MissionAssignment_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MissionAssignment_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MissionAssignment_Full_dataMode_Enum {}
pub enum MissionAssignment_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Platform mission assignment data.
pub struct MissionAssignment_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MissionAssignment_Full<'a> {
  type Inner = MissionAssignment_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MissionAssignment_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_TRKID: flatbuffers::VOffsetT = 8;
  pub const VT_TS: flatbuffers::VOffsetT = 10;
  pub const VT_MAD: flatbuffers::VOffsetT = 12;
  pub const VT_RC: flatbuffers::VOffsetT = 14;
  pub const VT_RR: flatbuffers::VOffsetT = 16;
  pub const VT_TNO: flatbuffers::VOffsetT = 18;
  pub const VT_TWENV: flatbuffers::VOffsetT = 20;
  pub const VT_LAT: flatbuffers::VOffsetT = 22;
  pub const VT_LON: flatbuffers::VOffsetT = 24;
  pub const VT_ORGINX: flatbuffers::VOffsetT = 26;
  pub const VT_ENV: flatbuffers::VOffsetT = 28;
  pub const VT_SZ: flatbuffers::VOffsetT = 30;
  pub const VT_INDEX: flatbuffers::VOffsetT = 32;
  pub const VT_C1ASSOCIATEDDMPIS: flatbuffers::VOffsetT = 34;
  pub const VT_C2SPC: flatbuffers::VOffsetT = 36;
  pub const VT_C2AIR: flatbuffers::VOffsetT = 38;
  pub const VT_C2SUR: flatbuffers::VOffsetT = 40;
  pub const VT_C2LND: flatbuffers::VOffsetT = 42;
  pub const VT_C2ID: flatbuffers::VOffsetT = 44;
  pub const VT_C2IDAMPLIFYINGDESCRIPTOR: flatbuffers::VOffsetT = 46;
  pub const VT_C2ALT: flatbuffers::VOffsetT = 48;
  pub const VT_C2CRS: flatbuffers::VOffsetT = 50;
  pub const VT_C2SPD: flatbuffers::VOffsetT = 52;
  pub const VT_C2SPECIALINTERESTINDICATOR: flatbuffers::VOffsetT = 54;
  pub const VT_C2EXERCISEINDICATOR: flatbuffers::VOffsetT = 56;
  pub const VT_C2EXERCISEMOF: flatbuffers::VOffsetT = 58;
  pub const VT_C3LAT: flatbuffers::VOffsetT = 60;
  pub const VT_C3LON: flatbuffers::VOffsetT = 62;
  pub const VT_C3ELV: flatbuffers::VOffsetT = 64;
  pub const VT_C3PTL: flatbuffers::VOffsetT = 66;
  pub const VT_C3PTNUM: flatbuffers::VOffsetT = 68;
  pub const VT_C4TGT: flatbuffers::VOffsetT = 70;
  pub const VT_C4DEF: flatbuffers::VOffsetT = 72;
  pub const VT_C4RUNIN: flatbuffers::VOffsetT = 74;
  pub const VT_C4EGRESS: flatbuffers::VOffsetT = 76;
  pub const VT_C4NUMBEROFSTORES: flatbuffers::VOffsetT = 78;
  pub const VT_C4TYPEOFSTORES: flatbuffers::VOffsetT = 80;
  pub const VT_C4TIMEDISCRETE: flatbuffers::VOffsetT = 82;
  pub const VT_C4TM: flatbuffers::VOffsetT = 84;
  pub const VT_C4COLON: flatbuffers::VOffsetT = 86;
  pub const VT_C4MOD: flatbuffers::VOffsetT = 88;
  pub const VT_C5HAEADJ: flatbuffers::VOffsetT = 90;
  pub const VT_C5TW: flatbuffers::VOffsetT = 92;
  pub const VT_C5TGTBRNG: flatbuffers::VOffsetT = 94;
  pub const VT_C5LATLSB: flatbuffers::VOffsetT = 96;
  pub const VT_C5LONLSB: flatbuffers::VOffsetT = 98;
  pub const VT_C5ELEVATIONLSBS: flatbuffers::VOffsetT = 100;
  pub const VT_C5COLON: flatbuffers::VOffsetT = 102;
  pub const VT_C6LASER: flatbuffers::VOffsetT = 104;
  pub const VT_C6INTEL: flatbuffers::VOffsetT = 106;
  pub const VT_C6TNR3: flatbuffers::VOffsetT = 108;
  pub const VT_C6DSPCT: flatbuffers::VOffsetT = 110;
  pub const VT_C6DSPC: flatbuffers::VOffsetT = 112;
  pub const VT_C6FPLPM: flatbuffers::VOffsetT = 114;
  pub const VT_C6LONGPM: flatbuffers::VOffsetT = 116;
  pub const VT_C7TNOR: flatbuffers::VOffsetT = 118;
  pub const VT_C7IN3P: flatbuffers::VOffsetT = 120;
  pub const VT_C7ELANG2: flatbuffers::VOffsetT = 122;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 124;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 126;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 128;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 130;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 132;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 134;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 136;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 138;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MissionAssignment_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MissionAssignment_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<MissionAssignment_Full<'bldr>> {
    let mut builder = MissionAssignment_FullBuilder::new(_fbb);
    builder.add_c7elang2(args.c7elang2);
    builder.add_c3elv(args.c3elv);
    builder.add_c3lon(args.c3lon);
    builder.add_c3lat(args.c3lat);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    builder.add_c7in3p(args.c7in3p);
    if let Some(x) = args.c7tnor { builder.add_c7tnor(x); }
    if let Some(x) = args.c6longpm { builder.add_c6longpm(x); }
    if let Some(x) = args.c6fplpm { builder.add_c6fplpm(x); }
    if let Some(x) = args.c6dspc { builder.add_c6dspc(x); }
    if let Some(x) = args.c6dspct { builder.add_c6dspct(x); }
    builder.add_c6tnr3(args.c6tnr3);
    builder.add_c6intel(args.c6intel);
    builder.add_c6laser(args.c6laser);
    builder.add_c5colon(args.c5colon);
    builder.add_c5elevationlsbs(args.c5elevationlsbs);
    builder.add_c5lonlsb(args.c5lonlsb);
    builder.add_c5latlsb(args.c5latlsb);
    builder.add_c5tgtbrng(args.c5tgtbrng);
    builder.add_c5tw(args.c5tw);
    builder.add_c5haeadj(args.c5haeadj);
    builder.add_c4mod(args.c4mod);
    builder.add_c4colon(args.c4colon);
    builder.add_c4tm(args.c4tm);
    if let Some(x) = args.c4timediscrete { builder.add_c4timediscrete(x); }
    builder.add_c4typeofstores(args.c4typeofstores);
    builder.add_c4numberofstores(args.c4numberofstores);
    builder.add_c4egress(args.c4egress);
    builder.add_c4runin(args.c4runin);
    if let Some(x) = args.c4def { builder.add_c4def(x); }
    if let Some(x) = args.c4tgt { builder.add_c4tgt(x); }
    if let Some(x) = args.c3ptnum { builder.add_c3ptnum(x); }
    if let Some(x) = args.c3ptl { builder.add_c3ptl(x); }
    if let Some(x) = args.c2exercisemof { builder.add_c2exercisemof(x); }
    if let Some(x) = args.c2exerciseindicator { builder.add_c2exerciseindicator(x); }
    if let Some(x) = args.c2specialinterestindicator { builder.add_c2specialinterestindicator(x); }
    builder.add_c2spd(args.c2spd);
    builder.add_c2crs(args.c2crs);
    builder.add_c2alt(args.c2alt);
    if let Some(x) = args.c2idamplifyingdescriptor { builder.add_c2idamplifyingdescriptor(x); }
    if let Some(x) = args.c2id { builder.add_c2id(x); }
    if let Some(x) = args.c2lnd { builder.add_c2lnd(x); }
    if let Some(x) = args.c2sur { builder.add_c2sur(x); }
    if let Some(x) = args.c2air { builder.add_c2air(x); }
    if let Some(x) = args.c2spc { builder.add_c2spc(x); }
    builder.add_c1associateddmpis(args.c1associateddmpis);
    builder.add_index(args.index);
    if let Some(x) = args.sz { builder.add_sz(x); }
    if let Some(x) = args.env { builder.add_env(x); }
    if let Some(x) = args.orginx { builder.add_orginx(x); }
    if let Some(x) = args.twenv { builder.add_twenv(x); }
    if let Some(x) = args.tno { builder.add_tno(x); }
    builder.add_rr(args.rr);
    if let Some(x) = args.rc { builder.add_rc(x); }
    if let Some(x) = args.mad { builder.add_mad(x); }
    if let Some(x) = args.ts { builder.add_ts(x); }
    if let Some(x) = args.trkId { builder.add_trkId(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> MissionAssignment_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let trkId = self.trkId().map(|x| {
      x.to_string()
    });
    let ts = self.ts().map(|x| {
      x.to_string()
    });
    let mad = self.mad().map(|x| {
      x.to_string()
    });
    let rc = self.rc().map(|x| {
      x.to_string()
    });
    let rr = self.rr();
    let tno = self.tno().map(|x| {
      x.to_string()
    });
    let twenv = self.twenv().map(|x| {
      x.to_string()
    });
    let lat = self.lat();
    let lon = self.lon();
    let orginx = self.orginx().map(|x| {
      x.to_string()
    });
    let env = self.env().map(|x| {
      x.to_string()
    });
    let sz = self.sz().map(|x| {
      x.to_string()
    });
    let index = self.index();
    let c1associateddmpis = self.c1associateddmpis();
    let c2spc = self.c2spc().map(|x| {
      x.to_string()
    });
    let c2air = self.c2air().map(|x| {
      x.to_string()
    });
    let c2sur = self.c2sur().map(|x| {
      x.to_string()
    });
    let c2lnd = self.c2lnd().map(|x| {
      x.to_string()
    });
    let c2id = self.c2id().map(|x| {
      x.to_string()
    });
    let c2idamplifyingdescriptor = self.c2idamplifyingdescriptor().map(|x| {
      x.to_string()
    });
    let c2alt = self.c2alt();
    let c2crs = self.c2crs();
    let c2spd = self.c2spd();
    let c2specialinterestindicator = self.c2specialinterestindicator().map(|x| {
      x.to_string()
    });
    let c2exerciseindicator = self.c2exerciseindicator().map(|x| {
      x.to_string()
    });
    let c2exercisemof = self.c2exercisemof().map(|x| {
      x.to_string()
    });
    let c3lat = self.c3lat();
    let c3lon = self.c3lon();
    let c3elv = self.c3elv();
    let c3ptl = self.c3ptl().map(|x| {
      x.to_string()
    });
    let c3ptnum = self.c3ptnum().map(|x| {
      x.to_string()
    });
    let c4tgt = self.c4tgt().map(|x| {
      x.to_string()
    });
    let c4def = self.c4def().map(|x| {
      x.to_string()
    });
    let c4runin = self.c4runin();
    let c4egress = self.c4egress();
    let c4numberofstores = self.c4numberofstores();
    let c4typeofstores = self.c4typeofstores();
    let c4timediscrete = self.c4timediscrete().map(|x| {
      x.to_string()
    });
    let c4tm = self.c4tm();
    let c4colon = self.c4colon();
    let c4mod = self.c4mod();
    let c5haeadj = self.c5haeadj();
    let c5tw = self.c5tw();
    let c5tgtbrng = self.c5tgtbrng();
    let c5latlsb = self.c5latlsb();
    let c5lonlsb = self.c5lonlsb();
    let c5elevationlsbs = self.c5elevationlsbs();
    let c5colon = self.c5colon();
    let c6laser = self.c6laser();
    let c6intel = self.c6intel();
    let c6tnr3 = self.c6tnr3();
    let c6dspct = self.c6dspct().map(|x| {
      x.to_string()
    });
    let c6dspc = self.c6dspc().map(|x| {
      x.to_string()
    });
    let c6fplpm = self.c6fplpm().map(|x| {
      x.to_string()
    });
    let c6longpm = self.c6longpm().map(|x| {
      x.to_string()
    });
    let c7tnor = self.c7tnor().map(|x| {
      x.to_string()
    });
    let c7in3p = self.c7in3p();
    let c7elang2 = self.c7elang2();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    MissionAssignment_FullT {
      id,
      classificationMarking,
      trkId,
      ts,
      mad,
      rc,
      rr,
      tno,
      twenv,
      lat,
      lon,
      orginx,
      env,
      sz,
      index,
      c1associateddmpis,
      c2spc,
      c2air,
      c2sur,
      c2lnd,
      c2id,
      c2idamplifyingdescriptor,
      c2alt,
      c2crs,
      c2spd,
      c2specialinterestindicator,
      c2exerciseindicator,
      c2exercisemof,
      c3lat,
      c3lon,
      c3elv,
      c3ptl,
      c3ptnum,
      c4tgt,
      c4def,
      c4runin,
      c4egress,
      c4numberofstores,
      c4typeofstores,
      c4timediscrete,
      c4tm,
      c4colon,
      c4mod,
      c5haeadj,
      c5tw,
      c5tgtbrng,
      c5latlsb,
      c5lonlsb,
      c5elevationlsbs,
      c5colon,
      c6laser,
      c6intel,
      c6tnr3,
      c6dspct,
      c6dspc,
      c6fplpm,
      c6longpm,
      c7tnor,
      c7in3p,
      c7elang2,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      dataMode,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: MISSIONASSIGNMENT-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// The track ID that the status is referencing, addressee.
  /// Example: /// Example: TRK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn trkId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_TRKID, None)}
  }
  /// The timestamp of the mission data, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ts(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_TS, None)}
  }
  /// The mission assignment discrete value.
  /// Example: /// Example: MAD
  /// Constraints: Minimum length = 1, Maximum length = 16
  #[inline]
  pub fn mad(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_MAD, None)}
  }
  /// Receipt/Compliance, values from TABLE B-9.
  /// Example: /// Example: RC-123
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn rc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_RC, None)}
  }
  /// Recurrence rate, receipt/compliance.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rr(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_RR, Some(0)).unwrap()}
  }
  /// Track number objective.
  /// Example: /// Example: TRACK_NUMBER
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tno(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_TNO, None)}
  }
  /// Threat warning environment.
  /// Example: /// Example: THREAT_WARNING
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn twenv(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_TWENV, None)}
  }
  /// WGS84 latitude, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissionAssignment_Full::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissionAssignment_Full::VT_LON, Some(0.0)).unwrap()}
  }
  /// Origin of index number.
  /// Example: /// Example: ORIGIN
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn orginx(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_ORGINX, None)}
  }
  /// Environment.
  /// Example: /// Example: ENV
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn env(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_ENV, None)}
  }
  /// Strength.
  /// Example: /// Example: STRENGTH
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn sz(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_SZ, None)}
  }
  /// Index number.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_INDEX, Some(0)).unwrap()}
  }
  /// TARGET POSITION CONTINUATION WORD - number of associated dmpis.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c1associateddmpis(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C1ASSOCIATEDDMPIS, Some(0)).unwrap()}
  }
  /// TARGET DATA CONTINUATION WORD - space specific type, see TABLE B-39.
  /// Example: /// Example: C2SPC
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c2spc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C2SPC, None)}
  }
  /// TARGET DATA CONTINUATION WORD - air specific type, see TABLE B-21.
  /// Example: /// Example: C2AIR
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c2air(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C2AIR, None)}
  }
  /// TARGET DATA CONTINUATION WORD - surface specific type, see TABLE B-21.
  /// Example: /// Example: C2SUR
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c2sur(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C2SUR, None)}
  }
  /// TARGET DATA CONTINUATION WORD - land specific type, see TABLE B-21.
  /// Example: /// Example: C2LND
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c2lnd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C2LND, None)}
  }
  /// TARGET DATA CONTINUATION WORD - identity.
  /// Example: /// Example: C2ID
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c2id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C2ID, None)}
  }
  /// TARGET DATA CONTINUATION WORD - identity amplifying descriptor.
  /// Example: /// Example: C2IDAMP
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c2idamplifyingdescriptor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C2IDAMPLIFYINGDESCRIPTOR, None)}
  }
  /// TARGET DATA CONTINUATION WORD - altitude, 100 FT, 2047=NS.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c2alt(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C2ALT, Some(0)).unwrap()}
  }
  /// TARGET DATA CONTINUATION WORD - course in increments of 1 degree.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c2crs(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C2CRS, Some(0)).unwrap()}
  }
  /// TARGET DATA CONTINUATION WORD - speed in 2 DM/HR, 2047=NS.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c2spd(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C2SPD, Some(0)).unwrap()}
  }
  /// TARGET DATA CONTINUATION WORD - special interest indicator.
  /// Example: /// Example: C2SPECIAL
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c2specialinterestindicator(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C2SPECIALINTERESTINDICATOR, None)}
  }
  /// TARGET DATA CONTINUATION WORD - exercise indicator.
  /// Example: /// Example: C2EXERCISE
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c2exerciseindicator(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C2EXERCISEINDICATOR, None)}
  }
  /// TARGET DATA CONTINUATION WORD - method of fire.
  /// Example: /// Example: MOF
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c2exercisemof(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C2EXERCISEMOF, None)}
  }
  /// POINT LOCATION CONTINUATION WORD - latitude, 0.0013 MINUTE.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c3lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissionAssignment_Full::VT_C3LAT, Some(0.0)).unwrap()}
  }
  /// POINT LOCATION CONTINUATION WORD - longitude, 0.0013 MINUTE.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c3lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissionAssignment_Full::VT_C3LON, Some(0.0)).unwrap()}
  }
  /// POINT LOCATION CONTINUATION WORD - elevation, 25 FT, 1023=NS.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c3elv(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissionAssignment_Full::VT_C3ELV, Some(0.0)).unwrap()}
  }
  /// TARGET DATA CONTINUATION WORD - point type 1.
  /// Example: /// Example: C3PTL
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c3ptl(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C3PTL, None)}
  }
  /// TARGET DATA CONTINUATION WORD - point number.
  /// Example: /// Example: C3PTNUM
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c3ptnum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C3PTNUM, None)}
  }
  /// SURFACE ATTACK CONTINUATION WORD - target type - see TABLE B-32.
  /// Example: /// Example: C4TGT
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c4tgt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C4TGT, None)}
  }
  /// SURFACE ATTACK CONTINUATION WORD - target defenses.
  /// Example: /// Example: C4DEF
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c4def(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C4DEF, None)}
  }
  /// SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c4runin(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C4RUNIN, Some(0)).unwrap()}
  }
  /// SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c4egress(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C4EGRESS, Some(0)).unwrap()}
  }
  /// SURFACE ATTACK CONTINUATION WORD - number of stores, NS=63.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c4numberofstores(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C4NUMBEROFSTORES, Some(0)).unwrap()}
  }
  /// SURFACE ATTACK CONTINUATION WORD - type of stores.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c4typeofstores(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C4TYPEOFSTORES, Some(0)).unwrap()}
  }
  /// SURFACE ATTACK CONTINUATION WORD - time discrete.
  /// Example: /// Example: C4TIMED
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c4timediscrete(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C4TIMEDISCRETE, None)}
  }
  /// SURFACE ATTACK CONTINUATION WORD - hour.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c4tm(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C4TM, Some(0)).unwrap()}
  }
  /// SURFACE ATTACK CONTINUATION WORD - minute.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c4colon(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C4COLON, Some(0)).unwrap()}
  }
  /// SURFACE ATTACK CONTINUATION WORD - mode of delivery.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c4mod(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C4MOD, Some(0)).unwrap()}
  }
  /// CONTINUATION WORD - hae adjustment, measured in 3.125 FT.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c5haeadj(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C5HAEADJ, Some(0)).unwrap()}
  }
  /// CONTINUATION WORD - time window.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c5tw(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C5TW, Some(0)).unwrap()}
  }
  /// CONTINUATION WORD - target bearing.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c5tgtbrng(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C5TGTBRNG, Some(0)).unwrap()}
  }
  /// CONTINUATION WORD - used with c3_lat to double precision to approx 4 ft.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c5latlsb(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C5LATLSB, Some(0)).unwrap()}
  }
  /// CONTINUATION WORD - used with c3_lon to double precision to approx 4 ft.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c5lonlsb(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C5LONLSB, Some(0)).unwrap()}
  }
  /// CONTINUATION WORD - used with c3_elv to double precision to approx 3 ft.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c5elevationlsbs(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C5ELEVATIONLSBS, Some(0)).unwrap()}
  }
  /// SURFACE ATTACK CONTINUATION WORD - seconds in increments of 1 sec.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c5colon(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C5COLON, Some(0)).unwrap()}
  }
  /// TARGETING CONTINUATION WORD - laser illuminator code.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c6laser(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C6LASER, Some(0)).unwrap()}
  }
  /// TARGETING CONTINUATION WORD - index number, related, 0=NS.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c6intel(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C6INTEL, Some(0)).unwrap()}
  }
  /// TARGETING CONTINUATION WORD - track number, related to 3.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c6tnr3(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C6TNR3, Some(0)).unwrap()}
  }
  /// TARGETING CONTINUATION WORD - designator/seeker pulse code type.
  /// Example: /// Example: C6DSPCT
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c6dspct(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C6DSPCT, None)}
  }
  /// TARGETING CONTINUATION WORD - designator/seeker pulse code.
  /// Example: /// Example: C6DSPC
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c6dspc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C6DSPC, None)}
  }
  /// TARGETING CONTINUATION WORD - first pulse/last pulse mode.
  /// Example: /// Example: C6FPLPM
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c6fplpm(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C6FPLPM, None)}
  }
  /// TARGETING CONTINUATION WORD - long pulse mode.
  /// Example: /// Example: C6LONGPM
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn c6longpm(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C6LONGPM, None)}
  }
  /// THIRD PARTY CONTINUATION WORD  - track number, index originator.
  /// Example: /// Example: C7TNOR
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c7tnor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_C7TNOR, None)}
  }
  /// THIRD PARTY CONTINUATION WORD  - index number, third party.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c7in3p(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissionAssignment_Full::VT_C7IN3P, Some(0)).unwrap()}
  }
  /// THIRD PARTY CONTINUATION WORD  - elevation angle, 2.
  /// Example: /// Example: 5.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn c7elang2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissionAssignment_Full::VT_C7ELANG2, Some(0.0)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_CREATEDBY, None)}
  }
  /// Time the row was updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_UPDATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> MissionAssignment_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MissionAssignment_Full_dataMode_Enum>(MissionAssignment_Full::VT_DATAMODE, Some(MissionAssignment_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissionAssignment_Full::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for MissionAssignment_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trkId", Self::VT_TRKID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ts", Self::VT_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mad", Self::VT_MAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rc", Self::VT_RC, false)?
     .visit_field::<i32>("rr", Self::VT_RR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tno", Self::VT_TNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("twenv", Self::VT_TWENV, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("orginx", Self::VT_ORGINX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("env", Self::VT_ENV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sz", Self::VT_SZ, false)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<i32>("c1associateddmpis", Self::VT_C1ASSOCIATEDDMPIS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c2spc", Self::VT_C2SPC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c2air", Self::VT_C2AIR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c2sur", Self::VT_C2SUR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c2lnd", Self::VT_C2LND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c2id", Self::VT_C2ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c2idamplifyingdescriptor", Self::VT_C2IDAMPLIFYINGDESCRIPTOR, false)?
     .visit_field::<i32>("c2alt", Self::VT_C2ALT, false)?
     .visit_field::<i32>("c2crs", Self::VT_C2CRS, false)?
     .visit_field::<i32>("c2spd", Self::VT_C2SPD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c2specialinterestindicator", Self::VT_C2SPECIALINTERESTINDICATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c2exerciseindicator", Self::VT_C2EXERCISEINDICATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c2exercisemof", Self::VT_C2EXERCISEMOF, false)?
     .visit_field::<f64>("c3lat", Self::VT_C3LAT, false)?
     .visit_field::<f64>("c3lon", Self::VT_C3LON, false)?
     .visit_field::<f64>("c3elv", Self::VT_C3ELV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c3ptl", Self::VT_C3PTL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c3ptnum", Self::VT_C3PTNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c4tgt", Self::VT_C4TGT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c4def", Self::VT_C4DEF, false)?
     .visit_field::<i32>("c4runin", Self::VT_C4RUNIN, false)?
     .visit_field::<i32>("c4egress", Self::VT_C4EGRESS, false)?
     .visit_field::<i32>("c4numberofstores", Self::VT_C4NUMBEROFSTORES, false)?
     .visit_field::<i32>("c4typeofstores", Self::VT_C4TYPEOFSTORES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c4timediscrete", Self::VT_C4TIMEDISCRETE, false)?
     .visit_field::<i32>("c4tm", Self::VT_C4TM, false)?
     .visit_field::<i32>("c4colon", Self::VT_C4COLON, false)?
     .visit_field::<i32>("c4mod", Self::VT_C4MOD, false)?
     .visit_field::<i32>("c5haeadj", Self::VT_C5HAEADJ, false)?
     .visit_field::<i32>("c5tw", Self::VT_C5TW, false)?
     .visit_field::<i32>("c5tgtbrng", Self::VT_C5TGTBRNG, false)?
     .visit_field::<i32>("c5latlsb", Self::VT_C5LATLSB, false)?
     .visit_field::<i32>("c5lonlsb", Self::VT_C5LONLSB, false)?
     .visit_field::<i32>("c5elevationlsbs", Self::VT_C5ELEVATIONLSBS, false)?
     .visit_field::<i32>("c5colon", Self::VT_C5COLON, false)?
     .visit_field::<i32>("c6laser", Self::VT_C6LASER, false)?
     .visit_field::<i32>("c6intel", Self::VT_C6INTEL, false)?
     .visit_field::<i32>("c6tnr3", Self::VT_C6TNR3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c6dspct", Self::VT_C6DSPCT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c6dspc", Self::VT_C6DSPC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c6fplpm", Self::VT_C6FPLPM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c6longpm", Self::VT_C6LONGPM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c7tnor", Self::VT_C7TNOR, false)?
     .visit_field::<i32>("c7in3p", Self::VT_C7IN3P, false)?
     .visit_field::<f64>("c7elang2", Self::VT_C7ELANG2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<MissionAssignment_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct MissionAssignment_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trkId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mad: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rr: i32,
    pub tno: Option<flatbuffers::WIPOffset<&'a str>>,
    pub twenv: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lat: f64,
    pub lon: f64,
    pub orginx: Option<flatbuffers::WIPOffset<&'a str>>,
    pub env: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sz: Option<flatbuffers::WIPOffset<&'a str>>,
    pub index: i32,
    pub c1associateddmpis: i32,
    pub c2spc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c2air: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c2sur: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c2lnd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c2id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c2idamplifyingdescriptor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c2alt: i32,
    pub c2crs: i32,
    pub c2spd: i32,
    pub c2specialinterestindicator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c2exerciseindicator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c2exercisemof: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c3lat: f64,
    pub c3lon: f64,
    pub c3elv: f64,
    pub c3ptl: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c3ptnum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c4tgt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c4def: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c4runin: i32,
    pub c4egress: i32,
    pub c4numberofstores: i32,
    pub c4typeofstores: i32,
    pub c4timediscrete: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c4tm: i32,
    pub c4colon: i32,
    pub c4mod: i32,
    pub c5haeadj: i32,
    pub c5tw: i32,
    pub c5tgtbrng: i32,
    pub c5latlsb: i32,
    pub c5lonlsb: i32,
    pub c5elevationlsbs: i32,
    pub c5colon: i32,
    pub c6laser: i32,
    pub c6intel: i32,
    pub c6tnr3: i32,
    pub c6dspct: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c6dspc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c6fplpm: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c6longpm: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c7tnor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c7in3p: i32,
    pub c7elang2: f64,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: MissionAssignment_Full_dataMode_Enum,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MissionAssignment_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    MissionAssignment_FullArgs {
      id: None,
      classificationMarking: None,
      trkId: None,
      ts: None,
      mad: None,
      rc: None,
      rr: 0,
      tno: None,
      twenv: None,
      lat: 0.0,
      lon: 0.0,
      orginx: None,
      env: None,
      sz: None,
      index: 0,
      c1associateddmpis: 0,
      c2spc: None,
      c2air: None,
      c2sur: None,
      c2lnd: None,
      c2id: None,
      c2idamplifyingdescriptor: None,
      c2alt: 0,
      c2crs: 0,
      c2spd: 0,
      c2specialinterestindicator: None,
      c2exerciseindicator: None,
      c2exercisemof: None,
      c3lat: 0.0,
      c3lon: 0.0,
      c3elv: 0.0,
      c3ptl: None,
      c3ptnum: None,
      c4tgt: None,
      c4def: None,
      c4runin: 0,
      c4egress: 0,
      c4numberofstores: 0,
      c4typeofstores: 0,
      c4timediscrete: None,
      c4tm: 0,
      c4colon: 0,
      c4mod: 0,
      c5haeadj: 0,
      c5tw: 0,
      c5tgtbrng: 0,
      c5latlsb: 0,
      c5lonlsb: 0,
      c5elevationlsbs: 0,
      c5colon: 0,
      c6laser: 0,
      c6intel: 0,
      c6tnr3: 0,
      c6dspct: None,
      c6dspc: None,
      c6fplpm: None,
      c6longpm: None,
      c7tnor: None,
      c7in3p: 0,
      c7elang2: 0.0,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      dataMode: MissionAssignment_Full_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}

pub struct MissionAssignment_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MissionAssignment_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_trkId(&mut self, trkId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_TRKID, trkId);
  }
  #[inline]
  pub fn add_ts(&mut self, ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_TS, ts);
  }
  #[inline]
  pub fn add_mad(&mut self, mad: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_MAD, mad);
  }
  #[inline]
  pub fn add_rc(&mut self, rc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_RC, rc);
  }
  #[inline]
  pub fn add_rr(&mut self, rr: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_RR, rr, 0);
  }
  #[inline]
  pub fn add_tno(&mut self, tno: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_TNO, tno);
  }
  #[inline]
  pub fn add_twenv(&mut self, twenv: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_TWENV, twenv);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(MissionAssignment_Full::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(MissionAssignment_Full::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_orginx(&mut self, orginx: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_ORGINX, orginx);
  }
  #[inline]
  pub fn add_env(&mut self, env: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_ENV, env);
  }
  #[inline]
  pub fn add_sz(&mut self, sz: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_SZ, sz);
  }
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_c1associateddmpis(&mut self, c1associateddmpis: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C1ASSOCIATEDDMPIS, c1associateddmpis, 0);
  }
  #[inline]
  pub fn add_c2spc(&mut self, c2spc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C2SPC, c2spc);
  }
  #[inline]
  pub fn add_c2air(&mut self, c2air: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C2AIR, c2air);
  }
  #[inline]
  pub fn add_c2sur(&mut self, c2sur: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C2SUR, c2sur);
  }
  #[inline]
  pub fn add_c2lnd(&mut self, c2lnd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C2LND, c2lnd);
  }
  #[inline]
  pub fn add_c2id(&mut self, c2id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C2ID, c2id);
  }
  #[inline]
  pub fn add_c2idamplifyingdescriptor(&mut self, c2idamplifyingdescriptor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C2IDAMPLIFYINGDESCRIPTOR, c2idamplifyingdescriptor);
  }
  #[inline]
  pub fn add_c2alt(&mut self, c2alt: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C2ALT, c2alt, 0);
  }
  #[inline]
  pub fn add_c2crs(&mut self, c2crs: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C2CRS, c2crs, 0);
  }
  #[inline]
  pub fn add_c2spd(&mut self, c2spd: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C2SPD, c2spd, 0);
  }
  #[inline]
  pub fn add_c2specialinterestindicator(&mut self, c2specialinterestindicator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C2SPECIALINTERESTINDICATOR, c2specialinterestindicator);
  }
  #[inline]
  pub fn add_c2exerciseindicator(&mut self, c2exerciseindicator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C2EXERCISEINDICATOR, c2exerciseindicator);
  }
  #[inline]
  pub fn add_c2exercisemof(&mut self, c2exercisemof: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C2EXERCISEMOF, c2exercisemof);
  }
  #[inline]
  pub fn add_c3lat(&mut self, c3lat: f64) {
    self.fbb_.push_slot::<f64>(MissionAssignment_Full::VT_C3LAT, c3lat, 0.0);
  }
  #[inline]
  pub fn add_c3lon(&mut self, c3lon: f64) {
    self.fbb_.push_slot::<f64>(MissionAssignment_Full::VT_C3LON, c3lon, 0.0);
  }
  #[inline]
  pub fn add_c3elv(&mut self, c3elv: f64) {
    self.fbb_.push_slot::<f64>(MissionAssignment_Full::VT_C3ELV, c3elv, 0.0);
  }
  #[inline]
  pub fn add_c3ptl(&mut self, c3ptl: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C3PTL, c3ptl);
  }
  #[inline]
  pub fn add_c3ptnum(&mut self, c3ptnum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C3PTNUM, c3ptnum);
  }
  #[inline]
  pub fn add_c4tgt(&mut self, c4tgt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C4TGT, c4tgt);
  }
  #[inline]
  pub fn add_c4def(&mut self, c4def: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C4DEF, c4def);
  }
  #[inline]
  pub fn add_c4runin(&mut self, c4runin: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C4RUNIN, c4runin, 0);
  }
  #[inline]
  pub fn add_c4egress(&mut self, c4egress: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C4EGRESS, c4egress, 0);
  }
  #[inline]
  pub fn add_c4numberofstores(&mut self, c4numberofstores: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C4NUMBEROFSTORES, c4numberofstores, 0);
  }
  #[inline]
  pub fn add_c4typeofstores(&mut self, c4typeofstores: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C4TYPEOFSTORES, c4typeofstores, 0);
  }
  #[inline]
  pub fn add_c4timediscrete(&mut self, c4timediscrete: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C4TIMEDISCRETE, c4timediscrete);
  }
  #[inline]
  pub fn add_c4tm(&mut self, c4tm: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C4TM, c4tm, 0);
  }
  #[inline]
  pub fn add_c4colon(&mut self, c4colon: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C4COLON, c4colon, 0);
  }
  #[inline]
  pub fn add_c4mod(&mut self, c4mod: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C4MOD, c4mod, 0);
  }
  #[inline]
  pub fn add_c5haeadj(&mut self, c5haeadj: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C5HAEADJ, c5haeadj, 0);
  }
  #[inline]
  pub fn add_c5tw(&mut self, c5tw: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C5TW, c5tw, 0);
  }
  #[inline]
  pub fn add_c5tgtbrng(&mut self, c5tgtbrng: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C5TGTBRNG, c5tgtbrng, 0);
  }
  #[inline]
  pub fn add_c5latlsb(&mut self, c5latlsb: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C5LATLSB, c5latlsb, 0);
  }
  #[inline]
  pub fn add_c5lonlsb(&mut self, c5lonlsb: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C5LONLSB, c5lonlsb, 0);
  }
  #[inline]
  pub fn add_c5elevationlsbs(&mut self, c5elevationlsbs: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C5ELEVATIONLSBS, c5elevationlsbs, 0);
  }
  #[inline]
  pub fn add_c5colon(&mut self, c5colon: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C5COLON, c5colon, 0);
  }
  #[inline]
  pub fn add_c6laser(&mut self, c6laser: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C6LASER, c6laser, 0);
  }
  #[inline]
  pub fn add_c6intel(&mut self, c6intel: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C6INTEL, c6intel, 0);
  }
  #[inline]
  pub fn add_c6tnr3(&mut self, c6tnr3: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C6TNR3, c6tnr3, 0);
  }
  #[inline]
  pub fn add_c6dspct(&mut self, c6dspct: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C6DSPCT, c6dspct);
  }
  #[inline]
  pub fn add_c6dspc(&mut self, c6dspc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C6DSPC, c6dspc);
  }
  #[inline]
  pub fn add_c6fplpm(&mut self, c6fplpm: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C6FPLPM, c6fplpm);
  }
  #[inline]
  pub fn add_c6longpm(&mut self, c6longpm: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C6LONGPM, c6longpm);
  }
  #[inline]
  pub fn add_c7tnor(&mut self, c7tnor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_C7TNOR, c7tnor);
  }
  #[inline]
  pub fn add_c7in3p(&mut self, c7in3p: i32) {
    self.fbb_.push_slot::<i32>(MissionAssignment_Full::VT_C7IN3P, c7in3p, 0);
  }
  #[inline]
  pub fn add_c7elang2(&mut self, c7elang2: f64) {
    self.fbb_.push_slot::<f64>(MissionAssignment_Full::VT_C7ELANG2, c7elang2, 0.0);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: MissionAssignment_Full_dataMode_Enum) {
    self.fbb_.push_slot::<MissionAssignment_Full_dataMode_Enum>(MissionAssignment_Full::VT_DATAMODE, dataMode, MissionAssignment_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissionAssignment_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MissionAssignment_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MissionAssignment_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MissionAssignment_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MissionAssignment_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MissionAssignment_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("trkId", &self.trkId());
      ds.field("ts", &self.ts());
      ds.field("mad", &self.mad());
      ds.field("rc", &self.rc());
      ds.field("rr", &self.rr());
      ds.field("tno", &self.tno());
      ds.field("twenv", &self.twenv());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("orginx", &self.orginx());
      ds.field("env", &self.env());
      ds.field("sz", &self.sz());
      ds.field("index", &self.index());
      ds.field("c1associateddmpis", &self.c1associateddmpis());
      ds.field("c2spc", &self.c2spc());
      ds.field("c2air", &self.c2air());
      ds.field("c2sur", &self.c2sur());
      ds.field("c2lnd", &self.c2lnd());
      ds.field("c2id", &self.c2id());
      ds.field("c2idamplifyingdescriptor", &self.c2idamplifyingdescriptor());
      ds.field("c2alt", &self.c2alt());
      ds.field("c2crs", &self.c2crs());
      ds.field("c2spd", &self.c2spd());
      ds.field("c2specialinterestindicator", &self.c2specialinterestindicator());
      ds.field("c2exerciseindicator", &self.c2exerciseindicator());
      ds.field("c2exercisemof", &self.c2exercisemof());
      ds.field("c3lat", &self.c3lat());
      ds.field("c3lon", &self.c3lon());
      ds.field("c3elv", &self.c3elv());
      ds.field("c3ptl", &self.c3ptl());
      ds.field("c3ptnum", &self.c3ptnum());
      ds.field("c4tgt", &self.c4tgt());
      ds.field("c4def", &self.c4def());
      ds.field("c4runin", &self.c4runin());
      ds.field("c4egress", &self.c4egress());
      ds.field("c4numberofstores", &self.c4numberofstores());
      ds.field("c4typeofstores", &self.c4typeofstores());
      ds.field("c4timediscrete", &self.c4timediscrete());
      ds.field("c4tm", &self.c4tm());
      ds.field("c4colon", &self.c4colon());
      ds.field("c4mod", &self.c4mod());
      ds.field("c5haeadj", &self.c5haeadj());
      ds.field("c5tw", &self.c5tw());
      ds.field("c5tgtbrng", &self.c5tgtbrng());
      ds.field("c5latlsb", &self.c5latlsb());
      ds.field("c5lonlsb", &self.c5lonlsb());
      ds.field("c5elevationlsbs", &self.c5elevationlsbs());
      ds.field("c5colon", &self.c5colon());
      ds.field("c6laser", &self.c6laser());
      ds.field("c6intel", &self.c6intel());
      ds.field("c6tnr3", &self.c6tnr3());
      ds.field("c6dspct", &self.c6dspct());
      ds.field("c6dspc", &self.c6dspc());
      ds.field("c6fplpm", &self.c6fplpm());
      ds.field("c6longpm", &self.c6longpm());
      ds.field("c7tnor", &self.c7tnor());
      ds.field("c7in3p", &self.c7in3p());
      ds.field("c7elang2", &self.c7elang2());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MissionAssignment_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub trkId: Option<String>,
  pub ts: Option<String>,
  pub mad: Option<String>,
  pub rc: Option<String>,
  pub rr: i32,
  pub tno: Option<String>,
  pub twenv: Option<String>,
  pub lat: f64,
  pub lon: f64,
  pub orginx: Option<String>,
  pub env: Option<String>,
  pub sz: Option<String>,
  pub index: i32,
  pub c1associateddmpis: i32,
  pub c2spc: Option<String>,
  pub c2air: Option<String>,
  pub c2sur: Option<String>,
  pub c2lnd: Option<String>,
  pub c2id: Option<String>,
  pub c2idamplifyingdescriptor: Option<String>,
  pub c2alt: i32,
  pub c2crs: i32,
  pub c2spd: i32,
  pub c2specialinterestindicator: Option<String>,
  pub c2exerciseindicator: Option<String>,
  pub c2exercisemof: Option<String>,
  pub c3lat: f64,
  pub c3lon: f64,
  pub c3elv: f64,
  pub c3ptl: Option<String>,
  pub c3ptnum: Option<String>,
  pub c4tgt: Option<String>,
  pub c4def: Option<String>,
  pub c4runin: i32,
  pub c4egress: i32,
  pub c4numberofstores: i32,
  pub c4typeofstores: i32,
  pub c4timediscrete: Option<String>,
  pub c4tm: i32,
  pub c4colon: i32,
  pub c4mod: i32,
  pub c5haeadj: i32,
  pub c5tw: i32,
  pub c5tgtbrng: i32,
  pub c5latlsb: i32,
  pub c5lonlsb: i32,
  pub c5elevationlsbs: i32,
  pub c5colon: i32,
  pub c6laser: i32,
  pub c6intel: i32,
  pub c6tnr3: i32,
  pub c6dspct: Option<String>,
  pub c6dspc: Option<String>,
  pub c6fplpm: Option<String>,
  pub c6longpm: Option<String>,
  pub c7tnor: Option<String>,
  pub c7in3p: i32,
  pub c7elang2: f64,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: MissionAssignment_Full_dataMode_Enum,
  pub origNetwork: Option<String>,
}
impl Default for MissionAssignment_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      trkId: None,
      ts: None,
      mad: None,
      rc: None,
      rr: 0,
      tno: None,
      twenv: None,
      lat: 0.0,
      lon: 0.0,
      orginx: None,
      env: None,
      sz: None,
      index: 0,
      c1associateddmpis: 0,
      c2spc: None,
      c2air: None,
      c2sur: None,
      c2lnd: None,
      c2id: None,
      c2idamplifyingdescriptor: None,
      c2alt: 0,
      c2crs: 0,
      c2spd: 0,
      c2specialinterestindicator: None,
      c2exerciseindicator: None,
      c2exercisemof: None,
      c3lat: 0.0,
      c3lon: 0.0,
      c3elv: 0.0,
      c3ptl: None,
      c3ptnum: None,
      c4tgt: None,
      c4def: None,
      c4runin: 0,
      c4egress: 0,
      c4numberofstores: 0,
      c4typeofstores: 0,
      c4timediscrete: None,
      c4tm: 0,
      c4colon: 0,
      c4mod: 0,
      c5haeadj: 0,
      c5tw: 0,
      c5tgtbrng: 0,
      c5latlsb: 0,
      c5lonlsb: 0,
      c5elevationlsbs: 0,
      c5colon: 0,
      c6laser: 0,
      c6intel: 0,
      c6tnr3: 0,
      c6dspct: None,
      c6dspc: None,
      c6fplpm: None,
      c6longpm: None,
      c7tnor: None,
      c7in3p: 0,
      c7elang2: 0.0,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      origin: None,
      dataMode: MissionAssignment_Full_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}
impl MissionAssignment_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MissionAssignment_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trkId = self.trkId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ts = self.ts.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mad = self.mad.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rc = self.rc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rr = self.rr;
    let tno = self.tno.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let twenv = self.twenv.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lat = self.lat;
    let lon = self.lon;
    let orginx = self.orginx.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let env = self.env.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sz = self.sz.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let index = self.index;
    let c1associateddmpis = self.c1associateddmpis;
    let c2spc = self.c2spc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c2air = self.c2air.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c2sur = self.c2sur.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c2lnd = self.c2lnd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c2id = self.c2id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c2idamplifyingdescriptor = self.c2idamplifyingdescriptor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c2alt = self.c2alt;
    let c2crs = self.c2crs;
    let c2spd = self.c2spd;
    let c2specialinterestindicator = self.c2specialinterestindicator.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c2exerciseindicator = self.c2exerciseindicator.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c2exercisemof = self.c2exercisemof.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c3lat = self.c3lat;
    let c3lon = self.c3lon;
    let c3elv = self.c3elv;
    let c3ptl = self.c3ptl.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c3ptnum = self.c3ptnum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c4tgt = self.c4tgt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c4def = self.c4def.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c4runin = self.c4runin;
    let c4egress = self.c4egress;
    let c4numberofstores = self.c4numberofstores;
    let c4typeofstores = self.c4typeofstores;
    let c4timediscrete = self.c4timediscrete.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c4tm = self.c4tm;
    let c4colon = self.c4colon;
    let c4mod = self.c4mod;
    let c5haeadj = self.c5haeadj;
    let c5tw = self.c5tw;
    let c5tgtbrng = self.c5tgtbrng;
    let c5latlsb = self.c5latlsb;
    let c5lonlsb = self.c5lonlsb;
    let c5elevationlsbs = self.c5elevationlsbs;
    let c5colon = self.c5colon;
    let c6laser = self.c6laser;
    let c6intel = self.c6intel;
    let c6tnr3 = self.c6tnr3;
    let c6dspct = self.c6dspct.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c6dspc = self.c6dspc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c6fplpm = self.c6fplpm.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c6longpm = self.c6longpm.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c7tnor = self.c7tnor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let c7in3p = self.c7in3p;
    let c7elang2 = self.c7elang2;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    MissionAssignment_Full::create(_fbb, &MissionAssignment_FullArgs{
      id,
      classificationMarking,
      trkId,
      ts,
      mad,
      rc,
      rr,
      tno,
      twenv,
      lat,
      lon,
      orginx,
      env,
      sz,
      index,
      c1associateddmpis,
      c2spc,
      c2air,
      c2sur,
      c2lnd,
      c2id,
      c2idamplifyingdescriptor,
      c2alt,
      c2crs,
      c2spd,
      c2specialinterestindicator,
      c2exerciseindicator,
      c2exercisemof,
      c3lat,
      c3lon,
      c3elv,
      c3ptl,
      c3ptnum,
      c4tgt,
      c4def,
      c4runin,
      c4egress,
      c4numberofstores,
      c4typeofstores,
      c4timediscrete,
      c4tm,
      c4colon,
      c4mod,
      c5haeadj,
      c5tw,
      c5tgtbrng,
      c5latlsb,
      c5lonlsb,
      c5elevationlsbs,
      c5colon,
      c6laser,
      c6intel,
      c6tnr3,
      c6dspct,
      c6dspc,
      c6fplpm,
      c6longpm,
      c7tnor,
      c7in3p,
      c7elang2,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      origin,
      dataMode,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `MissionAssignment_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mission_assignment_full_unchecked`.
pub fn root_as_mission_assignment_full(buf: &[u8]) -> Result<MissionAssignment_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MissionAssignment_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MissionAssignment_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_mission_assignment_full_unchecked`.
pub fn size_prefixed_root_as_mission_assignment_full(buf: &[u8]) -> Result<MissionAssignment_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MissionAssignment_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MissionAssignment_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mission_assignment_full_unchecked`.
pub fn root_as_mission_assignment_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MissionAssignment_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MissionAssignment_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MissionAssignment_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mission_assignment_full_unchecked`.
pub fn size_prefixed_root_as_mission_assignment_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MissionAssignment_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MissionAssignment_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MissionAssignment_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MissionAssignment_Full`.
pub unsafe fn root_as_mission_assignment_full_unchecked(buf: &[u8]) -> MissionAssignment_Full {
  flatbuffers::root_unchecked::<MissionAssignment_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MissionAssignment_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MissionAssignment_Full`.
pub unsafe fn size_prefixed_root_as_mission_assignment_full_unchecked(buf: &[u8]) -> MissionAssignment_Full {
  flatbuffers::size_prefixed_root_unchecked::<MissionAssignment_Full>(buf)
}
pub const MISSION_ASSIGNMENT_FULL_IDENTIFIER: &str = "MISS";

#[inline]
pub fn mission_assignment_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MISSION_ASSIGNMENT_FULL_IDENTIFIER, false)
}

#[inline]
pub fn mission_assignment_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MISSION_ASSIGNMENT_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_mission_assignment_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<MissionAssignment_Full<'a>>) {
  fbb.finish(root, Some(MISSION_ASSIGNMENT_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_mission_assignment_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<MissionAssignment_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(MISSION_ASSIGNMENT_FULL_IDENTIFIER));
}
