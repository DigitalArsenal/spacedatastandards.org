// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONJUNCTION_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONJUNCTION_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONJUNCTION_FULL_DATA_MODE_ENUM: [Conjunction_Full_dataMode_Enum; 4] = [
  Conjunction_Full_dataMode_Enum::REAL,
  Conjunction_Full_dataMode_Enum::TEST,
  Conjunction_Full_dataMode_Enum::SIMULATED,
  Conjunction_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Conjunction_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Conjunction_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Conjunction_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Conjunction_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Conjunction_Full_dataMode_Enum {
    type Output = Conjunction_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Conjunction_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Conjunction_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Conjunction_Full_dataMode_Enum {}
pub enum Conjunction_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Stores the results of a particular Conjunction Assessment (CA) run.
pub struct Conjunction_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Conjunction_Full<'a> {
  type Inner = Conjunction_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Conjunction_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDONORBIT1: flatbuffers::VOffsetT = 8;
  pub const VT_IDONORBIT2: flatbuffers::VOffsetT = 10;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 12;
  pub const VT_TCA: flatbuffers::VOffsetT = 14;
  pub const VT_MISSDISTANCE: flatbuffers::VOffsetT = 16;
  pub const VT_COLLISIONPROB: flatbuffers::VOffsetT = 18;
  pub const VT_COLLISIONPROBMETHOD: flatbuffers::VOffsetT = 20;
  pub const VT_EPHEMNAME1: flatbuffers::VOffsetT = 22;
  pub const VT_ESID1: flatbuffers::VOffsetT = 24;
  pub const VT_EPHEMNAME2: flatbuffers::VOffsetT = 26;
  pub const VT_ESID2: flatbuffers::VOffsetT = 28;
  pub const VT_RELPOSR: flatbuffers::VOffsetT = 30;
  pub const VT_RELPOST: flatbuffers::VOffsetT = 32;
  pub const VT_RELPOSN: flatbuffers::VOffsetT = 34;
  pub const VT_RELVELMAG: flatbuffers::VOffsetT = 36;
  pub const VT_RELVELR: flatbuffers::VOffsetT = 38;
  pub const VT_RELVELT: flatbuffers::VOffsetT = 40;
  pub const VT_RELVELN: flatbuffers::VOffsetT = 42;
  pub const VT_SCREENENTRYTIME: flatbuffers::VOffsetT = 44;
  pub const VT_SCREENEXITTIME: flatbuffers::VOffsetT = 46;
  pub const VT_SCREENVOLUMEX: flatbuffers::VOffsetT = 48;
  pub const VT_SCREENVOLUMEY: flatbuffers::VOffsetT = 50;
  pub const VT_SCREENVOLUMEZ: flatbuffers::VOffsetT = 52;
  pub const VT_VOLSHAPE: flatbuffers::VOffsetT = 54;
  pub const VT_VOLENTRYTIME: flatbuffers::VOffsetT = 56;
  pub const VT_VOLEXITTIME: flatbuffers::VOffsetT = 58;
  pub const VT_PENETRATIONLEVELSIGMA: flatbuffers::VOffsetT = 60;
  pub const VT_IDSTATEVECTOR1: flatbuffers::VOffsetT = 62;
  pub const VT_LASTOBTIME1: flatbuffers::VOffsetT = 64;
  pub const VT_CDAOM1: flatbuffers::VOffsetT = 66;
  pub const VT_CRAOM1: flatbuffers::VOffsetT = 68;
  pub const VT_THRUSTACCEL1: flatbuffers::VOffsetT = 70;
  pub const VT_IDSTATEVECTOR2: flatbuffers::VOffsetT = 72;
  pub const VT_LASTOBTIME2: flatbuffers::VOffsetT = 74;
  pub const VT_CDAOM2: flatbuffers::VOffsetT = 76;
  pub const VT_CRAOM2: flatbuffers::VOffsetT = 78;
  pub const VT_THRUSTACCEL2: flatbuffers::VOffsetT = 80;
  pub const VT_COMMENTS: flatbuffers::VOffsetT = 82;
  pub const VT_CCIR: flatbuffers::VOffsetT = 84;
  pub const VT_CONCERNNOTES: flatbuffers::VOffsetT = 86;
  pub const VT_STATEDEPTNOTIFIED: flatbuffers::VOffsetT = 88;
  pub const VT_OWNERCONTACTED: flatbuffers::VOffsetT = 90;
  pub const VT_RAWFILEURI: flatbuffers::VOffsetT = 92;
  pub const VT_MESSAGEFOR: flatbuffers::VOffsetT = 94;
  pub const VT_MESSAGEID: flatbuffers::VOffsetT = 96;
  pub const VT_UVWWARN: flatbuffers::VOffsetT = 98;
  pub const VT_SMALLRELVELWARNING: flatbuffers::VOffsetT = 100;
  pub const VT_LARGERELPOSWARNING: flatbuffers::VOffsetT = 102;
  pub const VT_SMALLCOVWARNING: flatbuffers::VOffsetT = 104;
  pub const VT_LARGECOVWARNING: flatbuffers::VOffsetT = 106;
  pub const VT_TRANSACTIONID: flatbuffers::VOffsetT = 108;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 110;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 112;
  pub const VT_ORIGINATOR: flatbuffers::VOffsetT = 114;
  pub const VT_EVENTID: flatbuffers::VOffsetT = 116;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 118;
  pub const VT_TAGS: flatbuffers::VOffsetT = 120;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 122;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 124;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 126;
  pub const VT_STATEVECTOR1: flatbuffers::VOffsetT = 128;
  pub const VT_STATEVECTOR2: flatbuffers::VOffsetT = 130;
  pub const VT_SATNO1: flatbuffers::VOffsetT = 132;
  pub const VT_SATNO2: flatbuffers::VOffsetT = 134;
  pub const VT_ONORBIT1: flatbuffers::VOffsetT = 136;
  pub const VT_ONORBIT2: flatbuffers::VOffsetT = 138;
  pub const VT_ORIGIDONORBIT1: flatbuffers::VOffsetT = 140;
  pub const VT_ORIGIDONORBIT2: flatbuffers::VOffsetT = 142;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 144;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Conjunction_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Conjunction_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<Conjunction_Full<'bldr>> {
    let mut builder = Conjunction_FullBuilder::new(_fbb);
    builder.add_thrustAccel2(args.thrustAccel2);
    builder.add_crAoM2(args.crAoM2);
    builder.add_cdAoM2(args.cdAoM2);
    builder.add_thrustAccel1(args.thrustAccel1);
    builder.add_crAoM1(args.crAoM1);
    builder.add_cdAoM1(args.cdAoM1);
    builder.add_penetrationLevelSigma(args.penetrationLevelSigma);
    builder.add_screenVolumeZ(args.screenVolumeZ);
    builder.add_screenVolumeY(args.screenVolumeY);
    builder.add_screenVolumeX(args.screenVolumeX);
    builder.add_relVelN(args.relVelN);
    builder.add_relVelT(args.relVelT);
    builder.add_relVelR(args.relVelR);
    builder.add_relVelMag(args.relVelMag);
    builder.add_relPosN(args.relPosN);
    builder.add_relPosT(args.relPosT);
    builder.add_relPosR(args.relPosR);
    builder.add_collisionProb(args.collisionProb);
    builder.add_missDistance(args.missDistance);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origIdOnOrbit2 { builder.add_origIdOnOrbit2(x); }
    if let Some(x) = args.origIdOnOrbit1 { builder.add_origIdOnOrbit1(x); }
    if let Some(x) = args.onOrbit2 { builder.add_onOrbit2(x); }
    if let Some(x) = args.onOrbit1 { builder.add_onOrbit1(x); }
    builder.add_satNo2(args.satNo2);
    builder.add_satNo1(args.satNo1);
    if let Some(x) = args.stateVector2 { builder.add_stateVector2(x); }
    if let Some(x) = args.stateVector1 { builder.add_stateVector1(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.descriptor { builder.add_descriptor(x); }
    if let Some(x) = args.eventId { builder.add_eventId(x); }
    if let Some(x) = args.originator { builder.add_originator(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.transactionId { builder.add_transactionId(x); }
    if let Some(x) = args.messageId { builder.add_messageId(x); }
    if let Some(x) = args.messageFor { builder.add_messageFor(x); }
    if let Some(x) = args.rawFileURI { builder.add_rawFileURI(x); }
    if let Some(x) = args.concernNotes { builder.add_concernNotes(x); }
    if let Some(x) = args.ccir { builder.add_ccir(x); }
    if let Some(x) = args.comments { builder.add_comments(x); }
    if let Some(x) = args.lastObTime2 { builder.add_lastObTime2(x); }
    if let Some(x) = args.idStateVector2 { builder.add_idStateVector2(x); }
    if let Some(x) = args.lastObTime1 { builder.add_lastObTime1(x); }
    if let Some(x) = args.idStateVector1 { builder.add_idStateVector1(x); }
    if let Some(x) = args.volExitTime { builder.add_volExitTime(x); }
    if let Some(x) = args.volEntryTime { builder.add_volEntryTime(x); }
    if let Some(x) = args.volShape { builder.add_volShape(x); }
    if let Some(x) = args.screenExitTime { builder.add_screenExitTime(x); }
    if let Some(x) = args.screenEntryTime { builder.add_screenEntryTime(x); }
    if let Some(x) = args.esId2 { builder.add_esId2(x); }
    if let Some(x) = args.ephemName2 { builder.add_ephemName2(x); }
    if let Some(x) = args.esId1 { builder.add_esId1(x); }
    if let Some(x) = args.ephemName1 { builder.add_ephemName1(x); }
    if let Some(x) = args.collisionProbMethod { builder.add_collisionProbMethod(x); }
    if let Some(x) = args.tca { builder.add_tca(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.idOnOrbit2 { builder.add_idOnOrbit2(x); }
    if let Some(x) = args.idOnOrbit1 { builder.add_idOnOrbit1(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_largeCovWarning(args.largeCovWarning);
    builder.add_smallCovWarning(args.smallCovWarning);
    builder.add_largeRelPosWarning(args.largeRelPosWarning);
    builder.add_smallRelVelWarning(args.smallRelVelWarning);
    builder.add_uvwWarn(args.uvwWarn);
    builder.add_ownerContacted(args.ownerContacted);
    builder.add_stateDeptNotified(args.stateDeptNotified);
    builder.finish()
  }

  pub fn unpack(&self) -> Conjunction_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idOnOrbit1 = self.idOnOrbit1().map(|x| {
      x.to_string()
    });
    let idOnOrbit2 = self.idOnOrbit2().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let tca = self.tca().map(|x| {
      x.to_string()
    });
    let missDistance = self.missDistance();
    let collisionProb = self.collisionProb();
    let collisionProbMethod = self.collisionProbMethod().map(|x| {
      x.to_string()
    });
    let ephemName1 = self.ephemName1().map(|x| {
      x.to_string()
    });
    let esId1 = self.esId1().map(|x| {
      x.to_string()
    });
    let ephemName2 = self.ephemName2().map(|x| {
      x.to_string()
    });
    let esId2 = self.esId2().map(|x| {
      x.to_string()
    });
    let relPosR = self.relPosR();
    let relPosT = self.relPosT();
    let relPosN = self.relPosN();
    let relVelMag = self.relVelMag();
    let relVelR = self.relVelR();
    let relVelT = self.relVelT();
    let relVelN = self.relVelN();
    let screenEntryTime = self.screenEntryTime().map(|x| {
      x.to_string()
    });
    let screenExitTime = self.screenExitTime().map(|x| {
      x.to_string()
    });
    let screenVolumeX = self.screenVolumeX();
    let screenVolumeY = self.screenVolumeY();
    let screenVolumeZ = self.screenVolumeZ();
    let volShape = self.volShape().map(|x| {
      x.to_string()
    });
    let volEntryTime = self.volEntryTime().map(|x| {
      x.to_string()
    });
    let volExitTime = self.volExitTime().map(|x| {
      x.to_string()
    });
    let penetrationLevelSigma = self.penetrationLevelSigma();
    let idStateVector1 = self.idStateVector1().map(|x| {
      x.to_string()
    });
    let lastObTime1 = self.lastObTime1().map(|x| {
      x.to_string()
    });
    let cdAoM1 = self.cdAoM1();
    let crAoM1 = self.crAoM1();
    let thrustAccel1 = self.thrustAccel1();
    let idStateVector2 = self.idStateVector2().map(|x| {
      x.to_string()
    });
    let lastObTime2 = self.lastObTime2().map(|x| {
      x.to_string()
    });
    let cdAoM2 = self.cdAoM2();
    let crAoM2 = self.crAoM2();
    let thrustAccel2 = self.thrustAccel2();
    let comments = self.comments().map(|x| {
      x.to_string()
    });
    let ccir = self.ccir().map(|x| {
      x.to_string()
    });
    let concernNotes = self.concernNotes().map(|x| {
      x.to_string()
    });
    let stateDeptNotified = self.stateDeptNotified();
    let ownerContacted = self.ownerContacted();
    let rawFileURI = self.rawFileURI().map(|x| {
      x.to_string()
    });
    let messageFor = self.messageFor().map(|x| {
      x.to_string()
    });
    let messageId = self.messageId().map(|x| {
      x.to_string()
    });
    let uvwWarn = self.uvwWarn();
    let smallRelVelWarning = self.smallRelVelWarning();
    let largeRelPosWarning = self.largeRelPosWarning();
    let smallCovWarning = self.smallCovWarning();
    let largeCovWarning = self.largeCovWarning();
    let transactionId = self.transactionId().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let originator = self.originator().map(|x| {
      x.to_string()
    });
    let eventId = self.eventId().map(|x| {
      x.to_string()
    });
    let descriptor = self.descriptor().map(|x| {
      x.to_string()
    });
    let tags = self.tags().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let dataMode = self.dataMode();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let stateVector1 = self.stateVector1().map(|x| {
      x.to_string()
    });
    let stateVector2 = self.stateVector2().map(|x| {
      x.to_string()
    });
    let satNo1 = self.satNo1();
    let satNo2 = self.satNo2();
    let onOrbit1 = self.onOrbit1().map(|x| {
      x.to_string()
    });
    let onOrbit2 = self.onOrbit2().map(|x| {
      x.to_string()
    });
    let origIdOnOrbit1 = self.origIdOnOrbit1().map(|x| {
      x.to_string()
    });
    let origIdOnOrbit2 = self.origIdOnOrbit2().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    Conjunction_FullT {
      id,
      classificationMarking,
      idOnOrbit1,
      idOnOrbit2,
      type_,
      tca,
      missDistance,
      collisionProb,
      collisionProbMethod,
      ephemName1,
      esId1,
      ephemName2,
      esId2,
      relPosR,
      relPosT,
      relPosN,
      relVelMag,
      relVelR,
      relVelT,
      relVelN,
      screenEntryTime,
      screenExitTime,
      screenVolumeX,
      screenVolumeY,
      screenVolumeZ,
      volShape,
      volEntryTime,
      volExitTime,
      penetrationLevelSigma,
      idStateVector1,
      lastObTime1,
      cdAoM1,
      crAoM1,
      thrustAccel1,
      idStateVector2,
      lastObTime2,
      cdAoM2,
      crAoM2,
      thrustAccel2,
      comments,
      ccir,
      concernNotes,
      stateDeptNotified,
      ownerContacted,
      rawFileURI,
      messageFor,
      messageId,
      uvwWarn,
      smallRelVelWarning,
      largeRelPosWarning,
      smallCovWarning,
      largeCovWarning,
      transactionId,
      source,
      origin,
      originator,
      eventId,
      descriptor,
      tags,
      dataMode,
      createdAt,
      createdBy,
      stateVector1,
      stateVector2,
      satNo1,
      satNo2,
      onOrbit1,
      onOrbit2,
      origIdOnOrbit1,
      origIdOnOrbit2,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: CONJUNCTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the primary satellite on-orbit object, if correlated.
  /// Example: /// Example: ONORBIT1-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_IDONORBIT1, None)}
  }
  /// Unique identifier of the secondary satellite on-orbit object, if correlated.
  /// Example: /// Example: ONORBIT2-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_IDONORBIT2, None)}
  }
  /// The type of data represented in this conjunction record (e.g. CONJUNCTION, CARA-WORKLIST, etc.).  If type is null the record is assumed to be a Conjunction.
  /// Example: /// Example: CONJUNCTION
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_TYPE_, None)}
  }
  /// Time of closest approach (TCA) in UTC.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tca(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_TCA, None)}
  }
  /// Distance between objects at Time of Closest Approach (TCA) in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn missDistance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_MISSDISTANCE, Some(0.0)).unwrap()}
  }
  /// Probability of Collision is the probability (denoted p, where 0.0<=p<=1.0), that Object1 and Object2 will collide.
  /// Example: /// Example: 0.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn collisionProb(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_COLLISIONPROB, Some(0.0)).unwrap()}
  }
  /// The method that was used to calculate the collision probability, ex. FOSTER-1992.
  /// Example: /// Example: FOSTER-1992
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn collisionProbMethod(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_COLLISIONPROBMETHOD, None)}
  }
  /// The filename of the primary (object1) ephemeris used in the screening, if applicable.
  /// Example: /// Example: MEME_SPCFT_ABC_2180000_ops_nomnvr_unclassified.oem
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn ephemName1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_EPHEMNAME1, None)}
  }
  /// Unique identifier of the parent Ephemeris Set of the primary (object1) ephemeris used in the screening, if applicable.
  /// Example: /// Example: a2ae2356-6d83-4e4b-896d-ddd1958800fa
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn esId1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_ESID1, None)}
  }
  /// The filename of the secondary (object2) ephemeris used in the screening, if applicable.
  /// Example: /// Example: MEME_SPCFT_DEF_2170000_ops_nomnvr_unclassified.txt
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn ephemName2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_EPHEMNAME2, None)}
  }
  /// Unique identifier of the parent Ephemeris Set of the secondary (object2) ephemeris used in the screening, if applicable.
  /// Example: /// Example: 6fa31433-8beb-4b9b-8bf9-326dbd041c3f
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn esId2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_ESID2, None)}
  }
  /// Distance between objects along Radial Vector at Time of Closest Approach in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn relPosR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_RELPOSR, Some(0.0)).unwrap()}
  }
  /// Distance between objects along Tangential Vector in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn relPosT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_RELPOST, Some(0.0)).unwrap()}
  }
  /// Distance between objects along Normal vector in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn relPosN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_RELPOSN, Some(0.0)).unwrap()}
  }
  /// Closing velocity magnitude (relative speed) at Time of Closest Approach in meters/sec.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn relVelMag(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_RELVELMAG, Some(0.0)).unwrap()}
  }
  /// Closing velocity between objects along Radial Vector at Time of Closest Approach in meters/sec.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn relVelR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_RELVELR, Some(0.0)).unwrap()}
  }
  /// Closing velocity between objects along Tangential Vector in meters/sec.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn relVelT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_RELVELT, Some(0.0)).unwrap()}
  }
  /// Closing velocity between objects along Normal Vector in meters/sec.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn relVelN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_RELVELN, Some(0.0)).unwrap()}
  }
  /// The start time in UTC of the screening period for the conjunction assessment.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn screenEntryTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_SCREENENTRYTIME, None)}
  }
  /// The stop time in UTC of the screening period for the conjunction assessment.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn screenExitTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_SCREENEXITTIME, None)}
  }
  /// Component size of screen in X component of  RTN (Radial, Transverse and Normal) frame in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn screenVolumeX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_SCREENVOLUMEX, Some(0.0)).unwrap()}
  }
  /// Component size of screen in Y component of  RTN (Radial, Transverse and Normal) frame in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn screenVolumeY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_SCREENVOLUMEY, Some(0.0)).unwrap()}
  }
  /// Component size of screen in Z component of  RTN (Radial, Transverse and Normal) frame in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn screenVolumeZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_SCREENVOLUMEZ, Some(0.0)).unwrap()}
  }
  /// The shape (BOX, ELLIPSOID) of the screening volume.
  /// Example: /// Example: ELLIPSOID
  /// Constraints: Minimum length = 0, Maximum length = 12
  #[inline]
  pub fn volShape(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_VOLSHAPE, None)}
  }
  /// The time at which the secondary (object2) enters the screening volume, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-01-01T01:02:01.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn volEntryTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_VOLENTRYTIME, None)}
  }
  /// The time at which the secondary (object2) exits the screening volume, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-01-01T01:02:28.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn volExitTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_VOLEXITTIME, None)}
  }
  /// Penetration Level Sigma.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn penetrationLevelSigma(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_PENETRATIONLEVELSIGMA, Some(0.0)).unwrap()}
  }
  /// Optional ID of the UDL State Vector at TCA of the primary object. When performing a create, this id will be ignored in favor of the UDL generated id of the stateVector1.
  /// Example: /// Example: REF-STATEVECTOR1-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idStateVector1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_IDSTATEVECTOR1, None)}
  }
  /// Time of last positive metric observation of the primary satellite.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lastObTime1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_LASTOBTIME1, None)}
  }
  /// The value of the primary (object1) Area times the drag coefficient over the object Mass, expressed in m^2/kg, used for propagation of the primary state vector and covariance to TCA.
  /// Example: /// Example: 0.016386
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cdAoM1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_CDAOM1, Some(0.0)).unwrap()}
  }
  /// The value of the primary (object1) Area times the solar radiation pressure coefficient over the object Mass, expressed in m^2/kg, used for propagation of the primary state vector and covariance to TCA.  This parameter is sometimes referred to as AGOM.
  /// Example: /// Example: 0.013814
  /// Constraints: No constraints specified.
  #[inline]
  pub fn crAoM1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_CRAOM1, Some(0.0)).unwrap()}
  }
  /// The primary (object1) acceleration, expressed in m/s^2, due to in-track thrust used to propagate the primary state vector and covariance to TCA.
  /// Example: /// Example: 0.033814
  /// Constraints: No constraints specified.
  #[inline]
  pub fn thrustAccel1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_THRUSTACCEL1, Some(0.0)).unwrap()}
  }
  /// Optional ID of the UDL State Vector at TCA of the secondary object. When performing a create, this id will be ignored in favor of the UDL generated id of the stateVector2.
  /// Example: /// Example: REF-STATEVECTOR2-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idStateVector2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_IDSTATEVECTOR2, None)}
  }
  /// Time of last positive metric observation of the secondary satellite.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lastObTime2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_LASTOBTIME2, None)}
  }
  /// The value of the secondary (object2) Area times the drag coefficient over the object Mass, expressed in m^2/kg, used for propagation of the primary state vector and covariance to TCA.
  /// Example: /// Example: 0.016386
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cdAoM2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_CDAOM2, Some(0.0)).unwrap()}
  }
  /// The value of the secondary (object2) Area times the solar radiation pressure coefficient over the object Mass, expressed in m^2/kg, used for propagation of the primary state vector and covariance to TCA.  This parameter is sometimes referred to as AGOM.
  /// Example: /// Example: 0.013814
  /// Constraints: No constraints specified.
  #[inline]
  pub fn crAoM2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_CRAOM2, Some(0.0)).unwrap()}
  }
  /// The secondary (object2) acceleration, expressed in m/s^2, due to in-track thrust used to propagate the primary state vector and covariance to TCA.
  /// Example: /// Example: 0.033814
  /// Constraints: No constraints specified.
  #[inline]
  pub fn thrustAccel2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Conjunction_Full::VT_THRUSTACCEL2, Some(0.0)).unwrap()}
  }
  /// Additional notes from data providers.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 1024
  #[inline]
  pub fn comments(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_COMMENTS, None)}
  }
  /// Commander's critical information requirements notes.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn ccir(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_CCIR, None)}
  }
  /// Emergency comments.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn concernNotes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_CONCERNNOTES, None)}
  }
  /// Flag indicating if State department was notified.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stateDeptNotified(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Conjunction_Full::VT_STATEDEPTNOTIFIED, Some(false)).unwrap()}
  }
  /// Flag indicating if owner was contacted.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ownerContacted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Conjunction_Full::VT_OWNERCONTACTED, Some(false)).unwrap()}
  }
  /// Link to filename associated with JMS record.
  /// Example: /// Example: Example link
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn rawFileURI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_RAWFILEURI, None)}
  }
  /// Spacecraft name(s) for which the Collision message is provided.
  /// Example: /// Example: Message for space craft A
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn messageFor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_MESSAGEFOR, None)}
  }
  /// JMS provided message ID link.
  /// Example: /// Example: MESSAGE-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn messageId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_MESSAGEID, None)}
  }
  /// Used for probability of collision calculation, not Warning/Alert Threshold notifications.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn uvwWarn(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Conjunction_Full::VT_UVWWARN, Some(false)).unwrap()}
  }
  /// Used for probability of collision calculation, not Warning/Alert Threshold notifications.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn smallRelVelWarning(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Conjunction_Full::VT_SMALLRELVELWARNING, Some(false)).unwrap()}
  }
  /// Used for probability of collision calculation, not Warning/Alert Threshold notifications.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn largeRelPosWarning(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Conjunction_Full::VT_LARGERELPOSWARNING, Some(false)).unwrap()}
  }
  /// Used for probability of collision calculation, not Warning/Alert Threshold notifications.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn smallCovWarning(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Conjunction_Full::VT_SMALLCOVWARNING, Some(false)).unwrap()}
  }
  /// Used for probability of collision calculation, not Warning/Alert Threshold notifications.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn largeCovWarning(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Conjunction_Full::VT_LARGECOVWARNING, Some(false)).unwrap()}
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn transactionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_TRANSACTIONID, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_ORIGIN, None)}
  }
  /// Creating agency or owner/operator (may be different than provider who submitted the conjunction message).
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn originator(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_ORIGINATOR, None)}
  }
  /// Optional source-provided identifier for this conjunction event. In the case where multiple conjunction records are submitted for the same event, this field can be used to tie them together to the same event.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn eventId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_EVENTID, None)}
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: sample_descriptor here
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn descriptor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_DESCRIPTOR, None)}
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG1']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Conjunction_Full::VT_TAGS, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> Conjunction_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Conjunction_Full_dataMode_Enum>(Conjunction_Full::VT_DATAMODE, Some(Conjunction_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_CREATEDBY, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stateVector1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_STATEVECTOR1, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stateVector2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_STATEVECTOR2, None)}
  }
  /// Satellite/catalog number of the target on-orbit primary object.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo1(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conjunction_Full::VT_SATNO1, Some(0)).unwrap()}
  }
  /// Satellite/catalog number of the target on-orbit secondary object.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo2(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Conjunction_Full::VT_SATNO2, Some(0)).unwrap()}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn onOrbit1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_ONORBIT1, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn onOrbit2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_ONORBIT2, None)}
  }
  /// Optional place holder for an OnOrbit ID that does not exist in UDL.
  /// Example: /// Example: ORIGONORBIT1-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn origIdOnOrbit1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_ORIGIDONORBIT1, None)}
  }
  /// Optional place holder for an OnOrbit ID that does not exist in UDL.
  /// Example: /// Example: ORIGONORBIT2-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn origIdOnOrbit2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_ORIGIDONORBIT2, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Conjunction_Full::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for Conjunction_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit1", Self::VT_IDONORBIT1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit2", Self::VT_IDONORBIT2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tca", Self::VT_TCA, false)?
     .visit_field::<f64>("missDistance", Self::VT_MISSDISTANCE, false)?
     .visit_field::<f64>("collisionProb", Self::VT_COLLISIONPROB, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("collisionProbMethod", Self::VT_COLLISIONPROBMETHOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ephemName1", Self::VT_EPHEMNAME1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("esId1", Self::VT_ESID1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ephemName2", Self::VT_EPHEMNAME2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("esId2", Self::VT_ESID2, false)?
     .visit_field::<f64>("relPosR", Self::VT_RELPOSR, false)?
     .visit_field::<f64>("relPosT", Self::VT_RELPOST, false)?
     .visit_field::<f64>("relPosN", Self::VT_RELPOSN, false)?
     .visit_field::<f64>("relVelMag", Self::VT_RELVELMAG, false)?
     .visit_field::<f64>("relVelR", Self::VT_RELVELR, false)?
     .visit_field::<f64>("relVelT", Self::VT_RELVELT, false)?
     .visit_field::<f64>("relVelN", Self::VT_RELVELN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("screenEntryTime", Self::VT_SCREENENTRYTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("screenExitTime", Self::VT_SCREENEXITTIME, false)?
     .visit_field::<f64>("screenVolumeX", Self::VT_SCREENVOLUMEX, false)?
     .visit_field::<f64>("screenVolumeY", Self::VT_SCREENVOLUMEY, false)?
     .visit_field::<f64>("screenVolumeZ", Self::VT_SCREENVOLUMEZ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("volShape", Self::VT_VOLSHAPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("volEntryTime", Self::VT_VOLENTRYTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("volExitTime", Self::VT_VOLEXITTIME, false)?
     .visit_field::<f64>("penetrationLevelSigma", Self::VT_PENETRATIONLEVELSIGMA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idStateVector1", Self::VT_IDSTATEVECTOR1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastObTime1", Self::VT_LASTOBTIME1, false)?
     .visit_field::<f64>("cdAoM1", Self::VT_CDAOM1, false)?
     .visit_field::<f64>("crAoM1", Self::VT_CRAOM1, false)?
     .visit_field::<f64>("thrustAccel1", Self::VT_THRUSTACCEL1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idStateVector2", Self::VT_IDSTATEVECTOR2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastObTime2", Self::VT_LASTOBTIME2, false)?
     .visit_field::<f64>("cdAoM2", Self::VT_CDAOM2, false)?
     .visit_field::<f64>("crAoM2", Self::VT_CRAOM2, false)?
     .visit_field::<f64>("thrustAccel2", Self::VT_THRUSTACCEL2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("comments", Self::VT_COMMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ccir", Self::VT_CCIR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("concernNotes", Self::VT_CONCERNNOTES, false)?
     .visit_field::<bool>("stateDeptNotified", Self::VT_STATEDEPTNOTIFIED, false)?
     .visit_field::<bool>("ownerContacted", Self::VT_OWNERCONTACTED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawFileURI", Self::VT_RAWFILEURI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("messageFor", Self::VT_MESSAGEFOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("messageId", Self::VT_MESSAGEID, false)?
     .visit_field::<bool>("uvwWarn", Self::VT_UVWWARN, false)?
     .visit_field::<bool>("smallRelVelWarning", Self::VT_SMALLRELVELWARNING, false)?
     .visit_field::<bool>("largeRelPosWarning", Self::VT_LARGERELPOSWARNING, false)?
     .visit_field::<bool>("smallCovWarning", Self::VT_SMALLCOVWARNING, false)?
     .visit_field::<bool>("largeCovWarning", Self::VT_LARGECOVWARNING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transactionId", Self::VT_TRANSACTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("originator", Self::VT_ORIGINATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventId", Self::VT_EVENTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("descriptor", Self::VT_DESCRIPTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<Conjunction_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stateVector1", Self::VT_STATEVECTOR1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stateVector2", Self::VT_STATEVECTOR2, false)?
     .visit_field::<i32>("satNo1", Self::VT_SATNO1, false)?
     .visit_field::<i32>("satNo2", Self::VT_SATNO2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("onOrbit1", Self::VT_ONORBIT1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("onOrbit2", Self::VT_ONORBIT2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origIdOnOrbit1", Self::VT_ORIGIDONORBIT1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origIdOnOrbit2", Self::VT_ORIGIDONORBIT2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct Conjunction_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tca: Option<flatbuffers::WIPOffset<&'a str>>,
    pub missDistance: f64,
    pub collisionProb: f64,
    pub collisionProbMethod: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ephemName1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub esId1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ephemName2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub esId2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relPosR: f64,
    pub relPosT: f64,
    pub relPosN: f64,
    pub relVelMag: f64,
    pub relVelR: f64,
    pub relVelT: f64,
    pub relVelN: f64,
    pub screenEntryTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub screenExitTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub screenVolumeX: f64,
    pub screenVolumeY: f64,
    pub screenVolumeZ: f64,
    pub volShape: Option<flatbuffers::WIPOffset<&'a str>>,
    pub volEntryTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub volExitTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub penetrationLevelSigma: f64,
    pub idStateVector1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lastObTime1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cdAoM1: f64,
    pub crAoM1: f64,
    pub thrustAccel1: f64,
    pub idStateVector2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lastObTime2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cdAoM2: f64,
    pub crAoM2: f64,
    pub thrustAccel2: f64,
    pub comments: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ccir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub concernNotes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stateDeptNotified: bool,
    pub ownerContacted: bool,
    pub rawFileURI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub messageFor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub messageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uvwWarn: bool,
    pub smallRelVelWarning: bool,
    pub largeRelPosWarning: bool,
    pub smallCovWarning: bool,
    pub largeCovWarning: bool,
    pub transactionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub originator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub descriptor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub dataMode: Conjunction_Full_dataMode_Enum,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stateVector1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stateVector2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo1: i32,
    pub satNo2: i32,
    pub onOrbit1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub onOrbit2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origIdOnOrbit1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origIdOnOrbit2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Conjunction_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    Conjunction_FullArgs {
      id: None,
      classificationMarking: None,
      idOnOrbit1: None,
      idOnOrbit2: None,
      type_: None,
      tca: None,
      missDistance: 0.0,
      collisionProb: 0.0,
      collisionProbMethod: None,
      ephemName1: None,
      esId1: None,
      ephemName2: None,
      esId2: None,
      relPosR: 0.0,
      relPosT: 0.0,
      relPosN: 0.0,
      relVelMag: 0.0,
      relVelR: 0.0,
      relVelT: 0.0,
      relVelN: 0.0,
      screenEntryTime: None,
      screenExitTime: None,
      screenVolumeX: 0.0,
      screenVolumeY: 0.0,
      screenVolumeZ: 0.0,
      volShape: None,
      volEntryTime: None,
      volExitTime: None,
      penetrationLevelSigma: 0.0,
      idStateVector1: None,
      lastObTime1: None,
      cdAoM1: 0.0,
      crAoM1: 0.0,
      thrustAccel1: 0.0,
      idStateVector2: None,
      lastObTime2: None,
      cdAoM2: 0.0,
      crAoM2: 0.0,
      thrustAccel2: 0.0,
      comments: None,
      ccir: None,
      concernNotes: None,
      stateDeptNotified: false,
      ownerContacted: false,
      rawFileURI: None,
      messageFor: None,
      messageId: None,
      uvwWarn: false,
      smallRelVelWarning: false,
      largeRelPosWarning: false,
      smallCovWarning: false,
      largeCovWarning: false,
      transactionId: None,
      source: None,
      origin: None,
      originator: None,
      eventId: None,
      descriptor: None,
      tags: None,
      dataMode: Conjunction_Full_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
      stateVector1: None,
      stateVector2: None,
      satNo1: 0,
      satNo2: 0,
      onOrbit1: None,
      onOrbit2: None,
      origIdOnOrbit1: None,
      origIdOnOrbit2: None,
      origNetwork: None,
    }
  }
}

pub struct Conjunction_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Conjunction_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idOnOrbit1(&mut self, idOnOrbit1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_IDONORBIT1, idOnOrbit1);
  }
  #[inline]
  pub fn add_idOnOrbit2(&mut self, idOnOrbit2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_IDONORBIT2, idOnOrbit2);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_tca(&mut self, tca: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_TCA, tca);
  }
  #[inline]
  pub fn add_missDistance(&mut self, missDistance: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_MISSDISTANCE, missDistance, 0.0);
  }
  #[inline]
  pub fn add_collisionProb(&mut self, collisionProb: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_COLLISIONPROB, collisionProb, 0.0);
  }
  #[inline]
  pub fn add_collisionProbMethod(&mut self, collisionProbMethod: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_COLLISIONPROBMETHOD, collisionProbMethod);
  }
  #[inline]
  pub fn add_ephemName1(&mut self, ephemName1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_EPHEMNAME1, ephemName1);
  }
  #[inline]
  pub fn add_esId1(&mut self, esId1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_ESID1, esId1);
  }
  #[inline]
  pub fn add_ephemName2(&mut self, ephemName2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_EPHEMNAME2, ephemName2);
  }
  #[inline]
  pub fn add_esId2(&mut self, esId2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_ESID2, esId2);
  }
  #[inline]
  pub fn add_relPosR(&mut self, relPosR: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_RELPOSR, relPosR, 0.0);
  }
  #[inline]
  pub fn add_relPosT(&mut self, relPosT: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_RELPOST, relPosT, 0.0);
  }
  #[inline]
  pub fn add_relPosN(&mut self, relPosN: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_RELPOSN, relPosN, 0.0);
  }
  #[inline]
  pub fn add_relVelMag(&mut self, relVelMag: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_RELVELMAG, relVelMag, 0.0);
  }
  #[inline]
  pub fn add_relVelR(&mut self, relVelR: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_RELVELR, relVelR, 0.0);
  }
  #[inline]
  pub fn add_relVelT(&mut self, relVelT: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_RELVELT, relVelT, 0.0);
  }
  #[inline]
  pub fn add_relVelN(&mut self, relVelN: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_RELVELN, relVelN, 0.0);
  }
  #[inline]
  pub fn add_screenEntryTime(&mut self, screenEntryTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_SCREENENTRYTIME, screenEntryTime);
  }
  #[inline]
  pub fn add_screenExitTime(&mut self, screenExitTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_SCREENEXITTIME, screenExitTime);
  }
  #[inline]
  pub fn add_screenVolumeX(&mut self, screenVolumeX: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_SCREENVOLUMEX, screenVolumeX, 0.0);
  }
  #[inline]
  pub fn add_screenVolumeY(&mut self, screenVolumeY: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_SCREENVOLUMEY, screenVolumeY, 0.0);
  }
  #[inline]
  pub fn add_screenVolumeZ(&mut self, screenVolumeZ: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_SCREENVOLUMEZ, screenVolumeZ, 0.0);
  }
  #[inline]
  pub fn add_volShape(&mut self, volShape: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_VOLSHAPE, volShape);
  }
  #[inline]
  pub fn add_volEntryTime(&mut self, volEntryTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_VOLENTRYTIME, volEntryTime);
  }
  #[inline]
  pub fn add_volExitTime(&mut self, volExitTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_VOLEXITTIME, volExitTime);
  }
  #[inline]
  pub fn add_penetrationLevelSigma(&mut self, penetrationLevelSigma: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_PENETRATIONLEVELSIGMA, penetrationLevelSigma, 0.0);
  }
  #[inline]
  pub fn add_idStateVector1(&mut self, idStateVector1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_IDSTATEVECTOR1, idStateVector1);
  }
  #[inline]
  pub fn add_lastObTime1(&mut self, lastObTime1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_LASTOBTIME1, lastObTime1);
  }
  #[inline]
  pub fn add_cdAoM1(&mut self, cdAoM1: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_CDAOM1, cdAoM1, 0.0);
  }
  #[inline]
  pub fn add_crAoM1(&mut self, crAoM1: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_CRAOM1, crAoM1, 0.0);
  }
  #[inline]
  pub fn add_thrustAccel1(&mut self, thrustAccel1: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_THRUSTACCEL1, thrustAccel1, 0.0);
  }
  #[inline]
  pub fn add_idStateVector2(&mut self, idStateVector2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_IDSTATEVECTOR2, idStateVector2);
  }
  #[inline]
  pub fn add_lastObTime2(&mut self, lastObTime2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_LASTOBTIME2, lastObTime2);
  }
  #[inline]
  pub fn add_cdAoM2(&mut self, cdAoM2: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_CDAOM2, cdAoM2, 0.0);
  }
  #[inline]
  pub fn add_crAoM2(&mut self, crAoM2: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_CRAOM2, crAoM2, 0.0);
  }
  #[inline]
  pub fn add_thrustAccel2(&mut self, thrustAccel2: f64) {
    self.fbb_.push_slot::<f64>(Conjunction_Full::VT_THRUSTACCEL2, thrustAccel2, 0.0);
  }
  #[inline]
  pub fn add_comments(&mut self, comments: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_COMMENTS, comments);
  }
  #[inline]
  pub fn add_ccir(&mut self, ccir: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_CCIR, ccir);
  }
  #[inline]
  pub fn add_concernNotes(&mut self, concernNotes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_CONCERNNOTES, concernNotes);
  }
  #[inline]
  pub fn add_stateDeptNotified(&mut self, stateDeptNotified: bool) {
    self.fbb_.push_slot::<bool>(Conjunction_Full::VT_STATEDEPTNOTIFIED, stateDeptNotified, false);
  }
  #[inline]
  pub fn add_ownerContacted(&mut self, ownerContacted: bool) {
    self.fbb_.push_slot::<bool>(Conjunction_Full::VT_OWNERCONTACTED, ownerContacted, false);
  }
  #[inline]
  pub fn add_rawFileURI(&mut self, rawFileURI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_RAWFILEURI, rawFileURI);
  }
  #[inline]
  pub fn add_messageFor(&mut self, messageFor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_MESSAGEFOR, messageFor);
  }
  #[inline]
  pub fn add_messageId(&mut self, messageId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_MESSAGEID, messageId);
  }
  #[inline]
  pub fn add_uvwWarn(&mut self, uvwWarn: bool) {
    self.fbb_.push_slot::<bool>(Conjunction_Full::VT_UVWWARN, uvwWarn, false);
  }
  #[inline]
  pub fn add_smallRelVelWarning(&mut self, smallRelVelWarning: bool) {
    self.fbb_.push_slot::<bool>(Conjunction_Full::VT_SMALLRELVELWARNING, smallRelVelWarning, false);
  }
  #[inline]
  pub fn add_largeRelPosWarning(&mut self, largeRelPosWarning: bool) {
    self.fbb_.push_slot::<bool>(Conjunction_Full::VT_LARGERELPOSWARNING, largeRelPosWarning, false);
  }
  #[inline]
  pub fn add_smallCovWarning(&mut self, smallCovWarning: bool) {
    self.fbb_.push_slot::<bool>(Conjunction_Full::VT_SMALLCOVWARNING, smallCovWarning, false);
  }
  #[inline]
  pub fn add_largeCovWarning(&mut self, largeCovWarning: bool) {
    self.fbb_.push_slot::<bool>(Conjunction_Full::VT_LARGECOVWARNING, largeCovWarning, false);
  }
  #[inline]
  pub fn add_transactionId(&mut self, transactionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_TRANSACTIONID, transactionId);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_originator(&mut self, originator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_ORIGINATOR, originator);
  }
  #[inline]
  pub fn add_eventId(&mut self, eventId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_EVENTID, eventId);
  }
  #[inline]
  pub fn add_descriptor(&mut self, descriptor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_DESCRIPTOR, descriptor);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Conjunction_Full_dataMode_Enum) {
    self.fbb_.push_slot::<Conjunction_Full_dataMode_Enum>(Conjunction_Full::VT_DATAMODE, dataMode, Conjunction_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_stateVector1(&mut self, stateVector1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_STATEVECTOR1, stateVector1);
  }
  #[inline]
  pub fn add_stateVector2(&mut self, stateVector2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_STATEVECTOR2, stateVector2);
  }
  #[inline]
  pub fn add_satNo1(&mut self, satNo1: i32) {
    self.fbb_.push_slot::<i32>(Conjunction_Full::VT_SATNO1, satNo1, 0);
  }
  #[inline]
  pub fn add_satNo2(&mut self, satNo2: i32) {
    self.fbb_.push_slot::<i32>(Conjunction_Full::VT_SATNO2, satNo2, 0);
  }
  #[inline]
  pub fn add_onOrbit1(&mut self, onOrbit1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_ONORBIT1, onOrbit1);
  }
  #[inline]
  pub fn add_onOrbit2(&mut self, onOrbit2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_ONORBIT2, onOrbit2);
  }
  #[inline]
  pub fn add_origIdOnOrbit1(&mut self, origIdOnOrbit1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_ORIGIDONORBIT1, origIdOnOrbit1);
  }
  #[inline]
  pub fn add_origIdOnOrbit2(&mut self, origIdOnOrbit2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_ORIGIDONORBIT2, origIdOnOrbit2);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Conjunction_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Conjunction_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Conjunction_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Conjunction_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Conjunction_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Conjunction_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idOnOrbit1", &self.idOnOrbit1());
      ds.field("idOnOrbit2", &self.idOnOrbit2());
      ds.field("type_", &self.type_());
      ds.field("tca", &self.tca());
      ds.field("missDistance", &self.missDistance());
      ds.field("collisionProb", &self.collisionProb());
      ds.field("collisionProbMethod", &self.collisionProbMethod());
      ds.field("ephemName1", &self.ephemName1());
      ds.field("esId1", &self.esId1());
      ds.field("ephemName2", &self.ephemName2());
      ds.field("esId2", &self.esId2());
      ds.field("relPosR", &self.relPosR());
      ds.field("relPosT", &self.relPosT());
      ds.field("relPosN", &self.relPosN());
      ds.field("relVelMag", &self.relVelMag());
      ds.field("relVelR", &self.relVelR());
      ds.field("relVelT", &self.relVelT());
      ds.field("relVelN", &self.relVelN());
      ds.field("screenEntryTime", &self.screenEntryTime());
      ds.field("screenExitTime", &self.screenExitTime());
      ds.field("screenVolumeX", &self.screenVolumeX());
      ds.field("screenVolumeY", &self.screenVolumeY());
      ds.field("screenVolumeZ", &self.screenVolumeZ());
      ds.field("volShape", &self.volShape());
      ds.field("volEntryTime", &self.volEntryTime());
      ds.field("volExitTime", &self.volExitTime());
      ds.field("penetrationLevelSigma", &self.penetrationLevelSigma());
      ds.field("idStateVector1", &self.idStateVector1());
      ds.field("lastObTime1", &self.lastObTime1());
      ds.field("cdAoM1", &self.cdAoM1());
      ds.field("crAoM1", &self.crAoM1());
      ds.field("thrustAccel1", &self.thrustAccel1());
      ds.field("idStateVector2", &self.idStateVector2());
      ds.field("lastObTime2", &self.lastObTime2());
      ds.field("cdAoM2", &self.cdAoM2());
      ds.field("crAoM2", &self.crAoM2());
      ds.field("thrustAccel2", &self.thrustAccel2());
      ds.field("comments", &self.comments());
      ds.field("ccir", &self.ccir());
      ds.field("concernNotes", &self.concernNotes());
      ds.field("stateDeptNotified", &self.stateDeptNotified());
      ds.field("ownerContacted", &self.ownerContacted());
      ds.field("rawFileURI", &self.rawFileURI());
      ds.field("messageFor", &self.messageFor());
      ds.field("messageId", &self.messageId());
      ds.field("uvwWarn", &self.uvwWarn());
      ds.field("smallRelVelWarning", &self.smallRelVelWarning());
      ds.field("largeRelPosWarning", &self.largeRelPosWarning());
      ds.field("smallCovWarning", &self.smallCovWarning());
      ds.field("largeCovWarning", &self.largeCovWarning());
      ds.field("transactionId", &self.transactionId());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("originator", &self.originator());
      ds.field("eventId", &self.eventId());
      ds.field("descriptor", &self.descriptor());
      ds.field("tags", &self.tags());
      ds.field("dataMode", &self.dataMode());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("stateVector1", &self.stateVector1());
      ds.field("stateVector2", &self.stateVector2());
      ds.field("satNo1", &self.satNo1());
      ds.field("satNo2", &self.satNo2());
      ds.field("onOrbit1", &self.onOrbit1());
      ds.field("onOrbit2", &self.onOrbit2());
      ds.field("origIdOnOrbit1", &self.origIdOnOrbit1());
      ds.field("origIdOnOrbit2", &self.origIdOnOrbit2());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Conjunction_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idOnOrbit1: Option<String>,
  pub idOnOrbit2: Option<String>,
  pub type_: Option<String>,
  pub tca: Option<String>,
  pub missDistance: f64,
  pub collisionProb: f64,
  pub collisionProbMethod: Option<String>,
  pub ephemName1: Option<String>,
  pub esId1: Option<String>,
  pub ephemName2: Option<String>,
  pub esId2: Option<String>,
  pub relPosR: f64,
  pub relPosT: f64,
  pub relPosN: f64,
  pub relVelMag: f64,
  pub relVelR: f64,
  pub relVelT: f64,
  pub relVelN: f64,
  pub screenEntryTime: Option<String>,
  pub screenExitTime: Option<String>,
  pub screenVolumeX: f64,
  pub screenVolumeY: f64,
  pub screenVolumeZ: f64,
  pub volShape: Option<String>,
  pub volEntryTime: Option<String>,
  pub volExitTime: Option<String>,
  pub penetrationLevelSigma: f64,
  pub idStateVector1: Option<String>,
  pub lastObTime1: Option<String>,
  pub cdAoM1: f64,
  pub crAoM1: f64,
  pub thrustAccel1: f64,
  pub idStateVector2: Option<String>,
  pub lastObTime2: Option<String>,
  pub cdAoM2: f64,
  pub crAoM2: f64,
  pub thrustAccel2: f64,
  pub comments: Option<String>,
  pub ccir: Option<String>,
  pub concernNotes: Option<String>,
  pub stateDeptNotified: bool,
  pub ownerContacted: bool,
  pub rawFileURI: Option<String>,
  pub messageFor: Option<String>,
  pub messageId: Option<String>,
  pub uvwWarn: bool,
  pub smallRelVelWarning: bool,
  pub largeRelPosWarning: bool,
  pub smallCovWarning: bool,
  pub largeCovWarning: bool,
  pub transactionId: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub originator: Option<String>,
  pub eventId: Option<String>,
  pub descriptor: Option<String>,
  pub tags: Option<Vec<String>>,
  pub dataMode: Conjunction_Full_dataMode_Enum,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub stateVector1: Option<String>,
  pub stateVector2: Option<String>,
  pub satNo1: i32,
  pub satNo2: i32,
  pub onOrbit1: Option<String>,
  pub onOrbit2: Option<String>,
  pub origIdOnOrbit1: Option<String>,
  pub origIdOnOrbit2: Option<String>,
  pub origNetwork: Option<String>,
}
impl Default for Conjunction_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idOnOrbit1: None,
      idOnOrbit2: None,
      type_: None,
      tca: None,
      missDistance: 0.0,
      collisionProb: 0.0,
      collisionProbMethod: None,
      ephemName1: None,
      esId1: None,
      ephemName2: None,
      esId2: None,
      relPosR: 0.0,
      relPosT: 0.0,
      relPosN: 0.0,
      relVelMag: 0.0,
      relVelR: 0.0,
      relVelT: 0.0,
      relVelN: 0.0,
      screenEntryTime: None,
      screenExitTime: None,
      screenVolumeX: 0.0,
      screenVolumeY: 0.0,
      screenVolumeZ: 0.0,
      volShape: None,
      volEntryTime: None,
      volExitTime: None,
      penetrationLevelSigma: 0.0,
      idStateVector1: None,
      lastObTime1: None,
      cdAoM1: 0.0,
      crAoM1: 0.0,
      thrustAccel1: 0.0,
      idStateVector2: None,
      lastObTime2: None,
      cdAoM2: 0.0,
      crAoM2: 0.0,
      thrustAccel2: 0.0,
      comments: None,
      ccir: None,
      concernNotes: None,
      stateDeptNotified: false,
      ownerContacted: false,
      rawFileURI: None,
      messageFor: None,
      messageId: None,
      uvwWarn: false,
      smallRelVelWarning: false,
      largeRelPosWarning: false,
      smallCovWarning: false,
      largeCovWarning: false,
      transactionId: None,
      source: None,
      origin: None,
      originator: None,
      eventId: None,
      descriptor: None,
      tags: None,
      dataMode: Conjunction_Full_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
      stateVector1: None,
      stateVector2: None,
      satNo1: 0,
      satNo2: 0,
      onOrbit1: None,
      onOrbit2: None,
      origIdOnOrbit1: None,
      origIdOnOrbit2: None,
      origNetwork: None,
    }
  }
}
impl Conjunction_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Conjunction_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit1 = self.idOnOrbit1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit2 = self.idOnOrbit2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tca = self.tca.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let missDistance = self.missDistance;
    let collisionProb = self.collisionProb;
    let collisionProbMethod = self.collisionProbMethod.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ephemName1 = self.ephemName1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let esId1 = self.esId1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ephemName2 = self.ephemName2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let esId2 = self.esId2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let relPosR = self.relPosR;
    let relPosT = self.relPosT;
    let relPosN = self.relPosN;
    let relVelMag = self.relVelMag;
    let relVelR = self.relVelR;
    let relVelT = self.relVelT;
    let relVelN = self.relVelN;
    let screenEntryTime = self.screenEntryTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let screenExitTime = self.screenExitTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let screenVolumeX = self.screenVolumeX;
    let screenVolumeY = self.screenVolumeY;
    let screenVolumeZ = self.screenVolumeZ;
    let volShape = self.volShape.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let volEntryTime = self.volEntryTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let volExitTime = self.volExitTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let penetrationLevelSigma = self.penetrationLevelSigma;
    let idStateVector1 = self.idStateVector1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lastObTime1 = self.lastObTime1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cdAoM1 = self.cdAoM1;
    let crAoM1 = self.crAoM1;
    let thrustAccel1 = self.thrustAccel1;
    let idStateVector2 = self.idStateVector2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lastObTime2 = self.lastObTime2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cdAoM2 = self.cdAoM2;
    let crAoM2 = self.crAoM2;
    let thrustAccel2 = self.thrustAccel2;
    let comments = self.comments.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ccir = self.ccir.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let concernNotes = self.concernNotes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stateDeptNotified = self.stateDeptNotified;
    let ownerContacted = self.ownerContacted;
    let rawFileURI = self.rawFileURI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let messageFor = self.messageFor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let messageId = self.messageId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let uvwWarn = self.uvwWarn;
    let smallRelVelWarning = self.smallRelVelWarning;
    let largeRelPosWarning = self.largeRelPosWarning;
    let smallCovWarning = self.smallCovWarning;
    let largeCovWarning = self.largeCovWarning;
    let transactionId = self.transactionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let originator = self.originator.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eventId = self.eventId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let descriptor = self.descriptor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let dataMode = self.dataMode;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stateVector1 = self.stateVector1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stateVector2 = self.stateVector2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo1 = self.satNo1;
    let satNo2 = self.satNo2;
    let onOrbit1 = self.onOrbit1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let onOrbit2 = self.onOrbit2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origIdOnOrbit1 = self.origIdOnOrbit1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origIdOnOrbit2 = self.origIdOnOrbit2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Conjunction_Full::create(_fbb, &Conjunction_FullArgs{
      id,
      classificationMarking,
      idOnOrbit1,
      idOnOrbit2,
      type_,
      tca,
      missDistance,
      collisionProb,
      collisionProbMethod,
      ephemName1,
      esId1,
      ephemName2,
      esId2,
      relPosR,
      relPosT,
      relPosN,
      relVelMag,
      relVelR,
      relVelT,
      relVelN,
      screenEntryTime,
      screenExitTime,
      screenVolumeX,
      screenVolumeY,
      screenVolumeZ,
      volShape,
      volEntryTime,
      volExitTime,
      penetrationLevelSigma,
      idStateVector1,
      lastObTime1,
      cdAoM1,
      crAoM1,
      thrustAccel1,
      idStateVector2,
      lastObTime2,
      cdAoM2,
      crAoM2,
      thrustAccel2,
      comments,
      ccir,
      concernNotes,
      stateDeptNotified,
      ownerContacted,
      rawFileURI,
      messageFor,
      messageId,
      uvwWarn,
      smallRelVelWarning,
      largeRelPosWarning,
      smallCovWarning,
      largeCovWarning,
      transactionId,
      source,
      origin,
      originator,
      eventId,
      descriptor,
      tags,
      dataMode,
      createdAt,
      createdBy,
      stateVector1,
      stateVector2,
      satNo1,
      satNo2,
      onOrbit1,
      onOrbit2,
      origIdOnOrbit1,
      origIdOnOrbit2,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Conjunction_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_conjunction_full_unchecked`.
pub fn root_as_conjunction_full(buf: &[u8]) -> Result<Conjunction_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Conjunction_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Conjunction_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_conjunction_full_unchecked`.
pub fn size_prefixed_root_as_conjunction_full(buf: &[u8]) -> Result<Conjunction_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Conjunction_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Conjunction_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_conjunction_full_unchecked`.
pub fn root_as_conjunction_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Conjunction_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Conjunction_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Conjunction_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_conjunction_full_unchecked`.
pub fn size_prefixed_root_as_conjunction_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Conjunction_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Conjunction_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Conjunction_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Conjunction_Full`.
pub unsafe fn root_as_conjunction_full_unchecked(buf: &[u8]) -> Conjunction_Full {
  flatbuffers::root_unchecked::<Conjunction_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Conjunction_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Conjunction_Full`.
pub unsafe fn size_prefixed_root_as_conjunction_full_unchecked(buf: &[u8]) -> Conjunction_Full {
  flatbuffers::size_prefixed_root_unchecked::<Conjunction_Full>(buf)
}
pub const CONJUNCTION_FULL_IDENTIFIER: &str = "CONJ";

#[inline]
pub fn conjunction_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CONJUNCTION_FULL_IDENTIFIER, false)
}

#[inline]
pub fn conjunction_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CONJUNCTION_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_conjunction_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Conjunction_Full<'a>>) {
  fbb.finish(root, Some(CONJUNCTION_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_conjunction_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Conjunction_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(CONJUNCTION_FULL_IDENTIFIER));
}
