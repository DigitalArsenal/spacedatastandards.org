// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VESSEL_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VESSEL_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VESSEL_FULL_DATA_MODE_ENUM: [Vessel_Full_dataMode_Enum; 4] = [
  Vessel_Full_dataMode_Enum::REAL,
  Vessel_Full_dataMode_Enum::TEST,
  Vessel_Full_dataMode_Enum::SIMULATED,
  Vessel_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Vessel_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Vessel_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Vessel_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Vessel_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Vessel_Full_dataMode_Enum {
    type Output = Vessel_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Vessel_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Vessel_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vessel_Full_dataMode_Enum {}
pub enum Vessel_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// This service provides operations for manipulation and querying of maritime Vessel data. Vessel contains the static data of the specific vessel: mmsi, cruise speed, max speed, etc.
pub struct Vessel_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Vessel_Full<'a> {
  type Inner = Vessel_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Vessel_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_ENTITY: flatbuffers::VOffsetT = 8;
  pub const VT_IDENTITY: flatbuffers::VOffsetT = 10;
  pub const VT_ALTVESSELID: flatbuffers::VOffsetT = 12;
  pub const VT_IDORGANIZATION: flatbuffers::VOffsetT = 14;
  pub const VT_VESSELNAME: flatbuffers::VOffsetT = 16;
  pub const VT_VESSELTYPE: flatbuffers::VOffsetT = 18;
  pub const VT_VESSELCLASS: flatbuffers::VOffsetT = 20;
  pub const VT_VESSELDESCRIPTION: flatbuffers::VOffsetT = 22;
  pub const VT_SCONUM: flatbuffers::VOffsetT = 24;
  pub const VT_IMON: flatbuffers::VOffsetT = 26;
  pub const VT_MMSI: flatbuffers::VOffsetT = 28;
  pub const VT_CALLSIGN: flatbuffers::VOffsetT = 30;
  pub const VT_VESSELFLAG: flatbuffers::VOffsetT = 32;
  pub const VT_YEARBUILT: flatbuffers::VOffsetT = 34;
  pub const VT_VESSELBUILDER: flatbuffers::VOffsetT = 36;
  pub const VT_STATUS: flatbuffers::VOffsetT = 38;
  pub const VT_FIRSTSEEN: flatbuffers::VOffsetT = 40;
  pub const VT_LENGTH: flatbuffers::VOffsetT = 42;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 44;
  pub const VT_MAXDRAUGHT: flatbuffers::VOffsetT = 46;
  pub const VT_VSLWT: flatbuffers::VOffsetT = 48;
  pub const VT_MAXSPEED: flatbuffers::VOffsetT = 50;
  pub const VT_STERNTYPE: flatbuffers::VOffsetT = 52;
  pub const VT_NUMBLADES: flatbuffers::VOffsetT = 54;
  pub const VT_NUMSHAFTS: flatbuffers::VOffsetT = 56;
  pub const VT_PROPTYPE: flatbuffers::VOffsetT = 58;
  pub const VT_HULLNUM: flatbuffers::VOffsetT = 60;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 62;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 64;
  pub const VT_UPDATEDAT: flatbuffers::VOffsetT = 66;
  pub const VT_UPDATEDBY: flatbuffers::VOffsetT = 68;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 70;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 72;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 74;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 76;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 78;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Vessel_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Vessel_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<Vessel_Full<'bldr>> {
    let mut builder = Vessel_FullBuilder::new(_fbb);
    builder.add_maxSpeed(args.maxSpeed);
    builder.add_vslWt(args.vslWt);
    builder.add_maxDraught(args.maxDraught);
    builder.add_width(args.width);
    builder.add_length(args.length);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.updatedBy { builder.add_updatedBy(x); }
    if let Some(x) = args.updatedAt { builder.add_updatedAt(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.hullNum { builder.add_hullNum(x); }
    if let Some(x) = args.propType { builder.add_propType(x); }
    builder.add_numShafts(args.numShafts);
    builder.add_numBlades(args.numBlades);
    if let Some(x) = args.sternType { builder.add_sternType(x); }
    if let Some(x) = args.firstSeen { builder.add_firstSeen(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    if let Some(x) = args.vesselBuilder { builder.add_vesselBuilder(x); }
    if let Some(x) = args.yearBuilt { builder.add_yearBuilt(x); }
    if let Some(x) = args.vesselFlag { builder.add_vesselFlag(x); }
    if let Some(x) = args.callsign { builder.add_callsign(x); }
    if let Some(x) = args.mmsi { builder.add_mmsi(x); }
    builder.add_imon(args.imon);
    if let Some(x) = args.sconum { builder.add_sconum(x); }
    if let Some(x) = args.vesselDescription { builder.add_vesselDescription(x); }
    if let Some(x) = args.vesselClass { builder.add_vesselClass(x); }
    if let Some(x) = args.vesselType { builder.add_vesselType(x); }
    if let Some(x) = args.vesselName { builder.add_vesselName(x); }
    if let Some(x) = args.idOrganization { builder.add_idOrganization(x); }
    if let Some(x) = args.altVesselId { builder.add_altVesselId(x); }
    if let Some(x) = args.idEntity { builder.add_idEntity(x); }
    if let Some(x) = args.entity { builder.add_entity(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> Vessel_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let entity = self.entity().map(|x| {
      x.to_string()
    });
    let idEntity = self.idEntity().map(|x| {
      x.to_string()
    });
    let altVesselId = self.altVesselId().map(|x| {
      x.to_string()
    });
    let idOrganization = self.idOrganization().map(|x| {
      x.to_string()
    });
    let vesselName = self.vesselName().map(|x| {
      x.to_string()
    });
    let vesselType = self.vesselType().map(|x| {
      x.to_string()
    });
    let vesselClass = self.vesselClass().map(|x| {
      x.to_string()
    });
    let vesselDescription = self.vesselDescription().map(|x| {
      x.to_string()
    });
    let sconum = self.sconum().map(|x| {
      x.to_string()
    });
    let imon = self.imon();
    let mmsi = self.mmsi().map(|x| {
      x.to_string()
    });
    let callsign = self.callsign().map(|x| {
      x.to_string()
    });
    let vesselFlag = self.vesselFlag().map(|x| {
      x.to_string()
    });
    let yearBuilt = self.yearBuilt().map(|x| {
      x.to_string()
    });
    let vesselBuilder = self.vesselBuilder().map(|x| {
      x.to_string()
    });
    let status = self.status().map(|x| {
      x.to_string()
    });
    let firstSeen = self.firstSeen().map(|x| {
      x.to_string()
    });
    let length = self.length();
    let width = self.width();
    let maxDraught = self.maxDraught();
    let vslWt = self.vslWt();
    let maxSpeed = self.maxSpeed();
    let sternType = self.sternType().map(|x| {
      x.to_string()
    });
    let numBlades = self.numBlades();
    let numShafts = self.numShafts();
    let propType = self.propType().map(|x| {
      x.to_string()
    });
    let hullNum = self.hullNum().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let updatedAt = self.updatedAt().map(|x| {
      x.to_string()
    });
    let updatedBy = self.updatedBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    Vessel_FullT {
      id,
      classificationMarking,
      entity,
      idEntity,
      altVesselId,
      idOrganization,
      vesselName,
      vesselType,
      vesselClass,
      vesselDescription,
      sconum,
      imon,
      mmsi,
      callsign,
      vesselFlag,
      yearBuilt,
      vesselBuilder,
      status,
      firstSeen,
      length,
      width,
      maxDraught,
      vslWt,
      maxSpeed,
      sternType,
      numBlades,
      numShafts,
      propType,
      hullNum,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      sourceDL,
      origin,
      dataMode,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: 0167f577-e06c-358e-85aa-0a07a730bdd0
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn entity(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_ENTITY, None)}
  }
  /// Unique identifier of the parent entity. idEntity is required for Put.
  /// Example: /// Example: ENTITY-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idEntity(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_IDENTITY, None)}
  }
  /// The original source Id for this vessel.
  /// Example: /// Example: 590b5194fc32e75dd00682ba
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn altVesselId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_ALTVESSELID, None)}
  }
  /// The UDL ID of the organization that owns the vessel.
  /// Example: /// Example: 0147f777-w09a-835f-85aa-0a07a730fgg0
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOrganization(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_IDORGANIZATION, None)}
  }
  /// The name of this vessel. Vessel names that exceed the AIS 20 character are shortened (not truncated) to 15 character-spaces, followed by an underscore and the last 4 characters-spaces of the vessel full name.
  /// Example: /// Example: DORNUM
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn vesselName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_VESSELNAME, None)}
  }
  /// The reported ship type (e.g. Passenger, Tanker, Cargo, Other, etc.).
  /// Example: /// Example: Passenger
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn vesselType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_VESSELTYPE, None)}
  }
  /// The common name for a group of ships with similar design, usually named for the first vessel of the class.
  /// Example: /// Example: Nimitz
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn vesselClass(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_VESSELCLASS, None)}
  }
  /// Further description or explanation of the vessel or type.
  /// Example: /// Example: Search and Rescue Vessel
  /// Constraints: Minimum length = 0, Maximum length = 100
  #[inline]
  pub fn vesselDescription(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_VESSELDESCRIPTION, None)}
  }
  /// The Ship Control Number (SCONUM) is a naval vessel identification number (alphanumeric code) assigned by the Office of Naval Intelligence. SCONUM is sometimes referred to as NOIC ID. SCONUMs are typically of the form A#####, where A is an alpha character and # is numerical.
  /// Example: /// Example: B45524
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn sconum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_SCONUM, None)}
  }
  /// The International Maritime Organization Number of the vessel. IMON is a seven-digit number that uniquely identifies the vessel.
  /// Example: /// Example: 9566356
  /// Constraints: No constraints specified.
  #[inline]
  pub fn imon(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Vessel_Full::VT_IMON, Some(0)).unwrap()}
  }
  /// The Maritime Mobile Service Identity of the vessel. MMSI is a nine-digit number that identifies the transmitter station of the vessel.
  /// Example: /// Example: 416450000
  /// Constraints: Minimum length = 0, Maximum length = 9
  #[inline]
  pub fn mmsi(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_MMSI, None)}
  }
  /// A uniquely designated identifier for the vessel's transmitter station. All radio transmissions must be individually identified by the call sign. Merchant and naval vessels are assigned call signs by their national licensing authorities.
  /// Example: /// Example: V2OZ
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn callsign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_CALLSIGN, None)}
  }
  /// The flag of the subject vessel.
  /// Example: /// Example: United States
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn vesselFlag(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_VESSELFLAG, None)}
  }
  /// Year the vessel went into service.
  /// Example: /// Example: 2014
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn yearBuilt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_YEARBUILT, None)}
  }
  /// The shipbuilder who built this vessel.
  /// Example: /// Example: Samsung Heavy Inds - Geoje
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn vesselBuilder(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_VESSELBUILDER, None)}
  }
  /// The status of this vessel.
  /// Example: /// Example: In Service/Commission
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn status(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_STATUS, None)}
  }
  /// The date this vessel was first seen.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn firstSeen(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_FIRSTSEEN, None)}
  }
  /// The overall length of the vessel, in meters. A value of 511 indicates a vessel length of 511 meters or greater.
  /// Example: /// Example: 511.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn length(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Vessel_Full::VT_LENGTH, Some(0.0)).unwrap()}
  }
  /// The breadth of the vessel, in meters. A value of 63 indicates a vessel breadth of 63 meters or greater.
  /// Example: /// Example: 24.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Vessel_Full::VT_WIDTH, Some(0.0)).unwrap()}
  }
  /// The maximum static draught, in meters, of the vessel defined as the distance between the ship’s keel and the waterline of the vessel.
  /// Example: /// Example: 21.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxDraught(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Vessel_Full::VT_MAXDRAUGHT, Some(0.0)).unwrap()}
  }
  /// The weight in tons, of this vessel.
  /// Example: /// Example: 3423.76
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vslWt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Vessel_Full::VT_VSLWT, Some(0.0)).unwrap()}
  }
  /// The maximum possible speed of this vessel in meters per second.
  /// Example: /// Example: 32.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxSpeed(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Vessel_Full::VT_MAXSPEED, Some(0.0)).unwrap()}
  }
  /// The stern type code (Counter, Cruiser) associated with this vessel.
  /// Example: /// Example: Cruiser
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn sternType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_STERNTYPE, None)}
  }
  /// The number of blades per shaft for this vessel.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numBlades(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Vessel_Full::VT_NUMBLADES, Some(0)).unwrap()}
  }
  /// The number of shafts on this vessel.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numShafts(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Vessel_Full::VT_NUMSHAFTS, Some(0)).unwrap()}
  }
  /// The type of propulsion employed by this vessel.
  /// Example: /// Example: Diesel
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn propType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_PROPTYPE, None)}
  }
  /// The vessel hull number designation of this maritime vessel. The hull number is a 1-6 character alphanumeric entry assigned to a ship and painted on the hull.
  /// Example: /// Example: A30081
  /// Constraints: Minimum length = 0, Maximum length = 7
  #[inline]
  pub fn hullNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_HULLNUM, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_CREATEDBY, None)}
  }
  /// Time the row was updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn updatedAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_UPDATEDAT, None)}
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn updatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_UPDATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_SOURCE, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_SOURCEDL, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn dataMode(&self) -> Vessel_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vessel_Full_dataMode_Enum>(Vessel_Full::VT_DATAMODE, Some(Vessel_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Vessel_Full::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for Vessel_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("entity", Self::VT_ENTITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idEntity", Self::VT_IDENTITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altVesselId", Self::VT_ALTVESSELID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOrganization", Self::VT_IDORGANIZATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("vesselName", Self::VT_VESSELNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("vesselType", Self::VT_VESSELTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("vesselClass", Self::VT_VESSELCLASS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("vesselDescription", Self::VT_VESSELDESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sconum", Self::VT_SCONUM, false)?
     .visit_field::<i32>("imon", Self::VT_IMON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mmsi", Self::VT_MMSI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("callsign", Self::VT_CALLSIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("vesselFlag", Self::VT_VESSELFLAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("yearBuilt", Self::VT_YEARBUILT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("vesselBuilder", Self::VT_VESSELBUILDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("firstSeen", Self::VT_FIRSTSEEN, false)?
     .visit_field::<f64>("length", Self::VT_LENGTH, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<f64>("maxDraught", Self::VT_MAXDRAUGHT, false)?
     .visit_field::<f64>("vslWt", Self::VT_VSLWT, false)?
     .visit_field::<f64>("maxSpeed", Self::VT_MAXSPEED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sternType", Self::VT_STERNTYPE, false)?
     .visit_field::<i32>("numBlades", Self::VT_NUMBLADES, false)?
     .visit_field::<i32>("numShafts", Self::VT_NUMSHAFTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("propType", Self::VT_PROPTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hullNum", Self::VT_HULLNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedAt", Self::VT_UPDATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("updatedBy", Self::VT_UPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<Vessel_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct Vessel_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub entity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idEntity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altVesselId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOrganization: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vesselName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vesselType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vesselClass: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vesselDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sconum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub imon: i32,
    pub mmsi: Option<flatbuffers::WIPOffset<&'a str>>,
    pub callsign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vesselFlag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub yearBuilt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vesselBuilder: Option<flatbuffers::WIPOffset<&'a str>>,
    pub status: Option<flatbuffers::WIPOffset<&'a str>>,
    pub firstSeen: Option<flatbuffers::WIPOffset<&'a str>>,
    pub length: f64,
    pub width: f64,
    pub maxDraught: f64,
    pub vslWt: f64,
    pub maxSpeed: f64,
    pub sternType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub numBlades: i32,
    pub numShafts: i32,
    pub propType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hullNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: Vessel_Full_dataMode_Enum,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Vessel_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    Vessel_FullArgs {
      id: None,
      classificationMarking: None,
      entity: None,
      idEntity: None,
      altVesselId: None,
      idOrganization: None,
      vesselName: None,
      vesselType: None,
      vesselClass: None,
      vesselDescription: None,
      sconum: None,
      imon: 0,
      mmsi: None,
      callsign: None,
      vesselFlag: None,
      yearBuilt: None,
      vesselBuilder: None,
      status: None,
      firstSeen: None,
      length: 0.0,
      width: 0.0,
      maxDraught: 0.0,
      vslWt: 0.0,
      maxSpeed: 0.0,
      sternType: None,
      numBlades: 0,
      numShafts: 0,
      propType: None,
      hullNum: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      sourceDL: None,
      origin: None,
      dataMode: Vessel_Full_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}

pub struct Vessel_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Vessel_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_entity(&mut self, entity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_ENTITY, entity);
  }
  #[inline]
  pub fn add_idEntity(&mut self, idEntity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_IDENTITY, idEntity);
  }
  #[inline]
  pub fn add_altVesselId(&mut self, altVesselId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_ALTVESSELID, altVesselId);
  }
  #[inline]
  pub fn add_idOrganization(&mut self, idOrganization: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_IDORGANIZATION, idOrganization);
  }
  #[inline]
  pub fn add_vesselName(&mut self, vesselName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_VESSELNAME, vesselName);
  }
  #[inline]
  pub fn add_vesselType(&mut self, vesselType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_VESSELTYPE, vesselType);
  }
  #[inline]
  pub fn add_vesselClass(&mut self, vesselClass: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_VESSELCLASS, vesselClass);
  }
  #[inline]
  pub fn add_vesselDescription(&mut self, vesselDescription: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_VESSELDESCRIPTION, vesselDescription);
  }
  #[inline]
  pub fn add_sconum(&mut self, sconum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_SCONUM, sconum);
  }
  #[inline]
  pub fn add_imon(&mut self, imon: i32) {
    self.fbb_.push_slot::<i32>(Vessel_Full::VT_IMON, imon, 0);
  }
  #[inline]
  pub fn add_mmsi(&mut self, mmsi: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_MMSI, mmsi);
  }
  #[inline]
  pub fn add_callsign(&mut self, callsign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_CALLSIGN, callsign);
  }
  #[inline]
  pub fn add_vesselFlag(&mut self, vesselFlag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_VESSELFLAG, vesselFlag);
  }
  #[inline]
  pub fn add_yearBuilt(&mut self, yearBuilt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_YEARBUILT, yearBuilt);
  }
  #[inline]
  pub fn add_vesselBuilder(&mut self, vesselBuilder: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_VESSELBUILDER, vesselBuilder);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_STATUS, status);
  }
  #[inline]
  pub fn add_firstSeen(&mut self, firstSeen: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_FIRSTSEEN, firstSeen);
  }
  #[inline]
  pub fn add_length(&mut self, length: f64) {
    self.fbb_.push_slot::<f64>(Vessel_Full::VT_LENGTH, length, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(Vessel_Full::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_maxDraught(&mut self, maxDraught: f64) {
    self.fbb_.push_slot::<f64>(Vessel_Full::VT_MAXDRAUGHT, maxDraught, 0.0);
  }
  #[inline]
  pub fn add_vslWt(&mut self, vslWt: f64) {
    self.fbb_.push_slot::<f64>(Vessel_Full::VT_VSLWT, vslWt, 0.0);
  }
  #[inline]
  pub fn add_maxSpeed(&mut self, maxSpeed: f64) {
    self.fbb_.push_slot::<f64>(Vessel_Full::VT_MAXSPEED, maxSpeed, 0.0);
  }
  #[inline]
  pub fn add_sternType(&mut self, sternType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_STERNTYPE, sternType);
  }
  #[inline]
  pub fn add_numBlades(&mut self, numBlades: i32) {
    self.fbb_.push_slot::<i32>(Vessel_Full::VT_NUMBLADES, numBlades, 0);
  }
  #[inline]
  pub fn add_numShafts(&mut self, numShafts: i32) {
    self.fbb_.push_slot::<i32>(Vessel_Full::VT_NUMSHAFTS, numShafts, 0);
  }
  #[inline]
  pub fn add_propType(&mut self, propType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_PROPTYPE, propType);
  }
  #[inline]
  pub fn add_hullNum(&mut self, hullNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_HULLNUM, hullNum);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_updatedAt(&mut self, updatedAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_UPDATEDAT, updatedAt);
  }
  #[inline]
  pub fn add_updatedBy(&mut self, updatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_UPDATEDBY, updatedBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Vessel_Full_dataMode_Enum) {
    self.fbb_.push_slot::<Vessel_Full_dataMode_Enum>(Vessel_Full::VT_DATAMODE, dataMode, Vessel_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Vessel_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Vessel_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Vessel_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Vessel_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Vessel_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Vessel_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("entity", &self.entity());
      ds.field("idEntity", &self.idEntity());
      ds.field("altVesselId", &self.altVesselId());
      ds.field("idOrganization", &self.idOrganization());
      ds.field("vesselName", &self.vesselName());
      ds.field("vesselType", &self.vesselType());
      ds.field("vesselClass", &self.vesselClass());
      ds.field("vesselDescription", &self.vesselDescription());
      ds.field("sconum", &self.sconum());
      ds.field("imon", &self.imon());
      ds.field("mmsi", &self.mmsi());
      ds.field("callsign", &self.callsign());
      ds.field("vesselFlag", &self.vesselFlag());
      ds.field("yearBuilt", &self.yearBuilt());
      ds.field("vesselBuilder", &self.vesselBuilder());
      ds.field("status", &self.status());
      ds.field("firstSeen", &self.firstSeen());
      ds.field("length", &self.length());
      ds.field("width", &self.width());
      ds.field("maxDraught", &self.maxDraught());
      ds.field("vslWt", &self.vslWt());
      ds.field("maxSpeed", &self.maxSpeed());
      ds.field("sternType", &self.sternType());
      ds.field("numBlades", &self.numBlades());
      ds.field("numShafts", &self.numShafts());
      ds.field("propType", &self.propType());
      ds.field("hullNum", &self.hullNum());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("updatedAt", &self.updatedAt());
      ds.field("updatedBy", &self.updatedBy());
      ds.field("source", &self.source());
      ds.field("sourceDL", &self.sourceDL());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Vessel_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub entity: Option<String>,
  pub idEntity: Option<String>,
  pub altVesselId: Option<String>,
  pub idOrganization: Option<String>,
  pub vesselName: Option<String>,
  pub vesselType: Option<String>,
  pub vesselClass: Option<String>,
  pub vesselDescription: Option<String>,
  pub sconum: Option<String>,
  pub imon: i32,
  pub mmsi: Option<String>,
  pub callsign: Option<String>,
  pub vesselFlag: Option<String>,
  pub yearBuilt: Option<String>,
  pub vesselBuilder: Option<String>,
  pub status: Option<String>,
  pub firstSeen: Option<String>,
  pub length: f64,
  pub width: f64,
  pub maxDraught: f64,
  pub vslWt: f64,
  pub maxSpeed: f64,
  pub sternType: Option<String>,
  pub numBlades: i32,
  pub numShafts: i32,
  pub propType: Option<String>,
  pub hullNum: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub updatedAt: Option<String>,
  pub updatedBy: Option<String>,
  pub source: Option<String>,
  pub sourceDL: Option<String>,
  pub origin: Option<String>,
  pub dataMode: Vessel_Full_dataMode_Enum,
  pub origNetwork: Option<String>,
}
impl Default for Vessel_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      entity: None,
      idEntity: None,
      altVesselId: None,
      idOrganization: None,
      vesselName: None,
      vesselType: None,
      vesselClass: None,
      vesselDescription: None,
      sconum: None,
      imon: 0,
      mmsi: None,
      callsign: None,
      vesselFlag: None,
      yearBuilt: None,
      vesselBuilder: None,
      status: None,
      firstSeen: None,
      length: 0.0,
      width: 0.0,
      maxDraught: 0.0,
      vslWt: 0.0,
      maxSpeed: 0.0,
      sternType: None,
      numBlades: 0,
      numShafts: 0,
      propType: None,
      hullNum: None,
      createdAt: None,
      createdBy: None,
      updatedAt: None,
      updatedBy: None,
      source: None,
      sourceDL: None,
      origin: None,
      dataMode: Vessel_Full_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}
impl Vessel_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Vessel_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let entity = self.entity.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idEntity = self.idEntity.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altVesselId = self.altVesselId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOrganization = self.idOrganization.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let vesselName = self.vesselName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let vesselType = self.vesselType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let vesselClass = self.vesselClass.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let vesselDescription = self.vesselDescription.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sconum = self.sconum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let imon = self.imon;
    let mmsi = self.mmsi.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let callsign = self.callsign.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let vesselFlag = self.vesselFlag.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let yearBuilt = self.yearBuilt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let vesselBuilder = self.vesselBuilder.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let status = self.status.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let firstSeen = self.firstSeen.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let length = self.length;
    let width = self.width;
    let maxDraught = self.maxDraught;
    let vslWt = self.vslWt;
    let maxSpeed = self.maxSpeed;
    let sternType = self.sternType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let numBlades = self.numBlades;
    let numShafts = self.numShafts;
    let propType = self.propType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let hullNum = self.hullNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedAt = self.updatedAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let updatedBy = self.updatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Vessel_Full::create(_fbb, &Vessel_FullArgs{
      id,
      classificationMarking,
      entity,
      idEntity,
      altVesselId,
      idOrganization,
      vesselName,
      vesselType,
      vesselClass,
      vesselDescription,
      sconum,
      imon,
      mmsi,
      callsign,
      vesselFlag,
      yearBuilt,
      vesselBuilder,
      status,
      firstSeen,
      length,
      width,
      maxDraught,
      vslWt,
      maxSpeed,
      sternType,
      numBlades,
      numShafts,
      propType,
      hullNum,
      createdAt,
      createdBy,
      updatedAt,
      updatedBy,
      source,
      sourceDL,
      origin,
      dataMode,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Vessel_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_vessel_full_unchecked`.
pub fn root_as_vessel_full(buf: &[u8]) -> Result<Vessel_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Vessel_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Vessel_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_vessel_full_unchecked`.
pub fn size_prefixed_root_as_vessel_full(buf: &[u8]) -> Result<Vessel_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Vessel_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Vessel_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_vessel_full_unchecked`.
pub fn root_as_vessel_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Vessel_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Vessel_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Vessel_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_vessel_full_unchecked`.
pub fn size_prefixed_root_as_vessel_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Vessel_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Vessel_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Vessel_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Vessel_Full`.
pub unsafe fn root_as_vessel_full_unchecked(buf: &[u8]) -> Vessel_Full {
  flatbuffers::root_unchecked::<Vessel_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Vessel_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Vessel_Full`.
pub unsafe fn size_prefixed_root_as_vessel_full_unchecked(buf: &[u8]) -> Vessel_Full {
  flatbuffers::size_prefixed_root_unchecked::<Vessel_Full>(buf)
}
pub const VESSEL_FULL_IDENTIFIER: &str = "VESS";

#[inline]
pub fn vessel_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, VESSEL_FULL_IDENTIFIER, false)
}

#[inline]
pub fn vessel_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, VESSEL_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_vessel_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Vessel_Full<'a>>) {
  fbb.finish(root, Some(VESSEL_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_vessel_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Vessel_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(VESSEL_FULL_IDENTIFIER));
}
