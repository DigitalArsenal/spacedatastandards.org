// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SURFACE_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SURFACE_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SURFACE_ABRIDGED_DATA_MODE_ENUM: [Surface_Abridged_dataMode_Enum; 4] = [
  Surface_Abridged_dataMode_Enum::REAL,
  Surface_Abridged_dataMode_Enum::TEST,
  Surface_Abridged_dataMode_Enum::SIMULATED,
  Surface_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Surface_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Surface_Abridged_dataMode_Enum {
  /// No description available.
  pub const REAL: Self = Self(0);
  /// No description available.
  pub const TEST: Self = Self(1);
  /// No description available.
  pub const SIMULATED: Self = Self(2);
  /// No description available.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Surface_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Surface_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Surface_Abridged_dataMode_Enum {
    type Output = Surface_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Surface_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Surface_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Surface_Abridged_dataMode_Enum {}
pub enum Surface_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Surface information contains properties related to an airfield's runway, taxiway, and parking. The surface types and characteristics can dictate the airfield's capability of hosting a specific aircraft.
pub struct Surface_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Surface_Abridged<'a> {
  type Inner = Surface_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Surface_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 10;
  pub const VT_IDSITE: flatbuffers::VOffsetT = 12;
  pub const VT_ALTSITEID: flatbuffers::VOffsetT = 14;
  pub const VT_PRIMARY: flatbuffers::VOffsetT = 16;
  pub const VT_LENGTHFT: flatbuffers::VOffsetT = 18;
  pub const VT_LDAFT: flatbuffers::VOffsetT = 20;
  pub const VT_WIDTHFT: flatbuffers::VOffsetT = 22;
  pub const VT_LENGTHM: flatbuffers::VOffsetT = 24;
  pub const VT_LDAM: flatbuffers::VOffsetT = 26;
  pub const VT_WIDTHM: flatbuffers::VOffsetT = 28;
  pub const VT_MATERIAL: flatbuffers::VOffsetT = 30;
  pub const VT_CONDITION: flatbuffers::VOffsetT = 32;
  pub const VT_RAWWBC: flatbuffers::VOffsetT = 34;
  pub const VT_PCN: flatbuffers::VOffsetT = 36;
  pub const VT_LCN: flatbuffers::VOffsetT = 38;
  pub const VT_SWTKIP: flatbuffers::VOffsetT = 40;
  pub const VT_TWTKIP: flatbuffers::VOffsetT = 42;
  pub const VT_STWTKIP: flatbuffers::VOffsetT = 44;
  pub const VT_TTWTKIP: flatbuffers::VOffsetT = 46;
  pub const VT_DDWTKIP: flatbuffers::VOffsetT = 48;
  pub const VT_SBTTWTKIP: flatbuffers::VOffsetT = 50;
  pub const VT_TDTWTKIP: flatbuffers::VOffsetT = 52;
  pub const VT_TRTWTKIP: flatbuffers::VOffsetT = 54;
  pub const VT_DDTWTKIP: flatbuffers::VOffsetT = 56;
  pub const VT_SWTKN: flatbuffers::VOffsetT = 58;
  pub const VT_TWTKN: flatbuffers::VOffsetT = 60;
  pub const VT_STWTKN: flatbuffers::VOffsetT = 62;
  pub const VT_TTWTKN: flatbuffers::VOffsetT = 64;
  pub const VT_DDWTKN: flatbuffers::VOffsetT = 66;
  pub const VT_SBTTWTKN: flatbuffers::VOffsetT = 68;
  pub const VT_TDTWTKN: flatbuffers::VOffsetT = 70;
  pub const VT_TRTWTKN: flatbuffers::VOffsetT = 72;
  pub const VT_DDTWTKN: flatbuffers::VOffsetT = 74;
  pub const VT_LIGHTING: flatbuffers::VOffsetT = 76;
  pub const VT_LIGHTSUNKN: flatbuffers::VOffsetT = 78;
  pub const VT_LIGHTSAPRCH: flatbuffers::VOffsetT = 80;
  pub const VT_LIGHTSVASI: flatbuffers::VOffsetT = 82;
  pub const VT_LIGHTSPAPI: flatbuffers::VOffsetT = 84;
  pub const VT_LIGHTSOLS: flatbuffers::VOffsetT = 86;
  pub const VT_LIGHTSREIL: flatbuffers::VOffsetT = 88;
  pub const VT_LIGHTSTDZL: flatbuffers::VOffsetT = 90;
  pub const VT_LIGHTSCL: flatbuffers::VOffsetT = 92;
  pub const VT_OBSTACLE: flatbuffers::VOffsetT = 94;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 96;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 98;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 100;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 102;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 104;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 106;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Surface_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Surface_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<Surface_Abridged<'bldr>> {
    let mut builder = Surface_AbridgedBuilder::new(_fbb);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    builder.add_ddtWtKN(args.ddtWtKN);
    builder.add_trtWtKN(args.trtWtKN);
    builder.add_tdtWtKN(args.tdtWtKN);
    builder.add_sbttWtKN(args.sbttWtKN);
    builder.add_ddWtKN(args.ddWtKN);
    builder.add_ttWtKN(args.ttWtKN);
    builder.add_stWtKN(args.stWtKN);
    builder.add_tWtKN(args.tWtKN);
    builder.add_sWtKN(args.sWtKN);
    builder.add_ddtWtKip(args.ddtWtKip);
    builder.add_trtWtKip(args.trtWtKip);
    builder.add_tdtWtkip(args.tdtWtkip);
    builder.add_sbttWtKip(args.sbttWtKip);
    builder.add_ddWtKip(args.ddWtKip);
    builder.add_ttWtKip(args.ttWtKip);
    builder.add_stWtKip(args.stWtKip);
    builder.add_tWtKip(args.tWtKip);
    builder.add_sWtKip(args.sWtKip);
    builder.add_lcn(args.lcn);
    if let Some(x) = args.pcn { builder.add_pcn(x); }
    if let Some(x) = args.rawWBC { builder.add_rawWBC(x); }
    if let Some(x) = args.condition { builder.add_condition(x); }
    if let Some(x) = args.material { builder.add_material(x); }
    builder.add_widthM(args.widthM);
    builder.add_ldaM(args.ldaM);
    builder.add_lengthM(args.lengthM);
    builder.add_widthFt(args.widthFt);
    builder.add_ldaFt(args.ldaFt);
    builder.add_lengthFt(args.lengthFt);
    if let Some(x) = args.altSiteId { builder.add_altSiteId(x); }
    if let Some(x) = args.idSite { builder.add_idSite(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_obstacle(args.obstacle);
    builder.add_lightsCL(args.lightsCL);
    builder.add_lightsTDZL(args.lightsTDZL);
    builder.add_lightsREIL(args.lightsREIL);
    builder.add_lightsOLS(args.lightsOLS);
    builder.add_lightsPAPI(args.lightsPAPI);
    builder.add_lightsVASI(args.lightsVASI);
    builder.add_lightsAPRCH(args.lightsAPRCH);
    builder.add_lightsUNKN(args.lightsUNKN);
    builder.add_lighting(args.lighting);
    builder.add_primary(args.primary);
    builder.finish()
  }

  pub fn unpack(&self) -> Surface_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let name = self.name().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let idSite = self.idSite().map(|x| {
      x.to_string()
    });
    let altSiteId = self.altSiteId().map(|x| {
      x.to_string()
    });
    let primary = self.primary();
    let lengthFt = self.lengthFt();
    let ldaFt = self.ldaFt();
    let widthFt = self.widthFt();
    let lengthM = self.lengthM();
    let ldaM = self.ldaM();
    let widthM = self.widthM();
    let material = self.material().map(|x| {
      x.to_string()
    });
    let condition = self.condition().map(|x| {
      x.to_string()
    });
    let rawWBC = self.rawWBC().map(|x| {
      x.to_string()
    });
    let pcn = self.pcn().map(|x| {
      x.to_string()
    });
    let lcn = self.lcn();
    let sWtKip = self.sWtKip();
    let tWtKip = self.tWtKip();
    let stWtKip = self.stWtKip();
    let ttWtKip = self.ttWtKip();
    let ddWtKip = self.ddWtKip();
    let sbttWtKip = self.sbttWtKip();
    let tdtWtkip = self.tdtWtkip();
    let trtWtKip = self.trtWtKip();
    let ddtWtKip = self.ddtWtKip();
    let sWtKN = self.sWtKN();
    let tWtKN = self.tWtKN();
    let stWtKN = self.stWtKN();
    let ttWtKN = self.ttWtKN();
    let ddWtKN = self.ddWtKN();
    let sbttWtKN = self.sbttWtKN();
    let tdtWtKN = self.tdtWtKN();
    let trtWtKN = self.trtWtKN();
    let ddtWtKN = self.ddtWtKN();
    let lighting = self.lighting();
    let lightsUNKN = self.lightsUNKN();
    let lightsAPRCH = self.lightsAPRCH();
    let lightsVASI = self.lightsVASI();
    let lightsPAPI = self.lightsPAPI();
    let lightsOLS = self.lightsOLS();
    let lightsREIL = self.lightsREIL();
    let lightsTDZL = self.lightsTDZL();
    let lightsCL = self.lightsCL();
    let obstacle = self.obstacle();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    Surface_AbridgedT {
      id,
      classificationMarking,
      name,
      type_,
      idSite,
      altSiteId,
      primary,
      lengthFt,
      ldaFt,
      widthFt,
      lengthM,
      ldaM,
      widthM,
      material,
      condition,
      rawWBC,
      pcn,
      lcn,
      sWtKip,
      tWtKip,
      stWtKip,
      ttWtKip,
      ddWtKip,
      sbttWtKip,
      tdtWtkip,
      trtWtKip,
      ddtWtKip,
      sWtKN,
      tWtKN,
      stWtKN,
      ttWtKN,
      ddWtKN,
      sbttWtKN,
      tdtWtKN,
      trtWtKN,
      ddtWtKN,
      lighting,
      lightsUNKN,
      lightsAPRCH,
      lightsVASI,
      lightsPAPI,
      lightsOLS,
      lightsREIL,
      lightsTDZL,
      lightsCL,
      obstacle,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: be831d39-1822-da9f-7ace-6cc5643397dc
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// The surface name or identifier.
  /// Example: /// Example: West lot
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_NAME, None)}
  }
  /// The surface type of this record (e.g. RUNWAY, TAXIWAY, PARKING).
  /// Example: /// Example: PARKING
  /// Constraints: Minimum length = 1, Maximum length = 7
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_TYPE_, None)}
  }
  /// The ID of the site where this surface is located.
  /// Example: /// Example: SITE-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSite(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_IDSITE, None)}
  }
  /// Alternate site identifier provided by the source.
  /// Example: /// Example: ORIG-SITE-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn altSiteId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_ALTSITEID, None)}
  }
  /// Flag indicating this is the primary runway.  Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn primary(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Surface_Abridged::VT_PRIMARY, Some(false)).unwrap()}
  }
  /// The length of the surface type, in feet.  Applicable for runway and parking surface types.
  /// Example: /// Example: 1500
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lengthFt(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_LENGTHFT, Some(0)).unwrap()}
  }
  /// The landing distance available for the runway, in feet.  Applicable for runway surface types only.
  /// Example: /// Example: 475
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ldaFt(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_LDAFT, Some(0)).unwrap()}
  }
  /// The width of the surface type, in feet.
  /// Example: /// Example: 220
  /// Constraints: No constraints specified.
  #[inline]
  pub fn widthFt(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_WIDTHFT, Some(0)).unwrap()}
  }
  /// The length of the surface type, in meters.  Applicable for runway and parking surface types.
  /// Example: /// Example: 457
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lengthM(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_LENGTHM, Some(0)).unwrap()}
  }
  /// The landing distance available for the runway, in meters.  Applicable for runway surface types only.
  /// Example: /// Example: 145
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ldaM(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_LDAM, Some(0)).unwrap()}
  }
  /// The width of the surface type, in meters.
  /// Example: /// Example: 67
  /// Constraints: No constraints specified.
  #[inline]
  pub fn widthM(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_WIDTHM, Some(0)).unwrap()}
  }
  /// The surface material (e.g. Asphalt, Concrete, Dirt).
  /// Example: /// Example: Concrete
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn material(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_MATERIAL, None)}
  }
  /// The surface condition (e.g. GOOD, FAIR, POOR, SERIOUS, FAILED, CLOSED, UNKNOWN).
  /// Example: /// Example: GOOD
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn condition(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_CONDITION, None)}
  }
  /// Raw weight bearing capacity value or pavement strength.
  /// Example: /// Example: LCN 42
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn rawWBC(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_RAWWBC, None)}
  }
  /// Pavement classification number (PCN) and tire pressure code.
  /// Example: /// Example: 73RBWT
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn pcn(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_PCN, None)}
  }
  /// Load classification number or pavement rating which ranks aircraft on a scale of 1 to 120.
  /// Example: /// Example: 50
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lcn(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_LCN, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for an S-type (single) landing gear configuration, in kilopounds (kip). Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 143
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sWtKip(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_SWTKIP, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for a T-type (twin (dual)) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 188
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tWtKip(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_TWTKIP, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for an ST-type (single tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 195
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stWtKip(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_STWTKIP, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for a GDSS TT-type (twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 414
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ttWtKip(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_TTWTKIP, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for an FAA 2D-type (twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 416
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ddWtKip(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_DDWTKIP, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for an SBTT-type (single belly twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 603
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sbttWtKip(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_SBTTWTKIP, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for a TDT-type (twin delta tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 870
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tdtWtkip(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_TDTWTKIP, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for a TRT-type (triple tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 622
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trtWtKip(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_TRTWTKIP, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for a DDT-type (double dual tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 833
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ddtWtKip(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_DDTWTKIP, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for an S-type (single) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 636
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sWtKN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_SWTKN, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for a T-type (twin (dual)) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 836
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tWtKN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_TWTKN, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for an ST-type (single tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 867
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stWtKN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_STWTKN, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for a GDSS TT-type (twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 1842
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ttWtKN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_TTWTKN, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for an FAA 2D-type (twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 1850
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ddWtKN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_DDWTKN, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for an SBTT-type (single belly twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 2682
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sbttWtKN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_SBTTWTKN, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for a TDT-type (twin delta tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 3870
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tdtWtKN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_TDTWTKN, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for a TRT-type (triple tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 2767
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trtWtKN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_TRTWTKN, Some(0)).unwrap()}
  }
  /// The max weight allowable on this surface type for a DDT-type (double dual tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 3705
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ddtWtKN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Surface_Abridged::VT_DDTWTKN, Some(0)).unwrap()}
  }
  /// Flag indicating the surface has lighting.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lighting(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Surface_Abridged::VT_LIGHTING, Some(false)).unwrap()}
  }
  /// Flag indicating the runway lighting is unknown. Applicable for runway surface types only.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lightsUNKN(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Surface_Abridged::VT_LIGHTSUNKN, Some(false)).unwrap()}
  }
  /// Flag indicating the runway has approach lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lightsAPRCH(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Surface_Abridged::VT_LIGHTSAPRCH, Some(false)).unwrap()}
  }
  /// Flag indicating the runway has Visual Approach Slope Indicator (VASI) lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lightsVASI(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Surface_Abridged::VT_LIGHTSVASI, Some(false)).unwrap()}
  }
  /// Flag indicating the runway has Precision Approach Path Indicator (PAPI) lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lightsPAPI(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Surface_Abridged::VT_LIGHTSPAPI, Some(false)).unwrap()}
  }
  /// Flag indicating the runway has Optical Landing System (OLS) lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lightsOLS(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Surface_Abridged::VT_LIGHTSOLS, Some(false)).unwrap()}
  }
  /// Flag indicating the runway has Runway End Identifier Lights (REIL). Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lightsREIL(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Surface_Abridged::VT_LIGHTSREIL, Some(false)).unwrap()}
  }
  /// Flag indicating the runway has Touchdown Zone lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lightsTDZL(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Surface_Abridged::VT_LIGHTSTDZL, Some(false)).unwrap()}
  }
  /// Flag indicating the runway has centerline lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lightsCL(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Surface_Abridged::VT_LIGHTSCL, Some(false)).unwrap()}
  }
  /// Flag indicating the surface type has an obstacle. Applicable for taxiway and parking surface types.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obstacle(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Surface_Abridged::VT_OBSTACLE, Some(false)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Surface_Abridged::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> Surface_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Surface_Abridged_dataMode_Enum>(Surface_Abridged::VT_DATAMODE, Some(Surface_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Surface_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSite", Self::VT_IDSITE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altSiteId", Self::VT_ALTSITEID, false)?
     .visit_field::<bool>("primary", Self::VT_PRIMARY, false)?
     .visit_field::<i32>("lengthFt", Self::VT_LENGTHFT, false)?
     .visit_field::<i32>("ldaFt", Self::VT_LDAFT, false)?
     .visit_field::<i32>("widthFt", Self::VT_WIDTHFT, false)?
     .visit_field::<i32>("lengthM", Self::VT_LENGTHM, false)?
     .visit_field::<i32>("ldaM", Self::VT_LDAM, false)?
     .visit_field::<i32>("widthM", Self::VT_WIDTHM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("material", Self::VT_MATERIAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("condition", Self::VT_CONDITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawWBC", Self::VT_RAWWBC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pcn", Self::VT_PCN, false)?
     .visit_field::<i32>("lcn", Self::VT_LCN, false)?
     .visit_field::<i32>("sWtKip", Self::VT_SWTKIP, false)?
     .visit_field::<i32>("tWtKip", Self::VT_TWTKIP, false)?
     .visit_field::<i32>("stWtKip", Self::VT_STWTKIP, false)?
     .visit_field::<i32>("ttWtKip", Self::VT_TTWTKIP, false)?
     .visit_field::<i32>("ddWtKip", Self::VT_DDWTKIP, false)?
     .visit_field::<i32>("sbttWtKip", Self::VT_SBTTWTKIP, false)?
     .visit_field::<i32>("tdtWtkip", Self::VT_TDTWTKIP, false)?
     .visit_field::<i32>("trtWtKip", Self::VT_TRTWTKIP, false)?
     .visit_field::<i32>("ddtWtKip", Self::VT_DDTWTKIP, false)?
     .visit_field::<i32>("sWtKN", Self::VT_SWTKN, false)?
     .visit_field::<i32>("tWtKN", Self::VT_TWTKN, false)?
     .visit_field::<i32>("stWtKN", Self::VT_STWTKN, false)?
     .visit_field::<i32>("ttWtKN", Self::VT_TTWTKN, false)?
     .visit_field::<i32>("ddWtKN", Self::VT_DDWTKN, false)?
     .visit_field::<i32>("sbttWtKN", Self::VT_SBTTWTKN, false)?
     .visit_field::<i32>("tdtWtKN", Self::VT_TDTWTKN, false)?
     .visit_field::<i32>("trtWtKN", Self::VT_TRTWTKN, false)?
     .visit_field::<i32>("ddtWtKN", Self::VT_DDTWTKN, false)?
     .visit_field::<bool>("lighting", Self::VT_LIGHTING, false)?
     .visit_field::<bool>("lightsUNKN", Self::VT_LIGHTSUNKN, false)?
     .visit_field::<bool>("lightsAPRCH", Self::VT_LIGHTSAPRCH, false)?
     .visit_field::<bool>("lightsVASI", Self::VT_LIGHTSVASI, false)?
     .visit_field::<bool>("lightsPAPI", Self::VT_LIGHTSPAPI, false)?
     .visit_field::<bool>("lightsOLS", Self::VT_LIGHTSOLS, false)?
     .visit_field::<bool>("lightsREIL", Self::VT_LIGHTSREIL, false)?
     .visit_field::<bool>("lightsTDZL", Self::VT_LIGHTSTDZL, false)?
     .visit_field::<bool>("lightsCL", Self::VT_LIGHTSCL, false)?
     .visit_field::<bool>("obstacle", Self::VT_OBSTACLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<Surface_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct Surface_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSite: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altSiteId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub primary: bool,
    pub lengthFt: i32,
    pub ldaFt: i32,
    pub widthFt: i32,
    pub lengthM: i32,
    pub ldaM: i32,
    pub widthM: i32,
    pub material: Option<flatbuffers::WIPOffset<&'a str>>,
    pub condition: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rawWBC: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pcn: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lcn: i32,
    pub sWtKip: i32,
    pub tWtKip: i32,
    pub stWtKip: i32,
    pub ttWtKip: i32,
    pub ddWtKip: i32,
    pub sbttWtKip: i32,
    pub tdtWtkip: i32,
    pub trtWtKip: i32,
    pub ddtWtKip: i32,
    pub sWtKN: i32,
    pub tWtKN: i32,
    pub stWtKN: i32,
    pub ttWtKN: i32,
    pub ddWtKN: i32,
    pub sbttWtKN: i32,
    pub tdtWtKN: i32,
    pub trtWtKN: i32,
    pub ddtWtKN: i32,
    pub lighting: bool,
    pub lightsUNKN: bool,
    pub lightsAPRCH: bool,
    pub lightsVASI: bool,
    pub lightsPAPI: bool,
    pub lightsOLS: bool,
    pub lightsREIL: bool,
    pub lightsTDZL: bool,
    pub lightsCL: bool,
    pub obstacle: bool,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: Surface_Abridged_dataMode_Enum,
}
impl<'a> Default for Surface_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Surface_AbridgedArgs {
      id: None,
      classificationMarking: None,
      name: None,
      type_: None,
      idSite: None,
      altSiteId: None,
      primary: false,
      lengthFt: 0,
      ldaFt: 0,
      widthFt: 0,
      lengthM: 0,
      ldaM: 0,
      widthM: 0,
      material: None,
      condition: None,
      rawWBC: None,
      pcn: None,
      lcn: 0,
      sWtKip: 0,
      tWtKip: 0,
      stWtKip: 0,
      ttWtKip: 0,
      ddWtKip: 0,
      sbttWtKip: 0,
      tdtWtkip: 0,
      trtWtKip: 0,
      ddtWtKip: 0,
      sWtKN: 0,
      tWtKN: 0,
      stWtKN: 0,
      ttWtKN: 0,
      ddWtKN: 0,
      sbttWtKN: 0,
      tdtWtKN: 0,
      trtWtKN: 0,
      ddtWtKN: 0,
      lighting: false,
      lightsUNKN: false,
      lightsAPRCH: false,
      lightsVASI: false,
      lightsPAPI: false,
      lightsOLS: false,
      lightsREIL: false,
      lightsTDZL: false,
      lightsCL: false,
      obstacle: false,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: Surface_Abridged_dataMode_Enum::REAL,
    }
  }
}

pub struct Surface_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Surface_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_idSite(&mut self, idSite: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_IDSITE, idSite);
  }
  #[inline]
  pub fn add_altSiteId(&mut self, altSiteId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_ALTSITEID, altSiteId);
  }
  #[inline]
  pub fn add_primary(&mut self, primary: bool) {
    self.fbb_.push_slot::<bool>(Surface_Abridged::VT_PRIMARY, primary, false);
  }
  #[inline]
  pub fn add_lengthFt(&mut self, lengthFt: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_LENGTHFT, lengthFt, 0);
  }
  #[inline]
  pub fn add_ldaFt(&mut self, ldaFt: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_LDAFT, ldaFt, 0);
  }
  #[inline]
  pub fn add_widthFt(&mut self, widthFt: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_WIDTHFT, widthFt, 0);
  }
  #[inline]
  pub fn add_lengthM(&mut self, lengthM: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_LENGTHM, lengthM, 0);
  }
  #[inline]
  pub fn add_ldaM(&mut self, ldaM: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_LDAM, ldaM, 0);
  }
  #[inline]
  pub fn add_widthM(&mut self, widthM: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_WIDTHM, widthM, 0);
  }
  #[inline]
  pub fn add_material(&mut self, material: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_MATERIAL, material);
  }
  #[inline]
  pub fn add_condition(&mut self, condition: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_CONDITION, condition);
  }
  #[inline]
  pub fn add_rawWBC(&mut self, rawWBC: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_RAWWBC, rawWBC);
  }
  #[inline]
  pub fn add_pcn(&mut self, pcn: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_PCN, pcn);
  }
  #[inline]
  pub fn add_lcn(&mut self, lcn: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_LCN, lcn, 0);
  }
  #[inline]
  pub fn add_sWtKip(&mut self, sWtKip: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_SWTKIP, sWtKip, 0);
  }
  #[inline]
  pub fn add_tWtKip(&mut self, tWtKip: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_TWTKIP, tWtKip, 0);
  }
  #[inline]
  pub fn add_stWtKip(&mut self, stWtKip: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_STWTKIP, stWtKip, 0);
  }
  #[inline]
  pub fn add_ttWtKip(&mut self, ttWtKip: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_TTWTKIP, ttWtKip, 0);
  }
  #[inline]
  pub fn add_ddWtKip(&mut self, ddWtKip: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_DDWTKIP, ddWtKip, 0);
  }
  #[inline]
  pub fn add_sbttWtKip(&mut self, sbttWtKip: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_SBTTWTKIP, sbttWtKip, 0);
  }
  #[inline]
  pub fn add_tdtWtkip(&mut self, tdtWtkip: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_TDTWTKIP, tdtWtkip, 0);
  }
  #[inline]
  pub fn add_trtWtKip(&mut self, trtWtKip: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_TRTWTKIP, trtWtKip, 0);
  }
  #[inline]
  pub fn add_ddtWtKip(&mut self, ddtWtKip: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_DDTWTKIP, ddtWtKip, 0);
  }
  #[inline]
  pub fn add_sWtKN(&mut self, sWtKN: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_SWTKN, sWtKN, 0);
  }
  #[inline]
  pub fn add_tWtKN(&mut self, tWtKN: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_TWTKN, tWtKN, 0);
  }
  #[inline]
  pub fn add_stWtKN(&mut self, stWtKN: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_STWTKN, stWtKN, 0);
  }
  #[inline]
  pub fn add_ttWtKN(&mut self, ttWtKN: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_TTWTKN, ttWtKN, 0);
  }
  #[inline]
  pub fn add_ddWtKN(&mut self, ddWtKN: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_DDWTKN, ddWtKN, 0);
  }
  #[inline]
  pub fn add_sbttWtKN(&mut self, sbttWtKN: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_SBTTWTKN, sbttWtKN, 0);
  }
  #[inline]
  pub fn add_tdtWtKN(&mut self, tdtWtKN: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_TDTWTKN, tdtWtKN, 0);
  }
  #[inline]
  pub fn add_trtWtKN(&mut self, trtWtKN: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_TRTWTKN, trtWtKN, 0);
  }
  #[inline]
  pub fn add_ddtWtKN(&mut self, ddtWtKN: i32) {
    self.fbb_.push_slot::<i32>(Surface_Abridged::VT_DDTWTKN, ddtWtKN, 0);
  }
  #[inline]
  pub fn add_lighting(&mut self, lighting: bool) {
    self.fbb_.push_slot::<bool>(Surface_Abridged::VT_LIGHTING, lighting, false);
  }
  #[inline]
  pub fn add_lightsUNKN(&mut self, lightsUNKN: bool) {
    self.fbb_.push_slot::<bool>(Surface_Abridged::VT_LIGHTSUNKN, lightsUNKN, false);
  }
  #[inline]
  pub fn add_lightsAPRCH(&mut self, lightsAPRCH: bool) {
    self.fbb_.push_slot::<bool>(Surface_Abridged::VT_LIGHTSAPRCH, lightsAPRCH, false);
  }
  #[inline]
  pub fn add_lightsVASI(&mut self, lightsVASI: bool) {
    self.fbb_.push_slot::<bool>(Surface_Abridged::VT_LIGHTSVASI, lightsVASI, false);
  }
  #[inline]
  pub fn add_lightsPAPI(&mut self, lightsPAPI: bool) {
    self.fbb_.push_slot::<bool>(Surface_Abridged::VT_LIGHTSPAPI, lightsPAPI, false);
  }
  #[inline]
  pub fn add_lightsOLS(&mut self, lightsOLS: bool) {
    self.fbb_.push_slot::<bool>(Surface_Abridged::VT_LIGHTSOLS, lightsOLS, false);
  }
  #[inline]
  pub fn add_lightsREIL(&mut self, lightsREIL: bool) {
    self.fbb_.push_slot::<bool>(Surface_Abridged::VT_LIGHTSREIL, lightsREIL, false);
  }
  #[inline]
  pub fn add_lightsTDZL(&mut self, lightsTDZL: bool) {
    self.fbb_.push_slot::<bool>(Surface_Abridged::VT_LIGHTSTDZL, lightsTDZL, false);
  }
  #[inline]
  pub fn add_lightsCL(&mut self, lightsCL: bool) {
    self.fbb_.push_slot::<bool>(Surface_Abridged::VT_LIGHTSCL, lightsCL, false);
  }
  #[inline]
  pub fn add_obstacle(&mut self, obstacle: bool) {
    self.fbb_.push_slot::<bool>(Surface_Abridged::VT_OBSTACLE, obstacle, false);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Surface_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Surface_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<Surface_Abridged_dataMode_Enum>(Surface_Abridged::VT_DATAMODE, dataMode, Surface_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Surface_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Surface_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Surface_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Surface_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Surface_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("name", &self.name());
      ds.field("type_", &self.type_());
      ds.field("idSite", &self.idSite());
      ds.field("altSiteId", &self.altSiteId());
      ds.field("primary", &self.primary());
      ds.field("lengthFt", &self.lengthFt());
      ds.field("ldaFt", &self.ldaFt());
      ds.field("widthFt", &self.widthFt());
      ds.field("lengthM", &self.lengthM());
      ds.field("ldaM", &self.ldaM());
      ds.field("widthM", &self.widthM());
      ds.field("material", &self.material());
      ds.field("condition", &self.condition());
      ds.field("rawWBC", &self.rawWBC());
      ds.field("pcn", &self.pcn());
      ds.field("lcn", &self.lcn());
      ds.field("sWtKip", &self.sWtKip());
      ds.field("tWtKip", &self.tWtKip());
      ds.field("stWtKip", &self.stWtKip());
      ds.field("ttWtKip", &self.ttWtKip());
      ds.field("ddWtKip", &self.ddWtKip());
      ds.field("sbttWtKip", &self.sbttWtKip());
      ds.field("tdtWtkip", &self.tdtWtkip());
      ds.field("trtWtKip", &self.trtWtKip());
      ds.field("ddtWtKip", &self.ddtWtKip());
      ds.field("sWtKN", &self.sWtKN());
      ds.field("tWtKN", &self.tWtKN());
      ds.field("stWtKN", &self.stWtKN());
      ds.field("ttWtKN", &self.ttWtKN());
      ds.field("ddWtKN", &self.ddWtKN());
      ds.field("sbttWtKN", &self.sbttWtKN());
      ds.field("tdtWtKN", &self.tdtWtKN());
      ds.field("trtWtKN", &self.trtWtKN());
      ds.field("ddtWtKN", &self.ddtWtKN());
      ds.field("lighting", &self.lighting());
      ds.field("lightsUNKN", &self.lightsUNKN());
      ds.field("lightsAPRCH", &self.lightsAPRCH());
      ds.field("lightsVASI", &self.lightsVASI());
      ds.field("lightsPAPI", &self.lightsPAPI());
      ds.field("lightsOLS", &self.lightsOLS());
      ds.field("lightsREIL", &self.lightsREIL());
      ds.field("lightsTDZL", &self.lightsTDZL());
      ds.field("lightsCL", &self.lightsCL());
      ds.field("obstacle", &self.obstacle());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Surface_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub name: Option<String>,
  pub type_: Option<String>,
  pub idSite: Option<String>,
  pub altSiteId: Option<String>,
  pub primary: bool,
  pub lengthFt: i32,
  pub ldaFt: i32,
  pub widthFt: i32,
  pub lengthM: i32,
  pub ldaM: i32,
  pub widthM: i32,
  pub material: Option<String>,
  pub condition: Option<String>,
  pub rawWBC: Option<String>,
  pub pcn: Option<String>,
  pub lcn: i32,
  pub sWtKip: i32,
  pub tWtKip: i32,
  pub stWtKip: i32,
  pub ttWtKip: i32,
  pub ddWtKip: i32,
  pub sbttWtKip: i32,
  pub tdtWtkip: i32,
  pub trtWtKip: i32,
  pub ddtWtKip: i32,
  pub sWtKN: i32,
  pub tWtKN: i32,
  pub stWtKN: i32,
  pub ttWtKN: i32,
  pub ddWtKN: i32,
  pub sbttWtKN: i32,
  pub tdtWtKN: i32,
  pub trtWtKN: i32,
  pub ddtWtKN: i32,
  pub lighting: bool,
  pub lightsUNKN: bool,
  pub lightsAPRCH: bool,
  pub lightsVASI: bool,
  pub lightsPAPI: bool,
  pub lightsOLS: bool,
  pub lightsREIL: bool,
  pub lightsTDZL: bool,
  pub lightsCL: bool,
  pub obstacle: bool,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: Surface_Abridged_dataMode_Enum,
}
impl Default for Surface_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      name: None,
      type_: None,
      idSite: None,
      altSiteId: None,
      primary: false,
      lengthFt: 0,
      ldaFt: 0,
      widthFt: 0,
      lengthM: 0,
      ldaM: 0,
      widthM: 0,
      material: None,
      condition: None,
      rawWBC: None,
      pcn: None,
      lcn: 0,
      sWtKip: 0,
      tWtKip: 0,
      stWtKip: 0,
      ttWtKip: 0,
      ddWtKip: 0,
      sbttWtKip: 0,
      tdtWtkip: 0,
      trtWtKip: 0,
      ddtWtKip: 0,
      sWtKN: 0,
      tWtKN: 0,
      stWtKN: 0,
      ttWtKN: 0,
      ddWtKN: 0,
      sbttWtKN: 0,
      tdtWtKN: 0,
      trtWtKN: 0,
      ddtWtKN: 0,
      lighting: false,
      lightsUNKN: false,
      lightsAPRCH: false,
      lightsVASI: false,
      lightsPAPI: false,
      lightsOLS: false,
      lightsREIL: false,
      lightsTDZL: false,
      lightsCL: false,
      obstacle: false,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: Surface_Abridged_dataMode_Enum::REAL,
    }
  }
}
impl Surface_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Surface_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSite = self.idSite.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altSiteId = self.altSiteId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let primary = self.primary;
    let lengthFt = self.lengthFt;
    let ldaFt = self.ldaFt;
    let widthFt = self.widthFt;
    let lengthM = self.lengthM;
    let ldaM = self.ldaM;
    let widthM = self.widthM;
    let material = self.material.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let condition = self.condition.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rawWBC = self.rawWBC.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pcn = self.pcn.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lcn = self.lcn;
    let sWtKip = self.sWtKip;
    let tWtKip = self.tWtKip;
    let stWtKip = self.stWtKip;
    let ttWtKip = self.ttWtKip;
    let ddWtKip = self.ddWtKip;
    let sbttWtKip = self.sbttWtKip;
    let tdtWtkip = self.tdtWtkip;
    let trtWtKip = self.trtWtKip;
    let ddtWtKip = self.ddtWtKip;
    let sWtKN = self.sWtKN;
    let tWtKN = self.tWtKN;
    let stWtKN = self.stWtKN;
    let ttWtKN = self.ttWtKN;
    let ddWtKN = self.ddWtKN;
    let sbttWtKN = self.sbttWtKN;
    let tdtWtKN = self.tdtWtKN;
    let trtWtKN = self.trtWtKN;
    let ddtWtKN = self.ddtWtKN;
    let lighting = self.lighting;
    let lightsUNKN = self.lightsUNKN;
    let lightsAPRCH = self.lightsAPRCH;
    let lightsVASI = self.lightsVASI;
    let lightsPAPI = self.lightsPAPI;
    let lightsOLS = self.lightsOLS;
    let lightsREIL = self.lightsREIL;
    let lightsTDZL = self.lightsTDZL;
    let lightsCL = self.lightsCL;
    let obstacle = self.obstacle;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    Surface_Abridged::create(_fbb, &Surface_AbridgedArgs{
      id,
      classificationMarking,
      name,
      type_,
      idSite,
      altSiteId,
      primary,
      lengthFt,
      ldaFt,
      widthFt,
      lengthM,
      ldaM,
      widthM,
      material,
      condition,
      rawWBC,
      pcn,
      lcn,
      sWtKip,
      tWtKip,
      stWtKip,
      ttWtKip,
      ddWtKip,
      sbttWtKip,
      tdtWtkip,
      trtWtKip,
      ddtWtKip,
      sWtKN,
      tWtKN,
      stWtKN,
      ttWtKN,
      ddWtKN,
      sbttWtKN,
      tdtWtKN,
      trtWtKN,
      ddtWtKN,
      lighting,
      lightsUNKN,
      lightsAPRCH,
      lightsVASI,
      lightsPAPI,
      lightsOLS,
      lightsREIL,
      lightsTDZL,
      lightsCL,
      obstacle,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Surface_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_surface_abridged_unchecked`.
pub fn root_as_surface_abridged(buf: &[u8]) -> Result<Surface_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Surface_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Surface_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_surface_abridged_unchecked`.
pub fn size_prefixed_root_as_surface_abridged(buf: &[u8]) -> Result<Surface_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Surface_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Surface_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_surface_abridged_unchecked`.
pub fn root_as_surface_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Surface_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Surface_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Surface_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_surface_abridged_unchecked`.
pub fn size_prefixed_root_as_surface_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Surface_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Surface_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Surface_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Surface_Abridged`.
pub unsafe fn root_as_surface_abridged_unchecked(buf: &[u8]) -> Surface_Abridged {
  flatbuffers::root_unchecked::<Surface_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Surface_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Surface_Abridged`.
pub unsafe fn size_prefixed_root_as_surface_abridged_unchecked(buf: &[u8]) -> Surface_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<Surface_Abridged>(buf)
}
pub const SURFACE_ABRIDGED_IDENTIFIER: &str = "SURF";

#[inline]
pub fn surface_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SURFACE_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn surface_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SURFACE_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_surface_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Surface_Abridged<'a>>) {
  fbb.finish(root, Some(SURFACE_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_surface_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Surface_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(SURFACE_ABRIDGED_IDENTIFIER));
}
