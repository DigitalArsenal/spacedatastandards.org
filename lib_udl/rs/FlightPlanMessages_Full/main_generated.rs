// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum FlightPlanMessages_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Collection of messages associated with this flight plan indicating the severity, the point where the message was generated, the path (Primary, Alternate, etc.), and the text of the message.
pub struct FlightPlanMessages_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FlightPlanMessages_Full<'a> {
  type Inner = FlightPlanMessages_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FlightPlanMessages_Full<'a> {
  pub const VT_SEVERITY: flatbuffers::VOffsetT = 4;
  pub const VT_WPNUM: flatbuffers::VOffsetT = 6;
  pub const VT_ROUTEPATH: flatbuffers::VOffsetT = 8;
  pub const VT_MSGTEXT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FlightPlanMessages_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FlightPlanMessages_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<FlightPlanMessages_Full<'bldr>> {
    let mut builder = FlightPlanMessages_FullBuilder::new(_fbb);
    if let Some(x) = args.msgText { builder.add_msgText(x); }
    if let Some(x) = args.routePath { builder.add_routePath(x); }
    if let Some(x) = args.wpNum { builder.add_wpNum(x); }
    if let Some(x) = args.severity { builder.add_severity(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> FlightPlanMessages_FullT {
    let severity = self.severity().map(|x| {
      x.to_string()
    });
    let wpNum = self.wpNum().map(|x| {
      x.to_string()
    });
    let routePath = self.routePath().map(|x| {
      x.to_string()
    });
    let msgText = self.msgText().map(|x| {
      x.to_string()
    });
    FlightPlanMessages_FullT {
      severity,
      wpNum,
      routePath,
      msgText,
    }
  }

  /// The severity of the message.
  /// Example: /// Example: SEVERE
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn severity(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanMessages_Full::VT_SEVERITY, None)}
  }
  /// The waypoint number for which the message was generated, or enter "PLAN" for a message impacting the entire route.
  /// Example: /// Example: 20
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn wpNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanMessages_Full::VT_WPNUM, None)}
  }
  /// The flight path that generated the message (PRIMARY, ALTERNATE, etc.).
  /// Example: /// Example: PRIMARY
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn routePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanMessages_Full::VT_ROUTEPATH, None)}
  }
  /// The text of the message.
  /// Example: /// Example: Message text
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn msgText(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanMessages_Full::VT_MSGTEXT, None)}
  }
}

impl flatbuffers::Verifiable for FlightPlanMessages_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("severity", Self::VT_SEVERITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("wpNum", Self::VT_WPNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("routePath", Self::VT_ROUTEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msgText", Self::VT_MSGTEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct FlightPlanMessages_FullArgs<'a> {
    pub severity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub wpNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub routePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgText: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FlightPlanMessages_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    FlightPlanMessages_FullArgs {
      severity: None,
      wpNum: None,
      routePath: None,
      msgText: None,
    }
  }
}

pub struct FlightPlanMessages_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FlightPlanMessages_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_severity(&mut self, severity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanMessages_Full::VT_SEVERITY, severity);
  }
  #[inline]
  pub fn add_wpNum(&mut self, wpNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanMessages_Full::VT_WPNUM, wpNum);
  }
  #[inline]
  pub fn add_routePath(&mut self, routePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanMessages_Full::VT_ROUTEPATH, routePath);
  }
  #[inline]
  pub fn add_msgText(&mut self, msgText: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanMessages_Full::VT_MSGTEXT, msgText);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FlightPlanMessages_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FlightPlanMessages_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FlightPlanMessages_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FlightPlanMessages_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FlightPlanMessages_Full");
      ds.field("severity", &self.severity());
      ds.field("wpNum", &self.wpNum());
      ds.field("routePath", &self.routePath());
      ds.field("msgText", &self.msgText());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FlightPlanMessages_FullT {
  pub severity: Option<String>,
  pub wpNum: Option<String>,
  pub routePath: Option<String>,
  pub msgText: Option<String>,
}
impl Default for FlightPlanMessages_FullT {
  fn default() -> Self {
    Self {
      severity: None,
      wpNum: None,
      routePath: None,
      msgText: None,
    }
  }
}
impl FlightPlanMessages_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<FlightPlanMessages_Full<'b>> {
    let severity = self.severity.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let wpNum = self.wpNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let routePath = self.routePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msgText = self.msgText.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    FlightPlanMessages_Full::create(_fbb, &FlightPlanMessages_FullArgs{
      severity,
      wpNum,
      routePath,
      msgText,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `FlightPlanMessages_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_messages_full_unchecked`.
pub fn root_as_flight_plan_messages_full(buf: &[u8]) -> Result<FlightPlanMessages_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<FlightPlanMessages_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FlightPlanMessages_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_flight_plan_messages_full_unchecked`.
pub fn size_prefixed_root_as_flight_plan_messages_full(buf: &[u8]) -> Result<FlightPlanMessages_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<FlightPlanMessages_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FlightPlanMessages_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_messages_full_unchecked`.
pub fn root_as_flight_plan_messages_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlightPlanMessages_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<FlightPlanMessages_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FlightPlanMessages_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_messages_full_unchecked`.
pub fn size_prefixed_root_as_flight_plan_messages_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlightPlanMessages_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<FlightPlanMessages_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FlightPlanMessages_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FlightPlanMessages_Full`.
pub unsafe fn root_as_flight_plan_messages_full_unchecked(buf: &[u8]) -> FlightPlanMessages_Full {
  flatbuffers::root_unchecked::<FlightPlanMessages_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FlightPlanMessages_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FlightPlanMessages_Full`.
pub unsafe fn size_prefixed_root_as_flight_plan_messages_full_unchecked(buf: &[u8]) -> FlightPlanMessages_Full {
  flatbuffers::size_prefixed_root_unchecked::<FlightPlanMessages_Full>(buf)
}
pub const FLIGHT_PLAN_MESSAGES_FULL_IDENTIFIER: &str = "FLIG";

#[inline]
pub fn flight_plan_messages_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, FLIGHT_PLAN_MESSAGES_FULL_IDENTIFIER, false)
}

#[inline]
pub fn flight_plan_messages_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, FLIGHT_PLAN_MESSAGES_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_flight_plan_messages_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<FlightPlanMessages_Full<'a>>) {
  fbb.finish(root, Some(FLIGHT_PLAN_MESSAGES_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_flight_plan_messages_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<FlightPlanMessages_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(FLIGHT_PLAN_MESSAGES_FULL_IDENTIFIER));
}
