// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum IonoObservationElevation_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Multidimensional array of incoming elevation at the receiver. Has the same dimensions as power. Antenna type, configuration, and method of determination to be documented in the metadata notes field.
pub struct IonoObservationElevation_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IonoObservationElevation_Abridged<'a> {
  type Inner = IonoObservationElevation_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IonoObservationElevation_Abridged<'a> {
  pub const VT_NOTES: flatbuffers::VOffsetT = 4;
  pub const VT_DIMENSIONS: flatbuffers::VOffsetT = 6;
  pub const VT_DIMENSIONNAME: flatbuffers::VOffsetT = 8;
  pub const VT_DATA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IonoObservationElevation_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IonoObservationElevation_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<IonoObservationElevation_Abridged<'bldr>> {
    let mut builder = IonoObservationElevation_AbridgedBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.dimensionName { builder.add_dimensionName(x); }
    if let Some(x) = args.dimensions { builder.add_dimensions(x); }
    if let Some(x) = args.notes { builder.add_notes(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> IonoObservationElevation_AbridgedT {
    let notes = self.notes().map(|x| {
      x.to_string()
    });
    let dimensions = self.dimensions().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let dimensionName = self.dimensionName().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let data = self.data().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    IonoObservationElevation_AbridgedT {
      notes,
      dimensions,
      dimensionName,
      data,
    }
  }

  /// Notes for the elevation data.
  /// Example: /// Example: NOTES
  /// Constraints: Minimum length = 0, Maximum length = 512
  #[inline]
  pub fn notes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservationElevation_Abridged::VT_NOTES, None)}
  }
  /// Array of integers of the elevation array dimensions.
  /// Example: /// Example: [2, 3]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dimensions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservationElevation_Abridged::VT_DIMENSIONS, None)}
  }
  /// Array of names for dimensions.
  /// Example: /// Example: ['NAME1', 'NAME2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dimensionName(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservationElevation_Abridged::VT_DIMENSIONNAME, None)}
  }
  /// Array of incoming elevation at the receiver.
  /// Example: /// Example: [[[[[[[0.02, 0.034]]]]]]]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservationElevation_Abridged::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for IonoObservationElevation_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("notes", Self::VT_NOTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("dimensions", Self::VT_DIMENSIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("dimensionName", Self::VT_DIMENSIONNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct IonoObservationElevation_AbridgedArgs<'a> {
    pub notes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dimensions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub dimensionName: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for IonoObservationElevation_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    IonoObservationElevation_AbridgedArgs {
      notes: None,
      dimensions: None,
      dimensionName: None,
      data: None,
    }
  }
}

pub struct IonoObservationElevation_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IonoObservationElevation_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_notes(&mut self, notes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationElevation_Abridged::VT_NOTES, notes);
  }
  #[inline]
  pub fn add_dimensions(&mut self, dimensions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationElevation_Abridged::VT_DIMENSIONS, dimensions);
  }
  #[inline]
  pub fn add_dimensionName(&mut self, dimensionName: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationElevation_Abridged::VT_DIMENSIONNAME, dimensionName);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationElevation_Abridged::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IonoObservationElevation_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IonoObservationElevation_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IonoObservationElevation_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IonoObservationElevation_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IonoObservationElevation_Abridged");
      ds.field("notes", &self.notes());
      ds.field("dimensions", &self.dimensions());
      ds.field("dimensionName", &self.dimensionName());
      ds.field("data", &self.data());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct IonoObservationElevation_AbridgedT {
  pub notes: Option<String>,
  pub dimensions: Option<Vec<String>>,
  pub dimensionName: Option<Vec<String>>,
  pub data: Option<Vec<String>>,
}
impl Default for IonoObservationElevation_AbridgedT {
  fn default() -> Self {
    Self {
      notes: None,
      dimensions: None,
      dimensionName: None,
      data: None,
    }
  }
}
impl IonoObservationElevation_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<IonoObservationElevation_Abridged<'b>> {
    let notes = self.notes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dimensions = self.dimensions.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let dimensionName = self.dimensionName.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let data = self.data.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    IonoObservationElevation_Abridged::create(_fbb, &IonoObservationElevation_AbridgedArgs{
      notes,
      dimensions,
      dimensionName,
      data,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `IonoObservationElevation_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_iono_observation_elevation_abridged_unchecked`.
pub fn root_as_iono_observation_elevation_abridged(buf: &[u8]) -> Result<IonoObservationElevation_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<IonoObservationElevation_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `IonoObservationElevation_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_iono_observation_elevation_abridged_unchecked`.
pub fn size_prefixed_root_as_iono_observation_elevation_abridged(buf: &[u8]) -> Result<IonoObservationElevation_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<IonoObservationElevation_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `IonoObservationElevation_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_iono_observation_elevation_abridged_unchecked`.
pub fn root_as_iono_observation_elevation_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<IonoObservationElevation_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<IonoObservationElevation_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `IonoObservationElevation_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_iono_observation_elevation_abridged_unchecked`.
pub fn size_prefixed_root_as_iono_observation_elevation_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<IonoObservationElevation_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<IonoObservationElevation_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a IonoObservationElevation_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `IonoObservationElevation_Abridged`.
pub unsafe fn root_as_iono_observation_elevation_abridged_unchecked(buf: &[u8]) -> IonoObservationElevation_Abridged {
  flatbuffers::root_unchecked::<IonoObservationElevation_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed IonoObservationElevation_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `IonoObservationElevation_Abridged`.
pub unsafe fn size_prefixed_root_as_iono_observation_elevation_abridged_unchecked(buf: &[u8]) -> IonoObservationElevation_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<IonoObservationElevation_Abridged>(buf)
}
pub const IONO_OBSERVATION_ELEVATION_ABRIDGED_IDENTIFIER: &str = "IONO";

#[inline]
pub fn iono_observation_elevation_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, IONO_OBSERVATION_ELEVATION_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn iono_observation_elevation_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, IONO_OBSERVATION_ELEVATION_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_iono_observation_elevation_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<IonoObservationElevation_Abridged<'a>>) {
  fbb.finish(root, Some(IONO_OBSERVATION_ELEVATION_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_iono_observation_elevation_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<IonoObservationElevation_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(IONO_OBSERVATION_ELEVATION_ABRIDGED_IDENTIFIER));
}
