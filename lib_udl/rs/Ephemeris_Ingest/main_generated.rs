// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EPHEMERIS_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EPHEMERIS_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EPHEMERIS_INGEST_DATA_MODE_ENUM: [Ephemeris_Ingest_dataMode_Enum; 4] = [
  Ephemeris_Ingest_dataMode_Enum::REAL,
  Ephemeris_Ingest_dataMode_Enum::TEST,
  Ephemeris_Ingest_dataMode_Enum::SIMULATED,
  Ephemeris_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Ephemeris_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Ephemeris_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Ephemeris_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Ephemeris_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Ephemeris_Ingest_dataMode_Enum {
    type Output = Ephemeris_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Ephemeris_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Ephemeris_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Ephemeris_Ingest_dataMode_Enum {}
pub enum Ephemeris_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID (esId).
pub struct Ephemeris_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ephemeris_Ingest<'a> {
  type Inner = Ephemeris_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Ephemeris_Ingest<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_ESID: flatbuffers::VOffsetT = 8;
  pub const VT_TS: flatbuffers::VOffsetT = 10;
  pub const VT_XPOS: flatbuffers::VOffsetT = 12;
  pub const VT_YPOS: flatbuffers::VOffsetT = 14;
  pub const VT_ZPOS: flatbuffers::VOffsetT = 16;
  pub const VT_XVEL: flatbuffers::VOffsetT = 18;
  pub const VT_YVEL: flatbuffers::VOffsetT = 20;
  pub const VT_ZVEL: flatbuffers::VOffsetT = 22;
  pub const VT_XACCEL: flatbuffers::VOffsetT = 24;
  pub const VT_YACCEL: flatbuffers::VOffsetT = 26;
  pub const VT_ZACCEL: flatbuffers::VOffsetT = 28;
  pub const VT_COV: flatbuffers::VOffsetT = 30;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 32;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 34;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 36;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 38;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 40;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 42;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 44;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Ephemeris_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Ephemeris_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<Ephemeris_Ingest<'bldr>> {
    let mut builder = Ephemeris_IngestBuilder::new(_fbb);
    builder.add_zaccel(args.zaccel);
    builder.add_yaccel(args.yaccel);
    builder.add_xaccel(args.xaccel);
    builder.add_zvel(args.zvel);
    builder.add_yvel(args.yvel);
    builder.add_xvel(args.xvel);
    builder.add_zpos(args.zpos);
    builder.add_ypos(args.ypos);
    builder.add_xpos(args.xpos);
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.cov { builder.add_cov(x); }
    if let Some(x) = args.ts { builder.add_ts(x); }
    if let Some(x) = args.esId { builder.add_esId(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> Ephemeris_IngestT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let esId = self.esId().map(|x| {
      x.to_string()
    });
    let ts = self.ts().map(|x| {
      x.to_string()
    });
    let xpos = self.xpos();
    let ypos = self.ypos();
    let zpos = self.zpos();
    let xvel = self.xvel();
    let yvel = self.yvel();
    let zvel = self.zvel();
    let xaccel = self.xaccel();
    let yaccel = self.yaccel();
    let zaccel = self.zaccel();
    let cov = self.cov().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    Ephemeris_IngestT {
      id,
      classificationMarking,
      esId,
      ts,
      xpos,
      ypos,
      zpos,
      xvel,
      yvel,
      zvel,
      xaccel,
      yaccel,
      zaccel,
      cov,
      createdAt,
      createdBy,
      source,
      dataMode,
      idOnOrbit,
      origObjectId,
      origin,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: EPHEMERIS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris_Ingest::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the parent EphemerisSet, auto-generated by the system. The esId (ephemerisSet id) is used to identify all individual ephemeris states associated with a parent ephemerisSet.
  /// Example: /// Example: ES-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn esId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris_Ingest::VT_ESID, None)}
  }
  /// Time associated with the Ephemeris Point, in ISO8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ts(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris_Ingest::VT_TS, None)}
  }
  /// Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xpos(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Ephemeris_Ingest::VT_XPOS, Some(0.0)).unwrap()}
  }
  /// Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ypos(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Ephemeris_Ingest::VT_YPOS, Some(0.0)).unwrap()}
  }
  /// Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zpos(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Ephemeris_Ingest::VT_ZPOS, Some(0.0)).unwrap()}
  }
  /// Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xvel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Ephemeris_Ingest::VT_XVEL, Some(0.0)).unwrap()}
  }
  /// Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yvel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Ephemeris_Ingest::VT_YVEL, Some(0.0)).unwrap()}
  }
  /// Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zvel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Ephemeris_Ingest::VT_ZVEL, Some(0.0)).unwrap()}
  }
  /// Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xaccel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Ephemeris_Ingest::VT_XACCEL, Some(0.0)).unwrap()}
  }
  /// Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yaccel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Ephemeris_Ingest::VT_YACCEL, Some(0.0)).unwrap()}
  }
  /// Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zaccel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Ephemeris_Ingest::VT_ZACCEL, Some(0.0)).unwrap()}
  }
  /// Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
  /// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
  /// x&nbsp;&nbsp;&nbsp;&nbsp;1
  /// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
  /// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
  /// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
  /// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
  /// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
  /// The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cov(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Ephemeris_Ingest::VT_COV, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris_Ingest::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris_Ingest::VT_SOURCE, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> Ephemeris_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Ephemeris_Ingest_dataMode_Enum>(Ephemeris_Ingest::VT_DATAMODE, Some(Ephemeris_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
  /// Unique identifier of the on-orbit satellite object.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris_Ingest::VT_IDONORBIT, None)}
  }
  /// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris_Ingest::VT_ORIGOBJECTID, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Ephemeris_Ingest::VT_ORIGIN, None)}
  }
}

impl flatbuffers::Verifiable for Ephemeris_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("esId", Self::VT_ESID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ts", Self::VT_TS, false)?
     .visit_field::<f64>("xpos", Self::VT_XPOS, false)?
     .visit_field::<f64>("ypos", Self::VT_YPOS, false)?
     .visit_field::<f64>("zpos", Self::VT_ZPOS, false)?
     .visit_field::<f64>("xvel", Self::VT_XVEL, false)?
     .visit_field::<f64>("yvel", Self::VT_YVEL, false)?
     .visit_field::<f64>("zvel", Self::VT_ZVEL, false)?
     .visit_field::<f64>("xaccel", Self::VT_XACCEL, false)?
     .visit_field::<f64>("yaccel", Self::VT_YACCEL, false)?
     .visit_field::<f64>("zaccel", Self::VT_ZACCEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("cov", Self::VT_COV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<Ephemeris_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .finish();
    Ok(())
  }
}
pub struct Ephemeris_IngestArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub esId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub xpos: f64,
    pub ypos: f64,
    pub zpos: f64,
    pub xvel: f64,
    pub yvel: f64,
    pub zvel: f64,
    pub xaccel: f64,
    pub yaccel: f64,
    pub zaccel: f64,
    pub cov: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: Ephemeris_Ingest_dataMode_Enum,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Ephemeris_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    Ephemeris_IngestArgs {
      id: None,
      classificationMarking: None,
      esId: None,
      ts: None,
      xpos: 0.0,
      ypos: 0.0,
      zpos: 0.0,
      xvel: 0.0,
      yvel: 0.0,
      zvel: 0.0,
      xaccel: 0.0,
      yaccel: 0.0,
      zaccel: 0.0,
      cov: None,
      createdAt: None,
      createdBy: None,
      source: None,
      dataMode: Ephemeris_Ingest_dataMode_Enum::REAL,
      idOnOrbit: None,
      origObjectId: None,
      origin: None,
    }
  }
}

pub struct Ephemeris_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Ephemeris_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris_Ingest::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_esId(&mut self, esId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris_Ingest::VT_ESID, esId);
  }
  #[inline]
  pub fn add_ts(&mut self, ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris_Ingest::VT_TS, ts);
  }
  #[inline]
  pub fn add_xpos(&mut self, xpos: f64) {
    self.fbb_.push_slot::<f64>(Ephemeris_Ingest::VT_XPOS, xpos, 0.0);
  }
  #[inline]
  pub fn add_ypos(&mut self, ypos: f64) {
    self.fbb_.push_slot::<f64>(Ephemeris_Ingest::VT_YPOS, ypos, 0.0);
  }
  #[inline]
  pub fn add_zpos(&mut self, zpos: f64) {
    self.fbb_.push_slot::<f64>(Ephemeris_Ingest::VT_ZPOS, zpos, 0.0);
  }
  #[inline]
  pub fn add_xvel(&mut self, xvel: f64) {
    self.fbb_.push_slot::<f64>(Ephemeris_Ingest::VT_XVEL, xvel, 0.0);
  }
  #[inline]
  pub fn add_yvel(&mut self, yvel: f64) {
    self.fbb_.push_slot::<f64>(Ephemeris_Ingest::VT_YVEL, yvel, 0.0);
  }
  #[inline]
  pub fn add_zvel(&mut self, zvel: f64) {
    self.fbb_.push_slot::<f64>(Ephemeris_Ingest::VT_ZVEL, zvel, 0.0);
  }
  #[inline]
  pub fn add_xaccel(&mut self, xaccel: f64) {
    self.fbb_.push_slot::<f64>(Ephemeris_Ingest::VT_XACCEL, xaccel, 0.0);
  }
  #[inline]
  pub fn add_yaccel(&mut self, yaccel: f64) {
    self.fbb_.push_slot::<f64>(Ephemeris_Ingest::VT_YACCEL, yaccel, 0.0);
  }
  #[inline]
  pub fn add_zaccel(&mut self, zaccel: f64) {
    self.fbb_.push_slot::<f64>(Ephemeris_Ingest::VT_ZACCEL, zaccel, 0.0);
  }
  #[inline]
  pub fn add_cov(&mut self, cov: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris_Ingest::VT_COV, cov);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Ephemeris_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<Ephemeris_Ingest_dataMode_Enum>(Ephemeris_Ingest::VT_DATAMODE, dataMode, Ephemeris_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris_Ingest::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris_Ingest::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Ephemeris_Ingest::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Ephemeris_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Ephemeris_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ephemeris_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Ephemeris_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Ephemeris_Ingest");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("esId", &self.esId());
      ds.field("ts", &self.ts());
      ds.field("xpos", &self.xpos());
      ds.field("ypos", &self.ypos());
      ds.field("zpos", &self.zpos());
      ds.field("xvel", &self.xvel());
      ds.field("yvel", &self.yvel());
      ds.field("zvel", &self.zvel());
      ds.field("xaccel", &self.xaccel());
      ds.field("yaccel", &self.yaccel());
      ds.field("zaccel", &self.zaccel());
      ds.field("cov", &self.cov());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("dataMode", &self.dataMode());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("origin", &self.origin());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Ephemeris_IngestT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub esId: Option<String>,
  pub ts: Option<String>,
  pub xpos: f64,
  pub ypos: f64,
  pub zpos: f64,
  pub xvel: f64,
  pub yvel: f64,
  pub zvel: f64,
  pub xaccel: f64,
  pub yaccel: f64,
  pub zaccel: f64,
  pub cov: Option<Vec<String>>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub dataMode: Ephemeris_Ingest_dataMode_Enum,
  pub idOnOrbit: Option<String>,
  pub origObjectId: Option<String>,
  pub origin: Option<String>,
}
impl Default for Ephemeris_IngestT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      esId: None,
      ts: None,
      xpos: 0.0,
      ypos: 0.0,
      zpos: 0.0,
      xvel: 0.0,
      yvel: 0.0,
      zvel: 0.0,
      xaccel: 0.0,
      yaccel: 0.0,
      zaccel: 0.0,
      cov: None,
      createdAt: None,
      createdBy: None,
      source: None,
      dataMode: Ephemeris_Ingest_dataMode_Enum::REAL,
      idOnOrbit: None,
      origObjectId: None,
      origin: None,
    }
  }
}
impl Ephemeris_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Ephemeris_Ingest<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let esId = self.esId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ts = self.ts.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let xpos = self.xpos;
    let ypos = self.ypos;
    let zpos = self.zpos;
    let xvel = self.xvel;
    let yvel = self.yvel;
    let zvel = self.zvel;
    let xaccel = self.xaccel;
    let yaccel = self.yaccel;
    let zaccel = self.zaccel;
    let cov = self.cov.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Ephemeris_Ingest::create(_fbb, &Ephemeris_IngestArgs{
      id,
      classificationMarking,
      esId,
      ts,
      xpos,
      ypos,
      zpos,
      xvel,
      yvel,
      zvel,
      xaccel,
      yaccel,
      zaccel,
      cov,
      createdAt,
      createdBy,
      source,
      dataMode,
      idOnOrbit,
      origObjectId,
      origin,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Ephemeris_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ephemeris_ingest_unchecked`.
pub fn root_as_ephemeris_ingest(buf: &[u8]) -> Result<Ephemeris_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Ephemeris_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Ephemeris_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ephemeris_ingest_unchecked`.
pub fn size_prefixed_root_as_ephemeris_ingest(buf: &[u8]) -> Result<Ephemeris_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Ephemeris_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Ephemeris_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ephemeris_ingest_unchecked`.
pub fn root_as_ephemeris_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Ephemeris_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Ephemeris_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Ephemeris_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ephemeris_ingest_unchecked`.
pub fn size_prefixed_root_as_ephemeris_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Ephemeris_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Ephemeris_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Ephemeris_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Ephemeris_Ingest`.
pub unsafe fn root_as_ephemeris_ingest_unchecked(buf: &[u8]) -> Ephemeris_Ingest {
  flatbuffers::root_unchecked::<Ephemeris_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Ephemeris_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Ephemeris_Ingest`.
pub unsafe fn size_prefixed_root_as_ephemeris_ingest_unchecked(buf: &[u8]) -> Ephemeris_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<Ephemeris_Ingest>(buf)
}
pub const EPHEMERIS_INGEST_IDENTIFIER: &str = "EPHE";

#[inline]
pub fn ephemeris_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EPHEMERIS_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn ephemeris_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EPHEMERIS_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_ephemeris_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Ephemeris_Ingest<'a>>) {
  fbb.finish(root, Some(EPHEMERIS_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_ephemeris_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Ephemeris_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(EPHEMERIS_INGEST_IDENTIFIER));
}
