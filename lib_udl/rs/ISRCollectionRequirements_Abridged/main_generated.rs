// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum ISRCollectionRequirements_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Tasking desired collection requirements.
pub struct ISRCollectionRequirements_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ISRCollectionRequirements_Abridged<'a> {
  type Inner = ISRCollectionRequirements_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ISRCollectionRequirements_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_HASH: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
  pub const VT_CRIDNUMBERS: flatbuffers::VOffsetT = 10;
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 12;
  pub const VT_RECORDID: flatbuffers::VOffsetT = 14;
  pub const VT_RECONSURVEY: flatbuffers::VOffsetT = 16;
  pub const VT_INTELDISCIPLINE: flatbuffers::VOffsetT = 18;
  pub const VT_SECONDARY: flatbuffers::VOffsetT = 20;
  pub const VT_EMPHASIZED: flatbuffers::VOffsetT = 22;
  pub const VT_ISPRISMCR: flatbuffers::VOffsetT = 24;
  pub const VT_START: flatbuffers::VOffsetT = 26;
  pub const VT_STOP: flatbuffers::VOffsetT = 28;
  pub const VT_OPERATION: flatbuffers::VOffsetT = 30;
  pub const VT_SUPPORTEDUNIT: flatbuffers::VOffsetT = 32;
  pub const VT_COUNTRY: flatbuffers::VOffsetT = 34;
  pub const VT_REGION: flatbuffers::VOffsetT = 36;
  pub const VT_SUBREGION: flatbuffers::VOffsetT = 38;
  pub const VT_SPECIALCOMGUIDANCE: flatbuffers::VOffsetT = 40;
  pub const VT_CRITICALTIMES: flatbuffers::VOffsetT = 42;
  pub const VT_EXPLOITATIONREQUIREMENT: flatbuffers::VOffsetT = 44;
  pub const VT_TARGETLIST: flatbuffers::VOffsetT = 46;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ISRCollectionRequirements_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ISRCollectionRequirements_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<ISRCollectionRequirements_Abridged<'bldr>> {
    let mut builder = ISRCollectionRequirements_AbridgedBuilder::new(_fbb);
    builder.add_priority(args.priority);
    if let Some(x) = args.targetList { builder.add_targetList(x); }
    if let Some(x) = args.exploitationRequirement { builder.add_exploitationRequirement(x); }
    if let Some(x) = args.criticalTimes { builder.add_criticalTimes(x); }
    if let Some(x) = args.specialComGuidance { builder.add_specialComGuidance(x); }
    if let Some(x) = args.subregion { builder.add_subregion(x); }
    if let Some(x) = args.region { builder.add_region(x); }
    if let Some(x) = args.country { builder.add_country(x); }
    if let Some(x) = args.supportedUnit { builder.add_supportedUnit(x); }
    if let Some(x) = args.operation { builder.add_operation(x); }
    if let Some(x) = args.stop { builder.add_stop(x); }
    if let Some(x) = args.start { builder.add_start(x); }
    if let Some(x) = args.intelDiscipline { builder.add_intelDiscipline(x); }
    if let Some(x) = args.reconSurvey { builder.add_reconSurvey(x); }
    if let Some(x) = args.recordId { builder.add_recordId(x); }
    if let Some(x) = args.cridNumbers { builder.add_cridNumbers(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.hash { builder.add_hash(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_isPrismCr(args.isPrismCr);
    builder.add_emphasized(args.emphasized);
    builder.add_secondary(args.secondary);
    builder.finish()
  }

  pub fn unpack(&self) -> ISRCollectionRequirements_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let hash = self.hash().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let cridNumbers = self.cridNumbers().map(|x| {
      x.to_string()
    });
    let priority = self.priority();
    let recordId = self.recordId().map(|x| {
      x.to_string()
    });
    let reconSurvey = self.reconSurvey().map(|x| {
      x.to_string()
    });
    let intelDiscipline = self.intelDiscipline().map(|x| {
      x.to_string()
    });
    let secondary = self.secondary();
    let emphasized = self.emphasized();
    let isPrismCr = self.isPrismCr();
    let start = self.start().map(|x| {
      x.to_string()
    });
    let stop = self.stop().map(|x| {
      x.to_string()
    });
    let operation = self.operation().map(|x| {
      x.to_string()
    });
    let supportedUnit = self.supportedUnit().map(|x| {
      x.to_string()
    });
    let country = self.country().map(|x| {
      x.to_string()
    });
    let region = self.region().map(|x| {
      x.to_string()
    });
    let subregion = self.subregion().map(|x| {
      x.to_string()
    });
    let specialComGuidance = self.specialComGuidance().map(|x| {
      x.to_string()
    });
    let criticalTimes = self.criticalTimes().map(|x| {
      x.to_string()
    });
    let exploitationRequirement = self.exploitationRequirement().map(|x| {
      x.to_string()
    });
    let targetList = self.targetList().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    ISRCollectionRequirements_AbridgedT {
      id,
      hash,
      type_,
      cridNumbers,
      priority,
      recordId,
      reconSurvey,
      intelDiscipline,
      secondary,
      emphasized,
      isPrismCr,
      start,
      stop,
      operation,
      supportedUnit,
      country,
      region,
      subregion,
      specialComGuidance,
      criticalTimes,
      exploitationRequirement,
      targetList,
    }
  }

  /// Collection Requirement Unique Identifier.
  /// Example: /// Example: ISCRCOLLECTIONREQUIREMENTS
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_ID, None)}
  }
  /// Encryption hashing algorithm.
  /// Example: /// Example: HASH
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn hash(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_HASH, None)}
  }
  /// Type collection this requirement applies to.
  /// Example: /// Example: COLLECTION_TYPE
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_TYPE_, None)}
  }
  /// Collection Requirement Unique Identifier.
  /// Example: /// Example: CRID
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn cridNumbers(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_CRIDNUMBERS, None)}
  }
  /// 1-n priority for this collection requirement.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn priority(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ISRCollectionRequirements_Abridged::VT_PRIORITY, Some(0.0)).unwrap()}
  }
  /// Record id.
  /// Example: /// Example: RECORD-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn recordId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_RECORDID, None)}
  }
  /// Reconnaissance Survey information the operator needs.
  /// Example: /// Example: SURVEY_INFO
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn reconSurvey(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_RECONSURVEY, None)}
  }
  /// Primary type of intelligence to be collected for this requirement.
  /// Example: /// Example: Sig
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn intelDiscipline(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_INTELDISCIPLINE, None)}
  }
  /// Sub category of primary intelligence to be collected for this requirement.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn secondary(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ISRCollectionRequirements_Abridged::VT_SECONDARY, Some(false)).unwrap()}
  }
  /// Is this collection requirement an emphasized/critical requirement.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn emphasized(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ISRCollectionRequirements_Abridged::VT_EMPHASIZED, Some(false)).unwrap()}
  }
  /// Is this collection request for the Prism system?.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn isPrismCr(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ISRCollectionRequirements_Abridged::VT_ISPRISMCR, Some(false)).unwrap()}
  }
  /// Start time for this requirement, should be within the mission time window.
  /// Example: /// Example: 2021-01-19T01:01:15.001Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn start(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_START, None)}
  }
  /// Stop time for this requirement, should be within the mission time window.
  /// Example: /// Example: 2021-01-19T01:20:01.001Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stop(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_STOP, None)}
  }
  /// Human readable name for this operation.
  /// Example: /// Example: NAME
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn operation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_OPERATION, None)}
  }
  /// The name of the military unit that this assigned collection requirement will support.
  /// Example: /// Example: UNIT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn supportedUnit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_SUPPORTEDUNIT, None)}
  }
  /// Country code of the collection requirement. A Country may represent countries, multi-national consortiums, and international organizations.
  /// Example: /// Example: COUNTRY_CODE
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn country(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_COUNTRY, None)}
  }
  /// Region of the collection requirement.
  /// Example: /// Example: REGION
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn region(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_REGION, None)}
  }
  /// Subregion of the collection requirement.
  /// Example: /// Example: SUBREGION
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn subregion(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_SUBREGION, None)}
  }
  /// Free text field for the user to specify special instructions needed for this collection.
  /// Example: /// Example: TEXT
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn specialComGuidance(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_SPECIALCOMGUIDANCE, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn criticalTimes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_CRITICALTIMES, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn exploitationRequirement(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ISRCollectionRequirements_Abridged::VT_EXPLOITATIONREQUIREMENT, None)}
  }
  /// Array of POI Id's for the targets being tasked.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn targetList(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ISRCollectionRequirements_Abridged::VT_TARGETLIST, None)}
  }
}

impl flatbuffers::Verifiable for ISRCollectionRequirements_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hash", Self::VT_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cridNumbers", Self::VT_CRIDNUMBERS, false)?
     .visit_field::<f64>("priority", Self::VT_PRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recordId", Self::VT_RECORDID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reconSurvey", Self::VT_RECONSURVEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("intelDiscipline", Self::VT_INTELDISCIPLINE, false)?
     .visit_field::<bool>("secondary", Self::VT_SECONDARY, false)?
     .visit_field::<bool>("emphasized", Self::VT_EMPHASIZED, false)?
     .visit_field::<bool>("isPrismCr", Self::VT_ISPRISMCR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("start", Self::VT_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stop", Self::VT_STOP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("operation", Self::VT_OPERATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("supportedUnit", Self::VT_SUPPORTEDUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("country", Self::VT_COUNTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("region", Self::VT_REGION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subregion", Self::VT_SUBREGION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("specialComGuidance", Self::VT_SPECIALCOMGUIDANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("criticalTimes", Self::VT_CRITICALTIMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("exploitationRequirement", Self::VT_EXPLOITATIONREQUIREMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("targetList", Self::VT_TARGETLIST, false)?
     .finish();
    Ok(())
  }
}
pub struct ISRCollectionRequirements_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hash: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cridNumbers: Option<flatbuffers::WIPOffset<&'a str>>,
    pub priority: f64,
    pub recordId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reconSurvey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub intelDiscipline: Option<flatbuffers::WIPOffset<&'a str>>,
    pub secondary: bool,
    pub emphasized: bool,
    pub isPrismCr: bool,
    pub start: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stop: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub supportedUnit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub country: Option<flatbuffers::WIPOffset<&'a str>>,
    pub region: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subregion: Option<flatbuffers::WIPOffset<&'a str>>,
    pub specialComGuidance: Option<flatbuffers::WIPOffset<&'a str>>,
    pub criticalTimes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub exploitationRequirement: Option<flatbuffers::WIPOffset<&'a str>>,
    pub targetList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ISRCollectionRequirements_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    ISRCollectionRequirements_AbridgedArgs {
      id: None,
      hash: None,
      type_: None,
      cridNumbers: None,
      priority: 0.0,
      recordId: None,
      reconSurvey: None,
      intelDiscipline: None,
      secondary: false,
      emphasized: false,
      isPrismCr: false,
      start: None,
      stop: None,
      operation: None,
      supportedUnit: None,
      country: None,
      region: None,
      subregion: None,
      specialComGuidance: None,
      criticalTimes: None,
      exploitationRequirement: None,
      targetList: None,
    }
  }
}

pub struct ISRCollectionRequirements_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ISRCollectionRequirements_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_HASH, hash);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_cridNumbers(&mut self, cridNumbers: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_CRIDNUMBERS, cridNumbers);
  }
  #[inline]
  pub fn add_priority(&mut self, priority: f64) {
    self.fbb_.push_slot::<f64>(ISRCollectionRequirements_Abridged::VT_PRIORITY, priority, 0.0);
  }
  #[inline]
  pub fn add_recordId(&mut self, recordId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_RECORDID, recordId);
  }
  #[inline]
  pub fn add_reconSurvey(&mut self, reconSurvey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_RECONSURVEY, reconSurvey);
  }
  #[inline]
  pub fn add_intelDiscipline(&mut self, intelDiscipline: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_INTELDISCIPLINE, intelDiscipline);
  }
  #[inline]
  pub fn add_secondary(&mut self, secondary: bool) {
    self.fbb_.push_slot::<bool>(ISRCollectionRequirements_Abridged::VT_SECONDARY, secondary, false);
  }
  #[inline]
  pub fn add_emphasized(&mut self, emphasized: bool) {
    self.fbb_.push_slot::<bool>(ISRCollectionRequirements_Abridged::VT_EMPHASIZED, emphasized, false);
  }
  #[inline]
  pub fn add_isPrismCr(&mut self, isPrismCr: bool) {
    self.fbb_.push_slot::<bool>(ISRCollectionRequirements_Abridged::VT_ISPRISMCR, isPrismCr, false);
  }
  #[inline]
  pub fn add_start(&mut self, start: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_START, start);
  }
  #[inline]
  pub fn add_stop(&mut self, stop: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_STOP, stop);
  }
  #[inline]
  pub fn add_operation(&mut self, operation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_OPERATION, operation);
  }
  #[inline]
  pub fn add_supportedUnit(&mut self, supportedUnit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_SUPPORTEDUNIT, supportedUnit);
  }
  #[inline]
  pub fn add_country(&mut self, country: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_COUNTRY, country);
  }
  #[inline]
  pub fn add_region(&mut self, region: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_REGION, region);
  }
  #[inline]
  pub fn add_subregion(&mut self, subregion: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_SUBREGION, subregion);
  }
  #[inline]
  pub fn add_specialComGuidance(&mut self, specialComGuidance: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_SPECIALCOMGUIDANCE, specialComGuidance);
  }
  #[inline]
  pub fn add_criticalTimes(&mut self, criticalTimes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_CRITICALTIMES, criticalTimes);
  }
  #[inline]
  pub fn add_exploitationRequirement(&mut self, exploitationRequirement: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_EXPLOITATIONREQUIREMENT, exploitationRequirement);
  }
  #[inline]
  pub fn add_targetList(&mut self, targetList: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ISRCollectionRequirements_Abridged::VT_TARGETLIST, targetList);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ISRCollectionRequirements_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ISRCollectionRequirements_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ISRCollectionRequirements_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ISRCollectionRequirements_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ISRCollectionRequirements_Abridged");
      ds.field("id", &self.id());
      ds.field("hash", &self.hash());
      ds.field("type_", &self.type_());
      ds.field("cridNumbers", &self.cridNumbers());
      ds.field("priority", &self.priority());
      ds.field("recordId", &self.recordId());
      ds.field("reconSurvey", &self.reconSurvey());
      ds.field("intelDiscipline", &self.intelDiscipline());
      ds.field("secondary", &self.secondary());
      ds.field("emphasized", &self.emphasized());
      ds.field("isPrismCr", &self.isPrismCr());
      ds.field("start", &self.start());
      ds.field("stop", &self.stop());
      ds.field("operation", &self.operation());
      ds.field("supportedUnit", &self.supportedUnit());
      ds.field("country", &self.country());
      ds.field("region", &self.region());
      ds.field("subregion", &self.subregion());
      ds.field("specialComGuidance", &self.specialComGuidance());
      ds.field("criticalTimes", &self.criticalTimes());
      ds.field("exploitationRequirement", &self.exploitationRequirement());
      ds.field("targetList", &self.targetList());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ISRCollectionRequirements_AbridgedT {
  pub id: Option<String>,
  pub hash: Option<String>,
  pub type_: Option<String>,
  pub cridNumbers: Option<String>,
  pub priority: f64,
  pub recordId: Option<String>,
  pub reconSurvey: Option<String>,
  pub intelDiscipline: Option<String>,
  pub secondary: bool,
  pub emphasized: bool,
  pub isPrismCr: bool,
  pub start: Option<String>,
  pub stop: Option<String>,
  pub operation: Option<String>,
  pub supportedUnit: Option<String>,
  pub country: Option<String>,
  pub region: Option<String>,
  pub subregion: Option<String>,
  pub specialComGuidance: Option<String>,
  pub criticalTimes: Option<String>,
  pub exploitationRequirement: Option<String>,
  pub targetList: Option<Vec<String>>,
}
impl Default for ISRCollectionRequirements_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      hash: None,
      type_: None,
      cridNumbers: None,
      priority: 0.0,
      recordId: None,
      reconSurvey: None,
      intelDiscipline: None,
      secondary: false,
      emphasized: false,
      isPrismCr: false,
      start: None,
      stop: None,
      operation: None,
      supportedUnit: None,
      country: None,
      region: None,
      subregion: None,
      specialComGuidance: None,
      criticalTimes: None,
      exploitationRequirement: None,
      targetList: None,
    }
  }
}
impl ISRCollectionRequirements_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ISRCollectionRequirements_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let hash = self.hash.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cridNumbers = self.cridNumbers.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let priority = self.priority;
    let recordId = self.recordId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reconSurvey = self.reconSurvey.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let intelDiscipline = self.intelDiscipline.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let secondary = self.secondary;
    let emphasized = self.emphasized;
    let isPrismCr = self.isPrismCr;
    let start = self.start.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stop = self.stop.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let operation = self.operation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let supportedUnit = self.supportedUnit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let country = self.country.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let region = self.region.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let subregion = self.subregion.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let specialComGuidance = self.specialComGuidance.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let criticalTimes = self.criticalTimes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let exploitationRequirement = self.exploitationRequirement.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let targetList = self.targetList.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    ISRCollectionRequirements_Abridged::create(_fbb, &ISRCollectionRequirements_AbridgedArgs{
      id,
      hash,
      type_,
      cridNumbers,
      priority,
      recordId,
      reconSurvey,
      intelDiscipline,
      secondary,
      emphasized,
      isPrismCr,
      start,
      stop,
      operation,
      supportedUnit,
      country,
      region,
      subregion,
      specialComGuidance,
      criticalTimes,
      exploitationRequirement,
      targetList,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ISRCollectionRequirements_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_isrcollection_requirements_abridged_unchecked`.
pub fn root_as_isrcollection_requirements_abridged(buf: &[u8]) -> Result<ISRCollectionRequirements_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ISRCollectionRequirements_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ISRCollectionRequirements_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_isrcollection_requirements_abridged_unchecked`.
pub fn size_prefixed_root_as_isrcollection_requirements_abridged(buf: &[u8]) -> Result<ISRCollectionRequirements_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ISRCollectionRequirements_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ISRCollectionRequirements_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_isrcollection_requirements_abridged_unchecked`.
pub fn root_as_isrcollection_requirements_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ISRCollectionRequirements_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ISRCollectionRequirements_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ISRCollectionRequirements_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_isrcollection_requirements_abridged_unchecked`.
pub fn size_prefixed_root_as_isrcollection_requirements_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ISRCollectionRequirements_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ISRCollectionRequirements_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ISRCollectionRequirements_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ISRCollectionRequirements_Abridged`.
pub unsafe fn root_as_isrcollection_requirements_abridged_unchecked(buf: &[u8]) -> ISRCollectionRequirements_Abridged {
  flatbuffers::root_unchecked::<ISRCollectionRequirements_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ISRCollectionRequirements_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ISRCollectionRequirements_Abridged`.
pub unsafe fn size_prefixed_root_as_isrcollection_requirements_abridged_unchecked(buf: &[u8]) -> ISRCollectionRequirements_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<ISRCollectionRequirements_Abridged>(buf)
}
pub const ISRCOLLECTION_REQUIREMENTS_ABRIDGED_IDENTIFIER: &str = "ISRC";

#[inline]
pub fn isrcollection_requirements_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ISRCOLLECTION_REQUIREMENTS_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn isrcollection_requirements_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ISRCOLLECTION_REQUIREMENTS_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_isrcollection_requirements_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ISRCollectionRequirements_Abridged<'a>>) {
  fbb.finish(root, Some(ISRCOLLECTION_REQUIREMENTS_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_isrcollection_requirements_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ISRCollectionRequirements_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(ISRCOLLECTION_REQUIREMENTS_ABRIDGED_IDENTIFIER));
}
