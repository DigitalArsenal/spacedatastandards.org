// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum FlightPlanAirRefuelEvents_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Collection of air refueling events occurring on this flight.
pub struct FlightPlanAirRefuelEvents_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FlightPlanAirRefuelEvents_Full<'a> {
  type Inner = FlightPlanAirRefuelEvents_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FlightPlanAirRefuelEvents_Full<'a> {
  pub const VT_ARDEGRADE: flatbuffers::VOffsetT = 4;
  pub const VT_ARNUM: flatbuffers::VOffsetT = 6;
  pub const VT_AREXCHANGEDFUEL: flatbuffers::VOffsetT = 8;
  pub const VT_DIVERTFUEL: flatbuffers::VOffsetT = 10;
  pub const VT_EXITFUEL: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FlightPlanAirRefuelEvents_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FlightPlanAirRefuelEvents_FullArgs
  ) -> flatbuffers::WIPOffset<FlightPlanAirRefuelEvents_Full<'bldr>> {
    let mut builder = FlightPlanAirRefuelEvents_FullBuilder::new(_fbb);
    builder.add_exitFuel(args.exitFuel);
    builder.add_divertFuel(args.divertFuel);
    builder.add_arExchangedFuel(args.arExchangedFuel);
    builder.add_arDegrade(args.arDegrade);
    builder.add_arNum(args.arNum);
    builder.finish()
  }

  pub fn unpack(&self) -> FlightPlanAirRefuelEvents_FullT {
    let arDegrade = self.arDegrade();
    let arNum = self.arNum();
    let arExchangedFuel = self.arExchangedFuel();
    let divertFuel = self.divertFuel();
    let exitFuel = self.exitFuel();
    FlightPlanAirRefuelEvents_FullT {
      arDegrade,
      arNum,
      arExchangedFuel,
      divertFuel,
      exitFuel,
    }
  }

  /// Additional degrade for air refueling, cumulative with fuelDegrade field percent.
  /// Example: /// Example: 3.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn arDegrade(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanAirRefuelEvents_Full::VT_ARDEGRADE, Some(0.0)).unwrap()}
  }
  /// The number of this air refueling event within the flight plan.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn arNum(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(FlightPlanAirRefuelEvents_Full::VT_ARNUM, Some(0)).unwrap()}
  }
  /// Fuel onloaded (use positive numbers) or fuel offloaded (use negative numbers) in pounds.
  /// Example: /// Example: 1500.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn arExchangedFuel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanAirRefuelEvents_Full::VT_AREXCHANGEDFUEL, Some(0.0)).unwrap()}
  }
  /// Fuel required to fly from air refueling exit point to air refueling divert alternate airfield in pounds.
  /// Example: /// Example: 143000.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn divertFuel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanAirRefuelEvents_Full::VT_DIVERTFUEL, Some(0.0)).unwrap()}
  }
  /// Fuel remaining at the air refueling exit in pounds.
  /// Example: /// Example: 160000.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn exitFuel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanAirRefuelEvents_Full::VT_EXITFUEL, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FlightPlanAirRefuelEvents_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("arDegrade", Self::VT_ARDEGRADE, false)?
     .visit_field::<i32>("arNum", Self::VT_ARNUM, false)?
     .visit_field::<f64>("arExchangedFuel", Self::VT_AREXCHANGEDFUEL, false)?
     .visit_field::<f64>("divertFuel", Self::VT_DIVERTFUEL, false)?
     .visit_field::<f64>("exitFuel", Self::VT_EXITFUEL, false)?
     .finish();
    Ok(())
  }
}
pub struct FlightPlanAirRefuelEvents_FullArgs {
    pub arDegrade: f64,
    pub arNum: i32,
    pub arExchangedFuel: f64,
    pub divertFuel: f64,
    pub exitFuel: f64,
}
impl<'a> Default for FlightPlanAirRefuelEvents_FullArgs {
  #[inline]
  fn default() -> Self {
    FlightPlanAirRefuelEvents_FullArgs {
      arDegrade: 0.0,
      arNum: 0,
      arExchangedFuel: 0.0,
      divertFuel: 0.0,
      exitFuel: 0.0,
    }
  }
}

pub struct FlightPlanAirRefuelEvents_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FlightPlanAirRefuelEvents_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_arDegrade(&mut self, arDegrade: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanAirRefuelEvents_Full::VT_ARDEGRADE, arDegrade, 0.0);
  }
  #[inline]
  pub fn add_arNum(&mut self, arNum: i32) {
    self.fbb_.push_slot::<i32>(FlightPlanAirRefuelEvents_Full::VT_ARNUM, arNum, 0);
  }
  #[inline]
  pub fn add_arExchangedFuel(&mut self, arExchangedFuel: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanAirRefuelEvents_Full::VT_AREXCHANGEDFUEL, arExchangedFuel, 0.0);
  }
  #[inline]
  pub fn add_divertFuel(&mut self, divertFuel: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanAirRefuelEvents_Full::VT_DIVERTFUEL, divertFuel, 0.0);
  }
  #[inline]
  pub fn add_exitFuel(&mut self, exitFuel: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanAirRefuelEvents_Full::VT_EXITFUEL, exitFuel, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FlightPlanAirRefuelEvents_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FlightPlanAirRefuelEvents_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FlightPlanAirRefuelEvents_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FlightPlanAirRefuelEvents_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FlightPlanAirRefuelEvents_Full");
      ds.field("arDegrade", &self.arDegrade());
      ds.field("arNum", &self.arNum());
      ds.field("arExchangedFuel", &self.arExchangedFuel());
      ds.field("divertFuel", &self.divertFuel());
      ds.field("exitFuel", &self.exitFuel());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FlightPlanAirRefuelEvents_FullT {
  pub arDegrade: f64,
  pub arNum: i32,
  pub arExchangedFuel: f64,
  pub divertFuel: f64,
  pub exitFuel: f64,
}
impl Default for FlightPlanAirRefuelEvents_FullT {
  fn default() -> Self {
    Self {
      arDegrade: 0.0,
      arNum: 0,
      arExchangedFuel: 0.0,
      divertFuel: 0.0,
      exitFuel: 0.0,
    }
  }
}
impl FlightPlanAirRefuelEvents_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<FlightPlanAirRefuelEvents_Full<'b>> {
    let arDegrade = self.arDegrade;
    let arNum = self.arNum;
    let arExchangedFuel = self.arExchangedFuel;
    let divertFuel = self.divertFuel;
    let exitFuel = self.exitFuel;
    FlightPlanAirRefuelEvents_Full::create(_fbb, &FlightPlanAirRefuelEvents_FullArgs{
      arDegrade,
      arNum,
      arExchangedFuel,
      divertFuel,
      exitFuel,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `FlightPlanAirRefuelEvents_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_air_refuel_events_full_unchecked`.
pub fn root_as_flight_plan_air_refuel_events_full(buf: &[u8]) -> Result<FlightPlanAirRefuelEvents_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<FlightPlanAirRefuelEvents_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FlightPlanAirRefuelEvents_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_flight_plan_air_refuel_events_full_unchecked`.
pub fn size_prefixed_root_as_flight_plan_air_refuel_events_full(buf: &[u8]) -> Result<FlightPlanAirRefuelEvents_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<FlightPlanAirRefuelEvents_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FlightPlanAirRefuelEvents_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_air_refuel_events_full_unchecked`.
pub fn root_as_flight_plan_air_refuel_events_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlightPlanAirRefuelEvents_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<FlightPlanAirRefuelEvents_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FlightPlanAirRefuelEvents_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_air_refuel_events_full_unchecked`.
pub fn size_prefixed_root_as_flight_plan_air_refuel_events_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlightPlanAirRefuelEvents_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<FlightPlanAirRefuelEvents_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FlightPlanAirRefuelEvents_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FlightPlanAirRefuelEvents_Full`.
pub unsafe fn root_as_flight_plan_air_refuel_events_full_unchecked(buf: &[u8]) -> FlightPlanAirRefuelEvents_Full {
  flatbuffers::root_unchecked::<FlightPlanAirRefuelEvents_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FlightPlanAirRefuelEvents_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FlightPlanAirRefuelEvents_Full`.
pub unsafe fn size_prefixed_root_as_flight_plan_air_refuel_events_full_unchecked(buf: &[u8]) -> FlightPlanAirRefuelEvents_Full {
  flatbuffers::size_prefixed_root_unchecked::<FlightPlanAirRefuelEvents_Full>(buf)
}
pub const FLIGHT_PLAN_AIR_REFUEL_EVENTS_FULL_IDENTIFIER: &str = "FLIG";

#[inline]
pub fn flight_plan_air_refuel_events_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, FLIGHT_PLAN_AIR_REFUEL_EVENTS_FULL_IDENTIFIER, false)
}

#[inline]
pub fn flight_plan_air_refuel_events_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, FLIGHT_PLAN_AIR_REFUEL_EVENTS_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_flight_plan_air_refuel_events_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<FlightPlanAirRefuelEvents_Full<'a>>) {
  fbb.finish(root, Some(FLIGHT_PLAN_AIR_REFUEL_EVENTS_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_flight_plan_air_refuel_events_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<FlightPlanAirRefuelEvents_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(FLIGHT_PLAN_AIR_REFUEL_EVENTS_FULL_IDENTIFIER));
}
