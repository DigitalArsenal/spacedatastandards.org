// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum CrewMembers_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Schema for Crew Member data.
pub struct CrewMembers_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CrewMembers_Full<'a> {
  type Inner = CrewMembers_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CrewMembers_Full<'a> {
  pub const VT_LASTNAME: flatbuffers::VOffsetT = 4;
  pub const VT_FIRSTNAME: flatbuffers::VOffsetT = 6;
  pub const VT_MIDDLEINITIAL: flatbuffers::VOffsetT = 8;
  pub const VT_MEMBERID: flatbuffers::VOffsetT = 10;
  pub const VT_CIVILIAN: flatbuffers::VOffsetT = 12;
  pub const VT_COMMANDER: flatbuffers::VOffsetT = 14;
  pub const VT_LAST4SSN: flatbuffers::VOffsetT = 16;
  pub const VT_DODID: flatbuffers::VOffsetT = 18;
  pub const VT_DUTYPOSITION: flatbuffers::VOffsetT = 20;
  pub const VT_CREWPOSITION: flatbuffers::VOffsetT = 22;
  pub const VT_MEMBERTYPE: flatbuffers::VOffsetT = 24;
  pub const VT_BRANCH: flatbuffers::VOffsetT = 26;
  pub const VT_RANK: flatbuffers::VOffsetT = 28;
  pub const VT_WING: flatbuffers::VOffsetT = 30;
  pub const VT_SQUADRON: flatbuffers::VOffsetT = 32;
  pub const VT_MEMBERREMARKS: flatbuffers::VOffsetT = 34;
  pub const VT_USERNAME: flatbuffers::VOffsetT = 36;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CrewMembers_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CrewMembers_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<CrewMembers_Full<'bldr>> {
    let mut builder = CrewMembers_FullBuilder::new(_fbb);
    if let Some(x) = args.username { builder.add_username(x); }
    if let Some(x) = args.memberRemarks { builder.add_memberRemarks(x); }
    if let Some(x) = args.squadron { builder.add_squadron(x); }
    if let Some(x) = args.wing { builder.add_wing(x); }
    if let Some(x) = args.rank { builder.add_rank(x); }
    if let Some(x) = args.branch { builder.add_branch(x); }
    if let Some(x) = args.memberType { builder.add_memberType(x); }
    if let Some(x) = args.crewPosition { builder.add_crewPosition(x); }
    if let Some(x) = args.dutyPosition { builder.add_dutyPosition(x); }
    if let Some(x) = args.dodID { builder.add_dodID(x); }
    if let Some(x) = args.last4SSN { builder.add_last4SSN(x); }
    if let Some(x) = args.memberId { builder.add_memberId(x); }
    if let Some(x) = args.middleInitial { builder.add_middleInitial(x); }
    if let Some(x) = args.firstName { builder.add_firstName(x); }
    if let Some(x) = args.lastName { builder.add_lastName(x); }
    builder.add_commander(args.commander);
    builder.add_civilian(args.civilian);
    builder.finish()
  }

  pub fn unpack(&self) -> CrewMembers_FullT {
    let lastName = self.lastName().map(|x| {
      x.to_string()
    });
    let firstName = self.firstName().map(|x| {
      x.to_string()
    });
    let middleInitial = self.middleInitial().map(|x| {
      x.to_string()
    });
    let memberId = self.memberId().map(|x| {
      x.to_string()
    });
    let civilian = self.civilian();
    let commander = self.commander();
    let last4SSN = self.last4SSN().map(|x| {
      x.to_string()
    });
    let dodID = self.dodID().map(|x| {
      x.to_string()
    });
    let dutyPosition = self.dutyPosition().map(|x| {
      x.to_string()
    });
    let crewPosition = self.crewPosition().map(|x| {
      x.to_string()
    });
    let memberType = self.memberType().map(|x| {
      x.to_string()
    });
    let branch = self.branch().map(|x| {
      x.to_string()
    });
    let rank = self.rank().map(|x| {
      x.to_string()
    });
    let wing = self.wing().map(|x| {
      x.to_string()
    });
    let squadron = self.squadron().map(|x| {
      x.to_string()
    });
    let memberRemarks = self.memberRemarks().map(|x| {
      x.to_string()
    });
    let username = self.username().map(|x| {
      x.to_string()
    });
    CrewMembers_FullT {
      lastName,
      firstName,
      middleInitial,
      memberId,
      civilian,
      commander,
      last4SSN,
      dodID,
      dutyPosition,
      crewPosition,
      memberType,
      branch,
      rank,
      wing,
      squadron,
      memberRemarks,
      username,
    }
  }

  /// The last name of the crew member.
  /// Example: /// Example: Smith
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn lastName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_LASTNAME, None)}
  }
  /// The first name of the crew member.
  /// Example: /// Example: Freddie
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn firstName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_FIRSTNAME, None)}
  }
  /// The middle initial of the crew member.
  /// Example: /// Example: G
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn middleInitial(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_MIDDLEINITIAL, None)}
  }
  /// Unique identifier of the crew member assigned by the originating source.
  /// Example: /// Example: 12345678abc
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn memberId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_MEMBERID, None)}
  }
  /// Flag indicating this crew member is a civilian or non-military person.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn civilian(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CrewMembers_Full::VT_CIVILIAN, Some(false)).unwrap()}
  }
  /// Flag indicating this person is the aircraft commander.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn commander(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CrewMembers_Full::VT_COMMANDER, Some(false)).unwrap()}
  }
  /// Last four digits of the crew member's social security number.
  /// Example: /// Example: 1234
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn last4SSN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_LAST4SSN, None)}
  }
  /// The crew member's 10-digit DoD ID number.
  /// Example: /// Example: 0123456789
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn dodID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_DODID, None)}
  }
  /// The duty position of the crew member.
  /// Example: /// Example: IP
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn dutyPosition(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_DUTYPOSITION, None)}
  }
  /// The crew position of the crew member.
  /// Example: /// Example: EP A
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn crewPosition(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_CREWPOSITION, None)}
  }
  /// Amplifying details about the crew member type (e.g. RAVEN, FCC, COMCAM, AIRCREW, MEP, OTHER, etc.).
  /// Example: /// Example: AIRCREW
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn memberType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_MEMBERTYPE, None)}
  }
  /// The military branch assignment of the crew member.
  /// Example: /// Example: Air Force
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn branch(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_BRANCH, None)}
  }
  /// The rank of the crew member.
  /// Example: /// Example: Capt
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn rank(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_RANK, None)}
  }
  /// The wing the crew member serves.
  /// Example: /// Example: 60AMW
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn wing(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_WING, None)}
  }
  /// The squadron the crew member serves.
  /// Example: /// Example: 21AS
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn squadron(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_SQUADRON, None)}
  }
  /// Remarks concerning the crew member.
  /// Example: /// Example: Crew member remark
  /// Constraints: Minimum length = 0, Maximum length = 512
  #[inline]
  pub fn memberRemarks(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_MEMBERREMARKS, None)}
  }
  /// The Mattermost username of this crew member.
  /// Example: /// Example: fgsmith
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn username(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrewMembers_Full::VT_USERNAME, None)}
  }
}

impl flatbuffers::Verifiable for CrewMembers_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastName", Self::VT_LASTNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("firstName", Self::VT_FIRSTNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("middleInitial", Self::VT_MIDDLEINITIAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memberId", Self::VT_MEMBERID, false)?
     .visit_field::<bool>("civilian", Self::VT_CIVILIAN, false)?
     .visit_field::<bool>("commander", Self::VT_COMMANDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("last4SSN", Self::VT_LAST4SSN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dodID", Self::VT_DODID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dutyPosition", Self::VT_DUTYPOSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("crewPosition", Self::VT_CREWPOSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memberType", Self::VT_MEMBERTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("branch", Self::VT_BRANCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rank", Self::VT_RANK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("wing", Self::VT_WING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("squadron", Self::VT_SQUADRON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memberRemarks", Self::VT_MEMBERREMARKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("username", Self::VT_USERNAME, false)?
     .finish();
    Ok(())
  }
}
pub struct CrewMembers_FullArgs<'a> {
    pub lastName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub firstName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub middleInitial: Option<flatbuffers::WIPOffset<&'a str>>,
    pub memberId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub civilian: bool,
    pub commander: bool,
    pub last4SSN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dodID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dutyPosition: Option<flatbuffers::WIPOffset<&'a str>>,
    pub crewPosition: Option<flatbuffers::WIPOffset<&'a str>>,
    pub memberType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub branch: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rank: Option<flatbuffers::WIPOffset<&'a str>>,
    pub wing: Option<flatbuffers::WIPOffset<&'a str>>,
    pub squadron: Option<flatbuffers::WIPOffset<&'a str>>,
    pub memberRemarks: Option<flatbuffers::WIPOffset<&'a str>>,
    pub username: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CrewMembers_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    CrewMembers_FullArgs {
      lastName: None,
      firstName: None,
      middleInitial: None,
      memberId: None,
      civilian: false,
      commander: false,
      last4SSN: None,
      dodID: None,
      dutyPosition: None,
      crewPosition: None,
      memberType: None,
      branch: None,
      rank: None,
      wing: None,
      squadron: None,
      memberRemarks: None,
      username: None,
    }
  }
}

pub struct CrewMembers_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CrewMembers_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_lastName(&mut self, lastName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_LASTNAME, lastName);
  }
  #[inline]
  pub fn add_firstName(&mut self, firstName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_FIRSTNAME, firstName);
  }
  #[inline]
  pub fn add_middleInitial(&mut self, middleInitial: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_MIDDLEINITIAL, middleInitial);
  }
  #[inline]
  pub fn add_memberId(&mut self, memberId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_MEMBERID, memberId);
  }
  #[inline]
  pub fn add_civilian(&mut self, civilian: bool) {
    self.fbb_.push_slot::<bool>(CrewMembers_Full::VT_CIVILIAN, civilian, false);
  }
  #[inline]
  pub fn add_commander(&mut self, commander: bool) {
    self.fbb_.push_slot::<bool>(CrewMembers_Full::VT_COMMANDER, commander, false);
  }
  #[inline]
  pub fn add_last4SSN(&mut self, last4SSN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_LAST4SSN, last4SSN);
  }
  #[inline]
  pub fn add_dodID(&mut self, dodID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_DODID, dodID);
  }
  #[inline]
  pub fn add_dutyPosition(&mut self, dutyPosition: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_DUTYPOSITION, dutyPosition);
  }
  #[inline]
  pub fn add_crewPosition(&mut self, crewPosition: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_CREWPOSITION, crewPosition);
  }
  #[inline]
  pub fn add_memberType(&mut self, memberType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_MEMBERTYPE, memberType);
  }
  #[inline]
  pub fn add_branch(&mut self, branch: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_BRANCH, branch);
  }
  #[inline]
  pub fn add_rank(&mut self, rank: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_RANK, rank);
  }
  #[inline]
  pub fn add_wing(&mut self, wing: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_WING, wing);
  }
  #[inline]
  pub fn add_squadron(&mut self, squadron: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_SQUADRON, squadron);
  }
  #[inline]
  pub fn add_memberRemarks(&mut self, memberRemarks: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_MEMBERREMARKS, memberRemarks);
  }
  #[inline]
  pub fn add_username(&mut self, username: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrewMembers_Full::VT_USERNAME, username);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CrewMembers_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CrewMembers_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CrewMembers_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CrewMembers_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CrewMembers_Full");
      ds.field("lastName", &self.lastName());
      ds.field("firstName", &self.firstName());
      ds.field("middleInitial", &self.middleInitial());
      ds.field("memberId", &self.memberId());
      ds.field("civilian", &self.civilian());
      ds.field("commander", &self.commander());
      ds.field("last4SSN", &self.last4SSN());
      ds.field("dodID", &self.dodID());
      ds.field("dutyPosition", &self.dutyPosition());
      ds.field("crewPosition", &self.crewPosition());
      ds.field("memberType", &self.memberType());
      ds.field("branch", &self.branch());
      ds.field("rank", &self.rank());
      ds.field("wing", &self.wing());
      ds.field("squadron", &self.squadron());
      ds.field("memberRemarks", &self.memberRemarks());
      ds.field("username", &self.username());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CrewMembers_FullT {
  pub lastName: Option<String>,
  pub firstName: Option<String>,
  pub middleInitial: Option<String>,
  pub memberId: Option<String>,
  pub civilian: bool,
  pub commander: bool,
  pub last4SSN: Option<String>,
  pub dodID: Option<String>,
  pub dutyPosition: Option<String>,
  pub crewPosition: Option<String>,
  pub memberType: Option<String>,
  pub branch: Option<String>,
  pub rank: Option<String>,
  pub wing: Option<String>,
  pub squadron: Option<String>,
  pub memberRemarks: Option<String>,
  pub username: Option<String>,
}
impl Default for CrewMembers_FullT {
  fn default() -> Self {
    Self {
      lastName: None,
      firstName: None,
      middleInitial: None,
      memberId: None,
      civilian: false,
      commander: false,
      last4SSN: None,
      dodID: None,
      dutyPosition: None,
      crewPosition: None,
      memberType: None,
      branch: None,
      rank: None,
      wing: None,
      squadron: None,
      memberRemarks: None,
      username: None,
    }
  }
}
impl CrewMembers_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CrewMembers_Full<'b>> {
    let lastName = self.lastName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let firstName = self.firstName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let middleInitial = self.middleInitial.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let memberId = self.memberId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let civilian = self.civilian;
    let commander = self.commander;
    let last4SSN = self.last4SSN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dodID = self.dodID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dutyPosition = self.dutyPosition.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let crewPosition = self.crewPosition.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let memberType = self.memberType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let branch = self.branch.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rank = self.rank.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let wing = self.wing.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let squadron = self.squadron.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let memberRemarks = self.memberRemarks.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let username = self.username.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    CrewMembers_Full::create(_fbb, &CrewMembers_FullArgs{
      lastName,
      firstName,
      middleInitial,
      memberId,
      civilian,
      commander,
      last4SSN,
      dodID,
      dutyPosition,
      crewPosition,
      memberType,
      branch,
      rank,
      wing,
      squadron,
      memberRemarks,
      username,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CrewMembers_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_crew_members_full_unchecked`.
pub fn root_as_crew_members_full(buf: &[u8]) -> Result<CrewMembers_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<CrewMembers_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CrewMembers_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_crew_members_full_unchecked`.
pub fn size_prefixed_root_as_crew_members_full(buf: &[u8]) -> Result<CrewMembers_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<CrewMembers_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CrewMembers_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_crew_members_full_unchecked`.
pub fn root_as_crew_members_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CrewMembers_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<CrewMembers_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CrewMembers_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_crew_members_full_unchecked`.
pub fn size_prefixed_root_as_crew_members_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CrewMembers_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<CrewMembers_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CrewMembers_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CrewMembers_Full`.
pub unsafe fn root_as_crew_members_full_unchecked(buf: &[u8]) -> CrewMembers_Full {
  flatbuffers::root_unchecked::<CrewMembers_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CrewMembers_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CrewMembers_Full`.
pub unsafe fn size_prefixed_root_as_crew_members_full_unchecked(buf: &[u8]) -> CrewMembers_Full {
  flatbuffers::size_prefixed_root_unchecked::<CrewMembers_Full>(buf)
}
pub const CREW_MEMBERS_FULL_IDENTIFIER: &str = "CREW";

#[inline]
pub fn crew_members_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CREW_MEMBERS_FULL_IDENTIFIER, false)
}

#[inline]
pub fn crew_members_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CREW_MEMBERS_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_crew_members_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CrewMembers_Full<'a>>) {
  fbb.finish(root, Some(CREW_MEMBERS_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_crew_members_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<CrewMembers_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(CREW_MEMBERS_FULL_IDENTIFIER));
}
