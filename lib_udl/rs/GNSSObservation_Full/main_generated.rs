// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum GNSSObservation_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Information for Global Navigation Satellite Systems (GNSS) Observations collected from GNSS receivers, including the specific GNSS sat from which each signal was received, and the observation codes of each observation in the record. Each GNSS Observation is associated with a GNSS Observation Set record containing data which applies to all observations in the set, including observation time, receiver location, and Dilution of Precision (DOP) values. Users can Reference RINEX 3+ documentation for further information concerning many of the standards and conventions for GNSS observations.
pub struct GNSSObservation_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GNSSObservation_Full<'a> {
  type Inner = GNSSObservation_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GNSSObservation_Full<'a> {
  pub const VT_GNSSSATID: flatbuffers::VOffsetT = 4;
  pub const VT_TRACKINGSTATUS: flatbuffers::VOffsetT = 6;
  pub const VT_AGCSTATE: flatbuffers::VOffsetT = 8;
  pub const VT_OBSCODESET: flatbuffers::VOffsetT = 10;
  pub const VT_OB: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GNSSObservation_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GNSSObservation_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<GNSSObservation_Full<'bldr>> {
    let mut builder = GNSSObservation_FullBuilder::new(_fbb);
    if let Some(x) = args.ob { builder.add_ob(x); }
    if let Some(x) = args.obsCodeSet { builder.add_obsCodeSet(x); }
    builder.add_agcState(args.agcState);
    builder.add_trackingStatus(args.trackingStatus);
    if let Some(x) = args.gnssSatId { builder.add_gnssSatId(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GNSSObservation_FullT {
    let gnssSatId = self.gnssSatId().map(|x| {
      x.to_string()
    });
    let trackingStatus = self.trackingStatus();
    let agcState = self.agcState();
    let obsCodeSet = self.obsCodeSet().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ob = self.ob().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    GNSSObservation_FullT {
      gnssSatId,
      trackingStatus,
      agcState,
      obsCodeSet,
      ob,
    }
  }

  /// RINEX 3+ compliant GNSS System and Satellite Identifier (represented as SNN, where S is the system code, and NN is the satellite identifier) associated with this observation:
  /// G - GPS (NN = PRN)
  /// R - GLONASS (NN = Slot Number)
  /// S - SBAS Payload (NN = PRN-100)
  /// E - Galileo (NN = PRN)
  /// C - BeiDou (NN = PRN)
  /// J - QZSS (NN = PRN - 1923)
  /// I - IRNSS (NN = PRN)
  /// Example: /// Example: GEJ
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn gnssSatId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GNSSObservation_Full::VT_GNSSSATID, None)}
  }
  /// Status of the GNSS receiver signal. Status options are 0, 1 or 2 (0 being the best).
  /// Example: /// Example: 0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trackingStatus(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GNSSObservation_Full::VT_TRACKINGSTATUS, Some(0)).unwrap()}
  }
  /// GNSS Automatic Gain Control State.
  /// Example: /// Example: 20
  /// Constraints: No constraints specified.
  #[inline]
  pub fn agcState(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GNSSObservation_Full::VT_AGCSTATE, Some(0)).unwrap()}
  }
  /// The observation code set that applies to this observation record.  Reference RINEX 3+ for further information concerning observation code set conventions.
  /// Example: /// Example: ['S1C', 'C1C', 'C1D']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obsCodeSet(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservation_Full::VT_OBSCODESET, None)}
  }
  /// Array of observation(s).  The ob array must be the same length as the obsCodeSet.  Pseudorange (C) is expressed meters, carrier phase (L) in cycles,  doppler (D) in Hz where + values indicate approaching sats, and signal strength C/No (S) in dB-Hz.
  /// Example: /// Example: [42.1, 1000.0, 0.9]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ob(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GNSSObservation_Full::VT_OB, None)}
  }
}

impl flatbuffers::Verifiable for GNSSObservation_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("gnssSatId", Self::VT_GNSSSATID, false)?
     .visit_field::<i32>("trackingStatus", Self::VT_TRACKINGSTATUS, false)?
     .visit_field::<i32>("agcState", Self::VT_AGCSTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("obsCodeSet", Self::VT_OBSCODESET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ob", Self::VT_OB, false)?
     .finish();
    Ok(())
  }
}
pub struct GNSSObservation_FullArgs<'a> {
    pub gnssSatId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trackingStatus: i32,
    pub agcState: i32,
    pub obsCodeSet: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ob: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for GNSSObservation_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    GNSSObservation_FullArgs {
      gnssSatId: None,
      trackingStatus: 0,
      agcState: 0,
      obsCodeSet: None,
      ob: None,
    }
  }
}

pub struct GNSSObservation_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GNSSObservation_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_gnssSatId(&mut self, gnssSatId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservation_Full::VT_GNSSSATID, gnssSatId);
  }
  #[inline]
  pub fn add_trackingStatus(&mut self, trackingStatus: i32) {
    self.fbb_.push_slot::<i32>(GNSSObservation_Full::VT_TRACKINGSTATUS, trackingStatus, 0);
  }
  #[inline]
  pub fn add_agcState(&mut self, agcState: i32) {
    self.fbb_.push_slot::<i32>(GNSSObservation_Full::VT_AGCSTATE, agcState, 0);
  }
  #[inline]
  pub fn add_obsCodeSet(&mut self, obsCodeSet: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservation_Full::VT_OBSCODESET, obsCodeSet);
  }
  #[inline]
  pub fn add_ob(&mut self, ob: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GNSSObservation_Full::VT_OB, ob);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GNSSObservation_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GNSSObservation_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GNSSObservation_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GNSSObservation_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GNSSObservation_Full");
      ds.field("gnssSatId", &self.gnssSatId());
      ds.field("trackingStatus", &self.trackingStatus());
      ds.field("agcState", &self.agcState());
      ds.field("obsCodeSet", &self.obsCodeSet());
      ds.field("ob", &self.ob());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GNSSObservation_FullT {
  pub gnssSatId: Option<String>,
  pub trackingStatus: i32,
  pub agcState: i32,
  pub obsCodeSet: Option<Vec<String>>,
  pub ob: Option<Vec<String>>,
}
impl Default for GNSSObservation_FullT {
  fn default() -> Self {
    Self {
      gnssSatId: None,
      trackingStatus: 0,
      agcState: 0,
      obsCodeSet: None,
      ob: None,
    }
  }
}
impl GNSSObservation_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GNSSObservation_Full<'b>> {
    let gnssSatId = self.gnssSatId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trackingStatus = self.trackingStatus;
    let agcState = self.agcState;
    let obsCodeSet = self.obsCodeSet.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ob = self.ob.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    GNSSObservation_Full::create(_fbb, &GNSSObservation_FullArgs{
      gnssSatId,
      trackingStatus,
      agcState,
      obsCodeSet,
      ob,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `GNSSObservation_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gnssobservation_full_unchecked`.
pub fn root_as_gnssobservation_full(buf: &[u8]) -> Result<GNSSObservation_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<GNSSObservation_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `GNSSObservation_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_gnssobservation_full_unchecked`.
pub fn size_prefixed_root_as_gnssobservation_full(buf: &[u8]) -> Result<GNSSObservation_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<GNSSObservation_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `GNSSObservation_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gnssobservation_full_unchecked`.
pub fn root_as_gnssobservation_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GNSSObservation_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<GNSSObservation_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `GNSSObservation_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gnssobservation_full_unchecked`.
pub fn size_prefixed_root_as_gnssobservation_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GNSSObservation_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<GNSSObservation_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a GNSSObservation_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `GNSSObservation_Full`.
pub unsafe fn root_as_gnssobservation_full_unchecked(buf: &[u8]) -> GNSSObservation_Full {
  flatbuffers::root_unchecked::<GNSSObservation_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed GNSSObservation_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `GNSSObservation_Full`.
pub unsafe fn size_prefixed_root_as_gnssobservation_full_unchecked(buf: &[u8]) -> GNSSObservation_Full {
  flatbuffers::size_prefixed_root_unchecked::<GNSSObservation_Full>(buf)
}
pub const GNSSOBSERVATION_FULL_IDENTIFIER: &str = "GNSS";

#[inline]
pub fn gnssobservation_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GNSSOBSERVATION_FULL_IDENTIFIER, false)
}

#[inline]
pub fn gnssobservation_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GNSSOBSERVATION_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_gnssobservation_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<GNSSObservation_Full<'a>>) {
  fbb.finish(root, Some(GNSSOBSERVATION_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_gnssobservation_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<GNSSObservation_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(GNSSOBSERVATION_FULL_IDENTIFIER));
}
