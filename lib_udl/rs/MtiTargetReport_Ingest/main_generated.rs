// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum MtiTargetReport_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// A grouping of zero or more target reports for which the sensor provides a single time, sensor position, reference position on the ground with simple estimates for the observed area at the reported time, and other pertinent data.
pub struct MtiTargetReport_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MtiTargetReport_Ingest<'a> {
  type Inner = MtiTargetReport_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MtiTargetReport_Ingest<'a> {
  pub const VT_D32_1: flatbuffers::VOffsetT = 4;
  pub const VT_D32_2: flatbuffers::VOffsetT = 6;
  pub const VT_D32_3: flatbuffers::VOffsetT = 8;
  pub const VT_D32_4: flatbuffers::VOffsetT = 10;
  pub const VT_D32_5: flatbuffers::VOffsetT = 12;
  pub const VT_D32_6: flatbuffers::VOffsetT = 14;
  pub const VT_D32_7: flatbuffers::VOffsetT = 16;
  pub const VT_D32_8: flatbuffers::VOffsetT = 18;
  pub const VT_D32_9: flatbuffers::VOffsetT = 20;
  pub const VT_D32_10: flatbuffers::VOffsetT = 22;
  pub const VT_D32_11: flatbuffers::VOffsetT = 24;
  pub const VT_D32_12: flatbuffers::VOffsetT = 26;
  pub const VT_D32_13: flatbuffers::VOffsetT = 28;
  pub const VT_D32_14: flatbuffers::VOffsetT = 30;
  pub const VT_D32_15: flatbuffers::VOffsetT = 32;
  pub const VT_D32_16: flatbuffers::VOffsetT = 34;
  pub const VT_D32_17: flatbuffers::VOffsetT = 36;
  pub const VT_D32_18: flatbuffers::VOffsetT = 38;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MtiTargetReport_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MtiTargetReport_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<MtiTargetReport_Ingest<'bldr>> {
    let mut builder = MtiTargetReport_IngestBuilder::new(_fbb);
    builder.add_d32_17(args.d32_17);
    builder.add_d32_3(args.d32_3);
    builder.add_d32_2(args.d32_2);
    builder.add_d32_18(args.d32_18);
    builder.add_d32_16(args.d32_16);
    builder.add_d32_15(args.d32_15);
    builder.add_d32_14(args.d32_14);
    builder.add_d32_13(args.d32_13);
    builder.add_d32_12(args.d32_12);
    builder.add_d32_11(args.d32_11);
    if let Some(x) = args.d32_10 { builder.add_d32_10(x); }
    builder.add_d32_9(args.d32_9);
    builder.add_d32_8(args.d32_8);
    builder.add_d32_7(args.d32_7);
    builder.add_d32_6(args.d32_6);
    builder.add_d32_5(args.d32_5);
    builder.add_d32_4(args.d32_4);
    builder.add_d32_1(args.d32_1);
    builder.finish()
  }

  pub fn unpack(&self) -> MtiTargetReport_IngestT {
    let d32_1 = self.d32_1();
    let d32_2 = self.d32_2();
    let d32_3 = self.d32_3();
    let d32_4 = self.d32_4();
    let d32_5 = self.d32_5();
    let d32_6 = self.d32_6();
    let d32_7 = self.d32_7();
    let d32_8 = self.d32_8();
    let d32_9 = self.d32_9();
    let d32_10 = self.d32_10().map(|x| {
      x.to_string()
    });
    let d32_11 = self.d32_11();
    let d32_12 = self.d32_12();
    let d32_13 = self.d32_13();
    let d32_14 = self.d32_14();
    let d32_15 = self.d32_15();
    let d32_16 = self.d32_16();
    let d32_17 = self.d32_17();
    let d32_18 = self.d32_18();
    MtiTargetReport_IngestT {
      d32_1,
      d32_2,
      d32_3,
      d32_4,
      d32_5,
      d32_6,
      d32_7,
      d32_8,
      d32_9,
      d32_10,
      d32_11,
      d32_12,
      d32_13,
      d32_14,
      d32_15,
      d32_16,
      d32_17,
      d32_18,
    }
  }

  /// Sequential count of this MTI report within the dwell.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_1(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_1, Some(0)).unwrap()}
  }
  /// The North-South position of the reported detection, expressed as degrees North (positive) or South (negative) of the Equator.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MtiTargetReport_Ingest::VT_D32_2, Some(0.0)).unwrap()}
  }
  /// The East-West position of the reported detection, expressed as degrees East (positive) from the Prime Meridian.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MtiTargetReport_Ingest::VT_D32_3, Some(0.0)).unwrap()}
  }
  /// The North-South position of the reported detection, expressed as degrees North (positive) or South (negative) from the Dwell Area Center Latitude.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_4(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_4, Some(0)).unwrap()}
  }
  /// The East-West position of the reported detection, expressed as degrees East (positive, 0 to 180) or West (negative, 0 to -180) of the Prime Meridian from the Dwell Area Center Longitude.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_5(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_5, Some(0)).unwrap()}
  }
  /// Height of the reported detection, referenced to its position above the WGS 84 ellipsoid, in meters.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_6(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_6, Some(0)).unwrap()}
  }
  /// The component of velocity for the reported detection, expressed in centimeters per second, corrected for platform motion, along the line of sight between the sensor and the reported detection, where the positive direction is away from the sensor.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_7(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_7, Some(0)).unwrap()}
  }
  /// The target wrap velocity permits trackers to un-wrap velocities for targets with line-of-sight components large enough to exceed the first velocity period.  Expressed in centimeters/sec.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_8(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_8, Some(0)).unwrap()}
  }
  /// Estimated signal-to-noise ratio (SNR) of the target return, in decibels.
  /// Example: /// Example: 17
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_9(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_9, Some(0)).unwrap()}
  }
  /// The classification of the target (i.e. vehicle, aircraft, â€¦).
  /// Example: /// Example: vehicle
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn d32_10(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MtiTargetReport_Ingest::VT_D32_10, None)}
  }
  /// Estimated probability that the target classification field is correctly classified.
  /// Example: /// Example: 90
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_11(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_11, Some(0)).unwrap()}
  }
  /// Standard deviation of the estimated slant range of the reported detection, in centimeters.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_12(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_12, Some(0)).unwrap()}
  }
  /// Standard deviation of the position estimate, in the cross-range direction, of the reported detection, in decimeters.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_13(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_13, Some(0)).unwrap()}
  }
  /// Standard deviation of the estimated geodetic height, in meters.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_14(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_14, Some(0)).unwrap()}
  }
  /// Standard deviation of the measured line-of-sight velocity component, in centimeters per second.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_15(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_15, Some(0)).unwrap()}
  }
  /// The Truth Tag- Application is the Application Field truncated to 8 bits, from the Entity State Protocol Data Unit (PDU) used to generate the MTI Target.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_16(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_16, Some(0)).unwrap()}
  }
  /// The Truth Tag - Entity is the Entity Field from the Entity State PDU used to generate the MTI Target.
  /// Example: /// Example: 1234567890
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_17(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MtiTargetReport_Ingest::VT_D32_17, Some(0)).unwrap()}
  }
  /// Estimated radar cross section of the target return, in half-decibels.
  /// Example: /// Example: 98
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d32_18(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiTargetReport_Ingest::VT_D32_18, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MtiTargetReport_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("d32_1", Self::VT_D32_1, false)?
     .visit_field::<f64>("d32_2", Self::VT_D32_2, false)?
     .visit_field::<f64>("d32_3", Self::VT_D32_3, false)?
     .visit_field::<i32>("d32_4", Self::VT_D32_4, false)?
     .visit_field::<i32>("d32_5", Self::VT_D32_5, false)?
     .visit_field::<i32>("d32_6", Self::VT_D32_6, false)?
     .visit_field::<i32>("d32_7", Self::VT_D32_7, false)?
     .visit_field::<i32>("d32_8", Self::VT_D32_8, false)?
     .visit_field::<i32>("d32_9", Self::VT_D32_9, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("d32_10", Self::VT_D32_10, false)?
     .visit_field::<i32>("d32_11", Self::VT_D32_11, false)?
     .visit_field::<i32>("d32_12", Self::VT_D32_12, false)?
     .visit_field::<i32>("d32_13", Self::VT_D32_13, false)?
     .visit_field::<i32>("d32_14", Self::VT_D32_14, false)?
     .visit_field::<i32>("d32_15", Self::VT_D32_15, false)?
     .visit_field::<i32>("d32_16", Self::VT_D32_16, false)?
     .visit_field::<i64>("d32_17", Self::VT_D32_17, false)?
     .visit_field::<i32>("d32_18", Self::VT_D32_18, false)?
     .finish();
    Ok(())
  }
}
pub struct MtiTargetReport_IngestArgs<'a> {
    pub d32_1: i32,
    pub d32_2: f64,
    pub d32_3: f64,
    pub d32_4: i32,
    pub d32_5: i32,
    pub d32_6: i32,
    pub d32_7: i32,
    pub d32_8: i32,
    pub d32_9: i32,
    pub d32_10: Option<flatbuffers::WIPOffset<&'a str>>,
    pub d32_11: i32,
    pub d32_12: i32,
    pub d32_13: i32,
    pub d32_14: i32,
    pub d32_15: i32,
    pub d32_16: i32,
    pub d32_17: i64,
    pub d32_18: i32,
}
impl<'a> Default for MtiTargetReport_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    MtiTargetReport_IngestArgs {
      d32_1: 0,
      d32_2: 0.0,
      d32_3: 0.0,
      d32_4: 0,
      d32_5: 0,
      d32_6: 0,
      d32_7: 0,
      d32_8: 0,
      d32_9: 0,
      d32_10: None,
      d32_11: 0,
      d32_12: 0,
      d32_13: 0,
      d32_14: 0,
      d32_15: 0,
      d32_16: 0,
      d32_17: 0,
      d32_18: 0,
    }
  }
}

pub struct MtiTargetReport_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MtiTargetReport_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_d32_1(&mut self, d32_1: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_1, d32_1, 0);
  }
  #[inline]
  pub fn add_d32_2(&mut self, d32_2: f64) {
    self.fbb_.push_slot::<f64>(MtiTargetReport_Ingest::VT_D32_2, d32_2, 0.0);
  }
  #[inline]
  pub fn add_d32_3(&mut self, d32_3: f64) {
    self.fbb_.push_slot::<f64>(MtiTargetReport_Ingest::VT_D32_3, d32_3, 0.0);
  }
  #[inline]
  pub fn add_d32_4(&mut self, d32_4: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_4, d32_4, 0);
  }
  #[inline]
  pub fn add_d32_5(&mut self, d32_5: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_5, d32_5, 0);
  }
  #[inline]
  pub fn add_d32_6(&mut self, d32_6: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_6, d32_6, 0);
  }
  #[inline]
  pub fn add_d32_7(&mut self, d32_7: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_7, d32_7, 0);
  }
  #[inline]
  pub fn add_d32_8(&mut self, d32_8: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_8, d32_8, 0);
  }
  #[inline]
  pub fn add_d32_9(&mut self, d32_9: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_9, d32_9, 0);
  }
  #[inline]
  pub fn add_d32_10(&mut self, d32_10: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MtiTargetReport_Ingest::VT_D32_10, d32_10);
  }
  #[inline]
  pub fn add_d32_11(&mut self, d32_11: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_11, d32_11, 0);
  }
  #[inline]
  pub fn add_d32_12(&mut self, d32_12: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_12, d32_12, 0);
  }
  #[inline]
  pub fn add_d32_13(&mut self, d32_13: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_13, d32_13, 0);
  }
  #[inline]
  pub fn add_d32_14(&mut self, d32_14: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_14, d32_14, 0);
  }
  #[inline]
  pub fn add_d32_15(&mut self, d32_15: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_15, d32_15, 0);
  }
  #[inline]
  pub fn add_d32_16(&mut self, d32_16: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_16, d32_16, 0);
  }
  #[inline]
  pub fn add_d32_17(&mut self, d32_17: i64) {
    self.fbb_.push_slot::<i64>(MtiTargetReport_Ingest::VT_D32_17, d32_17, 0);
  }
  #[inline]
  pub fn add_d32_18(&mut self, d32_18: i32) {
    self.fbb_.push_slot::<i32>(MtiTargetReport_Ingest::VT_D32_18, d32_18, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MtiTargetReport_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MtiTargetReport_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MtiTargetReport_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MtiTargetReport_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MtiTargetReport_Ingest");
      ds.field("d32_1", &self.d32_1());
      ds.field("d32_2", &self.d32_2());
      ds.field("d32_3", &self.d32_3());
      ds.field("d32_4", &self.d32_4());
      ds.field("d32_5", &self.d32_5());
      ds.field("d32_6", &self.d32_6());
      ds.field("d32_7", &self.d32_7());
      ds.field("d32_8", &self.d32_8());
      ds.field("d32_9", &self.d32_9());
      ds.field("d32_10", &self.d32_10());
      ds.field("d32_11", &self.d32_11());
      ds.field("d32_12", &self.d32_12());
      ds.field("d32_13", &self.d32_13());
      ds.field("d32_14", &self.d32_14());
      ds.field("d32_15", &self.d32_15());
      ds.field("d32_16", &self.d32_16());
      ds.field("d32_17", &self.d32_17());
      ds.field("d32_18", &self.d32_18());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MtiTargetReport_IngestT {
  pub d32_1: i32,
  pub d32_2: f64,
  pub d32_3: f64,
  pub d32_4: i32,
  pub d32_5: i32,
  pub d32_6: i32,
  pub d32_7: i32,
  pub d32_8: i32,
  pub d32_9: i32,
  pub d32_10: Option<String>,
  pub d32_11: i32,
  pub d32_12: i32,
  pub d32_13: i32,
  pub d32_14: i32,
  pub d32_15: i32,
  pub d32_16: i32,
  pub d32_17: i64,
  pub d32_18: i32,
}
impl Default for MtiTargetReport_IngestT {
  fn default() -> Self {
    Self {
      d32_1: 0,
      d32_2: 0.0,
      d32_3: 0.0,
      d32_4: 0,
      d32_5: 0,
      d32_6: 0,
      d32_7: 0,
      d32_8: 0,
      d32_9: 0,
      d32_10: None,
      d32_11: 0,
      d32_12: 0,
      d32_13: 0,
      d32_14: 0,
      d32_15: 0,
      d32_16: 0,
      d32_17: 0,
      d32_18: 0,
    }
  }
}
impl MtiTargetReport_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MtiTargetReport_Ingest<'b>> {
    let d32_1 = self.d32_1;
    let d32_2 = self.d32_2;
    let d32_3 = self.d32_3;
    let d32_4 = self.d32_4;
    let d32_5 = self.d32_5;
    let d32_6 = self.d32_6;
    let d32_7 = self.d32_7;
    let d32_8 = self.d32_8;
    let d32_9 = self.d32_9;
    let d32_10 = self.d32_10.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let d32_11 = self.d32_11;
    let d32_12 = self.d32_12;
    let d32_13 = self.d32_13;
    let d32_14 = self.d32_14;
    let d32_15 = self.d32_15;
    let d32_16 = self.d32_16;
    let d32_17 = self.d32_17;
    let d32_18 = self.d32_18;
    MtiTargetReport_Ingest::create(_fbb, &MtiTargetReport_IngestArgs{
      d32_1,
      d32_2,
      d32_3,
      d32_4,
      d32_5,
      d32_6,
      d32_7,
      d32_8,
      d32_9,
      d32_10,
      d32_11,
      d32_12,
      d32_13,
      d32_14,
      d32_15,
      d32_16,
      d32_17,
      d32_18,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `MtiTargetReport_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mti_target_report_ingest_unchecked`.
pub fn root_as_mti_target_report_ingest(buf: &[u8]) -> Result<MtiTargetReport_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MtiTargetReport_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MtiTargetReport_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_mti_target_report_ingest_unchecked`.
pub fn size_prefixed_root_as_mti_target_report_ingest(buf: &[u8]) -> Result<MtiTargetReport_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MtiTargetReport_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MtiTargetReport_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mti_target_report_ingest_unchecked`.
pub fn root_as_mti_target_report_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MtiTargetReport_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MtiTargetReport_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MtiTargetReport_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mti_target_report_ingest_unchecked`.
pub fn size_prefixed_root_as_mti_target_report_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MtiTargetReport_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MtiTargetReport_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MtiTargetReport_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MtiTargetReport_Ingest`.
pub unsafe fn root_as_mti_target_report_ingest_unchecked(buf: &[u8]) -> MtiTargetReport_Ingest {
  flatbuffers::root_unchecked::<MtiTargetReport_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MtiTargetReport_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MtiTargetReport_Ingest`.
pub unsafe fn size_prefixed_root_as_mti_target_report_ingest_unchecked(buf: &[u8]) -> MtiTargetReport_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<MtiTargetReport_Ingest>(buf)
}
pub const MTI_TARGET_REPORT_INGEST_IDENTIFIER: &str = "MTIT";

#[inline]
pub fn mti_target_report_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MTI_TARGET_REPORT_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn mti_target_report_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MTI_TARGET_REPORT_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_mti_target_report_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<MtiTargetReport_Ingest<'a>>) {
  fbb.finish(root, Some(MTI_TARGET_REPORT_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_mti_target_report_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<MtiTargetReport_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(MTI_TARGET_REPORT_INGEST_IDENTIFIER));
}
