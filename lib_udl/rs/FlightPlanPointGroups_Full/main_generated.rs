// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum FlightPlanPointGroups_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Collection of point groups generated for this flight plan. Groups include point sets for Extended Operations (ETOPS), Critical Fuel Point, and Equal Time Point (ETP).
pub struct FlightPlanPointGroups_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FlightPlanPointGroups_Full<'a> {
  type Inner = FlightPlanPointGroups_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FlightPlanPointGroups_Full<'a> {
  pub const VT_POINTGROUPNAME: flatbuffers::VOffsetT = 4;
  pub const VT_WORSTFUELCASE: flatbuffers::VOffsetT = 6;
  pub const VT_LSAFNAME: flatbuffers::VOffsetT = 8;
  pub const VT_LSAFDISTANCE: flatbuffers::VOffsetT = 10;
  pub const VT_FSAFDISTANCE: flatbuffers::VOffsetT = 12;
  pub const VT_ETOPSDISTANCE: flatbuffers::VOffsetT = 14;
  pub const VT_LSAFTIME: flatbuffers::VOffsetT = 16;
  pub const VT_FSAFTIME: flatbuffers::VOffsetT = 18;
  pub const VT_ETOPSTIME: flatbuffers::VOffsetT = 20;
  pub const VT_LSAFAVGWINDFACTOR: flatbuffers::VOffsetT = 22;
  pub const VT_FSAFAVGWINDFACTOR: flatbuffers::VOffsetT = 24;
  pub const VT_ETOPSAVGWINDFACTOR: flatbuffers::VOffsetT = 26;
  pub const VT_LSAFTEMPDEV: flatbuffers::VOffsetT = 28;
  pub const VT_FSAFTEMPDEV: flatbuffers::VOffsetT = 30;
  pub const VT_ETOPSTEMPDEV: flatbuffers::VOffsetT = 32;
  pub const VT_LSAFREQFUEL: flatbuffers::VOffsetT = 34;
  pub const VT_FSAFREQFUEL: flatbuffers::VOffsetT = 36;
  pub const VT_ETOPSREQFUEL: flatbuffers::VOffsetT = 38;
  pub const VT_FROMTAKEOFFTIME: flatbuffers::VOffsetT = 40;
  pub const VT_PLANNEDFUEL: flatbuffers::VOffsetT = 42;
  pub const VT_FUELCALCALT: flatbuffers::VOffsetT = 44;
  pub const VT_FUELCALCSPD: flatbuffers::VOffsetT = 46;
  pub const VT_AVGFUELFLOW: flatbuffers::VOffsetT = 48;
  pub const VT_FLIGHTPLANPOINTS: flatbuffers::VOffsetT = 50;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FlightPlanPointGroups_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FlightPlanPointGroups_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<FlightPlanPointGroups_Full<'bldr>> {
    let mut builder = FlightPlanPointGroups_FullBuilder::new(_fbb);
    builder.add_avgFuelFlow(args.avgFuelFlow);
    builder.add_fuelCalcSpd(args.fuelCalcSpd);
    builder.add_fuelCalcAlt(args.fuelCalcAlt);
    builder.add_plannedFuel(args.plannedFuel);
    builder.add_etopsReqFuel(args.etopsReqFuel);
    builder.add_fsafReqFuel(args.fsafReqFuel);
    builder.add_lsafReqFuel(args.lsafReqFuel);
    builder.add_etopsTempDev(args.etopsTempDev);
    builder.add_fsafTempDev(args.fsafTempDev);
    builder.add_lsafTempDev(args.lsafTempDev);
    builder.add_etopsAvgWindFactor(args.etopsAvgWindFactor);
    builder.add_fsafAvgWindFactor(args.fsafAvgWindFactor);
    builder.add_lsafAvgWindFactor(args.lsafAvgWindFactor);
    builder.add_etopsDistance(args.etopsDistance);
    builder.add_fsafDistance(args.fsafDistance);
    builder.add_lsafDistance(args.lsafDistance);
    if let Some(x) = args.flightPlanPoints { builder.add_flightPlanPoints(x); }
    if let Some(x) = args.fromTakeoffTime { builder.add_fromTakeoffTime(x); }
    if let Some(x) = args.etopsTime { builder.add_etopsTime(x); }
    if let Some(x) = args.fsafTime { builder.add_fsafTime(x); }
    if let Some(x) = args.lsafTime { builder.add_lsafTime(x); }
    if let Some(x) = args.lsafName { builder.add_lsafName(x); }
    if let Some(x) = args.worstFuelCase { builder.add_worstFuelCase(x); }
    if let Some(x) = args.pointGroupName { builder.add_pointGroupName(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> FlightPlanPointGroups_FullT {
    let pointGroupName = self.pointGroupName().map(|x| {
      x.to_string()
    });
    let worstFuelCase = self.worstFuelCase().map(|x| {
      x.to_string()
    });
    let lsafName = self.lsafName().map(|x| {
      x.to_string()
    });
    let lsafDistance = self.lsafDistance();
    let fsafDistance = self.fsafDistance();
    let etopsDistance = self.etopsDistance();
    let lsafTime = self.lsafTime().map(|x| {
      x.to_string()
    });
    let fsafTime = self.fsafTime().map(|x| {
      x.to_string()
    });
    let etopsTime = self.etopsTime().map(|x| {
      x.to_string()
    });
    let lsafAvgWindFactor = self.lsafAvgWindFactor();
    let fsafAvgWindFactor = self.fsafAvgWindFactor();
    let etopsAvgWindFactor = self.etopsAvgWindFactor();
    let lsafTempDev = self.lsafTempDev();
    let fsafTempDev = self.fsafTempDev();
    let etopsTempDev = self.etopsTempDev();
    let lsafReqFuel = self.lsafReqFuel();
    let fsafReqFuel = self.fsafReqFuel();
    let etopsReqFuel = self.etopsReqFuel();
    let fromTakeoffTime = self.fromTakeoffTime().map(|x| {
      x.to_string()
    });
    let plannedFuel = self.plannedFuel();
    let fuelCalcAlt = self.fuelCalcAlt();
    let fuelCalcSpd = self.fuelCalcSpd();
    let avgFuelFlow = self.avgFuelFlow();
    let flightPlanPoints = self.flightPlanPoints().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    FlightPlanPointGroups_FullT {
      pointGroupName,
      worstFuelCase,
      lsafName,
      lsafDistance,
      fsafDistance,
      etopsDistance,
      lsafTime,
      fsafTime,
      etopsTime,
      lsafAvgWindFactor,
      fsafAvgWindFactor,
      etopsAvgWindFactor,
      lsafTempDev,
      fsafTempDev,
      etopsTempDev,
      lsafReqFuel,
      fsafReqFuel,
      etopsReqFuel,
      fromTakeoffTime,
      plannedFuel,
      fuelCalcAlt,
      fuelCalcSpd,
      avgFuelFlow,
      flightPlanPoints,
    }
  }

  /// Name of the point group, usually Extended Operations (ETOPS), Critical Fuel Point, and Equal Time Point (ETP) sections.
  /// Example: /// Example: ETOPS_CF_POINT_1
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn pointGroupName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanPointGroups_Full::VT_POINTGROUPNAME, None)}
  }
  /// Specifies which Point Group case requires the most fuel.
  /// Example: /// Example: DEPRESSURIZED ENGINE OUT ETP
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn worstFuelCase(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanPointGroups_Full::VT_WORSTFUELCASE, None)}
  }
  /// Name of the last suitable airfield, International Civil Aviation Organization (ICAO) code preferred.
  /// Example: /// Example: LPPD
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn lsafName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanPointGroups_Full::VT_LSAFNAME, None)}
  }
  /// Distance from the Equal Time Point (ETP) to the last suitable airfield in nautical miles.
  /// Example: /// Example: 684.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lsafDistance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_LSAFDISTANCE, Some(0.0)).unwrap()}
  }
  /// Distance from the Equal Time Point (ETP) to the first suitable airfield in nautical miles.
  /// Example: /// Example: 684.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fsafDistance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_FSAFDISTANCE, Some(0.0)).unwrap()}
  }
  /// Distance from the Extended Operations (ETOPS) point to the recovery airfield in nautical miles.
  /// Example: /// Example: 684.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn etopsDistance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_ETOPSDISTANCE, Some(0.0)).unwrap()}
  }
  /// Time to fly from the Equal Time Point (ETP) to the last suitable airfield expressed in HH:MM format.
  /// Example: /// Example: 01:23
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn lsafTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanPointGroups_Full::VT_LSAFTIME, None)}
  }
  /// Time to fly from the Equal Time Point (ETP) to the first suitable airfield expressed in HH:MM format.
  /// Example: /// Example: 01:23
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn fsafTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanPointGroups_Full::VT_FSAFTIME, None)}
  }
  /// Time to fly from the Extended Operations (ETOPS) point to the recovery airfield expressed in HH:MM format.
  /// Example: /// Example: 01:23
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn etopsTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanPointGroups_Full::VT_ETOPSTIME, None)}
  }
  /// Average wind factor from the Equal Time Point (ETP) to the last suitable airfield in knots.
  /// Example: /// Example: 13.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lsafAvgWindFactor(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_LSAFAVGWINDFACTOR, Some(0.0)).unwrap()}
  }
  /// Average wind factor from the Equal Time Point (ETP) to the first suitable airfield in knots.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fsafAvgWindFactor(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_FSAFAVGWINDFACTOR, Some(0.0)).unwrap()}
  }
  /// Average wind factor from the Extended Operations (ETOPS) point to the recovery airfield in knots.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn etopsAvgWindFactor(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_ETOPSAVGWINDFACTOR, Some(0.0)).unwrap()}
  }
  /// Temperature deviation from the Equal Time Point (ETP) to the last suitable airfield in degrees Celsius.
  /// Example: /// Example: 9.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lsafTempDev(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_LSAFTEMPDEV, Some(0.0)).unwrap()}
  }
  /// Temperature deviation from the Equal Time Point (ETP) to the first suitable airfield in degrees Celsius.
  /// Example: /// Example: 9.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fsafTempDev(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_FSAFTEMPDEV, Some(0.0)).unwrap()}
  }
  /// Temperature deviation from the Extended Operations (ETOPS) point to the recovery airfield in degrees Celsius.
  /// Example: /// Example: 9.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn etopsTempDev(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_ETOPSTEMPDEV, Some(0.0)).unwrap()}
  }
  /// Fuel required to fly from the Equal Time Point (ETP) to the last suitable airfield in pounds.
  /// Example: /// Example: 50787.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lsafReqFuel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_LSAFREQFUEL, Some(0.0)).unwrap()}
  }
  /// Fuel required to fly from the Equal Time Point (ETP) to the first suitable airfield in pounds.
  /// Example: /// Example: 50380.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fsafReqFuel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_FSAFREQFUEL, Some(0.0)).unwrap()}
  }
  /// Fuel required to fly from the Extended Operations (ETOPS) point to the recovery airfield in pounds.
  /// Example: /// Example: 4412.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn etopsReqFuel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_ETOPSREQFUEL, Some(0.0)).unwrap()}
  }
  /// Total time from takeoff when the point is reached expressed in HH:MM format.
  /// Example: /// Example: 07:29
  /// Constraints: Minimum length = 0, Maximum length = 6
  #[inline]
  pub fn fromTakeoffTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FlightPlanPointGroups_Full::VT_FROMTAKEOFFTIME, None)}
  }
  /// Amount of planned fuel on board when the point is reached in pounds.
  /// Example: /// Example: 190319.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn plannedFuel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_PLANNEDFUEL, Some(0.0)).unwrap()}
  }
  /// Flight level of the point at which the fuel was calculated in feet.
  /// Example: /// Example: 100.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fuelCalcAlt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_FUELCALCALT, Some(0.0)).unwrap()}
  }
  /// True airspeed at which the fuel was calculated in knots.
  /// Example: /// Example: 365.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fuelCalcSpd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_FUELCALCSPD, Some(0.0)).unwrap()}
  }
  /// Average fuel flow at which the fuel was calculated in pounds per hour.
  /// Example: /// Example: 19693.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn avgFuelFlow(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FlightPlanPointGroups_Full::VT_AVGFUELFLOW, Some(0.0)).unwrap()}
  }
  /// Array of point data for this Point Group.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn flightPlanPoints(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(FlightPlanPointGroups_Full::VT_FLIGHTPLANPOINTS, None)}
  }
}

impl flatbuffers::Verifiable for FlightPlanPointGroups_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pointGroupName", Self::VT_POINTGROUPNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("worstFuelCase", Self::VT_WORSTFUELCASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lsafName", Self::VT_LSAFNAME, false)?
     .visit_field::<f64>("lsafDistance", Self::VT_LSAFDISTANCE, false)?
     .visit_field::<f64>("fsafDistance", Self::VT_FSAFDISTANCE, false)?
     .visit_field::<f64>("etopsDistance", Self::VT_ETOPSDISTANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lsafTime", Self::VT_LSAFTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fsafTime", Self::VT_FSAFTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("etopsTime", Self::VT_ETOPSTIME, false)?
     .visit_field::<f64>("lsafAvgWindFactor", Self::VT_LSAFAVGWINDFACTOR, false)?
     .visit_field::<f64>("fsafAvgWindFactor", Self::VT_FSAFAVGWINDFACTOR, false)?
     .visit_field::<f64>("etopsAvgWindFactor", Self::VT_ETOPSAVGWINDFACTOR, false)?
     .visit_field::<f64>("lsafTempDev", Self::VT_LSAFTEMPDEV, false)?
     .visit_field::<f64>("fsafTempDev", Self::VT_FSAFTEMPDEV, false)?
     .visit_field::<f64>("etopsTempDev", Self::VT_ETOPSTEMPDEV, false)?
     .visit_field::<f64>("lsafReqFuel", Self::VT_LSAFREQFUEL, false)?
     .visit_field::<f64>("fsafReqFuel", Self::VT_FSAFREQFUEL, false)?
     .visit_field::<f64>("etopsReqFuel", Self::VT_ETOPSREQFUEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fromTakeoffTime", Self::VT_FROMTAKEOFFTIME, false)?
     .visit_field::<f64>("plannedFuel", Self::VT_PLANNEDFUEL, false)?
     .visit_field::<f64>("fuelCalcAlt", Self::VT_FUELCALCALT, false)?
     .visit_field::<f64>("fuelCalcSpd", Self::VT_FUELCALCSPD, false)?
     .visit_field::<f64>("avgFuelFlow", Self::VT_AVGFUELFLOW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("flightPlanPoints", Self::VT_FLIGHTPLANPOINTS, false)?
     .finish();
    Ok(())
  }
}
pub struct FlightPlanPointGroups_FullArgs<'a> {
    pub pointGroupName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub worstFuelCase: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lsafName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lsafDistance: f64,
    pub fsafDistance: f64,
    pub etopsDistance: f64,
    pub lsafTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fsafTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub etopsTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lsafAvgWindFactor: f64,
    pub fsafAvgWindFactor: f64,
    pub etopsAvgWindFactor: f64,
    pub lsafTempDev: f64,
    pub fsafTempDev: f64,
    pub etopsTempDev: f64,
    pub lsafReqFuel: f64,
    pub fsafReqFuel: f64,
    pub etopsReqFuel: f64,
    pub fromTakeoffTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub plannedFuel: f64,
    pub fuelCalcAlt: f64,
    pub fuelCalcSpd: f64,
    pub avgFuelFlow: f64,
    pub flightPlanPoints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for FlightPlanPointGroups_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    FlightPlanPointGroups_FullArgs {
      pointGroupName: None,
      worstFuelCase: None,
      lsafName: None,
      lsafDistance: 0.0,
      fsafDistance: 0.0,
      etopsDistance: 0.0,
      lsafTime: None,
      fsafTime: None,
      etopsTime: None,
      lsafAvgWindFactor: 0.0,
      fsafAvgWindFactor: 0.0,
      etopsAvgWindFactor: 0.0,
      lsafTempDev: 0.0,
      fsafTempDev: 0.0,
      etopsTempDev: 0.0,
      lsafReqFuel: 0.0,
      fsafReqFuel: 0.0,
      etopsReqFuel: 0.0,
      fromTakeoffTime: None,
      plannedFuel: 0.0,
      fuelCalcAlt: 0.0,
      fuelCalcSpd: 0.0,
      avgFuelFlow: 0.0,
      flightPlanPoints: None,
    }
  }
}

pub struct FlightPlanPointGroups_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FlightPlanPointGroups_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pointGroupName(&mut self, pointGroupName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanPointGroups_Full::VT_POINTGROUPNAME, pointGroupName);
  }
  #[inline]
  pub fn add_worstFuelCase(&mut self, worstFuelCase: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanPointGroups_Full::VT_WORSTFUELCASE, worstFuelCase);
  }
  #[inline]
  pub fn add_lsafName(&mut self, lsafName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanPointGroups_Full::VT_LSAFNAME, lsafName);
  }
  #[inline]
  pub fn add_lsafDistance(&mut self, lsafDistance: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_LSAFDISTANCE, lsafDistance, 0.0);
  }
  #[inline]
  pub fn add_fsafDistance(&mut self, fsafDistance: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_FSAFDISTANCE, fsafDistance, 0.0);
  }
  #[inline]
  pub fn add_etopsDistance(&mut self, etopsDistance: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_ETOPSDISTANCE, etopsDistance, 0.0);
  }
  #[inline]
  pub fn add_lsafTime(&mut self, lsafTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanPointGroups_Full::VT_LSAFTIME, lsafTime);
  }
  #[inline]
  pub fn add_fsafTime(&mut self, fsafTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanPointGroups_Full::VT_FSAFTIME, fsafTime);
  }
  #[inline]
  pub fn add_etopsTime(&mut self, etopsTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanPointGroups_Full::VT_ETOPSTIME, etopsTime);
  }
  #[inline]
  pub fn add_lsafAvgWindFactor(&mut self, lsafAvgWindFactor: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_LSAFAVGWINDFACTOR, lsafAvgWindFactor, 0.0);
  }
  #[inline]
  pub fn add_fsafAvgWindFactor(&mut self, fsafAvgWindFactor: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_FSAFAVGWINDFACTOR, fsafAvgWindFactor, 0.0);
  }
  #[inline]
  pub fn add_etopsAvgWindFactor(&mut self, etopsAvgWindFactor: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_ETOPSAVGWINDFACTOR, etopsAvgWindFactor, 0.0);
  }
  #[inline]
  pub fn add_lsafTempDev(&mut self, lsafTempDev: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_LSAFTEMPDEV, lsafTempDev, 0.0);
  }
  #[inline]
  pub fn add_fsafTempDev(&mut self, fsafTempDev: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_FSAFTEMPDEV, fsafTempDev, 0.0);
  }
  #[inline]
  pub fn add_etopsTempDev(&mut self, etopsTempDev: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_ETOPSTEMPDEV, etopsTempDev, 0.0);
  }
  #[inline]
  pub fn add_lsafReqFuel(&mut self, lsafReqFuel: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_LSAFREQFUEL, lsafReqFuel, 0.0);
  }
  #[inline]
  pub fn add_fsafReqFuel(&mut self, fsafReqFuel: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_FSAFREQFUEL, fsafReqFuel, 0.0);
  }
  #[inline]
  pub fn add_etopsReqFuel(&mut self, etopsReqFuel: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_ETOPSREQFUEL, etopsReqFuel, 0.0);
  }
  #[inline]
  pub fn add_fromTakeoffTime(&mut self, fromTakeoffTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanPointGroups_Full::VT_FROMTAKEOFFTIME, fromTakeoffTime);
  }
  #[inline]
  pub fn add_plannedFuel(&mut self, plannedFuel: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_PLANNEDFUEL, plannedFuel, 0.0);
  }
  #[inline]
  pub fn add_fuelCalcAlt(&mut self, fuelCalcAlt: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_FUELCALCALT, fuelCalcAlt, 0.0);
  }
  #[inline]
  pub fn add_fuelCalcSpd(&mut self, fuelCalcSpd: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_FUELCALCSPD, fuelCalcSpd, 0.0);
  }
  #[inline]
  pub fn add_avgFuelFlow(&mut self, avgFuelFlow: f64) {
    self.fbb_.push_slot::<f64>(FlightPlanPointGroups_Full::VT_AVGFUELFLOW, avgFuelFlow, 0.0);
  }
  #[inline]
  pub fn add_flightPlanPoints(&mut self, flightPlanPoints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlightPlanPointGroups_Full::VT_FLIGHTPLANPOINTS, flightPlanPoints);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FlightPlanPointGroups_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FlightPlanPointGroups_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FlightPlanPointGroups_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FlightPlanPointGroups_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FlightPlanPointGroups_Full");
      ds.field("pointGroupName", &self.pointGroupName());
      ds.field("worstFuelCase", &self.worstFuelCase());
      ds.field("lsafName", &self.lsafName());
      ds.field("lsafDistance", &self.lsafDistance());
      ds.field("fsafDistance", &self.fsafDistance());
      ds.field("etopsDistance", &self.etopsDistance());
      ds.field("lsafTime", &self.lsafTime());
      ds.field("fsafTime", &self.fsafTime());
      ds.field("etopsTime", &self.etopsTime());
      ds.field("lsafAvgWindFactor", &self.lsafAvgWindFactor());
      ds.field("fsafAvgWindFactor", &self.fsafAvgWindFactor());
      ds.field("etopsAvgWindFactor", &self.etopsAvgWindFactor());
      ds.field("lsafTempDev", &self.lsafTempDev());
      ds.field("fsafTempDev", &self.fsafTempDev());
      ds.field("etopsTempDev", &self.etopsTempDev());
      ds.field("lsafReqFuel", &self.lsafReqFuel());
      ds.field("fsafReqFuel", &self.fsafReqFuel());
      ds.field("etopsReqFuel", &self.etopsReqFuel());
      ds.field("fromTakeoffTime", &self.fromTakeoffTime());
      ds.field("plannedFuel", &self.plannedFuel());
      ds.field("fuelCalcAlt", &self.fuelCalcAlt());
      ds.field("fuelCalcSpd", &self.fuelCalcSpd());
      ds.field("avgFuelFlow", &self.avgFuelFlow());
      ds.field("flightPlanPoints", &self.flightPlanPoints());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FlightPlanPointGroups_FullT {
  pub pointGroupName: Option<String>,
  pub worstFuelCase: Option<String>,
  pub lsafName: Option<String>,
  pub lsafDistance: f64,
  pub fsafDistance: f64,
  pub etopsDistance: f64,
  pub lsafTime: Option<String>,
  pub fsafTime: Option<String>,
  pub etopsTime: Option<String>,
  pub lsafAvgWindFactor: f64,
  pub fsafAvgWindFactor: f64,
  pub etopsAvgWindFactor: f64,
  pub lsafTempDev: f64,
  pub fsafTempDev: f64,
  pub etopsTempDev: f64,
  pub lsafReqFuel: f64,
  pub fsafReqFuel: f64,
  pub etopsReqFuel: f64,
  pub fromTakeoffTime: Option<String>,
  pub plannedFuel: f64,
  pub fuelCalcAlt: f64,
  pub fuelCalcSpd: f64,
  pub avgFuelFlow: f64,
  pub flightPlanPoints: Option<Vec<String>>,
}
impl Default for FlightPlanPointGroups_FullT {
  fn default() -> Self {
    Self {
      pointGroupName: None,
      worstFuelCase: None,
      lsafName: None,
      lsafDistance: 0.0,
      fsafDistance: 0.0,
      etopsDistance: 0.0,
      lsafTime: None,
      fsafTime: None,
      etopsTime: None,
      lsafAvgWindFactor: 0.0,
      fsafAvgWindFactor: 0.0,
      etopsAvgWindFactor: 0.0,
      lsafTempDev: 0.0,
      fsafTempDev: 0.0,
      etopsTempDev: 0.0,
      lsafReqFuel: 0.0,
      fsafReqFuel: 0.0,
      etopsReqFuel: 0.0,
      fromTakeoffTime: None,
      plannedFuel: 0.0,
      fuelCalcAlt: 0.0,
      fuelCalcSpd: 0.0,
      avgFuelFlow: 0.0,
      flightPlanPoints: None,
    }
  }
}
impl FlightPlanPointGroups_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<FlightPlanPointGroups_Full<'b>> {
    let pointGroupName = self.pointGroupName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let worstFuelCase = self.worstFuelCase.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lsafName = self.lsafName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lsafDistance = self.lsafDistance;
    let fsafDistance = self.fsafDistance;
    let etopsDistance = self.etopsDistance;
    let lsafTime = self.lsafTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let fsafTime = self.fsafTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let etopsTime = self.etopsTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lsafAvgWindFactor = self.lsafAvgWindFactor;
    let fsafAvgWindFactor = self.fsafAvgWindFactor;
    let etopsAvgWindFactor = self.etopsAvgWindFactor;
    let lsafTempDev = self.lsafTempDev;
    let fsafTempDev = self.fsafTempDev;
    let etopsTempDev = self.etopsTempDev;
    let lsafReqFuel = self.lsafReqFuel;
    let fsafReqFuel = self.fsafReqFuel;
    let etopsReqFuel = self.etopsReqFuel;
    let fromTakeoffTime = self.fromTakeoffTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let plannedFuel = self.plannedFuel;
    let fuelCalcAlt = self.fuelCalcAlt;
    let fuelCalcSpd = self.fuelCalcSpd;
    let avgFuelFlow = self.avgFuelFlow;
    let flightPlanPoints = self.flightPlanPoints.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    FlightPlanPointGroups_Full::create(_fbb, &FlightPlanPointGroups_FullArgs{
      pointGroupName,
      worstFuelCase,
      lsafName,
      lsafDistance,
      fsafDistance,
      etopsDistance,
      lsafTime,
      fsafTime,
      etopsTime,
      lsafAvgWindFactor,
      fsafAvgWindFactor,
      etopsAvgWindFactor,
      lsafTempDev,
      fsafTempDev,
      etopsTempDev,
      lsafReqFuel,
      fsafReqFuel,
      etopsReqFuel,
      fromTakeoffTime,
      plannedFuel,
      fuelCalcAlt,
      fuelCalcSpd,
      avgFuelFlow,
      flightPlanPoints,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `FlightPlanPointGroups_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_point_groups_full_unchecked`.
pub fn root_as_flight_plan_point_groups_full(buf: &[u8]) -> Result<FlightPlanPointGroups_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<FlightPlanPointGroups_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FlightPlanPointGroups_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_flight_plan_point_groups_full_unchecked`.
pub fn size_prefixed_root_as_flight_plan_point_groups_full(buf: &[u8]) -> Result<FlightPlanPointGroups_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<FlightPlanPointGroups_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FlightPlanPointGroups_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_point_groups_full_unchecked`.
pub fn root_as_flight_plan_point_groups_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlightPlanPointGroups_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<FlightPlanPointGroups_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FlightPlanPointGroups_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flight_plan_point_groups_full_unchecked`.
pub fn size_prefixed_root_as_flight_plan_point_groups_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlightPlanPointGroups_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<FlightPlanPointGroups_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FlightPlanPointGroups_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FlightPlanPointGroups_Full`.
pub unsafe fn root_as_flight_plan_point_groups_full_unchecked(buf: &[u8]) -> FlightPlanPointGroups_Full {
  flatbuffers::root_unchecked::<FlightPlanPointGroups_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FlightPlanPointGroups_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FlightPlanPointGroups_Full`.
pub unsafe fn size_prefixed_root_as_flight_plan_point_groups_full_unchecked(buf: &[u8]) -> FlightPlanPointGroups_Full {
  flatbuffers::size_prefixed_root_unchecked::<FlightPlanPointGroups_Full>(buf)
}
pub const FLIGHT_PLAN_POINT_GROUPS_FULL_IDENTIFIER: &str = "FLIG";

#[inline]
pub fn flight_plan_point_groups_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, FLIGHT_PLAN_POINT_GROUPS_FULL_IDENTIFIER, false)
}

#[inline]
pub fn flight_plan_point_groups_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, FLIGHT_PLAN_POINT_GROUPS_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_flight_plan_point_groups_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<FlightPlanPointGroups_Full<'a>>) {
  fbb.finish(root, Some(FLIGHT_PLAN_POINT_GROUPS_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_flight_plan_point_groups_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<FlightPlanPointGroups_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(FLIGHT_PLAN_POINT_GROUPS_FULL_IDENTIFIER));
}
