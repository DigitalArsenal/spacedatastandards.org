// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ORBIT_TRACK_INGEST_OBJ_IDENT_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ORBIT_TRACK_INGEST_OBJ_IDENT_ENUM: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ORBIT_TRACK_INGEST_OBJ_IDENT_ENUM: [OrbitTrack_Ingest_objIdent_Enum; 7] = [
  OrbitTrack_Ingest_objIdent_Enum::ASSUMED_FRIEND,
  OrbitTrack_Ingest_objIdent_Enum::FRIEND,
  OrbitTrack_Ingest_objIdent_Enum::HOSTILE,
  OrbitTrack_Ingest_objIdent_Enum::NEUTRAL,
  OrbitTrack_Ingest_objIdent_Enum::PENDING,
  OrbitTrack_Ingest_objIdent_Enum::SUSPECT,
  OrbitTrack_Ingest_objIdent_Enum::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OrbitTrack_Ingest_objIdent_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl OrbitTrack_Ingest_objIdent_Enum {
  /// Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  pub const ASSUMED_FRIEND: Self = Self(0);
  /// Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  pub const FRIEND: Self = Self(1);
  /// Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  pub const HOSTILE: Self = Self(2);
  /// Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  pub const NEUTRAL: Self = Self(3);
  /// Track object which has not been evaluated.
  pub const PENDING: Self = Self(4);
  /// Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  pub const SUSPECT: Self = Self(5);
  /// Track object which has been evaluated and does not meet criteria for any standard identity.
  pub const UNKNOWN: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ASSUMED_FRIEND,
    Self::FRIEND,
    Self::HOSTILE,
    Self::NEUTRAL,
    Self::PENDING,
    Self::SUSPECT,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ASSUMED_FRIEND => Some("ASSUMED_FRIEND"),
      Self::FRIEND => Some("FRIEND"),
      Self::HOSTILE => Some("HOSTILE"),
      Self::NEUTRAL => Some("NEUTRAL"),
      Self::PENDING => Some("PENDING"),
      Self::SUSPECT => Some("SUSPECT"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OrbitTrack_Ingest_objIdent_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OrbitTrack_Ingest_objIdent_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for OrbitTrack_Ingest_objIdent_Enum {
    type Output = OrbitTrack_Ingest_objIdent_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OrbitTrack_Ingest_objIdent_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OrbitTrack_Ingest_objIdent_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OrbitTrack_Ingest_objIdent_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ORBIT_TRACK_INGEST_OBJECT_TYPE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ORBIT_TRACK_INGEST_OBJECT_TYPE_ENUM: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ORBIT_TRACK_INGEST_OBJECT_TYPE_ENUM: [OrbitTrack_Ingest_objectType_Enum; 6] = [
  OrbitTrack_Ingest_objectType_Enum::DEBRIS,
  OrbitTrack_Ingest_objectType_Enum::MANNED,
  OrbitTrack_Ingest_objectType_Enum::PAYLOAD,
  OrbitTrack_Ingest_objectType_Enum::PLATFORM,
  OrbitTrack_Ingest_objectType_Enum::ROCKET_BODY,
  OrbitTrack_Ingest_objectType_Enum::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OrbitTrack_Ingest_objectType_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl OrbitTrack_Ingest_objectType_Enum {
  /// No description available.
  pub const DEBRIS: Self = Self(0);
  /// No description available.
  pub const MANNED: Self = Self(1);
  /// No description available.
  pub const PAYLOAD: Self = Self(2);
  /// No description available.
  pub const PLATFORM: Self = Self(3);
  /// No description available.
  pub const ROCKET_BODY: Self = Self(4);
  /// No description available.
  pub const UNKNOWN: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DEBRIS,
    Self::MANNED,
    Self::PAYLOAD,
    Self::PLATFORM,
    Self::ROCKET_BODY,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DEBRIS => Some("DEBRIS"),
      Self::MANNED => Some("MANNED"),
      Self::PAYLOAD => Some("PAYLOAD"),
      Self::PLATFORM => Some("PLATFORM"),
      Self::ROCKET_BODY => Some("ROCKET_BODY"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OrbitTrack_Ingest_objectType_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OrbitTrack_Ingest_objectType_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for OrbitTrack_Ingest_objectType_Enum {
    type Output = OrbitTrack_Ingest_objectType_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OrbitTrack_Ingest_objectType_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OrbitTrack_Ingest_objectType_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OrbitTrack_Ingest_objectType_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ORBIT_TRACK_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ORBIT_TRACK_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ORBIT_TRACK_INGEST_DATA_MODE_ENUM: [OrbitTrack_Ingest_dataMode_Enum; 4] = [
  OrbitTrack_Ingest_dataMode_Enum::REAL,
  OrbitTrack_Ingest_dataMode_Enum::TEST,
  OrbitTrack_Ingest_dataMode_Enum::SIMULATED,
  OrbitTrack_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OrbitTrack_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl OrbitTrack_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OrbitTrack_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OrbitTrack_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for OrbitTrack_Ingest_dataMode_Enum {
    type Output = OrbitTrack_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OrbitTrack_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OrbitTrack_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OrbitTrack_Ingest_dataMode_Enum {}
pub enum OrbitTrack_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Keplerian orbital elements describing an orbit for a particular on-orbit satellite and applicable sensor data aiding in the orbit prediction.
pub struct OrbitTrack_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OrbitTrack_Ingest<'a> {
  type Inner = OrbitTrack_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OrbitTrack_Ingest<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 8;
  pub const VT_SATNO: flatbuffers::VOffsetT = 10;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 12;
  pub const VT_IDELSET: flatbuffers::VOffsetT = 14;
  pub const VT_TS: flatbuffers::VOffsetT = 16;
  pub const VT_LAT: flatbuffers::VOffsetT = 18;
  pub const VT_LON: flatbuffers::VOffsetT = 20;
  pub const VT_ALT: flatbuffers::VOffsetT = 22;
  pub const VT_RDFRF: flatbuffers::VOffsetT = 24;
  pub const VT_CALLSIGN: flatbuffers::VOffsetT = 26;
  pub const VT_RPTNUM: flatbuffers::VOffsetT = 28;
  pub const VT_OBJIDENT: flatbuffers::VOffsetT = 30;
  pub const VT_IDENTAMP: flatbuffers::VOffsetT = 32;
  pub const VT_SATSTATUS: flatbuffers::VOffsetT = 34;
  pub const VT_OBJECTTYPE: flatbuffers::VOffsetT = 36;
  pub const VT_COUNTRYCODE: flatbuffers::VOffsetT = 38;
  pub const VT_DECAY: flatbuffers::VOffsetT = 40;
  pub const VT_CHARLIELINE: flatbuffers::VOffsetT = 42;
  pub const VT_AOUTYPE: flatbuffers::VOffsetT = 44;
  pub const VT_AOUDATA: flatbuffers::VOffsetT = 46;
  pub const VT_SPD: flatbuffers::VOffsetT = 48;
  pub const VT_ANGELEV: flatbuffers::VOffsetT = 50;
  pub const VT_CNTNMNT: flatbuffers::VOffsetT = 52;
  pub const VT_XREF: flatbuffers::VOffsetT = 54;
  pub const VT_CHXREF: flatbuffers::VOffsetT = 56;
  pub const VT_AMPLIFICATION: flatbuffers::VOffsetT = 58;
  pub const VT_IFF: flatbuffers::VOffsetT = 60;
  pub const VT_REINFORCED: flatbuffers::VOffsetT = 62;
  pub const VT_REDUCED: flatbuffers::VOffsetT = 64;
  pub const VT_HQ: flatbuffers::VOffsetT = 66;
  pub const VT_DUMMY: flatbuffers::VOffsetT = 68;
  pub const VT_TASKFORCE: flatbuffers::VOffsetT = 70;
  pub const VT_FEINT: flatbuffers::VOffsetT = 72;
  pub const VT_INSTALLATION: flatbuffers::VOffsetT = 74;
  pub const VT_VEHTYPE: flatbuffers::VOffsetT = 76;
  pub const VT_TRKID: flatbuffers::VOffsetT = 78;
  pub const VT_TRACKSENSORS: flatbuffers::VOffsetT = 80;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 82;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 84;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 86;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 88;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 90;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 92;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OrbitTrack_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OrbitTrack_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<OrbitTrack_Ingest<'bldr>> {
    let mut builder = OrbitTrack_IngestBuilder::new(_fbb);
    builder.add_cntnmnt(args.cntnmnt);
    builder.add_angElev(args.angElev);
    builder.add_spd(args.spd);
    builder.add_decay(args.decay);
    builder.add_rdfRF(args.rdfRF);
    builder.add_alt(args.alt);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.trackSensors { builder.add_trackSensors(x); }
    if let Some(x) = args.trkId { builder.add_trkId(x); }
    if let Some(x) = args.vehType { builder.add_vehType(x); }
    if let Some(x) = args.iff { builder.add_iff(x); }
    if let Some(x) = args.amplification { builder.add_amplification(x); }
    if let Some(x) = args.chXRef { builder.add_chXRef(x); }
    if let Some(x) = args.xref { builder.add_xref(x); }
    if let Some(x) = args.aouData { builder.add_aouData(x); }
    if let Some(x) = args.aouType { builder.add_aouType(x); }
    if let Some(x) = args.charlieLine { builder.add_charlieLine(x); }
    if let Some(x) = args.countryCode { builder.add_countryCode(x); }
    if let Some(x) = args.satStatus { builder.add_satStatus(x); }
    if let Some(x) = args.identAmp { builder.add_identAmp(x); }
    if let Some(x) = args.rptNum { builder.add_rptNum(x); }
    if let Some(x) = args.callSign { builder.add_callSign(x); }
    if let Some(x) = args.ts { builder.add_ts(x); }
    if let Some(x) = args.idElset { builder.add_idElset(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_installation(args.installation);
    builder.add_feint(args.feint);
    builder.add_taskForce(args.taskForce);
    builder.add_dummy(args.dummy);
    builder.add_hq(args.hq);
    builder.add_reduced(args.reduced);
    builder.add_reinforced(args.reinforced);
    builder.add_objectType(args.objectType);
    builder.add_objIdent(args.objIdent);
    builder.finish()
  }

  pub fn unpack(&self) -> OrbitTrack_IngestT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let satNo = self.satNo();
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let idElset = self.idElset().map(|x| {
      x.to_string()
    });
    let ts = self.ts().map(|x| {
      x.to_string()
    });
    let lat = self.lat();
    let lon = self.lon();
    let alt = self.alt();
    let rdfRF = self.rdfRF();
    let callSign = self.callSign().map(|x| {
      x.to_string()
    });
    let rptNum = self.rptNum().map(|x| {
      x.to_string()
    });
    let objIdent = self.objIdent();
    let identAmp = self.identAmp().map(|x| {
      x.to_string()
    });
    let satStatus = self.satStatus().map(|x| {
      x.to_string()
    });
    let objectType = self.objectType();
    let countryCode = self.countryCode().map(|x| {
      x.to_string()
    });
    let decay = self.decay();
    let charlieLine = self.charlieLine().map(|x| {
      x.to_string()
    });
    let aouType = self.aouType().map(|x| {
      x.to_string()
    });
    let aouData = self.aouData().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let spd = self.spd();
    let angElev = self.angElev();
    let cntnmnt = self.cntnmnt();
    let xref = self.xref().map(|x| {
      x.to_string()
    });
    let chXRef = self.chXRef().map(|x| {
      x.to_string()
    });
    let amplification = self.amplification().map(|x| {
      x.to_string()
    });
    let iff = self.iff().map(|x| {
      x.to_string()
    });
    let reinforced = self.reinforced();
    let reduced = self.reduced();
    let hq = self.hq();
    let dummy = self.dummy();
    let taskForce = self.taskForce();
    let feint = self.feint();
    let installation = self.installation();
    let vehType = self.vehType().map(|x| {
      x.to_string()
    });
    let trkId = self.trkId().map(|x| {
      x.to_string()
    });
    let trackSensors = self.trackSensors().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    OrbitTrack_IngestT {
      id,
      classificationMarking,
      idOnOrbit,
      satNo,
      origObjectId,
      idElset,
      ts,
      lat,
      lon,
      alt,
      rdfRF,
      callSign,
      rptNum,
      objIdent,
      identAmp,
      satStatus,
      objectType,
      countryCode,
      decay,
      charlieLine,
      aouType,
      aouData,
      spd,
      angElev,
      cntnmnt,
      xref,
      chXRef,
      amplification,
      iff,
      reinforced,
      reduced,
      hq,
      dummy,
      taskForce,
      feint,
      installation,
      vehType,
      trkId,
      trackSensors,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system if not provided on create operations.
  /// Example: /// Example: ORBIT_TRACK_ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the target on-orbit object, if correlated.
  /// Example: /// Example: 32375
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_IDONORBIT, None)}
  }
  /// Satellite/catalog number of the target on-orbit object.
  /// Example: /// Example: 37375
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OrbitTrack_Ingest::VT_SATNO, Some(0)).unwrap()}
  }
  /// Optional identifier provided by observation source to indicate the target on-orbit object of this track. This may be an internal identifier and not necessarily a valid satellite number.
  /// Example: /// Example: L2045
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_ORIGOBJECTID, None)}
  }
  /// Unique identifier of the Elset associated with this object.
  /// Example: /// Example: c715a619-8695-44d2-9e7d-effd257b4843
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idElset(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_IDELSET, None)}
  }
  /// Track timestamp in ISO8601 UTC format, with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ts(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_TS, None)}
  }
  /// WGS-84 latitude of the track object subpoint, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OrbitTrack_Ingest::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude of the track object subpoint, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OrbitTrack_Ingest::VT_LON, Some(0.0)).unwrap()}
  }
  /// Track point altitude relative to WGS-84 ellipsoid, in meters.
  /// Example: /// Example: 585.71
  /// Constraints: No constraints specified.
  #[inline]
  pub fn alt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OrbitTrack_Ingest::VT_ALT, Some(0.0)).unwrap()}
  }
  /// Radio frequency of the track, measured in megahertz (MHz).
  /// Example: /// Example: 1.5273
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rdfRF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OrbitTrack_Ingest::VT_RDFRF, Some(0.0)).unwrap()}
  }
  /// International radio call sign assigned to the track. This is an 8-character alphanumeric code.
  /// Example: /// Example: Charlie
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn callSign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_CALLSIGN, None)}
  }
  /// Report number received from the reporting source for this track.
  /// Example: /// Example: 123
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn rptNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_RPTNUM, None)}
  }
  /// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
  ///  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  ///  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  ///  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  ///  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  ///  PENDING: Track object which has not been evaluated.
  ///  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  ///  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
  /// Example: /// Example: FRIEND
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn objIdent(&self) -> OrbitTrack_Ingest_objIdent_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OrbitTrack_Ingest_objIdent_Enum>(OrbitTrack_Ingest::VT_OBJIDENT, Some(OrbitTrack_Ingest_objIdent_Enum::ASSUMED_FRIEND)).unwrap()}
  }
  /// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
  ///  FAKER: Friendly track, object, or entity acting as an exercise hostile.
  ///  JOKER: Friendly track, object, or entity acting as an exercise suspect.
  ///  KILO: Friendly high-value object.
  ///  TRAVELLER: Suspect land or surface track following a recognized traffic route.
  ///  ZOMBIE: Suspect track, object, or entity of special interest.
  /// Example: /// Example: JOKER
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn identAmp(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_IDENTAMP, None)}
  }
  /// Status of the satellite.
  /// Example: /// Example: INACTIVE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn satStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_SATSTATUS, None)}
  }
  /// The on-orbit category assigned to this track object (DEBRIS, MANNED, PAYLOAD, PLATFORM, ROCKET BODY, UNKNOWN).
  /// Example: /// Example: PAYLOAD
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn objectType(&self) -> OrbitTrack_Ingest_objectType_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OrbitTrack_Ingest_objectType_Enum>(OrbitTrack_Ingest::VT_OBJECTTYPE, Some(OrbitTrack_Ingest_objectType_Enum::DEBRIS)).unwrap()}
  }
  /// The country code. This value is typically the ISO 3166 Alpha-2 two-character country code, however it can also represent various consortiums that do not appear in the ISO document. The code must correspond to an existing country in the UDL’s country API. Call udl/country/{code} to get any associated FIPS code, ISO Alpha-3 code, or alternate code values that exist for the specified country code.
  /// Example: /// Example: US
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn countryCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_COUNTRYCODE, None)}
  }
  /// Predicted change in Mean Motion (velocity) in radians/herg^2.  herg is a unit of time measure equal to 806.8120769 seconds, and is the orbital period of an imaginary satellite rotating about the Earth at zero altitude.
  /// Example: /// Example: 0.5868
  /// Constraints: No constraints specified.
  #[inline]
  pub fn decay(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OrbitTrack_Ingest::VT_DECAY, Some(0.0)).unwrap()}
  }
  /// One-line Charlie elements set.
  /// Example: /// Example: 323751332255940400010000003635829600010200072500098205001150
  /// Constraints: Minimum length = 0, Maximum length = 100
  #[inline]
  pub fn charlieLine(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_CHARLIELINE, None)}
  }
  /// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouData array and is required if aouData is not null. See the aouData field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn aouType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_AOUTYPE, None)}
  }
  /// Three element array representing an Area of Uncertainty (AoU).  The array element definitions and units are type specific depending on the aouType specified in this record:
  /// ELLIPSE:
  ///    brg - orientation in degrees of the ellipse
  ///    a1 - semi-major axis in meters
  ///    a2 - semi-minor axis in meters
  /// BEARING (BEARING BOX or MTST BEARING BOX):
  ///    brg - orientation in degrees of the bearing box 
  ///    a1 - length of bearing box in meters 
  ///    a2 - half-width of bearing box in meters 
  /// OTHER (All other type values):
  ///    brg - line of bearing in degrees true 
  ///    a1 - bearing error in degrees 
  ///    a2 - estimated range in meters.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn aouData(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OrbitTrack_Ingest::VT_AOUDATA, None)}
  }
  /// Track object speed, in km/sec.
  /// Example: /// Example: 15.03443
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OrbitTrack_Ingest::VT_SPD, Some(0.0)).unwrap()}
  }
  /// The angle formed between the line of sight of the observer and the horizon at track timestamp, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
  /// Example: /// Example: 15.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn angElev(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OrbitTrack_Ingest::VT_ANGELEV, Some(0.0)).unwrap()}
  }
  /// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
  /// Example: /// Example: 90
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cntnmnt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OrbitTrack_Ingest::VT_CNTNMNT, Some(0.0)).unwrap()}
  }
  /// Source cross-reference code for the command that originated the track report.
  /// Example: /// Example: XE
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn xref(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_XREF, None)}
  }
  /// The cross-reference code of the channel on which this track report was received, if the report came over a comms channel.
  /// Example: /// Example: FHKX
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn chXRef(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_CHXREF, None)}
  }
  /// Free-form remarks entered for the satellite.
  /// Example: /// Example: A note regarding this spacecraft
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn amplification(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_AMPLIFICATION, None)}
  }
  /// A text aplifier displaying IFF/SIF/AIS Identification modes and codes.
  /// Example: /// Example: ID Mode
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn iff(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_IFF, None)}
  }
  /// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn reinforced(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OrbitTrack_Ingest::VT_REINFORCED, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents a reduced object or group.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn reduced(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OrbitTrack_Ingest::VT_REDUCED, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hq(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OrbitTrack_Ingest::VT_HQ, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dummy(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OrbitTrack_Ingest::VT_DUMMY, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taskForce(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OrbitTrack_Ingest::VT_TASKFORCE, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn feint(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OrbitTrack_Ingest::VT_FEINT, Some(false)).unwrap()}
  }
  /// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn installation(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OrbitTrack_Ingest::VT_INSTALLATION, Some(false)).unwrap()}
  }
  /// The type of vehicle with which the device is associated.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: SPACE
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn vehType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_VEHTYPE, None)}
  }
  /// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
  /// Example: /// Example: 3668f135-fcba-4630-a43d-e7782e11d988
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn trkId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_TRKID, None)}
  }
  /// TrackSensor Collection.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trackSensors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OrbitTrack_Ingest::VT_TRACKSENSORS, None)}
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2021-02-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> OrbitTrack_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OrbitTrack_Ingest_dataMode_Enum>(OrbitTrack_Ingest::VT_DATAMODE, Some(OrbitTrack_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrbitTrack_Ingest::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for OrbitTrack_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idElset", Self::VT_IDELSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ts", Self::VT_TS, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<f64>("alt", Self::VT_ALT, false)?
     .visit_field::<f64>("rdfRF", Self::VT_RDFRF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("callSign", Self::VT_CALLSIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rptNum", Self::VT_RPTNUM, false)?
     .visit_field::<OrbitTrack_Ingest_objIdent_Enum>("objIdent", Self::VT_OBJIDENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("identAmp", Self::VT_IDENTAMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("satStatus", Self::VT_SATSTATUS, false)?
     .visit_field::<OrbitTrack_Ingest_objectType_Enum>("objectType", Self::VT_OBJECTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("countryCode", Self::VT_COUNTRYCODE, false)?
     .visit_field::<f64>("decay", Self::VT_DECAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charlieLine", Self::VT_CHARLIELINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("aouType", Self::VT_AOUTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("aouData", Self::VT_AOUDATA, false)?
     .visit_field::<f64>("spd", Self::VT_SPD, false)?
     .visit_field::<f64>("angElev", Self::VT_ANGELEV, false)?
     .visit_field::<f64>("cntnmnt", Self::VT_CNTNMNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("xref", Self::VT_XREF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("chXRef", Self::VT_CHXREF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("amplification", Self::VT_AMPLIFICATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iff", Self::VT_IFF, false)?
     .visit_field::<bool>("reinforced", Self::VT_REINFORCED, false)?
     .visit_field::<bool>("reduced", Self::VT_REDUCED, false)?
     .visit_field::<bool>("hq", Self::VT_HQ, false)?
     .visit_field::<bool>("dummy", Self::VT_DUMMY, false)?
     .visit_field::<bool>("taskForce", Self::VT_TASKFORCE, false)?
     .visit_field::<bool>("feint", Self::VT_FEINT, false)?
     .visit_field::<bool>("installation", Self::VT_INSTALLATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("vehType", Self::VT_VEHTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trkId", Self::VT_TRKID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("trackSensors", Self::VT_TRACKSENSORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<OrbitTrack_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct OrbitTrack_IngestArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo: i32,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idElset: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lat: f64,
    pub lon: f64,
    pub alt: f64,
    pub rdfRF: f64,
    pub callSign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rptNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objIdent: OrbitTrack_Ingest_objIdent_Enum,
    pub identAmp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objectType: OrbitTrack_Ingest_objectType_Enum,
    pub countryCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub decay: f64,
    pub charlieLine: Option<flatbuffers::WIPOffset<&'a str>>,
    pub aouType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub aouData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub spd: f64,
    pub angElev: f64,
    pub cntnmnt: f64,
    pub xref: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chXRef: Option<flatbuffers::WIPOffset<&'a str>>,
    pub amplification: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iff: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reinforced: bool,
    pub reduced: bool,
    pub hq: bool,
    pub dummy: bool,
    pub taskForce: bool,
    pub feint: bool,
    pub installation: bool,
    pub vehType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trkId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trackSensors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: OrbitTrack_Ingest_dataMode_Enum,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OrbitTrack_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    OrbitTrack_IngestArgs {
      id: None,
      classificationMarking: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      idElset: None,
      ts: None,
      lat: 0.0,
      lon: 0.0,
      alt: 0.0,
      rdfRF: 0.0,
      callSign: None,
      rptNum: None,
      objIdent: OrbitTrack_Ingest_objIdent_Enum::ASSUMED_FRIEND,
      identAmp: None,
      satStatus: None,
      objectType: OrbitTrack_Ingest_objectType_Enum::DEBRIS,
      countryCode: None,
      decay: 0.0,
      charlieLine: None,
      aouType: None,
      aouData: None,
      spd: 0.0,
      angElev: 0.0,
      cntnmnt: 0.0,
      xref: None,
      chXRef: None,
      amplification: None,
      iff: None,
      reinforced: false,
      reduced: false,
      hq: false,
      dummy: false,
      taskForce: false,
      feint: false,
      installation: false,
      vehType: None,
      trkId: None,
      trackSensors: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: OrbitTrack_Ingest_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}

pub struct OrbitTrack_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OrbitTrack_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(OrbitTrack_Ingest::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_idElset(&mut self, idElset: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_IDELSET, idElset);
  }
  #[inline]
  pub fn add_ts(&mut self, ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_TS, ts);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(OrbitTrack_Ingest::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(OrbitTrack_Ingest::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_alt(&mut self, alt: f64) {
    self.fbb_.push_slot::<f64>(OrbitTrack_Ingest::VT_ALT, alt, 0.0);
  }
  #[inline]
  pub fn add_rdfRF(&mut self, rdfRF: f64) {
    self.fbb_.push_slot::<f64>(OrbitTrack_Ingest::VT_RDFRF, rdfRF, 0.0);
  }
  #[inline]
  pub fn add_callSign(&mut self, callSign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_CALLSIGN, callSign);
  }
  #[inline]
  pub fn add_rptNum(&mut self, rptNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_RPTNUM, rptNum);
  }
  #[inline]
  pub fn add_objIdent(&mut self, objIdent: OrbitTrack_Ingest_objIdent_Enum) {
    self.fbb_.push_slot::<OrbitTrack_Ingest_objIdent_Enum>(OrbitTrack_Ingest::VT_OBJIDENT, objIdent, OrbitTrack_Ingest_objIdent_Enum::ASSUMED_FRIEND);
  }
  #[inline]
  pub fn add_identAmp(&mut self, identAmp: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_IDENTAMP, identAmp);
  }
  #[inline]
  pub fn add_satStatus(&mut self, satStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_SATSTATUS, satStatus);
  }
  #[inline]
  pub fn add_objectType(&mut self, objectType: OrbitTrack_Ingest_objectType_Enum) {
    self.fbb_.push_slot::<OrbitTrack_Ingest_objectType_Enum>(OrbitTrack_Ingest::VT_OBJECTTYPE, objectType, OrbitTrack_Ingest_objectType_Enum::DEBRIS);
  }
  #[inline]
  pub fn add_countryCode(&mut self, countryCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_COUNTRYCODE, countryCode);
  }
  #[inline]
  pub fn add_decay(&mut self, decay: f64) {
    self.fbb_.push_slot::<f64>(OrbitTrack_Ingest::VT_DECAY, decay, 0.0);
  }
  #[inline]
  pub fn add_charlieLine(&mut self, charlieLine: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_CHARLIELINE, charlieLine);
  }
  #[inline]
  pub fn add_aouType(&mut self, aouType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_AOUTYPE, aouType);
  }
  #[inline]
  pub fn add_aouData(&mut self, aouData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_AOUDATA, aouData);
  }
  #[inline]
  pub fn add_spd(&mut self, spd: f64) {
    self.fbb_.push_slot::<f64>(OrbitTrack_Ingest::VT_SPD, spd, 0.0);
  }
  #[inline]
  pub fn add_angElev(&mut self, angElev: f64) {
    self.fbb_.push_slot::<f64>(OrbitTrack_Ingest::VT_ANGELEV, angElev, 0.0);
  }
  #[inline]
  pub fn add_cntnmnt(&mut self, cntnmnt: f64) {
    self.fbb_.push_slot::<f64>(OrbitTrack_Ingest::VT_CNTNMNT, cntnmnt, 0.0);
  }
  #[inline]
  pub fn add_xref(&mut self, xref: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_XREF, xref);
  }
  #[inline]
  pub fn add_chXRef(&mut self, chXRef: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_CHXREF, chXRef);
  }
  #[inline]
  pub fn add_amplification(&mut self, amplification: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_AMPLIFICATION, amplification);
  }
  #[inline]
  pub fn add_iff(&mut self, iff: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_IFF, iff);
  }
  #[inline]
  pub fn add_reinforced(&mut self, reinforced: bool) {
    self.fbb_.push_slot::<bool>(OrbitTrack_Ingest::VT_REINFORCED, reinforced, false);
  }
  #[inline]
  pub fn add_reduced(&mut self, reduced: bool) {
    self.fbb_.push_slot::<bool>(OrbitTrack_Ingest::VT_REDUCED, reduced, false);
  }
  #[inline]
  pub fn add_hq(&mut self, hq: bool) {
    self.fbb_.push_slot::<bool>(OrbitTrack_Ingest::VT_HQ, hq, false);
  }
  #[inline]
  pub fn add_dummy(&mut self, dummy: bool) {
    self.fbb_.push_slot::<bool>(OrbitTrack_Ingest::VT_DUMMY, dummy, false);
  }
  #[inline]
  pub fn add_taskForce(&mut self, taskForce: bool) {
    self.fbb_.push_slot::<bool>(OrbitTrack_Ingest::VT_TASKFORCE, taskForce, false);
  }
  #[inline]
  pub fn add_feint(&mut self, feint: bool) {
    self.fbb_.push_slot::<bool>(OrbitTrack_Ingest::VT_FEINT, feint, false);
  }
  #[inline]
  pub fn add_installation(&mut self, installation: bool) {
    self.fbb_.push_slot::<bool>(OrbitTrack_Ingest::VT_INSTALLATION, installation, false);
  }
  #[inline]
  pub fn add_vehType(&mut self, vehType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_VEHTYPE, vehType);
  }
  #[inline]
  pub fn add_trkId(&mut self, trkId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_TRKID, trkId);
  }
  #[inline]
  pub fn add_trackSensors(&mut self, trackSensors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_TRACKSENSORS, trackSensors);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: OrbitTrack_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<OrbitTrack_Ingest_dataMode_Enum>(OrbitTrack_Ingest::VT_DATAMODE, dataMode, OrbitTrack_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrbitTrack_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OrbitTrack_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OrbitTrack_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OrbitTrack_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OrbitTrack_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OrbitTrack_Ingest");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("satNo", &self.satNo());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("idElset", &self.idElset());
      ds.field("ts", &self.ts());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("alt", &self.alt());
      ds.field("rdfRF", &self.rdfRF());
      ds.field("callSign", &self.callSign());
      ds.field("rptNum", &self.rptNum());
      ds.field("objIdent", &self.objIdent());
      ds.field("identAmp", &self.identAmp());
      ds.field("satStatus", &self.satStatus());
      ds.field("objectType", &self.objectType());
      ds.field("countryCode", &self.countryCode());
      ds.field("decay", &self.decay());
      ds.field("charlieLine", &self.charlieLine());
      ds.field("aouType", &self.aouType());
      ds.field("aouData", &self.aouData());
      ds.field("spd", &self.spd());
      ds.field("angElev", &self.angElev());
      ds.field("cntnmnt", &self.cntnmnt());
      ds.field("xref", &self.xref());
      ds.field("chXRef", &self.chXRef());
      ds.field("amplification", &self.amplification());
      ds.field("iff", &self.iff());
      ds.field("reinforced", &self.reinforced());
      ds.field("reduced", &self.reduced());
      ds.field("hq", &self.hq());
      ds.field("dummy", &self.dummy());
      ds.field("taskForce", &self.taskForce());
      ds.field("feint", &self.feint());
      ds.field("installation", &self.installation());
      ds.field("vehType", &self.vehType());
      ds.field("trkId", &self.trkId());
      ds.field("trackSensors", &self.trackSensors());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OrbitTrack_IngestT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idOnOrbit: Option<String>,
  pub satNo: i32,
  pub origObjectId: Option<String>,
  pub idElset: Option<String>,
  pub ts: Option<String>,
  pub lat: f64,
  pub lon: f64,
  pub alt: f64,
  pub rdfRF: f64,
  pub callSign: Option<String>,
  pub rptNum: Option<String>,
  pub objIdent: OrbitTrack_Ingest_objIdent_Enum,
  pub identAmp: Option<String>,
  pub satStatus: Option<String>,
  pub objectType: OrbitTrack_Ingest_objectType_Enum,
  pub countryCode: Option<String>,
  pub decay: f64,
  pub charlieLine: Option<String>,
  pub aouType: Option<String>,
  pub aouData: Option<Vec<String>>,
  pub spd: f64,
  pub angElev: f64,
  pub cntnmnt: f64,
  pub xref: Option<String>,
  pub chXRef: Option<String>,
  pub amplification: Option<String>,
  pub iff: Option<String>,
  pub reinforced: bool,
  pub reduced: bool,
  pub hq: bool,
  pub dummy: bool,
  pub taskForce: bool,
  pub feint: bool,
  pub installation: bool,
  pub vehType: Option<String>,
  pub trkId: Option<String>,
  pub trackSensors: Option<Vec<String>>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: OrbitTrack_Ingest_dataMode_Enum,
  pub origNetwork: Option<String>,
}
impl Default for OrbitTrack_IngestT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      idElset: None,
      ts: None,
      lat: 0.0,
      lon: 0.0,
      alt: 0.0,
      rdfRF: 0.0,
      callSign: None,
      rptNum: None,
      objIdent: OrbitTrack_Ingest_objIdent_Enum::ASSUMED_FRIEND,
      identAmp: None,
      satStatus: None,
      objectType: OrbitTrack_Ingest_objectType_Enum::DEBRIS,
      countryCode: None,
      decay: 0.0,
      charlieLine: None,
      aouType: None,
      aouData: None,
      spd: 0.0,
      angElev: 0.0,
      cntnmnt: 0.0,
      xref: None,
      chXRef: None,
      amplification: None,
      iff: None,
      reinforced: false,
      reduced: false,
      hq: false,
      dummy: false,
      taskForce: false,
      feint: false,
      installation: false,
      vehType: None,
      trkId: None,
      trackSensors: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: OrbitTrack_Ingest_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}
impl OrbitTrack_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OrbitTrack_Ingest<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo = self.satNo;
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idElset = self.idElset.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ts = self.ts.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lat = self.lat;
    let lon = self.lon;
    let alt = self.alt;
    let rdfRF = self.rdfRF;
    let callSign = self.callSign.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rptNum = self.rptNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let objIdent = self.objIdent;
    let identAmp = self.identAmp.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satStatus = self.satStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let objectType = self.objectType;
    let countryCode = self.countryCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let decay = self.decay;
    let charlieLine = self.charlieLine.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let aouType = self.aouType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let aouData = self.aouData.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let spd = self.spd;
    let angElev = self.angElev;
    let cntnmnt = self.cntnmnt;
    let xref = self.xref.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let chXRef = self.chXRef.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let amplification = self.amplification.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let iff = self.iff.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reinforced = self.reinforced;
    let reduced = self.reduced;
    let hq = self.hq;
    let dummy = self.dummy;
    let taskForce = self.taskForce;
    let feint = self.feint;
    let installation = self.installation;
    let vehType = self.vehType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trkId = self.trkId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trackSensors = self.trackSensors.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    OrbitTrack_Ingest::create(_fbb, &OrbitTrack_IngestArgs{
      id,
      classificationMarking,
      idOnOrbit,
      satNo,
      origObjectId,
      idElset,
      ts,
      lat,
      lon,
      alt,
      rdfRF,
      callSign,
      rptNum,
      objIdent,
      identAmp,
      satStatus,
      objectType,
      countryCode,
      decay,
      charlieLine,
      aouType,
      aouData,
      spd,
      angElev,
      cntnmnt,
      xref,
      chXRef,
      amplification,
      iff,
      reinforced,
      reduced,
      hq,
      dummy,
      taskForce,
      feint,
      installation,
      vehType,
      trkId,
      trackSensors,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OrbitTrack_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_orbit_track_ingest_unchecked`.
pub fn root_as_orbit_track_ingest(buf: &[u8]) -> Result<OrbitTrack_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OrbitTrack_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OrbitTrack_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_orbit_track_ingest_unchecked`.
pub fn size_prefixed_root_as_orbit_track_ingest(buf: &[u8]) -> Result<OrbitTrack_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OrbitTrack_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OrbitTrack_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_orbit_track_ingest_unchecked`.
pub fn root_as_orbit_track_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OrbitTrack_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OrbitTrack_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OrbitTrack_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_orbit_track_ingest_unchecked`.
pub fn size_prefixed_root_as_orbit_track_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OrbitTrack_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OrbitTrack_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OrbitTrack_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OrbitTrack_Ingest`.
pub unsafe fn root_as_orbit_track_ingest_unchecked(buf: &[u8]) -> OrbitTrack_Ingest {
  flatbuffers::root_unchecked::<OrbitTrack_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OrbitTrack_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OrbitTrack_Ingest`.
pub unsafe fn size_prefixed_root_as_orbit_track_ingest_unchecked(buf: &[u8]) -> OrbitTrack_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<OrbitTrack_Ingest>(buf)
}
pub const ORBIT_TRACK_INGEST_IDENTIFIER: &str = "ORBI";

#[inline]
pub fn orbit_track_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ORBIT_TRACK_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn orbit_track_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ORBIT_TRACK_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_orbit_track_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OrbitTrack_Ingest<'a>>) {
  fbb.finish(root, Some(ORBIT_TRACK_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_orbit_track_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OrbitTrack_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(ORBIT_TRACK_INGEST_IDENTIFIER));
}
