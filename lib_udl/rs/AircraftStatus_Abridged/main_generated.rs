// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AIRCRAFT_STATUS_ABRIDGED_AIR_TO_AIR_STATUS_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AIRCRAFT_STATUS_ABRIDGED_AIR_TO_AIR_STATUS_ENUM: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AIRCRAFT_STATUS_ABRIDGED_AIR_TO_AIR_STATUS_ENUM: [AircraftStatus_Abridged_airToAirStatus_Enum; 3] = [
  AircraftStatus_Abridged_airToAirStatus_Enum::OPERATIONAL,
  AircraftStatus_Abridged_airToAirStatus_Enum::NON_OPERATIONAL,
  AircraftStatus_Abridged_airToAirStatus_Enum::OFF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AircraftStatus_Abridged_airToAirStatus_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AircraftStatus_Abridged_airToAirStatus_Enum {
  /// No description available.
  pub const OPERATIONAL: Self = Self(0);
  /// No description available.
  pub const NON_OPERATIONAL: Self = Self(1);
  /// No description available.
  pub const OFF: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OPERATIONAL,
    Self::NON_OPERATIONAL,
    Self::OFF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OPERATIONAL => Some("OPERATIONAL"),
      Self::NON_OPERATIONAL => Some("NON_OPERATIONAL"),
      Self::OFF => Some("OFF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AircraftStatus_Abridged_airToAirStatus_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AircraftStatus_Abridged_airToAirStatus_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AircraftStatus_Abridged_airToAirStatus_Enum {
    type Output = AircraftStatus_Abridged_airToAirStatus_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AircraftStatus_Abridged_airToAirStatus_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AircraftStatus_Abridged_airToAirStatus_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AircraftStatus_Abridged_airToAirStatus_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AIRCRAFT_STATUS_ABRIDGED_AIR_TO_GROUND_STATUS_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AIRCRAFT_STATUS_ABRIDGED_AIR_TO_GROUND_STATUS_ENUM: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AIRCRAFT_STATUS_ABRIDGED_AIR_TO_GROUND_STATUS_ENUM: [AircraftStatus_Abridged_airToGroundStatus_Enum; 3] = [
  AircraftStatus_Abridged_airToGroundStatus_Enum::OPERATIONAL,
  AircraftStatus_Abridged_airToGroundStatus_Enum::NON_OPERATIONAL,
  AircraftStatus_Abridged_airToGroundStatus_Enum::OFF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AircraftStatus_Abridged_airToGroundStatus_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AircraftStatus_Abridged_airToGroundStatus_Enum {
  /// No description available.
  pub const OPERATIONAL: Self = Self(0);
  /// No description available.
  pub const NON_OPERATIONAL: Self = Self(1);
  /// No description available.
  pub const OFF: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OPERATIONAL,
    Self::NON_OPERATIONAL,
    Self::OFF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OPERATIONAL => Some("OPERATIONAL"),
      Self::NON_OPERATIONAL => Some("NON_OPERATIONAL"),
      Self::OFF => Some("OFF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AircraftStatus_Abridged_airToGroundStatus_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AircraftStatus_Abridged_airToGroundStatus_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AircraftStatus_Abridged_airToGroundStatus_Enum {
    type Output = AircraftStatus_Abridged_airToGroundStatus_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AircraftStatus_Abridged_airToGroundStatus_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AircraftStatus_Abridged_airToGroundStatus_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AircraftStatus_Abridged_airToGroundStatus_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AIRCRAFT_STATUS_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AIRCRAFT_STATUS_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AIRCRAFT_STATUS_ABRIDGED_DATA_MODE_ENUM: [AircraftStatus_Abridged_dataMode_Enum; 4] = [
  AircraftStatus_Abridged_dataMode_Enum::REAL,
  AircraftStatus_Abridged_dataMode_Enum::TEST,
  AircraftStatus_Abridged_dataMode_Enum::SIMULATED,
  AircraftStatus_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AircraftStatus_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AircraftStatus_Abridged_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AircraftStatus_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AircraftStatus_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AircraftStatus_Abridged_dataMode_Enum {
    type Output = AircraftStatus_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AircraftStatus_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AircraftStatus_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AircraftStatus_Abridged_dataMode_Enum {}
pub enum AircraftStatus_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Aircraft readiness and status data. Contains the dynamic data associated with the specific aircraft status, either in-flight or on-ground, including remaining fuel, mission readiness, and inventory, etc.
pub struct AircraftStatus_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AircraftStatus_Abridged<'a> {
  type Inner = AircraftStatus_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AircraftStatus_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDAIRCRAFT: flatbuffers::VOffsetT = 8;
  pub const VT_ALTAIRCRAFTID: flatbuffers::VOffsetT = 10;
  pub const VT_CURRENTSTATE: flatbuffers::VOffsetT = 12;
  pub const VT_IDAIRFIELD: flatbuffers::VOffsetT = 14;
  pub const VT_GEOLOC: flatbuffers::VOffsetT = 16;
  pub const VT_PREVIOUSICAO: flatbuffers::VOffsetT = 18;
  pub const VT_CURRENTICAO: flatbuffers::VOffsetT = 20;
  pub const VT_NEXTICAO: flatbuffers::VOffsetT = 22;
  pub const VT_FLIGHTPHASE: flatbuffers::VOffsetT = 24;
  pub const VT_TASTARTTIME: flatbuffers::VOffsetT = 26;
  pub const VT_EARLIESTTAENDTIME: flatbuffers::VOffsetT = 28;
  pub const VT_MISSIONREADINESS: flatbuffers::VOffsetT = 30;
  pub const VT_FUEL: flatbuffers::VOffsetT = 32;
  pub const VT_FUELFUNCTION: flatbuffers::VOffsetT = 34;
  pub const VT_GUNCAPABLE: flatbuffers::VOffsetT = 36;
  pub const VT_GUNRDSTYPE: flatbuffers::VOffsetT = 38;
  pub const VT_GUNRDSMIN: flatbuffers::VOffsetT = 40;
  pub const VT_GUNRDSMAX: flatbuffers::VOffsetT = 42;
  pub const VT_AIRTOAIRSTATUS: flatbuffers::VOffsetT = 44;
  pub const VT_AIRTOGROUNDSTATUS: flatbuffers::VOffsetT = 46;
  pub const VT_INVENTORY: flatbuffers::VOffsetT = 48;
  pub const VT_INVENTORYMIN: flatbuffers::VOffsetT = 50;
  pub const VT_INVENTORYMAX: flatbuffers::VOffsetT = 52;
  pub const VT_UNAVAILABLESYS: flatbuffers::VOffsetT = 54;
  pub const VT_ADDITIONALSYS: flatbuffers::VOffsetT = 56;
  pub const VT_NOTES: flatbuffers::VOffsetT = 58;
  pub const VT_MXREMARK: flatbuffers::VOffsetT = 60;
  pub const VT_MAINTSTATUS: flatbuffers::VOffsetT = 62;
  pub const VT_MAINTSTATUSDRIVER: flatbuffers::VOffsetT = 64;
  pub const VT_MAINTPRIORITY: flatbuffers::VOffsetT = 66;
  pub const VT_ALPHASTATUSCODE: flatbuffers::VOffsetT = 68;
  pub const VT_MAINTSTATUSUPDATE: flatbuffers::VOffsetT = 70;
  pub const VT_LASTINSPECTIONDATE: flatbuffers::VOffsetT = 72;
  pub const VT_MAINTPOC: flatbuffers::VOffsetT = 74;
  pub const VT_GROUNDSTATUS: flatbuffers::VOffsetT = 76;
  pub const VT_CONTAMINATIONSTATUS: flatbuffers::VOffsetT = 78;
  pub const VT_FUELSTATUS: flatbuffers::VOffsetT = 80;
  pub const VT_LASTUPDATEDBY: flatbuffers::VOffsetT = 82;
  pub const VT_TROUBLESHOOTETIC: flatbuffers::VOffsetT = 84;
  pub const VT_ETIC: flatbuffers::VOffsetT = 86;
  pub const VT_PARKLOCATION: flatbuffers::VOffsetT = 88;
  pub const VT_PARKLOCATIONSYSTEM: flatbuffers::VOffsetT = 90;
  pub const VT_IDPOI: flatbuffers::VOffsetT = 92;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 94;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 96;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 98;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 100;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 102;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 104;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 106;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AircraftStatus_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AircraftStatus_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<AircraftStatus_Abridged<'bldr>> {
    let mut builder = AircraftStatus_AbridgedBuilder::new(_fbb);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.idPOI { builder.add_idPOI(x); }
    if let Some(x) = args.parkLocationSystem { builder.add_parkLocationSystem(x); }
    if let Some(x) = args.parkLocation { builder.add_parkLocation(x); }
    if let Some(x) = args.etic { builder.add_etic(x); }
    if let Some(x) = args.troubleshootEtic { builder.add_troubleshootEtic(x); }
    if let Some(x) = args.lastUpdatedBy { builder.add_lastUpdatedBy(x); }
    if let Some(x) = args.fuelStatus { builder.add_fuelStatus(x); }
    if let Some(x) = args.contaminationStatus { builder.add_contaminationStatus(x); }
    if let Some(x) = args.groundStatus { builder.add_groundStatus(x); }
    if let Some(x) = args.maintPoc { builder.add_maintPoc(x); }
    if let Some(x) = args.lastInspectionDate { builder.add_lastInspectionDate(x); }
    if let Some(x) = args.maintStatusUpdate { builder.add_maintStatusUpdate(x); }
    if let Some(x) = args.alphaStatusCode { builder.add_alphaStatusCode(x); }
    if let Some(x) = args.maintPriority { builder.add_maintPriority(x); }
    if let Some(x) = args.maintStatusDriver { builder.add_maintStatusDriver(x); }
    if let Some(x) = args.maintStatus { builder.add_maintStatus(x); }
    if let Some(x) = args.mxRemark { builder.add_mxRemark(x); }
    if let Some(x) = args.notes { builder.add_notes(x); }
    if let Some(x) = args.additionalSys { builder.add_additionalSys(x); }
    if let Some(x) = args.unavailableSys { builder.add_unavailableSys(x); }
    if let Some(x) = args.inventoryMax { builder.add_inventoryMax(x); }
    if let Some(x) = args.inventoryMin { builder.add_inventoryMin(x); }
    if let Some(x) = args.inventory { builder.add_inventory(x); }
    builder.add_gunRdsMax(args.gunRdsMax);
    builder.add_gunRdsMin(args.gunRdsMin);
    if let Some(x) = args.gunRdsType { builder.add_gunRdsType(x); }
    if let Some(x) = args.fuelFunction { builder.add_fuelFunction(x); }
    builder.add_fuel(args.fuel);
    if let Some(x) = args.missionReadiness { builder.add_missionReadiness(x); }
    if let Some(x) = args.earliestTAEndTime { builder.add_earliestTAEndTime(x); }
    if let Some(x) = args.taStartTime { builder.add_taStartTime(x); }
    if let Some(x) = args.flightPhase { builder.add_flightPhase(x); }
    if let Some(x) = args.nextICAO { builder.add_nextICAO(x); }
    if let Some(x) = args.currentICAO { builder.add_currentICAO(x); }
    if let Some(x) = args.previousICAO { builder.add_previousICAO(x); }
    if let Some(x) = args.geoLoc { builder.add_geoLoc(x); }
    if let Some(x) = args.idAirfield { builder.add_idAirfield(x); }
    if let Some(x) = args.currentState { builder.add_currentState(x); }
    if let Some(x) = args.altAircraftId { builder.add_altAircraftId(x); }
    if let Some(x) = args.idAircraft { builder.add_idAircraft(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_airToGroundStatus(args.airToGroundStatus);
    builder.add_airToAirStatus(args.airToAirStatus);
    builder.add_gunCapable(args.gunCapable);
    builder.finish()
  }

  pub fn unpack(&self) -> AircraftStatus_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idAircraft = self.idAircraft().map(|x| {
      x.to_string()
    });
    let altAircraftId = self.altAircraftId().map(|x| {
      x.to_string()
    });
    let currentState = self.currentState().map(|x| {
      x.to_string()
    });
    let idAirfield = self.idAirfield().map(|x| {
      x.to_string()
    });
    let geoLoc = self.geoLoc().map(|x| {
      x.to_string()
    });
    let previousICAO = self.previousICAO().map(|x| {
      x.to_string()
    });
    let currentICAO = self.currentICAO().map(|x| {
      x.to_string()
    });
    let nextICAO = self.nextICAO().map(|x| {
      x.to_string()
    });
    let flightPhase = self.flightPhase().map(|x| {
      x.to_string()
    });
    let taStartTime = self.taStartTime().map(|x| {
      x.to_string()
    });
    let earliestTAEndTime = self.earliestTAEndTime().map(|x| {
      x.to_string()
    });
    let missionReadiness = self.missionReadiness().map(|x| {
      x.to_string()
    });
    let fuel = self.fuel();
    let fuelFunction = self.fuelFunction().map(|x| {
      x.to_string()
    });
    let gunCapable = self.gunCapable();
    let gunRdsType = self.gunRdsType().map(|x| {
      x.to_string()
    });
    let gunRdsMin = self.gunRdsMin();
    let gunRdsMax = self.gunRdsMax();
    let airToAirStatus = self.airToAirStatus();
    let airToGroundStatus = self.airToGroundStatus();
    let inventory = self.inventory().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let inventoryMin = self.inventoryMin().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let inventoryMax = self.inventoryMax().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let unavailableSys = self.unavailableSys().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let additionalSys = self.additionalSys().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let notes = self.notes().map(|x| {
      x.to_string()
    });
    let mxRemark = self.mxRemark().map(|x| {
      x.to_string()
    });
    let maintStatus = self.maintStatus().map(|x| {
      x.to_string()
    });
    let maintStatusDriver = self.maintStatusDriver().map(|x| {
      x.to_string()
    });
    let maintPriority = self.maintPriority().map(|x| {
      x.to_string()
    });
    let alphaStatusCode = self.alphaStatusCode().map(|x| {
      x.to_string()
    });
    let maintStatusUpdate = self.maintStatusUpdate().map(|x| {
      x.to_string()
    });
    let lastInspectionDate = self.lastInspectionDate().map(|x| {
      x.to_string()
    });
    let maintPoc = self.maintPoc().map(|x| {
      x.to_string()
    });
    let groundStatus = self.groundStatus().map(|x| {
      x.to_string()
    });
    let contaminationStatus = self.contaminationStatus().map(|x| {
      x.to_string()
    });
    let fuelStatus = self.fuelStatus().map(|x| {
      x.to_string()
    });
    let lastUpdatedBy = self.lastUpdatedBy().map(|x| {
      x.to_string()
    });
    let troubleshootEtic = self.troubleshootEtic().map(|x| {
      x.to_string()
    });
    let etic = self.etic().map(|x| {
      x.to_string()
    });
    let parkLocation = self.parkLocation().map(|x| {
      x.to_string()
    });
    let parkLocationSystem = self.parkLocationSystem().map(|x| {
      x.to_string()
    });
    let idPOI = self.idPOI().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    AircraftStatus_AbridgedT {
      id,
      classificationMarking,
      idAircraft,
      altAircraftId,
      currentState,
      idAirfield,
      geoLoc,
      previousICAO,
      currentICAO,
      nextICAO,
      flightPhase,
      taStartTime,
      earliestTAEndTime,
      missionReadiness,
      fuel,
      fuelFunction,
      gunCapable,
      gunRdsType,
      gunRdsMin,
      gunRdsMax,
      airToAirStatus,
      airToGroundStatus,
      inventory,
      inventoryMin,
      inventoryMax,
      unavailableSys,
      additionalSys,
      notes,
      mxRemark,
      maintStatus,
      maintStatusDriver,
      maintPriority,
      alphaStatusCode,
      maintStatusUpdate,
      lastInspectionDate,
      maintPoc,
      groundStatus,
      contaminationStatus,
      fuelStatus,
      lastUpdatedBy,
      troubleshootEtic,
      etic,
      parkLocation,
      parkLocationSystem,
      idPOI,
      createdAt,
      createdBy,
      sourceDL,
      source,
      origin,
      dataMode,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: 0167f577-e06c-358e-85aa-0a07a730bdd0
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the aircraft.
  /// Example: /// Example: 29232269-e4c2-45c9-aa21-039a33209340
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn idAircraft(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_IDAIRCRAFT, None)}
  }
  /// Alternate Aircraft Identifier provided by source.
  /// Example: /// Example: ORIG-AIRCRAFT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn altAircraftId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_ALTAIRCRAFTID, None)}
  }
  /// The current readiness state of the aircraft (e.g. AIRBORNE, ALERTCOCKED, AVAILABLE, BATTLESTATION, RUNWAY ALERT, SUITUP).
  /// Example: /// Example: AVAILABLE
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn currentState(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_CURRENTSTATE, None)}
  }
  /// If not airborne, the unique identifier of the installation currently hosting the aircraft.
  /// Example: /// Example: b89430e3-97d9-408c-9c89-fd3840c4b84d
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idAirfield(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_IDAIRFIELD, None)}
  }
  /// US Air Force geographic location code of the airfield where the aircraft is located.
  /// Example: /// Example: AJJY
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn geoLoc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_GEOLOC, None)}
  }
  /// The International Civil Aviation Organization (ICAO) code at which this aircraft was previously located.
  /// Example: /// Example: EGLL
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn previousICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_PREVIOUSICAO, None)}
  }
  /// The International Civil Aviation Organization (ICAO) code at which this aircraft is currently located or has most recently departed, if airborne.
  /// Example: /// Example: KCHS
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn currentICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_CURRENTICAO, None)}
  }
  /// The International Civil Aviation Organization (ICAO) code of the next destination of this aircraft.
  /// Example: /// Example: PHNL
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn nextICAO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_NEXTICAO, None)}
  }
  /// Current flight phase (e.g. AIR REFUELING, GROUND, LANDING, etc.) of the aircraft.
  /// Example: /// Example: Landing
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn flightPhase(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_FLIGHTPHASE, None)}
  }
  /// The turnaround start time, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taStartTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_TASTARTTIME, None)}
  }
  /// The earliest time that turnaround of the aircraft may complete, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn earliestTAEndTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_EARLIESTTAENDTIME, None)}
  }
  /// The Operational Capability of the reported aircraft (ABLE, LOFUEL, UNABLE).
  /// Example: /// Example: ABLE
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn missionReadiness(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_MISSIONREADINESS, None)}
  }
  /// The mass of fuel remaining on the aircraft, in kilograms.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn fuel(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AircraftStatus_Abridged::VT_FUEL, Some(0)).unwrap()}
  }
  /// Used in conjunction with the fuel field to indicate either burnable or offload fuel.
  /// Example: /// Example: Burn
  /// Constraints: Minimum length = 0, Maximum length = 8
  #[inline]
  pub fn fuelFunction(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_FUELFUNCTION, None)}
  }
  /// Flag indicating that the aircraft is capable of making at least one gun pass.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gunCapable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AircraftStatus_Abridged::VT_GUNCAPABLE, Some(false)).unwrap()}
  }
  /// The type of gun rounds available (e.g. 7.62 MM, 20 MM, 25 MM, etc.).
  /// Example: /// Example: 7.62 MM
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn gunRdsType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_GUNRDSTYPE, None)}
  }
  /// The lower bound of the estimated number of gun rounds available.
  /// Example: /// Example: 150
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gunRdsMin(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AircraftStatus_Abridged::VT_GUNRDSMIN, Some(0)).unwrap()}
  }
  /// The upper bound of the estimated number of gun rounds available.
  /// Example: /// Example: 550
  /// Constraints: No constraints specified.
  #[inline]
  pub fn gunRdsMax(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AircraftStatus_Abridged::VT_GUNRDSMAX, Some(0)).unwrap()}
  }
  /// The status of the air-to-air weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF).
  /// Example: /// Example: OPERATIONAL
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn airToAirStatus(&self) -> AircraftStatus_Abridged_airToAirStatus_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AircraftStatus_Abridged_airToAirStatus_Enum>(AircraftStatus_Abridged::VT_AIRTOAIRSTATUS, Some(AircraftStatus_Abridged_airToAirStatus_Enum::OPERATIONAL)).unwrap()}
  }
  /// The status of the air-to-ground weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF).
  /// Example: /// Example: OPERATIONAL
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn airToGroundStatus(&self) -> AircraftStatus_Abridged_airToGroundStatus_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AircraftStatus_Abridged_airToGroundStatus_Enum>(AircraftStatus_Abridged::VT_AIRTOGROUNDSTATUS, Some(AircraftStatus_Abridged_airToGroundStatus_Enum::OPERATIONAL)).unwrap()}
  }
  /// Array of inventory item(s) for which estimate(s) are available (e.g. AIM-9 SIDEWINDER, AIM-120 AMRAAM, AIM-92 STINGER, CHAFF DECOY, FLARE TP 400, etc.).  Intended as, but not constrained to, MIL-STD-6016 environment dependent specific/store type designations.  This array must be the same length as inventoryMin and inventoryMax.
  /// Example: /// Example: ['AIM-9 SIDEWINDER', 'AIM-120 AMRAAM']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn inventory(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AircraftStatus_Abridged::VT_INVENTORY, None)}
  }
  /// Array of the lower bound quantity for each of the inventory items. The values in this array must correspond to position index in the inventory array. This array must be the same length as inventory and inventoryMax.
  /// Example: /// Example: [1, 2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn inventoryMin(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AircraftStatus_Abridged::VT_INVENTORYMIN, None)}
  }
  /// Array of the upper bound quantity for each of the inventory items. The values in this array must correspond to position index in the inventory array. This array must be the same length as inventory and inventoryMin.
  /// Example: /// Example: [2, 2]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn inventoryMax(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AircraftStatus_Abridged::VT_INVENTORYMAX, None)}
  }
  /// List of unavailable systems that would normally be on this aircraft.
  /// Example: /// Example: ['CMDS', 'AOC']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn unavailableSys(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AircraftStatus_Abridged::VT_UNAVAILABLESYS, None)}
  }
  /// List of additional operational systems on this aircraft beyond what is normally available.
  /// Example: /// Example: ['ATOMS', 'TUDL', 'BLOS1']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn additionalSys(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AircraftStatus_Abridged::VT_ADDITIONALSYS, None)}
  }
  /// Optional notes/comments concerning this aircraft status.
  /// Example: /// Example: Some notes for aircraft A
  /// Constraints: Minimum length = 0, Maximum length = 1024
  #[inline]
  pub fn notes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_NOTES, None)}
  }
  /// Maintenance pacing remarks assocociated with this aircraft.
  /// Example: /// Example: COM2 INOP
  /// Constraints: Minimum length = 0, Maximum length = 1024
  #[inline]
  pub fn mxRemark(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_MXREMARK, None)}
  }
  /// The maintenance status of the aircraft.
  /// Example: /// Example: maintenance status
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn maintStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_MAINTSTATUS, None)}
  }
  /// Indicates the maintenance discrepancy that drives the current maintenance status.
  /// Example: /// Example: SCREW STUCK IN LEFT NLG TIRE
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn maintStatusDriver(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_MAINTSTATUSDRIVER, None)}
  }
  /// Indicates the priority of the maintenance effort.
  /// Example: /// Example: 1
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn maintPriority(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_MAINTPRIORITY, None)}
  }
  /// Aircraft alpha status code that indicates the aircraft maintenance status estimated by the pilot.
  /// Example: /// Example: A2
  /// Constraints: Minimum length = 0, Maximum length = 2
  #[inline]
  pub fn alphaStatusCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_ALPHASTATUSCODE, None)}
  }
  /// The time of the last maintenance status update, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maintStatusUpdate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_MAINTSTATUSUPDATE, None)}
  }
  /// Date when the military aircraft inspection was last performed, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-09-09T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lastInspectionDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_LASTINSPECTIONDATE, None)}
  }
  /// Military aircraft maintenance point of contact for this aircraft.
  /// Example: /// Example: PSUP NIGHT SHIFT 800-555-4412
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn maintPoc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_MAINTPOC, None)}
  }
  /// The ground status of the aircraft (e.g. ALERT, CREW READY, ENGINE START, HANGAR, etc.).
  /// Example: /// Example: ALERT
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn groundStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_GROUNDSTATUS, None)}
  }
  /// The contamination status of the aircraft (e.g. CLEAR, CONTAMINATED, DECONTAMINATED, UNKNOWN, etc.).
  /// Example: /// Example: CLEAR
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn contaminationStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_CONTAMINATIONSTATUS, None)}
  }
  /// The state of the aircraft fuel status (e.g. DELIVERED, DUMPED, EMPTY, FULL, OTHER, REQUESTED, etc.).
  /// Example: /// Example: DELIVERED
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn fuelStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_FUELSTATUS, None)}
  }
  /// The name or ID of the external user that updated this status.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn lastUpdatedBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_LASTUPDATEDBY, None)}
  }
  /// Estimated Time for Completion (ETIC) of an aircraft issue, in ISO 8601 UTC format with millisecond precision. This is the estimated time when the course of action to resolve the issue will be determined.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn troubleshootEtic(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_TROUBLESHOOTETIC, None)}
  }
  /// The Expected Time in Commission (ETIC) for this aircraft, in ISO 8601 UTC format with millisecond precision. This is the estimated time when the issue will be resolved.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn etic(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_ETIC, None)}
  }
  /// The parking location of this aircraft.
  /// Example: /// Example: B1
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn parkLocation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_PARKLOCATION, None)}
  }
  /// The system that designated the parking location (e.g. EMOC, GDSS, PEX, etc.).
  /// Example: /// Example: GDSS
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn parkLocationSystem(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_PARKLOCATIONSYSTEM, None)}
  }
  /// Unique identifier of the Point of Interest (POI) record related to this aircraft status. This will generally represent the location of an aircraft on the ground.
  /// Example: /// Example: 0e52f081-a2e3-4b73-b822-88b882232691
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idPOI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_IDPOI, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_CREATEDBY, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_SOURCEDL, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> AircraftStatus_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AircraftStatus_Abridged_dataMode_Enum>(AircraftStatus_Abridged::VT_DATAMODE, Some(AircraftStatus_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AircraftStatus_Abridged::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for AircraftStatus_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idAircraft", Self::VT_IDAIRCRAFT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altAircraftId", Self::VT_ALTAIRCRAFTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentState", Self::VT_CURRENTSTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idAirfield", Self::VT_IDAIRFIELD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("geoLoc", Self::VT_GEOLOC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("previousICAO", Self::VT_PREVIOUSICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentICAO", Self::VT_CURRENTICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nextICAO", Self::VT_NEXTICAO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("flightPhase", Self::VT_FLIGHTPHASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taStartTime", Self::VT_TASTARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("earliestTAEndTime", Self::VT_EARLIESTTAENDTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("missionReadiness", Self::VT_MISSIONREADINESS, false)?
     .visit_field::<i32>("fuel", Self::VT_FUEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fuelFunction", Self::VT_FUELFUNCTION, false)?
     .visit_field::<bool>("gunCapable", Self::VT_GUNCAPABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("gunRdsType", Self::VT_GUNRDSTYPE, false)?
     .visit_field::<i32>("gunRdsMin", Self::VT_GUNRDSMIN, false)?
     .visit_field::<i32>("gunRdsMax", Self::VT_GUNRDSMAX, false)?
     .visit_field::<AircraftStatus_Abridged_airToAirStatus_Enum>("airToAirStatus", Self::VT_AIRTOAIRSTATUS, false)?
     .visit_field::<AircraftStatus_Abridged_airToGroundStatus_Enum>("airToGroundStatus", Self::VT_AIRTOGROUNDSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("inventory", Self::VT_INVENTORY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("inventoryMin", Self::VT_INVENTORYMIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("inventoryMax", Self::VT_INVENTORYMAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("unavailableSys", Self::VT_UNAVAILABLESYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("additionalSys", Self::VT_ADDITIONALSYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("notes", Self::VT_NOTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mxRemark", Self::VT_MXREMARK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("maintStatus", Self::VT_MAINTSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("maintStatusDriver", Self::VT_MAINTSTATUSDRIVER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("maintPriority", Self::VT_MAINTPRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alphaStatusCode", Self::VT_ALPHASTATUSCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("maintStatusUpdate", Self::VT_MAINTSTATUSUPDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastInspectionDate", Self::VT_LASTINSPECTIONDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("maintPoc", Self::VT_MAINTPOC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groundStatus", Self::VT_GROUNDSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("contaminationStatus", Self::VT_CONTAMINATIONSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fuelStatus", Self::VT_FUELSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastUpdatedBy", Self::VT_LASTUPDATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("troubleshootEtic", Self::VT_TROUBLESHOOTETIC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("etic", Self::VT_ETIC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("parkLocation", Self::VT_PARKLOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("parkLocationSystem", Self::VT_PARKLOCATIONSYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idPOI", Self::VT_IDPOI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<AircraftStatus_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct AircraftStatus_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idAircraft: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altAircraftId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentState: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idAirfield: Option<flatbuffers::WIPOffset<&'a str>>,
    pub geoLoc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub previousICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nextICAO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub flightPhase: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taStartTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub earliestTAEndTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub missionReadiness: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fuel: i32,
    pub fuelFunction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gunCapable: bool,
    pub gunRdsType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gunRdsMin: i32,
    pub gunRdsMax: i32,
    pub airToAirStatus: AircraftStatus_Abridged_airToAirStatus_Enum,
    pub airToGroundStatus: AircraftStatus_Abridged_airToGroundStatus_Enum,
    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub inventoryMin: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub inventoryMax: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub unavailableSys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub additionalSys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub notes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mxRemark: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maintStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maintStatusDriver: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maintPriority: Option<flatbuffers::WIPOffset<&'a str>>,
    pub alphaStatusCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maintStatusUpdate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lastInspectionDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maintPoc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groundStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub contaminationStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fuelStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lastUpdatedBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub troubleshootEtic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub etic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub parkLocation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub parkLocationSystem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idPOI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: AircraftStatus_Abridged_dataMode_Enum,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AircraftStatus_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    AircraftStatus_AbridgedArgs {
      id: None,
      classificationMarking: None,
      idAircraft: None,
      altAircraftId: None,
      currentState: None,
      idAirfield: None,
      geoLoc: None,
      previousICAO: None,
      currentICAO: None,
      nextICAO: None,
      flightPhase: None,
      taStartTime: None,
      earliestTAEndTime: None,
      missionReadiness: None,
      fuel: 0,
      fuelFunction: None,
      gunCapable: false,
      gunRdsType: None,
      gunRdsMin: 0,
      gunRdsMax: 0,
      airToAirStatus: AircraftStatus_Abridged_airToAirStatus_Enum::OPERATIONAL,
      airToGroundStatus: AircraftStatus_Abridged_airToGroundStatus_Enum::OPERATIONAL,
      inventory: None,
      inventoryMin: None,
      inventoryMax: None,
      unavailableSys: None,
      additionalSys: None,
      notes: None,
      mxRemark: None,
      maintStatus: None,
      maintStatusDriver: None,
      maintPriority: None,
      alphaStatusCode: None,
      maintStatusUpdate: None,
      lastInspectionDate: None,
      maintPoc: None,
      groundStatus: None,
      contaminationStatus: None,
      fuelStatus: None,
      lastUpdatedBy: None,
      troubleshootEtic: None,
      etic: None,
      parkLocation: None,
      parkLocationSystem: None,
      idPOI: None,
      createdAt: None,
      createdBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      dataMode: AircraftStatus_Abridged_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}

pub struct AircraftStatus_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AircraftStatus_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idAircraft(&mut self, idAircraft: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_IDAIRCRAFT, idAircraft);
  }
  #[inline]
  pub fn add_altAircraftId(&mut self, altAircraftId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_ALTAIRCRAFTID, altAircraftId);
  }
  #[inline]
  pub fn add_currentState(&mut self, currentState: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_CURRENTSTATE, currentState);
  }
  #[inline]
  pub fn add_idAirfield(&mut self, idAirfield: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_IDAIRFIELD, idAirfield);
  }
  #[inline]
  pub fn add_geoLoc(&mut self, geoLoc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_GEOLOC, geoLoc);
  }
  #[inline]
  pub fn add_previousICAO(&mut self, previousICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_PREVIOUSICAO, previousICAO);
  }
  #[inline]
  pub fn add_currentICAO(&mut self, currentICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_CURRENTICAO, currentICAO);
  }
  #[inline]
  pub fn add_nextICAO(&mut self, nextICAO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_NEXTICAO, nextICAO);
  }
  #[inline]
  pub fn add_flightPhase(&mut self, flightPhase: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_FLIGHTPHASE, flightPhase);
  }
  #[inline]
  pub fn add_taStartTime(&mut self, taStartTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_TASTARTTIME, taStartTime);
  }
  #[inline]
  pub fn add_earliestTAEndTime(&mut self, earliestTAEndTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_EARLIESTTAENDTIME, earliestTAEndTime);
  }
  #[inline]
  pub fn add_missionReadiness(&mut self, missionReadiness: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_MISSIONREADINESS, missionReadiness);
  }
  #[inline]
  pub fn add_fuel(&mut self, fuel: i32) {
    self.fbb_.push_slot::<i32>(AircraftStatus_Abridged::VT_FUEL, fuel, 0);
  }
  #[inline]
  pub fn add_fuelFunction(&mut self, fuelFunction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_FUELFUNCTION, fuelFunction);
  }
  #[inline]
  pub fn add_gunCapable(&mut self, gunCapable: bool) {
    self.fbb_.push_slot::<bool>(AircraftStatus_Abridged::VT_GUNCAPABLE, gunCapable, false);
  }
  #[inline]
  pub fn add_gunRdsType(&mut self, gunRdsType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_GUNRDSTYPE, gunRdsType);
  }
  #[inline]
  pub fn add_gunRdsMin(&mut self, gunRdsMin: i32) {
    self.fbb_.push_slot::<i32>(AircraftStatus_Abridged::VT_GUNRDSMIN, gunRdsMin, 0);
  }
  #[inline]
  pub fn add_gunRdsMax(&mut self, gunRdsMax: i32) {
    self.fbb_.push_slot::<i32>(AircraftStatus_Abridged::VT_GUNRDSMAX, gunRdsMax, 0);
  }
  #[inline]
  pub fn add_airToAirStatus(&mut self, airToAirStatus: AircraftStatus_Abridged_airToAirStatus_Enum) {
    self.fbb_.push_slot::<AircraftStatus_Abridged_airToAirStatus_Enum>(AircraftStatus_Abridged::VT_AIRTOAIRSTATUS, airToAirStatus, AircraftStatus_Abridged_airToAirStatus_Enum::OPERATIONAL);
  }
  #[inline]
  pub fn add_airToGroundStatus(&mut self, airToGroundStatus: AircraftStatus_Abridged_airToGroundStatus_Enum) {
    self.fbb_.push_slot::<AircraftStatus_Abridged_airToGroundStatus_Enum>(AircraftStatus_Abridged::VT_AIRTOGROUNDSTATUS, airToGroundStatus, AircraftStatus_Abridged_airToGroundStatus_Enum::OPERATIONAL);
  }
  #[inline]
  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_INVENTORY, inventory);
  }
  #[inline]
  pub fn add_inventoryMin(&mut self, inventoryMin: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_INVENTORYMIN, inventoryMin);
  }
  #[inline]
  pub fn add_inventoryMax(&mut self, inventoryMax: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_INVENTORYMAX, inventoryMax);
  }
  #[inline]
  pub fn add_unavailableSys(&mut self, unavailableSys: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_UNAVAILABLESYS, unavailableSys);
  }
  #[inline]
  pub fn add_additionalSys(&mut self, additionalSys: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_ADDITIONALSYS, additionalSys);
  }
  #[inline]
  pub fn add_notes(&mut self, notes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_NOTES, notes);
  }
  #[inline]
  pub fn add_mxRemark(&mut self, mxRemark: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_MXREMARK, mxRemark);
  }
  #[inline]
  pub fn add_maintStatus(&mut self, maintStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_MAINTSTATUS, maintStatus);
  }
  #[inline]
  pub fn add_maintStatusDriver(&mut self, maintStatusDriver: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_MAINTSTATUSDRIVER, maintStatusDriver);
  }
  #[inline]
  pub fn add_maintPriority(&mut self, maintPriority: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_MAINTPRIORITY, maintPriority);
  }
  #[inline]
  pub fn add_alphaStatusCode(&mut self, alphaStatusCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_ALPHASTATUSCODE, alphaStatusCode);
  }
  #[inline]
  pub fn add_maintStatusUpdate(&mut self, maintStatusUpdate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_MAINTSTATUSUPDATE, maintStatusUpdate);
  }
  #[inline]
  pub fn add_lastInspectionDate(&mut self, lastInspectionDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_LASTINSPECTIONDATE, lastInspectionDate);
  }
  #[inline]
  pub fn add_maintPoc(&mut self, maintPoc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_MAINTPOC, maintPoc);
  }
  #[inline]
  pub fn add_groundStatus(&mut self, groundStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_GROUNDSTATUS, groundStatus);
  }
  #[inline]
  pub fn add_contaminationStatus(&mut self, contaminationStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_CONTAMINATIONSTATUS, contaminationStatus);
  }
  #[inline]
  pub fn add_fuelStatus(&mut self, fuelStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_FUELSTATUS, fuelStatus);
  }
  #[inline]
  pub fn add_lastUpdatedBy(&mut self, lastUpdatedBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_LASTUPDATEDBY, lastUpdatedBy);
  }
  #[inline]
  pub fn add_troubleshootEtic(&mut self, troubleshootEtic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_TROUBLESHOOTETIC, troubleshootEtic);
  }
  #[inline]
  pub fn add_etic(&mut self, etic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_ETIC, etic);
  }
  #[inline]
  pub fn add_parkLocation(&mut self, parkLocation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_PARKLOCATION, parkLocation);
  }
  #[inline]
  pub fn add_parkLocationSystem(&mut self, parkLocationSystem: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_PARKLOCATIONSYSTEM, parkLocationSystem);
  }
  #[inline]
  pub fn add_idPOI(&mut self, idPOI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_IDPOI, idPOI);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: AircraftStatus_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<AircraftStatus_Abridged_dataMode_Enum>(AircraftStatus_Abridged::VT_DATAMODE, dataMode, AircraftStatus_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AircraftStatus_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AircraftStatus_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AircraftStatus_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AircraftStatus_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AircraftStatus_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AircraftStatus_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idAircraft", &self.idAircraft());
      ds.field("altAircraftId", &self.altAircraftId());
      ds.field("currentState", &self.currentState());
      ds.field("idAirfield", &self.idAirfield());
      ds.field("geoLoc", &self.geoLoc());
      ds.field("previousICAO", &self.previousICAO());
      ds.field("currentICAO", &self.currentICAO());
      ds.field("nextICAO", &self.nextICAO());
      ds.field("flightPhase", &self.flightPhase());
      ds.field("taStartTime", &self.taStartTime());
      ds.field("earliestTAEndTime", &self.earliestTAEndTime());
      ds.field("missionReadiness", &self.missionReadiness());
      ds.field("fuel", &self.fuel());
      ds.field("fuelFunction", &self.fuelFunction());
      ds.field("gunCapable", &self.gunCapable());
      ds.field("gunRdsType", &self.gunRdsType());
      ds.field("gunRdsMin", &self.gunRdsMin());
      ds.field("gunRdsMax", &self.gunRdsMax());
      ds.field("airToAirStatus", &self.airToAirStatus());
      ds.field("airToGroundStatus", &self.airToGroundStatus());
      ds.field("inventory", &self.inventory());
      ds.field("inventoryMin", &self.inventoryMin());
      ds.field("inventoryMax", &self.inventoryMax());
      ds.field("unavailableSys", &self.unavailableSys());
      ds.field("additionalSys", &self.additionalSys());
      ds.field("notes", &self.notes());
      ds.field("mxRemark", &self.mxRemark());
      ds.field("maintStatus", &self.maintStatus());
      ds.field("maintStatusDriver", &self.maintStatusDriver());
      ds.field("maintPriority", &self.maintPriority());
      ds.field("alphaStatusCode", &self.alphaStatusCode());
      ds.field("maintStatusUpdate", &self.maintStatusUpdate());
      ds.field("lastInspectionDate", &self.lastInspectionDate());
      ds.field("maintPoc", &self.maintPoc());
      ds.field("groundStatus", &self.groundStatus());
      ds.field("contaminationStatus", &self.contaminationStatus());
      ds.field("fuelStatus", &self.fuelStatus());
      ds.field("lastUpdatedBy", &self.lastUpdatedBy());
      ds.field("troubleshootEtic", &self.troubleshootEtic());
      ds.field("etic", &self.etic());
      ds.field("parkLocation", &self.parkLocation());
      ds.field("parkLocationSystem", &self.parkLocationSystem());
      ds.field("idPOI", &self.idPOI());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("sourceDL", &self.sourceDL());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AircraftStatus_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idAircraft: Option<String>,
  pub altAircraftId: Option<String>,
  pub currentState: Option<String>,
  pub idAirfield: Option<String>,
  pub geoLoc: Option<String>,
  pub previousICAO: Option<String>,
  pub currentICAO: Option<String>,
  pub nextICAO: Option<String>,
  pub flightPhase: Option<String>,
  pub taStartTime: Option<String>,
  pub earliestTAEndTime: Option<String>,
  pub missionReadiness: Option<String>,
  pub fuel: i32,
  pub fuelFunction: Option<String>,
  pub gunCapable: bool,
  pub gunRdsType: Option<String>,
  pub gunRdsMin: i32,
  pub gunRdsMax: i32,
  pub airToAirStatus: AircraftStatus_Abridged_airToAirStatus_Enum,
  pub airToGroundStatus: AircraftStatus_Abridged_airToGroundStatus_Enum,
  pub inventory: Option<Vec<String>>,
  pub inventoryMin: Option<Vec<String>>,
  pub inventoryMax: Option<Vec<String>>,
  pub unavailableSys: Option<Vec<String>>,
  pub additionalSys: Option<Vec<String>>,
  pub notes: Option<String>,
  pub mxRemark: Option<String>,
  pub maintStatus: Option<String>,
  pub maintStatusDriver: Option<String>,
  pub maintPriority: Option<String>,
  pub alphaStatusCode: Option<String>,
  pub maintStatusUpdate: Option<String>,
  pub lastInspectionDate: Option<String>,
  pub maintPoc: Option<String>,
  pub groundStatus: Option<String>,
  pub contaminationStatus: Option<String>,
  pub fuelStatus: Option<String>,
  pub lastUpdatedBy: Option<String>,
  pub troubleshootEtic: Option<String>,
  pub etic: Option<String>,
  pub parkLocation: Option<String>,
  pub parkLocationSystem: Option<String>,
  pub idPOI: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub sourceDL: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: AircraftStatus_Abridged_dataMode_Enum,
  pub origNetwork: Option<String>,
}
impl Default for AircraftStatus_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idAircraft: None,
      altAircraftId: None,
      currentState: None,
      idAirfield: None,
      geoLoc: None,
      previousICAO: None,
      currentICAO: None,
      nextICAO: None,
      flightPhase: None,
      taStartTime: None,
      earliestTAEndTime: None,
      missionReadiness: None,
      fuel: 0,
      fuelFunction: None,
      gunCapable: false,
      gunRdsType: None,
      gunRdsMin: 0,
      gunRdsMax: 0,
      airToAirStatus: AircraftStatus_Abridged_airToAirStatus_Enum::OPERATIONAL,
      airToGroundStatus: AircraftStatus_Abridged_airToGroundStatus_Enum::OPERATIONAL,
      inventory: None,
      inventoryMin: None,
      inventoryMax: None,
      unavailableSys: None,
      additionalSys: None,
      notes: None,
      mxRemark: None,
      maintStatus: None,
      maintStatusDriver: None,
      maintPriority: None,
      alphaStatusCode: None,
      maintStatusUpdate: None,
      lastInspectionDate: None,
      maintPoc: None,
      groundStatus: None,
      contaminationStatus: None,
      fuelStatus: None,
      lastUpdatedBy: None,
      troubleshootEtic: None,
      etic: None,
      parkLocation: None,
      parkLocationSystem: None,
      idPOI: None,
      createdAt: None,
      createdBy: None,
      sourceDL: None,
      source: None,
      origin: None,
      dataMode: AircraftStatus_Abridged_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}
impl AircraftStatus_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AircraftStatus_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idAircraft = self.idAircraft.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altAircraftId = self.altAircraftId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let currentState = self.currentState.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idAirfield = self.idAirfield.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let geoLoc = self.geoLoc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let previousICAO = self.previousICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let currentICAO = self.currentICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let nextICAO = self.nextICAO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let flightPhase = self.flightPhase.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taStartTime = self.taStartTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let earliestTAEndTime = self.earliestTAEndTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let missionReadiness = self.missionReadiness.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let fuel = self.fuel;
    let fuelFunction = self.fuelFunction.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let gunCapable = self.gunCapable;
    let gunRdsType = self.gunRdsType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let gunRdsMin = self.gunRdsMin;
    let gunRdsMax = self.gunRdsMax;
    let airToAirStatus = self.airToAirStatus;
    let airToGroundStatus = self.airToGroundStatus;
    let inventory = self.inventory.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let inventoryMin = self.inventoryMin.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let inventoryMax = self.inventoryMax.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let unavailableSys = self.unavailableSys.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let additionalSys = self.additionalSys.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let notes = self.notes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mxRemark = self.mxRemark.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let maintStatus = self.maintStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let maintStatusDriver = self.maintStatusDriver.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let maintPriority = self.maintPriority.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let alphaStatusCode = self.alphaStatusCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let maintStatusUpdate = self.maintStatusUpdate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lastInspectionDate = self.lastInspectionDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let maintPoc = self.maintPoc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let groundStatus = self.groundStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let contaminationStatus = self.contaminationStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let fuelStatus = self.fuelStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lastUpdatedBy = self.lastUpdatedBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let troubleshootEtic = self.troubleshootEtic.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let etic = self.etic.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let parkLocation = self.parkLocation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let parkLocationSystem = self.parkLocationSystem.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idPOI = self.idPOI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    AircraftStatus_Abridged::create(_fbb, &AircraftStatus_AbridgedArgs{
      id,
      classificationMarking,
      idAircraft,
      altAircraftId,
      currentState,
      idAirfield,
      geoLoc,
      previousICAO,
      currentICAO,
      nextICAO,
      flightPhase,
      taStartTime,
      earliestTAEndTime,
      missionReadiness,
      fuel,
      fuelFunction,
      gunCapable,
      gunRdsType,
      gunRdsMin,
      gunRdsMax,
      airToAirStatus,
      airToGroundStatus,
      inventory,
      inventoryMin,
      inventoryMax,
      unavailableSys,
      additionalSys,
      notes,
      mxRemark,
      maintStatus,
      maintStatusDriver,
      maintPriority,
      alphaStatusCode,
      maintStatusUpdate,
      lastInspectionDate,
      maintPoc,
      groundStatus,
      contaminationStatus,
      fuelStatus,
      lastUpdatedBy,
      troubleshootEtic,
      etic,
      parkLocation,
      parkLocationSystem,
      idPOI,
      createdAt,
      createdBy,
      sourceDL,
      source,
      origin,
      dataMode,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AircraftStatus_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_aircraft_status_abridged_unchecked`.
pub fn root_as_aircraft_status_abridged(buf: &[u8]) -> Result<AircraftStatus_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AircraftStatus_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AircraftStatus_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_aircraft_status_abridged_unchecked`.
pub fn size_prefixed_root_as_aircraft_status_abridged(buf: &[u8]) -> Result<AircraftStatus_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AircraftStatus_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AircraftStatus_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_aircraft_status_abridged_unchecked`.
pub fn root_as_aircraft_status_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AircraftStatus_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AircraftStatus_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AircraftStatus_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_aircraft_status_abridged_unchecked`.
pub fn size_prefixed_root_as_aircraft_status_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AircraftStatus_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AircraftStatus_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AircraftStatus_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AircraftStatus_Abridged`.
pub unsafe fn root_as_aircraft_status_abridged_unchecked(buf: &[u8]) -> AircraftStatus_Abridged {
  flatbuffers::root_unchecked::<AircraftStatus_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AircraftStatus_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AircraftStatus_Abridged`.
pub unsafe fn size_prefixed_root_as_aircraft_status_abridged_unchecked(buf: &[u8]) -> AircraftStatus_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<AircraftStatus_Abridged>(buf)
}
pub const AIRCRAFT_STATUS_ABRIDGED_IDENTIFIER: &str = "AIRC";

#[inline]
pub fn aircraft_status_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRCRAFT_STATUS_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn aircraft_status_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIRCRAFT_STATUS_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_aircraft_status_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AircraftStatus_Abridged<'a>>) {
  fbb.finish(root, Some(AIRCRAFT_STATUS_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_aircraft_status_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AircraftStatus_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(AIRCRAFT_STATUS_ABRIDGED_IDENTIFIER));
}
