// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ATTITUDE_DATA_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ATTITUDE_DATA_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ATTITUDE_DATA_ABRIDGED_DATA_MODE_ENUM: [AttitudeData_Abridged_dataMode_Enum; 4] = [
  AttitudeData_Abridged_dataMode_Enum::REAL,
  AttitudeData_Abridged_dataMode_Enum::TEST,
  AttitudeData_Abridged_dataMode_Enum::SIMULATED,
  AttitudeData_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AttitudeData_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AttitudeData_Abridged_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AttitudeData_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AttitudeData_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AttitudeData_Abridged_dataMode_Enum {
    type Output = AttitudeData_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AttitudeData_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AttitudeData_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AttitudeData_Abridged_dataMode_Enum {}
pub enum AttitudeData_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// These services provide operations for posting and querying attitude of on-orbit objects.  Attitude describes the orientation of an object, which can be represented by quaternions or euler angles.  The AttitudeSet ID (asId) identifies the 'AttitudeSet' record which contains details of the underlying data as well as a collection of attitude points. Points must be retrieved by first identifying a desired AttitudeSet and pulling its points by that AttitudeSet ID 'asId'.
pub struct AttitudeData_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AttitudeData_Abridged<'a> {
  type Inner = AttitudeData_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AttitudeData_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_ASID: flatbuffers::VOffsetT = 8;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 10;
  pub const VT_SATNO: flatbuffers::VOffsetT = 12;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 14;
  pub const VT_TS: flatbuffers::VOffsetT = 16;
  pub const VT_MOTIONTYPE: flatbuffers::VOffsetT = 18;
  pub const VT_Q1: flatbuffers::VOffsetT = 20;
  pub const VT_Q2: flatbuffers::VOffsetT = 22;
  pub const VT_Q3: flatbuffers::VOffsetT = 24;
  pub const VT_QC: flatbuffers::VOffsetT = 26;
  pub const VT_Q1DOT: flatbuffers::VOffsetT = 28;
  pub const VT_Q2DOT: flatbuffers::VOffsetT = 30;
  pub const VT_Q3DOT: flatbuffers::VOffsetT = 32;
  pub const VT_QCDOT: flatbuffers::VOffsetT = 34;
  pub const VT_XANGLE: flatbuffers::VOffsetT = 36;
  pub const VT_YANGLE: flatbuffers::VOffsetT = 38;
  pub const VT_ZANGLE: flatbuffers::VOffsetT = 40;
  pub const VT_XRATE: flatbuffers::VOffsetT = 42;
  pub const VT_YRATE: flatbuffers::VOffsetT = 44;
  pub const VT_ZRATE: flatbuffers::VOffsetT = 46;
  pub const VT_RA: flatbuffers::VOffsetT = 48;
  pub const VT_DECLINATION: flatbuffers::VOffsetT = 50;
  pub const VT_CONINGANGLE: flatbuffers::VOffsetT = 52;
  pub const VT_PRECPERIOD: flatbuffers::VOffsetT = 54;
  pub const VT_SPINPERIOD: flatbuffers::VOffsetT = 56;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 58;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 60;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 62;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 64;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 66;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 68;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AttitudeData_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AttitudeData_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<AttitudeData_Abridged<'bldr>> {
    let mut builder = AttitudeData_AbridgedBuilder::new(_fbb);
    builder.add_spinPeriod(args.spinPeriod);
    builder.add_precPeriod(args.precPeriod);
    builder.add_coningAngle(args.coningAngle);
    builder.add_declination(args.declination);
    builder.add_ra(args.ra);
    builder.add_qcDot(args.qcDot);
    builder.add_q3Dot(args.q3Dot);
    builder.add_q2Dot(args.q2Dot);
    builder.add_q1Dot(args.q1Dot);
    builder.add_qc(args.qc);
    builder.add_q3(args.q3);
    builder.add_q2(args.q2);
    builder.add_q1(args.q1);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.zRate { builder.add_zRate(x); }
    if let Some(x) = args.yRate { builder.add_yRate(x); }
    if let Some(x) = args.xRate { builder.add_xRate(x); }
    if let Some(x) = args.zAngle { builder.add_zAngle(x); }
    if let Some(x) = args.yAngle { builder.add_yAngle(x); }
    if let Some(x) = args.xAngle { builder.add_xAngle(x); }
    if let Some(x) = args.motionType { builder.add_motionType(x); }
    if let Some(x) = args.ts { builder.add_ts(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.asId { builder.add_asId(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> AttitudeData_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let asId = self.asId().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let satNo = self.satNo();
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let ts = self.ts().map(|x| {
      x.to_string()
    });
    let motionType = self.motionType().map(|x| {
      x.to_string()
    });
    let q1 = self.q1();
    let q2 = self.q2();
    let q3 = self.q3();
    let qc = self.qc();
    let q1Dot = self.q1Dot();
    let q2Dot = self.q2Dot();
    let q3Dot = self.q3Dot();
    let qcDot = self.qcDot();
    let xAngle = self.xAngle().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let yAngle = self.yAngle().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let zAngle = self.zAngle().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let xRate = self.xRate().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let yRate = self.yRate().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let zRate = self.zRate().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ra = self.ra();
    let declination = self.declination();
    let coningAngle = self.coningAngle();
    let precPeriod = self.precPeriod();
    let spinPeriod = self.spinPeriod();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    AttitudeData_AbridgedT {
      id,
      classificationMarking,
      asId,
      idOnOrbit,
      satNo,
      origObjectId,
      ts,
      motionType,
      q1,
      q2,
      q3,
      qc,
      q1Dot,
      q2Dot,
      q3Dot,
      qcDot,
      xAngle,
      yAngle,
      zAngle,
      xRate,
      yRate,
      zRate,
      ra,
      declination,
      coningAngle,
      precPeriod,
      spinPeriod,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: ATTITUDEDATA-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the parent AttitudeSet associated with this record.
  /// Example: /// Example: 773c9887-e931-42eb-8155-f0fbd227b235
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn asId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_ASID, None)}
  }
  /// Unique identifier of the on-orbit satellite to which this attitude record applies.
  /// Example: /// Example: 41947
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_IDONORBIT, None)}
  }
  /// Satellite/catalog number of the on-orbit object to which this attitude record applies.
  /// Example: /// Example: 41947
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AttitudeData_Abridged::VT_SATNO, Some(0)).unwrap()}
  }
  /// Optional identifier provided by the record source to indicate the target object of this attitude record. This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: D6593
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_ORIGOBJECTID, None)}
  }
  /// Time associated with this attitude record, in ISO 8601 UTC format, with microsecond precision.
  /// Example: /// Example: 2022-03-07T14:51:39.653043Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ts(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_TS, None)}
  }
  /// Label specifying type of rotational motion of target.
  /// Example: /// Example: PROSOL_MOTION
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn motionType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_MOTIONTYPE, None)}
  }
  /// Quaternion vector component 1.
  /// Example: /// Example: 0.0312
  /// Constraints: No constraints specified.
  #[inline]
  pub fn q1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_Q1, Some(0.0)).unwrap()}
  }
  /// Quaternion vector component 2.
  /// Example: /// Example: 0.7854
  /// Constraints: No constraints specified.
  #[inline]
  pub fn q2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_Q2, Some(0.0)).unwrap()}
  }
  /// Quaternion vector component 3.
  /// Example: /// Example: 0.3916
  /// Constraints: No constraints specified.
  #[inline]
  pub fn q3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_Q3, Some(0.0)).unwrap()}
  }
  /// Quaternion scalar component.
  /// Example: /// Example: 0.4783
  /// Constraints: No constraints specified.
  #[inline]
  pub fn qc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_QC, Some(0.0)).unwrap()}
  }
  /// Derivative of quaternion vector component 1.
  /// Example: /// Example: 0.0043
  /// Constraints: No constraints specified.
  #[inline]
  pub fn q1Dot(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_Q1DOT, Some(0.0)).unwrap()}
  }
  /// Derivative of quaternion vector component 2.
  /// Example: /// Example: 0.06
  /// Constraints: No constraints specified.
  #[inline]
  pub fn q2Dot(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_Q2DOT, Some(0.0)).unwrap()}
  }
  /// Derivative of quaternion vector component 3.
  /// Example: /// Example: 0.499
  /// Constraints: No constraints specified.
  #[inline]
  pub fn q3Dot(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_Q3DOT, Some(0.0)).unwrap()}
  }
  /// Derivative of quaternion scalar component.
  /// Example: /// Example: 0.011
  /// Constraints: No constraints specified.
  #[inline]
  pub fn qcDot(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_QCDOT, Some(0.0)).unwrap()}
  }
  /// Array of X body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
  /// Example: /// Example: [139.753]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xAngle(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AttitudeData_Abridged::VT_XANGLE, None)}
  }
  /// Array of Y body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
  /// Example: /// Example: [25.066]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yAngle(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AttitudeData_Abridged::VT_YANGLE, None)}
  }
  /// Array of Z body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
  /// Example: /// Example: [-53.368]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zAngle(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AttitudeData_Abridged::VT_ZANGLE, None)}
  }
  /// Array of X body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
  /// Example: /// Example: [0.105]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xRate(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AttitudeData_Abridged::VT_XRATE, None)}
  }
  /// Array of Y body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
  /// Example: /// Example: [0.032]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yRate(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AttitudeData_Abridged::VT_YRATE, None)}
  }
  /// Array of Z body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence  Attitude rates are expressed in frame1 with respect to frame2.
  /// Example: /// Example: [0.022]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn zRate(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AttitudeData_Abridged::VT_ZRATE, None)}
  }
  /// Precession axis right ascension (ECI J2000 frame) in degrees.
  /// Example: /// Example: -173.75
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ra(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_RA, Some(0.0)).unwrap()}
  }
  /// Precession axis declination (ECI J2000 frame) in degrees.
  /// Example: /// Example: 0.799
  /// Constraints: No constraints specified.
  #[inline]
  pub fn declination(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_DECLINATION, Some(0.0)).unwrap()}
  }
  /// Coning angle in degrees.
  /// Example: /// Example: 0.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn coningAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_CONINGANGLE, Some(0.0)).unwrap()}
  }
  /// Precession period in seconds.
  /// Example: /// Example: 36.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn precPeriod(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_PRECPERIOD, Some(0.0)).unwrap()}
  }
  /// Spin period in seconds.
  /// Example: /// Example: 0.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spinPeriod(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AttitudeData_Abridged::VT_SPINPERIOD, Some(0.0)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2022-07-05T12:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> AttitudeData_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AttitudeData_Abridged_dataMode_Enum>(AttitudeData_Abridged::VT_DATAMODE, Some(AttitudeData_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AttitudeData_Abridged::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for AttitudeData_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("asId", Self::VT_ASID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ts", Self::VT_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("motionType", Self::VT_MOTIONTYPE, false)?
     .visit_field::<f64>("q1", Self::VT_Q1, false)?
     .visit_field::<f64>("q2", Self::VT_Q2, false)?
     .visit_field::<f64>("q3", Self::VT_Q3, false)?
     .visit_field::<f64>("qc", Self::VT_QC, false)?
     .visit_field::<f64>("q1Dot", Self::VT_Q1DOT, false)?
     .visit_field::<f64>("q2Dot", Self::VT_Q2DOT, false)?
     .visit_field::<f64>("q3Dot", Self::VT_Q3DOT, false)?
     .visit_field::<f64>("qcDot", Self::VT_QCDOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("xAngle", Self::VT_XANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("yAngle", Self::VT_YANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("zAngle", Self::VT_ZANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("xRate", Self::VT_XRATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("yRate", Self::VT_YRATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("zRate", Self::VT_ZRATE, false)?
     .visit_field::<f64>("ra", Self::VT_RA, false)?
     .visit_field::<f64>("declination", Self::VT_DECLINATION, false)?
     .visit_field::<f64>("coningAngle", Self::VT_CONINGANGLE, false)?
     .visit_field::<f64>("precPeriod", Self::VT_PRECPERIOD, false)?
     .visit_field::<f64>("spinPeriod", Self::VT_SPINPERIOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<AttitudeData_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct AttitudeData_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub asId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo: i32,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub motionType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub q1: f64,
    pub q2: f64,
    pub q3: f64,
    pub qc: f64,
    pub q1Dot: f64,
    pub q2Dot: f64,
    pub q3Dot: f64,
    pub qcDot: f64,
    pub xAngle: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub yAngle: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub zAngle: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub xRate: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub yRate: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub zRate: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ra: f64,
    pub declination: f64,
    pub coningAngle: f64,
    pub precPeriod: f64,
    pub spinPeriod: f64,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: AttitudeData_Abridged_dataMode_Enum,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AttitudeData_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    AttitudeData_AbridgedArgs {
      id: None,
      classificationMarking: None,
      asId: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      ts: None,
      motionType: None,
      q1: 0.0,
      q2: 0.0,
      q3: 0.0,
      qc: 0.0,
      q1Dot: 0.0,
      q2Dot: 0.0,
      q3Dot: 0.0,
      qcDot: 0.0,
      xAngle: None,
      yAngle: None,
      zAngle: None,
      xRate: None,
      yRate: None,
      zRate: None,
      ra: 0.0,
      declination: 0.0,
      coningAngle: 0.0,
      precPeriod: 0.0,
      spinPeriod: 0.0,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: AttitudeData_Abridged_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}

pub struct AttitudeData_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AttitudeData_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_asId(&mut self, asId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_ASID, asId);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(AttitudeData_Abridged::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_ts(&mut self, ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_TS, ts);
  }
  #[inline]
  pub fn add_motionType(&mut self, motionType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_MOTIONTYPE, motionType);
  }
  #[inline]
  pub fn add_q1(&mut self, q1: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_Q1, q1, 0.0);
  }
  #[inline]
  pub fn add_q2(&mut self, q2: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_Q2, q2, 0.0);
  }
  #[inline]
  pub fn add_q3(&mut self, q3: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_Q3, q3, 0.0);
  }
  #[inline]
  pub fn add_qc(&mut self, qc: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_QC, qc, 0.0);
  }
  #[inline]
  pub fn add_q1Dot(&mut self, q1Dot: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_Q1DOT, q1Dot, 0.0);
  }
  #[inline]
  pub fn add_q2Dot(&mut self, q2Dot: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_Q2DOT, q2Dot, 0.0);
  }
  #[inline]
  pub fn add_q3Dot(&mut self, q3Dot: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_Q3DOT, q3Dot, 0.0);
  }
  #[inline]
  pub fn add_qcDot(&mut self, qcDot: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_QCDOT, qcDot, 0.0);
  }
  #[inline]
  pub fn add_xAngle(&mut self, xAngle: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_XANGLE, xAngle);
  }
  #[inline]
  pub fn add_yAngle(&mut self, yAngle: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_YANGLE, yAngle);
  }
  #[inline]
  pub fn add_zAngle(&mut self, zAngle: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_ZANGLE, zAngle);
  }
  #[inline]
  pub fn add_xRate(&mut self, xRate: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_XRATE, xRate);
  }
  #[inline]
  pub fn add_yRate(&mut self, yRate: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_YRATE, yRate);
  }
  #[inline]
  pub fn add_zRate(&mut self, zRate: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_ZRATE, zRate);
  }
  #[inline]
  pub fn add_ra(&mut self, ra: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_RA, ra, 0.0);
  }
  #[inline]
  pub fn add_declination(&mut self, declination: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_DECLINATION, declination, 0.0);
  }
  #[inline]
  pub fn add_coningAngle(&mut self, coningAngle: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_CONINGANGLE, coningAngle, 0.0);
  }
  #[inline]
  pub fn add_precPeriod(&mut self, precPeriod: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_PRECPERIOD, precPeriod, 0.0);
  }
  #[inline]
  pub fn add_spinPeriod(&mut self, spinPeriod: f64) {
    self.fbb_.push_slot::<f64>(AttitudeData_Abridged::VT_SPINPERIOD, spinPeriod, 0.0);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: AttitudeData_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<AttitudeData_Abridged_dataMode_Enum>(AttitudeData_Abridged::VT_DATAMODE, dataMode, AttitudeData_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AttitudeData_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AttitudeData_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AttitudeData_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AttitudeData_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AttitudeData_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AttitudeData_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("asId", &self.asId());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("satNo", &self.satNo());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("ts", &self.ts());
      ds.field("motionType", &self.motionType());
      ds.field("q1", &self.q1());
      ds.field("q2", &self.q2());
      ds.field("q3", &self.q3());
      ds.field("qc", &self.qc());
      ds.field("q1Dot", &self.q1Dot());
      ds.field("q2Dot", &self.q2Dot());
      ds.field("q3Dot", &self.q3Dot());
      ds.field("qcDot", &self.qcDot());
      ds.field("xAngle", &self.xAngle());
      ds.field("yAngle", &self.yAngle());
      ds.field("zAngle", &self.zAngle());
      ds.field("xRate", &self.xRate());
      ds.field("yRate", &self.yRate());
      ds.field("zRate", &self.zRate());
      ds.field("ra", &self.ra());
      ds.field("declination", &self.declination());
      ds.field("coningAngle", &self.coningAngle());
      ds.field("precPeriod", &self.precPeriod());
      ds.field("spinPeriod", &self.spinPeriod());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AttitudeData_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub asId: Option<String>,
  pub idOnOrbit: Option<String>,
  pub satNo: i32,
  pub origObjectId: Option<String>,
  pub ts: Option<String>,
  pub motionType: Option<String>,
  pub q1: f64,
  pub q2: f64,
  pub q3: f64,
  pub qc: f64,
  pub q1Dot: f64,
  pub q2Dot: f64,
  pub q3Dot: f64,
  pub qcDot: f64,
  pub xAngle: Option<Vec<String>>,
  pub yAngle: Option<Vec<String>>,
  pub zAngle: Option<Vec<String>>,
  pub xRate: Option<Vec<String>>,
  pub yRate: Option<Vec<String>>,
  pub zRate: Option<Vec<String>>,
  pub ra: f64,
  pub declination: f64,
  pub coningAngle: f64,
  pub precPeriod: f64,
  pub spinPeriod: f64,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: AttitudeData_Abridged_dataMode_Enum,
  pub origNetwork: Option<String>,
}
impl Default for AttitudeData_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      asId: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      ts: None,
      motionType: None,
      q1: 0.0,
      q2: 0.0,
      q3: 0.0,
      qc: 0.0,
      q1Dot: 0.0,
      q2Dot: 0.0,
      q3Dot: 0.0,
      qcDot: 0.0,
      xAngle: None,
      yAngle: None,
      zAngle: None,
      xRate: None,
      yRate: None,
      zRate: None,
      ra: 0.0,
      declination: 0.0,
      coningAngle: 0.0,
      precPeriod: 0.0,
      spinPeriod: 0.0,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: AttitudeData_Abridged_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}
impl AttitudeData_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AttitudeData_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let asId = self.asId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo = self.satNo;
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ts = self.ts.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let motionType = self.motionType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let q1 = self.q1;
    let q2 = self.q2;
    let q3 = self.q3;
    let qc = self.qc;
    let q1Dot = self.q1Dot;
    let q2Dot = self.q2Dot;
    let q3Dot = self.q3Dot;
    let qcDot = self.qcDot;
    let xAngle = self.xAngle.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let yAngle = self.yAngle.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let zAngle = self.zAngle.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let xRate = self.xRate.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let yRate = self.yRate.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let zRate = self.zRate.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ra = self.ra;
    let declination = self.declination;
    let coningAngle = self.coningAngle;
    let precPeriod = self.precPeriod;
    let spinPeriod = self.spinPeriod;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    AttitudeData_Abridged::create(_fbb, &AttitudeData_AbridgedArgs{
      id,
      classificationMarking,
      asId,
      idOnOrbit,
      satNo,
      origObjectId,
      ts,
      motionType,
      q1,
      q2,
      q3,
      qc,
      q1Dot,
      q2Dot,
      q3Dot,
      qcDot,
      xAngle,
      yAngle,
      zAngle,
      xRate,
      yRate,
      zRate,
      ra,
      declination,
      coningAngle,
      precPeriod,
      spinPeriod,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AttitudeData_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_attitude_data_abridged_unchecked`.
pub fn root_as_attitude_data_abridged(buf: &[u8]) -> Result<AttitudeData_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AttitudeData_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AttitudeData_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_attitude_data_abridged_unchecked`.
pub fn size_prefixed_root_as_attitude_data_abridged(buf: &[u8]) -> Result<AttitudeData_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AttitudeData_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AttitudeData_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_attitude_data_abridged_unchecked`.
pub fn root_as_attitude_data_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AttitudeData_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AttitudeData_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AttitudeData_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_attitude_data_abridged_unchecked`.
pub fn size_prefixed_root_as_attitude_data_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AttitudeData_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AttitudeData_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AttitudeData_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AttitudeData_Abridged`.
pub unsafe fn root_as_attitude_data_abridged_unchecked(buf: &[u8]) -> AttitudeData_Abridged {
  flatbuffers::root_unchecked::<AttitudeData_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AttitudeData_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AttitudeData_Abridged`.
pub unsafe fn size_prefixed_root_as_attitude_data_abridged_unchecked(buf: &[u8]) -> AttitudeData_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<AttitudeData_Abridged>(buf)
}
pub const ATTITUDE_DATA_ABRIDGED_IDENTIFIER: &str = "ATTI";

#[inline]
pub fn attitude_data_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ATTITUDE_DATA_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn attitude_data_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ATTITUDE_DATA_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_attitude_data_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AttitudeData_Abridged<'a>>) {
  fbb.finish(root, Some(ATTITUDE_DATA_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_attitude_data_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AttitudeData_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(ATTITUDE_DATA_ABRIDGED_IDENTIFIER));
}
