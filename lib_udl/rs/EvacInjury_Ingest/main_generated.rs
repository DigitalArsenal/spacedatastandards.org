// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum EvacInjury_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Injury specifics.
pub struct EvacInjury_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EvacInjury_Ingest<'a> {
  type Inner = EvacInjury_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EvacInjury_Ingest<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_BODYPART: flatbuffers::VOffsetT = 6;
  pub const VT_TIME: flatbuffers::VOffsetT = 8;
  pub const VT_COMMENTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EvacInjury_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EvacInjury_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<EvacInjury_Ingest<'bldr>> {
    let mut builder = EvacInjury_IngestBuilder::new(_fbb);
    if let Some(x) = args.comments { builder.add_comments(x); }
    if let Some(x) = args.time { builder.add_time(x); }
    if let Some(x) = args.bodyPart { builder.add_bodyPart(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EvacInjury_IngestT {
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let bodyPart = self.bodyPart().map(|x| {
      x.to_string()
    });
    let time = self.time().map(|x| {
      x.to_string()
    });
    let comments = self.comments().map(|x| {
      x.to_string()
    });
    EvacInjury_IngestT {
      type_,
      bodyPart,
      time,
      comments,
    }
  }

  /// Classification of the injury type (ABRASION, AMPUTATION IT, AVULATION, BALLISTIC, BLAST WAVE, BURN 1ST DEGREE, BURN 2ND DEGREE, BURN 3RD DEGREE, BURN INHALATION, BURN LOWER AIRWAY, CHEST FLAIL, CHEST OPEN, DEGLOVING, ECCHYMOSIS, FRACTURE CLOSED, FRACTURE CREPITUS, FRACTURE IT, FRACTURE OPEN, HEMATOMA, IRREGULAR CONSISTENCY, IRREGULAR CONSISTENCY RIDGED, IRREGULAR CONSISTENCY SWOLLEN, IRREGULAR CONSISTENCY SWOLLEN DISTENDED, IRREGULAR CONSISTENCY TENDER, IRREGULAR POSITION, IRREGULAR SHAPE, IRREGULAR SHAPE MISSHAPED, IRREGULAR SHAPE NON SYMMETRICAL, LACERATION, NEUROVASCULAR COMPROMISE, NEUROVASCULAR INTACT, PUNCTURE, SEAT BELT SIGN, STAB, TIC TIM).
  /// Example: /// Example: ABRASION
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacInjury_Ingest::VT_TYPE_, None)}
  }
  /// Body part location of the injury.  Intended as, but not constrained to, K07.1 Body Location Enumeration (e.g. ANKLE LEFT BACK, ANKLE LEFT FRONT, ANKLE RIGHT BACK, ANKLE RIGHT FRONT, ARM LEFT BACK, ARM LEFT ELBOW BACK, ARM LEFT ELBOW FRONT, ARM LEFT FRONT, ARM LEFT LOWER BACK, etc.).
  /// Example: /// Example: ARM LEFT FRONT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn bodyPart(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacInjury_Ingest::VT_BODYPART, None)}
  }
  /// The time of the injury, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-10-15T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn time(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacInjury_Ingest::VT_TIME, None)}
  }
  /// Additional comments on the patient's injury information.
  /// Example: /// Example: Comments on the patient's injury.
  /// Constraints: Minimum length = 0, Maximum length = 1024
  #[inline]
  pub fn comments(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacInjury_Ingest::VT_COMMENTS, None)}
  }
}

impl flatbuffers::Verifiable for EvacInjury_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bodyPart", Self::VT_BODYPART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("time", Self::VT_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("comments", Self::VT_COMMENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct EvacInjury_IngestArgs<'a> {
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bodyPart: Option<flatbuffers::WIPOffset<&'a str>>,
    pub time: Option<flatbuffers::WIPOffset<&'a str>>,
    pub comments: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EvacInjury_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    EvacInjury_IngestArgs {
      type_: None,
      bodyPart: None,
      time: None,
      comments: None,
    }
  }
}

pub struct EvacInjury_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EvacInjury_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacInjury_Ingest::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_bodyPart(&mut self, bodyPart: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacInjury_Ingest::VT_BODYPART, bodyPart);
  }
  #[inline]
  pub fn add_time(&mut self, time: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacInjury_Ingest::VT_TIME, time);
  }
  #[inline]
  pub fn add_comments(&mut self, comments: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacInjury_Ingest::VT_COMMENTS, comments);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EvacInjury_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EvacInjury_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EvacInjury_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EvacInjury_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EvacInjury_Ingest");
      ds.field("type_", &self.type_());
      ds.field("bodyPart", &self.bodyPart());
      ds.field("time", &self.time());
      ds.field("comments", &self.comments());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EvacInjury_IngestT {
  pub type_: Option<String>,
  pub bodyPart: Option<String>,
  pub time: Option<String>,
  pub comments: Option<String>,
}
impl Default for EvacInjury_IngestT {
  fn default() -> Self {
    Self {
      type_: None,
      bodyPart: None,
      time: None,
      comments: None,
    }
  }
}
impl EvacInjury_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EvacInjury_Ingest<'b>> {
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let bodyPart = self.bodyPart.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let time = self.time.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let comments = self.comments.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    EvacInjury_Ingest::create(_fbb, &EvacInjury_IngestArgs{
      type_,
      bodyPart,
      time,
      comments,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EvacInjury_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evac_injury_ingest_unchecked`.
pub fn root_as_evac_injury_ingest(buf: &[u8]) -> Result<EvacInjury_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EvacInjury_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EvacInjury_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_evac_injury_ingest_unchecked`.
pub fn size_prefixed_root_as_evac_injury_ingest(buf: &[u8]) -> Result<EvacInjury_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EvacInjury_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EvacInjury_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evac_injury_ingest_unchecked`.
pub fn root_as_evac_injury_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EvacInjury_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EvacInjury_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EvacInjury_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evac_injury_ingest_unchecked`.
pub fn size_prefixed_root_as_evac_injury_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EvacInjury_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EvacInjury_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EvacInjury_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EvacInjury_Ingest`.
pub unsafe fn root_as_evac_injury_ingest_unchecked(buf: &[u8]) -> EvacInjury_Ingest {
  flatbuffers::root_unchecked::<EvacInjury_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EvacInjury_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EvacInjury_Ingest`.
pub unsafe fn size_prefixed_root_as_evac_injury_ingest_unchecked(buf: &[u8]) -> EvacInjury_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<EvacInjury_Ingest>(buf)
}
pub const EVAC_INJURY_INGEST_IDENTIFIER: &str = "EVAC";

#[inline]
pub fn evac_injury_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EVAC_INJURY_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn evac_injury_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EVAC_INJURY_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_evac_injury_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<EvacInjury_Ingest<'a>>) {
  fbb.finish(root, Some(EVAC_INJURY_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_evac_injury_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<EvacInjury_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(EVAC_INJURY_INGEST_IDENTIFIER));
}
