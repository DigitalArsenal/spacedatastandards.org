// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EQUIPMENT_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EQUIPMENT_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EQUIPMENT_ABRIDGED_DATA_MODE_ENUM: [Equipment_Abridged_dataMode_Enum; 4] = [
  Equipment_Abridged_dataMode_Enum::REAL,
  Equipment_Abridged_dataMode_Enum::TEST,
  Equipment_Abridged_dataMode_Enum::SIMULATED,
  Equipment_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Equipment_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Equipment_Abridged_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Equipment_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Equipment_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Equipment_Abridged_dataMode_Enum {
    type Output = Equipment_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Equipment_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Equipment_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Equipment_Abridged_dataMode_Enum {}
pub enum Equipment_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Properties and characteristics of equipment that can be associated with a site or other entity.
pub struct Equipment_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Equipment_Abridged<'a> {
  type Inner = Equipment_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Equipment_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDPARENTEQUIPMENT: flatbuffers::VOffsetT = 8;
  pub const VT_IDSITE: flatbuffers::VOffsetT = 10;
  pub const VT_IDOPERATINGUNIT: flatbuffers::VOffsetT = 12;
  pub const VT_ALTEQPID: flatbuffers::VOffsetT = 14;
  pub const VT_EQPCODE: flatbuffers::VOffsetT = 16;
  pub const VT_EQPIDNUM: flatbuffers::VOffsetT = 18;
  pub const VT_COUNTRYCODE: flatbuffers::VOffsetT = 20;
  pub const VT_ALTCOUNTRYCODE: flatbuffers::VOffsetT = 22;
  pub const VT_WAC: flatbuffers::VOffsetT = 24;
  pub const VT_SEQNUM: flatbuffers::VOffsetT = 26;
  pub const VT_NOMEN: flatbuffers::VOffsetT = 28;
  pub const VT_OPERSTATUS: flatbuffers::VOffsetT = 30;
  pub const VT_CONDITION: flatbuffers::VOffsetT = 32;
  pub const VT_CONDITIONAVAIL: flatbuffers::VOffsetT = 34;
  pub const VT_EVAL: flatbuffers::VOffsetT = 36;
  pub const VT_FPA: flatbuffers::VOffsetT = 38;
  pub const VT_FUNCTION: flatbuffers::VOffsetT = 40;
  pub const VT_IDENT: flatbuffers::VOffsetT = 42;
  pub const VT_ALLEGIANCE: flatbuffers::VOffsetT = 44;
  pub const VT_ALTALLEGIANCE: flatbuffers::VOffsetT = 46;
  pub const VT_LOCREASON: flatbuffers::VOffsetT = 48;
  pub const VT_OPERAREAPRIMARY: flatbuffers::VOffsetT = 50;
  pub const VT_FUNCTPRIMARY: flatbuffers::VOffsetT = 52;
  pub const VT_COORDDATUM: flatbuffers::VOffsetT = 54;
  pub const VT_COORD: flatbuffers::VOffsetT = 56;
  pub const VT_COORDDERIVACC: flatbuffers::VOffsetT = 58;
  pub const VT_LAT: flatbuffers::VOffsetT = 60;
  pub const VT_LON: flatbuffers::VOffsetT = 62;
  pub const VT_ELEVMSL: flatbuffers::VOffsetT = 64;
  pub const VT_ELEVMSLCONFLVL: flatbuffers::VOffsetT = 66;
  pub const VT_ELEVMSLDERIVACC: flatbuffers::VOffsetT = 68;
  pub const VT_GEOIDALMSLSEP: flatbuffers::VOffsetT = 70;
  pub const VT_MILGRIDSYS: flatbuffers::VOffsetT = 72;
  pub const VT_MILGRID: flatbuffers::VOffsetT = 74;
  pub const VT_UTM: flatbuffers::VOffsetT = 76;
  pub const VT_AIRDEFAREA: flatbuffers::VOffsetT = 78;
  pub const VT_POLSUBDIV: flatbuffers::VOffsetT = 80;
  pub const VT_QTYOH: flatbuffers::VOffsetT = 82;
  pub const VT_SYMCODE: flatbuffers::VOffsetT = 84;
  pub const VT_CLASSRATING: flatbuffers::VOffsetT = 86;
  pub const VT_RECSTATUS: flatbuffers::VOffsetT = 88;
  pub const VT_REVIEWDATE: flatbuffers::VOffsetT = 90;
  pub const VT_RESPROD: flatbuffers::VOffsetT = 92;
  pub const VT_REFERENCEDOC: flatbuffers::VOffsetT = 94;
  pub const VT_SRCTYPS: flatbuffers::VOffsetT = 96;
  pub const VT_SRCIDS: flatbuffers::VOffsetT = 98;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 100;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 102;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 104;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 106;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 108;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Equipment_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Equipment_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<Equipment_Abridged<'bldr>> {
    let mut builder = Equipment_AbridgedBuilder::new(_fbb);
    builder.add_geoidalMslSep(args.geoidalMslSep);
    builder.add_elevMslDerivAcc(args.elevMslDerivAcc);
    builder.add_elevMsl(args.elevMsl);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    builder.add_coordDerivAcc(args.coordDerivAcc);
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.srcIds { builder.add_srcIds(x); }
    if let Some(x) = args.srcTyps { builder.add_srcTyps(x); }
    if let Some(x) = args.referenceDoc { builder.add_referenceDoc(x); }
    if let Some(x) = args.resProd { builder.add_resProd(x); }
    if let Some(x) = args.reviewDate { builder.add_reviewDate(x); }
    if let Some(x) = args.recStatus { builder.add_recStatus(x); }
    if let Some(x) = args.classRating { builder.add_classRating(x); }
    if let Some(x) = args.symCode { builder.add_symCode(x); }
    builder.add_qtyOH(args.qtyOH);
    if let Some(x) = args.polSubdiv { builder.add_polSubdiv(x); }
    if let Some(x) = args.airDefArea { builder.add_airDefArea(x); }
    if let Some(x) = args.utm { builder.add_utm(x); }
    if let Some(x) = args.milGrid { builder.add_milGrid(x); }
    if let Some(x) = args.milGridSys { builder.add_milGridSys(x); }
    builder.add_elevMslConfLvl(args.elevMslConfLvl);
    if let Some(x) = args.coord { builder.add_coord(x); }
    if let Some(x) = args.coordDatum { builder.add_coordDatum(x); }
    if let Some(x) = args.functPrimary { builder.add_functPrimary(x); }
    if let Some(x) = args.operAreaPrimary { builder.add_operAreaPrimary(x); }
    if let Some(x) = args.locReason { builder.add_locReason(x); }
    if let Some(x) = args.altAllegiance { builder.add_altAllegiance(x); }
    if let Some(x) = args.allegiance { builder.add_allegiance(x); }
    if let Some(x) = args.ident { builder.add_ident(x); }
    if let Some(x) = args.function { builder.add_function(x); }
    if let Some(x) = args.fpa { builder.add_fpa(x); }
    builder.add_eval(args.eval);
    if let Some(x) = args.conditionAvail { builder.add_conditionAvail(x); }
    if let Some(x) = args.condition { builder.add_condition(x); }
    if let Some(x) = args.operStatus { builder.add_operStatus(x); }
    if let Some(x) = args.nomen { builder.add_nomen(x); }
    builder.add_seqNum(args.seqNum);
    if let Some(x) = args.wac { builder.add_wac(x); }
    if let Some(x) = args.altCountryCode { builder.add_altCountryCode(x); }
    if let Some(x) = args.countryCode { builder.add_countryCode(x); }
    if let Some(x) = args.eqpIdNum { builder.add_eqpIdNum(x); }
    if let Some(x) = args.eqpCode { builder.add_eqpCode(x); }
    if let Some(x) = args.altEqpId { builder.add_altEqpId(x); }
    if let Some(x) = args.idOperatingUnit { builder.add_idOperatingUnit(x); }
    if let Some(x) = args.idSite { builder.add_idSite(x); }
    if let Some(x) = args.idParentEquipment { builder.add_idParentEquipment(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.finish()
  }

  pub fn unpack(&self) -> Equipment_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idParentEquipment = self.idParentEquipment().map(|x| {
      x.to_string()
    });
    let idSite = self.idSite().map(|x| {
      x.to_string()
    });
    let idOperatingUnit = self.idOperatingUnit().map(|x| {
      x.to_string()
    });
    let altEqpId = self.altEqpId().map(|x| {
      x.to_string()
    });
    let eqpCode = self.eqpCode().map(|x| {
      x.to_string()
    });
    let eqpIdNum = self.eqpIdNum().map(|x| {
      x.to_string()
    });
    let countryCode = self.countryCode().map(|x| {
      x.to_string()
    });
    let altCountryCode = self.altCountryCode().map(|x| {
      x.to_string()
    });
    let wac = self.wac().map(|x| {
      x.to_string()
    });
    let seqNum = self.seqNum();
    let nomen = self.nomen().map(|x| {
      x.to_string()
    });
    let operStatus = self.operStatus().map(|x| {
      x.to_string()
    });
    let condition = self.condition().map(|x| {
      x.to_string()
    });
    let conditionAvail = self.conditionAvail().map(|x| {
      x.to_string()
    });
    let eval = self.eval();
    let fpa = self.fpa().map(|x| {
      x.to_string()
    });
    let function = self.function().map(|x| {
      x.to_string()
    });
    let ident = self.ident().map(|x| {
      x.to_string()
    });
    let allegiance = self.allegiance().map(|x| {
      x.to_string()
    });
    let altAllegiance = self.altAllegiance().map(|x| {
      x.to_string()
    });
    let locReason = self.locReason().map(|x| {
      x.to_string()
    });
    let operAreaPrimary = self.operAreaPrimary().map(|x| {
      x.to_string()
    });
    let functPrimary = self.functPrimary().map(|x| {
      x.to_string()
    });
    let coordDatum = self.coordDatum().map(|x| {
      x.to_string()
    });
    let coord = self.coord().map(|x| {
      x.to_string()
    });
    let coordDerivAcc = self.coordDerivAcc();
    let lat = self.lat();
    let lon = self.lon();
    let elevMsl = self.elevMsl();
    let elevMslConfLvl = self.elevMslConfLvl();
    let elevMslDerivAcc = self.elevMslDerivAcc();
    let geoidalMslSep = self.geoidalMslSep();
    let milGridSys = self.milGridSys().map(|x| {
      x.to_string()
    });
    let milGrid = self.milGrid().map(|x| {
      x.to_string()
    });
    let utm = self.utm().map(|x| {
      x.to_string()
    });
    let airDefArea = self.airDefArea().map(|x| {
      x.to_string()
    });
    let polSubdiv = self.polSubdiv().map(|x| {
      x.to_string()
    });
    let qtyOH = self.qtyOH();
    let symCode = self.symCode().map(|x| {
      x.to_string()
    });
    let classRating = self.classRating().map(|x| {
      x.to_string()
    });
    let recStatus = self.recStatus().map(|x| {
      x.to_string()
    });
    let reviewDate = self.reviewDate().map(|x| {
      x.to_string()
    });
    let resProd = self.resProd().map(|x| {
      x.to_string()
    });
    let referenceDoc = self.referenceDoc().map(|x| {
      x.to_string()
    });
    let srcTyps = self.srcTyps().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let srcIds = self.srcIds().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    Equipment_AbridgedT {
      id,
      classificationMarking,
      idParentEquipment,
      idSite,
      idOperatingUnit,
      altEqpId,
      eqpCode,
      eqpIdNum,
      countryCode,
      altCountryCode,
      wac,
      seqNum,
      nomen,
      operStatus,
      condition,
      conditionAvail,
      eval,
      fpa,
      function,
      ident,
      allegiance,
      altAllegiance,
      locReason,
      operAreaPrimary,
      functPrimary,
      coordDatum,
      coord,
      coordDerivAcc,
      lat,
      lon,
      elevMsl,
      elevMslConfLvl,
      elevMslDerivAcc,
      geoidalMslSep,
      milGridSys,
      milGrid,
      utm,
      airDefArea,
      polSubdiv,
      qtyOH,
      symCode,
      classRating,
      recStatus,
      reviewDate,
      resProd,
      referenceDoc,
      srcTyps,
      srcIds,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: 0167f577-e06c-358e-85aa-0a07a730bdd0
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the Parent equipment record associated with this equipment record.
  /// Example: /// Example: PARENT-EQUIPMENT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idParentEquipment(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_IDPARENTEQUIPMENT, None)}
  }
  /// Unique identifier of the Site Entity associated with the equipment record.
  /// Example: /// Example: SITE-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSite(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_IDSITE, None)}
  }
  /// Unique identifier of the operating unit associated with the equipment record.
  /// Example: /// Example: UNIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOperatingUnit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_IDOPERATINGUNIT, None)}
  }
  /// Unique identifier of the Equipment record from the originating system.
  /// Example: /// Example: ORIG-EQP-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn altEqpId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_ALTEQPID, None)}
  }
  /// Designated equipment code assigned to the item of equipment or an abbreviation record type unique identifier. Users should consult the data provider for information on the equipment code structure.
  /// Example: /// Example: X12345
  /// Constraints: Minimum length = 0, Maximum length = 7
  #[inline]
  pub fn eqpCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_EQPCODE, None)}
  }
  /// Uniquely identifies each item or group of equipment associated with a unit, facility or site.
  /// Example: /// Example: 001
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn eqpIdNum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_EQPIDNUM, None)}
  }
  /// The DoD Standard Country Code designator for the country or political entity to which the equipment geographic coordinates reside. This field will be set to "OTHR" if the source value does not match a UDL Country code value (ISO-3166-ALPHA-2).
  /// Example: /// Example: IQ
  /// Constraints: Minimum length = 1, Maximum length = 4
  #[inline]
  pub fn countryCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_COUNTRYCODE, None)}
  }
  /// Specifies an alternate country code if the data provider code is not part of an official Country Code standard such as ISO-3166 or FIPS. This field will be set to the value provided by the source and should be used for all Queries specifying a Country Code.
  /// Example: /// Example: IZ
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn altCountryCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_ALTCOUNTRYCODE, None)}
  }
  /// World Aeronautical Chart identifier for the area in which a designated place is located.
  /// Example: /// Example: 0427
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn wac(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_WAC, None)}
  }
  /// Provider specific sequential number assigned to the equipment.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn seqNum(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Equipment_Abridged::VT_SEQNUM, Some(0)).unwrap()}
  }
  /// Generic type this specific piece of equipment belongs to, and the identifying nomenclature which describes the equipment.
  /// Example: /// Example: AMPHIBIOUS WARFARE SHIP
  /// Constraints: Minimum length = 0, Maximum length = 54
  #[inline]
  pub fn nomen(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_NOMEN, None)}
  }
  /// The Degree to which an entity is ready to perform the overall operational mission(s) for which it was organized and equipped. The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: OPR
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn operStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_OPERSTATUS, None)}
  }
  /// The physical manner of being or state of existence of the entity.  A physical condition that must be considered in the determining of a course of action. The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: RDY
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn condition(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_CONDITION, None)}
  }
  /// Availability of the entity relative to its condition.  Indicates the reason the entity is not fully operational. The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: A
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn conditionAvail(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_CONDITIONAVAIL, None)}
  }
  /// Eval represents the Intelligence Confidence Level or the Reliability/degree of confidence that the analyst has assigned to the data within this record. The numerical range is from 1 to 9 with 1 representing the highest confidence level.
  /// Example: /// Example: 7
  /// Constraints: No constraints specified.
  #[inline]
  pub fn eval(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Equipment_Abridged::VT_EVAL, Some(0)).unwrap()}
  }
  /// Functional Production Area (FPA) under the Shared Production Program (SPP).  Producers are defined per country per FPA. The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: NOB
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn fpa(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_FPA, None)}
  }
  /// Indicates the function or mission of this equipment, which may or may not be engaged in at any particular time.  Typically refers to a unit, organization, or installation/facility performing a specific function or mission such as a redistribution center or naval shipyard. The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: OCC
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn function(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_FUNCTION, None)}
  }
  /// Estimated identity of the Site (ASSUMED FRIEND, FRIEND, HOSTILE, FAKER, JOKER, NEUTRAL, PENDING, SUSPECT, UNKNOWN): 
  /// ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  /// FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  /// HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  /// FAKER: Friendly track, object, or entity acting as an exercise hostile.
  /// JOKER: Friendly track, object, or entity acting as an exercise suspect.
  /// NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  /// PENDING: Track object which has not been evaluated.
  /// SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  /// UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
  /// Example: /// Example: FRIEND
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn ident(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_IDENT, None)}
  }
  /// The DoD Standard Country Code designator for the country or political entity to which the equipment owes its allegiance. This field will be set to "OTHR" if the source value does not match a UDL Country code value (ISO-3166-ALPHA-2).
  /// Example: /// Example: OTHR
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn allegiance(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_ALLEGIANCE, None)}
  }
  /// Specifies an alternate allegiance code if the data provider code is not part of an official Country Code standard such as ISO-3166 or FIPS. This field will be set to the value provided by the source and should be used for all Queries specifying allegiance.
  /// Example: /// Example: HL
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn altAllegiance(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_ALTALLEGIANCE, None)}
  }
  /// Indicates the reason that the equipment is at that location. The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: GR
  /// Constraints: Minimum length = 0, Maximum length = 9
  #[inline]
  pub fn locReason(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_LOCREASON, None)}
  }
  /// Internationally recognized water area in which the vessel is most likely to be deployed or in which it normally operates most frequently.
  /// Example: /// Example: Territorial Sea
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn operAreaPrimary(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_OPERAREAPRIMARY, None)}
  }
  /// Principal operational function being performed.  The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: JG
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn functPrimary(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_FUNCTPRIMARY, None)}
  }
  /// A mathematical model of the earth used to calculate coordinates on a map.  US Forces use the World Geodetic System 1984 (WGS 84), but also use maps by allied countries with local datums.  The datum must be specified to ensure accuracy of coordinates. The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: WGS
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn coordDatum(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_COORDDATUM, None)}
  }
  /// Indicates any of the magnitudes that serve to define the position of a point by reference to a fixed figure, system of lines, etc. specified in degrees, minute, and seconds.
  /// Pos. 1-2.  Latitude Degrees     [00-90]
  /// Pos. 3-4.  Latitude Minutes     [00-59]
  /// Pos. 5-6.  Latitude Seconds     [00-59]
  /// Pos. 7-9.  Latitude Thousandths Of Seconds   [000-999]  
  /// Pos. 10. Latitude Hemisphere       [NS] 
  /// Pos. 11-13. Longitude Degrees     [00-180] 
  /// Pos. 14-15. Longitude Minutes     [00-59] 
  /// Pos. 16-17. Longitude Seconds     [00-59] 
  /// Pos. 18-20. Longitude Thousandths Of Seconds      [000-999]
  /// Pos. 21. Longitude Hemisphere     [EW]
  /// Pos. 1-21.  Unknown Latitude and Unknown Longitude [000000000U000000000U]].
  /// Example: /// Example: 340000000N0430000000E
  /// Constraints: Minimum length = 0, Maximum length = 21
  #[inline]
  pub fn coord(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_COORD, None)}
  }
  /// Indicates the plus or minus error assessed against the method used to derive the coordinate.
  /// Example: /// Example: 12.345
  /// Constraints: No constraints specified.
  #[inline]
  pub fn coordDerivAcc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Equipment_Abridged::VT_COORDDERIVACC, Some(0.0)).unwrap()}
  }
  /// WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 39.019242
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Equipment_Abridged::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: -104.251659
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Equipment_Abridged::VT_LON, Some(0.0)).unwrap()}
  }
  /// Ground elevation, in meters, of the geographic coordinates referenced to (above or below) Mean Sea Level (MSL) vertical datum.
  /// Example: /// Example: 123.45
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevMsl(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Equipment_Abridged::VT_ELEVMSL, Some(0.0)).unwrap()}
  }
  /// Indicates the confidence level expressed as a percent that a specific geometric spatial element, ELEVATION_MSL linear accuracy, has been vertically positioned to within a specified vertical accuracy. Confidence level has a range of values from 0 to 100, with 100 being highest level of confidence.
  /// Example: /// Example: 50
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevMslConfLvl(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Equipment_Abridged::VT_ELEVMSLCONFLVL, Some(0)).unwrap()}
  }
  /// Indicates the plus or minus error assessed against the method used to derive the elevation, measured in meters.
  /// Example: /// Example: 12.34
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevMslDerivAcc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Equipment_Abridged::VT_ELEVMSLDERIVACC, Some(0.0)).unwrap()}
  }
  /// The distance between Mean Sea Level and a referenced ellipsoid, measured in meters.
  /// Example: /// Example: 12.34
  /// Constraints: No constraints specified.
  #[inline]
  pub fn geoidalMslSep(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Equipment_Abridged::VT_GEOIDALMSLSEP, Some(0.0)).unwrap()}
  }
  /// Indicates the grid system used in the development of the milGrid coordinates. Values are:
  /// UPS - Universal Polar System
  /// UTM - Universal Transverse Mercator.
  /// Example: /// Example: UTM
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn milGridSys(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_MILGRIDSYS, None)}
  }
  /// The Military Grid Reference System is the geocoordinate standard used by NATO militaries for locating points on Earth. The MGRS is derived from the Universal Transverse Mercator (UTM) grid system and the Universal Polar Stereographic (UPS) grid system, but uses a different labeling convention. The MGRS is used as geocode for the entire Earth. Example of an milgrid coordinate, or grid reference, would be 4QFJ12345678, which consists of three parts:
  /// 4Q (grid zone designator, GZD)
  /// FJ (the 100,000-meter square identifier)
  /// 12345678 (numerical location; easting is 1234 and northing is 5678, in this case specifying a location with 10 m resolution).
  /// Example: /// Example: 4QFJ12345678
  /// Constraints: Minimum length = 0, Maximum length = 15
  #[inline]
  pub fn milGrid(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_MILGRID, None)}
  }
  /// Universal Transverse Mercator (UTM) grid coordinates.
  /// Pos. 1-2, UTM Zone Column   [01-60
  /// Pos. 3, UTM Zone Row   [C-HJ-NP-X]
  /// Pos. 4, UTM False Easting   [0-9]
  /// Pos. 5-9, UTM Meter Easting    [0-9][0-9][0-9][0-9][0-9]
  /// Pos. 10-11, UTM False Northing    [0-9][0-9]
  /// Pos. 12-16, UTM Meter Northing    [0-9][0-9][0-9][0-9][0-9].
  /// Example: /// Example: 19P4390691376966
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn utm(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_UTM, None)}
  }
  /// Air Defense District (ADD) or Air Defense Area (ADA) in which the geographic coordinates reside.
  /// Example: /// Example: AL006
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn airDefArea(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_AIRDEFAREA, None)}
  }
  /// Political subdivision in which the geographic coordinates reside. The specific usage and enumerations contained in this field may be found in the documentation provided in the referenceDoc field.  If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: IZ07
  /// Constraints: Minimum length = 0, Maximum length = 7
  #[inline]
  pub fn polSubdiv(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_POLSUBDIV, None)}
  }
  /// Relative to the parent entity, the total number of military personnel or equipment assessed to be on-hand (OH).
  /// Example: /// Example: 7
  /// Constraints: No constraints specified.
  #[inline]
  pub fn qtyOH(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Equipment_Abridged::VT_QTYOH, Some(0)).unwrap()}
  }
  /// A standard scheme for symbol coding enabling the transfer, display and use of symbols and graphics among information systems, as per MIL-STD 2525B, and supported by the element AFFILIATION.
  /// Example: /// Example: SOGPU----------
  /// Constraints: Minimum length = 0, Maximum length = 15
  #[inline]
  pub fn symCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_SYMCODE, None)}
  }
  /// Indicates the importance of the equipment. Referenced, but not constrained to, the following class ratings type classifications.
  /// 0 - Not of significant importance of the system
  /// 1 - Primary importance to system
  /// 2 - Secondary importance to system
  /// 3 - Tertiary importance to system
  /// O - Other. Explain in Remarks.
  /// Example: /// Example: 1
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn classRating(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_CLASSRATING, None)}
  }
  /// Validity and currency of the data in the record to be used in conjunction with the other elements in the record as defined by SOPs. Referenced, but not constrained to, the following record status type classifications.
  /// A - Active
  /// I - Inactive
  /// K - Acknowledged
  /// L - Local
  /// Q - A nominated (NOM) or Data Change Request (DCR) record
  /// R - Production reduced by CMD decision
  /// W - Working Record.
  /// Example: /// Example: A
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn recStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_RECSTATUS, None)}
  }
  /// Date on which the data in the record was last reviewed by the responsible analyst for accuracy and currency.  This date cannot be greater than the current date.
  /// Example: /// Example: 2008-06-10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn reviewDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_REVIEWDATE, None)}
  }
  /// Responsible Producer - Organization that is responsible for the maintenance of the record.
  /// Example: /// Example: RT
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn resProd(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_RESPROD, None)}
  }
  /// The reference documentiation that specifies the usage and enumerations contained in this record. If referenceDoc not provided, users may consult the data provider.
  /// Example: /// Example: Provider Reference Documentation
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn referenceDoc(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_REFERENCEDOC, None)}
  }
  /// Array of UDL record types such as AIRCRAFT, VESSEL, EO, MTI that are related to this equipment record. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
  /// Example: /// Example: ['AIRCRAFT']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn srcTyps(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Equipment_Abridged::VT_SRCTYPS, None)}
  }
  /// Array of UUID(s) of the UDL data record(s) that are related to this equipment record. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
  /// Example: /// Example: ['SRC_ID_1']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn srcIds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Equipment_Abridged::VT_SRCIDS, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Equipment_Abridged::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> Equipment_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Equipment_Abridged_dataMode_Enum>(Equipment_Abridged::VT_DATAMODE, Some(Equipment_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Equipment_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idParentEquipment", Self::VT_IDPARENTEQUIPMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSite", Self::VT_IDSITE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOperatingUnit", Self::VT_IDOPERATINGUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altEqpId", Self::VT_ALTEQPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eqpCode", Self::VT_EQPCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eqpIdNum", Self::VT_EQPIDNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("countryCode", Self::VT_COUNTRYCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altCountryCode", Self::VT_ALTCOUNTRYCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("wac", Self::VT_WAC, false)?
     .visit_field::<i32>("seqNum", Self::VT_SEQNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nomen", Self::VT_NOMEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("operStatus", Self::VT_OPERSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("condition", Self::VT_CONDITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("conditionAvail", Self::VT_CONDITIONAVAIL, false)?
     .visit_field::<i32>("eval", Self::VT_EVAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fpa", Self::VT_FPA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("function", Self::VT_FUNCTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ident", Self::VT_IDENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("allegiance", Self::VT_ALLEGIANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("altAllegiance", Self::VT_ALTALLEGIANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("locReason", Self::VT_LOCREASON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("operAreaPrimary", Self::VT_OPERAREAPRIMARY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("functPrimary", Self::VT_FUNCTPRIMARY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coordDatum", Self::VT_COORDDATUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coord", Self::VT_COORD, false)?
     .visit_field::<f64>("coordDerivAcc", Self::VT_COORDDERIVACC, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<f64>("elevMsl", Self::VT_ELEVMSL, false)?
     .visit_field::<i32>("elevMslConfLvl", Self::VT_ELEVMSLCONFLVL, false)?
     .visit_field::<f64>("elevMslDerivAcc", Self::VT_ELEVMSLDERIVACC, false)?
     .visit_field::<f64>("geoidalMslSep", Self::VT_GEOIDALMSLSEP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("milGridSys", Self::VT_MILGRIDSYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("milGrid", Self::VT_MILGRID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("utm", Self::VT_UTM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("airDefArea", Self::VT_AIRDEFAREA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("polSubdiv", Self::VT_POLSUBDIV, false)?
     .visit_field::<i32>("qtyOH", Self::VT_QTYOH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("symCode", Self::VT_SYMCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classRating", Self::VT_CLASSRATING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recStatus", Self::VT_RECSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reviewDate", Self::VT_REVIEWDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("resProd", Self::VT_RESPROD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("referenceDoc", Self::VT_REFERENCEDOC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("srcTyps", Self::VT_SRCTYPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("srcIds", Self::VT_SRCIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<Equipment_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .finish();
    Ok(())
  }
}
pub struct Equipment_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idParentEquipment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSite: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOperatingUnit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altEqpId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eqpCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eqpIdNum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub countryCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altCountryCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub wac: Option<flatbuffers::WIPOffset<&'a str>>,
    pub seqNum: i32,
    pub nomen: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub condition: Option<flatbuffers::WIPOffset<&'a str>>,
    pub conditionAvail: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eval: i32,
    pub fpa: Option<flatbuffers::WIPOffset<&'a str>>,
    pub function: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ident: Option<flatbuffers::WIPOffset<&'a str>>,
    pub allegiance: Option<flatbuffers::WIPOffset<&'a str>>,
    pub altAllegiance: Option<flatbuffers::WIPOffset<&'a str>>,
    pub locReason: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operAreaPrimary: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functPrimary: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coordDatum: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coord: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coordDerivAcc: f64,
    pub lat: f64,
    pub lon: f64,
    pub elevMsl: f64,
    pub elevMslConfLvl: i32,
    pub elevMslDerivAcc: f64,
    pub geoidalMslSep: f64,
    pub milGridSys: Option<flatbuffers::WIPOffset<&'a str>>,
    pub milGrid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub utm: Option<flatbuffers::WIPOffset<&'a str>>,
    pub airDefArea: Option<flatbuffers::WIPOffset<&'a str>>,
    pub polSubdiv: Option<flatbuffers::WIPOffset<&'a str>>,
    pub qtyOH: i32,
    pub symCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classRating: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reviewDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub resProd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub referenceDoc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub srcTyps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub srcIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: Equipment_Abridged_dataMode_Enum,
}
impl<'a> Default for Equipment_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Equipment_AbridgedArgs {
      id: None,
      classificationMarking: None,
      idParentEquipment: None,
      idSite: None,
      idOperatingUnit: None,
      altEqpId: None,
      eqpCode: None,
      eqpIdNum: None,
      countryCode: None,
      altCountryCode: None,
      wac: None,
      seqNum: 0,
      nomen: None,
      operStatus: None,
      condition: None,
      conditionAvail: None,
      eval: 0,
      fpa: None,
      function: None,
      ident: None,
      allegiance: None,
      altAllegiance: None,
      locReason: None,
      operAreaPrimary: None,
      functPrimary: None,
      coordDatum: None,
      coord: None,
      coordDerivAcc: 0.0,
      lat: 0.0,
      lon: 0.0,
      elevMsl: 0.0,
      elevMslConfLvl: 0,
      elevMslDerivAcc: 0.0,
      geoidalMslSep: 0.0,
      milGridSys: None,
      milGrid: None,
      utm: None,
      airDefArea: None,
      polSubdiv: None,
      qtyOH: 0,
      symCode: None,
      classRating: None,
      recStatus: None,
      reviewDate: None,
      resProd: None,
      referenceDoc: None,
      srcTyps: None,
      srcIds: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: Equipment_Abridged_dataMode_Enum::REAL,
    }
  }
}

pub struct Equipment_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Equipment_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idParentEquipment(&mut self, idParentEquipment: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_IDPARENTEQUIPMENT, idParentEquipment);
  }
  #[inline]
  pub fn add_idSite(&mut self, idSite: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_IDSITE, idSite);
  }
  #[inline]
  pub fn add_idOperatingUnit(&mut self, idOperatingUnit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_IDOPERATINGUNIT, idOperatingUnit);
  }
  #[inline]
  pub fn add_altEqpId(&mut self, altEqpId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_ALTEQPID, altEqpId);
  }
  #[inline]
  pub fn add_eqpCode(&mut self, eqpCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_EQPCODE, eqpCode);
  }
  #[inline]
  pub fn add_eqpIdNum(&mut self, eqpIdNum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_EQPIDNUM, eqpIdNum);
  }
  #[inline]
  pub fn add_countryCode(&mut self, countryCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_COUNTRYCODE, countryCode);
  }
  #[inline]
  pub fn add_altCountryCode(&mut self, altCountryCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_ALTCOUNTRYCODE, altCountryCode);
  }
  #[inline]
  pub fn add_wac(&mut self, wac: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_WAC, wac);
  }
  #[inline]
  pub fn add_seqNum(&mut self, seqNum: i32) {
    self.fbb_.push_slot::<i32>(Equipment_Abridged::VT_SEQNUM, seqNum, 0);
  }
  #[inline]
  pub fn add_nomen(&mut self, nomen: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_NOMEN, nomen);
  }
  #[inline]
  pub fn add_operStatus(&mut self, operStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_OPERSTATUS, operStatus);
  }
  #[inline]
  pub fn add_condition(&mut self, condition: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_CONDITION, condition);
  }
  #[inline]
  pub fn add_conditionAvail(&mut self, conditionAvail: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_CONDITIONAVAIL, conditionAvail);
  }
  #[inline]
  pub fn add_eval(&mut self, eval: i32) {
    self.fbb_.push_slot::<i32>(Equipment_Abridged::VT_EVAL, eval, 0);
  }
  #[inline]
  pub fn add_fpa(&mut self, fpa: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_FPA, fpa);
  }
  #[inline]
  pub fn add_function(&mut self, function: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_FUNCTION, function);
  }
  #[inline]
  pub fn add_ident(&mut self, ident: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_IDENT, ident);
  }
  #[inline]
  pub fn add_allegiance(&mut self, allegiance: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_ALLEGIANCE, allegiance);
  }
  #[inline]
  pub fn add_altAllegiance(&mut self, altAllegiance: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_ALTALLEGIANCE, altAllegiance);
  }
  #[inline]
  pub fn add_locReason(&mut self, locReason: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_LOCREASON, locReason);
  }
  #[inline]
  pub fn add_operAreaPrimary(&mut self, operAreaPrimary: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_OPERAREAPRIMARY, operAreaPrimary);
  }
  #[inline]
  pub fn add_functPrimary(&mut self, functPrimary: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_FUNCTPRIMARY, functPrimary);
  }
  #[inline]
  pub fn add_coordDatum(&mut self, coordDatum: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_COORDDATUM, coordDatum);
  }
  #[inline]
  pub fn add_coord(&mut self, coord: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_COORD, coord);
  }
  #[inline]
  pub fn add_coordDerivAcc(&mut self, coordDerivAcc: f64) {
    self.fbb_.push_slot::<f64>(Equipment_Abridged::VT_COORDDERIVACC, coordDerivAcc, 0.0);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(Equipment_Abridged::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(Equipment_Abridged::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_elevMsl(&mut self, elevMsl: f64) {
    self.fbb_.push_slot::<f64>(Equipment_Abridged::VT_ELEVMSL, elevMsl, 0.0);
  }
  #[inline]
  pub fn add_elevMslConfLvl(&mut self, elevMslConfLvl: i32) {
    self.fbb_.push_slot::<i32>(Equipment_Abridged::VT_ELEVMSLCONFLVL, elevMslConfLvl, 0);
  }
  #[inline]
  pub fn add_elevMslDerivAcc(&mut self, elevMslDerivAcc: f64) {
    self.fbb_.push_slot::<f64>(Equipment_Abridged::VT_ELEVMSLDERIVACC, elevMslDerivAcc, 0.0);
  }
  #[inline]
  pub fn add_geoidalMslSep(&mut self, geoidalMslSep: f64) {
    self.fbb_.push_slot::<f64>(Equipment_Abridged::VT_GEOIDALMSLSEP, geoidalMslSep, 0.0);
  }
  #[inline]
  pub fn add_milGridSys(&mut self, milGridSys: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_MILGRIDSYS, milGridSys);
  }
  #[inline]
  pub fn add_milGrid(&mut self, milGrid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_MILGRID, milGrid);
  }
  #[inline]
  pub fn add_utm(&mut self, utm: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_UTM, utm);
  }
  #[inline]
  pub fn add_airDefArea(&mut self, airDefArea: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_AIRDEFAREA, airDefArea);
  }
  #[inline]
  pub fn add_polSubdiv(&mut self, polSubdiv: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_POLSUBDIV, polSubdiv);
  }
  #[inline]
  pub fn add_qtyOH(&mut self, qtyOH: i32) {
    self.fbb_.push_slot::<i32>(Equipment_Abridged::VT_QTYOH, qtyOH, 0);
  }
  #[inline]
  pub fn add_symCode(&mut self, symCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_SYMCODE, symCode);
  }
  #[inline]
  pub fn add_classRating(&mut self, classRating: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_CLASSRATING, classRating);
  }
  #[inline]
  pub fn add_recStatus(&mut self, recStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_RECSTATUS, recStatus);
  }
  #[inline]
  pub fn add_reviewDate(&mut self, reviewDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_REVIEWDATE, reviewDate);
  }
  #[inline]
  pub fn add_resProd(&mut self, resProd: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_RESPROD, resProd);
  }
  #[inline]
  pub fn add_referenceDoc(&mut self, referenceDoc: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_REFERENCEDOC, referenceDoc);
  }
  #[inline]
  pub fn add_srcTyps(&mut self, srcTyps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_SRCTYPS, srcTyps);
  }
  #[inline]
  pub fn add_srcIds(&mut self, srcIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_SRCIDS, srcIds);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Equipment_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Equipment_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<Equipment_Abridged_dataMode_Enum>(Equipment_Abridged::VT_DATAMODE, dataMode, Equipment_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Equipment_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Equipment_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Equipment_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Equipment_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Equipment_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idParentEquipment", &self.idParentEquipment());
      ds.field("idSite", &self.idSite());
      ds.field("idOperatingUnit", &self.idOperatingUnit());
      ds.field("altEqpId", &self.altEqpId());
      ds.field("eqpCode", &self.eqpCode());
      ds.field("eqpIdNum", &self.eqpIdNum());
      ds.field("countryCode", &self.countryCode());
      ds.field("altCountryCode", &self.altCountryCode());
      ds.field("wac", &self.wac());
      ds.field("seqNum", &self.seqNum());
      ds.field("nomen", &self.nomen());
      ds.field("operStatus", &self.operStatus());
      ds.field("condition", &self.condition());
      ds.field("conditionAvail", &self.conditionAvail());
      ds.field("eval", &self.eval());
      ds.field("fpa", &self.fpa());
      ds.field("function", &self.function());
      ds.field("ident", &self.ident());
      ds.field("allegiance", &self.allegiance());
      ds.field("altAllegiance", &self.altAllegiance());
      ds.field("locReason", &self.locReason());
      ds.field("operAreaPrimary", &self.operAreaPrimary());
      ds.field("functPrimary", &self.functPrimary());
      ds.field("coordDatum", &self.coordDatum());
      ds.field("coord", &self.coord());
      ds.field("coordDerivAcc", &self.coordDerivAcc());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("elevMsl", &self.elevMsl());
      ds.field("elevMslConfLvl", &self.elevMslConfLvl());
      ds.field("elevMslDerivAcc", &self.elevMslDerivAcc());
      ds.field("geoidalMslSep", &self.geoidalMslSep());
      ds.field("milGridSys", &self.milGridSys());
      ds.field("milGrid", &self.milGrid());
      ds.field("utm", &self.utm());
      ds.field("airDefArea", &self.airDefArea());
      ds.field("polSubdiv", &self.polSubdiv());
      ds.field("qtyOH", &self.qtyOH());
      ds.field("symCode", &self.symCode());
      ds.field("classRating", &self.classRating());
      ds.field("recStatus", &self.recStatus());
      ds.field("reviewDate", &self.reviewDate());
      ds.field("resProd", &self.resProd());
      ds.field("referenceDoc", &self.referenceDoc());
      ds.field("srcTyps", &self.srcTyps());
      ds.field("srcIds", &self.srcIds());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Equipment_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idParentEquipment: Option<String>,
  pub idSite: Option<String>,
  pub idOperatingUnit: Option<String>,
  pub altEqpId: Option<String>,
  pub eqpCode: Option<String>,
  pub eqpIdNum: Option<String>,
  pub countryCode: Option<String>,
  pub altCountryCode: Option<String>,
  pub wac: Option<String>,
  pub seqNum: i32,
  pub nomen: Option<String>,
  pub operStatus: Option<String>,
  pub condition: Option<String>,
  pub conditionAvail: Option<String>,
  pub eval: i32,
  pub fpa: Option<String>,
  pub function: Option<String>,
  pub ident: Option<String>,
  pub allegiance: Option<String>,
  pub altAllegiance: Option<String>,
  pub locReason: Option<String>,
  pub operAreaPrimary: Option<String>,
  pub functPrimary: Option<String>,
  pub coordDatum: Option<String>,
  pub coord: Option<String>,
  pub coordDerivAcc: f64,
  pub lat: f64,
  pub lon: f64,
  pub elevMsl: f64,
  pub elevMslConfLvl: i32,
  pub elevMslDerivAcc: f64,
  pub geoidalMslSep: f64,
  pub milGridSys: Option<String>,
  pub milGrid: Option<String>,
  pub utm: Option<String>,
  pub airDefArea: Option<String>,
  pub polSubdiv: Option<String>,
  pub qtyOH: i32,
  pub symCode: Option<String>,
  pub classRating: Option<String>,
  pub recStatus: Option<String>,
  pub reviewDate: Option<String>,
  pub resProd: Option<String>,
  pub referenceDoc: Option<String>,
  pub srcTyps: Option<Vec<String>>,
  pub srcIds: Option<Vec<String>>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: Equipment_Abridged_dataMode_Enum,
}
impl Default for Equipment_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idParentEquipment: None,
      idSite: None,
      idOperatingUnit: None,
      altEqpId: None,
      eqpCode: None,
      eqpIdNum: None,
      countryCode: None,
      altCountryCode: None,
      wac: None,
      seqNum: 0,
      nomen: None,
      operStatus: None,
      condition: None,
      conditionAvail: None,
      eval: 0,
      fpa: None,
      function: None,
      ident: None,
      allegiance: None,
      altAllegiance: None,
      locReason: None,
      operAreaPrimary: None,
      functPrimary: None,
      coordDatum: None,
      coord: None,
      coordDerivAcc: 0.0,
      lat: 0.0,
      lon: 0.0,
      elevMsl: 0.0,
      elevMslConfLvl: 0,
      elevMslDerivAcc: 0.0,
      geoidalMslSep: 0.0,
      milGridSys: None,
      milGrid: None,
      utm: None,
      airDefArea: None,
      polSubdiv: None,
      qtyOH: 0,
      symCode: None,
      classRating: None,
      recStatus: None,
      reviewDate: None,
      resProd: None,
      referenceDoc: None,
      srcTyps: None,
      srcIds: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: Equipment_Abridged_dataMode_Enum::REAL,
    }
  }
}
impl Equipment_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Equipment_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idParentEquipment = self.idParentEquipment.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSite = self.idSite.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOperatingUnit = self.idOperatingUnit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altEqpId = self.altEqpId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eqpCode = self.eqpCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eqpIdNum = self.eqpIdNum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let countryCode = self.countryCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altCountryCode = self.altCountryCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let wac = self.wac.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let seqNum = self.seqNum;
    let nomen = self.nomen.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let operStatus = self.operStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let condition = self.condition.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let conditionAvail = self.conditionAvail.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eval = self.eval;
    let fpa = self.fpa.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let function = self.function.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ident = self.ident.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let allegiance = self.allegiance.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let altAllegiance = self.altAllegiance.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let locReason = self.locReason.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let operAreaPrimary = self.operAreaPrimary.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let functPrimary = self.functPrimary.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let coordDatum = self.coordDatum.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let coord = self.coord.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let coordDerivAcc = self.coordDerivAcc;
    let lat = self.lat;
    let lon = self.lon;
    let elevMsl = self.elevMsl;
    let elevMslConfLvl = self.elevMslConfLvl;
    let elevMslDerivAcc = self.elevMslDerivAcc;
    let geoidalMslSep = self.geoidalMslSep;
    let milGridSys = self.milGridSys.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let milGrid = self.milGrid.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let utm = self.utm.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let airDefArea = self.airDefArea.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let polSubdiv = self.polSubdiv.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let qtyOH = self.qtyOH;
    let symCode = self.symCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classRating = self.classRating.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let recStatus = self.recStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reviewDate = self.reviewDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let resProd = self.resProd.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let referenceDoc = self.referenceDoc.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let srcTyps = self.srcTyps.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let srcIds = self.srcIds.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    Equipment_Abridged::create(_fbb, &Equipment_AbridgedArgs{
      id,
      classificationMarking,
      idParentEquipment,
      idSite,
      idOperatingUnit,
      altEqpId,
      eqpCode,
      eqpIdNum,
      countryCode,
      altCountryCode,
      wac,
      seqNum,
      nomen,
      operStatus,
      condition,
      conditionAvail,
      eval,
      fpa,
      function,
      ident,
      allegiance,
      altAllegiance,
      locReason,
      operAreaPrimary,
      functPrimary,
      coordDatum,
      coord,
      coordDerivAcc,
      lat,
      lon,
      elevMsl,
      elevMslConfLvl,
      elevMslDerivAcc,
      geoidalMslSep,
      milGridSys,
      milGrid,
      utm,
      airDefArea,
      polSubdiv,
      qtyOH,
      symCode,
      classRating,
      recStatus,
      reviewDate,
      resProd,
      referenceDoc,
      srcTyps,
      srcIds,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Equipment_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_equipment_abridged_unchecked`.
pub fn root_as_equipment_abridged(buf: &[u8]) -> Result<Equipment_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Equipment_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Equipment_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_equipment_abridged_unchecked`.
pub fn size_prefixed_root_as_equipment_abridged(buf: &[u8]) -> Result<Equipment_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Equipment_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Equipment_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_equipment_abridged_unchecked`.
pub fn root_as_equipment_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Equipment_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Equipment_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Equipment_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_equipment_abridged_unchecked`.
pub fn size_prefixed_root_as_equipment_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Equipment_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Equipment_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Equipment_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Equipment_Abridged`.
pub unsafe fn root_as_equipment_abridged_unchecked(buf: &[u8]) -> Equipment_Abridged {
  flatbuffers::root_unchecked::<Equipment_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Equipment_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Equipment_Abridged`.
pub unsafe fn size_prefixed_root_as_equipment_abridged_unchecked(buf: &[u8]) -> Equipment_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<Equipment_Abridged>(buf)
}
pub const EQUIPMENT_ABRIDGED_IDENTIFIER: &str = "EQUI";

#[inline]
pub fn equipment_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EQUIPMENT_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn equipment_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EQUIPMENT_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_equipment_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Equipment_Abridged<'a>>) {
  fbb.finish(root, Some(EQUIPMENT_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_equipment_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Equipment_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(EQUIPMENT_ABRIDGED_IDENTIFIER));
}
