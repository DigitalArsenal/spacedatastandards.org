// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EPHEMERIS_SET_ABRIDGED_REFERENCE_FRAME_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EPHEMERIS_SET_ABRIDGED_REFERENCE_FRAME_ENUM: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EPHEMERIS_SET_ABRIDGED_REFERENCE_FRAME_ENUM: [EphemerisSet_Abridged_referenceFrame_Enum; 6] = [
  EphemerisSet_Abridged_referenceFrame_Enum::J2000,
  EphemerisSet_Abridged_referenceFrame_Enum::EFG_TDR,
  EphemerisSet_Abridged_referenceFrame_Enum::ECR_ECEF,
  EphemerisSet_Abridged_referenceFrame_Enum::TEME,
  EphemerisSet_Abridged_referenceFrame_Enum::ITRF,
  EphemerisSet_Abridged_referenceFrame_Enum::GCRF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EphemerisSet_Abridged_referenceFrame_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl EphemerisSet_Abridged_referenceFrame_Enum {
  /// No description available.
  pub const J2000: Self = Self(0);
  /// No description available.
  pub const EFG_TDR: Self = Self(1);
  /// No description available.
  pub const ECR_ECEF: Self = Self(2);
  /// No description available.
  pub const TEME: Self = Self(3);
  /// No description available.
  pub const ITRF: Self = Self(4);
  /// No description available.
  pub const GCRF: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::J2000,
    Self::EFG_TDR,
    Self::ECR_ECEF,
    Self::TEME,
    Self::ITRF,
    Self::GCRF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::J2000 => Some("J2000"),
      Self::EFG_TDR => Some("EFG_TDR"),
      Self::ECR_ECEF => Some("ECR_ECEF"),
      Self::TEME => Some("TEME"),
      Self::ITRF => Some("ITRF"),
      Self::GCRF => Some("GCRF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EphemerisSet_Abridged_referenceFrame_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EphemerisSet_Abridged_referenceFrame_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for EphemerisSet_Abridged_referenceFrame_Enum {
    type Output = EphemerisSet_Abridged_referenceFrame_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for EphemerisSet_Abridged_referenceFrame_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EphemerisSet_Abridged_referenceFrame_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EphemerisSet_Abridged_referenceFrame_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EPHEMERIS_SET_ABRIDGED_COV_REFERENCE_FRAME_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EPHEMERIS_SET_ABRIDGED_COV_REFERENCE_FRAME_ENUM: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EPHEMERIS_SET_ABRIDGED_COV_REFERENCE_FRAME_ENUM: [EphemerisSet_Abridged_covReferenceFrame_Enum; 2] = [
  EphemerisSet_Abridged_covReferenceFrame_Enum::J2000,
  EphemerisSet_Abridged_covReferenceFrame_Enum::UVW,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EphemerisSet_Abridged_covReferenceFrame_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl EphemerisSet_Abridged_covReferenceFrame_Enum {
  /// No description available.
  pub const J2000: Self = Self(0);
  /// No description available.
  pub const UVW: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::J2000,
    Self::UVW,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::J2000 => Some("J2000"),
      Self::UVW => Some("UVW"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EphemerisSet_Abridged_covReferenceFrame_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EphemerisSet_Abridged_covReferenceFrame_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for EphemerisSet_Abridged_covReferenceFrame_Enum {
    type Output = EphemerisSet_Abridged_covReferenceFrame_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for EphemerisSet_Abridged_covReferenceFrame_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EphemerisSet_Abridged_covReferenceFrame_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EphemerisSet_Abridged_covReferenceFrame_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EPHEMERIS_SET_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EPHEMERIS_SET_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EPHEMERIS_SET_ABRIDGED_DATA_MODE_ENUM: [EphemerisSet_Abridged_dataMode_Enum; 4] = [
  EphemerisSet_Abridged_dataMode_Enum::REAL,
  EphemerisSet_Abridged_dataMode_Enum::TEST,
  EphemerisSet_Abridged_dataMode_Enum::SIMULATED,
  EphemerisSet_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EphemerisSet_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl EphemerisSet_Abridged_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EphemerisSet_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EphemerisSet_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for EphemerisSet_Abridged_dataMode_Enum {
    type Output = EphemerisSet_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for EphemerisSet_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EphemerisSet_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EphemerisSet_Abridged_dataMode_Enum {}
pub enum EphemerisSet_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
pub struct EphemerisSet_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EphemerisSet_Abridged<'a> {
  type Inner = EphemerisSet_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EphemerisSet_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 8;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 10;
  pub const VT_POINTSTARTTIME: flatbuffers::VOffsetT = 12;
  pub const VT_USABLESTARTTIME: flatbuffers::VOffsetT = 14;
  pub const VT_POINTENDTIME: flatbuffers::VOffsetT = 16;
  pub const VT_USABLEENDTIME: flatbuffers::VOffsetT = 18;
  pub const VT_STEPSIZE: flatbuffers::VOffsetT = 20;
  pub const VT_NUMPOINTS: flatbuffers::VOffsetT = 22;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 24;
  pub const VT_PEDIGREE: flatbuffers::VOffsetT = 26;
  pub const VT_CATEGORY: flatbuffers::VOffsetT = 28;
  pub const VT_IDSTATEVECTOR: flatbuffers::VOffsetT = 30;
  pub const VT_HASMNVR: flatbuffers::VOffsetT = 32;
  pub const VT_IDMANEUVERS: flatbuffers::VOffsetT = 34;
  pub const VT_HASCOV: flatbuffers::VOffsetT = 36;
  pub const VT_HASACCEL: flatbuffers::VOffsetT = 38;
  pub const VT_CENTBODY: flatbuffers::VOffsetT = 40;
  pub const VT_INTEGRATOR: flatbuffers::VOffsetT = 42;
  pub const VT_GEOPOTENTIALMODEL: flatbuffers::VOffsetT = 44;
  pub const VT_DRAGMODEL: flatbuffers::VOffsetT = 46;
  pub const VT_LUNARSOLAR: flatbuffers::VOffsetT = 48;
  pub const VT_SOLIDEARTHTIDES: flatbuffers::VOffsetT = 50;
  pub const VT_BDOT: flatbuffers::VOffsetT = 52;
  pub const VT_EDR: flatbuffers::VOffsetT = 54;
  pub const VT_INTERPOLATION: flatbuffers::VOffsetT = 56;
  pub const VT_INTERPOLATIONDEGREE: flatbuffers::VOffsetT = 58;
  pub const VT_FILENAME: flatbuffers::VOffsetT = 60;
  pub const VT_COMMENTS: flatbuffers::VOffsetT = 62;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 64;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 66;
  pub const VT_REFERENCEFRAME: flatbuffers::VOffsetT = 68;
  pub const VT_COVREFERENCEFRAME: flatbuffers::VOffsetT = 70;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 72;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 74;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 76;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 78;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 80;
  pub const VT_SATNO: flatbuffers::VOffsetT = 82;
  pub const VT_TRANSACTIONID: flatbuffers::VOffsetT = 84;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 86;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EphemerisSet_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EphemerisSet_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<EphemerisSet_Abridged<'bldr>> {
    let mut builder = EphemerisSet_AbridgedBuilder::new(_fbb);
    builder.add_edr(args.edr);
    builder.add_bDot(args.bDot);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.transactionId { builder.add_transactionId(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.descriptor { builder.add_descriptor(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.comments { builder.add_comments(x); }
    if let Some(x) = args.filename { builder.add_filename(x); }
    builder.add_interpolationDegree(args.interpolationDegree);
    if let Some(x) = args.interpolation { builder.add_interpolation(x); }
    if let Some(x) = args.dragModel { builder.add_dragModel(x); }
    if let Some(x) = args.geopotentialModel { builder.add_geopotentialModel(x); }
    if let Some(x) = args.integrator { builder.add_integrator(x); }
    if let Some(x) = args.centBody { builder.add_centBody(x); }
    if let Some(x) = args.idManeuvers { builder.add_idManeuvers(x); }
    if let Some(x) = args.idStateVector { builder.add_idStateVector(x); }
    if let Some(x) = args.category { builder.add_category(x); }
    if let Some(x) = args.pedigree { builder.add_pedigree(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.add_numPoints(args.numPoints);
    builder.add_stepSize(args.stepSize);
    if let Some(x) = args.usableEndTime { builder.add_usableEndTime(x); }
    if let Some(x) = args.pointEndTime { builder.add_pointEndTime(x); }
    if let Some(x) = args.usableStartTime { builder.add_usableStartTime(x); }
    if let Some(x) = args.pointStartTime { builder.add_pointStartTime(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_covReferenceFrame(args.covReferenceFrame);
    builder.add_referenceFrame(args.referenceFrame);
    builder.add_solidEarthTides(args.solidEarthTides);
    builder.add_lunarSolar(args.lunarSolar);
    builder.add_hasAccel(args.hasAccel);
    builder.add_hasCov(args.hasCov);
    builder.add_hasMnvr(args.hasMnvr);
    builder.finish()
  }

  pub fn unpack(&self) -> EphemerisSet_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let pointStartTime = self.pointStartTime().map(|x| {
      x.to_string()
    });
    let usableStartTime = self.usableStartTime().map(|x| {
      x.to_string()
    });
    let pointEndTime = self.pointEndTime().map(|x| {
      x.to_string()
    });
    let usableEndTime = self.usableEndTime().map(|x| {
      x.to_string()
    });
    let stepSize = self.stepSize();
    let numPoints = self.numPoints();
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let pedigree = self.pedigree().map(|x| {
      x.to_string()
    });
    let category = self.category().map(|x| {
      x.to_string()
    });
    let idStateVector = self.idStateVector().map(|x| {
      x.to_string()
    });
    let hasMnvr = self.hasMnvr();
    let idManeuvers = self.idManeuvers().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let hasCov = self.hasCov();
    let hasAccel = self.hasAccel();
    let centBody = self.centBody().map(|x| {
      x.to_string()
    });
    let integrator = self.integrator().map(|x| {
      x.to_string()
    });
    let geopotentialModel = self.geopotentialModel().map(|x| {
      x.to_string()
    });
    let dragModel = self.dragModel().map(|x| {
      x.to_string()
    });
    let lunarSolar = self.lunarSolar();
    let solidEarthTides = self.solidEarthTides();
    let bDot = self.bDot();
    let edr = self.edr();
    let interpolation = self.interpolation().map(|x| {
      x.to_string()
    });
    let interpolationDegree = self.interpolationDegree();
    let filename = self.filename().map(|x| {
      x.to_string()
    });
    let comments = self.comments().map(|x| {
      x.to_string()
    });
    let description = self.description().map(|x| {
      x.to_string()
    });
    let descriptor = self.descriptor().map(|x| {
      x.to_string()
    });
    let referenceFrame = self.referenceFrame();
    let covReferenceFrame = self.covReferenceFrame();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let satNo = self.satNo();
    let transactionId = self.transactionId().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    EphemerisSet_AbridgedT {
      id,
      classificationMarking,
      idOnOrbit,
      origObjectId,
      pointStartTime,
      usableStartTime,
      pointEndTime,
      usableEndTime,
      stepSize,
      numPoints,
      type_,
      pedigree,
      category,
      idStateVector,
      hasMnvr,
      idManeuvers,
      hasCov,
      hasAccel,
      centBody,
      integrator,
      geopotentialModel,
      dragModel,
      lunarSolar,
      solidEarthTides,
      bDot,
      edr,
      interpolation,
      interpolationDegree,
      filename,
      comments,
      description,
      descriptor,
      referenceFrame,
      covReferenceFrame,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      satNo,
      transactionId,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: EPHEMERISSET-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the primary satellite on-orbit object.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_IDONORBIT, None)}
  }
  /// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_ORIGOBJECTID, None)}
  }
  /// Start time/first time point of the ephemeris, in ISO 8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pointStartTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_POINTSTARTTIME, None)}
  }
  /// Optional start time of the usable time span for the ephemeris data, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:10:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn usableStartTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_USABLESTARTTIME, None)}
  }
  /// End time/last time point of the ephemeris, in ISO 8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pointEndTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_POINTENDTIME, None)}
  }
  /// Optional end time of the usable time span for the ephemeris data, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2018-01-01T20:50:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn usableEndTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_USABLEENDTIME, None)}
  }
  /// Ephemeris step size, in seconds.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stepSize(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EphemerisSet_Abridged::VT_STEPSIZE, Some(0)).unwrap()}
  }
  /// Number of points contained in the ephemeris.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numPoints(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EphemerisSet_Abridged::VT_NUMPOINTS, Some(0)).unwrap()}
  }
  /// The type/purpose of the ephemeris (e.g., CALIBRATION, LAUNCH, MNVR_PLAN, ROUTINE, SCREENING).
  /// Example: /// Example: LAUNCH
  /// Constraints: Minimum length = 1, Maximum length = 24
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_TYPE_, None)}
  }
  /// The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID).
  /// Example: /// Example: PROPAGATED
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn pedigree(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_PEDIGREE, None)}
  }
  /// The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL).
  /// Example: /// Example: ANALYST
  /// Constraints: Minimum length = 1, Maximum length = 24
  #[inline]
  pub fn category(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_CATEGORY, None)}
  }
  /// ID of the State Vector used to generate the ephemeris.
  /// Example: /// Example: STATEVECTOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idStateVector(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_IDSTATEVECTOR, None)}
  }
  /// Boolean indicating whether maneuver(s) are incorporated into the ephemeris.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hasMnvr(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EphemerisSet_Abridged::VT_HASMNVR, Some(false)).unwrap()}
  }
  /// Array of the maneuver IDs of all maneuvers incorporated in the ephemeris.
  /// Example: /// Example: ['EXAMPLE_ID1', 'EXAMPLE_ID2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn idManeuvers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EphemerisSet_Abridged::VT_IDMANEUVERS, None)}
  }
  /// Boolean indicating whether covariance data is provided with the ephemeris.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hasCov(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EphemerisSet_Abridged::VT_HASCOV, Some(false)).unwrap()}
  }
  /// Boolean indicating whether acceleration data is provided with the ephemeris.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn hasAccel(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EphemerisSet_Abridged::VT_HASACCEL, Some(false)).unwrap()}
  }
  /// The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated.
  /// Example: /// Example: Earth
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn centBody(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_CENTBODY, None)}
  }
  /// Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY).
  /// Example: /// Example: COWELL
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn integrator(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_INTEGRATOR, None)}
  }
  /// Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T).
  /// Example: /// Example: GEM-T3
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn geopotentialModel(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_GEOPOTENTIALMODEL, None)}
  }
  /// Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.).
  /// Example: /// Example: JAC70
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn dragModel(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_DRAGMODEL, None)}
  }
  /// Boolean indicating use of lunar/solar data in ephemeris generation.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lunarSolar(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EphemerisSet_Abridged::VT_LUNARSOLAR, Some(false)).unwrap()}
  }
  /// Boolean indicating use of solid earth tide data in ephemeris generation.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn solidEarthTides(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EphemerisSet_Abridged::VT_SOLIDEARTHTIDES, Some(false)).unwrap()}
  }
  /// First derivative of ballistic coefficient (m^2/kg-s).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bDot(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EphemerisSet_Abridged::VT_BDOT, Some(0.0)).unwrap()}
  }
  /// Model parameter value for energy dissipation rate (EDR), expressed in w/kg.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn edr(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(EphemerisSet_Abridged::VT_EDR, Some(0.0)).unwrap()}
  }
  /// The recommended interpolation method for the ephemeris data.
  /// Example: /// Example: LINEAR
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn interpolation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_INTERPOLATION, None)}
  }
  /// The recommended interpolation degree for the ephemeris data.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn interpolationDegree(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EphemerisSet_Abridged::VT_INTERPOLATIONDEGREE, Some(0)).unwrap()}
  }
  /// Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the 'EphemerisSet' OpenAPI docs.
  /// Example: /// Example: Example file name
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn filename(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_FILENAME, None)}
  }
  /// Additional source provided comments associated with the ephemeris.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 512
  #[inline]
  pub fn comments(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_COMMENTS, None)}
  }
  /// Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 512
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_DESCRIPTION, None)}
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: Example descriptor
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn descriptor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_DESCRIPTOR, None)}
  }
  /// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn referenceFrame(&self) -> EphemerisSet_Abridged_referenceFrame_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EphemerisSet_Abridged_referenceFrame_Enum>(EphemerisSet_Abridged::VT_REFERENCEFRAME, Some(EphemerisSet_Abridged_referenceFrame_Enum::J2000)).unwrap()}
  }
  /// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn covReferenceFrame(&self) -> EphemerisSet_Abridged_covReferenceFrame_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EphemerisSet_Abridged_covReferenceFrame_Enum>(EphemerisSet_Abridged::VT_COVREFERENCEFRAME, Some(EphemerisSet_Abridged_covReferenceFrame_Enum::J2000)).unwrap()}
  }
  /// Time the row was created in the database, in UTC.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> EphemerisSet_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EphemerisSet_Abridged_dataMode_Enum>(EphemerisSet_Abridged::VT_DATAMODE, Some(EphemerisSet_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
  /// Satellite/catalog number of the target on-orbit object.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EphemerisSet_Abridged::VT_SATNO, Some(0)).unwrap()}
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn transactionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_TRANSACTIONID, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EphemerisSet_Abridged::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for EphemerisSet_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pointStartTime", Self::VT_POINTSTARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("usableStartTime", Self::VT_USABLESTARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pointEndTime", Self::VT_POINTENDTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("usableEndTime", Self::VT_USABLEENDTIME, false)?
     .visit_field::<i32>("stepSize", Self::VT_STEPSIZE, false)?
     .visit_field::<i32>("numPoints", Self::VT_NUMPOINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pedigree", Self::VT_PEDIGREE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("category", Self::VT_CATEGORY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idStateVector", Self::VT_IDSTATEVECTOR, false)?
     .visit_field::<bool>("hasMnvr", Self::VT_HASMNVR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("idManeuvers", Self::VT_IDMANEUVERS, false)?
     .visit_field::<bool>("hasCov", Self::VT_HASCOV, false)?
     .visit_field::<bool>("hasAccel", Self::VT_HASACCEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("centBody", Self::VT_CENTBODY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("integrator", Self::VT_INTEGRATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("geopotentialModel", Self::VT_GEOPOTENTIALMODEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dragModel", Self::VT_DRAGMODEL, false)?
     .visit_field::<bool>("lunarSolar", Self::VT_LUNARSOLAR, false)?
     .visit_field::<bool>("solidEarthTides", Self::VT_SOLIDEARTHTIDES, false)?
     .visit_field::<f64>("bDot", Self::VT_BDOT, false)?
     .visit_field::<f64>("edr", Self::VT_EDR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("interpolation", Self::VT_INTERPOLATION, false)?
     .visit_field::<i32>("interpolationDegree", Self::VT_INTERPOLATIONDEGREE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("filename", Self::VT_FILENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("comments", Self::VT_COMMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("descriptor", Self::VT_DESCRIPTOR, false)?
     .visit_field::<EphemerisSet_Abridged_referenceFrame_Enum>("referenceFrame", Self::VT_REFERENCEFRAME, false)?
     .visit_field::<EphemerisSet_Abridged_covReferenceFrame_Enum>("covReferenceFrame", Self::VT_COVREFERENCEFRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<EphemerisSet_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transactionId", Self::VT_TRANSACTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct EphemerisSet_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pointStartTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub usableStartTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pointEndTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub usableEndTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stepSize: i32,
    pub numPoints: i32,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pedigree: Option<flatbuffers::WIPOffset<&'a str>>,
    pub category: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idStateVector: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hasMnvr: bool,
    pub idManeuvers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub hasCov: bool,
    pub hasAccel: bool,
    pub centBody: Option<flatbuffers::WIPOffset<&'a str>>,
    pub integrator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub geopotentialModel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dragModel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lunarSolar: bool,
    pub solidEarthTides: bool,
    pub bDot: f64,
    pub edr: f64,
    pub interpolation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub interpolationDegree: i32,
    pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
    pub comments: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub descriptor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub referenceFrame: EphemerisSet_Abridged_referenceFrame_Enum,
    pub covReferenceFrame: EphemerisSet_Abridged_covReferenceFrame_Enum,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: EphemerisSet_Abridged_dataMode_Enum,
    pub satNo: i32,
    pub transactionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EphemerisSet_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    EphemerisSet_AbridgedArgs {
      id: None,
      classificationMarking: None,
      idOnOrbit: None,
      origObjectId: None,
      pointStartTime: None,
      usableStartTime: None,
      pointEndTime: None,
      usableEndTime: None,
      stepSize: 0,
      numPoints: 0,
      type_: None,
      pedigree: None,
      category: None,
      idStateVector: None,
      hasMnvr: false,
      idManeuvers: None,
      hasCov: false,
      hasAccel: false,
      centBody: None,
      integrator: None,
      geopotentialModel: None,
      dragModel: None,
      lunarSolar: false,
      solidEarthTides: false,
      bDot: 0.0,
      edr: 0.0,
      interpolation: None,
      interpolationDegree: 0,
      filename: None,
      comments: None,
      description: None,
      descriptor: None,
      referenceFrame: EphemerisSet_Abridged_referenceFrame_Enum::J2000,
      covReferenceFrame: EphemerisSet_Abridged_covReferenceFrame_Enum::J2000,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: EphemerisSet_Abridged_dataMode_Enum::REAL,
      satNo: 0,
      transactionId: None,
      origNetwork: None,
    }
  }
}

pub struct EphemerisSet_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EphemerisSet_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_pointStartTime(&mut self, pointStartTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_POINTSTARTTIME, pointStartTime);
  }
  #[inline]
  pub fn add_usableStartTime(&mut self, usableStartTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_USABLESTARTTIME, usableStartTime);
  }
  #[inline]
  pub fn add_pointEndTime(&mut self, pointEndTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_POINTENDTIME, pointEndTime);
  }
  #[inline]
  pub fn add_usableEndTime(&mut self, usableEndTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_USABLEENDTIME, usableEndTime);
  }
  #[inline]
  pub fn add_stepSize(&mut self, stepSize: i32) {
    self.fbb_.push_slot::<i32>(EphemerisSet_Abridged::VT_STEPSIZE, stepSize, 0);
  }
  #[inline]
  pub fn add_numPoints(&mut self, numPoints: i32) {
    self.fbb_.push_slot::<i32>(EphemerisSet_Abridged::VT_NUMPOINTS, numPoints, 0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_pedigree(&mut self, pedigree: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_PEDIGREE, pedigree);
  }
  #[inline]
  pub fn add_category(&mut self, category: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_CATEGORY, category);
  }
  #[inline]
  pub fn add_idStateVector(&mut self, idStateVector: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_IDSTATEVECTOR, idStateVector);
  }
  #[inline]
  pub fn add_hasMnvr(&mut self, hasMnvr: bool) {
    self.fbb_.push_slot::<bool>(EphemerisSet_Abridged::VT_HASMNVR, hasMnvr, false);
  }
  #[inline]
  pub fn add_idManeuvers(&mut self, idManeuvers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_IDMANEUVERS, idManeuvers);
  }
  #[inline]
  pub fn add_hasCov(&mut self, hasCov: bool) {
    self.fbb_.push_slot::<bool>(EphemerisSet_Abridged::VT_HASCOV, hasCov, false);
  }
  #[inline]
  pub fn add_hasAccel(&mut self, hasAccel: bool) {
    self.fbb_.push_slot::<bool>(EphemerisSet_Abridged::VT_HASACCEL, hasAccel, false);
  }
  #[inline]
  pub fn add_centBody(&mut self, centBody: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_CENTBODY, centBody);
  }
  #[inline]
  pub fn add_integrator(&mut self, integrator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_INTEGRATOR, integrator);
  }
  #[inline]
  pub fn add_geopotentialModel(&mut self, geopotentialModel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_GEOPOTENTIALMODEL, geopotentialModel);
  }
  #[inline]
  pub fn add_dragModel(&mut self, dragModel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_DRAGMODEL, dragModel);
  }
  #[inline]
  pub fn add_lunarSolar(&mut self, lunarSolar: bool) {
    self.fbb_.push_slot::<bool>(EphemerisSet_Abridged::VT_LUNARSOLAR, lunarSolar, false);
  }
  #[inline]
  pub fn add_solidEarthTides(&mut self, solidEarthTides: bool) {
    self.fbb_.push_slot::<bool>(EphemerisSet_Abridged::VT_SOLIDEARTHTIDES, solidEarthTides, false);
  }
  #[inline]
  pub fn add_bDot(&mut self, bDot: f64) {
    self.fbb_.push_slot::<f64>(EphemerisSet_Abridged::VT_BDOT, bDot, 0.0);
  }
  #[inline]
  pub fn add_edr(&mut self, edr: f64) {
    self.fbb_.push_slot::<f64>(EphemerisSet_Abridged::VT_EDR, edr, 0.0);
  }
  #[inline]
  pub fn add_interpolation(&mut self, interpolation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_INTERPOLATION, interpolation);
  }
  #[inline]
  pub fn add_interpolationDegree(&mut self, interpolationDegree: i32) {
    self.fbb_.push_slot::<i32>(EphemerisSet_Abridged::VT_INTERPOLATIONDEGREE, interpolationDegree, 0);
  }
  #[inline]
  pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_FILENAME, filename);
  }
  #[inline]
  pub fn add_comments(&mut self, comments: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_COMMENTS, comments);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_descriptor(&mut self, descriptor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_DESCRIPTOR, descriptor);
  }
  #[inline]
  pub fn add_referenceFrame(&mut self, referenceFrame: EphemerisSet_Abridged_referenceFrame_Enum) {
    self.fbb_.push_slot::<EphemerisSet_Abridged_referenceFrame_Enum>(EphemerisSet_Abridged::VT_REFERENCEFRAME, referenceFrame, EphemerisSet_Abridged_referenceFrame_Enum::J2000);
  }
  #[inline]
  pub fn add_covReferenceFrame(&mut self, covReferenceFrame: EphemerisSet_Abridged_covReferenceFrame_Enum) {
    self.fbb_.push_slot::<EphemerisSet_Abridged_covReferenceFrame_Enum>(EphemerisSet_Abridged::VT_COVREFERENCEFRAME, covReferenceFrame, EphemerisSet_Abridged_covReferenceFrame_Enum::J2000);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: EphemerisSet_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<EphemerisSet_Abridged_dataMode_Enum>(EphemerisSet_Abridged::VT_DATAMODE, dataMode, EphemerisSet_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(EphemerisSet_Abridged::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_transactionId(&mut self, transactionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_TRANSACTIONID, transactionId);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EphemerisSet_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EphemerisSet_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EphemerisSet_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EphemerisSet_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EphemerisSet_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EphemerisSet_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("pointStartTime", &self.pointStartTime());
      ds.field("usableStartTime", &self.usableStartTime());
      ds.field("pointEndTime", &self.pointEndTime());
      ds.field("usableEndTime", &self.usableEndTime());
      ds.field("stepSize", &self.stepSize());
      ds.field("numPoints", &self.numPoints());
      ds.field("type_", &self.type_());
      ds.field("pedigree", &self.pedigree());
      ds.field("category", &self.category());
      ds.field("idStateVector", &self.idStateVector());
      ds.field("hasMnvr", &self.hasMnvr());
      ds.field("idManeuvers", &self.idManeuvers());
      ds.field("hasCov", &self.hasCov());
      ds.field("hasAccel", &self.hasAccel());
      ds.field("centBody", &self.centBody());
      ds.field("integrator", &self.integrator());
      ds.field("geopotentialModel", &self.geopotentialModel());
      ds.field("dragModel", &self.dragModel());
      ds.field("lunarSolar", &self.lunarSolar());
      ds.field("solidEarthTides", &self.solidEarthTides());
      ds.field("bDot", &self.bDot());
      ds.field("edr", &self.edr());
      ds.field("interpolation", &self.interpolation());
      ds.field("interpolationDegree", &self.interpolationDegree());
      ds.field("filename", &self.filename());
      ds.field("comments", &self.comments());
      ds.field("description", &self.description());
      ds.field("descriptor", &self.descriptor());
      ds.field("referenceFrame", &self.referenceFrame());
      ds.field("covReferenceFrame", &self.covReferenceFrame());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("satNo", &self.satNo());
      ds.field("transactionId", &self.transactionId());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EphemerisSet_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idOnOrbit: Option<String>,
  pub origObjectId: Option<String>,
  pub pointStartTime: Option<String>,
  pub usableStartTime: Option<String>,
  pub pointEndTime: Option<String>,
  pub usableEndTime: Option<String>,
  pub stepSize: i32,
  pub numPoints: i32,
  pub type_: Option<String>,
  pub pedigree: Option<String>,
  pub category: Option<String>,
  pub idStateVector: Option<String>,
  pub hasMnvr: bool,
  pub idManeuvers: Option<Vec<String>>,
  pub hasCov: bool,
  pub hasAccel: bool,
  pub centBody: Option<String>,
  pub integrator: Option<String>,
  pub geopotentialModel: Option<String>,
  pub dragModel: Option<String>,
  pub lunarSolar: bool,
  pub solidEarthTides: bool,
  pub bDot: f64,
  pub edr: f64,
  pub interpolation: Option<String>,
  pub interpolationDegree: i32,
  pub filename: Option<String>,
  pub comments: Option<String>,
  pub description: Option<String>,
  pub descriptor: Option<String>,
  pub referenceFrame: EphemerisSet_Abridged_referenceFrame_Enum,
  pub covReferenceFrame: EphemerisSet_Abridged_covReferenceFrame_Enum,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: EphemerisSet_Abridged_dataMode_Enum,
  pub satNo: i32,
  pub transactionId: Option<String>,
  pub origNetwork: Option<String>,
}
impl Default for EphemerisSet_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idOnOrbit: None,
      origObjectId: None,
      pointStartTime: None,
      usableStartTime: None,
      pointEndTime: None,
      usableEndTime: None,
      stepSize: 0,
      numPoints: 0,
      type_: None,
      pedigree: None,
      category: None,
      idStateVector: None,
      hasMnvr: false,
      idManeuvers: None,
      hasCov: false,
      hasAccel: false,
      centBody: None,
      integrator: None,
      geopotentialModel: None,
      dragModel: None,
      lunarSolar: false,
      solidEarthTides: false,
      bDot: 0.0,
      edr: 0.0,
      interpolation: None,
      interpolationDegree: 0,
      filename: None,
      comments: None,
      description: None,
      descriptor: None,
      referenceFrame: EphemerisSet_Abridged_referenceFrame_Enum::J2000,
      covReferenceFrame: EphemerisSet_Abridged_covReferenceFrame_Enum::J2000,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      dataMode: EphemerisSet_Abridged_dataMode_Enum::REAL,
      satNo: 0,
      transactionId: None,
      origNetwork: None,
    }
  }
}
impl EphemerisSet_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EphemerisSet_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pointStartTime = self.pointStartTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let usableStartTime = self.usableStartTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pointEndTime = self.pointEndTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let usableEndTime = self.usableEndTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stepSize = self.stepSize;
    let numPoints = self.numPoints;
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pedigree = self.pedigree.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let category = self.category.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idStateVector = self.idStateVector.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let hasMnvr = self.hasMnvr;
    let idManeuvers = self.idManeuvers.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let hasCov = self.hasCov;
    let hasAccel = self.hasAccel;
    let centBody = self.centBody.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let integrator = self.integrator.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let geopotentialModel = self.geopotentialModel.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dragModel = self.dragModel.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lunarSolar = self.lunarSolar;
    let solidEarthTides = self.solidEarthTides;
    let bDot = self.bDot;
    let edr = self.edr;
    let interpolation = self.interpolation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let interpolationDegree = self.interpolationDegree;
    let filename = self.filename.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let comments = self.comments.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let description = self.description.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let descriptor = self.descriptor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let referenceFrame = self.referenceFrame;
    let covReferenceFrame = self.covReferenceFrame;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let satNo = self.satNo;
    let transactionId = self.transactionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    EphemerisSet_Abridged::create(_fbb, &EphemerisSet_AbridgedArgs{
      id,
      classificationMarking,
      idOnOrbit,
      origObjectId,
      pointStartTime,
      usableStartTime,
      pointEndTime,
      usableEndTime,
      stepSize,
      numPoints,
      type_,
      pedigree,
      category,
      idStateVector,
      hasMnvr,
      idManeuvers,
      hasCov,
      hasAccel,
      centBody,
      integrator,
      geopotentialModel,
      dragModel,
      lunarSolar,
      solidEarthTides,
      bDot,
      edr,
      interpolation,
      interpolationDegree,
      filename,
      comments,
      description,
      descriptor,
      referenceFrame,
      covReferenceFrame,
      createdAt,
      createdBy,
      source,
      origin,
      dataMode,
      satNo,
      transactionId,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EphemerisSet_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ephemeris_set_abridged_unchecked`.
pub fn root_as_ephemeris_set_abridged(buf: &[u8]) -> Result<EphemerisSet_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EphemerisSet_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EphemerisSet_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ephemeris_set_abridged_unchecked`.
pub fn size_prefixed_root_as_ephemeris_set_abridged(buf: &[u8]) -> Result<EphemerisSet_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EphemerisSet_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EphemerisSet_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ephemeris_set_abridged_unchecked`.
pub fn root_as_ephemeris_set_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EphemerisSet_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EphemerisSet_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EphemerisSet_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ephemeris_set_abridged_unchecked`.
pub fn size_prefixed_root_as_ephemeris_set_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EphemerisSet_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EphemerisSet_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EphemerisSet_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EphemerisSet_Abridged`.
pub unsafe fn root_as_ephemeris_set_abridged_unchecked(buf: &[u8]) -> EphemerisSet_Abridged {
  flatbuffers::root_unchecked::<EphemerisSet_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EphemerisSet_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EphemerisSet_Abridged`.
pub unsafe fn size_prefixed_root_as_ephemeris_set_abridged_unchecked(buf: &[u8]) -> EphemerisSet_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<EphemerisSet_Abridged>(buf)
}
pub const EPHEMERIS_SET_ABRIDGED_IDENTIFIER: &str = "EPHE";

#[inline]
pub fn ephemeris_set_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EPHEMERIS_SET_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn ephemeris_set_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EPHEMERIS_SET_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_ephemeris_set_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<EphemerisSet_Abridged<'a>>) {
  fbb.finish(root, Some(EPHEMERIS_SET_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_ephemeris_set_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<EphemerisSet_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(EPHEMERIS_SET_ABRIDGED_IDENTIFIER));
}
