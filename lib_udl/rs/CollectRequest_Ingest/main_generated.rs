// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COLLECT_REQUEST_INGEST_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COLLECT_REQUEST_INGEST_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COLLECT_REQUEST_INGEST_DATA_MODE_ENUM: [CollectRequest_Ingest_dataMode_Enum; 4] = [
  CollectRequest_Ingest_dataMode_Enum::REAL,
  CollectRequest_Ingest_dataMode_Enum::TEST,
  CollectRequest_Ingest_dataMode_Enum::SIMULATED,
  CollectRequest_Ingest_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CollectRequest_Ingest_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl CollectRequest_Ingest_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CollectRequest_Ingest_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CollectRequest_Ingest_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CollectRequest_Ingest_dataMode_Enum {
    type Output = CollectRequest_Ingest_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CollectRequest_Ingest_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CollectRequest_Ingest_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CollectRequest_Ingest_dataMode_Enum {}
pub enum CollectRequest_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Collect Requests support several types of individual requests, or planned/scheduled tasks on sensors and/or orbital objects. Options are provided to accomodate most common sensor contact and collection applications, including single sensor-object tasking, search operations, and TT&C support. Multiple requests originating from a plan or schedule may be associated to a sensor plan if desired.
pub struct CollectRequest_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CollectRequest_Ingest<'a> {
  type Inner = CollectRequest_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CollectRequest_Ingest<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDPARENTREQ: flatbuffers::VOffsetT = 8;
  pub const VT_MSGTYPE: flatbuffers::VOffsetT = 10;
  pub const VT_MSGCREATEDATE: flatbuffers::VOffsetT = 12;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 14;
  pub const VT_IDPLAN: flatbuffers::VOffsetT = 16;
  pub const VT_PLANINDEX: flatbuffers::VOffsetT = 18;
  pub const VT_TASKID: flatbuffers::VOffsetT = 20;
  pub const VT_DWELLID: flatbuffers::VOffsetT = 22;
  pub const VT_EXTERNALID: flatbuffers::VOffsetT = 24;
  pub const VT_IDSENSOR: flatbuffers::VOffsetT = 26;
  pub const VT_ORIGSENSORID: flatbuffers::VOffsetT = 28;
  pub const VT_OBTYPE: flatbuffers::VOffsetT = 30;
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 32;
  pub const VT_TASKCATEGORY: flatbuffers::VOffsetT = 34;
  pub const VT_SUFFIX: flatbuffers::VOffsetT = 36;
  pub const VT_UCTFOLLOWUP: flatbuffers::VOffsetT = 38;
  pub const VT_STARTTIME: flatbuffers::VOffsetT = 40;
  pub const VT_ENDTIME: flatbuffers::VOffsetT = 42;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 44;
  pub const VT_SATNO: flatbuffers::VOffsetT = 46;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 48;
  pub const VT_TASKGROUP: flatbuffers::VOffsetT = 50;
  pub const VT_IRON: flatbuffers::VOffsetT = 52;
  pub const VT_ORBITREGIME: flatbuffers::VOffsetT = 54;
  pub const VT_TARGETSIZE: flatbuffers::VOffsetT = 56;
  pub const VT_RCSMIN: flatbuffers::VOffsetT = 58;
  pub const VT_RCS: flatbuffers::VOffsetT = 60;
  pub const VT_RCSMAX: flatbuffers::VOffsetT = 62;
  pub const VT_FREQMIN: flatbuffers::VOffsetT = 64;
  pub const VT_FREQ: flatbuffers::VOffsetT = 66;
  pub const VT_FREQMAX: flatbuffers::VOffsetT = 68;
  pub const VT_POLARIZATION: flatbuffers::VOffsetT = 70;
  pub const VT_VISMAGMIN: flatbuffers::VOffsetT = 72;
  pub const VT_VISMAG: flatbuffers::VOffsetT = 74;
  pub const VT_VISMAGMAX: flatbuffers::VOffsetT = 76;
  pub const VT_SPECTRALMODEL: flatbuffers::VOffsetT = 78;
  pub const VT_REFLECTANCE: flatbuffers::VOffsetT = 80;
  pub const VT_IRRADIANCE: flatbuffers::VOffsetT = 82;
  pub const VT_NUMFRAMES: flatbuffers::VOffsetT = 84;
  pub const VT_FRAMERATE: flatbuffers::VOffsetT = 86;
  pub const VT_INTEGRATIONTIME: flatbuffers::VOffsetT = 88;
  pub const VT_NUMTRACKS: flatbuffers::VOffsetT = 90;
  pub const VT_NUMOBS: flatbuffers::VOffsetT = 92;
  pub const VT_DURATION: flatbuffers::VOffsetT = 94;
  pub const VT_SRCHPATTERN: flatbuffers::VOffsetT = 96;
  pub const VT_SCENARIO: flatbuffers::VOffsetT = 98;
  pub const VT_IDELSET: flatbuffers::VOffsetT = 100;
  pub const VT_IDMANIFOLD: flatbuffers::VOffsetT = 102;
  pub const VT_IDSTATEVECTOR: flatbuffers::VOffsetT = 104;
  pub const VT_ESID: flatbuffers::VOffsetT = 106;
  pub const VT_EPOCH: flatbuffers::VOffsetT = 108;
  pub const VT_SEMIMAJORAXIS: flatbuffers::VOffsetT = 110;
  pub const VT_ECCENTRICITY: flatbuffers::VOffsetT = 112;
  pub const VT_INCLINATION: flatbuffers::VOffsetT = 114;
  pub const VT_RAAN: flatbuffers::VOffsetT = 116;
  pub const VT_ARGOFPERIGEE: flatbuffers::VOffsetT = 118;
  pub const VT_TRUEANOMOLY: flatbuffers::VOffsetT = 120;
  pub const VT_RA: flatbuffers::VOffsetT = 122;
  pub const VT_DEC: flatbuffers::VOffsetT = 124;
  pub const VT_AZ: flatbuffers::VOffsetT = 126;
  pub const VT_EL: flatbuffers::VOffsetT = 128;
  pub const VT_RANGE: flatbuffers::VOffsetT = 130;
  pub const VT_EXTENTAZ: flatbuffers::VOffsetT = 132;
  pub const VT_EXTENTEL: flatbuffers::VOffsetT = 134;
  pub const VT_EXTENTRANGE: flatbuffers::VOffsetT = 136;
  pub const VT_LAT: flatbuffers::VOffsetT = 138;
  pub const VT_LON: flatbuffers::VOffsetT = 140;
  pub const VT_ALT: flatbuffers::VOffsetT = 142;
  pub const VT_STOPLAT: flatbuffers::VOffsetT = 144;
  pub const VT_STOPLON: flatbuffers::VOffsetT = 146;
  pub const VT_STOPALT: flatbuffers::VOffsetT = 148;
  pub const VT_SRCHINC: flatbuffers::VOffsetT = 150;
  pub const VT_XANGLE: flatbuffers::VOffsetT = 152;
  pub const VT_YANGLE: flatbuffers::VOffsetT = 154;
  pub const VT_ORIENTANGLE: flatbuffers::VOffsetT = 156;
  pub const VT_CUSTOMER: flatbuffers::VOffsetT = 158;
  pub const VT_NOTES: flatbuffers::VOffsetT = 160;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 162;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 164;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 166;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 168;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 170;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 172;
  pub const VT_STATEVECTOR: flatbuffers::VOffsetT = 174;
  pub const VT_ELSET: flatbuffers::VOffsetT = 176;
  pub const VT_TAGS: flatbuffers::VOffsetT = 178;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CollectRequest_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CollectRequest_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<CollectRequest_Ingest<'bldr>> {
    let mut builder = CollectRequest_IngestBuilder::new(_fbb);
    builder.add_orientAngle(args.orientAngle);
    builder.add_yAngle(args.yAngle);
    builder.add_xAngle(args.xAngle);
    builder.add_srchInc(args.srchInc);
    builder.add_stopAlt(args.stopAlt);
    builder.add_stopLon(args.stopLon);
    builder.add_stopLat(args.stopLat);
    builder.add_alt(args.alt);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    builder.add_extentRange(args.extentRange);
    builder.add_extentEl(args.extentEl);
    builder.add_extentAz(args.extentAz);
    builder.add_range(args.range);
    builder.add_el(args.el);
    builder.add_az(args.az);
    builder.add_dec(args.dec);
    builder.add_ra(args.ra);
    builder.add_trueAnomoly(args.trueAnomoly);
    builder.add_argOfPerigee(args.argOfPerigee);
    builder.add_raan(args.raan);
    builder.add_inclination(args.inclination);
    builder.add_eccentricity(args.eccentricity);
    builder.add_semiMajorAxis(args.semiMajorAxis);
    builder.add_integrationTime(args.integrationTime);
    builder.add_frameRate(args.frameRate);
    builder.add_irradiance(args.irradiance);
    builder.add_reflectance(args.reflectance);
    builder.add_visMagMax(args.visMagMax);
    builder.add_visMag(args.visMag);
    builder.add_visMagMin(args.visMagMin);
    builder.add_freqMax(args.freqMax);
    builder.add_freq(args.freq);
    builder.add_freqMin(args.freqMin);
    builder.add_rcsMax(args.rcsMax);
    builder.add_rcs(args.rcs);
    builder.add_rcsMin(args.rcsMin);
    builder.add_targetSize(args.targetSize);
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.elset { builder.add_elset(x); }
    if let Some(x) = args.stateVector { builder.add_stateVector(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.notes { builder.add_notes(x); }
    if let Some(x) = args.customer { builder.add_customer(x); }
    if let Some(x) = args.epoch { builder.add_epoch(x); }
    if let Some(x) = args.esId { builder.add_esId(x); }
    if let Some(x) = args.idStateVector { builder.add_idStateVector(x); }
    if let Some(x) = args.idManifold { builder.add_idManifold(x); }
    if let Some(x) = args.idElset { builder.add_idElset(x); }
    if let Some(x) = args.scenario { builder.add_scenario(x); }
    if let Some(x) = args.srchPattern { builder.add_srchPattern(x); }
    builder.add_duration(args.duration);
    builder.add_numObs(args.numObs);
    builder.add_numTracks(args.numTracks);
    builder.add_numFrames(args.numFrames);
    if let Some(x) = args.spectralModel { builder.add_spectralModel(x); }
    if let Some(x) = args.polarization { builder.add_polarization(x); }
    if let Some(x) = args.orbitRegime { builder.add_orbitRegime(x); }
    builder.add_iron(args.iron);
    if let Some(x) = args.taskGroup { builder.add_taskGroup(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.endTime { builder.add_endTime(x); }
    if let Some(x) = args.startTime { builder.add_startTime(x); }
    if let Some(x) = args.suffix { builder.add_suffix(x); }
    builder.add_taskCategory(args.taskCategory);
    if let Some(x) = args.priority { builder.add_priority(x); }
    if let Some(x) = args.obType { builder.add_obType(x); }
    if let Some(x) = args.origSensorId { builder.add_origSensorId(x); }
    if let Some(x) = args.idSensor { builder.add_idSensor(x); }
    if let Some(x) = args.externalId { builder.add_externalId(x); }
    if let Some(x) = args.dwellId { builder.add_dwellId(x); }
    if let Some(x) = args.taskId { builder.add_taskId(x); }
    builder.add_planIndex(args.planIndex);
    if let Some(x) = args.idPlan { builder.add_idPlan(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.msgCreateDate { builder.add_msgCreateDate(x); }
    if let Some(x) = args.msgType { builder.add_msgType(x); }
    if let Some(x) = args.idParentReq { builder.add_idParentReq(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_uctFollowUp(args.uctFollowUp);
    builder.finish()
  }

  pub fn unpack(&self) -> CollectRequest_IngestT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idParentReq = self.idParentReq().map(|x| {
      x.to_string()
    });
    let msgType = self.msgType().map(|x| {
      x.to_string()
    });
    let msgCreateDate = self.msgCreateDate().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let idPlan = self.idPlan().map(|x| {
      x.to_string()
    });
    let planIndex = self.planIndex();
    let taskId = self.taskId().map(|x| {
      x.to_string()
    });
    let dwellId = self.dwellId().map(|x| {
      x.to_string()
    });
    let externalId = self.externalId().map(|x| {
      x.to_string()
    });
    let idSensor = self.idSensor().map(|x| {
      x.to_string()
    });
    let origSensorId = self.origSensorId().map(|x| {
      x.to_string()
    });
    let obType = self.obType().map(|x| {
      x.to_string()
    });
    let priority = self.priority().map(|x| {
      x.to_string()
    });
    let taskCategory = self.taskCategory();
    let suffix = self.suffix().map(|x| {
      x.to_string()
    });
    let uctFollowUp = self.uctFollowUp();
    let startTime = self.startTime().map(|x| {
      x.to_string()
    });
    let endTime = self.endTime().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let satNo = self.satNo();
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let taskGroup = self.taskGroup().map(|x| {
      x.to_string()
    });
    let iron = self.iron();
    let orbitRegime = self.orbitRegime().map(|x| {
      x.to_string()
    });
    let targetSize = self.targetSize();
    let rcsMin = self.rcsMin();
    let rcs = self.rcs();
    let rcsMax = self.rcsMax();
    let freqMin = self.freqMin();
    let freq = self.freq();
    let freqMax = self.freqMax();
    let polarization = self.polarization().map(|x| {
      x.to_string()
    });
    let visMagMin = self.visMagMin();
    let visMag = self.visMag();
    let visMagMax = self.visMagMax();
    let spectralModel = self.spectralModel().map(|x| {
      x.to_string()
    });
    let reflectance = self.reflectance();
    let irradiance = self.irradiance();
    let numFrames = self.numFrames();
    let frameRate = self.frameRate();
    let integrationTime = self.integrationTime();
    let numTracks = self.numTracks();
    let numObs = self.numObs();
    let duration = self.duration();
    let srchPattern = self.srchPattern().map(|x| {
      x.to_string()
    });
    let scenario = self.scenario().map(|x| {
      x.to_string()
    });
    let idElset = self.idElset().map(|x| {
      x.to_string()
    });
    let idManifold = self.idManifold().map(|x| {
      x.to_string()
    });
    let idStateVector = self.idStateVector().map(|x| {
      x.to_string()
    });
    let esId = self.esId().map(|x| {
      x.to_string()
    });
    let epoch = self.epoch().map(|x| {
      x.to_string()
    });
    let semiMajorAxis = self.semiMajorAxis();
    let eccentricity = self.eccentricity();
    let inclination = self.inclination();
    let raan = self.raan();
    let argOfPerigee = self.argOfPerigee();
    let trueAnomoly = self.trueAnomoly();
    let ra = self.ra();
    let dec = self.dec();
    let az = self.az();
    let el = self.el();
    let range = self.range();
    let extentAz = self.extentAz();
    let extentEl = self.extentEl();
    let extentRange = self.extentRange();
    let lat = self.lat();
    let lon = self.lon();
    let alt = self.alt();
    let stopLat = self.stopLat();
    let stopLon = self.stopLon();
    let stopAlt = self.stopAlt();
    let srchInc = self.srchInc();
    let xAngle = self.xAngle();
    let yAngle = self.yAngle();
    let orientAngle = self.orientAngle();
    let customer = self.customer().map(|x| {
      x.to_string()
    });
    let notes = self.notes().map(|x| {
      x.to_string()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let stateVector = self.stateVector().map(|x| {
      x.to_string()
    });
    let elset = self.elset().map(|x| {
      x.to_string()
    });
    let tags = self.tags().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    CollectRequest_IngestT {
      id,
      classificationMarking,
      idParentReq,
      msgType,
      msgCreateDate,
      type_,
      idPlan,
      planIndex,
      taskId,
      dwellId,
      externalId,
      idSensor,
      origSensorId,
      obType,
      priority,
      taskCategory,
      suffix,
      uctFollowUp,
      startTime,
      endTime,
      idOnOrbit,
      satNo,
      origObjectId,
      taskGroup,
      iron,
      orbitRegime,
      targetSize,
      rcsMin,
      rcs,
      rcsMax,
      freqMin,
      freq,
      freqMax,
      polarization,
      visMagMin,
      visMag,
      visMagMax,
      spectralModel,
      reflectance,
      irradiance,
      numFrames,
      frameRate,
      integrationTime,
      numTracks,
      numObs,
      duration,
      srchPattern,
      scenario,
      idElset,
      idManifold,
      idStateVector,
      esId,
      epoch,
      semiMajorAxis,
      eccentricity,
      inclination,
      raan,
      argOfPerigee,
      trueAnomoly,
      ra,
      dec,
      az,
      el,
      range,
      extentAz,
      extentEl,
      extentRange,
      lat,
      lon,
      alt,
      stopLat,
      stopLon,
      stopAlt,
      srchInc,
      xAngle,
      yAngle,
      orientAngle,
      customer,
      notes,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      dataMode,
      stateVector,
      elset,
      tags,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: COLLECTREQUEST-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_CLASSIFICATIONMARKING, None)}
  }
  /// The unique ID of the collect request record from which this request originated. This may be used for cases of sensor-to-sensor tasking, such as tip/cue operations.
  /// Example: /// Example: da98671b-34db-47bf-8c8d-7c668b92c800
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idParentReq(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_IDPARENTREQ, None)}
  }
  /// The type of external message from which this request originated.
  /// Example: /// Example: SU67
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn msgType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_MSGTYPE, None)}
  }
  /// The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-04-25T08:17:01.346Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn msgCreateDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_MSGCREATEDATE, None)}
  }
  /// The type of this collect or contact request (DIRECTED SEARCH, DWELL, OBJECT, POL, RATE TRACK, SEARCH, SOI, STARE, TTC, VOLUME SEARCH, etc.).
  /// Example: /// Example: DWELL
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_TYPE_, None)}
  }
  /// Unique identifier of the parent plan or schedule associated with this request.  If null, this request is assumed not associated with a plan or schedule.
  /// Example: /// Example: REF-PLAN-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idPlan(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_IDPLAN, None)}
  }
  /// Index number (integer) for records within a collection plan or schedule.
  /// Example: /// Example: 8
  /// Constraints: No constraints specified.
  #[inline]
  pub fn planIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CollectRequest_Ingest::VT_PLANINDEX, Some(0)).unwrap()}
  }
  /// Task ID associated with this request.  A task ID may be associated with a single collect request or may be used to tie together the sub-requests of a full collect, for example a DWELL consisting of many dwell points.
  /// Example: /// Example: TASK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn taskId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_TASKID, None)}
  }
  /// The dwell ID associated with this request.  A dwell ID is dwell point specific and a DWELL request consist of many dwell point requests.
  /// Example: /// Example: DWELL-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn dwellId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_DWELLID, None)}
  }
  /// Optional ID from external systems.  This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: EXTERNAL-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn externalId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_EXTERNALID, None)}
  }
  /// Unique identifier of the requested/scheduled/planned sensor associated with this request.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
  /// Example: /// Example: REF-SENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_IDSENSOR, None)}
  }
  /// Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request. This may be an internal identifier and not necessarily a valid sensor ID.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origSensorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_ORIGSENSORID, None)}
  }
  /// Optional type of observation (EO, IR, RADAR, RF-ACTIVE, RF-PASSIVE, OTHER) requested.  This field may correspond to a request of a specific sensor, or to a general non sensor specific request.
  /// Example: /// Example: RADAR
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn obType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_OBTYPE, None)}
  }
  /// The priority of the collect request  (EMERGENCY, FLASH, IMMEDIATE, PRIORITY, ROUTINE).
  /// Example: /// Example: EMERGENCY
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn priority(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_PRIORITY, None)}
  }
  /// The (SSN) tasking category (1-5) associated with this request.  The tasking category defines the priority of gathering and transmitting the requested observational data.  Note that category definitions are sensor type specific.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn taskCategory(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CollectRequest_Ingest::VT_TASKCATEGORY, Some(0)).unwrap()}
  }
  /// The (SSN) tasking suffix (A-Z) associated with this request.  The suffix defines the amount of observational data and the frequency of collection.  Note that suffix definitions are sensor type specific.
  /// Example: /// Example: T
  /// Constraints: Minimum length = 0, Maximum length = 1
  #[inline]
  pub fn suffix(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_SUFFIX, None)}
  }
  /// Boolean indicating that this collect request is UCT follow-up.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn uctFollowUp(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CollectRequest_Ingest::VT_UCTFOLLOWUP, Some(false)).unwrap()}
  }
  /// The start time or earliest time of the collect or contact request window, in ISO 8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn startTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_STARTTIME, None)}
  }
  /// The end time of the collect or contact request window, in ISO 8601 UTC format.  If no endTime or duration is provided it is assumed the request is either ongoing or that the request is for a specified number of tracks (numTracks).  If both duration and endTime are provided, the endTime is assumed to take precedence.
  /// Example: /// Example: 2018-01-01T18:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn endTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_ENDTIME, None)}
  }
  /// Unique identifier of the target on-orbit object for this request.
  /// Example: /// Example: REF-ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_IDONORBIT, None)}
  }
  /// Satellite/catalog number of the target on-orbit object for this request.
  /// Example: /// Example: 101
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CollectRequest_Ingest::VT_SATNO, Some(0)).unwrap()}
  }
  /// Optional identifier provided by the data source to indicate the target object of this request. This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_ORIGOBJECTID, None)}
  }
  /// The tasking group to which the target object is assigned.
  /// Example: /// Example: 729
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn taskGroup(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_TASKGROUP, None)}
  }
  /// Inter-Range Operations Number.  Four-digit identifier used to schedule and identify AFSCN contact support for booster, launch, and on-orbit operations.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn iron(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CollectRequest_Ingest::VT_IRON, Some(0)).unwrap()}
  }
  /// The orbit regime of the target (GEO, HEO, LAUNCH, LEO, MEO, OTHER).
  /// Example: /// Example: GEO
  /// Constraints: Minimum length = 0, Maximum length = 12
  #[inline]
  pub fn orbitRegime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_ORBITREGIME, None)}
  }
  /// The minimum object (diameter) size, in meters, to be reported.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn targetSize(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_TARGETSIZE, Some(0.0)).unwrap()}
  }
  /// The minimum Radar Cross-Section of the target, in m^2.  If only minimum RCS is provided it is assumed to be minimum reportable RCS.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rcsMin(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_RCSMIN, Some(0.0)).unwrap()}
  }
  /// The Radar Cross-Section of the target, in m^2.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rcs(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_RCS, Some(0.0)).unwrap()}
  }
  /// The maximum Radar Cross-Section of the target, in m^2.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rcsMax(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_RCSMAX, Some(0.0)).unwrap()}
  }
  /// The minimum frequency of interest, in MHz.  If only minimum frequency is provided it is assumed to be minimum reportable frequency.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn freqMin(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_FREQMIN, Some(0.0)).unwrap()}
  }
  /// The estimated or expected emission frequency of the target, in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn freq(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_FREQ, Some(0.0)).unwrap()}
  }
  /// The maximum frequency of interest, in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn freqMax(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_FREQMAX, Some(0.0)).unwrap()}
  }
  /// The RF polarization (H, LHC, RHC, V).
  /// Example: /// Example: H
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn polarization(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_POLARIZATION, None)}
  }
  /// The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).  If only minimum vismag is provided it is assumed to be minimum reportable vismag.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn visMagMin(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_VISMAGMIN, Some(0.0)).unwrap()}
  }
  /// The estimated or expected visual magnitude of the target, in Magnitudes (M).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn visMag(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_VISMAG, Some(0.0)).unwrap()}
  }
  /// The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn visMagMax(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_VISMAGMAX, Some(0.0)).unwrap()}
  }
  /// The spectral model used for the irradiance calculation.
  /// Example: /// Example: Example Model
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn spectralModel(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_SPECTRALMODEL, None)}
  }
  /// The fraction of solar energy reflected from target.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn reflectance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_REFLECTANCE, Some(0.0)).unwrap()}
  }
  /// The target object irradiance value.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn irradiance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_IRRADIANCE, Some(0.0)).unwrap()}
  }
  /// For optical sensors, the requested number of frames to capture at each sensor step.
  /// Example: /// Example: 6
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numFrames(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CollectRequest_Ingest::VT_NUMFRAMES, Some(0)).unwrap()}
  }
  /// For optical sensors, the frame rate of the camera, in Hz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn frameRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_FRAMERATE, Some(0.0)).unwrap()}
  }
  /// For optical sensors, the integration time per camera frame, in milliseconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn integrationTime(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_INTEGRATIONTIME, Some(0.0)).unwrap()}
  }
  /// The number of requested tracks on the target.  If numTracks is not provided it is assumed to indicate all possible observations every pass over the request duration or within the request start/end window.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numTracks(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CollectRequest_Ingest::VT_NUMTRACKS, Some(0)).unwrap()}
  }
  /// The number of requested observations on the target.
  /// Example: /// Example: 9
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numObs(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CollectRequest_Ingest::VT_NUMOBS, Some(0)).unwrap()}
  }
  /// The duration of the collect request, in seconds.  If both duration and endTime are provided, the endTime is assumed to take precedence.
  /// Example: /// Example: 11
  /// Constraints: No constraints specified.
  #[inline]
  pub fn duration(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CollectRequest_Ingest::VT_DURATION, Some(0)).unwrap()}
  }
  /// The search pattern to be executed for this request (e.g. PICKET-FENCE, SCAN, etc.).
  /// Example: /// Example: SCAN
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn srchPattern(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_SRCHPATTERN, None)}
  }
  /// Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
  /// Example: /// Example: Example direction
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn scenario(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_SCENARIO, None)}
  }
  /// ID of the UDL Elset of the object associated with this request.
  /// Example: /// Example: REF-ELSET-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idElset(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_IDELSET, None)}
  }
  /// ID of the UDL Manifold Elset of the object associated with this request.  A Manifold Elset provides theoretical Keplerian orbital elements belonging to an object of interest's manifold describing a possible/theoretical orbit for an object of interest for tasking purposes.
  /// Example: /// Example: REF-MANIFOLD-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idManifold(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_IDMANIFOLD, None)}
  }
  /// ID of the UDL State Vector of the object or central vector associated with this request.
  /// Example: /// Example: STATEVECTOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idStateVector(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_IDSTATEVECTOR, None)}
  }
  /// ID of the UDL Ephemeris Set of the object associated with this request.
  /// Example: /// Example: ES-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn esId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_ESID, None)}
  }
  /// Epoch time, in ISO 8601 UTC format, of the orbital elements.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn epoch(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_EPOCH, None)}
  }
  /// The average of the periapsis and apoapsis distances, in kilometers. For circular orbits, the semimajor axis is the distance between the centers of the bodies.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn semiMajorAxis(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_SEMIMAJORAXIS, Some(0.0)).unwrap()}
  }
  /// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn eccentricity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_ECCENTRICITY, Some(0.0)).unwrap()}
  }
  /// The angle, in degrees, between the equator and the orbit plane when looking from the center of the Earth. Inclination ranges from 0-180 degrees, with 0-90 representing posigrade orbits and 90-180 representing retrograde orbits.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn inclination(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_INCLINATION, Some(0.0)).unwrap()}
  }
  /// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn raan(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_RAAN, Some(0.0)).unwrap()}
  }
  /// The argument of perigee is the angle, in degrees, formed between the perigee and the ascending node.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn argOfPerigee(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_ARGOFPERIGEE, Some(0.0)).unwrap()}
  }
  /// The true anomaly defines the angular position, in degrees, of the object on it's orbital path as measured from the orbit focal point at epoch.  The true anomaly is referenced from perigee.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trueAnomoly(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_TRUEANOMOLY, Some(0.0)).unwrap()}
  }
  /// The expected or directed right ascension angle, in degrees, for search or target acquisition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ra(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_RA, Some(0.0)).unwrap()}
  }
  /// The expected or directed declination angle, in degrees, for search or target acquisition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn dec(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_DEC, Some(0.0)).unwrap()}
  }
  /// The expected or directed azimuth angle, in degrees, for search or target acquisition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn az(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_AZ, Some(0.0)).unwrap()}
  }
  /// The expected or directed elevation angle, in degrees, for search or target acquisition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn el(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_EL, Some(0.0)).unwrap()}
  }
  /// The expected acquisition range or defined center range, in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn range(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_RANGE, Some(0.0)).unwrap()}
  }
  /// The extent of the azimuth angle, in degrees, from center azimuth to define a spatial volume.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn extentAz(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_EXTENTAZ, Some(0.0)).unwrap()}
  }
  /// The extent of the elevation angle, in degrees, from center elevation to define a spatial volume.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn extentEl(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_EXTENTEL, Some(0.0)).unwrap()}
  }
  /// The extent of the range, in km, from center range to define a spatial volume.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn extentRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_EXTENTRANGE, Some(0.0)).unwrap()}
  }
  /// WGS-84 latitude, in degrees. -90 to 90 degrees (negative values south of equator).  If an accompanying stopLat is provided, then the lat value can be assumed to be the starting latitude of a volume definition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).  If an accompanying stopLon is provided, then lon value can be assumed to be the starting longitude of a volume definition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_LON, Some(0.0)).unwrap()}
  }
  /// Height above WGS-84 ellipsoid (HAE), in kilometers.  If an accompanying stopAlt is provided, then alt value can be assumed to be the starting altitude of a volume definition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn alt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_ALT, Some(0.0)).unwrap()}
  }
  /// The stopping WGS-84 latitude of a volume definition, in degrees.  -90 to 90 degrees (negative values south of equator).  The stopLat value is only meaningful if a (starting) lat value is provided.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stopLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_STOPLAT, Some(0.0)).unwrap()}
  }
  /// The stopping WGS-84 longitude of a volume definition, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian).  The stopLon value is only meaningful if a (starting) lon value is provided.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stopLon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_STOPLON, Some(0.0)).unwrap()}
  }
  /// The stopping HAE WGS-84 height above ellipsoid (HAE), of a volume definition, in kilometers.  The stopAlt value is only meaningful if a (starting) alt value is provided.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stopAlt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_STOPALT, Some(0.0)).unwrap()}
  }
  /// The maximum inclination, in degrees, to be used in search operations.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn srchInc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_SRCHINC, Some(0.0)).unwrap()}
  }
  /// The angular distance, in degrees, in the sensor-x direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn xAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_XANGLE, Some(0.0)).unwrap()}
  }
  /// The angular distance, in degrees, in the sensor-y direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn yAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_YANGLE, Some(0.0)).unwrap()}
  }
  /// The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.  A positive value indicates clockwise rotation about the sensor boresight vector.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn orientAngle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CollectRequest_Ingest::VT_ORIENTANGLE, Some(0.0)).unwrap()}
  }
  /// The customer for this request.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn customer(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_CUSTOMER, None)}
  }
  /// Notes or comments associated with this request.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 512
  #[inline]
  pub fn notes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_NOTES, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: Example source
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_ORIGIN, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_ORIGNETWORK, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> CollectRequest_Ingest_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CollectRequest_Ingest_dataMode_Enum>(CollectRequest_Ingest::VT_DATAMODE, Some(CollectRequest_Ingest_dataMode_Enum::REAL)).unwrap()}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stateVector(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_STATEVECTOR, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elset(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CollectRequest_Ingest::VT_ELSET, None)}
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CollectRequest_Ingest::VT_TAGS, None)}
  }
}

impl flatbuffers::Verifiable for CollectRequest_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idParentReq", Self::VT_IDPARENTREQ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msgType", Self::VT_MSGTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("msgCreateDate", Self::VT_MSGCREATEDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idPlan", Self::VT_IDPLAN, false)?
     .visit_field::<i32>("planIndex", Self::VT_PLANINDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskId", Self::VT_TASKID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dwellId", Self::VT_DWELLID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("externalId", Self::VT_EXTERNALID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor", Self::VT_IDSENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId", Self::VT_ORIGSENSORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("obType", Self::VT_OBTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("priority", Self::VT_PRIORITY, false)?
     .visit_field::<i32>("taskCategory", Self::VT_TASKCATEGORY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("suffix", Self::VT_SUFFIX, false)?
     .visit_field::<bool>("uctFollowUp", Self::VT_UCTFOLLOWUP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("startTime", Self::VT_STARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endTime", Self::VT_ENDTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskGroup", Self::VT_TASKGROUP, false)?
     .visit_field::<i32>("iron", Self::VT_IRON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("orbitRegime", Self::VT_ORBITREGIME, false)?
     .visit_field::<f64>("targetSize", Self::VT_TARGETSIZE, false)?
     .visit_field::<f64>("rcsMin", Self::VT_RCSMIN, false)?
     .visit_field::<f64>("rcs", Self::VT_RCS, false)?
     .visit_field::<f64>("rcsMax", Self::VT_RCSMAX, false)?
     .visit_field::<f64>("freqMin", Self::VT_FREQMIN, false)?
     .visit_field::<f64>("freq", Self::VT_FREQ, false)?
     .visit_field::<f64>("freqMax", Self::VT_FREQMAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("polarization", Self::VT_POLARIZATION, false)?
     .visit_field::<f64>("visMagMin", Self::VT_VISMAGMIN, false)?
     .visit_field::<f64>("visMag", Self::VT_VISMAG, false)?
     .visit_field::<f64>("visMagMax", Self::VT_VISMAGMAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("spectralModel", Self::VT_SPECTRALMODEL, false)?
     .visit_field::<f64>("reflectance", Self::VT_REFLECTANCE, false)?
     .visit_field::<f64>("irradiance", Self::VT_IRRADIANCE, false)?
     .visit_field::<i32>("numFrames", Self::VT_NUMFRAMES, false)?
     .visit_field::<f64>("frameRate", Self::VT_FRAMERATE, false)?
     .visit_field::<f64>("integrationTime", Self::VT_INTEGRATIONTIME, false)?
     .visit_field::<i32>("numTracks", Self::VT_NUMTRACKS, false)?
     .visit_field::<i32>("numObs", Self::VT_NUMOBS, false)?
     .visit_field::<i32>("duration", Self::VT_DURATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("srchPattern", Self::VT_SRCHPATTERN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scenario", Self::VT_SCENARIO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idElset", Self::VT_IDELSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idManifold", Self::VT_IDMANIFOLD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idStateVector", Self::VT_IDSTATEVECTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("esId", Self::VT_ESID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("epoch", Self::VT_EPOCH, false)?
     .visit_field::<f64>("semiMajorAxis", Self::VT_SEMIMAJORAXIS, false)?
     .visit_field::<f64>("eccentricity", Self::VT_ECCENTRICITY, false)?
     .visit_field::<f64>("inclination", Self::VT_INCLINATION, false)?
     .visit_field::<f64>("raan", Self::VT_RAAN, false)?
     .visit_field::<f64>("argOfPerigee", Self::VT_ARGOFPERIGEE, false)?
     .visit_field::<f64>("trueAnomoly", Self::VT_TRUEANOMOLY, false)?
     .visit_field::<f64>("ra", Self::VT_RA, false)?
     .visit_field::<f64>("dec", Self::VT_DEC, false)?
     .visit_field::<f64>("az", Self::VT_AZ, false)?
     .visit_field::<f64>("el", Self::VT_EL, false)?
     .visit_field::<f64>("range", Self::VT_RANGE, false)?
     .visit_field::<f64>("extentAz", Self::VT_EXTENTAZ, false)?
     .visit_field::<f64>("extentEl", Self::VT_EXTENTEL, false)?
     .visit_field::<f64>("extentRange", Self::VT_EXTENTRANGE, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<f64>("alt", Self::VT_ALT, false)?
     .visit_field::<f64>("stopLat", Self::VT_STOPLAT, false)?
     .visit_field::<f64>("stopLon", Self::VT_STOPLON, false)?
     .visit_field::<f64>("stopAlt", Self::VT_STOPALT, false)?
     .visit_field::<f64>("srchInc", Self::VT_SRCHINC, false)?
     .visit_field::<f64>("xAngle", Self::VT_XANGLE, false)?
     .visit_field::<f64>("yAngle", Self::VT_YANGLE, false)?
     .visit_field::<f64>("orientAngle", Self::VT_ORIENTANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("customer", Self::VT_CUSTOMER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("notes", Self::VT_NOTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<CollectRequest_Ingest_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stateVector", Self::VT_STATEVECTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("elset", Self::VT_ELSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tags", Self::VT_TAGS, false)?
     .finish();
    Ok(())
  }
}
pub struct CollectRequest_IngestArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idParentReq: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub msgCreateDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idPlan: Option<flatbuffers::WIPOffset<&'a str>>,
    pub planIndex: i32,
    pub taskId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dwellId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub externalId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub priority: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskCategory: i32,
    pub suffix: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uctFollowUp: bool,
    pub startTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo: i32,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iron: i32,
    pub orbitRegime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub targetSize: f64,
    pub rcsMin: f64,
    pub rcs: f64,
    pub rcsMax: f64,
    pub freqMin: f64,
    pub freq: f64,
    pub freqMax: f64,
    pub polarization: Option<flatbuffers::WIPOffset<&'a str>>,
    pub visMagMin: f64,
    pub visMag: f64,
    pub visMagMax: f64,
    pub spectralModel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reflectance: f64,
    pub irradiance: f64,
    pub numFrames: i32,
    pub frameRate: f64,
    pub integrationTime: f64,
    pub numTracks: i32,
    pub numObs: i32,
    pub duration: i32,
    pub srchPattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scenario: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idElset: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idManifold: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idStateVector: Option<flatbuffers::WIPOffset<&'a str>>,
    pub esId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub epoch: Option<flatbuffers::WIPOffset<&'a str>>,
    pub semiMajorAxis: f64,
    pub eccentricity: f64,
    pub inclination: f64,
    pub raan: f64,
    pub argOfPerigee: f64,
    pub trueAnomoly: f64,
    pub ra: f64,
    pub dec: f64,
    pub az: f64,
    pub el: f64,
    pub range: f64,
    pub extentAz: f64,
    pub extentEl: f64,
    pub extentRange: f64,
    pub lat: f64,
    pub lon: f64,
    pub alt: f64,
    pub stopLat: f64,
    pub stopLon: f64,
    pub stopAlt: f64,
    pub srchInc: f64,
    pub xAngle: f64,
    pub yAngle: f64,
    pub orientAngle: f64,
    pub customer: Option<flatbuffers::WIPOffset<&'a str>>,
    pub notes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: CollectRequest_Ingest_dataMode_Enum,
    pub stateVector: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elset: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for CollectRequest_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    CollectRequest_IngestArgs {
      id: None,
      classificationMarking: None,
      idParentReq: None,
      msgType: None,
      msgCreateDate: None,
      type_: None,
      idPlan: None,
      planIndex: 0,
      taskId: None,
      dwellId: None,
      externalId: None,
      idSensor: None,
      origSensorId: None,
      obType: None,
      priority: None,
      taskCategory: 0,
      suffix: None,
      uctFollowUp: false,
      startTime: None,
      endTime: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      taskGroup: None,
      iron: 0,
      orbitRegime: None,
      targetSize: 0.0,
      rcsMin: 0.0,
      rcs: 0.0,
      rcsMax: 0.0,
      freqMin: 0.0,
      freq: 0.0,
      freqMax: 0.0,
      polarization: None,
      visMagMin: 0.0,
      visMag: 0.0,
      visMagMax: 0.0,
      spectralModel: None,
      reflectance: 0.0,
      irradiance: 0.0,
      numFrames: 0,
      frameRate: 0.0,
      integrationTime: 0.0,
      numTracks: 0,
      numObs: 0,
      duration: 0,
      srchPattern: None,
      scenario: None,
      idElset: None,
      idManifold: None,
      idStateVector: None,
      esId: None,
      epoch: None,
      semiMajorAxis: 0.0,
      eccentricity: 0.0,
      inclination: 0.0,
      raan: 0.0,
      argOfPerigee: 0.0,
      trueAnomoly: 0.0,
      ra: 0.0,
      dec: 0.0,
      az: 0.0,
      el: 0.0,
      range: 0.0,
      extentAz: 0.0,
      extentEl: 0.0,
      extentRange: 0.0,
      lat: 0.0,
      lon: 0.0,
      alt: 0.0,
      stopLat: 0.0,
      stopLon: 0.0,
      stopAlt: 0.0,
      srchInc: 0.0,
      xAngle: 0.0,
      yAngle: 0.0,
      orientAngle: 0.0,
      customer: None,
      notes: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: CollectRequest_Ingest_dataMode_Enum::REAL,
      stateVector: None,
      elset: None,
      tags: None,
    }
  }
}

pub struct CollectRequest_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CollectRequest_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idParentReq(&mut self, idParentReq: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_IDPARENTREQ, idParentReq);
  }
  #[inline]
  pub fn add_msgType(&mut self, msgType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_MSGTYPE, msgType);
  }
  #[inline]
  pub fn add_msgCreateDate(&mut self, msgCreateDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_MSGCREATEDATE, msgCreateDate);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_idPlan(&mut self, idPlan: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_IDPLAN, idPlan);
  }
  #[inline]
  pub fn add_planIndex(&mut self, planIndex: i32) {
    self.fbb_.push_slot::<i32>(CollectRequest_Ingest::VT_PLANINDEX, planIndex, 0);
  }
  #[inline]
  pub fn add_taskId(&mut self, taskId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_TASKID, taskId);
  }
  #[inline]
  pub fn add_dwellId(&mut self, dwellId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_DWELLID, dwellId);
  }
  #[inline]
  pub fn add_externalId(&mut self, externalId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_EXTERNALID, externalId);
  }
  #[inline]
  pub fn add_idSensor(&mut self, idSensor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_IDSENSOR, idSensor);
  }
  #[inline]
  pub fn add_origSensorId(&mut self, origSensorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_ORIGSENSORID, origSensorId);
  }
  #[inline]
  pub fn add_obType(&mut self, obType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_OBTYPE, obType);
  }
  #[inline]
  pub fn add_priority(&mut self, priority: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_PRIORITY, priority);
  }
  #[inline]
  pub fn add_taskCategory(&mut self, taskCategory: i32) {
    self.fbb_.push_slot::<i32>(CollectRequest_Ingest::VT_TASKCATEGORY, taskCategory, 0);
  }
  #[inline]
  pub fn add_suffix(&mut self, suffix: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_SUFFIX, suffix);
  }
  #[inline]
  pub fn add_uctFollowUp(&mut self, uctFollowUp: bool) {
    self.fbb_.push_slot::<bool>(CollectRequest_Ingest::VT_UCTFOLLOWUP, uctFollowUp, false);
  }
  #[inline]
  pub fn add_startTime(&mut self, startTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_STARTTIME, startTime);
  }
  #[inline]
  pub fn add_endTime(&mut self, endTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_ENDTIME, endTime);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(CollectRequest_Ingest::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_taskGroup(&mut self, taskGroup: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_TASKGROUP, taskGroup);
  }
  #[inline]
  pub fn add_iron(&mut self, iron: i32) {
    self.fbb_.push_slot::<i32>(CollectRequest_Ingest::VT_IRON, iron, 0);
  }
  #[inline]
  pub fn add_orbitRegime(&mut self, orbitRegime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_ORBITREGIME, orbitRegime);
  }
  #[inline]
  pub fn add_targetSize(&mut self, targetSize: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_TARGETSIZE, targetSize, 0.0);
  }
  #[inline]
  pub fn add_rcsMin(&mut self, rcsMin: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_RCSMIN, rcsMin, 0.0);
  }
  #[inline]
  pub fn add_rcs(&mut self, rcs: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_RCS, rcs, 0.0);
  }
  #[inline]
  pub fn add_rcsMax(&mut self, rcsMax: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_RCSMAX, rcsMax, 0.0);
  }
  #[inline]
  pub fn add_freqMin(&mut self, freqMin: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_FREQMIN, freqMin, 0.0);
  }
  #[inline]
  pub fn add_freq(&mut self, freq: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_FREQ, freq, 0.0);
  }
  #[inline]
  pub fn add_freqMax(&mut self, freqMax: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_FREQMAX, freqMax, 0.0);
  }
  #[inline]
  pub fn add_polarization(&mut self, polarization: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_POLARIZATION, polarization);
  }
  #[inline]
  pub fn add_visMagMin(&mut self, visMagMin: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_VISMAGMIN, visMagMin, 0.0);
  }
  #[inline]
  pub fn add_visMag(&mut self, visMag: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_VISMAG, visMag, 0.0);
  }
  #[inline]
  pub fn add_visMagMax(&mut self, visMagMax: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_VISMAGMAX, visMagMax, 0.0);
  }
  #[inline]
  pub fn add_spectralModel(&mut self, spectralModel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_SPECTRALMODEL, spectralModel);
  }
  #[inline]
  pub fn add_reflectance(&mut self, reflectance: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_REFLECTANCE, reflectance, 0.0);
  }
  #[inline]
  pub fn add_irradiance(&mut self, irradiance: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_IRRADIANCE, irradiance, 0.0);
  }
  #[inline]
  pub fn add_numFrames(&mut self, numFrames: i32) {
    self.fbb_.push_slot::<i32>(CollectRequest_Ingest::VT_NUMFRAMES, numFrames, 0);
  }
  #[inline]
  pub fn add_frameRate(&mut self, frameRate: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_FRAMERATE, frameRate, 0.0);
  }
  #[inline]
  pub fn add_integrationTime(&mut self, integrationTime: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_INTEGRATIONTIME, integrationTime, 0.0);
  }
  #[inline]
  pub fn add_numTracks(&mut self, numTracks: i32) {
    self.fbb_.push_slot::<i32>(CollectRequest_Ingest::VT_NUMTRACKS, numTracks, 0);
  }
  #[inline]
  pub fn add_numObs(&mut self, numObs: i32) {
    self.fbb_.push_slot::<i32>(CollectRequest_Ingest::VT_NUMOBS, numObs, 0);
  }
  #[inline]
  pub fn add_duration(&mut self, duration: i32) {
    self.fbb_.push_slot::<i32>(CollectRequest_Ingest::VT_DURATION, duration, 0);
  }
  #[inline]
  pub fn add_srchPattern(&mut self, srchPattern: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_SRCHPATTERN, srchPattern);
  }
  #[inline]
  pub fn add_scenario(&mut self, scenario: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_SCENARIO, scenario);
  }
  #[inline]
  pub fn add_idElset(&mut self, idElset: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_IDELSET, idElset);
  }
  #[inline]
  pub fn add_idManifold(&mut self, idManifold: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_IDMANIFOLD, idManifold);
  }
  #[inline]
  pub fn add_idStateVector(&mut self, idStateVector: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_IDSTATEVECTOR, idStateVector);
  }
  #[inline]
  pub fn add_esId(&mut self, esId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_ESID, esId);
  }
  #[inline]
  pub fn add_epoch(&mut self, epoch: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_EPOCH, epoch);
  }
  #[inline]
  pub fn add_semiMajorAxis(&mut self, semiMajorAxis: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_SEMIMAJORAXIS, semiMajorAxis, 0.0);
  }
  #[inline]
  pub fn add_eccentricity(&mut self, eccentricity: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_ECCENTRICITY, eccentricity, 0.0);
  }
  #[inline]
  pub fn add_inclination(&mut self, inclination: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_INCLINATION, inclination, 0.0);
  }
  #[inline]
  pub fn add_raan(&mut self, raan: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_RAAN, raan, 0.0);
  }
  #[inline]
  pub fn add_argOfPerigee(&mut self, argOfPerigee: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_ARGOFPERIGEE, argOfPerigee, 0.0);
  }
  #[inline]
  pub fn add_trueAnomoly(&mut self, trueAnomoly: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_TRUEANOMOLY, trueAnomoly, 0.0);
  }
  #[inline]
  pub fn add_ra(&mut self, ra: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_RA, ra, 0.0);
  }
  #[inline]
  pub fn add_dec(&mut self, dec: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_DEC, dec, 0.0);
  }
  #[inline]
  pub fn add_az(&mut self, az: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_AZ, az, 0.0);
  }
  #[inline]
  pub fn add_el(&mut self, el: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_EL, el, 0.0);
  }
  #[inline]
  pub fn add_range(&mut self, range: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_RANGE, range, 0.0);
  }
  #[inline]
  pub fn add_extentAz(&mut self, extentAz: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_EXTENTAZ, extentAz, 0.0);
  }
  #[inline]
  pub fn add_extentEl(&mut self, extentEl: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_EXTENTEL, extentEl, 0.0);
  }
  #[inline]
  pub fn add_extentRange(&mut self, extentRange: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_EXTENTRANGE, extentRange, 0.0);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_alt(&mut self, alt: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_ALT, alt, 0.0);
  }
  #[inline]
  pub fn add_stopLat(&mut self, stopLat: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_STOPLAT, stopLat, 0.0);
  }
  #[inline]
  pub fn add_stopLon(&mut self, stopLon: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_STOPLON, stopLon, 0.0);
  }
  #[inline]
  pub fn add_stopAlt(&mut self, stopAlt: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_STOPALT, stopAlt, 0.0);
  }
  #[inline]
  pub fn add_srchInc(&mut self, srchInc: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_SRCHINC, srchInc, 0.0);
  }
  #[inline]
  pub fn add_xAngle(&mut self, xAngle: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_XANGLE, xAngle, 0.0);
  }
  #[inline]
  pub fn add_yAngle(&mut self, yAngle: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_YANGLE, yAngle, 0.0);
  }
  #[inline]
  pub fn add_orientAngle(&mut self, orientAngle: f64) {
    self.fbb_.push_slot::<f64>(CollectRequest_Ingest::VT_ORIENTANGLE, orientAngle, 0.0);
  }
  #[inline]
  pub fn add_customer(&mut self, customer: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_CUSTOMER, customer);
  }
  #[inline]
  pub fn add_notes(&mut self, notes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_NOTES, notes);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: CollectRequest_Ingest_dataMode_Enum) {
    self.fbb_.push_slot::<CollectRequest_Ingest_dataMode_Enum>(CollectRequest_Ingest::VT_DATAMODE, dataMode, CollectRequest_Ingest_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_stateVector(&mut self, stateVector: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_STATEVECTOR, stateVector);
  }
  #[inline]
  pub fn add_elset(&mut self, elset: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_ELSET, elset);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CollectRequest_Ingest::VT_TAGS, tags);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CollectRequest_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CollectRequest_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CollectRequest_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CollectRequest_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CollectRequest_Ingest");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idParentReq", &self.idParentReq());
      ds.field("msgType", &self.msgType());
      ds.field("msgCreateDate", &self.msgCreateDate());
      ds.field("type_", &self.type_());
      ds.field("idPlan", &self.idPlan());
      ds.field("planIndex", &self.planIndex());
      ds.field("taskId", &self.taskId());
      ds.field("dwellId", &self.dwellId());
      ds.field("externalId", &self.externalId());
      ds.field("idSensor", &self.idSensor());
      ds.field("origSensorId", &self.origSensorId());
      ds.field("obType", &self.obType());
      ds.field("priority", &self.priority());
      ds.field("taskCategory", &self.taskCategory());
      ds.field("suffix", &self.suffix());
      ds.field("uctFollowUp", &self.uctFollowUp());
      ds.field("startTime", &self.startTime());
      ds.field("endTime", &self.endTime());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("satNo", &self.satNo());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("taskGroup", &self.taskGroup());
      ds.field("iron", &self.iron());
      ds.field("orbitRegime", &self.orbitRegime());
      ds.field("targetSize", &self.targetSize());
      ds.field("rcsMin", &self.rcsMin());
      ds.field("rcs", &self.rcs());
      ds.field("rcsMax", &self.rcsMax());
      ds.field("freqMin", &self.freqMin());
      ds.field("freq", &self.freq());
      ds.field("freqMax", &self.freqMax());
      ds.field("polarization", &self.polarization());
      ds.field("visMagMin", &self.visMagMin());
      ds.field("visMag", &self.visMag());
      ds.field("visMagMax", &self.visMagMax());
      ds.field("spectralModel", &self.spectralModel());
      ds.field("reflectance", &self.reflectance());
      ds.field("irradiance", &self.irradiance());
      ds.field("numFrames", &self.numFrames());
      ds.field("frameRate", &self.frameRate());
      ds.field("integrationTime", &self.integrationTime());
      ds.field("numTracks", &self.numTracks());
      ds.field("numObs", &self.numObs());
      ds.field("duration", &self.duration());
      ds.field("srchPattern", &self.srchPattern());
      ds.field("scenario", &self.scenario());
      ds.field("idElset", &self.idElset());
      ds.field("idManifold", &self.idManifold());
      ds.field("idStateVector", &self.idStateVector());
      ds.field("esId", &self.esId());
      ds.field("epoch", &self.epoch());
      ds.field("semiMajorAxis", &self.semiMajorAxis());
      ds.field("eccentricity", &self.eccentricity());
      ds.field("inclination", &self.inclination());
      ds.field("raan", &self.raan());
      ds.field("argOfPerigee", &self.argOfPerigee());
      ds.field("trueAnomoly", &self.trueAnomoly());
      ds.field("ra", &self.ra());
      ds.field("dec", &self.dec());
      ds.field("az", &self.az());
      ds.field("el", &self.el());
      ds.field("range", &self.range());
      ds.field("extentAz", &self.extentAz());
      ds.field("extentEl", &self.extentEl());
      ds.field("extentRange", &self.extentRange());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("alt", &self.alt());
      ds.field("stopLat", &self.stopLat());
      ds.field("stopLon", &self.stopLon());
      ds.field("stopAlt", &self.stopAlt());
      ds.field("srchInc", &self.srchInc());
      ds.field("xAngle", &self.xAngle());
      ds.field("yAngle", &self.yAngle());
      ds.field("orientAngle", &self.orientAngle());
      ds.field("customer", &self.customer());
      ds.field("notes", &self.notes());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("dataMode", &self.dataMode());
      ds.field("stateVector", &self.stateVector());
      ds.field("elset", &self.elset());
      ds.field("tags", &self.tags());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CollectRequest_IngestT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idParentReq: Option<String>,
  pub msgType: Option<String>,
  pub msgCreateDate: Option<String>,
  pub type_: Option<String>,
  pub idPlan: Option<String>,
  pub planIndex: i32,
  pub taskId: Option<String>,
  pub dwellId: Option<String>,
  pub externalId: Option<String>,
  pub idSensor: Option<String>,
  pub origSensorId: Option<String>,
  pub obType: Option<String>,
  pub priority: Option<String>,
  pub taskCategory: i32,
  pub suffix: Option<String>,
  pub uctFollowUp: bool,
  pub startTime: Option<String>,
  pub endTime: Option<String>,
  pub idOnOrbit: Option<String>,
  pub satNo: i32,
  pub origObjectId: Option<String>,
  pub taskGroup: Option<String>,
  pub iron: i32,
  pub orbitRegime: Option<String>,
  pub targetSize: f64,
  pub rcsMin: f64,
  pub rcs: f64,
  pub rcsMax: f64,
  pub freqMin: f64,
  pub freq: f64,
  pub freqMax: f64,
  pub polarization: Option<String>,
  pub visMagMin: f64,
  pub visMag: f64,
  pub visMagMax: f64,
  pub spectralModel: Option<String>,
  pub reflectance: f64,
  pub irradiance: f64,
  pub numFrames: i32,
  pub frameRate: f64,
  pub integrationTime: f64,
  pub numTracks: i32,
  pub numObs: i32,
  pub duration: i32,
  pub srchPattern: Option<String>,
  pub scenario: Option<String>,
  pub idElset: Option<String>,
  pub idManifold: Option<String>,
  pub idStateVector: Option<String>,
  pub esId: Option<String>,
  pub epoch: Option<String>,
  pub semiMajorAxis: f64,
  pub eccentricity: f64,
  pub inclination: f64,
  pub raan: f64,
  pub argOfPerigee: f64,
  pub trueAnomoly: f64,
  pub ra: f64,
  pub dec: f64,
  pub az: f64,
  pub el: f64,
  pub range: f64,
  pub extentAz: f64,
  pub extentEl: f64,
  pub extentRange: f64,
  pub lat: f64,
  pub lon: f64,
  pub alt: f64,
  pub stopLat: f64,
  pub stopLon: f64,
  pub stopAlt: f64,
  pub srchInc: f64,
  pub xAngle: f64,
  pub yAngle: f64,
  pub orientAngle: f64,
  pub customer: Option<String>,
  pub notes: Option<String>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub origNetwork: Option<String>,
  pub dataMode: CollectRequest_Ingest_dataMode_Enum,
  pub stateVector: Option<String>,
  pub elset: Option<String>,
  pub tags: Option<Vec<String>>,
}
impl Default for CollectRequest_IngestT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idParentReq: None,
      msgType: None,
      msgCreateDate: None,
      type_: None,
      idPlan: None,
      planIndex: 0,
      taskId: None,
      dwellId: None,
      externalId: None,
      idSensor: None,
      origSensorId: None,
      obType: None,
      priority: None,
      taskCategory: 0,
      suffix: None,
      uctFollowUp: false,
      startTime: None,
      endTime: None,
      idOnOrbit: None,
      satNo: 0,
      origObjectId: None,
      taskGroup: None,
      iron: 0,
      orbitRegime: None,
      targetSize: 0.0,
      rcsMin: 0.0,
      rcs: 0.0,
      rcsMax: 0.0,
      freqMin: 0.0,
      freq: 0.0,
      freqMax: 0.0,
      polarization: None,
      visMagMin: 0.0,
      visMag: 0.0,
      visMagMax: 0.0,
      spectralModel: None,
      reflectance: 0.0,
      irradiance: 0.0,
      numFrames: 0,
      frameRate: 0.0,
      integrationTime: 0.0,
      numTracks: 0,
      numObs: 0,
      duration: 0,
      srchPattern: None,
      scenario: None,
      idElset: None,
      idManifold: None,
      idStateVector: None,
      esId: None,
      epoch: None,
      semiMajorAxis: 0.0,
      eccentricity: 0.0,
      inclination: 0.0,
      raan: 0.0,
      argOfPerigee: 0.0,
      trueAnomoly: 0.0,
      ra: 0.0,
      dec: 0.0,
      az: 0.0,
      el: 0.0,
      range: 0.0,
      extentAz: 0.0,
      extentEl: 0.0,
      extentRange: 0.0,
      lat: 0.0,
      lon: 0.0,
      alt: 0.0,
      stopLat: 0.0,
      stopLon: 0.0,
      stopAlt: 0.0,
      srchInc: 0.0,
      xAngle: 0.0,
      yAngle: 0.0,
      orientAngle: 0.0,
      customer: None,
      notes: None,
      createdAt: None,
      createdBy: None,
      source: None,
      origin: None,
      origNetwork: None,
      dataMode: CollectRequest_Ingest_dataMode_Enum::REAL,
      stateVector: None,
      elset: None,
      tags: None,
    }
  }
}
impl CollectRequest_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CollectRequest_Ingest<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idParentReq = self.idParentReq.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msgType = self.msgType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let msgCreateDate = self.msgCreateDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idPlan = self.idPlan.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let planIndex = self.planIndex;
    let taskId = self.taskId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dwellId = self.dwellId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let externalId = self.externalId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor = self.idSensor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId = self.origSensorId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let obType = self.obType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let priority = self.priority.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskCategory = self.taskCategory;
    let suffix = self.suffix.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let uctFollowUp = self.uctFollowUp;
    let startTime = self.startTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let endTime = self.endTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo = self.satNo;
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let taskGroup = self.taskGroup.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let iron = self.iron;
    let orbitRegime = self.orbitRegime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let targetSize = self.targetSize;
    let rcsMin = self.rcsMin;
    let rcs = self.rcs;
    let rcsMax = self.rcsMax;
    let freqMin = self.freqMin;
    let freq = self.freq;
    let freqMax = self.freqMax;
    let polarization = self.polarization.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let visMagMin = self.visMagMin;
    let visMag = self.visMag;
    let visMagMax = self.visMagMax;
    let spectralModel = self.spectralModel.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reflectance = self.reflectance;
    let irradiance = self.irradiance;
    let numFrames = self.numFrames;
    let frameRate = self.frameRate;
    let integrationTime = self.integrationTime;
    let numTracks = self.numTracks;
    let numObs = self.numObs;
    let duration = self.duration;
    let srchPattern = self.srchPattern.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let scenario = self.scenario.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idElset = self.idElset.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idManifold = self.idManifold.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idStateVector = self.idStateVector.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let esId = self.esId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let epoch = self.epoch.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let semiMajorAxis = self.semiMajorAxis;
    let eccentricity = self.eccentricity;
    let inclination = self.inclination;
    let raan = self.raan;
    let argOfPerigee = self.argOfPerigee;
    let trueAnomoly = self.trueAnomoly;
    let ra = self.ra;
    let dec = self.dec;
    let az = self.az;
    let el = self.el;
    let range = self.range;
    let extentAz = self.extentAz;
    let extentEl = self.extentEl;
    let extentRange = self.extentRange;
    let lat = self.lat;
    let lon = self.lon;
    let alt = self.alt;
    let stopLat = self.stopLat;
    let stopLon = self.stopLon;
    let stopAlt = self.stopAlt;
    let srchInc = self.srchInc;
    let xAngle = self.xAngle;
    let yAngle = self.yAngle;
    let orientAngle = self.orientAngle;
    let customer = self.customer.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let notes = self.notes.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let stateVector = self.stateVector.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let elset = self.elset.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    CollectRequest_Ingest::create(_fbb, &CollectRequest_IngestArgs{
      id,
      classificationMarking,
      idParentReq,
      msgType,
      msgCreateDate,
      type_,
      idPlan,
      planIndex,
      taskId,
      dwellId,
      externalId,
      idSensor,
      origSensorId,
      obType,
      priority,
      taskCategory,
      suffix,
      uctFollowUp,
      startTime,
      endTime,
      idOnOrbit,
      satNo,
      origObjectId,
      taskGroup,
      iron,
      orbitRegime,
      targetSize,
      rcsMin,
      rcs,
      rcsMax,
      freqMin,
      freq,
      freqMax,
      polarization,
      visMagMin,
      visMag,
      visMagMax,
      spectralModel,
      reflectance,
      irradiance,
      numFrames,
      frameRate,
      integrationTime,
      numTracks,
      numObs,
      duration,
      srchPattern,
      scenario,
      idElset,
      idManifold,
      idStateVector,
      esId,
      epoch,
      semiMajorAxis,
      eccentricity,
      inclination,
      raan,
      argOfPerigee,
      trueAnomoly,
      ra,
      dec,
      az,
      el,
      range,
      extentAz,
      extentEl,
      extentRange,
      lat,
      lon,
      alt,
      stopLat,
      stopLon,
      stopAlt,
      srchInc,
      xAngle,
      yAngle,
      orientAngle,
      customer,
      notes,
      createdAt,
      createdBy,
      source,
      origin,
      origNetwork,
      dataMode,
      stateVector,
      elset,
      tags,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CollectRequest_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_collect_request_ingest_unchecked`.
pub fn root_as_collect_request_ingest(buf: &[u8]) -> Result<CollectRequest_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<CollectRequest_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CollectRequest_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_collect_request_ingest_unchecked`.
pub fn size_prefixed_root_as_collect_request_ingest(buf: &[u8]) -> Result<CollectRequest_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<CollectRequest_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CollectRequest_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_collect_request_ingest_unchecked`.
pub fn root_as_collect_request_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CollectRequest_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<CollectRequest_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CollectRequest_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_collect_request_ingest_unchecked`.
pub fn size_prefixed_root_as_collect_request_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CollectRequest_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<CollectRequest_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CollectRequest_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CollectRequest_Ingest`.
pub unsafe fn root_as_collect_request_ingest_unchecked(buf: &[u8]) -> CollectRequest_Ingest {
  flatbuffers::root_unchecked::<CollectRequest_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CollectRequest_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CollectRequest_Ingest`.
pub unsafe fn size_prefixed_root_as_collect_request_ingest_unchecked(buf: &[u8]) -> CollectRequest_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<CollectRequest_Ingest>(buf)
}
pub const COLLECT_REQUEST_INGEST_IDENTIFIER: &str = "COLL";

#[inline]
pub fn collect_request_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, COLLECT_REQUEST_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn collect_request_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, COLLECT_REQUEST_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_collect_request_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CollectRequest_Ingest<'a>>) {
  fbb.finish(root, Some(COLLECT_REQUEST_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_collect_request_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<CollectRequest_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(COLLECT_REQUEST_INGEST_IDENTIFIER));
}
