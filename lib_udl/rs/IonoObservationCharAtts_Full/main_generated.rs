// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum IonoObservationCharAtts_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Characteristic attributes of a IonoObservation.
pub struct IonoObservationCharAtts_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IonoObservationCharAtts_Full<'a> {
  type Inner = IonoObservationCharAtts_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IonoObservationCharAtts_Full<'a> {
  pub const VT_URSIID: flatbuffers::VOffsetT = 4;
  pub const VT_CHARNAME: flatbuffers::VOffsetT = 6;
  pub const VT_LOWERBOUND: flatbuffers::VOffsetT = 8;
  pub const VT_UPPERBOUND: flatbuffers::VOffsetT = 10;
  pub const VT_Q: flatbuffers::VOffsetT = 12;
  pub const VT_D: flatbuffers::VOffsetT = 14;
  pub const VT_CLIMATEMODELNAME: flatbuffers::VOffsetT = 16;
  pub const VT_CLIMATEMODELOPTIONS: flatbuffers::VOffsetT = 18;
  pub const VT_CLIMATEMODELINPUTPARAMS: flatbuffers::VOffsetT = 20;
  pub const VT_UNCERTAINTYBOUNDTYPE: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IonoObservationCharAtts_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IonoObservationCharAtts_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<IonoObservationCharAtts_Full<'bldr>> {
    let mut builder = IonoObservationCharAtts_FullBuilder::new(_fbb);
    builder.add_upperBound(args.upperBound);
    builder.add_lowerBound(args.lowerBound);
    if let Some(x) = args.uncertaintyBoundType { builder.add_uncertaintyBoundType(x); }
    if let Some(x) = args.climateModelInputParams { builder.add_climateModelInputParams(x); }
    if let Some(x) = args.climateModelOptions { builder.add_climateModelOptions(x); }
    if let Some(x) = args.climateModelName { builder.add_climateModelName(x); }
    if let Some(x) = args.d { builder.add_d(x); }
    if let Some(x) = args.q { builder.add_q(x); }
    if let Some(x) = args.charName { builder.add_charName(x); }
    if let Some(x) = args.ursiID { builder.add_ursiID(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> IonoObservationCharAtts_FullT {
    let ursiID = self.ursiID().map(|x| {
      x.to_string()
    });
    let charName = self.charName().map(|x| {
      x.to_string()
    });
    let lowerBound = self.lowerBound();
    let upperBound = self.upperBound();
    let q = self.q().map(|x| {
      x.to_string()
    });
    let d = self.d().map(|x| {
      x.to_string()
    });
    let climateModelName = self.climateModelName().map(|x| {
      x.to_string()
    });
    let climateModelOptions = self.climateModelOptions().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let climateModelInputParams = self.climateModelInputParams().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let uncertaintyBoundType = self.uncertaintyBoundType().map(|x| {
      x.to_string()
    });
    IonoObservationCharAtts_FullT {
      ursiID,
      charName,
      lowerBound,
      upperBound,
      q,
      d,
      climateModelName,
      climateModelOptions,
      climateModelInputParams,
      uncertaintyBoundType,
    }
  }

  /// Characteristic's URSI ID. See the characteristic's description for its corresponding URSI ID.
  /// Example: /// Example: 04
  /// Constraints: Minimum length = 0, Maximum length = 3
  #[inline]
  pub fn ursiID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservationCharAtts_Full::VT_URSIID, None)}
  }
  /// Characteristic name. This value should reflect the UDL field name for the corresponding characteristic.
  /// Example: /// Example: hprimeF2
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn charName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservationCharAtts_Full::VT_CHARNAME, None)}
  }
  /// Specified characteristic's lower bound. Should be less than or equal to the characteristic's current value as set in this record.
  /// Example: /// Example: 1.26
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lowerBound(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservationCharAtts_Full::VT_LOWERBOUND, Some(0.0)).unwrap()}
  }
  /// Specified characteristic's upper bound. Should be greater than or equal to the characteristic's current value as set in this record.
  /// Example: /// Example: 2.57
  /// Constraints: No constraints specified.
  #[inline]
  pub fn upperBound(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IonoObservationCharAtts_Full::VT_UPPERBOUND, Some(0.0)).unwrap()}
  }
  /// Qualifying letter (Q) for the characteristic specified by URSI ID. Describes specific ionospheric conditions, beyond numerical values.
  /// Example: /// Example: T
  /// Constraints: No constraints specified.
  #[inline]
  pub fn q(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservationCharAtts_Full::VT_Q, None)}
  }
  /// Descriptive letter (D) for the characteristic specified by URSI ID. Describes specific ionospheric conditions, beyond numerical values.
  /// Example: /// Example: K
  /// Constraints: No constraints specified.
  #[inline]
  pub fn d(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservationCharAtts_Full::VT_D, None)}
  }
  /// Name of the climate model.
  /// Example: /// Example: IRI
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn climateModelName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservationCharAtts_Full::VT_CLIMATEMODELNAME, None)}
  }
  /// List of options for the climate model.
  /// Example: /// Example: ['URSI-88', 'No storm']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn climateModelOptions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservationCharAtts_Full::VT_CLIMATEMODELOPTIONS, None)}
  }
  /// Input parameters for the climate model.
  /// Example: /// Example: ['ISSN1 88.1', 'Option 2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn climateModelInputParams(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IonoObservationCharAtts_Full::VT_CLIMATEMODELINPUTPARAMS, None)}
  }
  /// Uncertainty Bounds (lower and upper) define an interval around reported value that contains true value at the specified probability level. Probability levels are specified in terms of percentile (from 1 to 100) or the standard deviation, sigma (e.g. 1sigma, 2sigma, 3sigma, 5percentile, 10percentile, 25percentile).
  /// Example: /// Example: 1sigma
  /// Constraints: No constraints specified.
  #[inline]
  pub fn uncertaintyBoundType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IonoObservationCharAtts_Full::VT_UNCERTAINTYBOUNDTYPE, None)}
  }
}

impl flatbuffers::Verifiable for IonoObservationCharAtts_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ursiID", Self::VT_URSIID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charName", Self::VT_CHARNAME, false)?
     .visit_field::<f64>("lowerBound", Self::VT_LOWERBOUND, false)?
     .visit_field::<f64>("upperBound", Self::VT_UPPERBOUND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("q", Self::VT_Q, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("d", Self::VT_D, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("climateModelName", Self::VT_CLIMATEMODELNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("climateModelOptions", Self::VT_CLIMATEMODELOPTIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("climateModelInputParams", Self::VT_CLIMATEMODELINPUTPARAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("uncertaintyBoundType", Self::VT_UNCERTAINTYBOUNDTYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct IonoObservationCharAtts_FullArgs<'a> {
    pub ursiID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lowerBound: f64,
    pub upperBound: f64,
    pub q: Option<flatbuffers::WIPOffset<&'a str>>,
    pub d: Option<flatbuffers::WIPOffset<&'a str>>,
    pub climateModelName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub climateModelOptions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub climateModelInputParams: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub uncertaintyBoundType: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for IonoObservationCharAtts_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    IonoObservationCharAtts_FullArgs {
      ursiID: None,
      charName: None,
      lowerBound: 0.0,
      upperBound: 0.0,
      q: None,
      d: None,
      climateModelName: None,
      climateModelOptions: None,
      climateModelInputParams: None,
      uncertaintyBoundType: None,
    }
  }
}

pub struct IonoObservationCharAtts_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IonoObservationCharAtts_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ursiID(&mut self, ursiID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationCharAtts_Full::VT_URSIID, ursiID);
  }
  #[inline]
  pub fn add_charName(&mut self, charName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationCharAtts_Full::VT_CHARNAME, charName);
  }
  #[inline]
  pub fn add_lowerBound(&mut self, lowerBound: f64) {
    self.fbb_.push_slot::<f64>(IonoObservationCharAtts_Full::VT_LOWERBOUND, lowerBound, 0.0);
  }
  #[inline]
  pub fn add_upperBound(&mut self, upperBound: f64) {
    self.fbb_.push_slot::<f64>(IonoObservationCharAtts_Full::VT_UPPERBOUND, upperBound, 0.0);
  }
  #[inline]
  pub fn add_q(&mut self, q: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationCharAtts_Full::VT_Q, q);
  }
  #[inline]
  pub fn add_d(&mut self, d: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationCharAtts_Full::VT_D, d);
  }
  #[inline]
  pub fn add_climateModelName(&mut self, climateModelName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationCharAtts_Full::VT_CLIMATEMODELNAME, climateModelName);
  }
  #[inline]
  pub fn add_climateModelOptions(&mut self, climateModelOptions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationCharAtts_Full::VT_CLIMATEMODELOPTIONS, climateModelOptions);
  }
  #[inline]
  pub fn add_climateModelInputParams(&mut self, climateModelInputParams: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationCharAtts_Full::VT_CLIMATEMODELINPUTPARAMS, climateModelInputParams);
  }
  #[inline]
  pub fn add_uncertaintyBoundType(&mut self, uncertaintyBoundType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IonoObservationCharAtts_Full::VT_UNCERTAINTYBOUNDTYPE, uncertaintyBoundType);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IonoObservationCharAtts_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IonoObservationCharAtts_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IonoObservationCharAtts_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IonoObservationCharAtts_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IonoObservationCharAtts_Full");
      ds.field("ursiID", &self.ursiID());
      ds.field("charName", &self.charName());
      ds.field("lowerBound", &self.lowerBound());
      ds.field("upperBound", &self.upperBound());
      ds.field("q", &self.q());
      ds.field("d", &self.d());
      ds.field("climateModelName", &self.climateModelName());
      ds.field("climateModelOptions", &self.climateModelOptions());
      ds.field("climateModelInputParams", &self.climateModelInputParams());
      ds.field("uncertaintyBoundType", &self.uncertaintyBoundType());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct IonoObservationCharAtts_FullT {
  pub ursiID: Option<String>,
  pub charName: Option<String>,
  pub lowerBound: f64,
  pub upperBound: f64,
  pub q: Option<String>,
  pub d: Option<String>,
  pub climateModelName: Option<String>,
  pub climateModelOptions: Option<Vec<String>>,
  pub climateModelInputParams: Option<Vec<String>>,
  pub uncertaintyBoundType: Option<String>,
}
impl Default for IonoObservationCharAtts_FullT {
  fn default() -> Self {
    Self {
      ursiID: None,
      charName: None,
      lowerBound: 0.0,
      upperBound: 0.0,
      q: None,
      d: None,
      climateModelName: None,
      climateModelOptions: None,
      climateModelInputParams: None,
      uncertaintyBoundType: None,
    }
  }
}
impl IonoObservationCharAtts_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<IonoObservationCharAtts_Full<'b>> {
    let ursiID = self.ursiID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let charName = self.charName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lowerBound = self.lowerBound;
    let upperBound = self.upperBound;
    let q = self.q.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let d = self.d.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let climateModelName = self.climateModelName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let climateModelOptions = self.climateModelOptions.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let climateModelInputParams = self.climateModelInputParams.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let uncertaintyBoundType = self.uncertaintyBoundType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    IonoObservationCharAtts_Full::create(_fbb, &IonoObservationCharAtts_FullArgs{
      ursiID,
      charName,
      lowerBound,
      upperBound,
      q,
      d,
      climateModelName,
      climateModelOptions,
      climateModelInputParams,
      uncertaintyBoundType,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `IonoObservationCharAtts_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_iono_observation_char_atts_full_unchecked`.
pub fn root_as_iono_observation_char_atts_full(buf: &[u8]) -> Result<IonoObservationCharAtts_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<IonoObservationCharAtts_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `IonoObservationCharAtts_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_iono_observation_char_atts_full_unchecked`.
pub fn size_prefixed_root_as_iono_observation_char_atts_full(buf: &[u8]) -> Result<IonoObservationCharAtts_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<IonoObservationCharAtts_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `IonoObservationCharAtts_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_iono_observation_char_atts_full_unchecked`.
pub fn root_as_iono_observation_char_atts_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<IonoObservationCharAtts_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<IonoObservationCharAtts_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `IonoObservationCharAtts_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_iono_observation_char_atts_full_unchecked`.
pub fn size_prefixed_root_as_iono_observation_char_atts_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<IonoObservationCharAtts_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<IonoObservationCharAtts_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a IonoObservationCharAtts_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `IonoObservationCharAtts_Full`.
pub unsafe fn root_as_iono_observation_char_atts_full_unchecked(buf: &[u8]) -> IonoObservationCharAtts_Full {
  flatbuffers::root_unchecked::<IonoObservationCharAtts_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed IonoObservationCharAtts_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `IonoObservationCharAtts_Full`.
pub unsafe fn size_prefixed_root_as_iono_observation_char_atts_full_unchecked(buf: &[u8]) -> IonoObservationCharAtts_Full {
  flatbuffers::size_prefixed_root_unchecked::<IonoObservationCharAtts_Full>(buf)
}
pub const IONO_OBSERVATION_CHAR_ATTS_FULL_IDENTIFIER: &str = "IONO";

#[inline]
pub fn iono_observation_char_atts_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, IONO_OBSERVATION_CHAR_ATTS_FULL_IDENTIFIER, false)
}

#[inline]
pub fn iono_observation_char_atts_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, IONO_OBSERVATION_CHAR_ATTS_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_iono_observation_char_atts_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<IonoObservationCharAtts_Full<'a>>) {
  fbb.finish(root, Some(IONO_OBSERVATION_CHAR_ATTS_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_iono_observation_char_atts_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<IonoObservationCharAtts_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(IONO_OBSERVATION_CHAR_ATTS_FULL_IDENTIFIER));
}
