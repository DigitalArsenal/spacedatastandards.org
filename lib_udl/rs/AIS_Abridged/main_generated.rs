// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AIS_ABRIDGED_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AIS_ABRIDGED_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AIS_ABRIDGED_DATA_MODE_ENUM: [AIS_Abridged_dataMode_Enum; 4] = [
  AIS_Abridged_dataMode_Enum::REAL,
  AIS_Abridged_dataMode_Enum::TEST,
  AIS_Abridged_dataMode_Enum::SIMULATED,
  AIS_Abridged_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AIS_Abridged_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl AIS_Abridged_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AIS_Abridged_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AIS_Abridged_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AIS_Abridged_dataMode_Enum {
    type Output = AIS_Abridged_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AIS_Abridged_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AIS_Abridged_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AIS_Abridged_dataMode_Enum {}
pub enum AIS_AbridgedOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Self-reported information obtained from Automatic Identification System (AIS) equipment. This contains information such as unique identification, status, position, course, and speed. The AIS is an automatic tracking system that uses transceivers on ships and is used by vessel traffic services. Although technically and operationally distinct, the AIS system is analogous to ADS-B that performs a similar function for aircraft. AIS is intended to assist a vessel's watchstanding officers and allow maritime authorities to track and monitor vessel movements. AIS integrates a standardized VHF transceiver with a positioning system such as Global Positioning System receiver, with other electronic navigation sensors, such as gyrocompass or rate of turn indicator. Vessels fitted with AIS transceivers can be tracked by AIS base stations located along coast lines or, when out of range of terrestrial networks, through a growing number of satellites that are fitted with special AIS receivers which are capable of deconflicting a large number of signatures.
pub struct AIS_Abridged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AIS_Abridged<'a> {
  type Inner = AIS_Abridged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AIS_Abridged<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_IDTRACK: flatbuffers::VOffsetT = 8;
  pub const VT_IDVESSEL: flatbuffers::VOffsetT = 10;
  pub const VT_MMSI: flatbuffers::VOffsetT = 12;
  pub const VT_IMON: flatbuffers::VOffsetT = 14;
  pub const VT_TS: flatbuffers::VOffsetT = 16;
  pub const VT_SHIPNAME: flatbuffers::VOffsetT = 18;
  pub const VT_SHIPTYPE: flatbuffers::VOffsetT = 20;
  pub const VT_ENGAGEDIN: flatbuffers::VOffsetT = 22;
  pub const VT_SPECIALCRAFT: flatbuffers::VOffsetT = 24;
  pub const VT_CARGOTYPE: flatbuffers::VOffsetT = 26;
  pub const VT_CALLSIGN: flatbuffers::VOffsetT = 28;
  pub const VT_VESSELFLAG: flatbuffers::VOffsetT = 30;
  pub const VT_LAT: flatbuffers::VOffsetT = 32;
  pub const VT_LON: flatbuffers::VOffsetT = 34;
  pub const VT_POSHIACCURACY: flatbuffers::VOffsetT = 36;
  pub const VT_POSHILATENCY: flatbuffers::VOffsetT = 38;
  pub const VT_SPEED: flatbuffers::VOffsetT = 40;
  pub const VT_TRUEHEADING: flatbuffers::VOffsetT = 42;
  pub const VT_COURSE: flatbuffers::VOffsetT = 44;
  pub const VT_RATEOFTURN: flatbuffers::VOffsetT = 46;
  pub const VT_SPECIALMANEUVER: flatbuffers::VOffsetT = 48;
  pub const VT_NAVSTATUS: flatbuffers::VOffsetT = 50;
  pub const VT_POSDEVICETYPE: flatbuffers::VOffsetT = 52;
  pub const VT_ANTENNAREFDIMENSIONS: flatbuffers::VOffsetT = 54;
  pub const VT_LENGTH: flatbuffers::VOffsetT = 56;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 58;
  pub const VT_DRAUGHT: flatbuffers::VOffsetT = 60;
  pub const VT_SHIPDESCRIPTION: flatbuffers::VOffsetT = 62;
  pub const VT_DESTINATION: flatbuffers::VOffsetT = 64;
  pub const VT_DESTINATIONETA: flatbuffers::VOffsetT = 66;
  pub const VT_CURRENTPORTGUID: flatbuffers::VOffsetT = 68;
  pub const VT_CURRENTPORTLOCODE: flatbuffers::VOffsetT = 70;
  pub const VT_LASTPORTGUID: flatbuffers::VOffsetT = 72;
  pub const VT_LASTPORTLOCODE: flatbuffers::VOffsetT = 74;
  pub const VT_NEXTPORTGUID: flatbuffers::VOffsetT = 76;
  pub const VT_NEXTPORTLOCODE: flatbuffers::VOffsetT = 78;
  pub const VT_ETACALCULATED: flatbuffers::VOffsetT = 80;
  pub const VT_ETAUPDATED: flatbuffers::VOffsetT = 82;
  pub const VT_DISTANCETOGO: flatbuffers::VOffsetT = 84;
  pub const VT_DISTANCETRAVELLED: flatbuffers::VOffsetT = 86;
  pub const VT_AVGSPEED: flatbuffers::VOffsetT = 88;
  pub const VT_MAXSPEED: flatbuffers::VOffsetT = 90;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 92;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 94;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 96;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 98;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 100;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 102;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 104;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AIS_Abridged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AIS_AbridgedArgs<'args>
  ) -> flatbuffers::WIPOffset<AIS_Abridged<'bldr>> {
    let mut builder = AIS_AbridgedBuilder::new(_fbb);
    builder.add_maxSpeed(args.maxSpeed);
    builder.add_avgSpeed(args.avgSpeed);
    builder.add_distanceTravelled(args.distanceTravelled);
    builder.add_distanceToGo(args.distanceToGo);
    builder.add_draught(args.draught);
    builder.add_width(args.width);
    builder.add_length(args.length);
    builder.add_rateOfTurn(args.rateOfTurn);
    builder.add_course(args.course);
    builder.add_trueHeading(args.trueHeading);
    builder.add_speed(args.speed);
    builder.add_lon(args.lon);
    builder.add_lat(args.lat);
    builder.add_imon(args.imon);
    builder.add_mmsi(args.mmsi);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.etaUpdated { builder.add_etaUpdated(x); }
    if let Some(x) = args.etaCalculated { builder.add_etaCalculated(x); }
    if let Some(x) = args.nextPortLOCODE { builder.add_nextPortLOCODE(x); }
    if let Some(x) = args.nextPortGUID { builder.add_nextPortGUID(x); }
    if let Some(x) = args.lastPortLOCODE { builder.add_lastPortLOCODE(x); }
    if let Some(x) = args.lastPortGUID { builder.add_lastPortGUID(x); }
    if let Some(x) = args.currentPortLOCODE { builder.add_currentPortLOCODE(x); }
    if let Some(x) = args.currentPortGUID { builder.add_currentPortGUID(x); }
    if let Some(x) = args.destinationETA { builder.add_destinationETA(x); }
    if let Some(x) = args.destination { builder.add_destination(x); }
    if let Some(x) = args.shipDescription { builder.add_shipDescription(x); }
    if let Some(x) = args.antennaRefDimensions { builder.add_antennaRefDimensions(x); }
    if let Some(x) = args.posDeviceType { builder.add_posDeviceType(x); }
    if let Some(x) = args.navStatus { builder.add_navStatus(x); }
    if let Some(x) = args.vesselFlag { builder.add_vesselFlag(x); }
    if let Some(x) = args.callSign { builder.add_callSign(x); }
    if let Some(x) = args.cargoType { builder.add_cargoType(x); }
    if let Some(x) = args.specialCraft { builder.add_specialCraft(x); }
    if let Some(x) = args.engagedIn { builder.add_engagedIn(x); }
    if let Some(x) = args.shipType { builder.add_shipType(x); }
    if let Some(x) = args.shipName { builder.add_shipName(x); }
    if let Some(x) = args.ts { builder.add_ts(x); }
    if let Some(x) = args.idVessel { builder.add_idVessel(x); }
    if let Some(x) = args.idTrack { builder.add_idTrack(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_specialManeuver(args.specialManeuver);
    builder.add_posHiLatency(args.posHiLatency);
    builder.add_posHiAccuracy(args.posHiAccuracy);
    builder.finish()
  }

  pub fn unpack(&self) -> AIS_AbridgedT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let idTrack = self.idTrack().map(|x| {
      x.to_string()
    });
    let idVessel = self.idVessel().map(|x| {
      x.to_string()
    });
    let mmsi = self.mmsi();
    let imon = self.imon();
    let ts = self.ts().map(|x| {
      x.to_string()
    });
    let shipName = self.shipName().map(|x| {
      x.to_string()
    });
    let shipType = self.shipType().map(|x| {
      x.to_string()
    });
    let engagedIn = self.engagedIn().map(|x| {
      x.to_string()
    });
    let specialCraft = self.specialCraft().map(|x| {
      x.to_string()
    });
    let cargoType = self.cargoType().map(|x| {
      x.to_string()
    });
    let callSign = self.callSign().map(|x| {
      x.to_string()
    });
    let vesselFlag = self.vesselFlag().map(|x| {
      x.to_string()
    });
    let lat = self.lat();
    let lon = self.lon();
    let posHiAccuracy = self.posHiAccuracy();
    let posHiLatency = self.posHiLatency();
    let speed = self.speed();
    let trueHeading = self.trueHeading();
    let course = self.course();
    let rateOfTurn = self.rateOfTurn();
    let specialManeuver = self.specialManeuver();
    let navStatus = self.navStatus().map(|x| {
      x.to_string()
    });
    let posDeviceType = self.posDeviceType().map(|x| {
      x.to_string()
    });
    let antennaRefDimensions = self.antennaRefDimensions().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let length = self.length();
    let width = self.width();
    let draught = self.draught();
    let shipDescription = self.shipDescription().map(|x| {
      x.to_string()
    });
    let destination = self.destination().map(|x| {
      x.to_string()
    });
    let destinationETA = self.destinationETA().map(|x| {
      x.to_string()
    });
    let currentPortGUID = self.currentPortGUID().map(|x| {
      x.to_string()
    });
    let currentPortLOCODE = self.currentPortLOCODE().map(|x| {
      x.to_string()
    });
    let lastPortGUID = self.lastPortGUID().map(|x| {
      x.to_string()
    });
    let lastPortLOCODE = self.lastPortLOCODE().map(|x| {
      x.to_string()
    });
    let nextPortGUID = self.nextPortGUID().map(|x| {
      x.to_string()
    });
    let nextPortLOCODE = self.nextPortLOCODE().map(|x| {
      x.to_string()
    });
    let etaCalculated = self.etaCalculated().map(|x| {
      x.to_string()
    });
    let etaUpdated = self.etaUpdated().map(|x| {
      x.to_string()
    });
    let distanceToGo = self.distanceToGo();
    let distanceTravelled = self.distanceTravelled();
    let avgSpeed = self.avgSpeed();
    let maxSpeed = self.maxSpeed();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    AIS_AbridgedT {
      id,
      classificationMarking,
      idTrack,
      idVessel,
      mmsi,
      imon,
      ts,
      shipName,
      shipType,
      engagedIn,
      specialCraft,
      cargoType,
      callSign,
      vesselFlag,
      lat,
      lon,
      posHiAccuracy,
      posHiLatency,
      speed,
      trueHeading,
      course,
      rateOfTurn,
      specialManeuver,
      navStatus,
      posDeviceType,
      antennaRefDimensions,
      length,
      width,
      draught,
      shipDescription,
      destination,
      destinationETA,
      currentPortGUID,
      currentPortLOCODE,
      lastPortGUID,
      lastPortLOCODE,
      nextPortGUID,
      nextPortLOCODE,
      etaCalculated,
      etaUpdated,
      distanceToGo,
      distanceTravelled,
      avgSpeed,
      maxSpeed,
      createdAt,
      createdBy,
      source,
      sourceDL,
      origin,
      dataMode,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: AIS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Unique identifier of the Track.
  /// Example: /// Example: TRACK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idTrack(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_IDTRACK, None)}
  }
  /// Unique identifier of the vessel.
  /// Example: /// Example: VESSEL-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idVessel(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_IDVESSEL, None)}
  }
  /// The Maritime Mobile Service Identity of the vessel.  MMSI is a nine-digit number that identifies the transmitter station of the vessel.
  /// Example: /// Example: 304010417
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mmsi(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AIS_Abridged::VT_MMSI, Some(0)).unwrap()}
  }
  /// The International Maritime Organization Number of the vessel.  IMON is a seven-digit number that uniquely identifies the vessel.
  /// Example: /// Example: 9015462
  /// Constraints: No constraints specified.
  #[inline]
  pub fn imon(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AIS_Abridged::VT_IMON, Some(0)).unwrap()}
  }
  /// The timestamp that the vessel position was recorded, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn ts(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_TS, None)}
  }
  /// The name of the vessel.  Vessel names that exceed the AIS 20 character are shortened (not truncated) to 15 character-spaces, followed by an underscore and the last 4 characters-spaces of the vessel full name.
  /// Example: /// Example: DORNUM
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn shipName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_SHIPNAME, None)}
  }
  /// The reported ship type (e.g. Passenger, Tanker, Cargo, Other, etc.).  See the engagedIn and specialCraft entries for additional information on certain types of vessels.
  /// Example: /// Example: Passenger
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn shipType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_SHIPTYPE, None)}
  }
  /// The activity that the vessel is engaged in.  This entry applies only when the shipType = Other.
  /// Example: /// Example: Cargo
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn engagedIn(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_ENGAGEDIN, None)}
  }
  /// The type of special craft designation of the vessel.  This entry applies only when the shipType = Special Craft.
  /// Example: /// Example: Tug
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn specialCraft(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_SPECIALCRAFT, None)}
  }
  /// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  #[inline]
  pub fn cargoType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_CARGOTYPE, None)}
  }
  /// A uniquely designated identifier for the vessel's transmitter station.
  /// Example: /// Example: V2OZ
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn callSign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_CALLSIGN, None)}
  }
  /// The flag of the subject vessel according to AIS transmission.
  /// Example: /// Example: United States
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn vesselFlag(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_VESSELFLAG, None)}
  }
  /// WGS-84 latitude of the vessel position, in degrees.  -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 47.758499
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude of the vessel position, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: -5.154223
  /// Constraints: No constraints specified.
  #[inline]
  pub fn lon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_LON, Some(0.0)).unwrap()}
  }
  /// Flag indicating high reported position accuracy (less than or equal to 10 meters).  A value of 0/false indicates low accuracy (greater than 10 meters).
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn posHiAccuracy(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AIS_Abridged::VT_POSHIACCURACY, Some(false)).unwrap()}
  }
  /// Flag indicating high reported position latency (greater than 5 seconds).  A value of 0/false indicates low latency (less than 5 seconds).
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn posHiLatency(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AIS_Abridged::VT_POSHILATENCY, Some(false)).unwrap()}
  }
  /// The speed-over-ground reported by the vessel, in kilometers/hour.
  /// Example: /// Example: 10.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn speed(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_SPEED, Some(0.0)).unwrap()}
  }
  /// The true heading reported by the vessel, in degrees.
  /// Example: /// Example: 329.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trueHeading(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_TRUEHEADING, Some(0.0)).unwrap()}
  }
  /// The course-over-ground reported by the vessel, in degrees.
  /// Example: /// Example: 157.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn course(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_COURSE, Some(0.0)).unwrap()}
  }
  /// The Rate-of-Turn for the vessel, in degrees/minute.  Positive value indicates that the vessel is turning right.
  /// Example: /// Example: 22.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rateOfTurn(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_RATEOFTURN, Some(0.0)).unwrap()}
  }
  /// Flag indicating that the vessel is engaged in a special maneuver (e.g. Waterway Navigation).
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn specialManeuver(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AIS_Abridged::VT_SPECIALMANEUVER, Some(false)).unwrap()}
  }
  /// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Underway Using Engine
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn navStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_NAVSTATUS, None)}
  }
  /// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: GPS
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn posDeviceType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_POSDEVICETYPE, None)}
  }
  /// The reference dimensions of the vessel, reported as [A, B, C, D], in meters.  Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna.  Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
  /// Example: /// Example: [50.1, 50.1, 20.1, 20.1]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn antennaRefDimensions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AIS_Abridged::VT_ANTENNAREFDIMENSIONS, None)}
  }
  /// The overall length of the vessel, in meters.  A value of 511 indicates a vessel length of 511 meters or greater.
  /// Example: /// Example: 511.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn length(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_LENGTH, Some(0.0)).unwrap()}
  }
  /// The breadth of the vessel, in meters.  A value of 63 indicates a vessel breadth of 63 meters or greater.
  /// Example: /// Example: 24.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_WIDTH, Some(0.0)).unwrap()}
  }
  /// The maximum static draught, in meters, of the vessel according to the AIS transmission.
  /// Example: /// Example: 21.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn draught(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_DRAUGHT, Some(0.0)).unwrap()}
  }
  /// Further description or explanation of the vessel or type.
  /// Example: /// Example: Search and rescue vessels
  /// Constraints: Minimum length = 0, Maximum length = 100
  #[inline]
  pub fn shipDescription(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_SHIPDESCRIPTION, None)}
  }
  /// The destination of the vessel according to the AIS transmission.
  /// Example: /// Example: USCLE
  /// Constraints: Minimum length = 0, Maximum length = 20
  #[inline]
  pub fn destination(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_DESTINATION, None)}
  }
  /// The Estimated Time of Arrival of the vessel at the destination, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn destinationETA(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_DESTINATIONETA, None)}
  }
  /// The US Geographic Unique Identifier of the current port hosting the vessel.
  /// Example: /// Example: 0ABC
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn currentPortGUID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_CURRENTPORTGUID, None)}
  }
  /// The UN Location Code of the current port hosting the vessel.
  /// Example: /// Example: XF013
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn currentPortLOCODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_CURRENTPORTLOCODE, None)}
  }
  /// The US Geographic Unique Identifier of the last port visited by the vessel.
  /// Example: /// Example: 0VAX
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn lastPortGUID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_LASTPORTGUID, None)}
  }
  /// The UN Location Code of the last port visited by the vessel.
  /// Example: /// Example: USSKY
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn lastPortLOCODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_LASTPORTLOCODE, None)}
  }
  /// The US Geographic Unique Identifier of the next destination port of the vessel.
  /// Example: /// Example: 0Z8Q
  /// Constraints: Minimum length = 0, Maximum length = 4
  #[inline]
  pub fn nextPortGUID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_NEXTPORTGUID, None)}
  }
  /// The UN  Location Code of the next destination port of the vessel.
  /// Example: /// Example: USCLE
  /// Constraints: Minimum length = 0, Maximum length = 5
  #[inline]
  pub fn nextPortLOCODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_NEXTPORTLOCODE, None)}
  }
  /// The Estimated Time of Arrival of the vessel at the destination port, according to MarineTraffic calculations, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn etaCalculated(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_ETACALCULATED, None)}
  }
  /// The date and time that the ETA was calculated by MarineTraffic, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn etaUpdated(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_ETAUPDATED, None)}
  }
  /// The remaining distance, in kilometers, for the vessel to reach the reported destination.
  /// Example: /// Example: 150.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn distanceToGo(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_DISTANCETOGO, Some(0.0)).unwrap()}
  }
  /// The distance, in kilometers, that the vessel has travelled since departing the last port.
  /// Example: /// Example: 200.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn distanceTravelled(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_DISTANCETRAVELLED, Some(0.0)).unwrap()}
  }
  /// The average speed, in kilometers/hour, calculated for the subject vessel during the latest voyage (port to port).
  /// Example: /// Example: 12.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn avgSpeed(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_AVGSPEED, Some(0.0)).unwrap()}
  }
  /// The maximum speed, in kilometers/hour, reported by the subject vessel during the latest voyage (port to port).
  /// Example: /// Example: 13.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxSpeed(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AIS_Abridged::VT_MAXSPEED, Some(0.0)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_CREATEDBY, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_SOURCE, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_SOURCEDL, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> AIS_Abridged_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AIS_Abridged_dataMode_Enum>(AIS_Abridged::VT_DATAMODE, Some(AIS_Abridged_dataMode_Enum::REAL)).unwrap()}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AIS_Abridged::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for AIS_Abridged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idTrack", Self::VT_IDTRACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idVessel", Self::VT_IDVESSEL, false)?
     .visit_field::<i64>("mmsi", Self::VT_MMSI, false)?
     .visit_field::<i64>("imon", Self::VT_IMON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ts", Self::VT_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shipName", Self::VT_SHIPNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shipType", Self::VT_SHIPTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("engagedIn", Self::VT_ENGAGEDIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("specialCraft", Self::VT_SPECIALCRAFT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cargoType", Self::VT_CARGOTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("callSign", Self::VT_CALLSIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("vesselFlag", Self::VT_VESSELFLAG, false)?
     .visit_field::<f64>("lat", Self::VT_LAT, false)?
     .visit_field::<f64>("lon", Self::VT_LON, false)?
     .visit_field::<bool>("posHiAccuracy", Self::VT_POSHIACCURACY, false)?
     .visit_field::<bool>("posHiLatency", Self::VT_POSHILATENCY, false)?
     .visit_field::<f64>("speed", Self::VT_SPEED, false)?
     .visit_field::<f64>("trueHeading", Self::VT_TRUEHEADING, false)?
     .visit_field::<f64>("course", Self::VT_COURSE, false)?
     .visit_field::<f64>("rateOfTurn", Self::VT_RATEOFTURN, false)?
     .visit_field::<bool>("specialManeuver", Self::VT_SPECIALMANEUVER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("navStatus", Self::VT_NAVSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("posDeviceType", Self::VT_POSDEVICETYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("antennaRefDimensions", Self::VT_ANTENNAREFDIMENSIONS, false)?
     .visit_field::<f64>("length", Self::VT_LENGTH, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<f64>("draught", Self::VT_DRAUGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shipDescription", Self::VT_SHIPDESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("destination", Self::VT_DESTINATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("destinationETA", Self::VT_DESTINATIONETA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentPortGUID", Self::VT_CURRENTPORTGUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentPortLOCODE", Self::VT_CURRENTPORTLOCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastPortGUID", Self::VT_LASTPORTGUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastPortLOCODE", Self::VT_LASTPORTLOCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nextPortGUID", Self::VT_NEXTPORTGUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nextPortLOCODE", Self::VT_NEXTPORTLOCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("etaCalculated", Self::VT_ETACALCULATED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("etaUpdated", Self::VT_ETAUPDATED, false)?
     .visit_field::<f64>("distanceToGo", Self::VT_DISTANCETOGO, false)?
     .visit_field::<f64>("distanceTravelled", Self::VT_DISTANCETRAVELLED, false)?
     .visit_field::<f64>("avgSpeed", Self::VT_AVGSPEED, false)?
     .visit_field::<f64>("maxSpeed", Self::VT_MAXSPEED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<AIS_Abridged_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct AIS_AbridgedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idTrack: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idVessel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mmsi: i64,
    pub imon: i64,
    pub ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shipName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shipType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub engagedIn: Option<flatbuffers::WIPOffset<&'a str>>,
    pub specialCraft: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cargoType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub callSign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vesselFlag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lat: f64,
    pub lon: f64,
    pub posHiAccuracy: bool,
    pub posHiLatency: bool,
    pub speed: f64,
    pub trueHeading: f64,
    pub course: f64,
    pub rateOfTurn: f64,
    pub specialManeuver: bool,
    pub navStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub posDeviceType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub antennaRefDimensions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub length: f64,
    pub width: f64,
    pub draught: f64,
    pub shipDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub destination: Option<flatbuffers::WIPOffset<&'a str>>,
    pub destinationETA: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentPortGUID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentPortLOCODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lastPortGUID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lastPortLOCODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nextPortGUID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nextPortLOCODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub etaCalculated: Option<flatbuffers::WIPOffset<&'a str>>,
    pub etaUpdated: Option<flatbuffers::WIPOffset<&'a str>>,
    pub distanceToGo: f64,
    pub distanceTravelled: f64,
    pub avgSpeed: f64,
    pub maxSpeed: f64,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: AIS_Abridged_dataMode_Enum,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AIS_AbridgedArgs<'a> {
  #[inline]
  fn default() -> Self {
    AIS_AbridgedArgs {
      id: None,
      classificationMarking: None,
      idTrack: None,
      idVessel: None,
      mmsi: 0,
      imon: 0,
      ts: None,
      shipName: None,
      shipType: None,
      engagedIn: None,
      specialCraft: None,
      cargoType: None,
      callSign: None,
      vesselFlag: None,
      lat: 0.0,
      lon: 0.0,
      posHiAccuracy: false,
      posHiLatency: false,
      speed: 0.0,
      trueHeading: 0.0,
      course: 0.0,
      rateOfTurn: 0.0,
      specialManeuver: false,
      navStatus: None,
      posDeviceType: None,
      antennaRefDimensions: None,
      length: 0.0,
      width: 0.0,
      draught: 0.0,
      shipDescription: None,
      destination: None,
      destinationETA: None,
      currentPortGUID: None,
      currentPortLOCODE: None,
      lastPortGUID: None,
      lastPortLOCODE: None,
      nextPortGUID: None,
      nextPortLOCODE: None,
      etaCalculated: None,
      etaUpdated: None,
      distanceToGo: 0.0,
      distanceTravelled: 0.0,
      avgSpeed: 0.0,
      maxSpeed: 0.0,
      createdAt: None,
      createdBy: None,
      source: None,
      sourceDL: None,
      origin: None,
      dataMode: AIS_Abridged_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}

pub struct AIS_AbridgedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AIS_AbridgedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_idTrack(&mut self, idTrack: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_IDTRACK, idTrack);
  }
  #[inline]
  pub fn add_idVessel(&mut self, idVessel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_IDVESSEL, idVessel);
  }
  #[inline]
  pub fn add_mmsi(&mut self, mmsi: i64) {
    self.fbb_.push_slot::<i64>(AIS_Abridged::VT_MMSI, mmsi, 0);
  }
  #[inline]
  pub fn add_imon(&mut self, imon: i64) {
    self.fbb_.push_slot::<i64>(AIS_Abridged::VT_IMON, imon, 0);
  }
  #[inline]
  pub fn add_ts(&mut self, ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_TS, ts);
  }
  #[inline]
  pub fn add_shipName(&mut self, shipName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_SHIPNAME, shipName);
  }
  #[inline]
  pub fn add_shipType(&mut self, shipType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_SHIPTYPE, shipType);
  }
  #[inline]
  pub fn add_engagedIn(&mut self, engagedIn: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_ENGAGEDIN, engagedIn);
  }
  #[inline]
  pub fn add_specialCraft(&mut self, specialCraft: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_SPECIALCRAFT, specialCraft);
  }
  #[inline]
  pub fn add_cargoType(&mut self, cargoType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_CARGOTYPE, cargoType);
  }
  #[inline]
  pub fn add_callSign(&mut self, callSign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_CALLSIGN, callSign);
  }
  #[inline]
  pub fn add_vesselFlag(&mut self, vesselFlag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_VESSELFLAG, vesselFlag);
  }
  #[inline]
  pub fn add_lat(&mut self, lat: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_LAT, lat, 0.0);
  }
  #[inline]
  pub fn add_lon(&mut self, lon: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_LON, lon, 0.0);
  }
  #[inline]
  pub fn add_posHiAccuracy(&mut self, posHiAccuracy: bool) {
    self.fbb_.push_slot::<bool>(AIS_Abridged::VT_POSHIACCURACY, posHiAccuracy, false);
  }
  #[inline]
  pub fn add_posHiLatency(&mut self, posHiLatency: bool) {
    self.fbb_.push_slot::<bool>(AIS_Abridged::VT_POSHILATENCY, posHiLatency, false);
  }
  #[inline]
  pub fn add_speed(&mut self, speed: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_SPEED, speed, 0.0);
  }
  #[inline]
  pub fn add_trueHeading(&mut self, trueHeading: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_TRUEHEADING, trueHeading, 0.0);
  }
  #[inline]
  pub fn add_course(&mut self, course: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_COURSE, course, 0.0);
  }
  #[inline]
  pub fn add_rateOfTurn(&mut self, rateOfTurn: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_RATEOFTURN, rateOfTurn, 0.0);
  }
  #[inline]
  pub fn add_specialManeuver(&mut self, specialManeuver: bool) {
    self.fbb_.push_slot::<bool>(AIS_Abridged::VT_SPECIALMANEUVER, specialManeuver, false);
  }
  #[inline]
  pub fn add_navStatus(&mut self, navStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_NAVSTATUS, navStatus);
  }
  #[inline]
  pub fn add_posDeviceType(&mut self, posDeviceType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_POSDEVICETYPE, posDeviceType);
  }
  #[inline]
  pub fn add_antennaRefDimensions(&mut self, antennaRefDimensions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_ANTENNAREFDIMENSIONS, antennaRefDimensions);
  }
  #[inline]
  pub fn add_length(&mut self, length: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_LENGTH, length, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_draught(&mut self, draught: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_DRAUGHT, draught, 0.0);
  }
  #[inline]
  pub fn add_shipDescription(&mut self, shipDescription: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_SHIPDESCRIPTION, shipDescription);
  }
  #[inline]
  pub fn add_destination(&mut self, destination: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_DESTINATION, destination);
  }
  #[inline]
  pub fn add_destinationETA(&mut self, destinationETA: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_DESTINATIONETA, destinationETA);
  }
  #[inline]
  pub fn add_currentPortGUID(&mut self, currentPortGUID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_CURRENTPORTGUID, currentPortGUID);
  }
  #[inline]
  pub fn add_currentPortLOCODE(&mut self, currentPortLOCODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_CURRENTPORTLOCODE, currentPortLOCODE);
  }
  #[inline]
  pub fn add_lastPortGUID(&mut self, lastPortGUID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_LASTPORTGUID, lastPortGUID);
  }
  #[inline]
  pub fn add_lastPortLOCODE(&mut self, lastPortLOCODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_LASTPORTLOCODE, lastPortLOCODE);
  }
  #[inline]
  pub fn add_nextPortGUID(&mut self, nextPortGUID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_NEXTPORTGUID, nextPortGUID);
  }
  #[inline]
  pub fn add_nextPortLOCODE(&mut self, nextPortLOCODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_NEXTPORTLOCODE, nextPortLOCODE);
  }
  #[inline]
  pub fn add_etaCalculated(&mut self, etaCalculated: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_ETACALCULATED, etaCalculated);
  }
  #[inline]
  pub fn add_etaUpdated(&mut self, etaUpdated: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_ETAUPDATED, etaUpdated);
  }
  #[inline]
  pub fn add_distanceToGo(&mut self, distanceToGo: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_DISTANCETOGO, distanceToGo, 0.0);
  }
  #[inline]
  pub fn add_distanceTravelled(&mut self, distanceTravelled: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_DISTANCETRAVELLED, distanceTravelled, 0.0);
  }
  #[inline]
  pub fn add_avgSpeed(&mut self, avgSpeed: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_AVGSPEED, avgSpeed, 0.0);
  }
  #[inline]
  pub fn add_maxSpeed(&mut self, maxSpeed: f64) {
    self.fbb_.push_slot::<f64>(AIS_Abridged::VT_MAXSPEED, maxSpeed, 0.0);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: AIS_Abridged_dataMode_Enum) {
    self.fbb_.push_slot::<AIS_Abridged_dataMode_Enum>(AIS_Abridged::VT_DATAMODE, dataMode, AIS_Abridged_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AIS_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AIS_AbridgedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AIS_AbridgedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AIS_Abridged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AIS_Abridged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AIS_Abridged");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("idTrack", &self.idTrack());
      ds.field("idVessel", &self.idVessel());
      ds.field("mmsi", &self.mmsi());
      ds.field("imon", &self.imon());
      ds.field("ts", &self.ts());
      ds.field("shipName", &self.shipName());
      ds.field("shipType", &self.shipType());
      ds.field("engagedIn", &self.engagedIn());
      ds.field("specialCraft", &self.specialCraft());
      ds.field("cargoType", &self.cargoType());
      ds.field("callSign", &self.callSign());
      ds.field("vesselFlag", &self.vesselFlag());
      ds.field("lat", &self.lat());
      ds.field("lon", &self.lon());
      ds.field("posHiAccuracy", &self.posHiAccuracy());
      ds.field("posHiLatency", &self.posHiLatency());
      ds.field("speed", &self.speed());
      ds.field("trueHeading", &self.trueHeading());
      ds.field("course", &self.course());
      ds.field("rateOfTurn", &self.rateOfTurn());
      ds.field("specialManeuver", &self.specialManeuver());
      ds.field("navStatus", &self.navStatus());
      ds.field("posDeviceType", &self.posDeviceType());
      ds.field("antennaRefDimensions", &self.antennaRefDimensions());
      ds.field("length", &self.length());
      ds.field("width", &self.width());
      ds.field("draught", &self.draught());
      ds.field("shipDescription", &self.shipDescription());
      ds.field("destination", &self.destination());
      ds.field("destinationETA", &self.destinationETA());
      ds.field("currentPortGUID", &self.currentPortGUID());
      ds.field("currentPortLOCODE", &self.currentPortLOCODE());
      ds.field("lastPortGUID", &self.lastPortGUID());
      ds.field("lastPortLOCODE", &self.lastPortLOCODE());
      ds.field("nextPortGUID", &self.nextPortGUID());
      ds.field("nextPortLOCODE", &self.nextPortLOCODE());
      ds.field("etaCalculated", &self.etaCalculated());
      ds.field("etaUpdated", &self.etaUpdated());
      ds.field("distanceToGo", &self.distanceToGo());
      ds.field("distanceTravelled", &self.distanceTravelled());
      ds.field("avgSpeed", &self.avgSpeed());
      ds.field("maxSpeed", &self.maxSpeed());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("source", &self.source());
      ds.field("sourceDL", &self.sourceDL());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AIS_AbridgedT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub idTrack: Option<String>,
  pub idVessel: Option<String>,
  pub mmsi: i64,
  pub imon: i64,
  pub ts: Option<String>,
  pub shipName: Option<String>,
  pub shipType: Option<String>,
  pub engagedIn: Option<String>,
  pub specialCraft: Option<String>,
  pub cargoType: Option<String>,
  pub callSign: Option<String>,
  pub vesselFlag: Option<String>,
  pub lat: f64,
  pub lon: f64,
  pub posHiAccuracy: bool,
  pub posHiLatency: bool,
  pub speed: f64,
  pub trueHeading: f64,
  pub course: f64,
  pub rateOfTurn: f64,
  pub specialManeuver: bool,
  pub navStatus: Option<String>,
  pub posDeviceType: Option<String>,
  pub antennaRefDimensions: Option<Vec<String>>,
  pub length: f64,
  pub width: f64,
  pub draught: f64,
  pub shipDescription: Option<String>,
  pub destination: Option<String>,
  pub destinationETA: Option<String>,
  pub currentPortGUID: Option<String>,
  pub currentPortLOCODE: Option<String>,
  pub lastPortGUID: Option<String>,
  pub lastPortLOCODE: Option<String>,
  pub nextPortGUID: Option<String>,
  pub nextPortLOCODE: Option<String>,
  pub etaCalculated: Option<String>,
  pub etaUpdated: Option<String>,
  pub distanceToGo: f64,
  pub distanceTravelled: f64,
  pub avgSpeed: f64,
  pub maxSpeed: f64,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub source: Option<String>,
  pub sourceDL: Option<String>,
  pub origin: Option<String>,
  pub dataMode: AIS_Abridged_dataMode_Enum,
  pub origNetwork: Option<String>,
}
impl Default for AIS_AbridgedT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      idTrack: None,
      idVessel: None,
      mmsi: 0,
      imon: 0,
      ts: None,
      shipName: None,
      shipType: None,
      engagedIn: None,
      specialCraft: None,
      cargoType: None,
      callSign: None,
      vesselFlag: None,
      lat: 0.0,
      lon: 0.0,
      posHiAccuracy: false,
      posHiLatency: false,
      speed: 0.0,
      trueHeading: 0.0,
      course: 0.0,
      rateOfTurn: 0.0,
      specialManeuver: false,
      navStatus: None,
      posDeviceType: None,
      antennaRefDimensions: None,
      length: 0.0,
      width: 0.0,
      draught: 0.0,
      shipDescription: None,
      destination: None,
      destinationETA: None,
      currentPortGUID: None,
      currentPortLOCODE: None,
      lastPortGUID: None,
      lastPortLOCODE: None,
      nextPortGUID: None,
      nextPortLOCODE: None,
      etaCalculated: None,
      etaUpdated: None,
      distanceToGo: 0.0,
      distanceTravelled: 0.0,
      avgSpeed: 0.0,
      maxSpeed: 0.0,
      createdAt: None,
      createdBy: None,
      source: None,
      sourceDL: None,
      origin: None,
      dataMode: AIS_Abridged_dataMode_Enum::REAL,
      origNetwork: None,
    }
  }
}
impl AIS_AbridgedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AIS_Abridged<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idTrack = self.idTrack.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idVessel = self.idVessel.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mmsi = self.mmsi;
    let imon = self.imon;
    let ts = self.ts.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let shipName = self.shipName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let shipType = self.shipType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let engagedIn = self.engagedIn.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let specialCraft = self.specialCraft.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cargoType = self.cargoType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let callSign = self.callSign.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let vesselFlag = self.vesselFlag.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lat = self.lat;
    let lon = self.lon;
    let posHiAccuracy = self.posHiAccuracy;
    let posHiLatency = self.posHiLatency;
    let speed = self.speed;
    let trueHeading = self.trueHeading;
    let course = self.course;
    let rateOfTurn = self.rateOfTurn;
    let specialManeuver = self.specialManeuver;
    let navStatus = self.navStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let posDeviceType = self.posDeviceType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let antennaRefDimensions = self.antennaRefDimensions.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let length = self.length;
    let width = self.width;
    let draught = self.draught;
    let shipDescription = self.shipDescription.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let destination = self.destination.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let destinationETA = self.destinationETA.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let currentPortGUID = self.currentPortGUID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let currentPortLOCODE = self.currentPortLOCODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lastPortGUID = self.lastPortGUID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lastPortLOCODE = self.lastPortLOCODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let nextPortGUID = self.nextPortGUID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let nextPortLOCODE = self.nextPortLOCODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let etaCalculated = self.etaCalculated.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let etaUpdated = self.etaUpdated.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let distanceToGo = self.distanceToGo;
    let distanceTravelled = self.distanceTravelled;
    let avgSpeed = self.avgSpeed;
    let maxSpeed = self.maxSpeed;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    AIS_Abridged::create(_fbb, &AIS_AbridgedArgs{
      id,
      classificationMarking,
      idTrack,
      idVessel,
      mmsi,
      imon,
      ts,
      shipName,
      shipType,
      engagedIn,
      specialCraft,
      cargoType,
      callSign,
      vesselFlag,
      lat,
      lon,
      posHiAccuracy,
      posHiLatency,
      speed,
      trueHeading,
      course,
      rateOfTurn,
      specialManeuver,
      navStatus,
      posDeviceType,
      antennaRefDimensions,
      length,
      width,
      draught,
      shipDescription,
      destination,
      destinationETA,
      currentPortGUID,
      currentPortLOCODE,
      lastPortGUID,
      lastPortLOCODE,
      nextPortGUID,
      nextPortLOCODE,
      etaCalculated,
      etaUpdated,
      distanceToGo,
      distanceTravelled,
      avgSpeed,
      maxSpeed,
      createdAt,
      createdBy,
      source,
      sourceDL,
      origin,
      dataMode,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AIS_Abridged`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ais_abridged_unchecked`.
pub fn root_as_ais_abridged(buf: &[u8]) -> Result<AIS_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AIS_Abridged>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AIS_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ais_abridged_unchecked`.
pub fn size_prefixed_root_as_ais_abridged(buf: &[u8]) -> Result<AIS_Abridged, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AIS_Abridged>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AIS_Abridged` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ais_abridged_unchecked`.
pub fn root_as_ais_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AIS_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AIS_Abridged<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AIS_Abridged` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ais_abridged_unchecked`.
pub fn size_prefixed_root_as_ais_abridged_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AIS_Abridged<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AIS_Abridged<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AIS_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AIS_Abridged`.
pub unsafe fn root_as_ais_abridged_unchecked(buf: &[u8]) -> AIS_Abridged {
  flatbuffers::root_unchecked::<AIS_Abridged>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AIS_Abridged and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AIS_Abridged`.
pub unsafe fn size_prefixed_root_as_ais_abridged_unchecked(buf: &[u8]) -> AIS_Abridged {
  flatbuffers::size_prefixed_root_unchecked::<AIS_Abridged>(buf)
}
pub const AIS_ABRIDGED_IDENTIFIER: &str = "AISA";

#[inline]
pub fn ais_abridged_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIS_ABRIDGED_IDENTIFIER, false)
}

#[inline]
pub fn ais_abridged_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AIS_ABRIDGED_IDENTIFIER, true)
}

#[inline]
pub fn finish_ais_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AIS_Abridged<'a>>) {
  fbb.finish(root, Some(AIS_ABRIDGED_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_ais_abridged_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AIS_Abridged<'a>>) {
  fbb.finish_size_prefixed(root, Some(AIS_ABRIDGED_IDENTIFIER));
}
