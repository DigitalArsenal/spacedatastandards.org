// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum EvacCondition_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// The group path from transmitter to receiver.
pub struct EvacCondition_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EvacCondition_Full<'a> {
  type Inner = EvacCondition_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EvacCondition_Full<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_BODYPART: flatbuffers::VOffsetT = 6;
  pub const VT_TIME: flatbuffers::VOffsetT = 8;
  pub const VT_COMMENTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EvacCondition_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EvacCondition_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<EvacCondition_Full<'bldr>> {
    let mut builder = EvacCondition_FullBuilder::new(_fbb);
    if let Some(x) = args.comments { builder.add_comments(x); }
    if let Some(x) = args.time { builder.add_time(x); }
    if let Some(x) = args.bodyPart { builder.add_bodyPart(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EvacCondition_FullT {
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let bodyPart = self.bodyPart().map(|x| {
      x.to_string()
    });
    let time = self.time().map(|x| {
      x.to_string()
    });
    let comments = self.comments().map(|x| {
      x.to_string()
    });
    EvacCondition_FullT {
      type_,
      bodyPart,
      time,
      comments,
    }
  }

  /// Health condition assessment.  Intended as, but not constrained to, K07.1 Condition Type Enumeration (e.g. ACTIVITY HIGH, ACTIVITY LOW, ACTIVITY MEDIUM, ACTIVITY NONE, AVPU ALERT, AVPU ALTERED MENTAL STATE, AVPU PAIN, AVPU UNRESPONSIVE, etc.).
  /// Example: /// Example: ACTIVITY LOW
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacCondition_Full::VT_TYPE_, None)}
  }
  /// Body part location or body part referenced in condition.  Intended as, but not constrained to, K07.1 Body Location Enumeration (e.g. ANKLE LEFT BACK, ANKLE LEFT FRONT, ANKLE RIGHT BACK, ANKLE RIGHT FRONT, ARM LEFT BACK, ARM LEFT ELBOW BACK, ARM LEFT ELBOW FRONT, ARM LEFT FRONT, ARM LEFT LOWER BACK, etc.).
  /// Example: /// Example: ANKLE LEFT FRONT
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn bodyPart(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacCondition_Full::VT_BODYPART, None)}
  }
  /// Datetime of the condition diagnosis in ISO 8601 UTC datetime format.
  /// Example: /// Example: 2021-10-15T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn time(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacCondition_Full::VT_TIME, None)}
  }
  /// Additional comments on the patient's condition.
  /// Example: /// Example: Comments on the patient's condition.
  /// Constraints: Minimum length = 0, Maximum length = 1024
  #[inline]
  pub fn comments(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EvacCondition_Full::VT_COMMENTS, None)}
  }
}

impl flatbuffers::Verifiable for EvacCondition_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bodyPart", Self::VT_BODYPART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("time", Self::VT_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("comments", Self::VT_COMMENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct EvacCondition_FullArgs<'a> {
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bodyPart: Option<flatbuffers::WIPOffset<&'a str>>,
    pub time: Option<flatbuffers::WIPOffset<&'a str>>,
    pub comments: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EvacCondition_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    EvacCondition_FullArgs {
      type_: None,
      bodyPart: None,
      time: None,
      comments: None,
    }
  }
}

pub struct EvacCondition_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EvacCondition_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacCondition_Full::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_bodyPart(&mut self, bodyPart: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacCondition_Full::VT_BODYPART, bodyPart);
  }
  #[inline]
  pub fn add_time(&mut self, time: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacCondition_Full::VT_TIME, time);
  }
  #[inline]
  pub fn add_comments(&mut self, comments: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EvacCondition_Full::VT_COMMENTS, comments);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EvacCondition_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EvacCondition_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EvacCondition_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EvacCondition_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EvacCondition_Full");
      ds.field("type_", &self.type_());
      ds.field("bodyPart", &self.bodyPart());
      ds.field("time", &self.time());
      ds.field("comments", &self.comments());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EvacCondition_FullT {
  pub type_: Option<String>,
  pub bodyPart: Option<String>,
  pub time: Option<String>,
  pub comments: Option<String>,
}
impl Default for EvacCondition_FullT {
  fn default() -> Self {
    Self {
      type_: None,
      bodyPart: None,
      time: None,
      comments: None,
    }
  }
}
impl EvacCondition_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EvacCondition_Full<'b>> {
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let bodyPart = self.bodyPart.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let time = self.time.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let comments = self.comments.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    EvacCondition_Full::create(_fbb, &EvacCondition_FullArgs{
      type_,
      bodyPart,
      time,
      comments,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EvacCondition_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evac_condition_full_unchecked`.
pub fn root_as_evac_condition_full(buf: &[u8]) -> Result<EvacCondition_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EvacCondition_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EvacCondition_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_evac_condition_full_unchecked`.
pub fn size_prefixed_root_as_evac_condition_full(buf: &[u8]) -> Result<EvacCondition_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EvacCondition_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EvacCondition_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evac_condition_full_unchecked`.
pub fn root_as_evac_condition_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EvacCondition_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EvacCondition_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EvacCondition_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_evac_condition_full_unchecked`.
pub fn size_prefixed_root_as_evac_condition_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EvacCondition_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EvacCondition_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EvacCondition_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EvacCondition_Full`.
pub unsafe fn root_as_evac_condition_full_unchecked(buf: &[u8]) -> EvacCondition_Full {
  flatbuffers::root_unchecked::<EvacCondition_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EvacCondition_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EvacCondition_Full`.
pub unsafe fn size_prefixed_root_as_evac_condition_full_unchecked(buf: &[u8]) -> EvacCondition_Full {
  flatbuffers::size_prefixed_root_unchecked::<EvacCondition_Full>(buf)
}
pub const EVAC_CONDITION_FULL_IDENTIFIER: &str = "EVAC";

#[inline]
pub fn evac_condition_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EVAC_CONDITION_FULL_IDENTIFIER, false)
}

#[inline]
pub fn evac_condition_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EVAC_CONDITION_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_evac_condition_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<EvacCondition_Full<'a>>) {
  fbb.finish(root, Some(EVAC_CONDITION_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_evac_condition_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<EvacCondition_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(EVAC_CONDITION_FULL_IDENTIFIER));
}
