// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MANEUVER_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MANEUVER_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MANEUVER_FULL_DATA_MODE_ENUM: [Maneuver_Full_dataMode_Enum; 4] = [
  Maneuver_Full_dataMode_Enum::REAL,
  Maneuver_Full_dataMode_Enum::TEST,
  Maneuver_Full_dataMode_Enum::SIMULATED,
  Maneuver_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Maneuver_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Maneuver_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Maneuver_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Maneuver_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Maneuver_Full_dataMode_Enum {
    type Output = Maneuver_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Maneuver_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Maneuver_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Maneuver_Full_dataMode_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MANEUVER_FULL_SOURCED_DATA_TYPES_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MANEUVER_FULL_SOURCED_DATA_TYPES_ENUM: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MANEUVER_FULL_SOURCED_DATA_TYPES_ENUM: [Maneuver_Full_sourcedDataTypes_Enum; 6] = [
  Maneuver_Full_sourcedDataTypes_Enum::EO,
  Maneuver_Full_sourcedDataTypes_Enum::RADAR,
  Maneuver_Full_sourcedDataTypes_Enum::RF,
  Maneuver_Full_sourcedDataTypes_Enum::DOA,
  Maneuver_Full_sourcedDataTypes_Enum::ELSET,
  Maneuver_Full_sourcedDataTypes_Enum::SV,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Maneuver_Full_sourcedDataTypes_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl Maneuver_Full_sourcedDataTypes_Enum {
  /// No description available.
  pub const EO: Self = Self(0);
  /// No description available.
  pub const RADAR: Self = Self(1);
  /// No description available.
  pub const RF: Self = Self(2);
  /// No description available.
  pub const DOA: Self = Self(3);
  /// No description available.
  pub const ELSET: Self = Self(4);
  /// No description available.
  pub const SV: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EO,
    Self::RADAR,
    Self::RF,
    Self::DOA,
    Self::ELSET,
    Self::SV,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::EO => Some("EO"),
      Self::RADAR => Some("RADAR"),
      Self::RF => Some("RF"),
      Self::DOA => Some("DOA"),
      Self::ELSET => Some("ELSET"),
      Self::SV => Some("SV"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Maneuver_Full_sourcedDataTypes_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Maneuver_Full_sourcedDataTypes_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Maneuver_Full_sourcedDataTypes_Enum {
    type Output = Maneuver_Full_sourcedDataTypes_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Maneuver_Full_sourcedDataTypes_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Maneuver_Full_sourcedDataTypes_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Maneuver_Full_sourcedDataTypes_Enum {}
pub enum Maneuver_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Model representation of on-orbit object maneuver information for detected, possible, and confirmed maneuvers.
pub struct Maneuver_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Maneuver_Full<'a> {
  type Inner = Maneuver_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Maneuver_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_SATNO: flatbuffers::VOffsetT = 8;
  pub const VT_REPORTTIME: flatbuffers::VOffsetT = 10;
  pub const VT_EVENTSTARTTIME: flatbuffers::VOffsetT = 12;
  pub const VT_EVENTENDTIME: flatbuffers::VOffsetT = 14;
  pub const VT_TOTALBURNTIME: flatbuffers::VOffsetT = 16;
  pub const VT_ODFITENDTIME: flatbuffers::VOffsetT = 18;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 20;
  pub const VT_IDSENSOR: flatbuffers::VOffsetT = 22;
  pub const VT_UCT: flatbuffers::VOffsetT = 24;
  pub const VT_MANEUVERUNC: flatbuffers::VOffsetT = 26;
  pub const VT_CHARACTERIZATION: flatbuffers::VOffsetT = 28;
  pub const VT_CHARACTERIZATIONUNC: flatbuffers::VOffsetT = 30;
  pub const VT_EVENTID: flatbuffers::VOffsetT = 32;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 34;
  pub const VT_ORIGSENSORID: flatbuffers::VOffsetT = 36;
  pub const VT_STATUS: flatbuffers::VOffsetT = 38;
  pub const VT_DELTAPOS: flatbuffers::VOffsetT = 40;
  pub const VT_DELTAPOSU: flatbuffers::VOffsetT = 42;
  pub const VT_DELTAPOSV: flatbuffers::VOffsetT = 44;
  pub const VT_DELTAPOSW: flatbuffers::VOffsetT = 46;
  pub const VT_DELTAVEL: flatbuffers::VOffsetT = 48;
  pub const VT_DELTAVELU: flatbuffers::VOffsetT = 50;
  pub const VT_DELTAVELV: flatbuffers::VOffsetT = 52;
  pub const VT_DELTAVELW: flatbuffers::VOffsetT = 54;
  pub const VT_DELTAMASS: flatbuffers::VOffsetT = 56;
  pub const VT_PREEVENTIDELSET: flatbuffers::VOffsetT = 58;
  pub const VT_PREEVENTELSET: flatbuffers::VOffsetT = 60;
  pub const VT_PREEVENTIDSTATEVECTOR: flatbuffers::VOffsetT = 62;
  pub const VT_PREEVENTSTATEVECTOR: flatbuffers::VOffsetT = 64;
  pub const VT_PREPOSX: flatbuffers::VOffsetT = 66;
  pub const VT_PREPOSY: flatbuffers::VOffsetT = 68;
  pub const VT_PREPOSZ: flatbuffers::VOffsetT = 70;
  pub const VT_PREVELX: flatbuffers::VOffsetT = 72;
  pub const VT_PREVELY: flatbuffers::VOffsetT = 74;
  pub const VT_PREVELZ: flatbuffers::VOffsetT = 76;
  pub const VT_PRERADIATIONPRESSCOEFF: flatbuffers::VOffsetT = 78;
  pub const VT_PREBALLISTICCOEFF: flatbuffers::VOffsetT = 80;
  pub const VT_PREAPOGEE: flatbuffers::VOffsetT = 82;
  pub const VT_PREPERIGEE: flatbuffers::VOffsetT = 84;
  pub const VT_PREINCLINATION: flatbuffers::VOffsetT = 86;
  pub const VT_PREECCENTRICITY: flatbuffers::VOffsetT = 88;
  pub const VT_PREPERIOD: flatbuffers::VOffsetT = 90;
  pub const VT_PRERAAN: flatbuffers::VOffsetT = 92;
  pub const VT_PRESMA: flatbuffers::VOffsetT = 94;
  pub const VT_PREGEOLONGITUDE: flatbuffers::VOffsetT = 96;
  pub const VT_PREDRIFTRATE: flatbuffers::VOffsetT = 98;
  pub const VT_PRESIGMAU: flatbuffers::VOffsetT = 100;
  pub const VT_PRESIGMAV: flatbuffers::VOffsetT = 102;
  pub const VT_PRESIGMAW: flatbuffers::VOffsetT = 104;
  pub const VT_POSTEVENTIDELSET: flatbuffers::VOffsetT = 106;
  pub const VT_POSTEVENTELSET: flatbuffers::VOffsetT = 108;
  pub const VT_POSTEVENTIDSTATEVECTOR: flatbuffers::VOffsetT = 110;
  pub const VT_POSTEVENTSTATEVECTOR: flatbuffers::VOffsetT = 112;
  pub const VT_POSTPOSX: flatbuffers::VOffsetT = 114;
  pub const VT_POSTPOSY: flatbuffers::VOffsetT = 116;
  pub const VT_POSTPOSZ: flatbuffers::VOffsetT = 118;
  pub const VT_POSTVELX: flatbuffers::VOffsetT = 120;
  pub const VT_POSTVELY: flatbuffers::VOffsetT = 122;
  pub const VT_POSTVELZ: flatbuffers::VOffsetT = 124;
  pub const VT_POSTRADIATIONPRESSCOEFF: flatbuffers::VOffsetT = 126;
  pub const VT_POSTBALLISTICCOEFF: flatbuffers::VOffsetT = 128;
  pub const VT_POSTAPOGEE: flatbuffers::VOffsetT = 130;
  pub const VT_POSTPERIGEE: flatbuffers::VOffsetT = 132;
  pub const VT_POSTINCLINATION: flatbuffers::VOffsetT = 134;
  pub const VT_POSTECCENTRICITY: flatbuffers::VOffsetT = 136;
  pub const VT_POSTPERIOD: flatbuffers::VOffsetT = 138;
  pub const VT_POSTRAAN: flatbuffers::VOffsetT = 140;
  pub const VT_POSTSMA: flatbuffers::VOffsetT = 142;
  pub const VT_POSTGEOLONGITUDE: flatbuffers::VOffsetT = 144;
  pub const VT_POSTDRIFTRATE: flatbuffers::VOffsetT = 146;
  pub const VT_POSTSIGMAU: flatbuffers::VOffsetT = 148;
  pub const VT_POSTSIGMAV: flatbuffers::VOffsetT = 150;
  pub const VT_POSTSIGMAW: flatbuffers::VOffsetT = 152;
  pub const VT_COV: flatbuffers::VOffsetT = 154;
  pub const VT_POSTMASS: flatbuffers::VOffsetT = 156;
  pub const VT_POSTAREA: flatbuffers::VOffsetT = 158;
  pub const VT_NUMOBS: flatbuffers::VOffsetT = 160;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 162;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 164;
  pub const VT_STATEMODEL: flatbuffers::VOffsetT = 166;
  pub const VT_STATEMODELVERSION: flatbuffers::VOffsetT = 168;
  pub const VT_NUMACCELPOINTS: flatbuffers::VOffsetT = 170;
  pub const VT_MNVRACCELTIMES: flatbuffers::VOffsetT = 172;
  pub const VT_MNVRACCELS: flatbuffers::VOffsetT = 174;
  pub const VT_MNVRACCELUNCS: flatbuffers::VOffsetT = 176;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 178;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 180;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 182;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 184;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 186;
  pub const VT_TAGS: flatbuffers::VOffsetT = 188;
  pub const VT_ALGORITHM: flatbuffers::VOffsetT = 190;
  pub const VT_SOURCEDDATA: flatbuffers::VOffsetT = 192;
  pub const VT_SOURCEDDATATYPES: flatbuffers::VOffsetT = 194;
  pub const VT_ONORBIT: flatbuffers::VOffsetT = 196;
  pub const VT_TRANSACTIONID: flatbuffers::VOffsetT = 198;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 200;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Maneuver_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Maneuver_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<Maneuver_Full<'bldr>> {
    let mut builder = Maneuver_FullBuilder::new(_fbb);
    builder.add_stateModelVersion(args.stateModelVersion);
    builder.add_postArea(args.postArea);
    builder.add_postMass(args.postMass);
    builder.add_postSigmaW(args.postSigmaW);
    builder.add_postSigmaV(args.postSigmaV);
    builder.add_postSigmaU(args.postSigmaU);
    builder.add_postDriftRate(args.postDriftRate);
    builder.add_postGeoLongitude(args.postGeoLongitude);
    builder.add_postSMA(args.postSMA);
    builder.add_postRAAN(args.postRAAN);
    builder.add_postPeriod(args.postPeriod);
    builder.add_postEccentricity(args.postEccentricity);
    builder.add_postInclination(args.postInclination);
    builder.add_postPerigee(args.postPerigee);
    builder.add_postApogee(args.postApogee);
    builder.add_postBallisticCoeff(args.postBallisticCoeff);
    builder.add_postRadiationPressCoeff(args.postRadiationPressCoeff);
    builder.add_postVelZ(args.postVelZ);
    builder.add_postVelY(args.postVelY);
    builder.add_postVelX(args.postVelX);
    builder.add_postPosZ(args.postPosZ);
    builder.add_postPosY(args.postPosY);
    builder.add_postPosX(args.postPosX);
    builder.add_preSigmaW(args.preSigmaW);
    builder.add_preSigmaV(args.preSigmaV);
    builder.add_preSigmaU(args.preSigmaU);
    builder.add_preDriftRate(args.preDriftRate);
    builder.add_preGeoLongitude(args.preGeoLongitude);
    builder.add_preSMA(args.preSMA);
    builder.add_preRAAN(args.preRAAN);
    builder.add_prePeriod(args.prePeriod);
    builder.add_preEccentricity(args.preEccentricity);
    builder.add_preInclination(args.preInclination);
    builder.add_prePerigee(args.prePerigee);
    builder.add_preApogee(args.preApogee);
    builder.add_preBallisticCoeff(args.preBallisticCoeff);
    builder.add_preRadiationPressCoeff(args.preRadiationPressCoeff);
    builder.add_preVelZ(args.preVelZ);
    builder.add_preVelY(args.preVelY);
    builder.add_preVelX(args.preVelX);
    builder.add_prePosZ(args.prePosZ);
    builder.add_prePosY(args.prePosY);
    builder.add_prePosX(args.prePosX);
    builder.add_deltaMass(args.deltaMass);
    builder.add_deltaVelW(args.deltaVelW);
    builder.add_deltaVelV(args.deltaVelV);
    builder.add_deltaVelU(args.deltaVelU);
    builder.add_deltaVel(args.deltaVel);
    builder.add_deltaPosW(args.deltaPosW);
    builder.add_deltaPosV(args.deltaPosV);
    builder.add_deltaPosU(args.deltaPosU);
    builder.add_deltaPos(args.deltaPos);
    builder.add_characterizationUnc(args.characterizationUnc);
    builder.add_maneuverUnc(args.maneuverUnc);
    builder.add_totalBurnTime(args.totalBurnTime);
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.transactionId { builder.add_transactionId(x); }
    if let Some(x) = args.onOrbit { builder.add_onOrbit(x); }
    if let Some(x) = args.sourcedData { builder.add_sourcedData(x); }
    if let Some(x) = args.algorithm { builder.add_algorithm(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.mnvrAccelUncs { builder.add_mnvrAccelUncs(x); }
    if let Some(x) = args.mnvrAccels { builder.add_mnvrAccels(x); }
    if let Some(x) = args.mnvrAccelTimes { builder.add_mnvrAccelTimes(x); }
    builder.add_numAccelPoints(args.numAccelPoints);
    if let Some(x) = args.stateModel { builder.add_stateModel(x); }
    if let Some(x) = args.descriptor { builder.add_descriptor(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    builder.add_numObs(args.numObs);
    if let Some(x) = args.cov { builder.add_cov(x); }
    if let Some(x) = args.postEventStateVector { builder.add_postEventStateVector(x); }
    if let Some(x) = args.postEventIdStateVector { builder.add_postEventIdStateVector(x); }
    if let Some(x) = args.postEventElset { builder.add_postEventElset(x); }
    if let Some(x) = args.postEventIdElset { builder.add_postEventIdElset(x); }
    if let Some(x) = args.preEventStateVector { builder.add_preEventStateVector(x); }
    if let Some(x) = args.preEventIdStateVector { builder.add_preEventIdStateVector(x); }
    if let Some(x) = args.preEventElset { builder.add_preEventElset(x); }
    if let Some(x) = args.preEventIdElset { builder.add_preEventIdElset(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    if let Some(x) = args.origSensorId { builder.add_origSensorId(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    if let Some(x) = args.eventId { builder.add_eventId(x); }
    if let Some(x) = args.characterization { builder.add_characterization(x); }
    if let Some(x) = args.idSensor { builder.add_idSensor(x); }
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.odFitEndTime { builder.add_odFitEndTime(x); }
    if let Some(x) = args.eventEndTime { builder.add_eventEndTime(x); }
    if let Some(x) = args.eventStartTime { builder.add_eventStartTime(x); }
    if let Some(x) = args.reportTime { builder.add_reportTime(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_sourcedDataTypes(args.sourcedDataTypes);
    builder.add_dataMode(args.dataMode);
    builder.add_uct(args.uct);
    builder.finish()
  }

  pub fn unpack(&self) -> Maneuver_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let satNo = self.satNo();
    let reportTime = self.reportTime().map(|x| {
      x.to_string()
    });
    let eventStartTime = self.eventStartTime().map(|x| {
      x.to_string()
    });
    let eventEndTime = self.eventEndTime().map(|x| {
      x.to_string()
    });
    let totalBurnTime = self.totalBurnTime();
    let odFitEndTime = self.odFitEndTime().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let idSensor = self.idSensor().map(|x| {
      x.to_string()
    });
    let uct = self.uct();
    let maneuverUnc = self.maneuverUnc();
    let characterization = self.characterization().map(|x| {
      x.to_string()
    });
    let characterizationUnc = self.characterizationUnc();
    let eventId = self.eventId().map(|x| {
      x.to_string()
    });
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let origSensorId = self.origSensorId().map(|x| {
      x.to_string()
    });
    let status = self.status().map(|x| {
      x.to_string()
    });
    let deltaPos = self.deltaPos();
    let deltaPosU = self.deltaPosU();
    let deltaPosV = self.deltaPosV();
    let deltaPosW = self.deltaPosW();
    let deltaVel = self.deltaVel();
    let deltaVelU = self.deltaVelU();
    let deltaVelV = self.deltaVelV();
    let deltaVelW = self.deltaVelW();
    let deltaMass = self.deltaMass();
    let preEventIdElset = self.preEventIdElset().map(|x| {
      x.to_string()
    });
    let preEventElset = self.preEventElset().map(|x| {
      x.to_string()
    });
    let preEventIdStateVector = self.preEventIdStateVector().map(|x| {
      x.to_string()
    });
    let preEventStateVector = self.preEventStateVector().map(|x| {
      x.to_string()
    });
    let prePosX = self.prePosX();
    let prePosY = self.prePosY();
    let prePosZ = self.prePosZ();
    let preVelX = self.preVelX();
    let preVelY = self.preVelY();
    let preVelZ = self.preVelZ();
    let preRadiationPressCoeff = self.preRadiationPressCoeff();
    let preBallisticCoeff = self.preBallisticCoeff();
    let preApogee = self.preApogee();
    let prePerigee = self.prePerigee();
    let preInclination = self.preInclination();
    let preEccentricity = self.preEccentricity();
    let prePeriod = self.prePeriod();
    let preRAAN = self.preRAAN();
    let preSMA = self.preSMA();
    let preGeoLongitude = self.preGeoLongitude();
    let preDriftRate = self.preDriftRate();
    let preSigmaU = self.preSigmaU();
    let preSigmaV = self.preSigmaV();
    let preSigmaW = self.preSigmaW();
    let postEventIdElset = self.postEventIdElset().map(|x| {
      x.to_string()
    });
    let postEventElset = self.postEventElset().map(|x| {
      x.to_string()
    });
    let postEventIdStateVector = self.postEventIdStateVector().map(|x| {
      x.to_string()
    });
    let postEventStateVector = self.postEventStateVector().map(|x| {
      x.to_string()
    });
    let postPosX = self.postPosX();
    let postPosY = self.postPosY();
    let postPosZ = self.postPosZ();
    let postVelX = self.postVelX();
    let postVelY = self.postVelY();
    let postVelZ = self.postVelZ();
    let postRadiationPressCoeff = self.postRadiationPressCoeff();
    let postBallisticCoeff = self.postBallisticCoeff();
    let postApogee = self.postApogee();
    let postPerigee = self.postPerigee();
    let postInclination = self.postInclination();
    let postEccentricity = self.postEccentricity();
    let postPeriod = self.postPeriod();
    let postRAAN = self.postRAAN();
    let postSMA = self.postSMA();
    let postGeoLongitude = self.postGeoLongitude();
    let postDriftRate = self.postDriftRate();
    let postSigmaU = self.postSigmaU();
    let postSigmaV = self.postSigmaV();
    let postSigmaW = self.postSigmaW();
    let cov = self.cov().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let postMass = self.postMass();
    let postArea = self.postArea();
    let numObs = self.numObs();
    let description = self.description().map(|x| {
      x.to_string()
    });
    let descriptor = self.descriptor().map(|x| {
      x.to_string()
    });
    let stateModel = self.stateModel().map(|x| {
      x.to_string()
    });
    let stateModelVersion = self.stateModelVersion();
    let numAccelPoints = self.numAccelPoints();
    let mnvrAccelTimes = self.mnvrAccelTimes().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let mnvrAccels = self.mnvrAccels().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let mnvrAccelUncs = self.mnvrAccelUncs().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let tags = self.tags().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let algorithm = self.algorithm().map(|x| {
      x.to_string()
    });
    let sourcedData = self.sourcedData().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let sourcedDataTypes = self.sourcedDataTypes();
    let onOrbit = self.onOrbit().map(|x| {
      x.to_string()
    });
    let transactionId = self.transactionId().map(|x| {
      x.to_string()
    });
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    Maneuver_FullT {
      id,
      classificationMarking,
      satNo,
      reportTime,
      eventStartTime,
      eventEndTime,
      totalBurnTime,
      odFitEndTime,
      idOnOrbit,
      idSensor,
      uct,
      maneuverUnc,
      characterization,
      characterizationUnc,
      eventId,
      origObjectId,
      origSensorId,
      status,
      deltaPos,
      deltaPosU,
      deltaPosV,
      deltaPosW,
      deltaVel,
      deltaVelU,
      deltaVelV,
      deltaVelW,
      deltaMass,
      preEventIdElset,
      preEventElset,
      preEventIdStateVector,
      preEventStateVector,
      prePosX,
      prePosY,
      prePosZ,
      preVelX,
      preVelY,
      preVelZ,
      preRadiationPressCoeff,
      preBallisticCoeff,
      preApogee,
      prePerigee,
      preInclination,
      preEccentricity,
      prePeriod,
      preRAAN,
      preSMA,
      preGeoLongitude,
      preDriftRate,
      preSigmaU,
      preSigmaV,
      preSigmaW,
      postEventIdElset,
      postEventElset,
      postEventIdStateVector,
      postEventStateVector,
      postPosX,
      postPosY,
      postPosZ,
      postVelX,
      postVelY,
      postVelZ,
      postRadiationPressCoeff,
      postBallisticCoeff,
      postApogee,
      postPerigee,
      postInclination,
      postEccentricity,
      postPeriod,
      postRAAN,
      postSMA,
      postGeoLongitude,
      postDriftRate,
      postSigmaU,
      postSigmaV,
      postSigmaW,
      cov,
      postMass,
      postArea,
      numObs,
      description,
      descriptor,
      stateModel,
      stateModelVersion,
      numAccelPoints,
      mnvrAccelTimes,
      mnvrAccels,
      mnvrAccelUncs,
      source,
      origin,
      dataMode,
      createdAt,
      createdBy,
      tags,
      algorithm,
      sourcedData,
      sourcedDataTypes,
      onOrbit,
      transactionId,
      origNetwork,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: MANEUVER-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Satellite/Catalog number of the target on-orbit object.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Maneuver_Full::VT_SATNO, Some(0)).unwrap()}
  }
  /// The time that the report or alert of this maneuver was generated, in ISO 8601 UTC format.
  /// Example: /// Example: 2023-11-16T04:15:00.0001Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn reportTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_REPORTTIME, None)}
  }
  /// Maneuver event start time in ISO 8601 UTC with microsecond precision. For maneuvers without start and end times, the start time is considered to be the maneuver event time.
  /// Example: /// Example: 2023-11-16T01:05:16.835689Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn eventStartTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_EVENTSTARTTIME, None)}
  }
  /// Maneuver event end time in ISO 8601 UTC with microsecond precision.
  /// Example: /// Example: 2023-11-16T01:09:01.350012Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn eventEndTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_EVENTENDTIME, None)}
  }
  /// The estimated total active burn time of a maneuver, in seconds. This includes the sum of all burns in numAccelPoints. Not to be confused with the total duration of the maneuver.
  /// Example: /// Example: 600.72
  /// Constraints: No constraints specified.
  #[inline]
  pub fn totalBurnTime(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_TOTALBURNTIME, Some(0.0)).unwrap()}
  }
  /// Maneuver orbit determination fit data end time in ISO 8601 UTC with microsecond precision.
  /// Example: /// Example: 2023-11-16T03:55:51Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn odFitEndTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_ODFITENDTIME, None)}
  }
  /// Target maneuvering on-orbit object. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
  /// Example: /// Example: 12
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_IDONORBIT, None)}
  }
  /// Optional ID of the sensor that detected this maneuver (for example, if detected by passive RF anomalies).
  /// Example: /// Example: SENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_IDSENSOR, None)}
  }
  /// Boolean indicating this maneuver was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn uct(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Maneuver_Full::VT_UCT, Some(false)).unwrap()}
  }
  /// Uncertainty in the occurrence of this maneuver (0 - 1).
  /// Example: /// Example: 0.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maneuverUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_MANEUVERUNC, Some(0.0)).unwrap()}
  }
  /// Optional purpose of the maneuver if known (e.g. North-South Station Keeping, East-West Station Keeping, Longitude Shift, Unknown).
  /// Example: /// Example: North-South Station Keeping
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn characterization(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_CHARACTERIZATION, None)}
  }
  /// Uncertainty in the characterization or purpose assessment of this maneuver (0 - 1).
  /// Example: /// Example: 0.15
  /// Constraints: No constraints specified.
  #[inline]
  pub fn characterizationUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_CHARACTERIZATIONUNC, Some(0.0)).unwrap()}
  }
  /// Optional source-provided identifier for this maneuver event. In the case where multiple maneuver records are submitted for the same event, this field can be used to tie them together to the same event.
  /// Example: /// Example: EVENT-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn eventId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_EVENTID, None)}
  }
  /// Identifier provided by source to indicate the target on-orbit object performing this maneuver. This may be an internal identifier and not necessarily a valid satellite number/ID.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_ORIGOBJECTID, None)}
  }
  /// Optional identifier provided by source to indicate the sensor identifier used to detect this event. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origSensorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_ORIGSENSORID, None)}
  }
  /// Status of this maneuver (CANCELLED, PLANNED, POSSIBLE, REDACTED, VERIFIED).
  /// CANCELLED:  A previously planned maneuver whose execution was cancelled.
  /// PLANNED:  A maneuver planned to take place at the eventStartTime.
  /// POSSIBLE:  A possible maneuver detected by observation of the spacecraft or by evaluation of the spacecraft orbit.
  /// REDACTED:  A redaction of a reported possible maneuver that has been determined to have not taken place after further observation/evaluation.
  /// VERIFIED:  A maneuver whose execution has been verified, either by the owner/operator or observation/evaluation.
  /// Example: /// Example: POSSIBLE
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn status(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_STATUS, None)}
  }
  /// Magnitude, in km, of the difference in the pre- and post-maneuver position vectors at the maneuver event time.
  /// Example: /// Example: 0.715998327
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaPos(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_DELTAPOS, Some(0.0)).unwrap()}
  }
  /// Magnitude, in km, of the difference in the pre- and post-maneuver position vectors in the direction of the pre-maneuver 'U' unit vector at the maneuver event time.
  /// Example: /// Example: -0.022172844
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaPosU(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_DELTAPOSU, Some(0.0)).unwrap()}
  }
  /// Magnitude, in km, of the difference in the pre- and post-maneuver position vectors in the direction of the pre-maneuver 'V' unit vector at the maneuver event time.
  /// Example: /// Example: -0.033700154
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaPosV(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_DELTAPOSV, Some(0.0)).unwrap()}
  }
  /// Magnitude, in km, of the difference in the pre- and post-maneuver position vectors in the direction of the pre-maneuver 'W' unit vector at the maneuver event time.
  /// Example: /// Example: -0.714861014
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaPosW(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_DELTAPOSW, Some(0.0)).unwrap()}
  }
  /// Magnitude, in km/sec, of the difference in the pre- and post-maneuver velocity vectors at the maneuver event time.
  /// Example: /// Example: 0.000631505
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaVel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_DELTAVEL, Some(0.0)).unwrap()}
  }
  /// Magnitude, in km/sec, of the difference in the pre- and post-maneuver velocity vectors in the direction of the pre-maneuver 'U' unit vector at the maneuver event time.
  /// Example: /// Example: 3.50165629389647e-05
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaVelU(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_DELTAVELU, Some(0.0)).unwrap()}
  }
  /// Magnitude, in km/sec, of the difference in the pre- and post-maneuver velocity vectors in the direction of the pre-maneuver 'V' unit vector at the maneuver event time.
  /// Example: /// Example: 0.000544413
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaVelV(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_DELTAVELV, Some(0.0)).unwrap()}
  }
  /// Magnitude, in km/sec, of the difference in the pre- and post-maneuver velocity vectors in the direction of the pre-maneuver 'W' unit vector at the maneuver event time.
  /// Example: /// Example: -0.000318099
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaVelW(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_DELTAVELW, Some(0.0)).unwrap()}
  }
  /// Difference in mass before and after the maneuver, in kg.
  /// Example: /// Example: 0.15
  /// Constraints: No constraints specified.
  #[inline]
  pub fn deltaMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_DELTAMASS, Some(0.0)).unwrap()}
  }
  /// Optional identifier of the element set for the pre-maneuver orbit.
  /// Example: /// Example: 80e544b7-6a17-4554-8abf-7301e98f8e5d
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn preEventIdElset(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_PREEVENTIDELSET, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preEventElset(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_PREEVENTELSET, None)}
  }
  /// Optional identifier of the state vector for the pre-maneuver trajectory of the spacecraft.
  /// Example: /// Example: 6e291992-8ae3-4592-bb0f-055715bf4803
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn preEventIdStateVector(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_PREEVENTIDSTATEVECTOR, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preEventStateVector(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_PREEVENTSTATEVECTOR, None)}
  }
  /// Pre-event X component of position in ECI space, in km.
  /// Example: /// Example: 3584.432545
  /// Constraints: No constraints specified.
  #[inline]
  pub fn prePosX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREPOSX, Some(0.0)).unwrap()}
  }
  /// Pre-event Y component of position in ECI space, in km.
  /// Example: /// Example: 42028.43245
  /// Constraints: No constraints specified.
  #[inline]
  pub fn prePosY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREPOSY, Some(0.0)).unwrap()}
  }
  /// Pre-event Z component of position in ECI space, in km.
  /// Example: /// Example: -1.97765
  /// Constraints: No constraints specified.
  #[inline]
  pub fn prePosZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREPOSZ, Some(0.0)).unwrap()}
  }
  /// Pre-event X component of velocity in ECI space, in km/sec.
  /// Example: /// Example: -2.543266
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preVelX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREVELX, Some(0.0)).unwrap()}
  }
  /// Pre-event Y component of velocity in ECI space, in km/sec.
  /// Example: /// Example: 0.24876
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preVelY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREVELY, Some(0.0)).unwrap()}
  }
  /// Pre-event Z component of velocity in ECI space, in km/sec.
  /// Example: /// Example: 0.0067352
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preVelZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREVELZ, Some(0.0)).unwrap()}
  }
  /// Pre-event radiation pressure coefficient. The units of the radiation pressure coefficient vary depending on provider. Users should consult the data provider to verify the units of the radiation pressure coefficient.
  /// Example: /// Example: 4.51e-07
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preRadiationPressCoeff(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PRERADIATIONPRESSCOEFF, Some(0.0)).unwrap()}
  }
  /// Pre-event ballistic coefficient. The units of the ballistic coefficient vary depending on provider. Users should consult the data provider to verify the units of the ballistic coefficient.
  /// Example: /// Example: 0.000437116
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preBallisticCoeff(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREBALLISTICCOEFF, Some(0.0)).unwrap()}
  }
  /// Pre-event spacecraft apogee (measured from Earth center), in kilometers.
  /// Example: /// Example: 35802
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preApogee(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREAPOGEE, Some(0.0)).unwrap()}
  }
  /// Pre-event spacecraft perigee (measured from Earth center), in kilometers.
  /// Example: /// Example: 35786.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn prePerigee(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREPERIGEE, Some(0.0)).unwrap()}
  }
  /// Pre-event spacecraft orbital inclination, in degrees. 0-180.
  /// Example: /// Example: 0.0336
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preInclination(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREINCLINATION, Some(0.0)).unwrap()}
  }
  /// Pre-event spacecraft eccentricity.
  /// Example: /// Example: 0.00017
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preEccentricity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREECCENTRICITY, Some(0.0)).unwrap()}
  }
  /// Pre-event spacecraft orbital period, in minutes.
  /// Example: /// Example: 1436.12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn prePeriod(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREPERIOD, Some(0.0)).unwrap()}
  }
  /// Pre-event spacecraft Right Ascension of the Ascending Node (RAAN), in degrees.
  /// Example: /// Example: 98.3336
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preRAAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PRERAAN, Some(0.0)).unwrap()}
  }
  /// Pre-event spacecraft orbital Semi-Major Axis (SMA), in kilometers.
  /// Example: /// Example: 42165.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preSMA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PRESMA, Some(0.0)).unwrap()}
  }
  /// Pre-event spacecraft WGS-84 GEO belt longitude, represented as -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: -93.12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preGeoLongitude(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREGEOLONGITUDE, Some(0.0)).unwrap()}
  }
  /// Pre-event GEO drift rate of the spacecraft, in degrees per day. Negative values indicate westward drift.
  /// Example: /// Example: -0.0125
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preDriftRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PREDRIFTRATE, Some(0.0)).unwrap()}
  }
  /// Pre-event standard deviation, in kilometers, of spacecraft position in the 'U' unit vector direction.
  /// Example: /// Example: 0.215
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preSigmaU(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PRESIGMAU, Some(0.0)).unwrap()}
  }
  /// Pre-event standard deviation, in kilometers, of spacecraft position in the 'V' unit vector direction.
  /// Example: /// Example: 1.97
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preSigmaV(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PRESIGMAV, Some(0.0)).unwrap()}
  }
  /// Pre-event standard deviation, in kilometers, of spacecraft position in the 'W' unit vector direction.
  /// Example: /// Example: 0.208
  /// Constraints: No constraints specified.
  #[inline]
  pub fn preSigmaW(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_PRESIGMAW, Some(0.0)).unwrap()}
  }
  /// Optional identifier of the element set for the post-maneuver orbit.
  /// Example: /// Example: 225adf4c-8606-40a8-929e-63e22cffe220
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn postEventIdElset(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_POSTEVENTIDELSET, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postEventElset(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_POSTEVENTELSET, None)}
  }
  /// Optional identifier of the state vector for the post-maneuver trajectory of the spacecraft.
  /// Example: /// Example: d83a23f8-1496-485a-bd88-ec5808c73299
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn postEventIdStateVector(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_POSTEVENTIDSTATEVECTOR, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postEventStateVector(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_POSTEVENTSTATEVECTOR, None)}
  }
  /// Post-event X component of position in ECI space, in km.
  /// Example: /// Example: 3589.351957
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postPosX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTPOSX, Some(0.0)).unwrap()}
  }
  /// Post-event Y component of position in ECI space, in km.
  /// Example: /// Example: 42017.26823
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postPosY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTPOSY, Some(0.0)).unwrap()}
  }
  /// Post-event Z component of position in ECI space, in km.
  /// Example: /// Example: -1.27161796
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postPosZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTPOSZ, Some(0.0)).unwrap()}
  }
  /// Post-event X component of velocity in ECI space, in km/sec.
  /// Example: /// Example: -3.063152826
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postVelX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTVELX, Some(0.0)).unwrap()}
  }
  /// Post-event Y component of velocity in ECI space, in km/sec.
  /// Example: /// Example: 0.261586769
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postVelY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTVELY, Some(0.0)).unwrap()}
  }
  /// Post-event Z component of velocity in ECI space, in km/sec.
  /// Example: /// Example: 0.006842148
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postVelZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTVELZ, Some(0.0)).unwrap()}
  }
  /// Post-event radiation pressure coefficient. The units of the radiation pressure coefficient vary depending on provider. Users should consult the data provider to verify the units of the radiation pressure coefficient.
  /// Example: /// Example: 4.51e-07
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postRadiationPressCoeff(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTRADIATIONPRESSCOEFF, Some(0.0)).unwrap()}
  }
  /// Post-event ballistic coefficient. The units of the ballistic coefficient vary depending on provider. Users should consult the data provider to verify the units of the ballistic coefficient.
  /// Example: /// Example: 0.000433209
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postBallisticCoeff(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTBALLISTICCOEFF, Some(0.0)).unwrap()}
  }
  /// Post-event spacecraft apogee (measured from Earth center), in kilometers.
  /// Example: /// Example: 35800.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postApogee(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTAPOGEE, Some(0.0)).unwrap()}
  }
  /// Post-event spacecraft perigee (measured from Earth center), in kilometers.
  /// Example: /// Example: 35787.9
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postPerigee(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTPERIGEE, Some(0.0)).unwrap()}
  }
  /// Post-event spacecraft orbital inclination, in degrees. 0-180.
  /// Example: /// Example: 0.0327
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postInclination(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTINCLINATION, Some(0.0)).unwrap()}
  }
  /// Post-event spacecraft eccentricity.
  /// Example: /// Example: 0.000164
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postEccentricity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTECCENTRICITY, Some(0.0)).unwrap()}
  }
  /// Post-event spacecraft orbital period, in minutes.
  /// Example: /// Example: 1436.01
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postPeriod(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTPERIOD, Some(0.0)).unwrap()}
  }
  /// Post-event spacecraft Right Ascension of the Ascending Node (RAAN), in degrees.
  /// Example: /// Example: 98.3335
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postRAAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTRAAN, Some(0.0)).unwrap()}
  }
  /// Post-event spacecraft Semi-Major Axis (SMA), in kilometers.
  /// Example: /// Example: 42164.87
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postSMA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTSMA, Some(0.0)).unwrap()}
  }
  /// Post-event spacecraft WGS-84 GEO belt longitude, represented as -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: -93.15
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postGeoLongitude(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTGEOLONGITUDE, Some(0.0)).unwrap()}
  }
  /// Post-event GEO drift rate of the spacecraft, in degrees per day. Negative values indicate westward drift.
  /// Example: /// Example: -0.0125
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postDriftRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTDRIFTRATE, Some(0.0)).unwrap()}
  }
  /// Post-event standard deviation, in kilometers, of spacecraft position in the 'U' unit vector direction.
  /// Example: /// Example: 12.285
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postSigmaU(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTSIGMAU, Some(0.0)).unwrap()}
  }
  /// Post-event standard deviation, in kilometers, of spacecraft position in the 'V' unit vector direction.
  /// Example: /// Example: 71.339
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postSigmaV(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTSIGMAV, Some(0.0)).unwrap()}
  }
  /// Post-event standard deviation, in kilometers, of spacecraft position in the 'W' unit vector direction.
  /// Example: /// Example: 12.77
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postSigmaW(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTSIGMAW, Some(0.0)).unwrap()}
  }
  /// Optional maneuver cross-track/radial/in-track covariance array, in meter and second based units, in the following order: CR_R, CI_R, CI_I, CC_R, CC_I, CC_C, CT_R, CT_I, CT_C, CT_T.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cov(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Maneuver_Full::VT_COV, None)}
  }
  ///  Estimated mass of the object following the maneuver, in kg.
  /// Example: /// Example: 1844.5
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postMass(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTMASS, Some(0.0)).unwrap()}
  }
  /// Estimated area of the object following the maneuver, in meters squared.
  /// Example: /// Example: 35.77
  /// Constraints: No constraints specified.
  #[inline]
  pub fn postArea(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_POSTAREA, Some(0.0)).unwrap()}
  }
  /// Number of observations used to generate the maneuver data.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numObs(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Maneuver_Full::VT_NUMOBS, Some(0)).unwrap()}
  }
  /// Description and notes of the maneuver.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_DESCRIPTION, None)}
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: Example descriptor
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn descriptor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_DESCRIPTOR, None)}
  }
  /// Name of the state model used to generate the maneuver data.
  /// Example: /// Example: Example name
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn stateModel(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_STATEMODEL, None)}
  }
  /// Version of the state model used to generate the maneuver data.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn stateModelVersion(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Maneuver_Full::VT_STATEMODELVERSION, Some(0.0)).unwrap()}
  }
  /// The total number of estimated acceleration points during the maneuver.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn numAccelPoints(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Maneuver_Full::VT_NUMACCELPOINTS, Some(0)).unwrap()}
  }
  /// Array of elapsed times, in seconds from maneuver start time, at which each acceleration point is estimated. Number of elements must match the numAccelPoints.
  /// Example: /// Example: [10.25, 50.56, 150.78]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mnvrAccelTimes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Maneuver_Full::VT_MNVRACCELTIMES, None)}
  }
  /// Array of estimated acceleration values, in meters per second squared. Number of elements must match the numAccelPoints.
  /// Example: /// Example: [0.05, 0.1, 0.05]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mnvrAccels(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Maneuver_Full::VT_MNVRACCELS, None)}
  }
  /// Array of the 1-sigma uncertainties in estimated accelerations, in meters per second squared. Number of elements must match the numAccelPoints.
  /// Example: /// Example: [0.0005, 0.001, 0.0005]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn mnvrAccelUncs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Maneuver_Full::VT_MNVRACCELUNCS, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> Maneuver_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Maneuver_Full_dataMode_Enum>(Maneuver_Full::VT_DATAMODE, Some(Maneuver_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_CREATEDBY, None)}
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['PROVIDER_TAG1', 'PROVIDERTAG2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Maneuver_Full::VT_TAGS, None)}
  }
  /// Optional algorithm used to produce this record.
  /// Example: /// Example: Example algorithm
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn algorithm(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_ALGORITHM, None)}
  }
  /// Optional array of UDL data (elsets, state vectors, etc) UUIDs used to build this maneuver. See the associated sourcedDataTypes array for the specific types of data for the positionally corresponding UUIDs in this array (the two arrays must match in size).
  /// Example: /// Example: ['SOURCEDDATA-ID', 'SOURCEDDATA-ID']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sourcedData(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Maneuver_Full::VT_SOURCEDDATA, None)}
  }
  /// Optional array of UDL data types used to build this maneuver (e.g. EO, RADAR, RF, DOA, ELSET, SV). See the associated sourcedData array for the specific UUIDs of data for the positionally corresponding data types in this array (the two arrays must match in size).
  /// Example: /// Example: ['EO', 'RADAR']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sourcedDataTypes(&self) -> Maneuver_Full_sourcedDataTypes_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Maneuver_Full_sourcedDataTypes_Enum>(Maneuver_Full::VT_SOURCEDDATATYPES, Some(Maneuver_Full_sourcedDataTypes_Enum::EO)).unwrap()}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn onOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_ONORBIT, None)}
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn transactionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_TRANSACTIONID, None)}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Maneuver_Full::VT_ORIGNETWORK, None)}
  }
}

impl flatbuffers::Verifiable for Maneuver_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reportTime", Self::VT_REPORTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventStartTime", Self::VT_EVENTSTARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventEndTime", Self::VT_EVENTENDTIME, false)?
     .visit_field::<f64>("totalBurnTime", Self::VT_TOTALBURNTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("odFitEndTime", Self::VT_ODFITENDTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor", Self::VT_IDSENSOR, false)?
     .visit_field::<bool>("uct", Self::VT_UCT, false)?
     .visit_field::<f64>("maneuverUnc", Self::VT_MANEUVERUNC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("characterization", Self::VT_CHARACTERIZATION, false)?
     .visit_field::<f64>("characterizationUnc", Self::VT_CHARACTERIZATIONUNC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventId", Self::VT_EVENTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId", Self::VT_ORIGSENSORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("status", Self::VT_STATUS, false)?
     .visit_field::<f64>("deltaPos", Self::VT_DELTAPOS, false)?
     .visit_field::<f64>("deltaPosU", Self::VT_DELTAPOSU, false)?
     .visit_field::<f64>("deltaPosV", Self::VT_DELTAPOSV, false)?
     .visit_field::<f64>("deltaPosW", Self::VT_DELTAPOSW, false)?
     .visit_field::<f64>("deltaVel", Self::VT_DELTAVEL, false)?
     .visit_field::<f64>("deltaVelU", Self::VT_DELTAVELU, false)?
     .visit_field::<f64>("deltaVelV", Self::VT_DELTAVELV, false)?
     .visit_field::<f64>("deltaVelW", Self::VT_DELTAVELW, false)?
     .visit_field::<f64>("deltaMass", Self::VT_DELTAMASS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("preEventIdElset", Self::VT_PREEVENTIDELSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("preEventElset", Self::VT_PREEVENTELSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("preEventIdStateVector", Self::VT_PREEVENTIDSTATEVECTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("preEventStateVector", Self::VT_PREEVENTSTATEVECTOR, false)?
     .visit_field::<f64>("prePosX", Self::VT_PREPOSX, false)?
     .visit_field::<f64>("prePosY", Self::VT_PREPOSY, false)?
     .visit_field::<f64>("prePosZ", Self::VT_PREPOSZ, false)?
     .visit_field::<f64>("preVelX", Self::VT_PREVELX, false)?
     .visit_field::<f64>("preVelY", Self::VT_PREVELY, false)?
     .visit_field::<f64>("preVelZ", Self::VT_PREVELZ, false)?
     .visit_field::<f64>("preRadiationPressCoeff", Self::VT_PRERADIATIONPRESSCOEFF, false)?
     .visit_field::<f64>("preBallisticCoeff", Self::VT_PREBALLISTICCOEFF, false)?
     .visit_field::<f64>("preApogee", Self::VT_PREAPOGEE, false)?
     .visit_field::<f64>("prePerigee", Self::VT_PREPERIGEE, false)?
     .visit_field::<f64>("preInclination", Self::VT_PREINCLINATION, false)?
     .visit_field::<f64>("preEccentricity", Self::VT_PREECCENTRICITY, false)?
     .visit_field::<f64>("prePeriod", Self::VT_PREPERIOD, false)?
     .visit_field::<f64>("preRAAN", Self::VT_PRERAAN, false)?
     .visit_field::<f64>("preSMA", Self::VT_PRESMA, false)?
     .visit_field::<f64>("preGeoLongitude", Self::VT_PREGEOLONGITUDE, false)?
     .visit_field::<f64>("preDriftRate", Self::VT_PREDRIFTRATE, false)?
     .visit_field::<f64>("preSigmaU", Self::VT_PRESIGMAU, false)?
     .visit_field::<f64>("preSigmaV", Self::VT_PRESIGMAV, false)?
     .visit_field::<f64>("preSigmaW", Self::VT_PRESIGMAW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("postEventIdElset", Self::VT_POSTEVENTIDELSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("postEventElset", Self::VT_POSTEVENTELSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("postEventIdStateVector", Self::VT_POSTEVENTIDSTATEVECTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("postEventStateVector", Self::VT_POSTEVENTSTATEVECTOR, false)?
     .visit_field::<f64>("postPosX", Self::VT_POSTPOSX, false)?
     .visit_field::<f64>("postPosY", Self::VT_POSTPOSY, false)?
     .visit_field::<f64>("postPosZ", Self::VT_POSTPOSZ, false)?
     .visit_field::<f64>("postVelX", Self::VT_POSTVELX, false)?
     .visit_field::<f64>("postVelY", Self::VT_POSTVELY, false)?
     .visit_field::<f64>("postVelZ", Self::VT_POSTVELZ, false)?
     .visit_field::<f64>("postRadiationPressCoeff", Self::VT_POSTRADIATIONPRESSCOEFF, false)?
     .visit_field::<f64>("postBallisticCoeff", Self::VT_POSTBALLISTICCOEFF, false)?
     .visit_field::<f64>("postApogee", Self::VT_POSTAPOGEE, false)?
     .visit_field::<f64>("postPerigee", Self::VT_POSTPERIGEE, false)?
     .visit_field::<f64>("postInclination", Self::VT_POSTINCLINATION, false)?
     .visit_field::<f64>("postEccentricity", Self::VT_POSTECCENTRICITY, false)?
     .visit_field::<f64>("postPeriod", Self::VT_POSTPERIOD, false)?
     .visit_field::<f64>("postRAAN", Self::VT_POSTRAAN, false)?
     .visit_field::<f64>("postSMA", Self::VT_POSTSMA, false)?
     .visit_field::<f64>("postGeoLongitude", Self::VT_POSTGEOLONGITUDE, false)?
     .visit_field::<f64>("postDriftRate", Self::VT_POSTDRIFTRATE, false)?
     .visit_field::<f64>("postSigmaU", Self::VT_POSTSIGMAU, false)?
     .visit_field::<f64>("postSigmaV", Self::VT_POSTSIGMAV, false)?
     .visit_field::<f64>("postSigmaW", Self::VT_POSTSIGMAW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("cov", Self::VT_COV, false)?
     .visit_field::<f64>("postMass", Self::VT_POSTMASS, false)?
     .visit_field::<f64>("postArea", Self::VT_POSTAREA, false)?
     .visit_field::<i32>("numObs", Self::VT_NUMOBS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("descriptor", Self::VT_DESCRIPTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stateModel", Self::VT_STATEMODEL, false)?
     .visit_field::<f64>("stateModelVersion", Self::VT_STATEMODELVERSION, false)?
     .visit_field::<i32>("numAccelPoints", Self::VT_NUMACCELPOINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("mnvrAccelTimes", Self::VT_MNVRACCELTIMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("mnvrAccels", Self::VT_MNVRACCELS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("mnvrAccelUncs", Self::VT_MNVRACCELUNCS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<Maneuver_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("algorithm", Self::VT_ALGORITHM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("sourcedData", Self::VT_SOURCEDDATA, false)?
     .visit_field::<Maneuver_Full_sourcedDataTypes_Enum>("sourcedDataTypes", Self::VT_SOURCEDDATATYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("onOrbit", Self::VT_ONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transactionId", Self::VT_TRANSACTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct Maneuver_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo: i32,
    pub reportTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventStartTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventEndTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub totalBurnTime: f64,
    pub odFitEndTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uct: bool,
    pub maneuverUnc: f64,
    pub characterization: Option<flatbuffers::WIPOffset<&'a str>>,
    pub characterizationUnc: f64,
    pub eventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub status: Option<flatbuffers::WIPOffset<&'a str>>,
    pub deltaPos: f64,
    pub deltaPosU: f64,
    pub deltaPosV: f64,
    pub deltaPosW: f64,
    pub deltaVel: f64,
    pub deltaVelU: f64,
    pub deltaVelV: f64,
    pub deltaVelW: f64,
    pub deltaMass: f64,
    pub preEventIdElset: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preEventElset: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preEventIdStateVector: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preEventStateVector: Option<flatbuffers::WIPOffset<&'a str>>,
    pub prePosX: f64,
    pub prePosY: f64,
    pub prePosZ: f64,
    pub preVelX: f64,
    pub preVelY: f64,
    pub preVelZ: f64,
    pub preRadiationPressCoeff: f64,
    pub preBallisticCoeff: f64,
    pub preApogee: f64,
    pub prePerigee: f64,
    pub preInclination: f64,
    pub preEccentricity: f64,
    pub prePeriod: f64,
    pub preRAAN: f64,
    pub preSMA: f64,
    pub preGeoLongitude: f64,
    pub preDriftRate: f64,
    pub preSigmaU: f64,
    pub preSigmaV: f64,
    pub preSigmaW: f64,
    pub postEventIdElset: Option<flatbuffers::WIPOffset<&'a str>>,
    pub postEventElset: Option<flatbuffers::WIPOffset<&'a str>>,
    pub postEventIdStateVector: Option<flatbuffers::WIPOffset<&'a str>>,
    pub postEventStateVector: Option<flatbuffers::WIPOffset<&'a str>>,
    pub postPosX: f64,
    pub postPosY: f64,
    pub postPosZ: f64,
    pub postVelX: f64,
    pub postVelY: f64,
    pub postVelZ: f64,
    pub postRadiationPressCoeff: f64,
    pub postBallisticCoeff: f64,
    pub postApogee: f64,
    pub postPerigee: f64,
    pub postInclination: f64,
    pub postEccentricity: f64,
    pub postPeriod: f64,
    pub postRAAN: f64,
    pub postSMA: f64,
    pub postGeoLongitude: f64,
    pub postDriftRate: f64,
    pub postSigmaU: f64,
    pub postSigmaV: f64,
    pub postSigmaW: f64,
    pub cov: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub postMass: f64,
    pub postArea: f64,
    pub numObs: i32,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub descriptor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stateModel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stateModelVersion: f64,
    pub numAccelPoints: i32,
    pub mnvrAccelTimes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub mnvrAccels: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub mnvrAccelUncs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: Maneuver_Full_dataMode_Enum,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub algorithm: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourcedData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub sourcedDataTypes: Maneuver_Full_sourcedDataTypes_Enum,
    pub onOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transactionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Maneuver_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    Maneuver_FullArgs {
      id: None,
      classificationMarking: None,
      satNo: 0,
      reportTime: None,
      eventStartTime: None,
      eventEndTime: None,
      totalBurnTime: 0.0,
      odFitEndTime: None,
      idOnOrbit: None,
      idSensor: None,
      uct: false,
      maneuverUnc: 0.0,
      characterization: None,
      characterizationUnc: 0.0,
      eventId: None,
      origObjectId: None,
      origSensorId: None,
      status: None,
      deltaPos: 0.0,
      deltaPosU: 0.0,
      deltaPosV: 0.0,
      deltaPosW: 0.0,
      deltaVel: 0.0,
      deltaVelU: 0.0,
      deltaVelV: 0.0,
      deltaVelW: 0.0,
      deltaMass: 0.0,
      preEventIdElset: None,
      preEventElset: None,
      preEventIdStateVector: None,
      preEventStateVector: None,
      prePosX: 0.0,
      prePosY: 0.0,
      prePosZ: 0.0,
      preVelX: 0.0,
      preVelY: 0.0,
      preVelZ: 0.0,
      preRadiationPressCoeff: 0.0,
      preBallisticCoeff: 0.0,
      preApogee: 0.0,
      prePerigee: 0.0,
      preInclination: 0.0,
      preEccentricity: 0.0,
      prePeriod: 0.0,
      preRAAN: 0.0,
      preSMA: 0.0,
      preGeoLongitude: 0.0,
      preDriftRate: 0.0,
      preSigmaU: 0.0,
      preSigmaV: 0.0,
      preSigmaW: 0.0,
      postEventIdElset: None,
      postEventElset: None,
      postEventIdStateVector: None,
      postEventStateVector: None,
      postPosX: 0.0,
      postPosY: 0.0,
      postPosZ: 0.0,
      postVelX: 0.0,
      postVelY: 0.0,
      postVelZ: 0.0,
      postRadiationPressCoeff: 0.0,
      postBallisticCoeff: 0.0,
      postApogee: 0.0,
      postPerigee: 0.0,
      postInclination: 0.0,
      postEccentricity: 0.0,
      postPeriod: 0.0,
      postRAAN: 0.0,
      postSMA: 0.0,
      postGeoLongitude: 0.0,
      postDriftRate: 0.0,
      postSigmaU: 0.0,
      postSigmaV: 0.0,
      postSigmaW: 0.0,
      cov: None,
      postMass: 0.0,
      postArea: 0.0,
      numObs: 0,
      description: None,
      descriptor: None,
      stateModel: None,
      stateModelVersion: 0.0,
      numAccelPoints: 0,
      mnvrAccelTimes: None,
      mnvrAccels: None,
      mnvrAccelUncs: None,
      source: None,
      origin: None,
      dataMode: Maneuver_Full_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
      tags: None,
      algorithm: None,
      sourcedData: None,
      sourcedDataTypes: Maneuver_Full_sourcedDataTypes_Enum::EO,
      onOrbit: None,
      transactionId: None,
      origNetwork: None,
    }
  }
}

pub struct Maneuver_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Maneuver_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(Maneuver_Full::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_reportTime(&mut self, reportTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_REPORTTIME, reportTime);
  }
  #[inline]
  pub fn add_eventStartTime(&mut self, eventStartTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_EVENTSTARTTIME, eventStartTime);
  }
  #[inline]
  pub fn add_eventEndTime(&mut self, eventEndTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_EVENTENDTIME, eventEndTime);
  }
  #[inline]
  pub fn add_totalBurnTime(&mut self, totalBurnTime: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_TOTALBURNTIME, totalBurnTime, 0.0);
  }
  #[inline]
  pub fn add_odFitEndTime(&mut self, odFitEndTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_ODFITENDTIME, odFitEndTime);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_idSensor(&mut self, idSensor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_IDSENSOR, idSensor);
  }
  #[inline]
  pub fn add_uct(&mut self, uct: bool) {
    self.fbb_.push_slot::<bool>(Maneuver_Full::VT_UCT, uct, false);
  }
  #[inline]
  pub fn add_maneuverUnc(&mut self, maneuverUnc: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_MANEUVERUNC, maneuverUnc, 0.0);
  }
  #[inline]
  pub fn add_characterization(&mut self, characterization: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_CHARACTERIZATION, characterization);
  }
  #[inline]
  pub fn add_characterizationUnc(&mut self, characterizationUnc: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_CHARACTERIZATIONUNC, characterizationUnc, 0.0);
  }
  #[inline]
  pub fn add_eventId(&mut self, eventId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_EVENTID, eventId);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_origSensorId(&mut self, origSensorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_ORIGSENSORID, origSensorId);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_STATUS, status);
  }
  #[inline]
  pub fn add_deltaPos(&mut self, deltaPos: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_DELTAPOS, deltaPos, 0.0);
  }
  #[inline]
  pub fn add_deltaPosU(&mut self, deltaPosU: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_DELTAPOSU, deltaPosU, 0.0);
  }
  #[inline]
  pub fn add_deltaPosV(&mut self, deltaPosV: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_DELTAPOSV, deltaPosV, 0.0);
  }
  #[inline]
  pub fn add_deltaPosW(&mut self, deltaPosW: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_DELTAPOSW, deltaPosW, 0.0);
  }
  #[inline]
  pub fn add_deltaVel(&mut self, deltaVel: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_DELTAVEL, deltaVel, 0.0);
  }
  #[inline]
  pub fn add_deltaVelU(&mut self, deltaVelU: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_DELTAVELU, deltaVelU, 0.0);
  }
  #[inline]
  pub fn add_deltaVelV(&mut self, deltaVelV: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_DELTAVELV, deltaVelV, 0.0);
  }
  #[inline]
  pub fn add_deltaVelW(&mut self, deltaVelW: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_DELTAVELW, deltaVelW, 0.0);
  }
  #[inline]
  pub fn add_deltaMass(&mut self, deltaMass: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_DELTAMASS, deltaMass, 0.0);
  }
  #[inline]
  pub fn add_preEventIdElset(&mut self, preEventIdElset: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_PREEVENTIDELSET, preEventIdElset);
  }
  #[inline]
  pub fn add_preEventElset(&mut self, preEventElset: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_PREEVENTELSET, preEventElset);
  }
  #[inline]
  pub fn add_preEventIdStateVector(&mut self, preEventIdStateVector: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_PREEVENTIDSTATEVECTOR, preEventIdStateVector);
  }
  #[inline]
  pub fn add_preEventStateVector(&mut self, preEventStateVector: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_PREEVENTSTATEVECTOR, preEventStateVector);
  }
  #[inline]
  pub fn add_prePosX(&mut self, prePosX: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREPOSX, prePosX, 0.0);
  }
  #[inline]
  pub fn add_prePosY(&mut self, prePosY: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREPOSY, prePosY, 0.0);
  }
  #[inline]
  pub fn add_prePosZ(&mut self, prePosZ: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREPOSZ, prePosZ, 0.0);
  }
  #[inline]
  pub fn add_preVelX(&mut self, preVelX: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREVELX, preVelX, 0.0);
  }
  #[inline]
  pub fn add_preVelY(&mut self, preVelY: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREVELY, preVelY, 0.0);
  }
  #[inline]
  pub fn add_preVelZ(&mut self, preVelZ: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREVELZ, preVelZ, 0.0);
  }
  #[inline]
  pub fn add_preRadiationPressCoeff(&mut self, preRadiationPressCoeff: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PRERADIATIONPRESSCOEFF, preRadiationPressCoeff, 0.0);
  }
  #[inline]
  pub fn add_preBallisticCoeff(&mut self, preBallisticCoeff: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREBALLISTICCOEFF, preBallisticCoeff, 0.0);
  }
  #[inline]
  pub fn add_preApogee(&mut self, preApogee: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREAPOGEE, preApogee, 0.0);
  }
  #[inline]
  pub fn add_prePerigee(&mut self, prePerigee: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREPERIGEE, prePerigee, 0.0);
  }
  #[inline]
  pub fn add_preInclination(&mut self, preInclination: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREINCLINATION, preInclination, 0.0);
  }
  #[inline]
  pub fn add_preEccentricity(&mut self, preEccentricity: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREECCENTRICITY, preEccentricity, 0.0);
  }
  #[inline]
  pub fn add_prePeriod(&mut self, prePeriod: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREPERIOD, prePeriod, 0.0);
  }
  #[inline]
  pub fn add_preRAAN(&mut self, preRAAN: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PRERAAN, preRAAN, 0.0);
  }
  #[inline]
  pub fn add_preSMA(&mut self, preSMA: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PRESMA, preSMA, 0.0);
  }
  #[inline]
  pub fn add_preGeoLongitude(&mut self, preGeoLongitude: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREGEOLONGITUDE, preGeoLongitude, 0.0);
  }
  #[inline]
  pub fn add_preDriftRate(&mut self, preDriftRate: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PREDRIFTRATE, preDriftRate, 0.0);
  }
  #[inline]
  pub fn add_preSigmaU(&mut self, preSigmaU: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PRESIGMAU, preSigmaU, 0.0);
  }
  #[inline]
  pub fn add_preSigmaV(&mut self, preSigmaV: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PRESIGMAV, preSigmaV, 0.0);
  }
  #[inline]
  pub fn add_preSigmaW(&mut self, preSigmaW: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_PRESIGMAW, preSigmaW, 0.0);
  }
  #[inline]
  pub fn add_postEventIdElset(&mut self, postEventIdElset: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_POSTEVENTIDELSET, postEventIdElset);
  }
  #[inline]
  pub fn add_postEventElset(&mut self, postEventElset: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_POSTEVENTELSET, postEventElset);
  }
  #[inline]
  pub fn add_postEventIdStateVector(&mut self, postEventIdStateVector: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_POSTEVENTIDSTATEVECTOR, postEventIdStateVector);
  }
  #[inline]
  pub fn add_postEventStateVector(&mut self, postEventStateVector: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_POSTEVENTSTATEVECTOR, postEventStateVector);
  }
  #[inline]
  pub fn add_postPosX(&mut self, postPosX: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTPOSX, postPosX, 0.0);
  }
  #[inline]
  pub fn add_postPosY(&mut self, postPosY: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTPOSY, postPosY, 0.0);
  }
  #[inline]
  pub fn add_postPosZ(&mut self, postPosZ: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTPOSZ, postPosZ, 0.0);
  }
  #[inline]
  pub fn add_postVelX(&mut self, postVelX: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTVELX, postVelX, 0.0);
  }
  #[inline]
  pub fn add_postVelY(&mut self, postVelY: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTVELY, postVelY, 0.0);
  }
  #[inline]
  pub fn add_postVelZ(&mut self, postVelZ: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTVELZ, postVelZ, 0.0);
  }
  #[inline]
  pub fn add_postRadiationPressCoeff(&mut self, postRadiationPressCoeff: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTRADIATIONPRESSCOEFF, postRadiationPressCoeff, 0.0);
  }
  #[inline]
  pub fn add_postBallisticCoeff(&mut self, postBallisticCoeff: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTBALLISTICCOEFF, postBallisticCoeff, 0.0);
  }
  #[inline]
  pub fn add_postApogee(&mut self, postApogee: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTAPOGEE, postApogee, 0.0);
  }
  #[inline]
  pub fn add_postPerigee(&mut self, postPerigee: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTPERIGEE, postPerigee, 0.0);
  }
  #[inline]
  pub fn add_postInclination(&mut self, postInclination: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTINCLINATION, postInclination, 0.0);
  }
  #[inline]
  pub fn add_postEccentricity(&mut self, postEccentricity: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTECCENTRICITY, postEccentricity, 0.0);
  }
  #[inline]
  pub fn add_postPeriod(&mut self, postPeriod: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTPERIOD, postPeriod, 0.0);
  }
  #[inline]
  pub fn add_postRAAN(&mut self, postRAAN: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTRAAN, postRAAN, 0.0);
  }
  #[inline]
  pub fn add_postSMA(&mut self, postSMA: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTSMA, postSMA, 0.0);
  }
  #[inline]
  pub fn add_postGeoLongitude(&mut self, postGeoLongitude: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTGEOLONGITUDE, postGeoLongitude, 0.0);
  }
  #[inline]
  pub fn add_postDriftRate(&mut self, postDriftRate: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTDRIFTRATE, postDriftRate, 0.0);
  }
  #[inline]
  pub fn add_postSigmaU(&mut self, postSigmaU: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTSIGMAU, postSigmaU, 0.0);
  }
  #[inline]
  pub fn add_postSigmaV(&mut self, postSigmaV: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTSIGMAV, postSigmaV, 0.0);
  }
  #[inline]
  pub fn add_postSigmaW(&mut self, postSigmaW: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTSIGMAW, postSigmaW, 0.0);
  }
  #[inline]
  pub fn add_cov(&mut self, cov: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_COV, cov);
  }
  #[inline]
  pub fn add_postMass(&mut self, postMass: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTMASS, postMass, 0.0);
  }
  #[inline]
  pub fn add_postArea(&mut self, postArea: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_POSTAREA, postArea, 0.0);
  }
  #[inline]
  pub fn add_numObs(&mut self, numObs: i32) {
    self.fbb_.push_slot::<i32>(Maneuver_Full::VT_NUMOBS, numObs, 0);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_descriptor(&mut self, descriptor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_DESCRIPTOR, descriptor);
  }
  #[inline]
  pub fn add_stateModel(&mut self, stateModel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_STATEMODEL, stateModel);
  }
  #[inline]
  pub fn add_stateModelVersion(&mut self, stateModelVersion: f64) {
    self.fbb_.push_slot::<f64>(Maneuver_Full::VT_STATEMODELVERSION, stateModelVersion, 0.0);
  }
  #[inline]
  pub fn add_numAccelPoints(&mut self, numAccelPoints: i32) {
    self.fbb_.push_slot::<i32>(Maneuver_Full::VT_NUMACCELPOINTS, numAccelPoints, 0);
  }
  #[inline]
  pub fn add_mnvrAccelTimes(&mut self, mnvrAccelTimes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_MNVRACCELTIMES, mnvrAccelTimes);
  }
  #[inline]
  pub fn add_mnvrAccels(&mut self, mnvrAccels: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_MNVRACCELS, mnvrAccels);
  }
  #[inline]
  pub fn add_mnvrAccelUncs(&mut self, mnvrAccelUncs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_MNVRACCELUNCS, mnvrAccelUncs);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: Maneuver_Full_dataMode_Enum) {
    self.fbb_.push_slot::<Maneuver_Full_dataMode_Enum>(Maneuver_Full::VT_DATAMODE, dataMode, Maneuver_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_algorithm(&mut self, algorithm: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_ALGORITHM, algorithm);
  }
  #[inline]
  pub fn add_sourcedData(&mut self, sourcedData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_SOURCEDDATA, sourcedData);
  }
  #[inline]
  pub fn add_sourcedDataTypes(&mut self, sourcedDataTypes: Maneuver_Full_sourcedDataTypes_Enum) {
    self.fbb_.push_slot::<Maneuver_Full_sourcedDataTypes_Enum>(Maneuver_Full::VT_SOURCEDDATATYPES, sourcedDataTypes, Maneuver_Full_sourcedDataTypes_Enum::EO);
  }
  #[inline]
  pub fn add_onOrbit(&mut self, onOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_ONORBIT, onOrbit);
  }
  #[inline]
  pub fn add_transactionId(&mut self, transactionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_TRANSACTIONID, transactionId);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Maneuver_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Maneuver_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Maneuver_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Maneuver_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Maneuver_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Maneuver_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("satNo", &self.satNo());
      ds.field("reportTime", &self.reportTime());
      ds.field("eventStartTime", &self.eventStartTime());
      ds.field("eventEndTime", &self.eventEndTime());
      ds.field("totalBurnTime", &self.totalBurnTime());
      ds.field("odFitEndTime", &self.odFitEndTime());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("idSensor", &self.idSensor());
      ds.field("uct", &self.uct());
      ds.field("maneuverUnc", &self.maneuverUnc());
      ds.field("characterization", &self.characterization());
      ds.field("characterizationUnc", &self.characterizationUnc());
      ds.field("eventId", &self.eventId());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("origSensorId", &self.origSensorId());
      ds.field("status", &self.status());
      ds.field("deltaPos", &self.deltaPos());
      ds.field("deltaPosU", &self.deltaPosU());
      ds.field("deltaPosV", &self.deltaPosV());
      ds.field("deltaPosW", &self.deltaPosW());
      ds.field("deltaVel", &self.deltaVel());
      ds.field("deltaVelU", &self.deltaVelU());
      ds.field("deltaVelV", &self.deltaVelV());
      ds.field("deltaVelW", &self.deltaVelW());
      ds.field("deltaMass", &self.deltaMass());
      ds.field("preEventIdElset", &self.preEventIdElset());
      ds.field("preEventElset", &self.preEventElset());
      ds.field("preEventIdStateVector", &self.preEventIdStateVector());
      ds.field("preEventStateVector", &self.preEventStateVector());
      ds.field("prePosX", &self.prePosX());
      ds.field("prePosY", &self.prePosY());
      ds.field("prePosZ", &self.prePosZ());
      ds.field("preVelX", &self.preVelX());
      ds.field("preVelY", &self.preVelY());
      ds.field("preVelZ", &self.preVelZ());
      ds.field("preRadiationPressCoeff", &self.preRadiationPressCoeff());
      ds.field("preBallisticCoeff", &self.preBallisticCoeff());
      ds.field("preApogee", &self.preApogee());
      ds.field("prePerigee", &self.prePerigee());
      ds.field("preInclination", &self.preInclination());
      ds.field("preEccentricity", &self.preEccentricity());
      ds.field("prePeriod", &self.prePeriod());
      ds.field("preRAAN", &self.preRAAN());
      ds.field("preSMA", &self.preSMA());
      ds.field("preGeoLongitude", &self.preGeoLongitude());
      ds.field("preDriftRate", &self.preDriftRate());
      ds.field("preSigmaU", &self.preSigmaU());
      ds.field("preSigmaV", &self.preSigmaV());
      ds.field("preSigmaW", &self.preSigmaW());
      ds.field("postEventIdElset", &self.postEventIdElset());
      ds.field("postEventElset", &self.postEventElset());
      ds.field("postEventIdStateVector", &self.postEventIdStateVector());
      ds.field("postEventStateVector", &self.postEventStateVector());
      ds.field("postPosX", &self.postPosX());
      ds.field("postPosY", &self.postPosY());
      ds.field("postPosZ", &self.postPosZ());
      ds.field("postVelX", &self.postVelX());
      ds.field("postVelY", &self.postVelY());
      ds.field("postVelZ", &self.postVelZ());
      ds.field("postRadiationPressCoeff", &self.postRadiationPressCoeff());
      ds.field("postBallisticCoeff", &self.postBallisticCoeff());
      ds.field("postApogee", &self.postApogee());
      ds.field("postPerigee", &self.postPerigee());
      ds.field("postInclination", &self.postInclination());
      ds.field("postEccentricity", &self.postEccentricity());
      ds.field("postPeriod", &self.postPeriod());
      ds.field("postRAAN", &self.postRAAN());
      ds.field("postSMA", &self.postSMA());
      ds.field("postGeoLongitude", &self.postGeoLongitude());
      ds.field("postDriftRate", &self.postDriftRate());
      ds.field("postSigmaU", &self.postSigmaU());
      ds.field("postSigmaV", &self.postSigmaV());
      ds.field("postSigmaW", &self.postSigmaW());
      ds.field("cov", &self.cov());
      ds.field("postMass", &self.postMass());
      ds.field("postArea", &self.postArea());
      ds.field("numObs", &self.numObs());
      ds.field("description", &self.description());
      ds.field("descriptor", &self.descriptor());
      ds.field("stateModel", &self.stateModel());
      ds.field("stateModelVersion", &self.stateModelVersion());
      ds.field("numAccelPoints", &self.numAccelPoints());
      ds.field("mnvrAccelTimes", &self.mnvrAccelTimes());
      ds.field("mnvrAccels", &self.mnvrAccels());
      ds.field("mnvrAccelUncs", &self.mnvrAccelUncs());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("tags", &self.tags());
      ds.field("algorithm", &self.algorithm());
      ds.field("sourcedData", &self.sourcedData());
      ds.field("sourcedDataTypes", &self.sourcedDataTypes());
      ds.field("onOrbit", &self.onOrbit());
      ds.field("transactionId", &self.transactionId());
      ds.field("origNetwork", &self.origNetwork());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Maneuver_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub satNo: i32,
  pub reportTime: Option<String>,
  pub eventStartTime: Option<String>,
  pub eventEndTime: Option<String>,
  pub totalBurnTime: f64,
  pub odFitEndTime: Option<String>,
  pub idOnOrbit: Option<String>,
  pub idSensor: Option<String>,
  pub uct: bool,
  pub maneuverUnc: f64,
  pub characterization: Option<String>,
  pub characterizationUnc: f64,
  pub eventId: Option<String>,
  pub origObjectId: Option<String>,
  pub origSensorId: Option<String>,
  pub status: Option<String>,
  pub deltaPos: f64,
  pub deltaPosU: f64,
  pub deltaPosV: f64,
  pub deltaPosW: f64,
  pub deltaVel: f64,
  pub deltaVelU: f64,
  pub deltaVelV: f64,
  pub deltaVelW: f64,
  pub deltaMass: f64,
  pub preEventIdElset: Option<String>,
  pub preEventElset: Option<String>,
  pub preEventIdStateVector: Option<String>,
  pub preEventStateVector: Option<String>,
  pub prePosX: f64,
  pub prePosY: f64,
  pub prePosZ: f64,
  pub preVelX: f64,
  pub preVelY: f64,
  pub preVelZ: f64,
  pub preRadiationPressCoeff: f64,
  pub preBallisticCoeff: f64,
  pub preApogee: f64,
  pub prePerigee: f64,
  pub preInclination: f64,
  pub preEccentricity: f64,
  pub prePeriod: f64,
  pub preRAAN: f64,
  pub preSMA: f64,
  pub preGeoLongitude: f64,
  pub preDriftRate: f64,
  pub preSigmaU: f64,
  pub preSigmaV: f64,
  pub preSigmaW: f64,
  pub postEventIdElset: Option<String>,
  pub postEventElset: Option<String>,
  pub postEventIdStateVector: Option<String>,
  pub postEventStateVector: Option<String>,
  pub postPosX: f64,
  pub postPosY: f64,
  pub postPosZ: f64,
  pub postVelX: f64,
  pub postVelY: f64,
  pub postVelZ: f64,
  pub postRadiationPressCoeff: f64,
  pub postBallisticCoeff: f64,
  pub postApogee: f64,
  pub postPerigee: f64,
  pub postInclination: f64,
  pub postEccentricity: f64,
  pub postPeriod: f64,
  pub postRAAN: f64,
  pub postSMA: f64,
  pub postGeoLongitude: f64,
  pub postDriftRate: f64,
  pub postSigmaU: f64,
  pub postSigmaV: f64,
  pub postSigmaW: f64,
  pub cov: Option<Vec<String>>,
  pub postMass: f64,
  pub postArea: f64,
  pub numObs: i32,
  pub description: Option<String>,
  pub descriptor: Option<String>,
  pub stateModel: Option<String>,
  pub stateModelVersion: f64,
  pub numAccelPoints: i32,
  pub mnvrAccelTimes: Option<Vec<String>>,
  pub mnvrAccels: Option<Vec<String>>,
  pub mnvrAccelUncs: Option<Vec<String>>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: Maneuver_Full_dataMode_Enum,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub tags: Option<Vec<String>>,
  pub algorithm: Option<String>,
  pub sourcedData: Option<Vec<String>>,
  pub sourcedDataTypes: Maneuver_Full_sourcedDataTypes_Enum,
  pub onOrbit: Option<String>,
  pub transactionId: Option<String>,
  pub origNetwork: Option<String>,
}
impl Default for Maneuver_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      satNo: 0,
      reportTime: None,
      eventStartTime: None,
      eventEndTime: None,
      totalBurnTime: 0.0,
      odFitEndTime: None,
      idOnOrbit: None,
      idSensor: None,
      uct: false,
      maneuverUnc: 0.0,
      characterization: None,
      characterizationUnc: 0.0,
      eventId: None,
      origObjectId: None,
      origSensorId: None,
      status: None,
      deltaPos: 0.0,
      deltaPosU: 0.0,
      deltaPosV: 0.0,
      deltaPosW: 0.0,
      deltaVel: 0.0,
      deltaVelU: 0.0,
      deltaVelV: 0.0,
      deltaVelW: 0.0,
      deltaMass: 0.0,
      preEventIdElset: None,
      preEventElset: None,
      preEventIdStateVector: None,
      preEventStateVector: None,
      prePosX: 0.0,
      prePosY: 0.0,
      prePosZ: 0.0,
      preVelX: 0.0,
      preVelY: 0.0,
      preVelZ: 0.0,
      preRadiationPressCoeff: 0.0,
      preBallisticCoeff: 0.0,
      preApogee: 0.0,
      prePerigee: 0.0,
      preInclination: 0.0,
      preEccentricity: 0.0,
      prePeriod: 0.0,
      preRAAN: 0.0,
      preSMA: 0.0,
      preGeoLongitude: 0.0,
      preDriftRate: 0.0,
      preSigmaU: 0.0,
      preSigmaV: 0.0,
      preSigmaW: 0.0,
      postEventIdElset: None,
      postEventElset: None,
      postEventIdStateVector: None,
      postEventStateVector: None,
      postPosX: 0.0,
      postPosY: 0.0,
      postPosZ: 0.0,
      postVelX: 0.0,
      postVelY: 0.0,
      postVelZ: 0.0,
      postRadiationPressCoeff: 0.0,
      postBallisticCoeff: 0.0,
      postApogee: 0.0,
      postPerigee: 0.0,
      postInclination: 0.0,
      postEccentricity: 0.0,
      postPeriod: 0.0,
      postRAAN: 0.0,
      postSMA: 0.0,
      postGeoLongitude: 0.0,
      postDriftRate: 0.0,
      postSigmaU: 0.0,
      postSigmaV: 0.0,
      postSigmaW: 0.0,
      cov: None,
      postMass: 0.0,
      postArea: 0.0,
      numObs: 0,
      description: None,
      descriptor: None,
      stateModel: None,
      stateModelVersion: 0.0,
      numAccelPoints: 0,
      mnvrAccelTimes: None,
      mnvrAccels: None,
      mnvrAccelUncs: None,
      source: None,
      origin: None,
      dataMode: Maneuver_Full_dataMode_Enum::REAL,
      createdAt: None,
      createdBy: None,
      tags: None,
      algorithm: None,
      sourcedData: None,
      sourcedDataTypes: Maneuver_Full_sourcedDataTypes_Enum::EO,
      onOrbit: None,
      transactionId: None,
      origNetwork: None,
    }
  }
}
impl Maneuver_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Maneuver_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo = self.satNo;
    let reportTime = self.reportTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eventStartTime = self.eventStartTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let eventEndTime = self.eventEndTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let totalBurnTime = self.totalBurnTime;
    let odFitEndTime = self.odFitEndTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor = self.idSensor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let uct = self.uct;
    let maneuverUnc = self.maneuverUnc;
    let characterization = self.characterization.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let characterizationUnc = self.characterizationUnc;
    let eventId = self.eventId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId = self.origSensorId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let status = self.status.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let deltaPos = self.deltaPos;
    let deltaPosU = self.deltaPosU;
    let deltaPosV = self.deltaPosV;
    let deltaPosW = self.deltaPosW;
    let deltaVel = self.deltaVel;
    let deltaVelU = self.deltaVelU;
    let deltaVelV = self.deltaVelV;
    let deltaVelW = self.deltaVelW;
    let deltaMass = self.deltaMass;
    let preEventIdElset = self.preEventIdElset.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let preEventElset = self.preEventElset.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let preEventIdStateVector = self.preEventIdStateVector.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let preEventStateVector = self.preEventStateVector.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let prePosX = self.prePosX;
    let prePosY = self.prePosY;
    let prePosZ = self.prePosZ;
    let preVelX = self.preVelX;
    let preVelY = self.preVelY;
    let preVelZ = self.preVelZ;
    let preRadiationPressCoeff = self.preRadiationPressCoeff;
    let preBallisticCoeff = self.preBallisticCoeff;
    let preApogee = self.preApogee;
    let prePerigee = self.prePerigee;
    let preInclination = self.preInclination;
    let preEccentricity = self.preEccentricity;
    let prePeriod = self.prePeriod;
    let preRAAN = self.preRAAN;
    let preSMA = self.preSMA;
    let preGeoLongitude = self.preGeoLongitude;
    let preDriftRate = self.preDriftRate;
    let preSigmaU = self.preSigmaU;
    let preSigmaV = self.preSigmaV;
    let preSigmaW = self.preSigmaW;
    let postEventIdElset = self.postEventIdElset.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let postEventElset = self.postEventElset.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let postEventIdStateVector = self.postEventIdStateVector.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let postEventStateVector = self.postEventStateVector.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let postPosX = self.postPosX;
    let postPosY = self.postPosY;
    let postPosZ = self.postPosZ;
    let postVelX = self.postVelX;
    let postVelY = self.postVelY;
    let postVelZ = self.postVelZ;
    let postRadiationPressCoeff = self.postRadiationPressCoeff;
    let postBallisticCoeff = self.postBallisticCoeff;
    let postApogee = self.postApogee;
    let postPerigee = self.postPerigee;
    let postInclination = self.postInclination;
    let postEccentricity = self.postEccentricity;
    let postPeriod = self.postPeriod;
    let postRAAN = self.postRAAN;
    let postSMA = self.postSMA;
    let postGeoLongitude = self.postGeoLongitude;
    let postDriftRate = self.postDriftRate;
    let postSigmaU = self.postSigmaU;
    let postSigmaV = self.postSigmaV;
    let postSigmaW = self.postSigmaW;
    let cov = self.cov.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let postMass = self.postMass;
    let postArea = self.postArea;
    let numObs = self.numObs;
    let description = self.description.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let descriptor = self.descriptor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stateModel = self.stateModel.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stateModelVersion = self.stateModelVersion;
    let numAccelPoints = self.numAccelPoints;
    let mnvrAccelTimes = self.mnvrAccelTimes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let mnvrAccels = self.mnvrAccels.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let mnvrAccelUncs = self.mnvrAccelUncs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let algorithm = self.algorithm.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourcedData = self.sourcedData.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let sourcedDataTypes = self.sourcedDataTypes;
    let onOrbit = self.onOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let transactionId = self.transactionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Maneuver_Full::create(_fbb, &Maneuver_FullArgs{
      id,
      classificationMarking,
      satNo,
      reportTime,
      eventStartTime,
      eventEndTime,
      totalBurnTime,
      odFitEndTime,
      idOnOrbit,
      idSensor,
      uct,
      maneuverUnc,
      characterization,
      characterizationUnc,
      eventId,
      origObjectId,
      origSensorId,
      status,
      deltaPos,
      deltaPosU,
      deltaPosV,
      deltaPosW,
      deltaVel,
      deltaVelU,
      deltaVelV,
      deltaVelW,
      deltaMass,
      preEventIdElset,
      preEventElset,
      preEventIdStateVector,
      preEventStateVector,
      prePosX,
      prePosY,
      prePosZ,
      preVelX,
      preVelY,
      preVelZ,
      preRadiationPressCoeff,
      preBallisticCoeff,
      preApogee,
      prePerigee,
      preInclination,
      preEccentricity,
      prePeriod,
      preRAAN,
      preSMA,
      preGeoLongitude,
      preDriftRate,
      preSigmaU,
      preSigmaV,
      preSigmaW,
      postEventIdElset,
      postEventElset,
      postEventIdStateVector,
      postEventStateVector,
      postPosX,
      postPosY,
      postPosZ,
      postVelX,
      postVelY,
      postVelZ,
      postRadiationPressCoeff,
      postBallisticCoeff,
      postApogee,
      postPerigee,
      postInclination,
      postEccentricity,
      postPeriod,
      postRAAN,
      postSMA,
      postGeoLongitude,
      postDriftRate,
      postSigmaU,
      postSigmaV,
      postSigmaW,
      cov,
      postMass,
      postArea,
      numObs,
      description,
      descriptor,
      stateModel,
      stateModelVersion,
      numAccelPoints,
      mnvrAccelTimes,
      mnvrAccels,
      mnvrAccelUncs,
      source,
      origin,
      dataMode,
      createdAt,
      createdBy,
      tags,
      algorithm,
      sourcedData,
      sourcedDataTypes,
      onOrbit,
      transactionId,
      origNetwork,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Maneuver_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_maneuver_full_unchecked`.
pub fn root_as_maneuver_full(buf: &[u8]) -> Result<Maneuver_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Maneuver_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Maneuver_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_maneuver_full_unchecked`.
pub fn size_prefixed_root_as_maneuver_full(buf: &[u8]) -> Result<Maneuver_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Maneuver_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Maneuver_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_maneuver_full_unchecked`.
pub fn root_as_maneuver_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Maneuver_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Maneuver_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Maneuver_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_maneuver_full_unchecked`.
pub fn size_prefixed_root_as_maneuver_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Maneuver_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Maneuver_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Maneuver_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Maneuver_Full`.
pub unsafe fn root_as_maneuver_full_unchecked(buf: &[u8]) -> Maneuver_Full {
  flatbuffers::root_unchecked::<Maneuver_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Maneuver_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Maneuver_Full`.
pub unsafe fn size_prefixed_root_as_maneuver_full_unchecked(buf: &[u8]) -> Maneuver_Full {
  flatbuffers::size_prefixed_root_unchecked::<Maneuver_Full>(buf)
}
pub const MANEUVER_FULL_IDENTIFIER: &str = "MANE";

#[inline]
pub fn maneuver_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MANEUVER_FULL_IDENTIFIER, false)
}

#[inline]
pub fn maneuver_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MANEUVER_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_maneuver_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Maneuver_Full<'a>>) {
  fbb.finish(root, Some(MANEUVER_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_maneuver_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Maneuver_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(MANEUVER_FULL_IDENTIFIER));
}
