// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum MissileTrackVector_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Schema for Missile Track Vector data.
pub struct MissileTrackVector_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MissileTrackVector_Full<'a> {
  type Inner = MissileTrackVector_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MissileTrackVector_Full<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_OBJECT: flatbuffers::VOffsetT = 6;
  pub const VT_EPOCH: flatbuffers::VOffsetT = 8;
  pub const VT_IDSENSOR: flatbuffers::VOffsetT = 10;
  pub const VT_ORIGSENSORID: flatbuffers::VOffsetT = 12;
  pub const VT_POS: flatbuffers::VOffsetT = 14;
  pub const VT_VEL: flatbuffers::VOffsetT = 16;
  pub const VT_ACCEL: flatbuffers::VOffsetT = 18;
  pub const VT_COURSE: flatbuffers::VOffsetT = 20;
  pub const VT_SPD: flatbuffers::VOffsetT = 22;
  pub const VT_REFERENCEFRAME: flatbuffers::VOffsetT = 24;
  pub const VT_COV: flatbuffers::VOffsetT = 26;
  pub const VT_COVREFERENCEFRAME: flatbuffers::VOffsetT = 28;
  pub const VT_VECTORLAT: flatbuffers::VOffsetT = 30;
  pub const VT_VECTORLON: flatbuffers::VOffsetT = 32;
  pub const VT_VECTORALT: flatbuffers::VOffsetT = 34;
  pub const VT_CONFIDENCE: flatbuffers::VOffsetT = 36;
  pub const VT_STATUS: flatbuffers::VOffsetT = 38;
  pub const VT_TIMESOURCE: flatbuffers::VOffsetT = 40;
  pub const VT_QUAT: flatbuffers::VOffsetT = 42;
  pub const VT_FLIGHTAZ: flatbuffers::VOffsetT = 44;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MissileTrackVector_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MissileTrackVector_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<MissileTrackVector_Full<'bldr>> {
    let mut builder = MissileTrackVector_FullBuilder::new(_fbb);
    builder.add_flightAz(args.flightAz);
    builder.add_vectorAlt(args.vectorAlt);
    builder.add_vectorLon(args.vectorLon);
    builder.add_vectorLat(args.vectorLat);
    builder.add_spd(args.spd);
    builder.add_course(args.course);
    if let Some(x) = args.quat { builder.add_quat(x); }
    if let Some(x) = args.timeSource { builder.add_timeSource(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    builder.add_confidence(args.confidence);
    if let Some(x) = args.covReferenceFrame { builder.add_covReferenceFrame(x); }
    if let Some(x) = args.cov { builder.add_cov(x); }
    if let Some(x) = args.referenceFrame { builder.add_referenceFrame(x); }
    if let Some(x) = args.accel { builder.add_accel(x); }
    if let Some(x) = args.vel { builder.add_vel(x); }
    if let Some(x) = args.pos { builder.add_pos(x); }
    if let Some(x) = args.origSensorId { builder.add_origSensorId(x); }
    if let Some(x) = args.idSensor { builder.add_idSensor(x); }
    if let Some(x) = args.epoch { builder.add_epoch(x); }
    if let Some(x) = args.object { builder.add_object(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MissileTrackVector_FullT {
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let object = self.object().map(|x| {
      x.to_string()
    });
    let epoch = self.epoch().map(|x| {
      x.to_string()
    });
    let idSensor = self.idSensor().map(|x| {
      x.to_string()
    });
    let origSensorId = self.origSensorId().map(|x| {
      x.to_string()
    });
    let pos = self.pos().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let vel = self.vel().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let accel = self.accel().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let course = self.course();
    let spd = self.spd();
    let referenceFrame = self.referenceFrame().map(|x| {
      x.to_string()
    });
    let cov = self.cov().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let covReferenceFrame = self.covReferenceFrame().map(|x| {
      x.to_string()
    });
    let vectorLat = self.vectorLat();
    let vectorLon = self.vectorLon();
    let vectorAlt = self.vectorAlt();
    let confidence = self.confidence();
    let status = self.status().map(|x| {
      x.to_string()
    });
    let timeSource = self.timeSource().map(|x| {
      x.to_string()
    });
    let quat = self.quat().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let flightAz = self.flightAz();
    MissileTrackVector_FullT {
      type_,
      object,
      epoch,
      idSensor,
      origSensorId,
      pos,
      vel,
      accel,
      course,
      spd,
      referenceFrame,
      cov,
      covReferenceFrame,
      vectorLat,
      vectorLon,
      vectorAlt,
      confidence,
      status,
      timeSource,
      quat,
      flightAz,
    }
  }

  /// Type of vector represented (e.g. LOS, PREDICTED, STATE).
  /// Example: /// Example: STATE
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrackVector_Full::VT_TYPE_, None)}
  }
  /// Object to which this vector applies.
  /// Example: /// Example: TARGET
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn object(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrackVector_Full::VT_OBJECT, None)}
  }
  /// Vector timestamp in ISO8601 UTC format, with microsecond precision.
  /// Example: /// Example: 2024-03-30T15:02:39.346768Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn epoch(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrackVector_Full::VT_EPOCH, None)}
  }
  /// Unique identifier of the reporting sensor of the object.
  /// Example: /// Example: a7e99418-b6d6-29ab-e767-440a989cce26
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrackVector_Full::VT_IDSENSOR, None)}
  }
  /// Optional identifier provided by the source to indicate the reporting sensor of the object. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 46
  #[inline]
  pub fn origSensorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrackVector_Full::VT_ORIGSENSORID, None)}
  }
  /// Three element array, expressing the cartesian position vector of the target object, in kilometers, in the specified referenceFrame. If referenceFrame is null then ECEF should be assumed. The array element order is [x, y, z].
  /// Example: /// Example: [-1456.91592, -2883.54041, 6165.55186]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pos(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MissileTrackVector_Full::VT_POS, None)}
  }
  /// Three element array, expressing the cartesian velocity vector of the target object, in kilometers/second, in the specified referenceFrame. If referenceFrame is null then ECEF should be assumed. The array element order is [x', y', z'].
  /// Example: /// Example: [-1.21981, -6.60208, -3.36515]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vel(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MissileTrackVector_Full::VT_VEL, None)}
  }
  /// Three element array, expressing the cartesian acceleration vector of the target object, in kilometers/second^2, in the specified referenceFrame. If referenceFrame is null then ECEF should be assumed. The array element order is [x'', y'', z''].
  /// Example: /// Example: [0.59236, -0.03537, 0.35675]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn accel(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MissileTrackVector_Full::VT_ACCEL, None)}
  }
  /// Track object course, in degrees clockwise from true north.
  /// Example: /// Example: 7.3580153
  /// Constraints: No constraints specified.
  #[inline]
  pub fn course(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrackVector_Full::VT_COURSE, Some(0.0)).unwrap()}
  }
  /// Track object speed, in kilometers/sec.
  /// Example: /// Example: 15.03443
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spd(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrackVector_Full::VT_SPD, Some(0.0)).unwrap()}
  }
  /// The reference frame of the cartesian vector (ECEF, J2000). If the referenceFrame is null it is assumed to be ECEF.
  /// Example: /// Example: ECEF
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn referenceFrame(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrackVector_Full::VT_REFERENCEFRAME, None)}
  }
  /// Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.
  /// If the covReferenceFrame is null it is assumed to be UVW. The array values (1-45) represent the upper triangular half of the position-velocity-acceleration covariance matrix.
  /// The covariance elements are position dependent within the array with values ordered as follows:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x"&nbsp;&nbsp;&nbsp;&nbsp;y"&nbsp;&nbsp;&nbsp;&nbsp;z"
  /// x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9
  /// y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;14&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;&nbsp;17
  /// z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;&nbsp;23&nbsp;&nbsp;&nbsp;24
  /// x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;26&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;&nbsp;30
  /// y'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;31&nbsp;&nbsp;&nbsp;32&nbsp;&nbsp;&nbsp;33&nbsp;&nbsp;&nbsp;34&nbsp;&nbsp;&nbsp;35
  /// z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;&nbsp;38&nbsp;&nbsp;&nbsp;39
  /// x"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;42
  /// y"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;44
  /// z"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45
  /// The cov array should contain only the upper right triangle values from top left down to bottom right, in order.
  /// Example: /// Example: [1.1, 2.2, 3.3]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn cov(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MissileTrackVector_Full::VT_COV, None)}
  }
  /// The reference frame of the covariance elements (ECEF, J2000, UVW). If the referenceFrame is null it is assumed to be UVW.
  /// Example: /// Example: ECEF
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn covReferenceFrame(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrackVector_Full::VT_COVREFERENCEFRAME, None)}
  }
  /// WGS-84 object latitude subpoint at epoch, represented as -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vectorLat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrackVector_Full::VT_VECTORLAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 object longitude subpoint at epoch, represented as -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 150.0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vectorLon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrackVector_Full::VT_VECTORLON, Some(0.0)).unwrap()}
  }
  /// Object altitude at epoch, expressed in kilometers above WGS-84 ellipsoid.
  /// Example: /// Example: 25.0
  /// Constraints: No constraints specified.
  #[inline]
  pub fn vectorAlt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrackVector_Full::VT_VECTORALT, Some(0.0)).unwrap()}
  }
  /// Confidence of the vector, 0-100.
  /// Example: /// Example: 100
  /// Constraints: No constraints specified.
  #[inline]
  pub fn confidence(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MissileTrackVector_Full::VT_CONFIDENCE, Some(0)).unwrap()}
  }
  /// Status of the vector (e.g. INITIAL, UPDATE).
  /// Example: /// Example: INITIAL
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn status(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrackVector_Full::VT_STATUS, None)}
  }
  /// Source of the time value.
  /// Example: /// Example: Sensor 1
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn timeSource(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MissileTrackVector_Full::VT_TIMESOURCE, None)}
  }
  /// The quaternion describing the attitude of the spacecraft with respect to the reference frame listed in the 'referenceFrame' field. The array element order convention is the three vector components, followed by the scalar component.
  /// Example: /// Example: [0.03, 0.02, 0.01, 0.012]
  /// Constraints: No constraints specified.
  #[inline]
  pub fn quat(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MissileTrackVector_Full::VT_QUAT, None)}
  }
  /// The flight azimuth associated with the current state vector (0-360 degrees).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn flightAz(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MissileTrackVector_Full::VT_FLIGHTAZ, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MissileTrackVector_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("object", Self::VT_OBJECT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("epoch", Self::VT_EPOCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor", Self::VT_IDSENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId", Self::VT_ORIGSENSORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("pos", Self::VT_POS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("vel", Self::VT_VEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("accel", Self::VT_ACCEL, false)?
     .visit_field::<f64>("course", Self::VT_COURSE, false)?
     .visit_field::<f64>("spd", Self::VT_SPD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("referenceFrame", Self::VT_REFERENCEFRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("cov", Self::VT_COV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("covReferenceFrame", Self::VT_COVREFERENCEFRAME, false)?
     .visit_field::<f64>("vectorLat", Self::VT_VECTORLAT, false)?
     .visit_field::<f64>("vectorLon", Self::VT_VECTORLON, false)?
     .visit_field::<f64>("vectorAlt", Self::VT_VECTORALT, false)?
     .visit_field::<i32>("confidence", Self::VT_CONFIDENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("timeSource", Self::VT_TIMESOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("quat", Self::VT_QUAT, false)?
     .visit_field::<f64>("flightAz", Self::VT_FLIGHTAZ, false)?
     .finish();
    Ok(())
  }
}
pub struct MissileTrackVector_FullArgs<'a> {
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub object: Option<flatbuffers::WIPOffset<&'a str>>,
    pub epoch: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pos: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub vel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub accel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub course: f64,
    pub spd: f64,
    pub referenceFrame: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cov: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub covReferenceFrame: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vectorLat: f64,
    pub vectorLon: f64,
    pub vectorAlt: f64,
    pub confidence: i32,
    pub status: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timeSource: Option<flatbuffers::WIPOffset<&'a str>>,
    pub quat: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub flightAz: f64,
}
impl<'a> Default for MissileTrackVector_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    MissileTrackVector_FullArgs {
      type_: None,
      object: None,
      epoch: None,
      idSensor: None,
      origSensorId: None,
      pos: None,
      vel: None,
      accel: None,
      course: 0.0,
      spd: 0.0,
      referenceFrame: None,
      cov: None,
      covReferenceFrame: None,
      vectorLat: 0.0,
      vectorLon: 0.0,
      vectorAlt: 0.0,
      confidence: 0,
      status: None,
      timeSource: None,
      quat: None,
      flightAz: 0.0,
    }
  }
}

pub struct MissileTrackVector_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MissileTrackVector_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_object(&mut self, object: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_OBJECT, object);
  }
  #[inline]
  pub fn add_epoch(&mut self, epoch: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_EPOCH, epoch);
  }
  #[inline]
  pub fn add_idSensor(&mut self, idSensor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_IDSENSOR, idSensor);
  }
  #[inline]
  pub fn add_origSensorId(&mut self, origSensorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_ORIGSENSORID, origSensorId);
  }
  #[inline]
  pub fn add_pos(&mut self, pos: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_POS, pos);
  }
  #[inline]
  pub fn add_vel(&mut self, vel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_VEL, vel);
  }
  #[inline]
  pub fn add_accel(&mut self, accel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_ACCEL, accel);
  }
  #[inline]
  pub fn add_course(&mut self, course: f64) {
    self.fbb_.push_slot::<f64>(MissileTrackVector_Full::VT_COURSE, course, 0.0);
  }
  #[inline]
  pub fn add_spd(&mut self, spd: f64) {
    self.fbb_.push_slot::<f64>(MissileTrackVector_Full::VT_SPD, spd, 0.0);
  }
  #[inline]
  pub fn add_referenceFrame(&mut self, referenceFrame: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_REFERENCEFRAME, referenceFrame);
  }
  #[inline]
  pub fn add_cov(&mut self, cov: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_COV, cov);
  }
  #[inline]
  pub fn add_covReferenceFrame(&mut self, covReferenceFrame: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_COVREFERENCEFRAME, covReferenceFrame);
  }
  #[inline]
  pub fn add_vectorLat(&mut self, vectorLat: f64) {
    self.fbb_.push_slot::<f64>(MissileTrackVector_Full::VT_VECTORLAT, vectorLat, 0.0);
  }
  #[inline]
  pub fn add_vectorLon(&mut self, vectorLon: f64) {
    self.fbb_.push_slot::<f64>(MissileTrackVector_Full::VT_VECTORLON, vectorLon, 0.0);
  }
  #[inline]
  pub fn add_vectorAlt(&mut self, vectorAlt: f64) {
    self.fbb_.push_slot::<f64>(MissileTrackVector_Full::VT_VECTORALT, vectorAlt, 0.0);
  }
  #[inline]
  pub fn add_confidence(&mut self, confidence: i32) {
    self.fbb_.push_slot::<i32>(MissileTrackVector_Full::VT_CONFIDENCE, confidence, 0);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_STATUS, status);
  }
  #[inline]
  pub fn add_timeSource(&mut self, timeSource: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_TIMESOURCE, timeSource);
  }
  #[inline]
  pub fn add_quat(&mut self, quat: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MissileTrackVector_Full::VT_QUAT, quat);
  }
  #[inline]
  pub fn add_flightAz(&mut self, flightAz: f64) {
    self.fbb_.push_slot::<f64>(MissileTrackVector_Full::VT_FLIGHTAZ, flightAz, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MissileTrackVector_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MissileTrackVector_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MissileTrackVector_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MissileTrackVector_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MissileTrackVector_Full");
      ds.field("type_", &self.type_());
      ds.field("object", &self.object());
      ds.field("epoch", &self.epoch());
      ds.field("idSensor", &self.idSensor());
      ds.field("origSensorId", &self.origSensorId());
      ds.field("pos", &self.pos());
      ds.field("vel", &self.vel());
      ds.field("accel", &self.accel());
      ds.field("course", &self.course());
      ds.field("spd", &self.spd());
      ds.field("referenceFrame", &self.referenceFrame());
      ds.field("cov", &self.cov());
      ds.field("covReferenceFrame", &self.covReferenceFrame());
      ds.field("vectorLat", &self.vectorLat());
      ds.field("vectorLon", &self.vectorLon());
      ds.field("vectorAlt", &self.vectorAlt());
      ds.field("confidence", &self.confidence());
      ds.field("status", &self.status());
      ds.field("timeSource", &self.timeSource());
      ds.field("quat", &self.quat());
      ds.field("flightAz", &self.flightAz());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MissileTrackVector_FullT {
  pub type_: Option<String>,
  pub object: Option<String>,
  pub epoch: Option<String>,
  pub idSensor: Option<String>,
  pub origSensorId: Option<String>,
  pub pos: Option<Vec<String>>,
  pub vel: Option<Vec<String>>,
  pub accel: Option<Vec<String>>,
  pub course: f64,
  pub spd: f64,
  pub referenceFrame: Option<String>,
  pub cov: Option<Vec<String>>,
  pub covReferenceFrame: Option<String>,
  pub vectorLat: f64,
  pub vectorLon: f64,
  pub vectorAlt: f64,
  pub confidence: i32,
  pub status: Option<String>,
  pub timeSource: Option<String>,
  pub quat: Option<Vec<String>>,
  pub flightAz: f64,
}
impl Default for MissileTrackVector_FullT {
  fn default() -> Self {
    Self {
      type_: None,
      object: None,
      epoch: None,
      idSensor: None,
      origSensorId: None,
      pos: None,
      vel: None,
      accel: None,
      course: 0.0,
      spd: 0.0,
      referenceFrame: None,
      cov: None,
      covReferenceFrame: None,
      vectorLat: 0.0,
      vectorLon: 0.0,
      vectorAlt: 0.0,
      confidence: 0,
      status: None,
      timeSource: None,
      quat: None,
      flightAz: 0.0,
    }
  }
}
impl MissileTrackVector_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MissileTrackVector_Full<'b>> {
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let object = self.object.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let epoch = self.epoch.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor = self.idSensor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId = self.origSensorId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pos = self.pos.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let vel = self.vel.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let accel = self.accel.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let course = self.course;
    let spd = self.spd;
    let referenceFrame = self.referenceFrame.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let cov = self.cov.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let covReferenceFrame = self.covReferenceFrame.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let vectorLat = self.vectorLat;
    let vectorLon = self.vectorLon;
    let vectorAlt = self.vectorAlt;
    let confidence = self.confidence;
    let status = self.status.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let timeSource = self.timeSource.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let quat = self.quat.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let flightAz = self.flightAz;
    MissileTrackVector_Full::create(_fbb, &MissileTrackVector_FullArgs{
      type_,
      object,
      epoch,
      idSensor,
      origSensorId,
      pos,
      vel,
      accel,
      course,
      spd,
      referenceFrame,
      cov,
      covReferenceFrame,
      vectorLat,
      vectorLon,
      vectorAlt,
      confidence,
      status,
      timeSource,
      quat,
      flightAz,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `MissileTrackVector_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_missile_track_vector_full_unchecked`.
pub fn root_as_missile_track_vector_full(buf: &[u8]) -> Result<MissileTrackVector_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MissileTrackVector_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MissileTrackVector_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_missile_track_vector_full_unchecked`.
pub fn size_prefixed_root_as_missile_track_vector_full(buf: &[u8]) -> Result<MissileTrackVector_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MissileTrackVector_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MissileTrackVector_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_missile_track_vector_full_unchecked`.
pub fn root_as_missile_track_vector_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MissileTrackVector_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MissileTrackVector_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MissileTrackVector_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_missile_track_vector_full_unchecked`.
pub fn size_prefixed_root_as_missile_track_vector_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MissileTrackVector_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MissileTrackVector_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MissileTrackVector_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MissileTrackVector_Full`.
pub unsafe fn root_as_missile_track_vector_full_unchecked(buf: &[u8]) -> MissileTrackVector_Full {
  flatbuffers::root_unchecked::<MissileTrackVector_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MissileTrackVector_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MissileTrackVector_Full`.
pub unsafe fn size_prefixed_root_as_missile_track_vector_full_unchecked(buf: &[u8]) -> MissileTrackVector_Full {
  flatbuffers::size_prefixed_root_unchecked::<MissileTrackVector_Full>(buf)
}
pub const MISSILE_TRACK_VECTOR_FULL_IDENTIFIER: &str = "MISS";

#[inline]
pub fn missile_track_vector_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MISSILE_TRACK_VECTOR_FULL_IDENTIFIER, false)
}

#[inline]
pub fn missile_track_vector_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MISSILE_TRACK_VECTOR_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_missile_track_vector_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<MissileTrackVector_Full<'a>>) {
  fbb.finish(root, Some(MISSILE_TRACK_VECTOR_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_missile_track_vector_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<MissileTrackVector_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(MISSILE_TRACK_VECTOR_FULL_IDENTIFIER));
}
