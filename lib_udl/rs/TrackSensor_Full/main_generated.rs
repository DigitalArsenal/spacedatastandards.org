// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TRACK_SENSOR_FULL_SENSOR_FOVTYPE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TRACK_SENSOR_FULL_SENSOR_FOVTYPE_ENUM: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRACK_SENSOR_FULL_SENSOR_FOVTYPE_ENUM: [TrackSensor_Full_sensorFOVType_Enum; 5] = [
  TrackSensor_Full_sensorFOVType_Enum::BUTTERFLY,
  TrackSensor_Full_sensorFOVType_Enum::CONE_ANGULAR,
  TrackSensor_Full_sensorFOVType_Enum::CONE_DISTANCE,
  TrackSensor_Full_sensorFOVType_Enum::HORIZON_TO_HORIZON,
  TrackSensor_Full_sensorFOVType_Enum::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TrackSensor_Full_sensorFOVType_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl TrackSensor_Full_sensorFOVType_Enum {
  /// No description available.
  pub const BUTTERFLY: Self = Self(0);
  /// No description available.
  pub const CONE_ANGULAR: Self = Self(1);
  /// No description available.
  pub const CONE_DISTANCE: Self = Self(2);
  /// No description available.
  pub const HORIZON_TO_HORIZON: Self = Self(3);
  /// No description available.
  pub const UNKNOWN: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BUTTERFLY,
    Self::CONE_ANGULAR,
    Self::CONE_DISTANCE,
    Self::HORIZON_TO_HORIZON,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::BUTTERFLY => Some("BUTTERFLY"),
      Self::CONE_ANGULAR => Some("CONE_ANGULAR"),
      Self::CONE_DISTANCE => Some("CONE_DISTANCE"),
      Self::HORIZON_TO_HORIZON => Some("HORIZON_TO_HORIZON"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TrackSensor_Full_sensorFOVType_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TrackSensor_Full_sensorFOVType_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TrackSensor_Full_sensorFOVType_Enum {
    type Output = TrackSensor_Full_sensorFOVType_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TrackSensor_Full_sensorFOVType_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TrackSensor_Full_sensorFOVType_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TrackSensor_Full_sensorFOVType_Enum {}
pub enum TrackSensor_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Schema for Track Sensor data.
pub struct TrackSensor_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TrackSensor_Full<'a> {
  type Inner = TrackSensor_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TrackSensor_Full<'a> {
  pub const VT_RANGE: flatbuffers::VOffsetT = 4;
  pub const VT_AZ: flatbuffers::VOffsetT = 6;
  pub const VT_SENSORNUMBER: flatbuffers::VOffsetT = 8;
  pub const VT_SENSORNAME: flatbuffers::VOffsetT = 10;
  pub const VT_MISSIONNUMBER: flatbuffers::VOffsetT = 12;
  pub const VT_MINRANGELIMIT: flatbuffers::VOffsetT = 14;
  pub const VT_SENSORFOVTYPE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TrackSensor_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TrackSensor_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<TrackSensor_Full<'bldr>> {
    let mut builder = TrackSensor_FullBuilder::new(_fbb);
    builder.add_minRangeLimit(args.minRangeLimit);
    builder.add_az(args.az);
    builder.add_range(args.range);
    if let Some(x) = args.missionNumber { builder.add_missionNumber(x); }
    if let Some(x) = args.sensorName { builder.add_sensorName(x); }
    builder.add_sensorNumber(args.sensorNumber);
    builder.add_sensorFOVType(args.sensorFOVType);
    builder.finish()
  }

  pub fn unpack(&self) -> TrackSensor_FullT {
    let range = self.range();
    let az = self.az();
    let sensorNumber = self.sensorNumber();
    let sensorName = self.sensorName().map(|x| {
      x.to_string()
    });
    let missionNumber = self.missionNumber().map(|x| {
      x.to_string()
    });
    let minRangeLimit = self.minRangeLimit();
    let sensorFOVType = self.sensorFOVType();
    TrackSensor_FullT {
      range,
      az,
      sensorNumber,
      sensorName,
      missionNumber,
      minRangeLimit,
      sensorFOVType,
    }
  }

  /// The track object range from the observing sensor, in kilometers.
  /// Example: /// Example: 4023.95
  /// Constraints: No constraints specified.
  #[inline]
  pub fn range(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackSensor_Full::VT_RANGE, Some(0.0)).unwrap()}
  }
  /// The observing sensor azimuth angle, in degrees and topocentric frame.
  /// Example: /// Example: 90
  /// Constraints: No constraints specified.
  #[inline]
  pub fn az(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackSensor_Full::VT_AZ, Some(0.0)).unwrap()}
  }
  /// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
  /// Example: /// Example: 1234
  /// Constraints: No constraints specified.
  #[inline]
  pub fn sensorNumber(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TrackSensor_Full::VT_SENSORNUMBER, Some(0)).unwrap()}
  }
  /// Unique name of this sensor.
  /// Example: /// Example: SENSOR_NAME
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn sensorName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackSensor_Full::VT_SENSORNAME, None)}
  }
  /// The mission number which produced this track observation.
  /// Example: /// Example: Example Mission
  /// Constraints: Minimum length = 0, Maximum length = 128
  #[inline]
  pub fn missionNumber(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackSensor_Full::VT_MISSIONNUMBER, None)}
  }
  /// Minimum range measurement capability of the sensor, in kilometers.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn minRangeLimit(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackSensor_Full::VT_MINRANGELIMIT, Some(0.0)).unwrap()}
  }
  /// The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
  /// Example: /// Example: UNKNOWN
  /// Constraints: Minimum length = 0, Maximum length = 24
  #[inline]
  pub fn sensorFOVType(&self) -> TrackSensor_Full_sensorFOVType_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TrackSensor_Full_sensorFOVType_Enum>(TrackSensor_Full::VT_SENSORFOVTYPE, Some(TrackSensor_Full_sensorFOVType_Enum::BUTTERFLY)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TrackSensor_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("range", Self::VT_RANGE, false)?
     .visit_field::<f64>("az", Self::VT_AZ, false)?
     .visit_field::<i32>("sensorNumber", Self::VT_SENSORNUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sensorName", Self::VT_SENSORNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("missionNumber", Self::VT_MISSIONNUMBER, false)?
     .visit_field::<f64>("minRangeLimit", Self::VT_MINRANGELIMIT, false)?
     .visit_field::<TrackSensor_Full_sensorFOVType_Enum>("sensorFOVType", Self::VT_SENSORFOVTYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct TrackSensor_FullArgs<'a> {
    pub range: f64,
    pub az: f64,
    pub sensorNumber: i32,
    pub sensorName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub missionNumber: Option<flatbuffers::WIPOffset<&'a str>>,
    pub minRangeLimit: f64,
    pub sensorFOVType: TrackSensor_Full_sensorFOVType_Enum,
}
impl<'a> Default for TrackSensor_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    TrackSensor_FullArgs {
      range: 0.0,
      az: 0.0,
      sensorNumber: 0,
      sensorName: None,
      missionNumber: None,
      minRangeLimit: 0.0,
      sensorFOVType: TrackSensor_Full_sensorFOVType_Enum::BUTTERFLY,
    }
  }
}

pub struct TrackSensor_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TrackSensor_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_range(&mut self, range: f64) {
    self.fbb_.push_slot::<f64>(TrackSensor_Full::VT_RANGE, range, 0.0);
  }
  #[inline]
  pub fn add_az(&mut self, az: f64) {
    self.fbb_.push_slot::<f64>(TrackSensor_Full::VT_AZ, az, 0.0);
  }
  #[inline]
  pub fn add_sensorNumber(&mut self, sensorNumber: i32) {
    self.fbb_.push_slot::<i32>(TrackSensor_Full::VT_SENSORNUMBER, sensorNumber, 0);
  }
  #[inline]
  pub fn add_sensorName(&mut self, sensorName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackSensor_Full::VT_SENSORNAME, sensorName);
  }
  #[inline]
  pub fn add_missionNumber(&mut self, missionNumber: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackSensor_Full::VT_MISSIONNUMBER, missionNumber);
  }
  #[inline]
  pub fn add_minRangeLimit(&mut self, minRangeLimit: f64) {
    self.fbb_.push_slot::<f64>(TrackSensor_Full::VT_MINRANGELIMIT, minRangeLimit, 0.0);
  }
  #[inline]
  pub fn add_sensorFOVType(&mut self, sensorFOVType: TrackSensor_Full_sensorFOVType_Enum) {
    self.fbb_.push_slot::<TrackSensor_Full_sensorFOVType_Enum>(TrackSensor_Full::VT_SENSORFOVTYPE, sensorFOVType, TrackSensor_Full_sensorFOVType_Enum::BUTTERFLY);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TrackSensor_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TrackSensor_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TrackSensor_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TrackSensor_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TrackSensor_Full");
      ds.field("range", &self.range());
      ds.field("az", &self.az());
      ds.field("sensorNumber", &self.sensorNumber());
      ds.field("sensorName", &self.sensorName());
      ds.field("missionNumber", &self.missionNumber());
      ds.field("minRangeLimit", &self.minRangeLimit());
      ds.field("sensorFOVType", &self.sensorFOVType());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TrackSensor_FullT {
  pub range: f64,
  pub az: f64,
  pub sensorNumber: i32,
  pub sensorName: Option<String>,
  pub missionNumber: Option<String>,
  pub minRangeLimit: f64,
  pub sensorFOVType: TrackSensor_Full_sensorFOVType_Enum,
}
impl Default for TrackSensor_FullT {
  fn default() -> Self {
    Self {
      range: 0.0,
      az: 0.0,
      sensorNumber: 0,
      sensorName: None,
      missionNumber: None,
      minRangeLimit: 0.0,
      sensorFOVType: TrackSensor_Full_sensorFOVType_Enum::BUTTERFLY,
    }
  }
}
impl TrackSensor_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TrackSensor_Full<'b>> {
    let range = self.range;
    let az = self.az;
    let sensorNumber = self.sensorNumber;
    let sensorName = self.sensorName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let missionNumber = self.missionNumber.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let minRangeLimit = self.minRangeLimit;
    let sensorFOVType = self.sensorFOVType;
    TrackSensor_Full::create(_fbb, &TrackSensor_FullArgs{
      range,
      az,
      sensorNumber,
      sensorName,
      missionNumber,
      minRangeLimit,
      sensorFOVType,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TrackSensor_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_track_sensor_full_unchecked`.
pub fn root_as_track_sensor_full(buf: &[u8]) -> Result<TrackSensor_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TrackSensor_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TrackSensor_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_track_sensor_full_unchecked`.
pub fn size_prefixed_root_as_track_sensor_full(buf: &[u8]) -> Result<TrackSensor_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TrackSensor_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TrackSensor_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_track_sensor_full_unchecked`.
pub fn root_as_track_sensor_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TrackSensor_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TrackSensor_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TrackSensor_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_track_sensor_full_unchecked`.
pub fn size_prefixed_root_as_track_sensor_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TrackSensor_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TrackSensor_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TrackSensor_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TrackSensor_Full`.
pub unsafe fn root_as_track_sensor_full_unchecked(buf: &[u8]) -> TrackSensor_Full {
  flatbuffers::root_unchecked::<TrackSensor_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TrackSensor_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TrackSensor_Full`.
pub unsafe fn size_prefixed_root_as_track_sensor_full_unchecked(buf: &[u8]) -> TrackSensor_Full {
  flatbuffers::size_prefixed_root_unchecked::<TrackSensor_Full>(buf)
}
pub const TRACK_SENSOR_FULL_IDENTIFIER: &str = "TRAC";

#[inline]
pub fn track_sensor_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TRACK_SENSOR_FULL_IDENTIFIER, false)
}

#[inline]
pub fn track_sensor_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TRACK_SENSOR_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_track_sensor_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<TrackSensor_Full<'a>>) {
  fbb.finish(root, Some(TRACK_SENSOR_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_track_sensor_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<TrackSensor_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(TRACK_SENSOR_FULL_IDENTIFIER));
}
