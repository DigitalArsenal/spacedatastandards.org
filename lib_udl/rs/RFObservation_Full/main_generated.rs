// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RFOBSERVATION_FULL_POLARITY_TYPE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RFOBSERVATION_FULL_POLARITY_TYPE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RFOBSERVATION_FULL_POLARITY_TYPE_ENUM: [RFObservation_Full_polarityType_Enum; 4] = [
  RFObservation_Full_polarityType_Enum::H,
  RFObservation_Full_polarityType_Enum::V,
  RFObservation_Full_polarityType_Enum::R,
  RFObservation_Full_polarityType_Enum::L,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RFObservation_Full_polarityType_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl RFObservation_Full_polarityType_Enum {
  /// No description available.
  pub const H: Self = Self(0);
  /// No description available.
  pub const V: Self = Self(1);
  /// No description available.
  pub const R: Self = Self(2);
  /// No description available.
  pub const L: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::H,
    Self::V,
    Self::R,
    Self::L,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::H => Some("H"),
      Self::V => Some("V"),
      Self::R => Some("R"),
      Self::L => Some("L"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RFObservation_Full_polarityType_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RFObservation_Full_polarityType_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RFObservation_Full_polarityType_Enum {
    type Output = RFObservation_Full_polarityType_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RFObservation_Full_polarityType_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RFObservation_Full_polarityType_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RFObservation_Full_polarityType_Enum {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RFOBSERVATION_FULL_DATA_MODE_ENUM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RFOBSERVATION_FULL_DATA_MODE_ENUM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RFOBSERVATION_FULL_DATA_MODE_ENUM: [RFObservation_Full_dataMode_Enum; 4] = [
  RFObservation_Full_dataMode_Enum::REAL,
  RFObservation_Full_dataMode_Enum::TEST,
  RFObservation_Full_dataMode_Enum::SIMULATED,
  RFObservation_Full_dataMode_Enum::EXERCISE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RFObservation_Full_dataMode_Enum(pub i8);
#[allow(non_upper_case_globals)]
impl RFObservation_Full_dataMode_Enum {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  pub const REAL: Self = Self(0);
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  pub const TEST: Self = Self(1);
  /// Synthetic data generated by a model to mimic real-world datasets.
  pub const SIMULATED: Self = Self(2);
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  pub const EXERCISE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REAL,
    Self::TEST,
    Self::SIMULATED,
    Self::EXERCISE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REAL => Some("REAL"),
      Self::TEST => Some("TEST"),
      Self::SIMULATED => Some("SIMULATED"),
      Self::EXERCISE => Some("EXERCISE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RFObservation_Full_dataMode_Enum {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RFObservation_Full_dataMode_Enum {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RFObservation_Full_dataMode_Enum {
    type Output = RFObservation_Full_dataMode_Enum;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RFObservation_Full_dataMode_Enum {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RFObservation_Full_dataMode_Enum {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RFObservation_Full_dataMode_Enum {}
pub enum RFObservation_FullOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Model representation of observation data for active/passive radio frequency (RF) based sensor phenomenologies. J2000 is the preferred coordinate frame for all observations, but in some cases observations may be in another frame depending on the provider. Please see the 'Discover' tab in the storefront to confirm coordinate frames by data provider. RF observations include several optional ordered arrays which are used to provide detailed information on recorded signals such as power spectral density lists or active signals (code taps/fills, etc). In these cases, the sizes of the arrays must match and can be assumed to have consistent indexing across arrays (e.g. powers[0] is the measured power at frequencies[0]).
pub struct RFObservation_Full<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RFObservation_Full<'a> {
  type Inner = RFObservation_Full<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RFObservation_Full<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATIONMARKING: flatbuffers::VOffsetT = 6;
  pub const VT_OBTIME: flatbuffers::VOffsetT = 8;
  pub const VT_IDONORBIT: flatbuffers::VOffsetT = 10;
  pub const VT_IDSENSOR: flatbuffers::VOffsetT = 12;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 14;
  pub const VT_SATNO: flatbuffers::VOffsetT = 16;
  pub const VT_TASKID: flatbuffers::VOffsetT = 18;
  pub const VT_TRANSACTIONID: flatbuffers::VOffsetT = 20;
  pub const VT_TRACKID: flatbuffers::VOffsetT = 22;
  pub const VT_ORIGOBJECTID: flatbuffers::VOffsetT = 24;
  pub const VT_ORIGSENSORID: flatbuffers::VOffsetT = 26;
  pub const VT_UCT: flatbuffers::VOffsetT = 28;
  pub const VT_TRANSPONDER: flatbuffers::VOffsetT = 30;
  pub const VT_AZIMUTH: flatbuffers::VOffsetT = 32;
  pub const VT_AZIMUTHUNC: flatbuffers::VOffsetT = 34;
  pub const VT_AZIMUTHRATE: flatbuffers::VOffsetT = 36;
  pub const VT_ELEVATION: flatbuffers::VOffsetT = 38;
  pub const VT_ELEVATIONUNC: flatbuffers::VOffsetT = 40;
  pub const VT_ELEVATIONRATE: flatbuffers::VOffsetT = 42;
  pub const VT_RANGE: flatbuffers::VOffsetT = 44;
  pub const VT_RANGEUNC: flatbuffers::VOffsetT = 46;
  pub const VT_RANGERATE: flatbuffers::VOffsetT = 48;
  pub const VT_RANGERATEUNC: flatbuffers::VOffsetT = 50;
  pub const VT_TRACKRANGE: flatbuffers::VOffsetT = 52;
  pub const VT_SENLAT: flatbuffers::VOffsetT = 54;
  pub const VT_SENLON: flatbuffers::VOffsetT = 56;
  pub const VT_SENALT: flatbuffers::VOffsetT = 58;
  pub const VT_ELNOT: flatbuffers::VOffsetT = 60;
  pub const VT_FREQUENCY: flatbuffers::VOffsetT = 62;
  pub const VT_NOMINALFREQUENCY: flatbuffers::VOffsetT = 64;
  pub const VT_STARTFREQUENCY: flatbuffers::VOffsetT = 66;
  pub const VT_ENDFREQUENCY: flatbuffers::VOffsetT = 68;
  pub const VT_RELATIVECARRIERPOWER: flatbuffers::VOffsetT = 70;
  pub const VT_SPECTRUMANALYZERPOWER: flatbuffers::VOffsetT = 72;
  pub const VT_RELATIVENOISEFLOOR: flatbuffers::VOffsetT = 74;
  pub const VT_REFERENCELEVEL: flatbuffers::VOffsetT = 76;
  pub const VT_PGRI: flatbuffers::VOffsetT = 78;
  pub const VT_CONFIDENCE: flatbuffers::VOffsetT = 80;
  pub const VT_INCOMING: flatbuffers::VOffsetT = 82;
  pub const VT_SWITCHPOINT: flatbuffers::VOffsetT = 84;
  pub const VT_BAUDRATE: flatbuffers::VOffsetT = 86;
  pub const VT_SNR: flatbuffers::VOffsetT = 88;
  pub const VT_NOMINALSNR: flatbuffers::VOffsetT = 90;
  pub const VT_POLARITY: flatbuffers::VOffsetT = 92;
  pub const VT_POLARITYTYPE: flatbuffers::VOffsetT = 94;
  pub const VT_CHANNEL: flatbuffers::VOffsetT = 96;
  pub const VT_POWEROVERNOISE: flatbuffers::VOffsetT = 98;
  pub const VT_NOMINALPOWEROVERNOISE: flatbuffers::VOffsetT = 100;
  pub const VT_BANDWIDTH: flatbuffers::VOffsetT = 102;
  pub const VT_NOMINALBANDWIDTH: flatbuffers::VOffsetT = 104;
  pub const VT_RESOLUTIONBANDWIDTH: flatbuffers::VOffsetT = 106;
  pub const VT_VIDEOBANDWIDTH: flatbuffers::VOffsetT = 108;
  pub const VT_EIRP: flatbuffers::VOffsetT = 110;
  pub const VT_NOMINALEIRP: flatbuffers::VOffsetT = 112;
  pub const VT_MINPSD: flatbuffers::VOffsetT = 114;
  pub const VT_MAXPSD: flatbuffers::VOffsetT = 116;
  pub const VT_FREQUENCYSHIFT: flatbuffers::VOffsetT = 118;
  pub const VT_PEAK: flatbuffers::VOffsetT = 120;
  pub const VT_ANTENNANAME: flatbuffers::VOffsetT = 122;
  pub const VT_DETECTIONSTATUS: flatbuffers::VOffsetT = 124;
  pub const VT_COLLECTIONMODE: flatbuffers::VOffsetT = 126;
  pub const VT_RAWFILEURI: flatbuffers::VOffsetT = 128;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 130;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 132;
  pub const VT_DATAMODE: flatbuffers::VOffsetT = 134;
  pub const VT_TAGS: flatbuffers::VOffsetT = 136;
  pub const VT_CREATEDAT: flatbuffers::VOffsetT = 138;
  pub const VT_CREATEDBY: flatbuffers::VOffsetT = 140;
  pub const VT_NOISEPWRDENSITY: flatbuffers::VOffsetT = 142;
  pub const VT_CARRIERSTANDARD: flatbuffers::VOffsetT = 144;
  pub const VT_MODULATION: flatbuffers::VOffsetT = 146;
  pub const VT_INNERCODINGRATE: flatbuffers::VOffsetT = 148;
  pub const VT_OUTERCODINGRATE: flatbuffers::VOffsetT = 150;
  pub const VT_TRANSMITFILTERTYPE: flatbuffers::VOffsetT = 152;
  pub const VT_TRANSMITFILTERROLLOFF: flatbuffers::VOffsetT = 154;
  pub const VT_SYMBOLTONOISERATIO: flatbuffers::VOffsetT = 156;
  pub const VT_BITERRORRATE: flatbuffers::VOffsetT = 158;
  pub const VT_ORIGNETWORK: flatbuffers::VOffsetT = 160;
  pub const VT_SOURCEDL: flatbuffers::VOffsetT = 162;
  pub const VT_ONORBIT: flatbuffers::VOffsetT = 164;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 166;
  pub const VT_URL: flatbuffers::VOffsetT = 168;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RFObservation_Full { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RFObservation_FullArgs<'args>
  ) -> flatbuffers::WIPOffset<RFObservation_Full<'bldr>> {
    let mut builder = RFObservation_FullBuilder::new(_fbb);
    builder.add_bitErrorRate(args.bitErrorRate);
    builder.add_symbolToNoiseRatio(args.symbolToNoiseRatio);
    builder.add_transmitFilterRollOff(args.transmitFilterRollOff);
    builder.add_noisePwrDensity(args.noisePwrDensity);
    builder.add_frequencyShift(args.frequencyShift);
    builder.add_maxPSD(args.maxPSD);
    builder.add_minPSD(args.minPSD);
    builder.add_nominalEirp(args.nominalEirp);
    builder.add_eirp(args.eirp);
    builder.add_videoBandwidth(args.videoBandwidth);
    builder.add_resolutionBandwidth(args.resolutionBandwidth);
    builder.add_nominalBandwidth(args.nominalBandwidth);
    builder.add_bandwidth(args.bandwidth);
    builder.add_nominalPowerOverNoise(args.nominalPowerOverNoise);
    builder.add_powerOverNoise(args.powerOverNoise);
    builder.add_polarity(args.polarity);
    builder.add_nominalSnr(args.nominalSnr);
    builder.add_snr(args.snr);
    builder.add_baudRate(args.baudRate);
    builder.add_confidence(args.confidence);
    builder.add_pgri(args.pgri);
    builder.add_referenceLevel(args.referenceLevel);
    builder.add_relativeNoiseFloor(args.relativeNoiseFloor);
    builder.add_spectrumAnalyzerPower(args.spectrumAnalyzerPower);
    builder.add_relativeCarrierPower(args.relativeCarrierPower);
    builder.add_endFrequency(args.endFrequency);
    builder.add_startFrequency(args.startFrequency);
    builder.add_nominalFrequency(args.nominalFrequency);
    builder.add_frequency(args.frequency);
    builder.add_senalt(args.senalt);
    builder.add_senlon(args.senlon);
    builder.add_senlat(args.senlat);
    builder.add_trackRange(args.trackRange);
    builder.add_rangeRateUnc(args.rangeRateUnc);
    builder.add_rangeRate(args.rangeRate);
    builder.add_rangeUnc(args.rangeUnc);
    builder.add_range(args.range);
    builder.add_elevationRate(args.elevationRate);
    builder.add_elevationUnc(args.elevationUnc);
    builder.add_elevation(args.elevation);
    builder.add_azimuthRate(args.azimuthRate);
    builder.add_azimuthUnc(args.azimuthUnc);
    builder.add_azimuth(args.azimuth);
    if let Some(x) = args.url { builder.add_url(x); }
    if let Some(x) = args.descriptor { builder.add_descriptor(x); }
    if let Some(x) = args.onOrbit { builder.add_onOrbit(x); }
    if let Some(x) = args.sourceDL { builder.add_sourceDL(x); }
    if let Some(x) = args.origNetwork { builder.add_origNetwork(x); }
    if let Some(x) = args.transmitFilterType { builder.add_transmitFilterType(x); }
    builder.add_outerCodingRate(args.outerCodingRate);
    builder.add_innerCodingRate(args.innerCodingRate);
    if let Some(x) = args.modulation { builder.add_modulation(x); }
    if let Some(x) = args.carrierStandard { builder.add_carrierStandard(x); }
    if let Some(x) = args.createdBy { builder.add_createdBy(x); }
    if let Some(x) = args.createdAt { builder.add_createdAt(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.rawFileURI { builder.add_rawFileURI(x); }
    if let Some(x) = args.collectionMode { builder.add_collectionMode(x); }
    if let Some(x) = args.detectionStatus { builder.add_detectionStatus(x); }
    if let Some(x) = args.antennaName { builder.add_antennaName(x); }
    builder.add_channel(args.channel);
    builder.add_switchPoint(args.switchPoint);
    if let Some(x) = args.elnot { builder.add_elnot(x); }
    if let Some(x) = args.transponder { builder.add_transponder(x); }
    if let Some(x) = args.origSensorId { builder.add_origSensorId(x); }
    if let Some(x) = args.origObjectId { builder.add_origObjectId(x); }
    if let Some(x) = args.trackId { builder.add_trackId(x); }
    if let Some(x) = args.transactionId { builder.add_transactionId(x); }
    if let Some(x) = args.taskId { builder.add_taskId(x); }
    builder.add_satNo(args.satNo);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.idSensor { builder.add_idSensor(x); }
    if let Some(x) = args.idOnOrbit { builder.add_idOnOrbit(x); }
    if let Some(x) = args.obTime { builder.add_obTime(x); }
    if let Some(x) = args.classificationMarking { builder.add_classificationMarking(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_dataMode(args.dataMode);
    builder.add_peak(args.peak);
    builder.add_polarityType(args.polarityType);
    builder.add_incoming(args.incoming);
    builder.add_uct(args.uct);
    builder.finish()
  }

  pub fn unpack(&self) -> RFObservation_FullT {
    let id = self.id().map(|x| {
      x.to_string()
    });
    let classificationMarking = self.classificationMarking().map(|x| {
      x.to_string()
    });
    let obTime = self.obTime().map(|x| {
      x.to_string()
    });
    let idOnOrbit = self.idOnOrbit().map(|x| {
      x.to_string()
    });
    let idSensor = self.idSensor().map(|x| {
      x.to_string()
    });
    let type_ = self.type_().map(|x| {
      x.to_string()
    });
    let satNo = self.satNo();
    let taskId = self.taskId().map(|x| {
      x.to_string()
    });
    let transactionId = self.transactionId().map(|x| {
      x.to_string()
    });
    let trackId = self.trackId().map(|x| {
      x.to_string()
    });
    let origObjectId = self.origObjectId().map(|x| {
      x.to_string()
    });
    let origSensorId = self.origSensorId().map(|x| {
      x.to_string()
    });
    let uct = self.uct();
    let transponder = self.transponder().map(|x| {
      x.to_string()
    });
    let azimuth = self.azimuth();
    let azimuthUnc = self.azimuthUnc();
    let azimuthRate = self.azimuthRate();
    let elevation = self.elevation();
    let elevationUnc = self.elevationUnc();
    let elevationRate = self.elevationRate();
    let range = self.range();
    let rangeUnc = self.rangeUnc();
    let rangeRate = self.rangeRate();
    let rangeRateUnc = self.rangeRateUnc();
    let trackRange = self.trackRange();
    let senlat = self.senlat();
    let senlon = self.senlon();
    let senalt = self.senalt();
    let elnot = self.elnot().map(|x| {
      x.to_string()
    });
    let frequency = self.frequency();
    let nominalFrequency = self.nominalFrequency();
    let startFrequency = self.startFrequency();
    let endFrequency = self.endFrequency();
    let relativeCarrierPower = self.relativeCarrierPower();
    let spectrumAnalyzerPower = self.spectrumAnalyzerPower();
    let relativeNoiseFloor = self.relativeNoiseFloor();
    let referenceLevel = self.referenceLevel();
    let pgri = self.pgri();
    let confidence = self.confidence();
    let incoming = self.incoming();
    let switchPoint = self.switchPoint();
    let baudRate = self.baudRate();
    let snr = self.snr();
    let nominalSnr = self.nominalSnr();
    let polarity = self.polarity();
    let polarityType = self.polarityType();
    let channel = self.channel();
    let powerOverNoise = self.powerOverNoise();
    let nominalPowerOverNoise = self.nominalPowerOverNoise();
    let bandwidth = self.bandwidth();
    let nominalBandwidth = self.nominalBandwidth();
    let resolutionBandwidth = self.resolutionBandwidth();
    let videoBandwidth = self.videoBandwidth();
    let eirp = self.eirp();
    let nominalEirp = self.nominalEirp();
    let minPSD = self.minPSD();
    let maxPSD = self.maxPSD();
    let frequencyShift = self.frequencyShift();
    let peak = self.peak();
    let antennaName = self.antennaName().map(|x| {
      x.to_string()
    });
    let detectionStatus = self.detectionStatus().map(|x| {
      x.to_string()
    });
    let collectionMode = self.collectionMode().map(|x| {
      x.to_string()
    });
    let rawFileURI = self.rawFileURI().map(|x| {
      x.to_string()
    });
    let source = self.source().map(|x| {
      x.to_string()
    });
    let origin = self.origin().map(|x| {
      x.to_string()
    });
    let dataMode = self.dataMode();
    let tags = self.tags().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let createdAt = self.createdAt().map(|x| {
      x.to_string()
    });
    let createdBy = self.createdBy().map(|x| {
      x.to_string()
    });
    let noisePwrDensity = self.noisePwrDensity();
    let carrierStandard = self.carrierStandard().map(|x| {
      x.to_string()
    });
    let modulation = self.modulation().map(|x| {
      x.to_string()
    });
    let innerCodingRate = self.innerCodingRate();
    let outerCodingRate = self.outerCodingRate();
    let transmitFilterType = self.transmitFilterType().map(|x| {
      x.to_string()
    });
    let transmitFilterRollOff = self.transmitFilterRollOff();
    let symbolToNoiseRatio = self.symbolToNoiseRatio();
    let bitErrorRate = self.bitErrorRate();
    let origNetwork = self.origNetwork().map(|x| {
      x.to_string()
    });
    let sourceDL = self.sourceDL().map(|x| {
      x.to_string()
    });
    let onOrbit = self.onOrbit().map(|x| {
      x.to_string()
    });
    let descriptor = self.descriptor().map(|x| {
      x.to_string()
    });
    let url = self.url().map(|x| {
      x.to_string()
    });
    RFObservation_FullT {
      id,
      classificationMarking,
      obTime,
      idOnOrbit,
      idSensor,
      type_,
      satNo,
      taskId,
      transactionId,
      trackId,
      origObjectId,
      origSensorId,
      uct,
      transponder,
      azimuth,
      azimuthUnc,
      azimuthRate,
      elevation,
      elevationUnc,
      elevationRate,
      range,
      rangeUnc,
      rangeRate,
      rangeRateUnc,
      trackRange,
      senlat,
      senlon,
      senalt,
      elnot,
      frequency,
      nominalFrequency,
      startFrequency,
      endFrequency,
      relativeCarrierPower,
      spectrumAnalyzerPower,
      relativeNoiseFloor,
      referenceLevel,
      pgri,
      confidence,
      incoming,
      switchPoint,
      baudRate,
      snr,
      nominalSnr,
      polarity,
      polarityType,
      channel,
      powerOverNoise,
      nominalPowerOverNoise,
      bandwidth,
      nominalBandwidth,
      resolutionBandwidth,
      videoBandwidth,
      eirp,
      nominalEirp,
      minPSD,
      maxPSD,
      frequencyShift,
      peak,
      antennaName,
      detectionStatus,
      collectionMode,
      rawFileURI,
      source,
      origin,
      dataMode,
      tags,
      createdAt,
      createdBy,
      noisePwrDensity,
      carrierStandard,
      modulation,
      innerCodingRate,
      outerCodingRate,
      transmitFilterType,
      transmitFilterRollOff,
      symbolToNoiseRatio,
      bitErrorRate,
      origNetwork,
      sourceDL,
      onOrbit,
      descriptor,
      url,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: RFOBSERVATION-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  #[inline]
  pub fn classificationMarking(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_CLASSIFICATIONMARKING, None)}
  }
  /// Ob detection time in ISO 8601 UTC with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn obTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_OBTIME, None)}
  }
  /// Unique identifier of the target on-orbit object, if correlated.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idOnOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_IDONORBIT, None)}
  }
  /// Unique identifier of the reporting sensor.
  /// Example: /// Example: SENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn idSensor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_IDSENSOR, None)}
  }
  /// Type of RF ob (e.g. RF, RF-SOSI, PSD, RFI, SPOOF, etc).
  /// Example: /// Example: RF
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_TYPE_, None)}
  }
  /// Satellite/Catalog number of the target on-orbit object.
  /// Example: /// Example: 32258
  /// Constraints: No constraints specified.
  #[inline]
  pub fn satNo(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RFObservation_Full::VT_SATNO, Some(0)).unwrap()}
  }
  /// Optional identifier to indicate the specific tasking which produced this observation.
  /// Example: /// Example: TASK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn taskId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_TASKID, None)}
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn transactionId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_TRANSACTIONID, None)}
  }
  /// Optional identifier of the track to which this observation belongs.
  /// Example: /// Example: TRACK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  #[inline]
  pub fn trackId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_TRACKID, None)}
  }
  /// Optional identifier provided by observation source to indicate the target onorbit object of this observation. This may be an internal identifier and not necessarily a valid satellite number.
  /// Example: /// Example: ORIG-OBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origObjectId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_ORIGOBJECTID, None)}
  }
  /// Optional identifier provided by observation source to indicate the sensor identifier which produced this observation. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIG-SENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origSensorId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_ORIGSENSORID, None)}
  }
  /// Boolean indicating this observation is part of an uncorrelated track or was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn uct(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RFObservation_Full::VT_UCT, Some(false)).unwrap()}
  }
  /// Optional identifier provided by observation source to indicate the transponder used for this measurement.
  /// Example: /// Example: TRANSPONDER-A
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn transponder(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_TRANSPONDER, None)}
  }
  /// azimuth angle in degrees and J2000 coordinate frame.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn azimuth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_AZIMUTH, Some(0.0)).unwrap()}
  }
  /// One sigma uncertainty in the azimuth angle measurement, in degrees.
  /// Example: /// Example: 2.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn azimuthUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_AZIMUTHUNC, Some(0.0)).unwrap()}
  }
  /// Rate of change of the azimuth in degrees per second.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn azimuthRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_AZIMUTHRATE, Some(0.0)).unwrap()}
  }
  /// elevation in degrees and J2000 coordinate frame.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevation(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_ELEVATION, Some(0.0)).unwrap()}
  }
  /// One sigma uncertainty in the elevation angle measurement, in degrees.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevationUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_ELEVATIONUNC, Some(0.0)).unwrap()}
  }
  /// Rate of change of the elevation in degrees per second.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn elevationRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_ELEVATIONRATE, Some(0.0)).unwrap()}
  }
  /// Target range in km.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn range(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_RANGE, Some(0.0)).unwrap()}
  }
  /// One sigma uncertainty in the range measurement, in kilometers.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rangeUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_RANGEUNC, Some(0.0)).unwrap()}
  }
  /// Rate of change of the range in km/sec.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rangeRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_RANGERATE, Some(0.0)).unwrap()}
  }
  /// One sigma uncertainty in the range rate measurement, in kilometers/second.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn rangeRateUnc(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_RANGERATEUNC, Some(0.0)).unwrap()}
  }
  /// Target track or apparent range in km.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn trackRange(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_TRACKRANGE, Some(0.0)).unwrap()}
  }
  /// Sensor WGS84 latitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.2
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlat(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_SENLAT, Some(0.0)).unwrap()}
  }
  /// Sensor WGS84 longitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 80.3
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senlon(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_SENLON, Some(0.0)).unwrap()}
  }
  /// Sensor altitude at obTime (if mobile/onorbit) in km. If null, can be obtained from sensor info.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn senalt(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_SENALT, Some(0.0)).unwrap()}
  }
  /// ELINT notation.
  /// Example: /// Example: Ex. ELINT
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn elnot(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_ELNOT, None)}
  }
  /// Center carrier frequency in Hz.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn frequency(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_FREQUENCY, Some(0.0)).unwrap()}
  }
  /// Nominal or expected center carrier frequency in Hz.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn nominalFrequency(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_NOMINALFREQUENCY, Some(0.0)).unwrap()}
  }
  /// Start carrier frequency in Hz.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn startFrequency(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_STARTFREQUENCY, Some(0.0)).unwrap()}
  }
  /// End carrier frequency in Hz.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn endFrequency(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_ENDFREQUENCY, Some(0.0)).unwrap()}
  }
  /// Measured power of the center carrier frequency in dBW.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn relativeCarrierPower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_RELATIVECARRIERPOWER, Some(0.0)).unwrap()}
  }
  /// Measured spectrum analyzer power of the center carrier frequency in dBW.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn spectrumAnalyzerPower(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_SPECTRUMANALYZERPOWER, Some(0.0)).unwrap()}
  }
  /// The measure of the signal created from the sum of all the noise sources and unwanted signals within the measurement system, in dBW.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn relativeNoiseFloor(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_RELATIVENOISEFLOOR, Some(0.0)).unwrap()}
  }
  /// Reference signal level, in dBW.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn referenceLevel(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_REFERENCELEVEL, Some(0.0)).unwrap()}
  }
  /// A pulse group repetition interval (PGRI) is a pulse train in which there are groups of closely spaced pulses separated by much longer times between these pulse groups.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn pgri(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_PGRI, Some(0.0)).unwrap()}
  }
  /// Confidence in the signal and its measurements and characterization.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn confidence(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_CONFIDENCE, Some(0.0)).unwrap()}
  }
  /// True if the signal is incoming, false if outgoing.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn incoming(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RFObservation_Full::VT_INCOMING, Some(false)).unwrap()}
  }
  /// Switch Point of the RFObservation record.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn switchPoint(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RFObservation_Full::VT_SWITCHPOINT, Some(0)).unwrap()}
  }
  /// Baud rate is the number of symbol changes, waveform changes, or signaling events, across the transmission medium per second.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn baudRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_BAUDRATE, Some(0.0)).unwrap()}
  }
  /// Signal to noise ratio, in dB.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn snr(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_SNR, Some(0.0)).unwrap()}
  }
  /// Nominal or expected signal to noise ratio, in dB.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn nominalSnr(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_NOMINALSNR, Some(0.0)).unwrap()}
  }
  /// The antenna pointing dependent polarizer angle, in degrees.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn polarity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_POLARITY, Some(0.0)).unwrap()}
  }
  /// Transponder polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the earth's surface.
  /// Example: /// Example: H
  /// Constraints: Minimum length = 0, Maximum length = 16
  #[inline]
  pub fn polarityType(&self) -> RFObservation_Full_polarityType_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RFObservation_Full_polarityType_Enum>(RFObservation_Full::VT_POLARITYTYPE, Some(RFObservation_Full_polarityType_Enum::H)).unwrap()}
  }
  /// Channel of the RFObservation record.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  #[inline]
  pub fn channel(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RFObservation_Full::VT_CHANNEL, Some(0)).unwrap()}
  }
  /// Measured carrier power over noise (dBW/Hz).
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn powerOverNoise(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_POWEROVERNOISE, Some(0.0)).unwrap()}
  }
  /// Expected carrier power over noise (dBW/Hz).
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn nominalPowerOverNoise(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_NOMINALPOWEROVERNOISE, Some(0.0)).unwrap()}
  }
  /// Measured bandwidth in Hz.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bandwidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_BANDWIDTH, Some(0.0)).unwrap()}
  }
  /// Expected bandwidth in Hz.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn nominalBandwidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_NOMINALBANDWIDTH, Some(0.0)).unwrap()}
  }
  /// Resolution bandwidth in Hz.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn resolutionBandwidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_RESOLUTIONBANDWIDTH, Some(0.0)).unwrap()}
  }
  /// Video bandwidth in Hz.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn videoBandwidth(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_VIDEOBANDWIDTH, Some(0.0)).unwrap()}
  }
  /// Measured Equivalent Isotopically Radiated Power in dBW.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn eirp(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_EIRP, Some(0.0)).unwrap()}
  }
  /// Expected Equivalent Isotopically Radiated Power in dBW.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn nominalEirp(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_NOMINALEIRP, Some(0.0)).unwrap()}
  }
  /// Minimum measured PSD value of the trace in dBW.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn minPSD(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_MINPSD, Some(0.0)).unwrap()}
  }
  /// Maximum measured PSD value of the trace in dBW.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn maxPSD(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_MAXPSD, Some(0.0)).unwrap()}
  }
  /// Frequency Shift of the RFObservation record.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn frequencyShift(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_FREQUENCYSHIFT, Some(0.0)).unwrap()}
  }
  /// Peak of the RFObservation record.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  #[inline]
  pub fn peak(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RFObservation_Full::VT_PEAK, Some(false)).unwrap()}
  }
  /// Antenna name of the RFObservation record.
  /// Example: /// Example: Antenna1
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn antennaName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_ANTENNANAME, None)}
  }
  /// Detection status (e.g. DETECTED, CARRIER_ACQUIRING, CARRIER_DETECTED, NOT_DETECTED, etc).
  /// Example: /// Example: DETECTED
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn detectionStatus(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_DETECTIONSTATUS, None)}
  }
  /// Collection mode (e.g. SURVEY, SPOT_SEARCH, NEIGHBORHOOD_WATCH, DIRECTED_SEARCH, MANUAL, etc).
  /// Example: /// Example: SURVEY
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn collectionMode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_COLLECTIONMODE, None)}
  }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  /// Example: /// Example: Example URI
  /// Constraints: Minimum length = 0, Maximum length = 256
  #[inline]
  pub fn rawFileURI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_RAWFILEURI, None)}
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_SOURCE, None)}
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn origin(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_ORIGIN, None)}
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn dataMode(&self) -> RFObservation_Full_dataMode_Enum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RFObservation_Full_dataMode_Enum>(RFObservation_Full::VT_DATAMODE, Some(RFObservation_Full_dataMode_Enum::REAL)).unwrap()}
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
  /// Constraints: No constraints specified.
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RFObservation_Full::VT_TAGS, None)}
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  #[inline]
  pub fn createdAt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_CREATEDAT, None)}
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  #[inline]
  pub fn createdBy(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_CREATEDBY, None)}
  }
  /// Noise power density, in dBW-Hz.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn noisePwrDensity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_NOISEPWRDENSITY, Some(0.0)).unwrap()}
  }
  /// Carrier standard (e.g. DVB-S2, 802.11g, etc.).
  /// Example: /// Example: DVB-S2
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn carrierStandard(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_CARRIERSTANDARD, None)}
  }
  /// Transponder modulation (e.g. Auto, QPSK, 8PSK, etc).
  /// Example: /// Example: Auto
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn modulation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_MODULATION, None)}
  }
  /// Inner forward error correction rate:  0 = Auto, 1 = 1/2, 2 = 2/3, 3 = 3/4, 4 = 5/6, 5 = 7/8, 6 = 8/9, 7 = 3/5, 8 = 4/5, 9 = 9/10, 15 = None.
  /// Example: /// Example: 7
  /// Constraints: No constraints specified.
  #[inline]
  pub fn innerCodingRate(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RFObservation_Full::VT_INNERCODINGRATE, Some(0)).unwrap()}
  }
  /// Outer forward error correction rate:  0 = Auto, 1 = 1/2, 2 = 2/3, 3 = 3/4, 4 = 5/6, 5 = 7/8, 6 = 8/9, 7 = 3/5, 8 = 4/5, 9 = 9/10, 15 = None.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  #[inline]
  pub fn outerCodingRate(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RFObservation_Full::VT_OUTERCODINGRATE, Some(0)).unwrap()}
  }
  /// Transmit pulse shaping filter typ (e.g. RRC).
  /// Example: /// Example: RRC
  /// Constraints: Minimum length = 0, Maximum length = 10
  #[inline]
  pub fn transmitFilterType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_TRANSMITFILTERTYPE, None)}
  }
  /// Transmit pulse shaping filter roll-off value.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn transmitFilterRollOff(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_TRANSMITFILTERROLLOFF, Some(0.0)).unwrap()}
  }
  /// Symbol to noise ratio, in dB.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn symbolToNoiseRatio(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_SYMBOLTONOISERATIO, Some(0.0)).unwrap()}
  }
  /// The ratio of bit errors per number of received bits.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn bitErrorRate(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFObservation_Full::VT_BITERRORRATE, Some(0.0)).unwrap()}
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  #[inline]
  pub fn origNetwork(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_ORIGNETWORK, None)}
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn sourceDL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_SOURCEDL, None)}
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn onOrbit(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_ONORBIT, None)}
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: descriptor
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn descriptor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_DESCRIPTOR, None)}
  }
  /// Optional URL containing additional information on this observation.
  /// Example: /// Example: https://some-url
  /// Constraints: Minimum length = 0, Maximum length = 2048
  #[inline]
  pub fn url(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFObservation_Full::VT_URL, None)}
  }
}

impl flatbuffers::Verifiable for RFObservation_Full<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classificationMarking", Self::VT_CLASSIFICATIONMARKING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("obTime", Self::VT_OBTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idOnOrbit", Self::VT_IDONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("idSensor", Self::VT_IDSENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<i32>("satNo", Self::VT_SATNO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskId", Self::VT_TASKID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transactionId", Self::VT_TRANSACTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trackId", Self::VT_TRACKID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origObjectId", Self::VT_ORIGOBJECTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origSensorId", Self::VT_ORIGSENSORID, false)?
     .visit_field::<bool>("uct", Self::VT_UCT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transponder", Self::VT_TRANSPONDER, false)?
     .visit_field::<f64>("azimuth", Self::VT_AZIMUTH, false)?
     .visit_field::<f64>("azimuthUnc", Self::VT_AZIMUTHUNC, false)?
     .visit_field::<f64>("azimuthRate", Self::VT_AZIMUTHRATE, false)?
     .visit_field::<f64>("elevation", Self::VT_ELEVATION, false)?
     .visit_field::<f64>("elevationUnc", Self::VT_ELEVATIONUNC, false)?
     .visit_field::<f64>("elevationRate", Self::VT_ELEVATIONRATE, false)?
     .visit_field::<f64>("range", Self::VT_RANGE, false)?
     .visit_field::<f64>("rangeUnc", Self::VT_RANGEUNC, false)?
     .visit_field::<f64>("rangeRate", Self::VT_RANGERATE, false)?
     .visit_field::<f64>("rangeRateUnc", Self::VT_RANGERATEUNC, false)?
     .visit_field::<f64>("trackRange", Self::VT_TRACKRANGE, false)?
     .visit_field::<f64>("senlat", Self::VT_SENLAT, false)?
     .visit_field::<f64>("senlon", Self::VT_SENLON, false)?
     .visit_field::<f64>("senalt", Self::VT_SENALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("elnot", Self::VT_ELNOT, false)?
     .visit_field::<f64>("frequency", Self::VT_FREQUENCY, false)?
     .visit_field::<f64>("nominalFrequency", Self::VT_NOMINALFREQUENCY, false)?
     .visit_field::<f64>("startFrequency", Self::VT_STARTFREQUENCY, false)?
     .visit_field::<f64>("endFrequency", Self::VT_ENDFREQUENCY, false)?
     .visit_field::<f64>("relativeCarrierPower", Self::VT_RELATIVECARRIERPOWER, false)?
     .visit_field::<f64>("spectrumAnalyzerPower", Self::VT_SPECTRUMANALYZERPOWER, false)?
     .visit_field::<f64>("relativeNoiseFloor", Self::VT_RELATIVENOISEFLOOR, false)?
     .visit_field::<f64>("referenceLevel", Self::VT_REFERENCELEVEL, false)?
     .visit_field::<f64>("pgri", Self::VT_PGRI, false)?
     .visit_field::<f64>("confidence", Self::VT_CONFIDENCE, false)?
     .visit_field::<bool>("incoming", Self::VT_INCOMING, false)?
     .visit_field::<i32>("switchPoint", Self::VT_SWITCHPOINT, false)?
     .visit_field::<f64>("baudRate", Self::VT_BAUDRATE, false)?
     .visit_field::<f64>("snr", Self::VT_SNR, false)?
     .visit_field::<f64>("nominalSnr", Self::VT_NOMINALSNR, false)?
     .visit_field::<f64>("polarity", Self::VT_POLARITY, false)?
     .visit_field::<RFObservation_Full_polarityType_Enum>("polarityType", Self::VT_POLARITYTYPE, false)?
     .visit_field::<i32>("channel", Self::VT_CHANNEL, false)?
     .visit_field::<f64>("powerOverNoise", Self::VT_POWEROVERNOISE, false)?
     .visit_field::<f64>("nominalPowerOverNoise", Self::VT_NOMINALPOWEROVERNOISE, false)?
     .visit_field::<f64>("bandwidth", Self::VT_BANDWIDTH, false)?
     .visit_field::<f64>("nominalBandwidth", Self::VT_NOMINALBANDWIDTH, false)?
     .visit_field::<f64>("resolutionBandwidth", Self::VT_RESOLUTIONBANDWIDTH, false)?
     .visit_field::<f64>("videoBandwidth", Self::VT_VIDEOBANDWIDTH, false)?
     .visit_field::<f64>("eirp", Self::VT_EIRP, false)?
     .visit_field::<f64>("nominalEirp", Self::VT_NOMINALEIRP, false)?
     .visit_field::<f64>("minPSD", Self::VT_MINPSD, false)?
     .visit_field::<f64>("maxPSD", Self::VT_MAXPSD, false)?
     .visit_field::<f64>("frequencyShift", Self::VT_FREQUENCYSHIFT, false)?
     .visit_field::<bool>("peak", Self::VT_PEAK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("antennaName", Self::VT_ANTENNANAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("detectionStatus", Self::VT_DETECTIONSTATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("collectionMode", Self::VT_COLLECTIONMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawFileURI", Self::VT_RAWFILEURI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<RFObservation_Full_dataMode_Enum>("dataMode", Self::VT_DATAMODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdAt", Self::VT_CREATEDAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("createdBy", Self::VT_CREATEDBY, false)?
     .visit_field::<f64>("noisePwrDensity", Self::VT_NOISEPWRDENSITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("carrierStandard", Self::VT_CARRIERSTANDARD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("modulation", Self::VT_MODULATION, false)?
     .visit_field::<i32>("innerCodingRate", Self::VT_INNERCODINGRATE, false)?
     .visit_field::<i32>("outerCodingRate", Self::VT_OUTERCODINGRATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transmitFilterType", Self::VT_TRANSMITFILTERTYPE, false)?
     .visit_field::<f64>("transmitFilterRollOff", Self::VT_TRANSMITFILTERROLLOFF, false)?
     .visit_field::<f64>("symbolToNoiseRatio", Self::VT_SYMBOLTONOISERATIO, false)?
     .visit_field::<f64>("bitErrorRate", Self::VT_BITERRORRATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("origNetwork", Self::VT_ORIGNETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sourceDL", Self::VT_SOURCEDL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("onOrbit", Self::VT_ONORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("descriptor", Self::VT_DESCRIPTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, false)?
     .finish();
    Ok(())
  }
}
pub struct RFObservation_FullArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub classificationMarking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idOnOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub idSensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub satNo: i32,
    pub taskId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transactionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trackId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origObjectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origSensorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uct: bool,
    pub transponder: Option<flatbuffers::WIPOffset<&'a str>>,
    pub azimuth: f64,
    pub azimuthUnc: f64,
    pub azimuthRate: f64,
    pub elevation: f64,
    pub elevationUnc: f64,
    pub elevationRate: f64,
    pub range: f64,
    pub rangeUnc: f64,
    pub rangeRate: f64,
    pub rangeRateUnc: f64,
    pub trackRange: f64,
    pub senlat: f64,
    pub senlon: f64,
    pub senalt: f64,
    pub elnot: Option<flatbuffers::WIPOffset<&'a str>>,
    pub frequency: f64,
    pub nominalFrequency: f64,
    pub startFrequency: f64,
    pub endFrequency: f64,
    pub relativeCarrierPower: f64,
    pub spectrumAnalyzerPower: f64,
    pub relativeNoiseFloor: f64,
    pub referenceLevel: f64,
    pub pgri: f64,
    pub confidence: f64,
    pub incoming: bool,
    pub switchPoint: i32,
    pub baudRate: f64,
    pub snr: f64,
    pub nominalSnr: f64,
    pub polarity: f64,
    pub polarityType: RFObservation_Full_polarityType_Enum,
    pub channel: i32,
    pub powerOverNoise: f64,
    pub nominalPowerOverNoise: f64,
    pub bandwidth: f64,
    pub nominalBandwidth: f64,
    pub resolutionBandwidth: f64,
    pub videoBandwidth: f64,
    pub eirp: f64,
    pub nominalEirp: f64,
    pub minPSD: f64,
    pub maxPSD: f64,
    pub frequencyShift: f64,
    pub peak: bool,
    pub antennaName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub detectionStatus: Option<flatbuffers::WIPOffset<&'a str>>,
    pub collectionMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rawFileURI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub origin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataMode: RFObservation_Full_dataMode_Enum,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub createdAt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub createdBy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noisePwrDensity: f64,
    pub carrierStandard: Option<flatbuffers::WIPOffset<&'a str>>,
    pub modulation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub innerCodingRate: i32,
    pub outerCodingRate: i32,
    pub transmitFilterType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transmitFilterRollOff: f64,
    pub symbolToNoiseRatio: f64,
    pub bitErrorRate: f64,
    pub origNetwork: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sourceDL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub onOrbit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub descriptor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RFObservation_FullArgs<'a> {
  #[inline]
  fn default() -> Self {
    RFObservation_FullArgs {
      id: None,
      classificationMarking: None,
      obTime: None,
      idOnOrbit: None,
      idSensor: None,
      type_: None,
      satNo: 0,
      taskId: None,
      transactionId: None,
      trackId: None,
      origObjectId: None,
      origSensorId: None,
      uct: false,
      transponder: None,
      azimuth: 0.0,
      azimuthUnc: 0.0,
      azimuthRate: 0.0,
      elevation: 0.0,
      elevationUnc: 0.0,
      elevationRate: 0.0,
      range: 0.0,
      rangeUnc: 0.0,
      rangeRate: 0.0,
      rangeRateUnc: 0.0,
      trackRange: 0.0,
      senlat: 0.0,
      senlon: 0.0,
      senalt: 0.0,
      elnot: None,
      frequency: 0.0,
      nominalFrequency: 0.0,
      startFrequency: 0.0,
      endFrequency: 0.0,
      relativeCarrierPower: 0.0,
      spectrumAnalyzerPower: 0.0,
      relativeNoiseFloor: 0.0,
      referenceLevel: 0.0,
      pgri: 0.0,
      confidence: 0.0,
      incoming: false,
      switchPoint: 0,
      baudRate: 0.0,
      snr: 0.0,
      nominalSnr: 0.0,
      polarity: 0.0,
      polarityType: RFObservation_Full_polarityType_Enum::H,
      channel: 0,
      powerOverNoise: 0.0,
      nominalPowerOverNoise: 0.0,
      bandwidth: 0.0,
      nominalBandwidth: 0.0,
      resolutionBandwidth: 0.0,
      videoBandwidth: 0.0,
      eirp: 0.0,
      nominalEirp: 0.0,
      minPSD: 0.0,
      maxPSD: 0.0,
      frequencyShift: 0.0,
      peak: false,
      antennaName: None,
      detectionStatus: None,
      collectionMode: None,
      rawFileURI: None,
      source: None,
      origin: None,
      dataMode: RFObservation_Full_dataMode_Enum::REAL,
      tags: None,
      createdAt: None,
      createdBy: None,
      noisePwrDensity: 0.0,
      carrierStandard: None,
      modulation: None,
      innerCodingRate: 0,
      outerCodingRate: 0,
      transmitFilterType: None,
      transmitFilterRollOff: 0.0,
      symbolToNoiseRatio: 0.0,
      bitErrorRate: 0.0,
      origNetwork: None,
      sourceDL: None,
      onOrbit: None,
      descriptor: None,
      url: None,
    }
  }
}

pub struct RFObservation_FullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RFObservation_FullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_ID, id);
  }
  #[inline]
  pub fn add_classificationMarking(&mut self, classificationMarking: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  #[inline]
  pub fn add_obTime(&mut self, obTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_OBTIME, obTime);
  }
  #[inline]
  pub fn add_idOnOrbit(&mut self, idOnOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_IDONORBIT, idOnOrbit);
  }
  #[inline]
  pub fn add_idSensor(&mut self, idSensor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_IDSENSOR, idSensor);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_satNo(&mut self, satNo: i32) {
    self.fbb_.push_slot::<i32>(RFObservation_Full::VT_SATNO, satNo, 0);
  }
  #[inline]
  pub fn add_taskId(&mut self, taskId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_TASKID, taskId);
  }
  #[inline]
  pub fn add_transactionId(&mut self, transactionId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_TRANSACTIONID, transactionId);
  }
  #[inline]
  pub fn add_trackId(&mut self, trackId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_TRACKID, trackId);
  }
  #[inline]
  pub fn add_origObjectId(&mut self, origObjectId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_ORIGOBJECTID, origObjectId);
  }
  #[inline]
  pub fn add_origSensorId(&mut self, origSensorId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_ORIGSENSORID, origSensorId);
  }
  #[inline]
  pub fn add_uct(&mut self, uct: bool) {
    self.fbb_.push_slot::<bool>(RFObservation_Full::VT_UCT, uct, false);
  }
  #[inline]
  pub fn add_transponder(&mut self, transponder: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_TRANSPONDER, transponder);
  }
  #[inline]
  pub fn add_azimuth(&mut self, azimuth: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_AZIMUTH, azimuth, 0.0);
  }
  #[inline]
  pub fn add_azimuthUnc(&mut self, azimuthUnc: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_AZIMUTHUNC, azimuthUnc, 0.0);
  }
  #[inline]
  pub fn add_azimuthRate(&mut self, azimuthRate: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_AZIMUTHRATE, azimuthRate, 0.0);
  }
  #[inline]
  pub fn add_elevation(&mut self, elevation: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_ELEVATION, elevation, 0.0);
  }
  #[inline]
  pub fn add_elevationUnc(&mut self, elevationUnc: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_ELEVATIONUNC, elevationUnc, 0.0);
  }
  #[inline]
  pub fn add_elevationRate(&mut self, elevationRate: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_ELEVATIONRATE, elevationRate, 0.0);
  }
  #[inline]
  pub fn add_range(&mut self, range: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_RANGE, range, 0.0);
  }
  #[inline]
  pub fn add_rangeUnc(&mut self, rangeUnc: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_RANGEUNC, rangeUnc, 0.0);
  }
  #[inline]
  pub fn add_rangeRate(&mut self, rangeRate: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_RANGERATE, rangeRate, 0.0);
  }
  #[inline]
  pub fn add_rangeRateUnc(&mut self, rangeRateUnc: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_RANGERATEUNC, rangeRateUnc, 0.0);
  }
  #[inline]
  pub fn add_trackRange(&mut self, trackRange: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_TRACKRANGE, trackRange, 0.0);
  }
  #[inline]
  pub fn add_senlat(&mut self, senlat: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_SENLAT, senlat, 0.0);
  }
  #[inline]
  pub fn add_senlon(&mut self, senlon: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_SENLON, senlon, 0.0);
  }
  #[inline]
  pub fn add_senalt(&mut self, senalt: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_SENALT, senalt, 0.0);
  }
  #[inline]
  pub fn add_elnot(&mut self, elnot: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_ELNOT, elnot);
  }
  #[inline]
  pub fn add_frequency(&mut self, frequency: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_FREQUENCY, frequency, 0.0);
  }
  #[inline]
  pub fn add_nominalFrequency(&mut self, nominalFrequency: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_NOMINALFREQUENCY, nominalFrequency, 0.0);
  }
  #[inline]
  pub fn add_startFrequency(&mut self, startFrequency: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_STARTFREQUENCY, startFrequency, 0.0);
  }
  #[inline]
  pub fn add_endFrequency(&mut self, endFrequency: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_ENDFREQUENCY, endFrequency, 0.0);
  }
  #[inline]
  pub fn add_relativeCarrierPower(&mut self, relativeCarrierPower: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_RELATIVECARRIERPOWER, relativeCarrierPower, 0.0);
  }
  #[inline]
  pub fn add_spectrumAnalyzerPower(&mut self, spectrumAnalyzerPower: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_SPECTRUMANALYZERPOWER, spectrumAnalyzerPower, 0.0);
  }
  #[inline]
  pub fn add_relativeNoiseFloor(&mut self, relativeNoiseFloor: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_RELATIVENOISEFLOOR, relativeNoiseFloor, 0.0);
  }
  #[inline]
  pub fn add_referenceLevel(&mut self, referenceLevel: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_REFERENCELEVEL, referenceLevel, 0.0);
  }
  #[inline]
  pub fn add_pgri(&mut self, pgri: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_PGRI, pgri, 0.0);
  }
  #[inline]
  pub fn add_confidence(&mut self, confidence: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_CONFIDENCE, confidence, 0.0);
  }
  #[inline]
  pub fn add_incoming(&mut self, incoming: bool) {
    self.fbb_.push_slot::<bool>(RFObservation_Full::VT_INCOMING, incoming, false);
  }
  #[inline]
  pub fn add_switchPoint(&mut self, switchPoint: i32) {
    self.fbb_.push_slot::<i32>(RFObservation_Full::VT_SWITCHPOINT, switchPoint, 0);
  }
  #[inline]
  pub fn add_baudRate(&mut self, baudRate: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_BAUDRATE, baudRate, 0.0);
  }
  #[inline]
  pub fn add_snr(&mut self, snr: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_SNR, snr, 0.0);
  }
  #[inline]
  pub fn add_nominalSnr(&mut self, nominalSnr: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_NOMINALSNR, nominalSnr, 0.0);
  }
  #[inline]
  pub fn add_polarity(&mut self, polarity: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_POLARITY, polarity, 0.0);
  }
  #[inline]
  pub fn add_polarityType(&mut self, polarityType: RFObservation_Full_polarityType_Enum) {
    self.fbb_.push_slot::<RFObservation_Full_polarityType_Enum>(RFObservation_Full::VT_POLARITYTYPE, polarityType, RFObservation_Full_polarityType_Enum::H);
  }
  #[inline]
  pub fn add_channel(&mut self, channel: i32) {
    self.fbb_.push_slot::<i32>(RFObservation_Full::VT_CHANNEL, channel, 0);
  }
  #[inline]
  pub fn add_powerOverNoise(&mut self, powerOverNoise: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_POWEROVERNOISE, powerOverNoise, 0.0);
  }
  #[inline]
  pub fn add_nominalPowerOverNoise(&mut self, nominalPowerOverNoise: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_NOMINALPOWEROVERNOISE, nominalPowerOverNoise, 0.0);
  }
  #[inline]
  pub fn add_bandwidth(&mut self, bandwidth: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_BANDWIDTH, bandwidth, 0.0);
  }
  #[inline]
  pub fn add_nominalBandwidth(&mut self, nominalBandwidth: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_NOMINALBANDWIDTH, nominalBandwidth, 0.0);
  }
  #[inline]
  pub fn add_resolutionBandwidth(&mut self, resolutionBandwidth: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_RESOLUTIONBANDWIDTH, resolutionBandwidth, 0.0);
  }
  #[inline]
  pub fn add_videoBandwidth(&mut self, videoBandwidth: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_VIDEOBANDWIDTH, videoBandwidth, 0.0);
  }
  #[inline]
  pub fn add_eirp(&mut self, eirp: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_EIRP, eirp, 0.0);
  }
  #[inline]
  pub fn add_nominalEirp(&mut self, nominalEirp: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_NOMINALEIRP, nominalEirp, 0.0);
  }
  #[inline]
  pub fn add_minPSD(&mut self, minPSD: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_MINPSD, minPSD, 0.0);
  }
  #[inline]
  pub fn add_maxPSD(&mut self, maxPSD: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_MAXPSD, maxPSD, 0.0);
  }
  #[inline]
  pub fn add_frequencyShift(&mut self, frequencyShift: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_FREQUENCYSHIFT, frequencyShift, 0.0);
  }
  #[inline]
  pub fn add_peak(&mut self, peak: bool) {
    self.fbb_.push_slot::<bool>(RFObservation_Full::VT_PEAK, peak, false);
  }
  #[inline]
  pub fn add_antennaName(&mut self, antennaName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_ANTENNANAME, antennaName);
  }
  #[inline]
  pub fn add_detectionStatus(&mut self, detectionStatus: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_DETECTIONSTATUS, detectionStatus);
  }
  #[inline]
  pub fn add_collectionMode(&mut self, collectionMode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_COLLECTIONMODE, collectionMode);
  }
  #[inline]
  pub fn add_rawFileURI(&mut self, rawFileURI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_RAWFILEURI, rawFileURI);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_dataMode(&mut self, dataMode: RFObservation_Full_dataMode_Enum) {
    self.fbb_.push_slot::<RFObservation_Full_dataMode_Enum>(RFObservation_Full::VT_DATAMODE, dataMode, RFObservation_Full_dataMode_Enum::REAL);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_createdAt(&mut self, createdAt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_CREATEDAT, createdAt);
  }
  #[inline]
  pub fn add_createdBy(&mut self, createdBy: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_CREATEDBY, createdBy);
  }
  #[inline]
  pub fn add_noisePwrDensity(&mut self, noisePwrDensity: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_NOISEPWRDENSITY, noisePwrDensity, 0.0);
  }
  #[inline]
  pub fn add_carrierStandard(&mut self, carrierStandard: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_CARRIERSTANDARD, carrierStandard);
  }
  #[inline]
  pub fn add_modulation(&mut self, modulation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_MODULATION, modulation);
  }
  #[inline]
  pub fn add_innerCodingRate(&mut self, innerCodingRate: i32) {
    self.fbb_.push_slot::<i32>(RFObservation_Full::VT_INNERCODINGRATE, innerCodingRate, 0);
  }
  #[inline]
  pub fn add_outerCodingRate(&mut self, outerCodingRate: i32) {
    self.fbb_.push_slot::<i32>(RFObservation_Full::VT_OUTERCODINGRATE, outerCodingRate, 0);
  }
  #[inline]
  pub fn add_transmitFilterType(&mut self, transmitFilterType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_TRANSMITFILTERTYPE, transmitFilterType);
  }
  #[inline]
  pub fn add_transmitFilterRollOff(&mut self, transmitFilterRollOff: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_TRANSMITFILTERROLLOFF, transmitFilterRollOff, 0.0);
  }
  #[inline]
  pub fn add_symbolToNoiseRatio(&mut self, symbolToNoiseRatio: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_SYMBOLTONOISERATIO, symbolToNoiseRatio, 0.0);
  }
  #[inline]
  pub fn add_bitErrorRate(&mut self, bitErrorRate: f64) {
    self.fbb_.push_slot::<f64>(RFObservation_Full::VT_BITERRORRATE, bitErrorRate, 0.0);
  }
  #[inline]
  pub fn add_origNetwork(&mut self, origNetwork: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_ORIGNETWORK, origNetwork);
  }
  #[inline]
  pub fn add_sourceDL(&mut self, sourceDL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_SOURCEDL, sourceDL);
  }
  #[inline]
  pub fn add_onOrbit(&mut self, onOrbit: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_ONORBIT, onOrbit);
  }
  #[inline]
  pub fn add_descriptor(&mut self, descriptor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_DESCRIPTOR, descriptor);
  }
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFObservation_Full::VT_URL, url);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RFObservation_FullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RFObservation_FullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RFObservation_Full<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RFObservation_Full<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RFObservation_Full");
      ds.field("id", &self.id());
      ds.field("classificationMarking", &self.classificationMarking());
      ds.field("obTime", &self.obTime());
      ds.field("idOnOrbit", &self.idOnOrbit());
      ds.field("idSensor", &self.idSensor());
      ds.field("type_", &self.type_());
      ds.field("satNo", &self.satNo());
      ds.field("taskId", &self.taskId());
      ds.field("transactionId", &self.transactionId());
      ds.field("trackId", &self.trackId());
      ds.field("origObjectId", &self.origObjectId());
      ds.field("origSensorId", &self.origSensorId());
      ds.field("uct", &self.uct());
      ds.field("transponder", &self.transponder());
      ds.field("azimuth", &self.azimuth());
      ds.field("azimuthUnc", &self.azimuthUnc());
      ds.field("azimuthRate", &self.azimuthRate());
      ds.field("elevation", &self.elevation());
      ds.field("elevationUnc", &self.elevationUnc());
      ds.field("elevationRate", &self.elevationRate());
      ds.field("range", &self.range());
      ds.field("rangeUnc", &self.rangeUnc());
      ds.field("rangeRate", &self.rangeRate());
      ds.field("rangeRateUnc", &self.rangeRateUnc());
      ds.field("trackRange", &self.trackRange());
      ds.field("senlat", &self.senlat());
      ds.field("senlon", &self.senlon());
      ds.field("senalt", &self.senalt());
      ds.field("elnot", &self.elnot());
      ds.field("frequency", &self.frequency());
      ds.field("nominalFrequency", &self.nominalFrequency());
      ds.field("startFrequency", &self.startFrequency());
      ds.field("endFrequency", &self.endFrequency());
      ds.field("relativeCarrierPower", &self.relativeCarrierPower());
      ds.field("spectrumAnalyzerPower", &self.spectrumAnalyzerPower());
      ds.field("relativeNoiseFloor", &self.relativeNoiseFloor());
      ds.field("referenceLevel", &self.referenceLevel());
      ds.field("pgri", &self.pgri());
      ds.field("confidence", &self.confidence());
      ds.field("incoming", &self.incoming());
      ds.field("switchPoint", &self.switchPoint());
      ds.field("baudRate", &self.baudRate());
      ds.field("snr", &self.snr());
      ds.field("nominalSnr", &self.nominalSnr());
      ds.field("polarity", &self.polarity());
      ds.field("polarityType", &self.polarityType());
      ds.field("channel", &self.channel());
      ds.field("powerOverNoise", &self.powerOverNoise());
      ds.field("nominalPowerOverNoise", &self.nominalPowerOverNoise());
      ds.field("bandwidth", &self.bandwidth());
      ds.field("nominalBandwidth", &self.nominalBandwidth());
      ds.field("resolutionBandwidth", &self.resolutionBandwidth());
      ds.field("videoBandwidth", &self.videoBandwidth());
      ds.field("eirp", &self.eirp());
      ds.field("nominalEirp", &self.nominalEirp());
      ds.field("minPSD", &self.minPSD());
      ds.field("maxPSD", &self.maxPSD());
      ds.field("frequencyShift", &self.frequencyShift());
      ds.field("peak", &self.peak());
      ds.field("antennaName", &self.antennaName());
      ds.field("detectionStatus", &self.detectionStatus());
      ds.field("collectionMode", &self.collectionMode());
      ds.field("rawFileURI", &self.rawFileURI());
      ds.field("source", &self.source());
      ds.field("origin", &self.origin());
      ds.field("dataMode", &self.dataMode());
      ds.field("tags", &self.tags());
      ds.field("createdAt", &self.createdAt());
      ds.field("createdBy", &self.createdBy());
      ds.field("noisePwrDensity", &self.noisePwrDensity());
      ds.field("carrierStandard", &self.carrierStandard());
      ds.field("modulation", &self.modulation());
      ds.field("innerCodingRate", &self.innerCodingRate());
      ds.field("outerCodingRate", &self.outerCodingRate());
      ds.field("transmitFilterType", &self.transmitFilterType());
      ds.field("transmitFilterRollOff", &self.transmitFilterRollOff());
      ds.field("symbolToNoiseRatio", &self.symbolToNoiseRatio());
      ds.field("bitErrorRate", &self.bitErrorRate());
      ds.field("origNetwork", &self.origNetwork());
      ds.field("sourceDL", &self.sourceDL());
      ds.field("onOrbit", &self.onOrbit());
      ds.field("descriptor", &self.descriptor());
      ds.field("url", &self.url());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RFObservation_FullT {
  pub id: Option<String>,
  pub classificationMarking: Option<String>,
  pub obTime: Option<String>,
  pub idOnOrbit: Option<String>,
  pub idSensor: Option<String>,
  pub type_: Option<String>,
  pub satNo: i32,
  pub taskId: Option<String>,
  pub transactionId: Option<String>,
  pub trackId: Option<String>,
  pub origObjectId: Option<String>,
  pub origSensorId: Option<String>,
  pub uct: bool,
  pub transponder: Option<String>,
  pub azimuth: f64,
  pub azimuthUnc: f64,
  pub azimuthRate: f64,
  pub elevation: f64,
  pub elevationUnc: f64,
  pub elevationRate: f64,
  pub range: f64,
  pub rangeUnc: f64,
  pub rangeRate: f64,
  pub rangeRateUnc: f64,
  pub trackRange: f64,
  pub senlat: f64,
  pub senlon: f64,
  pub senalt: f64,
  pub elnot: Option<String>,
  pub frequency: f64,
  pub nominalFrequency: f64,
  pub startFrequency: f64,
  pub endFrequency: f64,
  pub relativeCarrierPower: f64,
  pub spectrumAnalyzerPower: f64,
  pub relativeNoiseFloor: f64,
  pub referenceLevel: f64,
  pub pgri: f64,
  pub confidence: f64,
  pub incoming: bool,
  pub switchPoint: i32,
  pub baudRate: f64,
  pub snr: f64,
  pub nominalSnr: f64,
  pub polarity: f64,
  pub polarityType: RFObservation_Full_polarityType_Enum,
  pub channel: i32,
  pub powerOverNoise: f64,
  pub nominalPowerOverNoise: f64,
  pub bandwidth: f64,
  pub nominalBandwidth: f64,
  pub resolutionBandwidth: f64,
  pub videoBandwidth: f64,
  pub eirp: f64,
  pub nominalEirp: f64,
  pub minPSD: f64,
  pub maxPSD: f64,
  pub frequencyShift: f64,
  pub peak: bool,
  pub antennaName: Option<String>,
  pub detectionStatus: Option<String>,
  pub collectionMode: Option<String>,
  pub rawFileURI: Option<String>,
  pub source: Option<String>,
  pub origin: Option<String>,
  pub dataMode: RFObservation_Full_dataMode_Enum,
  pub tags: Option<Vec<String>>,
  pub createdAt: Option<String>,
  pub createdBy: Option<String>,
  pub noisePwrDensity: f64,
  pub carrierStandard: Option<String>,
  pub modulation: Option<String>,
  pub innerCodingRate: i32,
  pub outerCodingRate: i32,
  pub transmitFilterType: Option<String>,
  pub transmitFilterRollOff: f64,
  pub symbolToNoiseRatio: f64,
  pub bitErrorRate: f64,
  pub origNetwork: Option<String>,
  pub sourceDL: Option<String>,
  pub onOrbit: Option<String>,
  pub descriptor: Option<String>,
  pub url: Option<String>,
}
impl Default for RFObservation_FullT {
  fn default() -> Self {
    Self {
      id: None,
      classificationMarking: None,
      obTime: None,
      idOnOrbit: None,
      idSensor: None,
      type_: None,
      satNo: 0,
      taskId: None,
      transactionId: None,
      trackId: None,
      origObjectId: None,
      origSensorId: None,
      uct: false,
      transponder: None,
      azimuth: 0.0,
      azimuthUnc: 0.0,
      azimuthRate: 0.0,
      elevation: 0.0,
      elevationUnc: 0.0,
      elevationRate: 0.0,
      range: 0.0,
      rangeUnc: 0.0,
      rangeRate: 0.0,
      rangeRateUnc: 0.0,
      trackRange: 0.0,
      senlat: 0.0,
      senlon: 0.0,
      senalt: 0.0,
      elnot: None,
      frequency: 0.0,
      nominalFrequency: 0.0,
      startFrequency: 0.0,
      endFrequency: 0.0,
      relativeCarrierPower: 0.0,
      spectrumAnalyzerPower: 0.0,
      relativeNoiseFloor: 0.0,
      referenceLevel: 0.0,
      pgri: 0.0,
      confidence: 0.0,
      incoming: false,
      switchPoint: 0,
      baudRate: 0.0,
      snr: 0.0,
      nominalSnr: 0.0,
      polarity: 0.0,
      polarityType: RFObservation_Full_polarityType_Enum::H,
      channel: 0,
      powerOverNoise: 0.0,
      nominalPowerOverNoise: 0.0,
      bandwidth: 0.0,
      nominalBandwidth: 0.0,
      resolutionBandwidth: 0.0,
      videoBandwidth: 0.0,
      eirp: 0.0,
      nominalEirp: 0.0,
      minPSD: 0.0,
      maxPSD: 0.0,
      frequencyShift: 0.0,
      peak: false,
      antennaName: None,
      detectionStatus: None,
      collectionMode: None,
      rawFileURI: None,
      source: None,
      origin: None,
      dataMode: RFObservation_Full_dataMode_Enum::REAL,
      tags: None,
      createdAt: None,
      createdBy: None,
      noisePwrDensity: 0.0,
      carrierStandard: None,
      modulation: None,
      innerCodingRate: 0,
      outerCodingRate: 0,
      transmitFilterType: None,
      transmitFilterRollOff: 0.0,
      symbolToNoiseRatio: 0.0,
      bitErrorRate: 0.0,
      origNetwork: None,
      sourceDL: None,
      onOrbit: None,
      descriptor: None,
      url: None,
    }
  }
}
impl RFObservation_FullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<RFObservation_Full<'b>> {
    let id = self.id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let classificationMarking = self.classificationMarking.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let obTime = self.obTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idOnOrbit = self.idOnOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let idSensor = self.idSensor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let satNo = self.satNo;
    let taskId = self.taskId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let transactionId = self.transactionId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let trackId = self.trackId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origObjectId = self.origObjectId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origSensorId = self.origSensorId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let uct = self.uct;
    let transponder = self.transponder.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let azimuth = self.azimuth;
    let azimuthUnc = self.azimuthUnc;
    let azimuthRate = self.azimuthRate;
    let elevation = self.elevation;
    let elevationUnc = self.elevationUnc;
    let elevationRate = self.elevationRate;
    let range = self.range;
    let rangeUnc = self.rangeUnc;
    let rangeRate = self.rangeRate;
    let rangeRateUnc = self.rangeRateUnc;
    let trackRange = self.trackRange;
    let senlat = self.senlat;
    let senlon = self.senlon;
    let senalt = self.senalt;
    let elnot = self.elnot.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let frequency = self.frequency;
    let nominalFrequency = self.nominalFrequency;
    let startFrequency = self.startFrequency;
    let endFrequency = self.endFrequency;
    let relativeCarrierPower = self.relativeCarrierPower;
    let spectrumAnalyzerPower = self.spectrumAnalyzerPower;
    let relativeNoiseFloor = self.relativeNoiseFloor;
    let referenceLevel = self.referenceLevel;
    let pgri = self.pgri;
    let confidence = self.confidence;
    let incoming = self.incoming;
    let switchPoint = self.switchPoint;
    let baudRate = self.baudRate;
    let snr = self.snr;
    let nominalSnr = self.nominalSnr;
    let polarity = self.polarity;
    let polarityType = self.polarityType;
    let channel = self.channel;
    let powerOverNoise = self.powerOverNoise;
    let nominalPowerOverNoise = self.nominalPowerOverNoise;
    let bandwidth = self.bandwidth;
    let nominalBandwidth = self.nominalBandwidth;
    let resolutionBandwidth = self.resolutionBandwidth;
    let videoBandwidth = self.videoBandwidth;
    let eirp = self.eirp;
    let nominalEirp = self.nominalEirp;
    let minPSD = self.minPSD;
    let maxPSD = self.maxPSD;
    let frequencyShift = self.frequencyShift;
    let peak = self.peak;
    let antennaName = self.antennaName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let detectionStatus = self.detectionStatus.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let collectionMode = self.collectionMode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let rawFileURI = self.rawFileURI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let source = self.source.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let origin = self.origin.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let dataMode = self.dataMode;
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let createdAt = self.createdAt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let createdBy = self.createdBy.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let noisePwrDensity = self.noisePwrDensity;
    let carrierStandard = self.carrierStandard.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let modulation = self.modulation.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let innerCodingRate = self.innerCodingRate;
    let outerCodingRate = self.outerCodingRate;
    let transmitFilterType = self.transmitFilterType.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let transmitFilterRollOff = self.transmitFilterRollOff;
    let symbolToNoiseRatio = self.symbolToNoiseRatio;
    let bitErrorRate = self.bitErrorRate;
    let origNetwork = self.origNetwork.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sourceDL = self.sourceDL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let onOrbit = self.onOrbit.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let descriptor = self.descriptor.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let url = self.url.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    RFObservation_Full::create(_fbb, &RFObservation_FullArgs{
      id,
      classificationMarking,
      obTime,
      idOnOrbit,
      idSensor,
      type_,
      satNo,
      taskId,
      transactionId,
      trackId,
      origObjectId,
      origSensorId,
      uct,
      transponder,
      azimuth,
      azimuthUnc,
      azimuthRate,
      elevation,
      elevationUnc,
      elevationRate,
      range,
      rangeUnc,
      rangeRate,
      rangeRateUnc,
      trackRange,
      senlat,
      senlon,
      senalt,
      elnot,
      frequency,
      nominalFrequency,
      startFrequency,
      endFrequency,
      relativeCarrierPower,
      spectrumAnalyzerPower,
      relativeNoiseFloor,
      referenceLevel,
      pgri,
      confidence,
      incoming,
      switchPoint,
      baudRate,
      snr,
      nominalSnr,
      polarity,
      polarityType,
      channel,
      powerOverNoise,
      nominalPowerOverNoise,
      bandwidth,
      nominalBandwidth,
      resolutionBandwidth,
      videoBandwidth,
      eirp,
      nominalEirp,
      minPSD,
      maxPSD,
      frequencyShift,
      peak,
      antennaName,
      detectionStatus,
      collectionMode,
      rawFileURI,
      source,
      origin,
      dataMode,
      tags,
      createdAt,
      createdBy,
      noisePwrDensity,
      carrierStandard,
      modulation,
      innerCodingRate,
      outerCodingRate,
      transmitFilterType,
      transmitFilterRollOff,
      symbolToNoiseRatio,
      bitErrorRate,
      origNetwork,
      sourceDL,
      onOrbit,
      descriptor,
      url,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `RFObservation_Full`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rfobservation_full_unchecked`.
pub fn root_as_rfobservation_full(buf: &[u8]) -> Result<RFObservation_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<RFObservation_Full>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `RFObservation_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_rfobservation_full_unchecked`.
pub fn size_prefixed_root_as_rfobservation_full(buf: &[u8]) -> Result<RFObservation_Full, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<RFObservation_Full>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `RFObservation_Full` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rfobservation_full_unchecked`.
pub fn root_as_rfobservation_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RFObservation_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<RFObservation_Full<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `RFObservation_Full` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rfobservation_full_unchecked`.
pub fn size_prefixed_root_as_rfobservation_full_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RFObservation_Full<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<RFObservation_Full<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a RFObservation_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `RFObservation_Full`.
pub unsafe fn root_as_rfobservation_full_unchecked(buf: &[u8]) -> RFObservation_Full {
  flatbuffers::root_unchecked::<RFObservation_Full>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed RFObservation_Full and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `RFObservation_Full`.
pub unsafe fn size_prefixed_root_as_rfobservation_full_unchecked(buf: &[u8]) -> RFObservation_Full {
  flatbuffers::size_prefixed_root_unchecked::<RFObservation_Full>(buf)
}
pub const RFOBSERVATION_FULL_IDENTIFIER: &str = "RFOB";

#[inline]
pub fn rfobservation_full_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, RFOBSERVATION_FULL_IDENTIFIER, false)
}

#[inline]
pub fn rfobservation_full_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, RFOBSERVATION_FULL_IDENTIFIER, true)
}

#[inline]
pub fn finish_rfobservation_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<RFObservation_Full<'a>>) {
  fbb.finish(root, Some(RFOBSERVATION_FULL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_rfobservation_full_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<RFObservation_Full<'a>>) {
  fbb.finish_size_prefixed(root, Some(RFOBSERVATION_FULL_IDENTIFIER));
}
