// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum MtiHRR_IngestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// /// Data on High-Range Resolution (HRR) targets or High Range Resolution Range Doppler Maps (RDM) for a specified area.
pub struct MtiHRR_Ingest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MtiHRR_Ingest<'a> {
  type Inner = MtiHRR_Ingest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MtiHRR_Ingest<'a> {
  pub const VT_H2: flatbuffers::VOffsetT = 4;
  pub const VT_H3: flatbuffers::VOffsetT = 6;
  pub const VT_H4: flatbuffers::VOffsetT = 8;
  pub const VT_H5: flatbuffers::VOffsetT = 10;
  pub const VT_H6: flatbuffers::VOffsetT = 12;
  pub const VT_H7: flatbuffers::VOffsetT = 14;
  pub const VT_H8: flatbuffers::VOffsetT = 16;
  pub const VT_H9: flatbuffers::VOffsetT = 18;
  pub const VT_H10: flatbuffers::VOffsetT = 20;
  pub const VT_H11: flatbuffers::VOffsetT = 22;
  pub const VT_H12: flatbuffers::VOffsetT = 24;
  pub const VT_H13: flatbuffers::VOffsetT = 26;
  pub const VT_H14: flatbuffers::VOffsetT = 28;
  pub const VT_H15: flatbuffers::VOffsetT = 30;
  pub const VT_H16: flatbuffers::VOffsetT = 32;
  pub const VT_H17: flatbuffers::VOffsetT = 34;
  pub const VT_H18: flatbuffers::VOffsetT = 36;
  pub const VT_H19: flatbuffers::VOffsetT = 38;
  pub const VT_H20: flatbuffers::VOffsetT = 40;
  pub const VT_H21: flatbuffers::VOffsetT = 42;
  pub const VT_H22: flatbuffers::VOffsetT = 44;
  pub const VT_H23: flatbuffers::VOffsetT = 46;
  pub const VT_H24: flatbuffers::VOffsetT = 48;
  pub const VT_H27: flatbuffers::VOffsetT = 50;
  pub const VT_H28: flatbuffers::VOffsetT = 52;
  pub const VT_H29: flatbuffers::VOffsetT = 54;
  pub const VT_H30: flatbuffers::VOffsetT = 56;
  pub const VT_H31: flatbuffers::VOffsetT = 58;
  pub const VT_H32: flatbuffers::VOffsetT = 60;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MtiHRR_Ingest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MtiHRR_IngestArgs<'args>
  ) -> flatbuffers::WIPOffset<MtiHRR_Ingest<'bldr>> {
    let mut builder = MtiHRR_IngestBuilder::new(_fbb);
    builder.add_h28(args.h28);
    builder.add_h19(args.h19);
    builder.add_h15(args.h15);
    builder.add_h14(args.h14);
    builder.add_h13(args.h13);
    builder.add_h12(args.h12);
    builder.add_h11(args.h11);
    if let Some(x) = args.h32 { builder.add_h32(x); }
    builder.add_h31(args.h31);
    builder.add_h30(args.h30);
    builder.add_h29(args.h29);
    builder.add_h27(args.h27);
    if let Some(x) = args.h24 { builder.add_h24(x); }
    if let Some(x) = args.h23 { builder.add_h23(x); }
    builder.add_h22(args.h22);
    builder.add_h21(args.h21);
    builder.add_h20(args.h20);
    if let Some(x) = args.h18 { builder.add_h18(x); }
    if let Some(x) = args.h17 { builder.add_h17(x); }
    if let Some(x) = args.h16 { builder.add_h16(x); }
    builder.add_h10(args.h10);
    builder.add_h9(args.h9);
    builder.add_h8(args.h8);
    builder.add_h7(args.h7);
    builder.add_h6(args.h6);
    builder.add_h5(args.h5);
    builder.add_h3(args.h3);
    builder.add_h2(args.h2);
    builder.add_h4(args.h4);
    builder.finish()
  }

  pub fn unpack(&self) -> MtiHRR_IngestT {
    let h2 = self.h2();
    let h3 = self.h3();
    let h4 = self.h4();
    let h5 = self.h5();
    let h6 = self.h6();
    let h7 = self.h7();
    let h8 = self.h8();
    let h9 = self.h9();
    let h10 = self.h10();
    let h11 = self.h11();
    let h12 = self.h12();
    let h13 = self.h13();
    let h14 = self.h14();
    let h15 = self.h15();
    let h16 = self.h16().map(|x| {
      x.to_string()
    });
    let h17 = self.h17().map(|x| {
      x.to_string()
    });
    let h18 = self.h18().map(|x| {
      x.to_string()
    });
    let h19 = self.h19();
    let h20 = self.h20();
    let h21 = self.h21();
    let h22 = self.h22();
    let h23 = self.h23().map(|x| {
      x.to_string()
    });
    let h24 = self.h24().map(|x| {
      x.to_string()
    });
    let h27 = self.h27();
    let h28 = self.h28();
    let h29 = self.h29();
    let h30 = self.h30();
    let h31 = self.h31();
    let h32 = self.h32().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    MtiHRR_IngestT {
      h2,
      h3,
      h4,
      h5,
      h6,
      h7,
      h8,
      h9,
      h10,
      h11,
      h12,
      h13,
      h14,
      h15,
      h16,
      h17,
      h18,
      h19,
      h20,
      h21,
      h22,
      h23,
      h24,
      h27,
      h28,
      h29,
      h30,
      h31,
      h32,
    }
  }

  /// Sequential count of a revisit of the bounding area for a given job ID.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h2(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H2, Some(0)).unwrap()}
  }
  /// Sequential count of a dwell within the revisit of a particular bounding area for a given job ID.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h3(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H3, Some(0)).unwrap()}
  }
  /// Flag to indicate the last dwell of the revisit.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h4(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MtiHRR_Ingest::VT_H4, Some(false)).unwrap()}
  }
  /// Sequential index of the associated MTI Report.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h5(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H5, Some(0)).unwrap()}
  }
  /// Number of Range Doppler pixels that exceed target scatterer threshold and are reported in this segment.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h6(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H6, Some(0)).unwrap()}
  }
  /// Number of Range Bins/Samples in a Range Doppler Chip.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h7(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H7, Some(0)).unwrap()}
  }
  /// Number of Doppler bins in a Range-Doppler chip.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h8(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H8, Some(0)).unwrap()}
  }
  /// The Peak Scatter returns the maximum power level (e.g. in milliwatts, or dBm) registered by the sensor.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h9(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H9, Some(0)).unwrap()}
  }
  /// Detection threshold used to isolate significant target scatterer pixels, expressed as power relative to clutter mean in negative quarter-decibels.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h10(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H10, Some(0)).unwrap()}
  }
  /// 3dB range impulse response of the radar, expressed in centimeters.
  /// Example: /// Example: 12.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h11(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MtiHRR_Ingest::VT_H11, Some(0.0)).unwrap()}
  }
  /// Slant Range pixel spacing after over sampling, expressed in centimeters.
  /// Example: /// Example: 12.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h12(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MtiHRR_Ingest::VT_H12, Some(0.0)).unwrap()}
  }
  /// 3dB Doppler resolution of the radar, expressed in Hertz.
  /// Example: /// Example: 12.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h13(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MtiHRR_Ingest::VT_H13, Some(0.0)).unwrap()}
  }
  /// Doppler pixel spacing after over sampling, expressed in Hertz.
  /// Example: /// Example: 12.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h14(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MtiHRR_Ingest::VT_H14, Some(0.0)).unwrap()}
  }
  /// Center Frequency of the radar in GHz.
  /// Example: /// Example: 12.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h15(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MtiHRR_Ingest::VT_H15, Some(0.0)).unwrap()}
  }
  /// Enumeration table denoting the compression technique used.
  /// Example: /// Example: TABLE
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn h16(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MtiHRR_Ingest::VT_H16, None)}
  }
  /// Enumeration table indicating the spectral weighting used in the range compression process.
  /// Example: /// Example: TABLE
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn h17(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MtiHRR_Ingest::VT_H17, None)}
  }
  /// Enumeration table indicating the spectral weighting used in the cross-range or Doppler compression process.
  /// Example: /// Example: TABLE
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn h18(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MtiHRR_Ingest::VT_H18, None)}
  }
  /// Initial power of the peak scatterer, expressed in dB.
  /// Example: /// Example: 12.23
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h19(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MtiHRR_Ingest::VT_H19, Some(0.0)).unwrap()}
  }
  /// RCS of the peak scatterer, expressed in half-decibels (dB/2).
  /// Example: /// Example: 117
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h20(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H20, Some(0)).unwrap()}
  }
  /// When the RDM does not correlate to a single MTI report index or when the center range bin does not correlate to the center of the dwell; provide the range sample offset in meters from Dwell Center (positive is away from the sensor) of the first scatterer record.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h21(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H21, Some(0)).unwrap()}
  }
  /// When the RDM does not correlate to a single MTI report index or the center doppler bin does not correlate to the doppler centroid of the dwell; Doppler sample value in Hz of the first scatterer record.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h22(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H22, Some(0)).unwrap()}
  }
  /// Enumeration field which designates the type of data being delivered.
  /// Example: /// Example: FIELD
  /// Constraints: Minimum length = 0, Maximum length = 32
  #[inline]
  pub fn h23(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MtiHRR_Ingest::VT_H23, None)}
  }
  /// Flag field to indicate the additional signal processing techniques applied to the data.
  /// Example: /// Example: FLAG
  /// Constraints: Minimum length = 0, Maximum length = 64
  #[inline]
  pub fn h24(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MtiHRR_Ingest::VT_H24, None)}
  }
  /// Number of pixels in the range dimension of the chip.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h27(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H27, Some(0)).unwrap()}
  }
  /// Distance from Range Bin to closest edge in the entire chip, expressed in centimeters.
  /// Example: /// Example: 1234567890
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h28(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MtiHRR_Ingest::VT_H28, Some(0)).unwrap()}
  }
  /// Relative velocity to skin line.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h29(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H29, Some(0)).unwrap()}
  }
  /// Computed object length based upon HRR profile, in meters.
  /// Example: /// Example: 22
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h30(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H30, Some(0)).unwrap()}
  }
  /// Standard deviation of estimate of the object length, expressed in meters.
  /// Example: /// Example: 55
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h31(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MtiHRR_Ingest::VT_H31, Some(0)).unwrap()}
  }
  /// Standard deviation of estimate of the object length, expressed in meters.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  #[inline]
  pub fn h32(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MtiHRR_Ingest::VT_H32, None)}
  }
}

impl flatbuffers::Verifiable for MtiHRR_Ingest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("h2", Self::VT_H2, false)?
     .visit_field::<i32>("h3", Self::VT_H3, false)?
     .visit_field::<bool>("h4", Self::VT_H4, false)?
     .visit_field::<i32>("h5", Self::VT_H5, false)?
     .visit_field::<i32>("h6", Self::VT_H6, false)?
     .visit_field::<i32>("h7", Self::VT_H7, false)?
     .visit_field::<i32>("h8", Self::VT_H8, false)?
     .visit_field::<i32>("h9", Self::VT_H9, false)?
     .visit_field::<i32>("h10", Self::VT_H10, false)?
     .visit_field::<f64>("h11", Self::VT_H11, false)?
     .visit_field::<f64>("h12", Self::VT_H12, false)?
     .visit_field::<f64>("h13", Self::VT_H13, false)?
     .visit_field::<f64>("h14", Self::VT_H14, false)?
     .visit_field::<f64>("h15", Self::VT_H15, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("h16", Self::VT_H16, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("h17", Self::VT_H17, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("h18", Self::VT_H18, false)?
     .visit_field::<f64>("h19", Self::VT_H19, false)?
     .visit_field::<i32>("h20", Self::VT_H20, false)?
     .visit_field::<i32>("h21", Self::VT_H21, false)?
     .visit_field::<i32>("h22", Self::VT_H22, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("h23", Self::VT_H23, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("h24", Self::VT_H24, false)?
     .visit_field::<i32>("h27", Self::VT_H27, false)?
     .visit_field::<i64>("h28", Self::VT_H28, false)?
     .visit_field::<i32>("h29", Self::VT_H29, false)?
     .visit_field::<i32>("h30", Self::VT_H30, false)?
     .visit_field::<i32>("h31", Self::VT_H31, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("h32", Self::VT_H32, false)?
     .finish();
    Ok(())
  }
}
pub struct MtiHRR_IngestArgs<'a> {
    pub h2: i32,
    pub h3: i32,
    pub h4: bool,
    pub h5: i32,
    pub h6: i32,
    pub h7: i32,
    pub h8: i32,
    pub h9: i32,
    pub h10: i32,
    pub h11: f64,
    pub h12: f64,
    pub h13: f64,
    pub h14: f64,
    pub h15: f64,
    pub h16: Option<flatbuffers::WIPOffset<&'a str>>,
    pub h17: Option<flatbuffers::WIPOffset<&'a str>>,
    pub h18: Option<flatbuffers::WIPOffset<&'a str>>,
    pub h19: f64,
    pub h20: i32,
    pub h21: i32,
    pub h22: i32,
    pub h23: Option<flatbuffers::WIPOffset<&'a str>>,
    pub h24: Option<flatbuffers::WIPOffset<&'a str>>,
    pub h27: i32,
    pub h28: i64,
    pub h29: i32,
    pub h30: i32,
    pub h31: i32,
    pub h32: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for MtiHRR_IngestArgs<'a> {
  #[inline]
  fn default() -> Self {
    MtiHRR_IngestArgs {
      h2: 0,
      h3: 0,
      h4: false,
      h5: 0,
      h6: 0,
      h7: 0,
      h8: 0,
      h9: 0,
      h10: 0,
      h11: 0.0,
      h12: 0.0,
      h13: 0.0,
      h14: 0.0,
      h15: 0.0,
      h16: None,
      h17: None,
      h18: None,
      h19: 0.0,
      h20: 0,
      h21: 0,
      h22: 0,
      h23: None,
      h24: None,
      h27: 0,
      h28: 0,
      h29: 0,
      h30: 0,
      h31: 0,
      h32: None,
    }
  }
}

pub struct MtiHRR_IngestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MtiHRR_IngestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_h2(&mut self, h2: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H2, h2, 0);
  }
  #[inline]
  pub fn add_h3(&mut self, h3: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H3, h3, 0);
  }
  #[inline]
  pub fn add_h4(&mut self, h4: bool) {
    self.fbb_.push_slot::<bool>(MtiHRR_Ingest::VT_H4, h4, false);
  }
  #[inline]
  pub fn add_h5(&mut self, h5: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H5, h5, 0);
  }
  #[inline]
  pub fn add_h6(&mut self, h6: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H6, h6, 0);
  }
  #[inline]
  pub fn add_h7(&mut self, h7: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H7, h7, 0);
  }
  #[inline]
  pub fn add_h8(&mut self, h8: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H8, h8, 0);
  }
  #[inline]
  pub fn add_h9(&mut self, h9: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H9, h9, 0);
  }
  #[inline]
  pub fn add_h10(&mut self, h10: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H10, h10, 0);
  }
  #[inline]
  pub fn add_h11(&mut self, h11: f64) {
    self.fbb_.push_slot::<f64>(MtiHRR_Ingest::VT_H11, h11, 0.0);
  }
  #[inline]
  pub fn add_h12(&mut self, h12: f64) {
    self.fbb_.push_slot::<f64>(MtiHRR_Ingest::VT_H12, h12, 0.0);
  }
  #[inline]
  pub fn add_h13(&mut self, h13: f64) {
    self.fbb_.push_slot::<f64>(MtiHRR_Ingest::VT_H13, h13, 0.0);
  }
  #[inline]
  pub fn add_h14(&mut self, h14: f64) {
    self.fbb_.push_slot::<f64>(MtiHRR_Ingest::VT_H14, h14, 0.0);
  }
  #[inline]
  pub fn add_h15(&mut self, h15: f64) {
    self.fbb_.push_slot::<f64>(MtiHRR_Ingest::VT_H15, h15, 0.0);
  }
  #[inline]
  pub fn add_h16(&mut self, h16: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MtiHRR_Ingest::VT_H16, h16);
  }
  #[inline]
  pub fn add_h17(&mut self, h17: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MtiHRR_Ingest::VT_H17, h17);
  }
  #[inline]
  pub fn add_h18(&mut self, h18: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MtiHRR_Ingest::VT_H18, h18);
  }
  #[inline]
  pub fn add_h19(&mut self, h19: f64) {
    self.fbb_.push_slot::<f64>(MtiHRR_Ingest::VT_H19, h19, 0.0);
  }
  #[inline]
  pub fn add_h20(&mut self, h20: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H20, h20, 0);
  }
  #[inline]
  pub fn add_h21(&mut self, h21: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H21, h21, 0);
  }
  #[inline]
  pub fn add_h22(&mut self, h22: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H22, h22, 0);
  }
  #[inline]
  pub fn add_h23(&mut self, h23: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MtiHRR_Ingest::VT_H23, h23);
  }
  #[inline]
  pub fn add_h24(&mut self, h24: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MtiHRR_Ingest::VT_H24, h24);
  }
  #[inline]
  pub fn add_h27(&mut self, h27: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H27, h27, 0);
  }
  #[inline]
  pub fn add_h28(&mut self, h28: i64) {
    self.fbb_.push_slot::<i64>(MtiHRR_Ingest::VT_H28, h28, 0);
  }
  #[inline]
  pub fn add_h29(&mut self, h29: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H29, h29, 0);
  }
  #[inline]
  pub fn add_h30(&mut self, h30: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H30, h30, 0);
  }
  #[inline]
  pub fn add_h31(&mut self, h31: i32) {
    self.fbb_.push_slot::<i32>(MtiHRR_Ingest::VT_H31, h31, 0);
  }
  #[inline]
  pub fn add_h32(&mut self, h32: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MtiHRR_Ingest::VT_H32, h32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MtiHRR_IngestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MtiHRR_IngestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MtiHRR_Ingest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MtiHRR_Ingest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MtiHRR_Ingest");
      ds.field("h2", &self.h2());
      ds.field("h3", &self.h3());
      ds.field("h4", &self.h4());
      ds.field("h5", &self.h5());
      ds.field("h6", &self.h6());
      ds.field("h7", &self.h7());
      ds.field("h8", &self.h8());
      ds.field("h9", &self.h9());
      ds.field("h10", &self.h10());
      ds.field("h11", &self.h11());
      ds.field("h12", &self.h12());
      ds.field("h13", &self.h13());
      ds.field("h14", &self.h14());
      ds.field("h15", &self.h15());
      ds.field("h16", &self.h16());
      ds.field("h17", &self.h17());
      ds.field("h18", &self.h18());
      ds.field("h19", &self.h19());
      ds.field("h20", &self.h20());
      ds.field("h21", &self.h21());
      ds.field("h22", &self.h22());
      ds.field("h23", &self.h23());
      ds.field("h24", &self.h24());
      ds.field("h27", &self.h27());
      ds.field("h28", &self.h28());
      ds.field("h29", &self.h29());
      ds.field("h30", &self.h30());
      ds.field("h31", &self.h31());
      ds.field("h32", &self.h32());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MtiHRR_IngestT {
  pub h2: i32,
  pub h3: i32,
  pub h4: bool,
  pub h5: i32,
  pub h6: i32,
  pub h7: i32,
  pub h8: i32,
  pub h9: i32,
  pub h10: i32,
  pub h11: f64,
  pub h12: f64,
  pub h13: f64,
  pub h14: f64,
  pub h15: f64,
  pub h16: Option<String>,
  pub h17: Option<String>,
  pub h18: Option<String>,
  pub h19: f64,
  pub h20: i32,
  pub h21: i32,
  pub h22: i32,
  pub h23: Option<String>,
  pub h24: Option<String>,
  pub h27: i32,
  pub h28: i64,
  pub h29: i32,
  pub h30: i32,
  pub h31: i32,
  pub h32: Option<Vec<String>>,
}
impl Default for MtiHRR_IngestT {
  fn default() -> Self {
    Self {
      h2: 0,
      h3: 0,
      h4: false,
      h5: 0,
      h6: 0,
      h7: 0,
      h8: 0,
      h9: 0,
      h10: 0,
      h11: 0.0,
      h12: 0.0,
      h13: 0.0,
      h14: 0.0,
      h15: 0.0,
      h16: None,
      h17: None,
      h18: None,
      h19: 0.0,
      h20: 0,
      h21: 0,
      h22: 0,
      h23: None,
      h24: None,
      h27: 0,
      h28: 0,
      h29: 0,
      h30: 0,
      h31: 0,
      h32: None,
    }
  }
}
impl MtiHRR_IngestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MtiHRR_Ingest<'b>> {
    let h2 = self.h2;
    let h3 = self.h3;
    let h4 = self.h4;
    let h5 = self.h5;
    let h6 = self.h6;
    let h7 = self.h7;
    let h8 = self.h8;
    let h9 = self.h9;
    let h10 = self.h10;
    let h11 = self.h11;
    let h12 = self.h12;
    let h13 = self.h13;
    let h14 = self.h14;
    let h15 = self.h15;
    let h16 = self.h16.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let h17 = self.h17.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let h18 = self.h18.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let h19 = self.h19;
    let h20 = self.h20;
    let h21 = self.h21;
    let h22 = self.h22;
    let h23 = self.h23.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let h24 = self.h24.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let h27 = self.h27;
    let h28 = self.h28;
    let h29 = self.h29;
    let h30 = self.h30;
    let h31 = self.h31;
    let h32 = self.h32.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    MtiHRR_Ingest::create(_fbb, &MtiHRR_IngestArgs{
      h2,
      h3,
      h4,
      h5,
      h6,
      h7,
      h8,
      h9,
      h10,
      h11,
      h12,
      h13,
      h14,
      h15,
      h16,
      h17,
      h18,
      h19,
      h20,
      h21,
      h22,
      h23,
      h24,
      h27,
      h28,
      h29,
      h30,
      h31,
      h32,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `MtiHRR_Ingest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mti_hrr_ingest_unchecked`.
pub fn root_as_mti_hrr_ingest(buf: &[u8]) -> Result<MtiHRR_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MtiHRR_Ingest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MtiHRR_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_mti_hrr_ingest_unchecked`.
pub fn size_prefixed_root_as_mti_hrr_ingest(buf: &[u8]) -> Result<MtiHRR_Ingest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MtiHRR_Ingest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MtiHRR_Ingest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mti_hrr_ingest_unchecked`.
pub fn root_as_mti_hrr_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MtiHRR_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MtiHRR_Ingest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MtiHRR_Ingest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mti_hrr_ingest_unchecked`.
pub fn size_prefixed_root_as_mti_hrr_ingest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MtiHRR_Ingest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MtiHRR_Ingest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MtiHRR_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MtiHRR_Ingest`.
pub unsafe fn root_as_mti_hrr_ingest_unchecked(buf: &[u8]) -> MtiHRR_Ingest {
  flatbuffers::root_unchecked::<MtiHRR_Ingest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MtiHRR_Ingest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MtiHRR_Ingest`.
pub unsafe fn size_prefixed_root_as_mti_hrr_ingest_unchecked(buf: &[u8]) -> MtiHRR_Ingest {
  flatbuffers::size_prefixed_root_unchecked::<MtiHRR_Ingest>(buf)
}
pub const MTI_HRR_INGEST_IDENTIFIER: &str = "MTIH";

#[inline]
pub fn mti_hrr_ingest_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MTI_HRR_INGEST_IDENTIFIER, false)
}

#[inline]
pub fn mti_hrr_ingest_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MTI_HRR_INGEST_IDENTIFIER, true)
}

#[inline]
pub fn finish_mti_hrr_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<MtiHRR_Ingest<'a>>) {
  fbb.finish(root, Some(MTI_HRR_INGEST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_mti_hrr_ingest_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<MtiHRR_Ingest<'a>>) {
  fbb.finish_size_prefixed(root, Some(MTI_HRR_INGEST_IDENTIFIER));
}
