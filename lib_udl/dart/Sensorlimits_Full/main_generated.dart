// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class SensorlimitsFullDataModeEnum {
  final int value;
  const SensorlimitsFullDataModeEnum._(this.value);

  factory SensorlimitsFullDataModeEnum.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum SensorlimitsFullDataModeEnum');
    }
    return result;
  }

  static SensorlimitsFullDataModeEnum? _createOrNull(int? value) => 
      value == null ? null : SensorlimitsFullDataModeEnum.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 3;
  static bool containsValue(int value) => values.containsKey(value);

  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  static const SensorlimitsFullDataModeEnum REAL = SensorlimitsFullDataModeEnum._(0);

  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  static const SensorlimitsFullDataModeEnum TEST = SensorlimitsFullDataModeEnum._(1);

  ///  Synthetic data generated by a model to mimic real-world datasets.
  static const SensorlimitsFullDataModeEnum SIMULATED = SensorlimitsFullDataModeEnum._(2);

  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  static const SensorlimitsFullDataModeEnum EXERCISE = SensorlimitsFullDataModeEnum._(3);
  static const Map<int, SensorlimitsFullDataModeEnum> values = {
    0: REAL,
    1: TEST,
    2: SIMULATED,
    3: EXERCISE};

  static const fb.Reader<SensorlimitsFullDataModeEnum> reader = _SensorlimitsFullDataModeEnumReader();

  @override
  String toString() {
    return 'SensorlimitsFullDataModeEnum{value: $value}';
  }
}

class _SensorlimitsFullDataModeEnumReader extends fb.Reader<SensorlimitsFullDataModeEnum> {
  const _SensorlimitsFullDataModeEnumReader();

  @override
  int get size => 1;

  @override
  SensorlimitsFullDataModeEnum read(fb.BufferContext bc, int offset) =>
      SensorlimitsFullDataModeEnum.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  /// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
class SensorlimitsFull {
  SensorlimitsFull._(this._bc, this._bcOffset);
  factory SensorlimitsFull(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<SensorlimitsFull> reader = _SensorlimitsFullReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: SENSORLIMITS-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  String? get idSensorLimits => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  String? get classificationMarking => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  String? get origNetwork => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 8);
  ///  Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get upperLeftAzimuthLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 10, 0.0);
  ///  Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get upperRightAzimuthLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 12, 0.0);
  ///  Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get lowerRightAzimuthLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 14, 0.0);
  ///  Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get lowerLeftAzimuthLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 16, 0.0);
  ///  Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get lowerLeftElevationLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 18, 0.0);
  ///  Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get upperLeftElevationLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 20, 0.0);
  ///  Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get lowerRightElevationLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 22, 0.0);
  ///  Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get upperRightElevationLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 24, 0.0);
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  String? get source => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 26);
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  SensorlimitsFullDataModeEnum get dataMode => SensorlimitsFullDataModeEnum.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 28, 0));
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  String? get createdAt => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 30);
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  String? get createdBy => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 32);
  ///  Time the row was last updated in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  String? get updatedAt => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 34);
  ///  Application user who updated the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 0, Maximum length = 64
  String? get updatedBy => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 36);
  ///  Unique identifier of the target sensor object.
  ///  Example: /// Example: SENSORLIMITS-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  String? get idSensor => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 38);

  @override
  String toString() {
    return 'SensorlimitsFull{idSensorLimits: ${idSensorLimits}, classificationMarking: ${classificationMarking}, origNetwork: ${origNetwork}, upperLeftAzimuthLimit: ${upperLeftAzimuthLimit}, upperRightAzimuthLimit: ${upperRightAzimuthLimit}, lowerRightAzimuthLimit: ${lowerRightAzimuthLimit}, lowerLeftAzimuthLimit: ${lowerLeftAzimuthLimit}, lowerLeftElevationLimit: ${lowerLeftElevationLimit}, upperLeftElevationLimit: ${upperLeftElevationLimit}, lowerRightElevationLimit: ${lowerRightElevationLimit}, upperRightElevationLimit: ${upperRightElevationLimit}, source: ${source}, dataMode: ${dataMode}, createdAt: ${createdAt}, createdBy: ${createdBy}, updatedAt: ${updatedAt}, updatedBy: ${updatedBy}, idSensor: ${idSensor}}';
  }
}

class _SensorlimitsFullReader extends fb.TableReader<SensorlimitsFull> {
  const _SensorlimitsFullReader();

  @override
  SensorlimitsFull createObject(fb.BufferContext bc, int offset) => 
    SensorlimitsFull._(bc, offset);
}

class SensorlimitsFullBuilder {
  SensorlimitsFullBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(18);
  }

  int addIdSensorLimitsOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addClassificationMarkingOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addOrigNetworkOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }
  int addUpperLeftAzimuthLimit(double? upperLeftAzimuthLimit) {
    fbBuilder.addFloat64(3, upperLeftAzimuthLimit);
    return fbBuilder.offset;
  }
  int addUpperRightAzimuthLimit(double? upperRightAzimuthLimit) {
    fbBuilder.addFloat64(4, upperRightAzimuthLimit);
    return fbBuilder.offset;
  }
  int addLowerRightAzimuthLimit(double? lowerRightAzimuthLimit) {
    fbBuilder.addFloat64(5, lowerRightAzimuthLimit);
    return fbBuilder.offset;
  }
  int addLowerLeftAzimuthLimit(double? lowerLeftAzimuthLimit) {
    fbBuilder.addFloat64(6, lowerLeftAzimuthLimit);
    return fbBuilder.offset;
  }
  int addLowerLeftElevationLimit(double? lowerLeftElevationLimit) {
    fbBuilder.addFloat64(7, lowerLeftElevationLimit);
    return fbBuilder.offset;
  }
  int addUpperLeftElevationLimit(double? upperLeftElevationLimit) {
    fbBuilder.addFloat64(8, upperLeftElevationLimit);
    return fbBuilder.offset;
  }
  int addLowerRightElevationLimit(double? lowerRightElevationLimit) {
    fbBuilder.addFloat64(9, lowerRightElevationLimit);
    return fbBuilder.offset;
  }
  int addUpperRightElevationLimit(double? upperRightElevationLimit) {
    fbBuilder.addFloat64(10, upperRightElevationLimit);
    return fbBuilder.offset;
  }
  int addSourceOffset(int? offset) {
    fbBuilder.addOffset(11, offset);
    return fbBuilder.offset;
  }
  int addDataMode(SensorlimitsFullDataModeEnum? dataMode) {
    fbBuilder.addInt8(12, dataMode?.value);
    return fbBuilder.offset;
  }
  int addCreatedAtOffset(int? offset) {
    fbBuilder.addOffset(13, offset);
    return fbBuilder.offset;
  }
  int addCreatedByOffset(int? offset) {
    fbBuilder.addOffset(14, offset);
    return fbBuilder.offset;
  }
  int addUpdatedAtOffset(int? offset) {
    fbBuilder.addOffset(15, offset);
    return fbBuilder.offset;
  }
  int addUpdatedByOffset(int? offset) {
    fbBuilder.addOffset(16, offset);
    return fbBuilder.offset;
  }
  int addIdSensorOffset(int? offset) {
    fbBuilder.addOffset(17, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class SensorlimitsFullObjectBuilder extends fb.ObjectBuilder {
  final String? _idSensorLimits;
  final String? _classificationMarking;
  final String? _origNetwork;
  final double? _upperLeftAzimuthLimit;
  final double? _upperRightAzimuthLimit;
  final double? _lowerRightAzimuthLimit;
  final double? _lowerLeftAzimuthLimit;
  final double? _lowerLeftElevationLimit;
  final double? _upperLeftElevationLimit;
  final double? _lowerRightElevationLimit;
  final double? _upperRightElevationLimit;
  final String? _source;
  final SensorlimitsFullDataModeEnum? _dataMode;
  final String? _createdAt;
  final String? _createdBy;
  final String? _updatedAt;
  final String? _updatedBy;
  final String? _idSensor;

  SensorlimitsFullObjectBuilder({
    String? idSensorLimits,
    String? classificationMarking,
    String? origNetwork,
    double? upperLeftAzimuthLimit,
    double? upperRightAzimuthLimit,
    double? lowerRightAzimuthLimit,
    double? lowerLeftAzimuthLimit,
    double? lowerLeftElevationLimit,
    double? upperLeftElevationLimit,
    double? lowerRightElevationLimit,
    double? upperRightElevationLimit,
    String? source,
    SensorlimitsFullDataModeEnum? dataMode,
    String? createdAt,
    String? createdBy,
    String? updatedAt,
    String? updatedBy,
    String? idSensor,
  })
      : _idSensorLimits = idSensorLimits,
        _classificationMarking = classificationMarking,
        _origNetwork = origNetwork,
        _upperLeftAzimuthLimit = upperLeftAzimuthLimit,
        _upperRightAzimuthLimit = upperRightAzimuthLimit,
        _lowerRightAzimuthLimit = lowerRightAzimuthLimit,
        _lowerLeftAzimuthLimit = lowerLeftAzimuthLimit,
        _lowerLeftElevationLimit = lowerLeftElevationLimit,
        _upperLeftElevationLimit = upperLeftElevationLimit,
        _lowerRightElevationLimit = lowerRightElevationLimit,
        _upperRightElevationLimit = upperRightElevationLimit,
        _source = source,
        _dataMode = dataMode,
        _createdAt = createdAt,
        _createdBy = createdBy,
        _updatedAt = updatedAt,
        _updatedBy = updatedBy,
        _idSensor = idSensor;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? idSensorLimitsOffset = _idSensorLimits == null ? null
        : fbBuilder.writeString(_idSensorLimits!);
    final int? classificationMarkingOffset = _classificationMarking == null ? null
        : fbBuilder.writeString(_classificationMarking!);
    final int? origNetworkOffset = _origNetwork == null ? null
        : fbBuilder.writeString(_origNetwork!);
    final int? sourceOffset = _source == null ? null
        : fbBuilder.writeString(_source!);
    final int? createdAtOffset = _createdAt == null ? null
        : fbBuilder.writeString(_createdAt!);
    final int? createdByOffset = _createdBy == null ? null
        : fbBuilder.writeString(_createdBy!);
    final int? updatedAtOffset = _updatedAt == null ? null
        : fbBuilder.writeString(_updatedAt!);
    final int? updatedByOffset = _updatedBy == null ? null
        : fbBuilder.writeString(_updatedBy!);
    final int? idSensorOffset = _idSensor == null ? null
        : fbBuilder.writeString(_idSensor!);
    fbBuilder.startTable(18);
    fbBuilder.addOffset(0, idSensorLimitsOffset);
    fbBuilder.addOffset(1, classificationMarkingOffset);
    fbBuilder.addOffset(2, origNetworkOffset);
    fbBuilder.addFloat64(3, _upperLeftAzimuthLimit);
    fbBuilder.addFloat64(4, _upperRightAzimuthLimit);
    fbBuilder.addFloat64(5, _lowerRightAzimuthLimit);
    fbBuilder.addFloat64(6, _lowerLeftAzimuthLimit);
    fbBuilder.addFloat64(7, _lowerLeftElevationLimit);
    fbBuilder.addFloat64(8, _upperLeftElevationLimit);
    fbBuilder.addFloat64(9, _lowerRightElevationLimit);
    fbBuilder.addFloat64(10, _upperRightElevationLimit);
    fbBuilder.addOffset(11, sourceOffset);
    fbBuilder.addInt8(12, _dataMode?.value);
    fbBuilder.addOffset(13, createdAtOffset);
    fbBuilder.addOffset(14, createdByOffset);
    fbBuilder.addOffset(15, updatedAtOffset);
    fbBuilder.addOffset(16, updatedByOffset);
    fbBuilder.addOffset(17, idSensorOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
