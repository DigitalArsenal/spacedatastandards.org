// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class SensorlimitsAbridgedDataModeEnum {
  final int value;
  const SensorlimitsAbridgedDataModeEnum._(this.value);

  factory SensorlimitsAbridgedDataModeEnum.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum SensorlimitsAbridgedDataModeEnum');
    }
    return result;
  }

  static SensorlimitsAbridgedDataModeEnum? _createOrNull(int? value) => 
      value == null ? null : SensorlimitsAbridgedDataModeEnum.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 3;
  static bool containsValue(int value) => values.containsKey(value);

  ///  Data collected or produced that pertains to real-world objects, events, and analysis.
  static const SensorlimitsAbridgedDataModeEnum REAL = SensorlimitsAbridgedDataModeEnum._(0);

  ///  Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  static const SensorlimitsAbridgedDataModeEnum TEST = SensorlimitsAbridgedDataModeEnum._(1);

  ///  Synthetic data generated by a model to mimic real-world datasets.
  static const SensorlimitsAbridgedDataModeEnum SIMULATED = SensorlimitsAbridgedDataModeEnum._(2);

  ///  Data pertaining to a government or military exercise. The data may include both real and simulated data.
  static const SensorlimitsAbridgedDataModeEnum EXERCISE = SensorlimitsAbridgedDataModeEnum._(3);
  static const Map<int, SensorlimitsAbridgedDataModeEnum> values = {
    0: REAL,
    1: TEST,
    2: SIMULATED,
    3: EXERCISE};

  static const fb.Reader<SensorlimitsAbridgedDataModeEnum> reader = _SensorlimitsAbridgedDataModeEnumReader();

  @override
  String toString() {
    return 'SensorlimitsAbridgedDataModeEnum{value: $value}';
  }
}

class _SensorlimitsAbridgedDataModeEnumReader extends fb.Reader<SensorlimitsAbridgedDataModeEnum> {
  const _SensorlimitsAbridgedDataModeEnumReader();

  @override
  int get size => 1;

  @override
  SensorlimitsAbridgedDataModeEnum read(fb.BufferContext bc, int offset) =>
      SensorlimitsAbridgedDataModeEnum.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  /// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
class SensorlimitsAbridged {
  SensorlimitsAbridged._(this._bc, this._bcOffset);
  factory SensorlimitsAbridged(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<SensorlimitsAbridged> reader = _SensorlimitsAbridgedReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Unique identifier of the record, auto-generated by the system.
  ///  Example: /// Example: SENSORLIMITS-ID
  ///  Constraints: Minimum length = 1, Maximum length = 36
  String? get idSensorLimits => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  ///  Classification marking of the data in IC/CAPCO Portion-marked format.
  ///  Example: /// Example: U
  ///  Constraints: Minimum length = 1, Maximum length = 128
  String? get classificationMarking => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);
  ///  The originating source network on which this record was created, auto-populated by the system.
  ///  Example: /// Example: ORIG
  ///  Constraints: Minimum length = 1, Maximum length = 32
  String? get origNetwork => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 8);
  ///  Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get upperLeftAzimuthLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 10, 0.0);
  ///  Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get upperRightAzimuthLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 12, 0.0);
  ///  Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get lowerRightAzimuthLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 14, 0.0);
  ///  Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get lowerLeftAzimuthLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 16, 0.0);
  ///  Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get lowerLeftElevationLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 18, 0.0);
  ///  Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get upperLeftElevationLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 20, 0.0);
  ///  Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get lowerRightElevationLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 22, 0.0);
  ///  Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
  ///  Example: /// Example: 1.23
  ///  Constraints: No constraints specified.
  double get upperRightElevationLimit => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 24, 0.0);
  ///  Source of the data.
  ///  Example: /// Example: Bluestaq
  ///  Constraints: Minimum length = 1, Maximum length = 64
  String? get source => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 26);
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  ///  EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  ///  REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  ///  SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  ///  TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  ///  Example: /// Example: TEST
  ///  Constraints: Minimum length = 1, Maximum length = 32
  SensorlimitsAbridgedDataModeEnum get dataMode => SensorlimitsAbridgedDataModeEnum.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 28, 0));
  ///  Time the row was created in the database, auto-populated by the system.
  ///  Example: /// Example: 2018-01-01T16:00:00.123Z
  ///  Constraints: No constraints specified.
  String? get createdAt => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 30);
  ///  Application user who created the row in the database, auto-populated by the system.
  ///  Example: /// Example: some.user
  ///  Constraints: Minimum length = 1, Maximum length = 64
  String? get createdBy => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 32);
  ///  Unique identifier of the target sensor object.
  ///  Example: /// Example: SENSORLIMITS-ID
  ///  Constraints: Minimum length = 0, Maximum length = 36
  String? get idSensor => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 34);

  @override
  String toString() {
    return 'SensorlimitsAbridged{idSensorLimits: ${idSensorLimits}, classificationMarking: ${classificationMarking}, origNetwork: ${origNetwork}, upperLeftAzimuthLimit: ${upperLeftAzimuthLimit}, upperRightAzimuthLimit: ${upperRightAzimuthLimit}, lowerRightAzimuthLimit: ${lowerRightAzimuthLimit}, lowerLeftAzimuthLimit: ${lowerLeftAzimuthLimit}, lowerLeftElevationLimit: ${lowerLeftElevationLimit}, upperLeftElevationLimit: ${upperLeftElevationLimit}, lowerRightElevationLimit: ${lowerRightElevationLimit}, upperRightElevationLimit: ${upperRightElevationLimit}, source: ${source}, dataMode: ${dataMode}, createdAt: ${createdAt}, createdBy: ${createdBy}, idSensor: ${idSensor}}';
  }
}

class _SensorlimitsAbridgedReader extends fb.TableReader<SensorlimitsAbridged> {
  const _SensorlimitsAbridgedReader();

  @override
  SensorlimitsAbridged createObject(fb.BufferContext bc, int offset) => 
    SensorlimitsAbridged._(bc, offset);
}

class SensorlimitsAbridgedBuilder {
  SensorlimitsAbridgedBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(16);
  }

  int addIdSensorLimitsOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addClassificationMarkingOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addOrigNetworkOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }
  int addUpperLeftAzimuthLimit(double? upperLeftAzimuthLimit) {
    fbBuilder.addFloat64(3, upperLeftAzimuthLimit);
    return fbBuilder.offset;
  }
  int addUpperRightAzimuthLimit(double? upperRightAzimuthLimit) {
    fbBuilder.addFloat64(4, upperRightAzimuthLimit);
    return fbBuilder.offset;
  }
  int addLowerRightAzimuthLimit(double? lowerRightAzimuthLimit) {
    fbBuilder.addFloat64(5, lowerRightAzimuthLimit);
    return fbBuilder.offset;
  }
  int addLowerLeftAzimuthLimit(double? lowerLeftAzimuthLimit) {
    fbBuilder.addFloat64(6, lowerLeftAzimuthLimit);
    return fbBuilder.offset;
  }
  int addLowerLeftElevationLimit(double? lowerLeftElevationLimit) {
    fbBuilder.addFloat64(7, lowerLeftElevationLimit);
    return fbBuilder.offset;
  }
  int addUpperLeftElevationLimit(double? upperLeftElevationLimit) {
    fbBuilder.addFloat64(8, upperLeftElevationLimit);
    return fbBuilder.offset;
  }
  int addLowerRightElevationLimit(double? lowerRightElevationLimit) {
    fbBuilder.addFloat64(9, lowerRightElevationLimit);
    return fbBuilder.offset;
  }
  int addUpperRightElevationLimit(double? upperRightElevationLimit) {
    fbBuilder.addFloat64(10, upperRightElevationLimit);
    return fbBuilder.offset;
  }
  int addSourceOffset(int? offset) {
    fbBuilder.addOffset(11, offset);
    return fbBuilder.offset;
  }
  int addDataMode(SensorlimitsAbridgedDataModeEnum? dataMode) {
    fbBuilder.addInt8(12, dataMode?.value);
    return fbBuilder.offset;
  }
  int addCreatedAtOffset(int? offset) {
    fbBuilder.addOffset(13, offset);
    return fbBuilder.offset;
  }
  int addCreatedByOffset(int? offset) {
    fbBuilder.addOffset(14, offset);
    return fbBuilder.offset;
  }
  int addIdSensorOffset(int? offset) {
    fbBuilder.addOffset(15, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class SensorlimitsAbridgedObjectBuilder extends fb.ObjectBuilder {
  final String? _idSensorLimits;
  final String? _classificationMarking;
  final String? _origNetwork;
  final double? _upperLeftAzimuthLimit;
  final double? _upperRightAzimuthLimit;
  final double? _lowerRightAzimuthLimit;
  final double? _lowerLeftAzimuthLimit;
  final double? _lowerLeftElevationLimit;
  final double? _upperLeftElevationLimit;
  final double? _lowerRightElevationLimit;
  final double? _upperRightElevationLimit;
  final String? _source;
  final SensorlimitsAbridgedDataModeEnum? _dataMode;
  final String? _createdAt;
  final String? _createdBy;
  final String? _idSensor;

  SensorlimitsAbridgedObjectBuilder({
    String? idSensorLimits,
    String? classificationMarking,
    String? origNetwork,
    double? upperLeftAzimuthLimit,
    double? upperRightAzimuthLimit,
    double? lowerRightAzimuthLimit,
    double? lowerLeftAzimuthLimit,
    double? lowerLeftElevationLimit,
    double? upperLeftElevationLimit,
    double? lowerRightElevationLimit,
    double? upperRightElevationLimit,
    String? source,
    SensorlimitsAbridgedDataModeEnum? dataMode,
    String? createdAt,
    String? createdBy,
    String? idSensor,
  })
      : _idSensorLimits = idSensorLimits,
        _classificationMarking = classificationMarking,
        _origNetwork = origNetwork,
        _upperLeftAzimuthLimit = upperLeftAzimuthLimit,
        _upperRightAzimuthLimit = upperRightAzimuthLimit,
        _lowerRightAzimuthLimit = lowerRightAzimuthLimit,
        _lowerLeftAzimuthLimit = lowerLeftAzimuthLimit,
        _lowerLeftElevationLimit = lowerLeftElevationLimit,
        _upperLeftElevationLimit = upperLeftElevationLimit,
        _lowerRightElevationLimit = lowerRightElevationLimit,
        _upperRightElevationLimit = upperRightElevationLimit,
        _source = source,
        _dataMode = dataMode,
        _createdAt = createdAt,
        _createdBy = createdBy,
        _idSensor = idSensor;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? idSensorLimitsOffset = _idSensorLimits == null ? null
        : fbBuilder.writeString(_idSensorLimits!);
    final int? classificationMarkingOffset = _classificationMarking == null ? null
        : fbBuilder.writeString(_classificationMarking!);
    final int? origNetworkOffset = _origNetwork == null ? null
        : fbBuilder.writeString(_origNetwork!);
    final int? sourceOffset = _source == null ? null
        : fbBuilder.writeString(_source!);
    final int? createdAtOffset = _createdAt == null ? null
        : fbBuilder.writeString(_createdAt!);
    final int? createdByOffset = _createdBy == null ? null
        : fbBuilder.writeString(_createdBy!);
    final int? idSensorOffset = _idSensor == null ? null
        : fbBuilder.writeString(_idSensor!);
    fbBuilder.startTable(16);
    fbBuilder.addOffset(0, idSensorLimitsOffset);
    fbBuilder.addOffset(1, classificationMarkingOffset);
    fbBuilder.addOffset(2, origNetworkOffset);
    fbBuilder.addFloat64(3, _upperLeftAzimuthLimit);
    fbBuilder.addFloat64(4, _upperRightAzimuthLimit);
    fbBuilder.addFloat64(5, _lowerRightAzimuthLimit);
    fbBuilder.addFloat64(6, _lowerLeftAzimuthLimit);
    fbBuilder.addFloat64(7, _lowerLeftElevationLimit);
    fbBuilder.addFloat64(8, _upperLeftElevationLimit);
    fbBuilder.addFloat64(9, _lowerRightElevationLimit);
    fbBuilder.addFloat64(10, _upperRightElevationLimit);
    fbBuilder.addOffset(11, sourceOffset);
    fbBuilder.addInt8(12, _dataMode?.value);
    fbBuilder.addOffset(13, createdAtOffset);
    fbBuilder.addOffset(14, createdByOffset);
    fbBuilder.addOffset(15, idSensorOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
