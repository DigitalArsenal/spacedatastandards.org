// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package AirspaceControlMeans_Abridged

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// /// A conditional nested segment to report multiple airspace control means within a particular airspace control means status.
type AirspaceControlMeans_Abridged struct {
	_tab flatbuffers.Table
}

const AirspaceControlMeans_AbridgedIdentifier = "AIRS"

func GetRootAsAirspaceControlMeans_Abridged(buf []byte, offset flatbuffers.UOffsetT) *AirspaceControlMeans_Abridged {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &AirspaceControlMeans_Abridged{}
	x.Init(buf, n+offset)
	return x
}

func FinishAirspaceControlMeans_AbridgedBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(AirspaceControlMeans_AbridgedIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func AirspaceControlMeans_AbridgedBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, AirspaceControlMeans_AbridgedIdentifier)
}

func GetSizePrefixedRootAsAirspaceControlMeans_Abridged(buf []byte, offset flatbuffers.UOffsetT) *AirspaceControlMeans_Abridged {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &AirspaceControlMeans_Abridged{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedAirspaceControlMeans_AbridgedBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(AirspaceControlMeans_AbridgedIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedAirspaceControlMeans_AbridgedBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, AirspaceControlMeans_AbridgedIdentifier)
}

func (rcv *AirspaceControlMeans_Abridged) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *AirspaceControlMeans_Abridged) Table() flatbuffers.Table {
	return rcv._tab
}

/// The code for the type of airspace control means.
/// Example: /// Example: ACM:ADAREA
/// Constraints: Minimum length = 0, Maximum length = 8
func (rcv *AirspaceControlMeans_Abridged) CmType() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The code for the type of airspace control means.
/// Example: /// Example: ACM:ADAREA
/// Constraints: Minimum length = 0, Maximum length = 8
/// Airspace control means name or designator.
/// Example: /// Example: DESIG:C34
/// Constraints: Minimum length = 0, Maximum length = 32
func (rcv *AirspaceControlMeans_Abridged) CmId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Airspace control means name or designator.
/// Example: /// Example: DESIG:C34
/// Constraints: Minimum length = 0, Maximum length = 32
/// Designates the geometric type that defines the airspace shape. One of CIRCLE, CORRIDOR, LINE, ORBIT, etc.
/// Example: /// Example: POLYARC
/// Constraints: Minimum length = 0, Maximum length = 8
func (rcv *AirspaceControlMeans_Abridged) CmShape() AirspaceControlMeans_Abridged_cmShape_Enum {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return AirspaceControlMeans_Abridged_cmShape_Enum(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Designates the geometric type that defines the airspace shape. One of CIRCLE, CORRIDOR, LINE, ORBIT, etc.
/// Example: /// Example: POLYARC
/// Constraints: Minimum length = 0, Maximum length = 8
func (rcv *AirspaceControlMeans_Abridged) MutateCmShape(n AirspaceControlMeans_Abridged_cmShape_Enum) bool {
	return rcv._tab.MutateInt8Slot(8, int8(n))
}

/// Designates the means by which a defined airspace control means is to be used.
/// Example: /// Example: USE:AIRCOR
/// Constraints: Minimum length = 0, Maximum length = 8
func (rcv *AirspaceControlMeans_Abridged) Usage() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Designates the means by which a defined airspace control means is to be used.
/// Example: /// Example: USE:AIRCOR
/// Constraints: Minimum length = 0, Maximum length = 8
/// Unique Link 16 identifier assigned to the airspace control means.
/// Example: /// Example: F3356
/// Constraints: Minimum length = 0, Maximum length = 8
func (rcv *AirspaceControlMeans_Abridged) Link16Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique Link 16 identifier assigned to the airspace control means.
/// Example: /// Example: F3356
/// Constraints: Minimum length = 0, Maximum length = 8
/// The altitude at or below which the vertical position of an aircraft is controlled by reference to true altitude.
/// Example: /// Example: 18000FT
/// Constraints: Minimum length = 0, Maximum length = 8
func (rcv *AirspaceControlMeans_Abridged) TransAltitude() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The altitude at or below which the vertical position of an aircraft is controlled by reference to true altitude.
/// Example: /// Example: 18000FT
/// Constraints: Minimum length = 0, Maximum length = 8
/// Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated, if different from the top level ACO datum.
/// Example: /// Example: NAR
/// Constraints: Minimum length = 0, Maximum length = 8
func (rcv *AirspaceControlMeans_Abridged) GeoDatumAlt() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated, if different from the top level ACO datum.
/// Example: /// Example: NAR
/// Constraints: Minimum length = 0, Maximum length = 8
/// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
/// Example: /// Example: 152345N0505657E
/// Constraints: Minimum length = 0, Maximum length = 16
func (rcv *AirspaceControlMeans_Abridged) Coord0() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
/// Example: /// Example: 152345N0505657E
/// Constraints: Minimum length = 0, Maximum length = 16
/// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
/// Example: /// Example: 1523N05057E
/// Constraints: Minimum length = 0, Maximum length = 16
func (rcv *AirspaceControlMeans_Abridged) Coord1() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
/// Example: /// Example: 1523N05057E
/// Constraints: Minimum length = 0, Maximum length = 16
/// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "beginning" radial bearing parameter.
/// Example: /// Example: 330
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) Bearing0() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "beginning" radial bearing parameter.
/// Example: /// Example: 330
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) MutateBearing0(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

/// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "ending" radial bearing parameter.
/// Example: /// Example: 160
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) Bearing1() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "ending" radial bearing parameter.
/// Example: /// Example: 160
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) MutateBearing1(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "inner" radial magnitude arc limit. If provided, the field radMagUnit is required.
/// Example: /// Example: 30.04
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) RadMag0() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "inner" radial magnitude arc limit. If provided, the field radMagUnit is required.
/// Example: /// Example: 30.04
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) MutateRadMag0(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "outer" radial magnitude arc limit. If provided, the field radMagUnit is required.
/// Example: /// Example: 50.12
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) RadMag1() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "outer" radial magnitude arc limit. If provided, the field radMagUnit is required.
/// Example: /// Example: 50.12
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) MutateRadMag1(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

/// Specifies the unit of length in which radial magnitudes are given. Use M for meters, KM for kilometers, or NM for nautical miles.
/// Example: /// Example: NM
/// Constraints: Minimum length = 0, Maximum length = 8
func (rcv *AirspaceControlMeans_Abridged) RadMagUnit() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Specifies the unit of length in which radial magnitudes are given. Use M for meters, KM for kilometers, or NM for nautical miles.
/// Example: /// Example: NM
/// Constraints: Minimum length = 0, Maximum length = 8
/// A set of geospatial coordinates specified in DMS (Degrees, Minutes, Seconds) format which determine the vertices of a one or two dimensional geospatial shape. When shape is set to "POLYARC" or "POLYGON," this field is required as applied in the construction of the area boundary. If cmShape is set to "COORIDOR" or "GEOLINE," this field is required and can be interpreted as an ordered set of points along a path in space.
/// Example: /// Example: ['203632N0594256E', '155000N0594815E', '155000N0591343E']
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) PolyCoord(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AirspaceControlMeans_Abridged) PolyCoordLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// A set of geospatial coordinates specified in DMS (Degrees, Minutes, Seconds) format which determine the vertices of a one or two dimensional geospatial shape. When shape is set to "POLYARC" or "POLYGON," this field is required as applied in the construction of the area boundary. If cmShape is set to "COORIDOR" or "GEOLINE," this field is required and can be interpreted as an ordered set of points along a path in space.
/// Example: /// Example: ['203632N0594256E', '155000N0594815E', '155000N0591343E']
/// Constraints: No constraints specified.
/// Index of a segment in an airtrack, which is defined by an ordered set of points.
/// Example: /// Example: 99
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) TrackLeg() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Index of a segment in an airtrack, which is defined by an ordered set of points.
/// Example: /// Example: 99
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) MutateTrackLeg(n int32) bool {
	return rcv._tab.MutateInt32Slot(34, n)
}

/// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the LEFT half-plane realtive to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the left of the track segment line. If provided, the field widthUnit is required.
/// Example: /// Example: 5.2
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) WidthLeft() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the LEFT half-plane realtive to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the left of the track segment line. If provided, the field widthUnit is required.
/// Example: /// Example: 5.2
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) MutateWidthLeft(n float64) bool {
	return rcv._tab.MutateFloat64Slot(36, n)
}

/// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the RIGHT half-plane relative to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the right of the track segment line. If provided, the field widthUnit is required.
/// Example: /// Example: 10.4
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) WidthRight() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the RIGHT half-plane relative to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the right of the track segment line. If provided, the field widthUnit is required.
/// Example: /// Example: 10.4
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) MutateWidthRight(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

/// Used to describe the "side to side" distance of a target, object or area. If cmShape is set to "CORRIDOR" or "AORBIT", this field is required and is mapped to the width parameter. If provided, the field widthUnit is required.
/// Example: /// Example: 15.6
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) Width() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Used to describe the "side to side" distance of a target, object or area. If cmShape is set to "CORRIDOR" or "AORBIT", this field is required and is mapped to the width parameter. If provided, the field widthUnit is required.
/// Example: /// Example: 15.6
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) MutateWidth(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// Specifies the unit of length for which widths are given. Use M for meters, KM for kilometers, or NM for nautical miles.
/// Example: /// Example: KM
/// Constraints: Minimum length = 0, Maximum length = 8
func (rcv *AirspaceControlMeans_Abridged) WidthUnit() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Specifies the unit of length for which widths are given. Use M for meters, KM for kilometers, or NM for nautical miles.
/// Example: /// Example: KM
/// Constraints: Minimum length = 0, Maximum length = 8
/// An array of at least two alphanumeric symbols used to serially identify the corridor waypoints. If cmShape is set to "CORRIDOR," one of either corrWayPoints or polyCoord is required to specify the centerline of the corridor path.
/// Example: /// Example: ['POB', 'RDU', 'IAD']
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) CorrWayPoints(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AirspaceControlMeans_Abridged) CorrWayPointsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// An array of at least two alphanumeric symbols used to serially identify the corridor waypoints. If cmShape is set to "CORRIDOR," one of either corrWayPoints or polyCoord is required to specify the centerline of the corridor path.
/// Example: /// Example: ['POB', 'RDU', 'IAD']
/// Constraints: No constraints specified.
/// Orbit alignment look-up code. Can be C=Center, L=Left, R=Right.
/// Example: /// Example: C
/// Constraints: Minimum length = 0, Maximum length = 1
func (rcv *AirspaceControlMeans_Abridged) OrbitAlignment() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Orbit alignment look-up code. Can be C=Center, L=Left, R=Right.
/// Example: /// Example: C
/// Constraints: Minimum length = 0, Maximum length = 1
/// Description of the airspace vertical dimension.
/// Example: /// Example: BRRA:GL-100AGL
/// Constraints: Minimum length = 0, Maximum length = 16
func (rcv *AirspaceControlMeans_Abridged) EffVdim() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Description of the airspace vertical dimension.
/// Example: /// Example: BRRA:GL-100AGL
/// Constraints: Minimum length = 0, Maximum length = 16
/// The timePeriod set describes the effective datetime for a given airspace control means.
/// Example: /// Example: No example provided.
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) AirspaceTimePeriod(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AirspaceControlMeans_Abridged) AirspaceTimePeriodLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// The timePeriod set describes the effective datetime for a given airspace control means.
/// Example: /// Example: No example provided.
/// Constraints: No constraints specified.
/// The controlPoint set describes any reference/controlling/rendevous point for a given airspace control means.
/// Example: /// Example: No example provided.
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) AirspaceControlPoint(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AirspaceControlMeans_Abridged) AirspaceControlPointLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// The controlPoint set describes any reference/controlling/rendevous point for a given airspace control means.
/// Example: /// Example: No example provided.
/// Constraints: No constraints specified.
/// The commander responsible within a specified geographical area for the airspace control operation assigned to him.
/// Example: /// Example: RHEIN MAIN CP
/// Constraints: Minimum length = 0, Maximum length = 36
func (rcv *AirspaceControlMeans_Abridged) CtrlAuth() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The commander responsible within a specified geographical area for the airspace control operation assigned to him.
/// Example: /// Example: RHEIN MAIN CP
/// Constraints: Minimum length = 0, Maximum length = 36
/// The frequency for the airspace control authority. Can specify HZ, KHZ, MHZ, GHZ or a DESIG frequency designator code.
/// Example: /// Example: ['125.25MHZ']
/// Constraints: No constraints specified.
func (rcv *AirspaceControlMeans_Abridged) CtrlAuthFreqs(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AirspaceControlMeans_Abridged) CtrlAuthFreqsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// The frequency for the airspace control authority. Can specify HZ, KHZ, MHZ, GHZ or a DESIG frequency designator code.
/// Example: /// Example: ['125.25MHZ']
/// Constraints: No constraints specified.
/// Used to provide transit intstructions for the airspace control means.
/// Example: /// Example: SITUATION
/// Constraints: Minimum length = 0, Maximum length = 64
func (rcv *AirspaceControlMeans_Abridged) GenTextInd() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Used to provide transit intstructions for the airspace control means.
/// Example: /// Example: SITUATION
/// Constraints: Minimum length = 0, Maximum length = 64
/// General informat detailing the transit instruction for the airspace control means.
/// Example: /// Example: 1. CAPACITY: MDM TK, 50 VEHICLE CONVOY. 2. CHOKE POINTS: EXIT 5
/// Constraints: Minimum length = 0, Maximum length = 128
func (rcv *AirspaceControlMeans_Abridged) FreeText() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// General informat detailing the transit instruction for the airspace control means.
/// Example: /// Example: 1. CAPACITY: MDM TK, 50 VEHICLE CONVOY. 2. CHOKE POINTS: EXIT 5
/// Constraints: Minimum length = 0, Maximum length = 128
func AirspaceControlMeans_AbridgedStart(builder *flatbuffers.Builder) {
	builder.StartObject(29)
}
func AirspaceControlMeans_AbridgedAddCmType(builder *flatbuffers.Builder, cmType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(cmType), 0)
}
func AirspaceControlMeans_AbridgedAddCmId(builder *flatbuffers.Builder, cmId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(cmId), 0)
}
func AirspaceControlMeans_AbridgedAddCmShape(builder *flatbuffers.Builder, cmShape AirspaceControlMeans_Abridged_cmShape_Enum) {
	builder.PrependInt8Slot(2, int8(cmShape), 0)
}
func AirspaceControlMeans_AbridgedAddUsage(builder *flatbuffers.Builder, usage flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(usage), 0)
}
func AirspaceControlMeans_AbridgedAddLink16Id(builder *flatbuffers.Builder, link16Id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(link16Id), 0)
}
func AirspaceControlMeans_AbridgedAddTransAltitude(builder *flatbuffers.Builder, transAltitude flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(transAltitude), 0)
}
func AirspaceControlMeans_AbridgedAddGeoDatumAlt(builder *flatbuffers.Builder, geoDatumAlt flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(geoDatumAlt), 0)
}
func AirspaceControlMeans_AbridgedAddCoord0(builder *flatbuffers.Builder, coord0 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(coord0), 0)
}
func AirspaceControlMeans_AbridgedAddCoord1(builder *flatbuffers.Builder, coord1 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(coord1), 0)
}
func AirspaceControlMeans_AbridgedAddBearing0(builder *flatbuffers.Builder, bearing0 float64) {
	builder.PrependFloat64Slot(9, bearing0, 0.0)
}
func AirspaceControlMeans_AbridgedAddBearing1(builder *flatbuffers.Builder, bearing1 float64) {
	builder.PrependFloat64Slot(10, bearing1, 0.0)
}
func AirspaceControlMeans_AbridgedAddRadMag0(builder *flatbuffers.Builder, radMag0 float64) {
	builder.PrependFloat64Slot(11, radMag0, 0.0)
}
func AirspaceControlMeans_AbridgedAddRadMag1(builder *flatbuffers.Builder, radMag1 float64) {
	builder.PrependFloat64Slot(12, radMag1, 0.0)
}
func AirspaceControlMeans_AbridgedAddRadMagUnit(builder *flatbuffers.Builder, radMagUnit flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(radMagUnit), 0)
}
func AirspaceControlMeans_AbridgedAddPolyCoord(builder *flatbuffers.Builder, polyCoord flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(polyCoord), 0)
}
func AirspaceControlMeans_AbridgedStartPolyCoordVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AirspaceControlMeans_AbridgedAddTrackLeg(builder *flatbuffers.Builder, trackLeg int32) {
	builder.PrependInt32Slot(15, trackLeg, 0)
}
func AirspaceControlMeans_AbridgedAddWidthLeft(builder *flatbuffers.Builder, widthLeft float64) {
	builder.PrependFloat64Slot(16, widthLeft, 0.0)
}
func AirspaceControlMeans_AbridgedAddWidthRight(builder *flatbuffers.Builder, widthRight float64) {
	builder.PrependFloat64Slot(17, widthRight, 0.0)
}
func AirspaceControlMeans_AbridgedAddWidth(builder *flatbuffers.Builder, width float64) {
	builder.PrependFloat64Slot(18, width, 0.0)
}
func AirspaceControlMeans_AbridgedAddWidthUnit(builder *flatbuffers.Builder, widthUnit flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(19, flatbuffers.UOffsetT(widthUnit), 0)
}
func AirspaceControlMeans_AbridgedAddCorrWayPoints(builder *flatbuffers.Builder, corrWayPoints flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(20, flatbuffers.UOffsetT(corrWayPoints), 0)
}
func AirspaceControlMeans_AbridgedStartCorrWayPointsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AirspaceControlMeans_AbridgedAddOrbitAlignment(builder *flatbuffers.Builder, orbitAlignment flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(orbitAlignment), 0)
}
func AirspaceControlMeans_AbridgedAddEffVdim(builder *flatbuffers.Builder, effVdim flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(22, flatbuffers.UOffsetT(effVdim), 0)
}
func AirspaceControlMeans_AbridgedAddAirspaceTimePeriod(builder *flatbuffers.Builder, airspaceTimePeriod flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(23, flatbuffers.UOffsetT(airspaceTimePeriod), 0)
}
func AirspaceControlMeans_AbridgedStartAirspaceTimePeriodVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AirspaceControlMeans_AbridgedAddAirspaceControlPoint(builder *flatbuffers.Builder, airspaceControlPoint flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(24, flatbuffers.UOffsetT(airspaceControlPoint), 0)
}
func AirspaceControlMeans_AbridgedStartAirspaceControlPointVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AirspaceControlMeans_AbridgedAddCtrlAuth(builder *flatbuffers.Builder, ctrlAuth flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(25, flatbuffers.UOffsetT(ctrlAuth), 0)
}
func AirspaceControlMeans_AbridgedAddCtrlAuthFreqs(builder *flatbuffers.Builder, ctrlAuthFreqs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(26, flatbuffers.UOffsetT(ctrlAuthFreqs), 0)
}
func AirspaceControlMeans_AbridgedStartCtrlAuthFreqsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AirspaceControlMeans_AbridgedAddGenTextInd(builder *flatbuffers.Builder, genTextInd flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(27, flatbuffers.UOffsetT(genTextInd), 0)
}
func AirspaceControlMeans_AbridgedAddFreeText(builder *flatbuffers.Builder, freeText flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(28, flatbuffers.UOffsetT(freeText), 0)
}
func AirspaceControlMeans_AbridgedEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
