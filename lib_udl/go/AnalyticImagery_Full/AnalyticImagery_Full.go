// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package AnalyticImagery_Full

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// /// The analytic imagery schema supports data plots and graphics of various types. The records contain general file information, allows for annotations to user-defined areas of interest on the graphics, and supports keyword searching.
type AnalyticImagery_Full struct {
	_tab flatbuffers.Table
}

const AnalyticImagery_FullIdentifier = "ANAL"

func GetRootAsAnalyticImagery_Full(buf []byte, offset flatbuffers.UOffsetT) *AnalyticImagery_Full {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &AnalyticImagery_Full{}
	x.Init(buf, n+offset)
	return x
}

func FinishAnalyticImagery_FullBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(AnalyticImagery_FullIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func AnalyticImagery_FullBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, AnalyticImagery_FullIdentifier)
}

func GetSizePrefixedRootAsAnalyticImagery_Full(buf []byte, offset flatbuffers.UOffsetT) *AnalyticImagery_Full {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &AnalyticImagery_Full{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedAnalyticImagery_FullBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(AnalyticImagery_FullIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedAnalyticImagery_FullBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, AnalyticImagery_FullIdentifier)
}

func (rcv *AnalyticImagery_Full) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *AnalyticImagery_Full) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier of the record, auto-generated by the system.
/// Example: /// Example: ANALYTIC-IMAGERY-ID
/// Constraints: Minimum length = 1, Maximum length = 36
func (rcv *AnalyticImagery_Full) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier of the record, auto-generated by the system.
/// Example: /// Example: ANALYTIC-IMAGERY-ID
/// Constraints: Minimum length = 1, Maximum length = 36
/// Classification marking of the data in IC/CAPCO Portion-marked format.
/// Example: /// Example: U
/// Constraints: Minimum length = 1, Maximum length = 128
func (rcv *AnalyticImagery_Full) ClassificationMarking() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Classification marking of the data in IC/CAPCO Portion-marked format.
/// Example: /// Example: U
/// Constraints: Minimum length = 1, Maximum length = 128
/// General type of content of this image (CONTOUR, DIAGRAM, HEATMAP, HISTOGRAM, PLOT, SCREENSHOT).
/// Example: /// Example: CONTOUR
/// Constraints: Minimum length = 1, Maximum length = 36
func (rcv *AnalyticImagery_Full) Content() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// General type of content of this image (CONTOUR, DIAGRAM, HEATMAP, HISTOGRAM, PLOT, SCREENSHOT).
/// Example: /// Example: CONTOUR
/// Constraints: Minimum length = 1, Maximum length = 36
/// The message time of this image record, in ISO8601 UTC format with millisecond precision.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) MsgTime() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The message time of this image record, in ISO8601 UTC format with millisecond precision.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
/// The type of image associated with this record (GIF, JPG, PNG, TIF).
/// Example: /// Example: JPG
/// Constraints: Minimum length = 1, Maximum length = 16
func (rcv *AnalyticImagery_Full) ImageType() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The type of image associated with this record (GIF, JPG, PNG, TIF).
/// Example: /// Example: JPG
/// Constraints: Minimum length = 1, Maximum length = 16
/// The image file name.
/// Example: /// Example: IMAGE-NAME
/// Constraints: Minimum length = 1, Maximum length = 128
func (rcv *AnalyticImagery_Full) Filename() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The image file name.
/// Example: /// Example: IMAGE-NAME
/// Constraints: Minimum length = 1, Maximum length = 128
/// The image file size, in bytes.  The maximum file size for this service is 40,000,000 bytes (40MB). Files exceeding the maximum size will be rejected.
/// Example: /// Example: 7654321
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) Filesize() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// The image file size, in bytes.  The maximum file size for this service is 40,000,000 bytes (40MB). Files exceeding the maximum size will be rejected.
/// Example: /// Example: 7654321
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) MutateFilesize(n int64) bool {
	return rcv._tab.MutateInt64Slot(16, n)
}

/// The image width (horizontal), in pixels.
/// Example: /// Example: 123
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) ImgWidth() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// The image width (horizontal), in pixels.
/// Example: /// Example: 123
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) MutateImgWidth(n int32) bool {
	return rcv._tab.MutateInt32Slot(18, n)
}

/// The image height (vertical), in pixels.
/// Example: /// Example: 123
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) ImgHeight() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// The image height (vertical), in pixels.
/// Example: /// Example: 123
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) MutateImgHeight(n int32) bool {
	return rcv._tab.MutateInt32Slot(20, n)
}

/// Optional field indicating the units that apply to the x-axis of the attached image, when applicable.
/// Example: /// Example: pixels
/// Constraints: Minimum length = 0, Maximum length = 36
func (rcv *AnalyticImagery_Full) XUnits() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional field indicating the units that apply to the x-axis of the attached image, when applicable.
/// Example: /// Example: pixels
/// Constraints: Minimum length = 0, Maximum length = 36
/// Optional field indicating the units that apply to the y-axis of the attached image, when applicable.
/// Example: /// Example: pixels
/// Constraints: Minimum length = 0, Maximum length = 36
func (rcv *AnalyticImagery_Full) YUnits() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional field indicating the units that apply to the y-axis of the attached image, when applicable.
/// Example: /// Example: pixels
/// Constraints: Minimum length = 0, Maximum length = 36
/// Optional field indicating the units that apply to the z-axis of the attached image, when applicable.
/// Example: /// Example: pixels
/// Constraints: Minimum length = 0, Maximum length = 36
func (rcv *AnalyticImagery_Full) ZUnits() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional field indicating the units that apply to the z-axis of the attached image, when applicable.
/// Example: /// Example: pixels
/// Constraints: Minimum length = 0, Maximum length = 36
/// User-defined set ID of a sequence of images.  Used to associate related analytic image records.
/// Example: /// Example: IMAGE-IDS
/// Constraints: Minimum length = 0, Maximum length = 36
func (rcv *AnalyticImagery_Full) ImageSetId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// User-defined set ID of a sequence of images.  Used to associate related analytic image records.
/// Example: /// Example: IMAGE-IDS
/// Constraints: Minimum length = 0, Maximum length = 36
/// The number of images in an image set.
/// Example: /// Example: 123
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) ImageSetLength() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// The number of images in an image set.
/// Example: /// Example: 123
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) MutateImageSetLength(n int32) bool {
	return rcv._tab.MutateInt32Slot(30, n)
}

/// The sequence number of an image within an image set.  If null, then it is assumed that the order of images in an imageSet is not relevant.
/// Example: /// Example: 123
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) SequenceId() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// The sequence number of an image within an image set.  If null, then it is assumed that the order of images in an imageSet is not relevant.
/// Example: /// Example: 123
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) MutateSequenceId(n int32) bool {
	return rcv._tab.MutateInt32Slot(32, n)
}

/// Description of the image content and utility.
/// Example: /// Example: Image description
/// Constraints: Minimum length = 1, Maximum length = 512
func (rcv *AnalyticImagery_Full) Description() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Description of the image content and utility.
/// Example: /// Example: Image description
/// Constraints: Minimum length = 1, Maximum length = 512
/// The start time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) DataStart() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The start time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
/// The stop time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) DataStop() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The stop time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
/// Rectangular annotation limits, specified in pixels, as an array of arrays of the coordinates [ [UL1x, UL1y], [UR1x, UR1y], [LR1x, LR1y], [LL1x, LL1y] ], indicating the corners of a rectangle beginning with the Upper Left (UL) and moving clockwise. Allows the image provider to highlight one or more rectangular area(s) of interest. The array must contain Nx4 two-element arrays, where N is the number of rectangles of interest.  The associated annotation(s) should be included in the annText array.
/// Example: /// Example: [[1, 1], [1, 2], [1, 3], [1, 4]]
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) AnnLims(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AnalyticImagery_Full) AnnLimsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Rectangular annotation limits, specified in pixels, as an array of arrays of the coordinates [ [UL1x, UL1y], [UR1x, UR1y], [LR1x, LR1y], [LL1x, LL1y] ], indicating the corners of a rectangle beginning with the Upper Left (UL) and moving clockwise. Allows the image provider to highlight one or more rectangular area(s) of interest. The array must contain Nx4 two-element arrays, where N is the number of rectangles of interest.  The associated annotation(s) should be included in the annText array.
/// Example: /// Example: [[1, 1], [1, 2], [1, 3], [1, 4]]
/// Constraints: No constraints specified.
/// Annotation text, a string array of annotation(s) corresponding to the rectangular areas specified in annLims.  This array contains the annotation text associated with the areas of interest indicated in annLims, in order.  This array should contain one annotation per four values of the area (annLims) array.
/// Example: /// Example: ['rec1', 'rec2']
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) AnnText(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AnalyticImagery_Full) AnnTextLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Annotation text, a string array of annotation(s) corresponding to the rectangular areas specified in annLims.  This array contains the annotation text associated with the areas of interest indicated in annLims, in order.  This array should contain one annotation per four values of the area (annLims) array.
/// Example: /// Example: ['rec1', 'rec2']
/// Constraints: No constraints specified.
/// Array of searchable keywords for this analytic imagery record.
/// Example: /// Example: ['Key1', 'Key2']
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) Keywords(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AnalyticImagery_Full) KeywordsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Array of searchable keywords for this analytic imagery record.
/// Example: /// Example: ['Key1', 'Key2']
/// Constraints: No constraints specified.
/// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
/// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) Area() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
/// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
/// Constraints: No constraints specified.
/// Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
/// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) Atext() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
/// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
/// Constraints: No constraints specified.
/// Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
/// Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) Agjson() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
/// Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
/// Constraints: No constraints specified.
/// Type of region as projected on the ground.
/// Example: /// Example: POLYGON
/// Constraints: Minimum length = 0, Maximum length = 128
func (rcv *AnalyticImagery_Full) Atype() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Type of region as projected on the ground.
/// Example: /// Example: POLYGON
/// Constraints: Minimum length = 0, Maximum length = 128
/// Number of dimensions of the geometry depicted by region.
/// Example: /// Example: 2
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) Andims() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of dimensions of the geometry depicted by region.
/// Example: /// Example: 2
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) MutateAndims(n int32) bool {
	return rcv._tab.MutateInt32Slot(54, n)
}

/// Geographical spatial_ref_sys for region.
/// Example: /// Example: 4326
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) Asrid() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Geographical spatial_ref_sys for region.
/// Example: /// Example: 4326
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) MutateAsrid(n int32) bool {
	return rcv._tab.MutateInt32Slot(56, n)
}

/// Assessed satellite ID (NORAD RSO object number).  The 'satId' and 'satIdConf' arrays must match in size.
/// Example: /// Example: [12004, 12005]
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) SatId(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AnalyticImagery_Full) SatIdLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Assessed satellite ID (NORAD RSO object number).  The 'satId' and 'satIdConf' arrays must match in size.
/// Example: /// Example: [12004, 12005]
/// Constraints: No constraints specified.
/// Assessed satellite confidence corresponding to an assessment ID.  Values are between 0.0 and 1.0.  The 'satId' and 'satIdConf' arrays must match in size.
/// Example: /// Example: [0.98, 0.22]
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) SatIdConf(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AnalyticImagery_Full) SatIdConfLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Assessed satellite confidence corresponding to an assessment ID.  Values are between 0.0 and 1.0.  The 'satId' and 'satIdConf' arrays must match in size.
/// Example: /// Example: [0.98, 0.22]
/// Constraints: No constraints specified.
/// Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this image. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
/// Example: /// Example: ['MTI', 'POI']
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) SrcTyps(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AnalyticImagery_Full) SrcTypsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this image. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
/// Example: /// Example: ['MTI', 'POI']
/// Constraints: No constraints specified.
/// Array of UUIDs of the UDL data records that are related to this image. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
/// Example: /// Example: ['DOA_ID', 'DWELL_ID']
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) SrcIds(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AnalyticImagery_Full) SrcIdsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Array of UUIDs of the UDL data records that are related to this image. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
/// Example: /// Example: ['DOA_ID', 'DWELL_ID']
/// Constraints: No constraints specified.
/// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
/// Example: /// Example: ['TAG1', 'TAG2']
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) Tags(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *AnalyticImagery_Full) TagsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
/// Example: /// Example: ['TAG1', 'TAG2']
/// Constraints: No constraints specified.
/// MD5 checksum value of the file. The ingest/create operation will automatically generate the value.
/// Example: /// Example: 123
/// Constraints: Minimum length = 0, Maximum length = 256
func (rcv *AnalyticImagery_Full) ChecksumValue() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// MD5 checksum value of the file. The ingest/create operation will automatically generate the value.
/// Example: /// Example: 123
/// Constraints: Minimum length = 0, Maximum length = 256
/// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
/// Example: /// Example: a7bdef1f-5a4f-4716-bee4-7a1e0ec7d35a
/// Constraints: Minimum length = 0, Maximum length = 64
func (rcv *AnalyticImagery_Full) TransactionId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
/// Example: /// Example: a7bdef1f-5a4f-4716-bee4-7a1e0ec7d35a
/// Constraints: Minimum length = 0, Maximum length = 64
/// Time the row was created in the database, auto-populated by the system.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
func (rcv *AnalyticImagery_Full) CreatedAt() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time the row was created in the database, auto-populated by the system.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
/// Application user who created the row in the database, auto-populated by the system.
/// Example: /// Example: some.user
/// Constraints: Minimum length = 1, Maximum length = 64
func (rcv *AnalyticImagery_Full) CreatedBy() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Application user who created the row in the database, auto-populated by the system.
/// Example: /// Example: some.user
/// Constraints: Minimum length = 1, Maximum length = 64
/// Source of the data.
/// Example: /// Example: Bluestaq
/// Constraints: Minimum length = 1, Maximum length = 36
func (rcv *AnalyticImagery_Full) Source() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Source of the data.
/// Example: /// Example: Bluestaq
/// Constraints: Minimum length = 1, Maximum length = 36
/// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
/// Example: /// Example: ORIGIN
/// Constraints: Minimum length = 0, Maximum length = 64
func (rcv *AnalyticImagery_Full) Origin() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
/// Example: /// Example: ORIGIN
/// Constraints: Minimum length = 0, Maximum length = 64
/// The originating source network on which this record was created, auto-populated by the system.
/// Example: /// Example: TST1
/// Constraints: Minimum length = 1, Maximum length = 32
func (rcv *AnalyticImagery_Full) OrigNetwork() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The originating source network on which this record was created, auto-populated by the system.
/// Example: /// Example: TST1
/// Constraints: Minimum length = 1, Maximum length = 32
/// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
/// Example: /// Example: AXE
/// Constraints: Minimum length = 0, Maximum length = 64
func (rcv *AnalyticImagery_Full) SourceDl() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
/// Example: /// Example: AXE
/// Constraints: Minimum length = 0, Maximum length = 64
/// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
/// Example: /// Example: TEST
/// Constraints: Minimum length = 1, Maximum length = 32
func (rcv *AnalyticImagery_Full) DataMode() AnalyticImagery_Full_dataMode_Enum {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return AnalyticImagery_Full_dataMode_Enum(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
/// Example: /// Example: TEST
/// Constraints: Minimum length = 1, Maximum length = 32
func (rcv *AnalyticImagery_Full) MutateDataMode(n AnalyticImagery_Full_dataMode_Enum) bool {
	return rcv._tab.MutateInt8Slot(84, int8(n))
}

func AnalyticImagery_FullStart(builder *flatbuffers.Builder) {
	builder.StartObject(41)
}
func AnalyticImagery_FullAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func AnalyticImagery_FullAddClassificationMarking(builder *flatbuffers.Builder, classificationMarking flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(classificationMarking), 0)
}
func AnalyticImagery_FullAddContent(builder *flatbuffers.Builder, content flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(content), 0)
}
func AnalyticImagery_FullAddMsgTime(builder *flatbuffers.Builder, msgTime flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(msgTime), 0)
}
func AnalyticImagery_FullAddImageType(builder *flatbuffers.Builder, imageType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(imageType), 0)
}
func AnalyticImagery_FullAddFilename(builder *flatbuffers.Builder, filename flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(filename), 0)
}
func AnalyticImagery_FullAddFilesize(builder *flatbuffers.Builder, filesize int64) {
	builder.PrependInt64Slot(6, filesize, 0)
}
func AnalyticImagery_FullAddImgWidth(builder *flatbuffers.Builder, imgWidth int32) {
	builder.PrependInt32Slot(7, imgWidth, 0)
}
func AnalyticImagery_FullAddImgHeight(builder *flatbuffers.Builder, imgHeight int32) {
	builder.PrependInt32Slot(8, imgHeight, 0)
}
func AnalyticImagery_FullAddXUnits(builder *flatbuffers.Builder, xUnits flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(xUnits), 0)
}
func AnalyticImagery_FullAddYUnits(builder *flatbuffers.Builder, yUnits flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(yUnits), 0)
}
func AnalyticImagery_FullAddZUnits(builder *flatbuffers.Builder, zUnits flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(zUnits), 0)
}
func AnalyticImagery_FullAddImageSetId(builder *flatbuffers.Builder, imageSetId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(imageSetId), 0)
}
func AnalyticImagery_FullAddImageSetLength(builder *flatbuffers.Builder, imageSetLength int32) {
	builder.PrependInt32Slot(13, imageSetLength, 0)
}
func AnalyticImagery_FullAddSequenceId(builder *flatbuffers.Builder, sequenceId int32) {
	builder.PrependInt32Slot(14, sequenceId, 0)
}
func AnalyticImagery_FullAddDescription(builder *flatbuffers.Builder, description flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(description), 0)
}
func AnalyticImagery_FullAddDataStart(builder *flatbuffers.Builder, dataStart flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(dataStart), 0)
}
func AnalyticImagery_FullAddDataStop(builder *flatbuffers.Builder, dataStop flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(dataStop), 0)
}
func AnalyticImagery_FullAddAnnLims(builder *flatbuffers.Builder, annLims flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(18, flatbuffers.UOffsetT(annLims), 0)
}
func AnalyticImagery_FullStartAnnLimsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AnalyticImagery_FullAddAnnText(builder *flatbuffers.Builder, annText flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(19, flatbuffers.UOffsetT(annText), 0)
}
func AnalyticImagery_FullStartAnnTextVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AnalyticImagery_FullAddKeywords(builder *flatbuffers.Builder, keywords flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(20, flatbuffers.UOffsetT(keywords), 0)
}
func AnalyticImagery_FullStartKeywordsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AnalyticImagery_FullAddArea(builder *flatbuffers.Builder, area flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(area), 0)
}
func AnalyticImagery_FullAddAtext(builder *flatbuffers.Builder, atext flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(22, flatbuffers.UOffsetT(atext), 0)
}
func AnalyticImagery_FullAddAgjson(builder *flatbuffers.Builder, agjson flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(23, flatbuffers.UOffsetT(agjson), 0)
}
func AnalyticImagery_FullAddAtype(builder *flatbuffers.Builder, atype flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(24, flatbuffers.UOffsetT(atype), 0)
}
func AnalyticImagery_FullAddAndims(builder *flatbuffers.Builder, andims int32) {
	builder.PrependInt32Slot(25, andims, 0)
}
func AnalyticImagery_FullAddAsrid(builder *flatbuffers.Builder, asrid int32) {
	builder.PrependInt32Slot(26, asrid, 0)
}
func AnalyticImagery_FullAddSatId(builder *flatbuffers.Builder, satId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(27, flatbuffers.UOffsetT(satId), 0)
}
func AnalyticImagery_FullStartSatIdVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AnalyticImagery_FullAddSatIdConf(builder *flatbuffers.Builder, satIdConf flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(28, flatbuffers.UOffsetT(satIdConf), 0)
}
func AnalyticImagery_FullStartSatIdConfVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AnalyticImagery_FullAddSrcTyps(builder *flatbuffers.Builder, srcTyps flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(29, flatbuffers.UOffsetT(srcTyps), 0)
}
func AnalyticImagery_FullStartSrcTypsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AnalyticImagery_FullAddSrcIds(builder *flatbuffers.Builder, srcIds flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(30, flatbuffers.UOffsetT(srcIds), 0)
}
func AnalyticImagery_FullStartSrcIdsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AnalyticImagery_FullAddTags(builder *flatbuffers.Builder, tags flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(31, flatbuffers.UOffsetT(tags), 0)
}
func AnalyticImagery_FullStartTagsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func AnalyticImagery_FullAddChecksumValue(builder *flatbuffers.Builder, checksumValue flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(32, flatbuffers.UOffsetT(checksumValue), 0)
}
func AnalyticImagery_FullAddTransactionId(builder *flatbuffers.Builder, transactionId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(33, flatbuffers.UOffsetT(transactionId), 0)
}
func AnalyticImagery_FullAddCreatedAt(builder *flatbuffers.Builder, createdAt flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(34, flatbuffers.UOffsetT(createdAt), 0)
}
func AnalyticImagery_FullAddCreatedBy(builder *flatbuffers.Builder, createdBy flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(35, flatbuffers.UOffsetT(createdBy), 0)
}
func AnalyticImagery_FullAddSource(builder *flatbuffers.Builder, source flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(36, flatbuffers.UOffsetT(source), 0)
}
func AnalyticImagery_FullAddOrigin(builder *flatbuffers.Builder, origin flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(37, flatbuffers.UOffsetT(origin), 0)
}
func AnalyticImagery_FullAddOrigNetwork(builder *flatbuffers.Builder, origNetwork flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(38, flatbuffers.UOffsetT(origNetwork), 0)
}
func AnalyticImagery_FullAddSourceDl(builder *flatbuffers.Builder, sourceDl flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(39, flatbuffers.UOffsetT(sourceDl), 0)
}
func AnalyticImagery_FullAddDataMode(builder *flatbuffers.Builder, dataMode AnalyticImagery_Full_dataMode_Enum) {
	builder.PrependInt8Slot(40, int8(dataMode), 0)
}
func AnalyticImagery_FullEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
