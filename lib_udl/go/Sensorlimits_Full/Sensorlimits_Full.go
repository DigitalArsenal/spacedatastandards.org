// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package Sensorlimits_Full

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// /// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
type Sensorlimits_Full struct {
	_tab flatbuffers.Table
}

const Sensorlimits_FullIdentifier = "SENS"

func GetRootAsSensorlimits_Full(buf []byte, offset flatbuffers.UOffsetT) *Sensorlimits_Full {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Sensorlimits_Full{}
	x.Init(buf, n+offset)
	return x
}

func FinishSensorlimits_FullBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(Sensorlimits_FullIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func Sensorlimits_FullBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, Sensorlimits_FullIdentifier)
}

func GetSizePrefixedRootAsSensorlimits_Full(buf []byte, offset flatbuffers.UOffsetT) *Sensorlimits_Full {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Sensorlimits_Full{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedSensorlimits_FullBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(Sensorlimits_FullIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedSensorlimits_FullBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, Sensorlimits_FullIdentifier)
}

func (rcv *Sensorlimits_Full) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Sensorlimits_Full) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier of the record, auto-generated by the system.
/// Example: /// Example: SENSORLIMITS-ID
/// Constraints: Minimum length = 1, Maximum length = 36
func (rcv *Sensorlimits_Full) IdSensorLimits() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier of the record, auto-generated by the system.
/// Example: /// Example: SENSORLIMITS-ID
/// Constraints: Minimum length = 1, Maximum length = 36
/// Classification marking of the data in IC/CAPCO Portion-marked format.
/// Example: /// Example: U
/// Constraints: Minimum length = 1, Maximum length = 128
func (rcv *Sensorlimits_Full) ClassificationMarking() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Classification marking of the data in IC/CAPCO Portion-marked format.
/// Example: /// Example: U
/// Constraints: Minimum length = 1, Maximum length = 128
/// The originating source network on which this record was created, auto-populated by the system.
/// Example: /// Example: ORIG
/// Constraints: Minimum length = 1, Maximum length = 32
func (rcv *Sensorlimits_Full) OrigNetwork() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The originating source network on which this record was created, auto-populated by the system.
/// Example: /// Example: ORIG
/// Constraints: Minimum length = 1, Maximum length = 32
/// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) UpperLeftAzimuthLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) MutateUpperLeftAzimuthLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

/// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) UpperRightAzimuthLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) MutateUpperRightAzimuthLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

/// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) LowerRightAzimuthLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) MutateLowerRightAzimuthLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

/// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) LowerLeftAzimuthLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) MutateLowerLeftAzimuthLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) LowerLeftElevationLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) MutateLowerLeftElevationLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

/// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) UpperLeftElevationLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) MutateUpperLeftElevationLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

/// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) LowerRightElevationLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) MutateLowerRightElevationLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

/// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) UpperRightElevationLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
/// Example: /// Example: 1.23
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) MutateUpperRightElevationLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// Source of the data.
/// Example: /// Example: Bluestaq
/// Constraints: Minimum length = 1, Maximum length = 64
func (rcv *Sensorlimits_Full) Source() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Source of the data.
/// Example: /// Example: Bluestaq
/// Constraints: Minimum length = 1, Maximum length = 64
/// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
/// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
/// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
/// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
/// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
/// Example: /// Example: TEST
/// Constraints: Minimum length = 1, Maximum length = 32
func (rcv *Sensorlimits_Full) DataMode() Sensorlimits_Full_dataMode_Enum {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return Sensorlimits_Full_dataMode_Enum(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
/// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
/// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
/// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
/// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
/// Example: /// Example: TEST
/// Constraints: Minimum length = 1, Maximum length = 32
func (rcv *Sensorlimits_Full) MutateDataMode(n Sensorlimits_Full_dataMode_Enum) bool {
	return rcv._tab.MutateInt8Slot(28, int8(n))
}

/// Time the row was created in the database, auto-populated by the system.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) CreatedAt() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time the row was created in the database, auto-populated by the system.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
/// Application user who created the row in the database, auto-populated by the system.
/// Example: /// Example: some.user
/// Constraints: Minimum length = 1, Maximum length = 64
func (rcv *Sensorlimits_Full) CreatedBy() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Application user who created the row in the database, auto-populated by the system.
/// Example: /// Example: some.user
/// Constraints: Minimum length = 1, Maximum length = 64
/// Time the row was last updated in the database, auto-populated by the system.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
func (rcv *Sensorlimits_Full) UpdatedAt() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time the row was last updated in the database, auto-populated by the system.
/// Example: /// Example: 2018-01-01T16:00:00.123Z
/// Constraints: No constraints specified.
/// Application user who updated the row in the database, auto-populated by the system.
/// Example: /// Example: some.user
/// Constraints: Minimum length = 0, Maximum length = 64
func (rcv *Sensorlimits_Full) UpdatedBy() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Application user who updated the row in the database, auto-populated by the system.
/// Example: /// Example: some.user
/// Constraints: Minimum length = 0, Maximum length = 64
/// Unique identifier of the target sensor object.
/// Example: /// Example: SENSORLIMITS-ID
/// Constraints: Minimum length = 0, Maximum length = 36
func (rcv *Sensorlimits_Full) IdSensor() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier of the target sensor object.
/// Example: /// Example: SENSORLIMITS-ID
/// Constraints: Minimum length = 0, Maximum length = 36
func Sensorlimits_FullStart(builder *flatbuffers.Builder) {
	builder.StartObject(18)
}
func Sensorlimits_FullAddIdSensorLimits(builder *flatbuffers.Builder, idSensorLimits flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(idSensorLimits), 0)
}
func Sensorlimits_FullAddClassificationMarking(builder *flatbuffers.Builder, classificationMarking flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(classificationMarking), 0)
}
func Sensorlimits_FullAddOrigNetwork(builder *flatbuffers.Builder, origNetwork flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(origNetwork), 0)
}
func Sensorlimits_FullAddUpperLeftAzimuthLimit(builder *flatbuffers.Builder, upperLeftAzimuthLimit float64) {
	builder.PrependFloat64Slot(3, upperLeftAzimuthLimit, 0.0)
}
func Sensorlimits_FullAddUpperRightAzimuthLimit(builder *flatbuffers.Builder, upperRightAzimuthLimit float64) {
	builder.PrependFloat64Slot(4, upperRightAzimuthLimit, 0.0)
}
func Sensorlimits_FullAddLowerRightAzimuthLimit(builder *flatbuffers.Builder, lowerRightAzimuthLimit float64) {
	builder.PrependFloat64Slot(5, lowerRightAzimuthLimit, 0.0)
}
func Sensorlimits_FullAddLowerLeftAzimuthLimit(builder *flatbuffers.Builder, lowerLeftAzimuthLimit float64) {
	builder.PrependFloat64Slot(6, lowerLeftAzimuthLimit, 0.0)
}
func Sensorlimits_FullAddLowerLeftElevationLimit(builder *flatbuffers.Builder, lowerLeftElevationLimit float64) {
	builder.PrependFloat64Slot(7, lowerLeftElevationLimit, 0.0)
}
func Sensorlimits_FullAddUpperLeftElevationLimit(builder *flatbuffers.Builder, upperLeftElevationLimit float64) {
	builder.PrependFloat64Slot(8, upperLeftElevationLimit, 0.0)
}
func Sensorlimits_FullAddLowerRightElevationLimit(builder *flatbuffers.Builder, lowerRightElevationLimit float64) {
	builder.PrependFloat64Slot(9, lowerRightElevationLimit, 0.0)
}
func Sensorlimits_FullAddUpperRightElevationLimit(builder *flatbuffers.Builder, upperRightElevationLimit float64) {
	builder.PrependFloat64Slot(10, upperRightElevationLimit, 0.0)
}
func Sensorlimits_FullAddSource(builder *flatbuffers.Builder, source flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(source), 0)
}
func Sensorlimits_FullAddDataMode(builder *flatbuffers.Builder, dataMode Sensorlimits_Full_dataMode_Enum) {
	builder.PrependInt8Slot(12, int8(dataMode), 0)
}
func Sensorlimits_FullAddCreatedAt(builder *flatbuffers.Builder, createdAt flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(createdAt), 0)
}
func Sensorlimits_FullAddCreatedBy(builder *flatbuffers.Builder, createdBy flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(createdBy), 0)
}
func Sensorlimits_FullAddUpdatedAt(builder *flatbuffers.Builder, updatedAt flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(updatedAt), 0)
}
func Sensorlimits_FullAddUpdatedBy(builder *flatbuffers.Builder, updatedBy flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(updatedBy), 0)
}
func Sensorlimits_FullAddIdSensor(builder *flatbuffers.Builder, idSensor flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(idSensor), 0)
}
func Sensorlimits_FullEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
