// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package TrackSensor_Full

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// /// Schema for Track Sensor data.
type TrackSensor_Full struct {
	_tab flatbuffers.Table
}

const TrackSensor_FullIdentifier = "TRAC"

func GetRootAsTrackSensor_Full(buf []byte, offset flatbuffers.UOffsetT) *TrackSensor_Full {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TrackSensor_Full{}
	x.Init(buf, n+offset)
	return x
}

func FinishTrackSensor_FullBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(TrackSensor_FullIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func TrackSensor_FullBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, TrackSensor_FullIdentifier)
}

func GetSizePrefixedRootAsTrackSensor_Full(buf []byte, offset flatbuffers.UOffsetT) *TrackSensor_Full {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TrackSensor_Full{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedTrackSensor_FullBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(TrackSensor_FullIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedTrackSensor_FullBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, TrackSensor_FullIdentifier)
}

func (rcv *TrackSensor_Full) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TrackSensor_Full) Table() flatbuffers.Table {
	return rcv._tab
}

/// The track object range from the observing sensor, in kilometers.
/// Example: /// Example: 4023.95
/// Constraints: No constraints specified.
func (rcv *TrackSensor_Full) Range() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The track object range from the observing sensor, in kilometers.
/// Example: /// Example: 4023.95
/// Constraints: No constraints specified.
func (rcv *TrackSensor_Full) MutateRange(n float64) bool {
	return rcv._tab.MutateFloat64Slot(4, n)
}

/// The observing sensor azimuth angle, in degrees and topocentric frame.
/// Example: /// Example: 90
/// Constraints: No constraints specified.
func (rcv *TrackSensor_Full) Az() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The observing sensor azimuth angle, in degrees and topocentric frame.
/// Example: /// Example: 90
/// Constraints: No constraints specified.
func (rcv *TrackSensor_Full) MutateAz(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

/// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
/// Example: /// Example: 1234
/// Constraints: No constraints specified.
func (rcv *TrackSensor_Full) SensorNumber() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
/// Example: /// Example: 1234
/// Constraints: No constraints specified.
func (rcv *TrackSensor_Full) MutateSensorNumber(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

/// Unique name of this sensor.
/// Example: /// Example: SENSOR_NAME
/// Constraints: Minimum length = 0, Maximum length = 128
func (rcv *TrackSensor_Full) SensorName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique name of this sensor.
/// Example: /// Example: SENSOR_NAME
/// Constraints: Minimum length = 0, Maximum length = 128
/// The mission number which produced this track observation.
/// Example: /// Example: Example Mission
/// Constraints: Minimum length = 0, Maximum length = 128
func (rcv *TrackSensor_Full) MissionNumber() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The mission number which produced this track observation.
/// Example: /// Example: Example Mission
/// Constraints: Minimum length = 0, Maximum length = 128
/// Minimum range measurement capability of the sensor, in kilometers.
/// Example: /// Example: 20.23
/// Constraints: No constraints specified.
func (rcv *TrackSensor_Full) MinRangeLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Minimum range measurement capability of the sensor, in kilometers.
/// Example: /// Example: 20.23
/// Constraints: No constraints specified.
func (rcv *TrackSensor_Full) MutateMinRangeLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

/// The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
/// Example: /// Example: UNKNOWN
/// Constraints: Minimum length = 0, Maximum length = 24
func (rcv *TrackSensor_Full) SensorFovtype() TrackSensor_Full_sensorFOVType_Enum {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return TrackSensor_Full_sensorFOVType_Enum(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
/// Example: /// Example: UNKNOWN
/// Constraints: Minimum length = 0, Maximum length = 24
func (rcv *TrackSensor_Full) MutateSensorFovtype(n TrackSensor_Full_sensorFOVType_Enum) bool {
	return rcv._tab.MutateInt8Slot(16, int8(n))
}

func TrackSensor_FullStart(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func TrackSensor_FullAddRange(builder *flatbuffers.Builder, range_ float64) {
	builder.PrependFloat64Slot(0, range_, 0.0)
}
func TrackSensor_FullAddAz(builder *flatbuffers.Builder, az float64) {
	builder.PrependFloat64Slot(1, az, 0.0)
}
func TrackSensor_FullAddSensorNumber(builder *flatbuffers.Builder, sensorNumber int32) {
	builder.PrependInt32Slot(2, sensorNumber, 0)
}
func TrackSensor_FullAddSensorName(builder *flatbuffers.Builder, sensorName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(sensorName), 0)
}
func TrackSensor_FullAddMissionNumber(builder *flatbuffers.Builder, missionNumber flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(missionNumber), 0)
}
func TrackSensor_FullAddMinRangeLimit(builder *flatbuffers.Builder, minRangeLimit float64) {
	builder.PrependFloat64Slot(5, minRangeLimit, 0.0)
}
func TrackSensor_FullAddSensorFovtype(builder *flatbuffers.Builder, sensorFovtype TrackSensor_Full_sensorFOVType_Enum) {
	builder.PrependInt8Slot(6, int8(sensorFovtype), 0)
}
func TrackSensor_FullEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
