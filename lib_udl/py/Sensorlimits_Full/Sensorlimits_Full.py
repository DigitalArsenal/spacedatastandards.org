# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# /// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
class Sensorlimits_Full(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Sensorlimits_Full()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSensorlimits_Full(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def Sensorlimits_FullBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x53\x45\x4E\x53", size_prefixed=size_prefixed)

    # Sensorlimits_Full
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Unique identifier of the record, auto-generated by the system.
    # Example: /// Example: SENSORLIMITS-ID
    # Constraints: Minimum length = 1, Maximum length = 36
    # Sensorlimits_Full
    def IdSensorLimits(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Classification marking of the data in IC/CAPCO Portion-marked format.
    # Example: /// Example: U
    # Constraints: Minimum length = 1, Maximum length = 128
    # Sensorlimits_Full
    def ClassificationMarking(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The originating source network on which this record was created, auto-populated by the system.
    # Example: /// Example: ORIG
    # Constraints: Minimum length = 1, Maximum length = 32
    # Sensorlimits_Full
    def OrigNetwork(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Sensorlimits_Full
    def UpperLeftAzimuthLimit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Sensorlimits_Full
    def UpperRightAzimuthLimit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Sensorlimits_Full
    def LowerRightAzimuthLimit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Sensorlimits_Full
    def LowerLeftAzimuthLimit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Sensorlimits_Full
    def LowerLeftElevationLimit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Sensorlimits_Full
    def UpperLeftElevationLimit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Sensorlimits_Full
    def LowerRightElevationLimit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Sensorlimits_Full
    def UpperRightElevationLimit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Source of the data.
    # Example: /// Example: Bluestaq
    # Constraints: Minimum length = 1, Maximum length = 64
    # Sensorlimits_Full
    def Source(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
    # EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
    # REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
    # SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
    # TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    # Example: /// Example: TEST
    # Constraints: Minimum length = 1, Maximum length = 32
    # Sensorlimits_Full
    def DataMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Time the row was created in the database, auto-populated by the system.
    # Example: /// Example: 2018-01-01T16:00:00.123Z
    # Constraints: No constraints specified.
    # Sensorlimits_Full
    def CreatedAt(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Application user who created the row in the database, auto-populated by the system.
    # Example: /// Example: some.user
    # Constraints: Minimum length = 1, Maximum length = 64
    # Sensorlimits_Full
    def CreatedBy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Time the row was last updated in the database, auto-populated by the system.
    # Example: /// Example: 2018-01-01T16:00:00.123Z
    # Constraints: No constraints specified.
    # Sensorlimits_Full
    def UpdatedAt(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Application user who updated the row in the database, auto-populated by the system.
    # Example: /// Example: some.user
    # Constraints: Minimum length = 0, Maximum length = 64
    # Sensorlimits_Full
    def UpdatedBy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Unique identifier of the target sensor object.
    # Example: /// Example: SENSORLIMITS-ID
    # Constraints: Minimum length = 0, Maximum length = 36
    # Sensorlimits_Full
    def IdSensor(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def Sensorlimits_FullStart(builder):
    builder.StartObject(18)

def Start(builder):
    Sensorlimits_FullStart(builder)

def Sensorlimits_FullAddIdSensorLimits(builder, idSensorLimits):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(idSensorLimits), 0)

def AddIdSensorLimits(builder, idSensorLimits):
    Sensorlimits_FullAddIdSensorLimits(builder, idSensorLimits)

def Sensorlimits_FullAddClassificationMarking(builder, classificationMarking):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(classificationMarking), 0)

def AddClassificationMarking(builder, classificationMarking):
    Sensorlimits_FullAddClassificationMarking(builder, classificationMarking)

def Sensorlimits_FullAddOrigNetwork(builder, origNetwork):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(origNetwork), 0)

def AddOrigNetwork(builder, origNetwork):
    Sensorlimits_FullAddOrigNetwork(builder, origNetwork)

def Sensorlimits_FullAddUpperLeftAzimuthLimit(builder, upperLeftAzimuthLimit):
    builder.PrependFloat64Slot(3, upperLeftAzimuthLimit, 0.0)

def AddUpperLeftAzimuthLimit(builder, upperLeftAzimuthLimit):
    Sensorlimits_FullAddUpperLeftAzimuthLimit(builder, upperLeftAzimuthLimit)

def Sensorlimits_FullAddUpperRightAzimuthLimit(builder, upperRightAzimuthLimit):
    builder.PrependFloat64Slot(4, upperRightAzimuthLimit, 0.0)

def AddUpperRightAzimuthLimit(builder, upperRightAzimuthLimit):
    Sensorlimits_FullAddUpperRightAzimuthLimit(builder, upperRightAzimuthLimit)

def Sensorlimits_FullAddLowerRightAzimuthLimit(builder, lowerRightAzimuthLimit):
    builder.PrependFloat64Slot(5, lowerRightAzimuthLimit, 0.0)

def AddLowerRightAzimuthLimit(builder, lowerRightAzimuthLimit):
    Sensorlimits_FullAddLowerRightAzimuthLimit(builder, lowerRightAzimuthLimit)

def Sensorlimits_FullAddLowerLeftAzimuthLimit(builder, lowerLeftAzimuthLimit):
    builder.PrependFloat64Slot(6, lowerLeftAzimuthLimit, 0.0)

def AddLowerLeftAzimuthLimit(builder, lowerLeftAzimuthLimit):
    Sensorlimits_FullAddLowerLeftAzimuthLimit(builder, lowerLeftAzimuthLimit)

def Sensorlimits_FullAddLowerLeftElevationLimit(builder, lowerLeftElevationLimit):
    builder.PrependFloat64Slot(7, lowerLeftElevationLimit, 0.0)

def AddLowerLeftElevationLimit(builder, lowerLeftElevationLimit):
    Sensorlimits_FullAddLowerLeftElevationLimit(builder, lowerLeftElevationLimit)

def Sensorlimits_FullAddUpperLeftElevationLimit(builder, upperLeftElevationLimit):
    builder.PrependFloat64Slot(8, upperLeftElevationLimit, 0.0)

def AddUpperLeftElevationLimit(builder, upperLeftElevationLimit):
    Sensorlimits_FullAddUpperLeftElevationLimit(builder, upperLeftElevationLimit)

def Sensorlimits_FullAddLowerRightElevationLimit(builder, lowerRightElevationLimit):
    builder.PrependFloat64Slot(9, lowerRightElevationLimit, 0.0)

def AddLowerRightElevationLimit(builder, lowerRightElevationLimit):
    Sensorlimits_FullAddLowerRightElevationLimit(builder, lowerRightElevationLimit)

def Sensorlimits_FullAddUpperRightElevationLimit(builder, upperRightElevationLimit):
    builder.PrependFloat64Slot(10, upperRightElevationLimit, 0.0)

def AddUpperRightElevationLimit(builder, upperRightElevationLimit):
    Sensorlimits_FullAddUpperRightElevationLimit(builder, upperRightElevationLimit)

def Sensorlimits_FullAddSource(builder, source):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(source), 0)

def AddSource(builder, source):
    Sensorlimits_FullAddSource(builder, source)

def Sensorlimits_FullAddDataMode(builder, dataMode):
    builder.PrependInt8Slot(12, dataMode, 0)

def AddDataMode(builder, dataMode):
    Sensorlimits_FullAddDataMode(builder, dataMode)

def Sensorlimits_FullAddCreatedAt(builder, createdAt):
    builder.PrependUOffsetTRelativeSlot(13, flatbuffers.number_types.UOffsetTFlags.py_type(createdAt), 0)

def AddCreatedAt(builder, createdAt):
    Sensorlimits_FullAddCreatedAt(builder, createdAt)

def Sensorlimits_FullAddCreatedBy(builder, createdBy):
    builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(createdBy), 0)

def AddCreatedBy(builder, createdBy):
    Sensorlimits_FullAddCreatedBy(builder, createdBy)

def Sensorlimits_FullAddUpdatedAt(builder, updatedAt):
    builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(updatedAt), 0)

def AddUpdatedAt(builder, updatedAt):
    Sensorlimits_FullAddUpdatedAt(builder, updatedAt)

def Sensorlimits_FullAddUpdatedBy(builder, updatedBy):
    builder.PrependUOffsetTRelativeSlot(16, flatbuffers.number_types.UOffsetTFlags.py_type(updatedBy), 0)

def AddUpdatedBy(builder, updatedBy):
    Sensorlimits_FullAddUpdatedBy(builder, updatedBy)

def Sensorlimits_FullAddIdSensor(builder, idSensor):
    builder.PrependUOffsetTRelativeSlot(17, flatbuffers.number_types.UOffsetTFlags.py_type(idSensor), 0)

def AddIdSensor(builder, idSensor):
    Sensorlimits_FullAddIdSensor(builder, idSensor)

def Sensorlimits_FullEnd(builder):
    return builder.EndObject()

def End(builder):
    return Sensorlimits_FullEnd(builder)


class Sensorlimits_FullT(object):

    # Sensorlimits_FullT
    def __init__(self):
        self.idSensorLimits = None  # type: str
        self.classificationMarking = None  # type: str
        self.origNetwork = None  # type: str
        self.upperLeftAzimuthLimit = 0.0  # type: float
        self.upperRightAzimuthLimit = 0.0  # type: float
        self.lowerRightAzimuthLimit = 0.0  # type: float
        self.lowerLeftAzimuthLimit = 0.0  # type: float
        self.lowerLeftElevationLimit = 0.0  # type: float
        self.upperLeftElevationLimit = 0.0  # type: float
        self.lowerRightElevationLimit = 0.0  # type: float
        self.upperRightElevationLimit = 0.0  # type: float
        self.source = None  # type: str
        self.dataMode = 0  # type: int
        self.createdAt = None  # type: str
        self.createdBy = None  # type: str
        self.updatedAt = None  # type: str
        self.updatedBy = None  # type: str
        self.idSensor = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        sensorlimitsFull = Sensorlimits_Full()
        sensorlimitsFull.Init(buf, pos)
        return cls.InitFromObj(sensorlimitsFull)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, sensorlimitsFull):
        x = Sensorlimits_FullT()
        x._UnPack(sensorlimitsFull)
        return x

    # Sensorlimits_FullT
    def _UnPack(self, sensorlimitsFull):
        if sensorlimitsFull is None:
            return
        self.idSensorLimits = sensorlimitsFull.IdSensorLimits()
        self.classificationMarking = sensorlimitsFull.ClassificationMarking()
        self.origNetwork = sensorlimitsFull.OrigNetwork()
        self.upperLeftAzimuthLimit = sensorlimitsFull.UpperLeftAzimuthLimit()
        self.upperRightAzimuthLimit = sensorlimitsFull.UpperRightAzimuthLimit()
        self.lowerRightAzimuthLimit = sensorlimitsFull.LowerRightAzimuthLimit()
        self.lowerLeftAzimuthLimit = sensorlimitsFull.LowerLeftAzimuthLimit()
        self.lowerLeftElevationLimit = sensorlimitsFull.LowerLeftElevationLimit()
        self.upperLeftElevationLimit = sensorlimitsFull.UpperLeftElevationLimit()
        self.lowerRightElevationLimit = sensorlimitsFull.LowerRightElevationLimit()
        self.upperRightElevationLimit = sensorlimitsFull.UpperRightElevationLimit()
        self.source = sensorlimitsFull.Source()
        self.dataMode = sensorlimitsFull.DataMode()
        self.createdAt = sensorlimitsFull.CreatedAt()
        self.createdBy = sensorlimitsFull.CreatedBy()
        self.updatedAt = sensorlimitsFull.UpdatedAt()
        self.updatedBy = sensorlimitsFull.UpdatedBy()
        self.idSensor = sensorlimitsFull.IdSensor()

    # Sensorlimits_FullT
    def Pack(self, builder):
        if self.idSensorLimits is not None:
            idSensorLimits = builder.CreateString(self.idSensorLimits)
        if self.classificationMarking is not None:
            classificationMarking = builder.CreateString(self.classificationMarking)
        if self.origNetwork is not None:
            origNetwork = builder.CreateString(self.origNetwork)
        if self.source is not None:
            source = builder.CreateString(self.source)
        if self.createdAt is not None:
            createdAt = builder.CreateString(self.createdAt)
        if self.createdBy is not None:
            createdBy = builder.CreateString(self.createdBy)
        if self.updatedAt is not None:
            updatedAt = builder.CreateString(self.updatedAt)
        if self.updatedBy is not None:
            updatedBy = builder.CreateString(self.updatedBy)
        if self.idSensor is not None:
            idSensor = builder.CreateString(self.idSensor)
        Sensorlimits_FullStart(builder)
        if self.idSensorLimits is not None:
            Sensorlimits_FullAddIdSensorLimits(builder, idSensorLimits)
        if self.classificationMarking is not None:
            Sensorlimits_FullAddClassificationMarking(builder, classificationMarking)
        if self.origNetwork is not None:
            Sensorlimits_FullAddOrigNetwork(builder, origNetwork)
        Sensorlimits_FullAddUpperLeftAzimuthLimit(builder, self.upperLeftAzimuthLimit)
        Sensorlimits_FullAddUpperRightAzimuthLimit(builder, self.upperRightAzimuthLimit)
        Sensorlimits_FullAddLowerRightAzimuthLimit(builder, self.lowerRightAzimuthLimit)
        Sensorlimits_FullAddLowerLeftAzimuthLimit(builder, self.lowerLeftAzimuthLimit)
        Sensorlimits_FullAddLowerLeftElevationLimit(builder, self.lowerLeftElevationLimit)
        Sensorlimits_FullAddUpperLeftElevationLimit(builder, self.upperLeftElevationLimit)
        Sensorlimits_FullAddLowerRightElevationLimit(builder, self.lowerRightElevationLimit)
        Sensorlimits_FullAddUpperRightElevationLimit(builder, self.upperRightElevationLimit)
        if self.source is not None:
            Sensorlimits_FullAddSource(builder, source)
        Sensorlimits_FullAddDataMode(builder, self.dataMode)
        if self.createdAt is not None:
            Sensorlimits_FullAddCreatedAt(builder, createdAt)
        if self.createdBy is not None:
            Sensorlimits_FullAddCreatedBy(builder, createdBy)
        if self.updatedAt is not None:
            Sensorlimits_FullAddUpdatedAt(builder, updatedAt)
        if self.updatedBy is not None:
            Sensorlimits_FullAddUpdatedBy(builder, updatedBy)
        if self.idSensor is not None:
            Sensorlimits_FullAddIdSensor(builder, idSensor)
        sensorlimitsFull = Sensorlimits_FullEnd(builder)
        return sensorlimitsFull
