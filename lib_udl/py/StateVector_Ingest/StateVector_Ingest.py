# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# /// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Discover' tab in the storefront to confirm coordinate frames by data provider.
class StateVector_Ingest(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = StateVector_Ingest()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsStateVector_Ingest(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def StateVector_IngestBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x53\x54\x41\x54", size_prefixed=size_prefixed)

    # StateVector_Ingest
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Unique identifier of the record, auto-generated by the system.
    # Example: /// Example: STATEVECTOR-ID
    # Constraints: Minimum length = 1, Maximum length = 36
    # StateVector_Ingest
    def IdStateVector(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Classification marking of the data in IC/CAPCO Portion-marked format.
    # Example: /// Example: U
    # Constraints: Minimum length = 1, Maximum length = 128
    # StateVector_Ingest
    def ClassificationMarking(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Time of validity for state vector in ISO 8601 UTC datetime format, with microsecond precision.
    # Example: /// Example: 2018-01-01T16:00:00.123456Z
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Epoch(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The pedigree of state vector, or methods used for its generation to include state update/orbit determination, propagation from another state, or a state from a calibration satellite (e.g. ORBIT_UPDATE, PROPAGATION, CALIBRATION, CONJUNCTION, FLIGHT_PLAN).
    # Example: /// Example: CONJUNCTION
    # Constraints: Minimum length = 0, Maximum length = 32
    # StateVector_Ingest
    def Pedigree(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
    # Example: /// Example: ONORBIT-ID
    # Constraints: Minimum length = 0, Maximum length = 36
    # StateVector_Ingest
    def IdOnOrbit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Satellite/Catalog number of the target OnOrbit object.
    # Example: /// Example: 12
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SatNo(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Optional identifier provided by state vector source to indicate the target onorbit object of this state vector. This may be an internal identifier and not necessarily map to a valid satellite number.
    # Example: /// Example: ORIGOBJECT-ID
    # Constraints: Minimum length = 0, Maximum length = 64
    # StateVector_Ingest
    def OrigObjectId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Unique identifier of the OD solution record that produced this state vector. This ID can be used to obtain additional information on an OrbitDetermination object using the 'get by ID' operation (e.g. /udl/orbitdetermination/{id}). For example, the OrbitDetermination with idOrbitDetermination = abc would be queries as /udl/orbitdetermination/abc.
    # Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
    # Constraints: Minimum length = 0, Maximum length = 36
    # StateVector_Ingest
    def IdOrbitDetermination(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Boolean indicating this state vector was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
    # Example: /// Example: True
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Uct(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Cartesian X position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
    # Example: /// Example: -1118.577381
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Xpos(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Y position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
    # Example: /// Example: 3026.231084
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Ypos(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Z position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
    # Example: /// Example: 6167.831808
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Zpos(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian X velocity of target, in kilometers/second, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
    # Example: /// Example: -4.25242784
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Xvel(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Y velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
    # Example: /// Example: 5.291107434
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Yvel(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Z velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
    # Example: /// Example: -3.356493869
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Zvel(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
    # Example: /// Example: J2000
    # Constraints: Minimum length = 0, Maximum length = 24
    # StateVector_Ingest
    def ReferenceFrame(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.  If the covReferenceFrame is null it is assumed to be J2000.
    # The array values (1-21) represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
    # &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR&nbsp;&nbsp;
    # x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
    # y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3
    # z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6
    # x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;10
    # y'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
    # z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;
    # The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
    # If additional covariance terms are included for DRAG, SRP, and/or THRUST, the matrix can be extended with the following order of elements:
    # &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR
    # DRG&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;23&nbsp;&nbsp;24&nbsp;&nbsp;25&nbsp;&nbsp;26&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;
    # SRP&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;30&nbsp;&nbsp;31&nbsp;&nbsp;32&nbsp;&nbsp;33&nbsp;&nbsp;&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;
    # THR&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;38&nbsp;&nbsp;39&nbsp;&nbsp;40&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45&nbsp;
    # Example: /// Example: [1.1, 2.2]
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Cov(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # StateVector_Ingest
    def CovLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # StateVector_Ingest
    def CovIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        return o == 0

    # The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
    # Example: /// Example: J2000
    # Constraints: Minimum length = 0, Maximum length = 24
    # StateVector_Ingest
    def CovReferenceFrame(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # The method used to generate the covariance during the orbit determination (OD) that produced the state vector, or whether an arbitrary, non-calculated default value was used (CALCULATED, DEFAULT).
    # Example: /// Example: CALCULATED
    # Constraints: Minimum length = 0, Maximum length = 24
    # StateVector_Ingest
    def CovMethod(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The covariance matrix values represent the lower triangular half of the covariance matrix in terms of equinoctial elements.&nbsp; The size of the covariance matrix is dynamic.&nbsp; The values are outputted in order across each row, i.e.:
    # 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5
    # 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp; 10
    # :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
    # :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
    # 51&nbsp; 52&nbsp; 53&nbsp; 54&nbsp; 55
    # :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
    # :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
    # The ordering of values is as follows:
    # &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Af&nbsp;&nbsp; Ag&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp; N&nbsp;&nbsp; Chi&nbsp; Psi&nbsp;&nbsp; B&nbsp;&nbsp; BDOT AGOM&nbsp; T&nbsp;&nbsp; C1&nbsp;&nbsp; C2&nbsp; ...
    # Af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
    # Ag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3
    # L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 6
    # N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 10
    # Chi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; 12&nbsp;&nbsp; 13&nbsp;&nbsp; 14&nbsp;&nbsp; 15
    # Psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 17&nbsp;&nbsp; 18&nbsp;&nbsp; 19&nbsp;&nbsp; 20&nbsp;&nbsp; 21
    # B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 23&nbsp;&nbsp; 24 &nbsp;&nbsp;25&nbsp;&nbsp; 26&nbsp;&nbsp; 27&nbsp;&nbsp; 28
    # BDOT&nbsp;&nbsp; 29&nbsp;&nbsp; 30&nbsp;&nbsp; 31&nbsp;&nbsp; 32&nbsp;&nbsp; 33&nbsp;&nbsp; 34&nbsp;&nbsp; 35&nbsp;&nbsp; 36
    # AGOM&nbsp; 37&nbsp;&nbsp; 38&nbsp;&nbsp; 39&nbsp;&nbsp; 40&nbsp;&nbsp; 41&nbsp;&nbsp; 42&nbsp;&nbsp; 43&nbsp;&nbsp; 44&nbsp;&nbsp; 45
    # T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;&nbsp; 47&nbsp;&nbsp; 48&nbsp;&nbsp; 49&nbsp;&nbsp; 50&nbsp;&nbsp; 51&nbsp;&nbsp; 52&nbsp;&nbsp; 53&nbsp;&nbsp; 54&nbsp;&nbsp; 55
    # C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 56&nbsp;&nbsp; 57&nbsp;&nbsp; 58&nbsp;&nbsp; 59&nbsp;&nbsp; 60&nbsp;&nbsp; 61&nbsp;&nbsp; 62&nbsp;&nbsp; 63&nbsp;&nbsp; 64&nbsp;&nbsp; 65&nbsp;&nbsp; 66
    # C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67&nbsp;&nbsp; 68&nbsp;&nbsp; 69&nbsp;&nbsp; 70&nbsp;&nbsp; 71&nbsp; &nbsp;72&nbsp;&nbsp; 73&nbsp;&nbsp; 74&nbsp;&nbsp; 75&nbsp;&nbsp; 76&nbsp;&nbsp; 77&nbsp;&nbsp; 78
    # :
    # :
    # where C1, C2, etc, are the "consider parameters" that may be added to the covariance matrix.&nbsp; The covariance matrix will be as large as the last element/model parameter needed.&nbsp; In other words, if the DC solved for all 6 elements plus AGOM, the covariance matrix will be 9x9 (and the rows for B and BDOT will be all zeros).&nbsp; If the covariance matrix is unavailable, the size will be set to 0x0, and no data will follow.&nbsp; The cov field should contain only the lower left triangle values from top left down to bottom right, in order.
    # Example: /// Example: [1.1, 2.2]
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def EqCov(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # StateVector_Ingest
    def EqCovLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # StateVector_Ingest
    def EqCovIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        return o == 0

    # Cartesian X position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: -1145.688502
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def XposAlt1(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(44))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Y position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: 3020.729572
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def YposAlt1(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(46))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Z position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: 6165.55187
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def ZposAlt1(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(48))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian X velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: -4.270832252
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def XvelAlt1(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(50))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Y velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: 5.27074276
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def YvelAlt1(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(52))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Z velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: -3.365155181
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def ZvelAlt1(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(54))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # The reference frame of the alternate1 (Alt1) cartesian orbital state.
    # Example: /// Example: TEME
    # Constraints: Minimum length = 0, Maximum length = 24
    # StateVector_Ingest
    def Alt1ReferenceFrame(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(56))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Cartesian X position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: -1456.915926
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def XposAlt2(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(58))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Y position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: -2883.540406
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def YposAlt2(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(60))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Z position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: 6165.55187
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def ZposAlt2(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(62))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian X velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: -1.219814294
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def XvelAlt2(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(64))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Y velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: -6.602080212
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def YvelAlt2(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(66))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Cartesian Z velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    # Example: /// Example: -3.365155181
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def ZvelAlt2(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(68))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # The reference frame of the alternate2 (Alt2) cartesian orbital state.
    # Example: /// Example: EFG/TDR
    # Constraints: Minimum length = 0, Maximum length = 24
    # StateVector_Ingest
    def Alt2ReferenceFrame(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(70))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # One sigma position uncertainty, in kilometers.
    # Example: /// Example: 0.333399744452
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def PosUnc(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(72))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # One sigma velocity uncertainty, in kilometers/second.
    # Example: /// Example: 4e-06
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def VelUnc(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(74))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # The mass of the object, in kilograms.
    # Example: /// Example: 164.5
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Mass(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(76))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # The actual area of the object at it's largest cross-section, expressed in meters^2.
    # Example: /// Example: 5.065
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Area(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(78))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Area-to-mass ratio coefficient for solar radiation pressure.
    # Example: /// Example: 0.0244394
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SolarRadPressCoeff(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(80))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Area-to-mass ratio coefficient for atmospheric ballistic drag (m2/kg).
    # Example: /// Example: 0.0224391269775
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def DragCoeff(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(82))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # The effective area of the object exposed to atmospheric drag, expressed in meters^2.
    # Example: /// Example: 4.739
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def DragArea(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(84))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Epoch revolution number.
    # Example: /// Example: 7205
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def RevNo(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(86))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Geopotential model used for this vector (e.g. EGM-96, WGS-84, WGS-72, JGM-2, or GEM-T3), including mm degree zonals, nn degree/order tesserals. E.g. EGM-96 24Z,24T.
    # Example: /// Example: EGM-96
    # Constraints: Minimum length = 0, Maximum length = 32
    # StateVector_Ingest
    def GeopotentialModel(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(88))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The Drag Model used for this vector (e.g. HARRIS-PRIESTER, JAC70, JBH09, MSIS90, NONE, etc.).
    # Example: /// Example: JAC70
    # Constraints: Minimum length = 0, Maximum length = 32
    # StateVector_Ingest
    def DragModel(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(90))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Boolean indicating use of lunar/solar perturbations for this vector.
    # Example: /// Example: True
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def LunarSolar(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(92))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Boolean indicating use of solar radiation pressure perturbations for this vector.
    # Example: /// Example: True
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SolarRadPress(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(94))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # The effective area of the object exposed to solar radiation pressure, expressed in meters^2.
    # Example: /// Example: 4.311
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SrpArea(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(96))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Boolean indicating use of solid earth tide perturbations for this vector.
    # Example: /// Example: True
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SolidEarthTides(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(98))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Boolean indicating use of in-track thrust perturbations for this vector.
    # Example: /// Example: True
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def InTrackThrust(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(100))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # First derivative of drag/ballistic coefficient (m2/kg-s).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def BDot(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(102))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Model parameter value for energy dissipation rate (EDR) (w/kg).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Edr(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(104))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Model parameter value for thrust acceleration (m/s2).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def ThrustAccel(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(106))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Model parameter value for center of mass offset (m).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def CmOffset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(108))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # The start of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
    # Example: /// Example: 2022-11-09T11:20:21.247192Z
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def LastObStart(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(110))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The end of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
    # Example: /// Example: 2022-11-09T11:20:21.247192Z
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def LastObEnd(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(112))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The number of observations available for the OD of the object.
    # Example: /// Example: 376
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def ObsAvailable(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(114))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # The number of observations accepted for the OD of the object.
    # Example: /// Example: 374
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def ObsUsed(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(116))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # The number of sensor tracks available for the OD of the object.
    # Example: /// Example: 163
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def TracksAvail(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(118))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # The number of sensor tracks accepted for the OD of the object.
    # Example: /// Example: 163
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def TracksUsed(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(120))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # The recommended OD time span calculated for the object, expressed in days.
    # Example: /// Example: 3.5
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def RecOdspan(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(122))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # The actual time span used for the OD of the object, expressed in days.
    # Example: /// Example: 3.5
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def ActualOdspan(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(124))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # The percentage of residuals accepted in the OD of the object.
    # Example: /// Example: 99.5
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def ResidualsAcc(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(126))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # F10 (10.7 cm) solar flux value.
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SolarFluxF10(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(128))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # F10 (10.7 cm) solar flux 81-day average value.
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SolarFluxF10Avg(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(130))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Average solar flux geomagnetic index.
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SolarFluxApavg(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(132))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # TAI (Temps Atomique International) minus UTC (Universal Time Coordinates) offset in seconds.
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def TaiUtc(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(134))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Universal Time-1 (UT1) minus UTC offset, in seconds.
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Ut1Utc(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(136))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Rate of change of UT1 (milliseconds/day) - first derivative of ut1Utc.
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Ut1Rate(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(138))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Polar Wander Motion X (arc seconds).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def PolarMotionX(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(140))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Polar Wander Motion Y (arc seconds).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def PolarMotionY(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(142))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Number of terms used in the IAU 1980 nutation model (4, 50, or 106).
    # Example: /// Example: 4
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Iau1980Terms(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(144))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Time of the next leap second after epoch in ISO 8601 UTC time. If the next leap second is not known, the time of the previous leap second is used.
    # Example: /// Example: 2021-01-01T01:01:01.123Z
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def LeapSecondTime(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(146))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Integrator Mode.
    # Example: /// Example: integratorMode
    # Constraints: Minimum length = 0, Maximum length = 32
    # StateVector_Ingest
    def IntegratorMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(148))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Type of partial derivatives used (ANALYTIC, FULL NUM, or FAST NUM).
    # Example: /// Example: ANALYTIC
    # Constraints: Minimum length = 0, Maximum length = 16
    # StateVector_Ingest
    def Partials(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(150))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Integrator step mode (AUTO, TIME, or S).
    # Example: /// Example: AUTO
    # Constraints: Minimum length = 0, Maximum length = 16
    # StateVector_Ingest
    def StepMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(152))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Boolean indicating use of fixed step size for this vector.
    # Example: /// Example: True
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def FixedStep(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(154))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Initial step size selection (AUTO or MANUAL).
    # Example: /// Example: AUTO
    # Constraints: Minimum length = 0, Maximum length = 16
    # StateVector_Ingest
    def StepSizeSelection(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(156))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Initial integration step size (seconds).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def StepSize(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(158))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Integrator error control.
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def ErrorControl(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(160))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Array containing the standard deviation of error in target object position, U, V and W direction respectively (km).
    # Example: /// Example: [1.23, 4.56]
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SigmaPosUvw(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(162))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # StateVector_Ingest
    def SigmaPosUvwLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(162))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # StateVector_Ingest
    def SigmaPosUvwIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(162))
        return o == 0

    # Array containing the standard deviation of error in target object velocity, U, V and W direction respectively (km/sec).
    # Example: /// Example: [1.23, 4.56]
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SigmaVelUvw(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(164))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # StateVector_Ingest
    def SigmaVelUvwLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(164))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # StateVector_Ingest
    def SigmaVelUvwIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(164))
        return o == 0

    # The Weighted Root Mean Squared (RMS) of the differential correction on the target object that produced this vector.  WRMS is a quality indicator of the state vector update, with a value of 1.00 being optimal.  WRMS applies to Batch Least Squares (BLS) processes.
    # Example: /// Example: 0.991
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Rms(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(166))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
    # Example: /// Example: rawFileURI
    # Constraints: Minimum length = 0, Maximum length = 256
    # StateVector_Ingest
    def RawFileUri(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(168))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Source of the data.
    # Example: /// Example: Bluestaq
    # Constraints: Minimum length = 1, Maximum length = 64
    # StateVector_Ingest
    def Source(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(170))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
    # Example: /// Example: THIRD_PARTY_DATASOURCE
    # Constraints: Minimum length = 0, Maximum length = 64
    # StateVector_Ingest
    def Origin(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(172))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
    # EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
    # REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
    # SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
    # TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    # Example: /// Example: TEST
    # Constraints: Minimum length = 1, Maximum length = 32
    # StateVector_Ingest
    def DataMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(174))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
    # Example: /// Example: ['TAG1', 'TAG2']
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def Tags(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(176))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # StateVector_Ingest
    def TagsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(176))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # StateVector_Ingest
    def TagsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(176))
        return o == 0

    # Optional algorithm used to produce this record.
    # Example: /// Example: SAMPLE_ALGORITHM
    # Constraints: Minimum length = 0, Maximum length = 64
    # StateVector_Ingest
    def Algorithm(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(178))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Optional array of UDL data (observation) UUIDs used to build this state vector. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
    # Example: /// Example: ['DATA1', 'DATA2']
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SourcedData(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(180))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # StateVector_Ingest
    def SourcedDataLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(180))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # StateVector_Ingest
    def SourcedDataIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(180))
        return o == 0

    # Optional array of UDL observation data types used to build this state vector (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
    # Example: /// Example: ['RADAR']
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def SourcedDataTypes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(182))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Time the row was created in the database, auto-populated by the system.
    # Example: /// Example: 2018-01-01T16:00:00.123Z
    # Constraints: No constraints specified.
    # StateVector_Ingest
    def CreatedAt(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(184))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Application user who created the row in the database, auto-populated by the system.
    # Example: /// Example: some.user
    # Constraints: Minimum length = 1, Maximum length = 64
    # StateVector_Ingest
    def CreatedBy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(186))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Optional source-provided and searchable metadata or descriptor of the data.
    # Example: /// Example: descriptor
    # Constraints: Minimum length = 0, Maximum length = 64
    # StateVector_Ingest
    def Descriptor(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(188))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Optional identifier to track a commercial or marketplace transaction executed to produce this data.
    # Example: /// Example: transactionId
    # Constraints: Minimum length = 0, Maximum length = 64
    # StateVector_Ingest
    def TransactionId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(190))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The originating source network on which this record was created, auto-populated by the system.
    # Example: /// Example: ORIG
    # Constraints: Minimum length = 1, Maximum length = 32
    # StateVector_Ingest
    def OrigNetwork(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(192))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
    # Example: /// Example: AXE
    # Constraints: Minimum length = 0, Maximum length = 64
    # StateVector_Ingest
    def SourceDl(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(194))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def StateVector_IngestStart(builder):
    builder.StartObject(96)

def Start(builder):
    StateVector_IngestStart(builder)

def StateVector_IngestAddIdStateVector(builder, idStateVector):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(idStateVector), 0)

def AddIdStateVector(builder, idStateVector):
    StateVector_IngestAddIdStateVector(builder, idStateVector)

def StateVector_IngestAddClassificationMarking(builder, classificationMarking):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(classificationMarking), 0)

def AddClassificationMarking(builder, classificationMarking):
    StateVector_IngestAddClassificationMarking(builder, classificationMarking)

def StateVector_IngestAddEpoch(builder, epoch):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(epoch), 0)

def AddEpoch(builder, epoch):
    StateVector_IngestAddEpoch(builder, epoch)

def StateVector_IngestAddPedigree(builder, pedigree):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(pedigree), 0)

def AddPedigree(builder, pedigree):
    StateVector_IngestAddPedigree(builder, pedigree)

def StateVector_IngestAddIdOnOrbit(builder, idOnOrbit):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(idOnOrbit), 0)

def AddIdOnOrbit(builder, idOnOrbit):
    StateVector_IngestAddIdOnOrbit(builder, idOnOrbit)

def StateVector_IngestAddSatNo(builder, satNo):
    builder.PrependInt32Slot(5, satNo, 0)

def AddSatNo(builder, satNo):
    StateVector_IngestAddSatNo(builder, satNo)

def StateVector_IngestAddOrigObjectId(builder, origObjectId):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(origObjectId), 0)

def AddOrigObjectId(builder, origObjectId):
    StateVector_IngestAddOrigObjectId(builder, origObjectId)

def StateVector_IngestAddIdOrbitDetermination(builder, idOrbitDetermination):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(idOrbitDetermination), 0)

def AddIdOrbitDetermination(builder, idOrbitDetermination):
    StateVector_IngestAddIdOrbitDetermination(builder, idOrbitDetermination)

def StateVector_IngestAddUct(builder, uct):
    builder.PrependBoolSlot(8, uct, 0)

def AddUct(builder, uct):
    StateVector_IngestAddUct(builder, uct)

def StateVector_IngestAddXpos(builder, xpos):
    builder.PrependFloat64Slot(9, xpos, 0.0)

def AddXpos(builder, xpos):
    StateVector_IngestAddXpos(builder, xpos)

def StateVector_IngestAddYpos(builder, ypos):
    builder.PrependFloat64Slot(10, ypos, 0.0)

def AddYpos(builder, ypos):
    StateVector_IngestAddYpos(builder, ypos)

def StateVector_IngestAddZpos(builder, zpos):
    builder.PrependFloat64Slot(11, zpos, 0.0)

def AddZpos(builder, zpos):
    StateVector_IngestAddZpos(builder, zpos)

def StateVector_IngestAddXvel(builder, xvel):
    builder.PrependFloat64Slot(12, xvel, 0.0)

def AddXvel(builder, xvel):
    StateVector_IngestAddXvel(builder, xvel)

def StateVector_IngestAddYvel(builder, yvel):
    builder.PrependFloat64Slot(13, yvel, 0.0)

def AddYvel(builder, yvel):
    StateVector_IngestAddYvel(builder, yvel)

def StateVector_IngestAddZvel(builder, zvel):
    builder.PrependFloat64Slot(14, zvel, 0.0)

def AddZvel(builder, zvel):
    StateVector_IngestAddZvel(builder, zvel)

def StateVector_IngestAddReferenceFrame(builder, referenceFrame):
    builder.PrependInt8Slot(15, referenceFrame, 0)

def AddReferenceFrame(builder, referenceFrame):
    StateVector_IngestAddReferenceFrame(builder, referenceFrame)

def StateVector_IngestAddCov(builder, cov):
    builder.PrependUOffsetTRelativeSlot(16, flatbuffers.number_types.UOffsetTFlags.py_type(cov), 0)

def AddCov(builder, cov):
    StateVector_IngestAddCov(builder, cov)

def StateVector_IngestStartCovVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartCovVector(builder, numElems):
    return StateVector_IngestStartCovVector(builder, numElems)

def StateVector_IngestAddCovReferenceFrame(builder, covReferenceFrame):
    builder.PrependInt8Slot(17, covReferenceFrame, 0)

def AddCovReferenceFrame(builder, covReferenceFrame):
    StateVector_IngestAddCovReferenceFrame(builder, covReferenceFrame)

def StateVector_IngestAddCovMethod(builder, covMethod):
    builder.PrependUOffsetTRelativeSlot(18, flatbuffers.number_types.UOffsetTFlags.py_type(covMethod), 0)

def AddCovMethod(builder, covMethod):
    StateVector_IngestAddCovMethod(builder, covMethod)

def StateVector_IngestAddEqCov(builder, eqCov):
    builder.PrependUOffsetTRelativeSlot(19, flatbuffers.number_types.UOffsetTFlags.py_type(eqCov), 0)

def AddEqCov(builder, eqCov):
    StateVector_IngestAddEqCov(builder, eqCov)

def StateVector_IngestStartEqCovVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartEqCovVector(builder, numElems):
    return StateVector_IngestStartEqCovVector(builder, numElems)

def StateVector_IngestAddXposAlt1(builder, xposAlt1):
    builder.PrependFloat64Slot(20, xposAlt1, 0.0)

def AddXposAlt1(builder, xposAlt1):
    StateVector_IngestAddXposAlt1(builder, xposAlt1)

def StateVector_IngestAddYposAlt1(builder, yposAlt1):
    builder.PrependFloat64Slot(21, yposAlt1, 0.0)

def AddYposAlt1(builder, yposAlt1):
    StateVector_IngestAddYposAlt1(builder, yposAlt1)

def StateVector_IngestAddZposAlt1(builder, zposAlt1):
    builder.PrependFloat64Slot(22, zposAlt1, 0.0)

def AddZposAlt1(builder, zposAlt1):
    StateVector_IngestAddZposAlt1(builder, zposAlt1)

def StateVector_IngestAddXvelAlt1(builder, xvelAlt1):
    builder.PrependFloat64Slot(23, xvelAlt1, 0.0)

def AddXvelAlt1(builder, xvelAlt1):
    StateVector_IngestAddXvelAlt1(builder, xvelAlt1)

def StateVector_IngestAddYvelAlt1(builder, yvelAlt1):
    builder.PrependFloat64Slot(24, yvelAlt1, 0.0)

def AddYvelAlt1(builder, yvelAlt1):
    StateVector_IngestAddYvelAlt1(builder, yvelAlt1)

def StateVector_IngestAddZvelAlt1(builder, zvelAlt1):
    builder.PrependFloat64Slot(25, zvelAlt1, 0.0)

def AddZvelAlt1(builder, zvelAlt1):
    StateVector_IngestAddZvelAlt1(builder, zvelAlt1)

def StateVector_IngestAddAlt1ReferenceFrame(builder, alt1ReferenceFrame):
    builder.PrependUOffsetTRelativeSlot(26, flatbuffers.number_types.UOffsetTFlags.py_type(alt1ReferenceFrame), 0)

def AddAlt1ReferenceFrame(builder, alt1ReferenceFrame):
    StateVector_IngestAddAlt1ReferenceFrame(builder, alt1ReferenceFrame)

def StateVector_IngestAddXposAlt2(builder, xposAlt2):
    builder.PrependFloat64Slot(27, xposAlt2, 0.0)

def AddXposAlt2(builder, xposAlt2):
    StateVector_IngestAddXposAlt2(builder, xposAlt2)

def StateVector_IngestAddYposAlt2(builder, yposAlt2):
    builder.PrependFloat64Slot(28, yposAlt2, 0.0)

def AddYposAlt2(builder, yposAlt2):
    StateVector_IngestAddYposAlt2(builder, yposAlt2)

def StateVector_IngestAddZposAlt2(builder, zposAlt2):
    builder.PrependFloat64Slot(29, zposAlt2, 0.0)

def AddZposAlt2(builder, zposAlt2):
    StateVector_IngestAddZposAlt2(builder, zposAlt2)

def StateVector_IngestAddXvelAlt2(builder, xvelAlt2):
    builder.PrependFloat64Slot(30, xvelAlt2, 0.0)

def AddXvelAlt2(builder, xvelAlt2):
    StateVector_IngestAddXvelAlt2(builder, xvelAlt2)

def StateVector_IngestAddYvelAlt2(builder, yvelAlt2):
    builder.PrependFloat64Slot(31, yvelAlt2, 0.0)

def AddYvelAlt2(builder, yvelAlt2):
    StateVector_IngestAddYvelAlt2(builder, yvelAlt2)

def StateVector_IngestAddZvelAlt2(builder, zvelAlt2):
    builder.PrependFloat64Slot(32, zvelAlt2, 0.0)

def AddZvelAlt2(builder, zvelAlt2):
    StateVector_IngestAddZvelAlt2(builder, zvelAlt2)

def StateVector_IngestAddAlt2ReferenceFrame(builder, alt2ReferenceFrame):
    builder.PrependUOffsetTRelativeSlot(33, flatbuffers.number_types.UOffsetTFlags.py_type(alt2ReferenceFrame), 0)

def AddAlt2ReferenceFrame(builder, alt2ReferenceFrame):
    StateVector_IngestAddAlt2ReferenceFrame(builder, alt2ReferenceFrame)

def StateVector_IngestAddPosUnc(builder, posUnc):
    builder.PrependFloat64Slot(34, posUnc, 0.0)

def AddPosUnc(builder, posUnc):
    StateVector_IngestAddPosUnc(builder, posUnc)

def StateVector_IngestAddVelUnc(builder, velUnc):
    builder.PrependFloat64Slot(35, velUnc, 0.0)

def AddVelUnc(builder, velUnc):
    StateVector_IngestAddVelUnc(builder, velUnc)

def StateVector_IngestAddMass(builder, mass):
    builder.PrependFloat64Slot(36, mass, 0.0)

def AddMass(builder, mass):
    StateVector_IngestAddMass(builder, mass)

def StateVector_IngestAddArea(builder, area):
    builder.PrependFloat64Slot(37, area, 0.0)

def AddArea(builder, area):
    StateVector_IngestAddArea(builder, area)

def StateVector_IngestAddSolarRadPressCoeff(builder, solarRadPressCoeff):
    builder.PrependFloat64Slot(38, solarRadPressCoeff, 0.0)

def AddSolarRadPressCoeff(builder, solarRadPressCoeff):
    StateVector_IngestAddSolarRadPressCoeff(builder, solarRadPressCoeff)

def StateVector_IngestAddDragCoeff(builder, dragCoeff):
    builder.PrependFloat64Slot(39, dragCoeff, 0.0)

def AddDragCoeff(builder, dragCoeff):
    StateVector_IngestAddDragCoeff(builder, dragCoeff)

def StateVector_IngestAddDragArea(builder, dragArea):
    builder.PrependFloat64Slot(40, dragArea, 0.0)

def AddDragArea(builder, dragArea):
    StateVector_IngestAddDragArea(builder, dragArea)

def StateVector_IngestAddRevNo(builder, revNo):
    builder.PrependInt32Slot(41, revNo, 0)

def AddRevNo(builder, revNo):
    StateVector_IngestAddRevNo(builder, revNo)

def StateVector_IngestAddGeopotentialModel(builder, geopotentialModel):
    builder.PrependUOffsetTRelativeSlot(42, flatbuffers.number_types.UOffsetTFlags.py_type(geopotentialModel), 0)

def AddGeopotentialModel(builder, geopotentialModel):
    StateVector_IngestAddGeopotentialModel(builder, geopotentialModel)

def StateVector_IngestAddDragModel(builder, dragModel):
    builder.PrependUOffsetTRelativeSlot(43, flatbuffers.number_types.UOffsetTFlags.py_type(dragModel), 0)

def AddDragModel(builder, dragModel):
    StateVector_IngestAddDragModel(builder, dragModel)

def StateVector_IngestAddLunarSolar(builder, lunarSolar):
    builder.PrependBoolSlot(44, lunarSolar, 0)

def AddLunarSolar(builder, lunarSolar):
    StateVector_IngestAddLunarSolar(builder, lunarSolar)

def StateVector_IngestAddSolarRadPress(builder, solarRadPress):
    builder.PrependBoolSlot(45, solarRadPress, 0)

def AddSolarRadPress(builder, solarRadPress):
    StateVector_IngestAddSolarRadPress(builder, solarRadPress)

def StateVector_IngestAddSrpArea(builder, srpArea):
    builder.PrependFloat64Slot(46, srpArea, 0.0)

def AddSrpArea(builder, srpArea):
    StateVector_IngestAddSrpArea(builder, srpArea)

def StateVector_IngestAddSolidEarthTides(builder, solidEarthTides):
    builder.PrependBoolSlot(47, solidEarthTides, 0)

def AddSolidEarthTides(builder, solidEarthTides):
    StateVector_IngestAddSolidEarthTides(builder, solidEarthTides)

def StateVector_IngestAddInTrackThrust(builder, inTrackThrust):
    builder.PrependBoolSlot(48, inTrackThrust, 0)

def AddInTrackThrust(builder, inTrackThrust):
    StateVector_IngestAddInTrackThrust(builder, inTrackThrust)

def StateVector_IngestAddBDot(builder, bDot):
    builder.PrependFloat64Slot(49, bDot, 0.0)

def AddBDot(builder, bDot):
    StateVector_IngestAddBDot(builder, bDot)

def StateVector_IngestAddEdr(builder, edr):
    builder.PrependFloat64Slot(50, edr, 0.0)

def AddEdr(builder, edr):
    StateVector_IngestAddEdr(builder, edr)

def StateVector_IngestAddThrustAccel(builder, thrustAccel):
    builder.PrependFloat64Slot(51, thrustAccel, 0.0)

def AddThrustAccel(builder, thrustAccel):
    StateVector_IngestAddThrustAccel(builder, thrustAccel)

def StateVector_IngestAddCmOffset(builder, cmOffset):
    builder.PrependFloat64Slot(52, cmOffset, 0.0)

def AddCmOffset(builder, cmOffset):
    StateVector_IngestAddCmOffset(builder, cmOffset)

def StateVector_IngestAddLastObStart(builder, lastObStart):
    builder.PrependUOffsetTRelativeSlot(53, flatbuffers.number_types.UOffsetTFlags.py_type(lastObStart), 0)

def AddLastObStart(builder, lastObStart):
    StateVector_IngestAddLastObStart(builder, lastObStart)

def StateVector_IngestAddLastObEnd(builder, lastObEnd):
    builder.PrependUOffsetTRelativeSlot(54, flatbuffers.number_types.UOffsetTFlags.py_type(lastObEnd), 0)

def AddLastObEnd(builder, lastObEnd):
    StateVector_IngestAddLastObEnd(builder, lastObEnd)

def StateVector_IngestAddObsAvailable(builder, obsAvailable):
    builder.PrependInt32Slot(55, obsAvailable, 0)

def AddObsAvailable(builder, obsAvailable):
    StateVector_IngestAddObsAvailable(builder, obsAvailable)

def StateVector_IngestAddObsUsed(builder, obsUsed):
    builder.PrependInt32Slot(56, obsUsed, 0)

def AddObsUsed(builder, obsUsed):
    StateVector_IngestAddObsUsed(builder, obsUsed)

def StateVector_IngestAddTracksAvail(builder, tracksAvail):
    builder.PrependInt32Slot(57, tracksAvail, 0)

def AddTracksAvail(builder, tracksAvail):
    StateVector_IngestAddTracksAvail(builder, tracksAvail)

def StateVector_IngestAddTracksUsed(builder, tracksUsed):
    builder.PrependInt32Slot(58, tracksUsed, 0)

def AddTracksUsed(builder, tracksUsed):
    StateVector_IngestAddTracksUsed(builder, tracksUsed)

def StateVector_IngestAddRecOdspan(builder, recOdspan):
    builder.PrependFloat64Slot(59, recOdspan, 0.0)

def AddRecOdspan(builder, recOdspan):
    StateVector_IngestAddRecOdspan(builder, recOdspan)

def StateVector_IngestAddActualOdspan(builder, actualOdspan):
    builder.PrependFloat64Slot(60, actualOdspan, 0.0)

def AddActualOdspan(builder, actualOdspan):
    StateVector_IngestAddActualOdspan(builder, actualOdspan)

def StateVector_IngestAddResidualsAcc(builder, residualsAcc):
    builder.PrependFloat64Slot(61, residualsAcc, 0.0)

def AddResidualsAcc(builder, residualsAcc):
    StateVector_IngestAddResidualsAcc(builder, residualsAcc)

def StateVector_IngestAddSolarFluxF10(builder, solarFluxF10):
    builder.PrependFloat64Slot(62, solarFluxF10, 0.0)

def AddSolarFluxF10(builder, solarFluxF10):
    StateVector_IngestAddSolarFluxF10(builder, solarFluxF10)

def StateVector_IngestAddSolarFluxF10Avg(builder, solarFluxF10Avg):
    builder.PrependFloat64Slot(63, solarFluxF10Avg, 0.0)

def AddSolarFluxF10Avg(builder, solarFluxF10Avg):
    StateVector_IngestAddSolarFluxF10Avg(builder, solarFluxF10Avg)

def StateVector_IngestAddSolarFluxApavg(builder, solarFluxApavg):
    builder.PrependFloat64Slot(64, solarFluxApavg, 0.0)

def AddSolarFluxApavg(builder, solarFluxApavg):
    StateVector_IngestAddSolarFluxApavg(builder, solarFluxApavg)

def StateVector_IngestAddTaiUtc(builder, taiUtc):
    builder.PrependFloat64Slot(65, taiUtc, 0.0)

def AddTaiUtc(builder, taiUtc):
    StateVector_IngestAddTaiUtc(builder, taiUtc)

def StateVector_IngestAddUt1Utc(builder, ut1Utc):
    builder.PrependFloat64Slot(66, ut1Utc, 0.0)

def AddUt1Utc(builder, ut1Utc):
    StateVector_IngestAddUt1Utc(builder, ut1Utc)

def StateVector_IngestAddUt1Rate(builder, ut1Rate):
    builder.PrependFloat64Slot(67, ut1Rate, 0.0)

def AddUt1Rate(builder, ut1Rate):
    StateVector_IngestAddUt1Rate(builder, ut1Rate)

def StateVector_IngestAddPolarMotionX(builder, polarMotionX):
    builder.PrependFloat64Slot(68, polarMotionX, 0.0)

def AddPolarMotionX(builder, polarMotionX):
    StateVector_IngestAddPolarMotionX(builder, polarMotionX)

def StateVector_IngestAddPolarMotionY(builder, polarMotionY):
    builder.PrependFloat64Slot(69, polarMotionY, 0.0)

def AddPolarMotionY(builder, polarMotionY):
    StateVector_IngestAddPolarMotionY(builder, polarMotionY)

def StateVector_IngestAddIau1980Terms(builder, iau1980Terms):
    builder.PrependInt32Slot(70, iau1980Terms, 0)

def AddIau1980Terms(builder, iau1980Terms):
    StateVector_IngestAddIau1980Terms(builder, iau1980Terms)

def StateVector_IngestAddLeapSecondTime(builder, leapSecondTime):
    builder.PrependUOffsetTRelativeSlot(71, flatbuffers.number_types.UOffsetTFlags.py_type(leapSecondTime), 0)

def AddLeapSecondTime(builder, leapSecondTime):
    StateVector_IngestAddLeapSecondTime(builder, leapSecondTime)

def StateVector_IngestAddIntegratorMode(builder, integratorMode):
    builder.PrependUOffsetTRelativeSlot(72, flatbuffers.number_types.UOffsetTFlags.py_type(integratorMode), 0)

def AddIntegratorMode(builder, integratorMode):
    StateVector_IngestAddIntegratorMode(builder, integratorMode)

def StateVector_IngestAddPartials(builder, partials):
    builder.PrependUOffsetTRelativeSlot(73, flatbuffers.number_types.UOffsetTFlags.py_type(partials), 0)

def AddPartials(builder, partials):
    StateVector_IngestAddPartials(builder, partials)

def StateVector_IngestAddStepMode(builder, stepMode):
    builder.PrependUOffsetTRelativeSlot(74, flatbuffers.number_types.UOffsetTFlags.py_type(stepMode), 0)

def AddStepMode(builder, stepMode):
    StateVector_IngestAddStepMode(builder, stepMode)

def StateVector_IngestAddFixedStep(builder, fixedStep):
    builder.PrependBoolSlot(75, fixedStep, 0)

def AddFixedStep(builder, fixedStep):
    StateVector_IngestAddFixedStep(builder, fixedStep)

def StateVector_IngestAddStepSizeSelection(builder, stepSizeSelection):
    builder.PrependUOffsetTRelativeSlot(76, flatbuffers.number_types.UOffsetTFlags.py_type(stepSizeSelection), 0)

def AddStepSizeSelection(builder, stepSizeSelection):
    StateVector_IngestAddStepSizeSelection(builder, stepSizeSelection)

def StateVector_IngestAddStepSize(builder, stepSize):
    builder.PrependFloat64Slot(77, stepSize, 0.0)

def AddStepSize(builder, stepSize):
    StateVector_IngestAddStepSize(builder, stepSize)

def StateVector_IngestAddErrorControl(builder, errorControl):
    builder.PrependFloat64Slot(78, errorControl, 0.0)

def AddErrorControl(builder, errorControl):
    StateVector_IngestAddErrorControl(builder, errorControl)

def StateVector_IngestAddSigmaPosUvw(builder, sigmaPosUvw):
    builder.PrependUOffsetTRelativeSlot(79, flatbuffers.number_types.UOffsetTFlags.py_type(sigmaPosUvw), 0)

def AddSigmaPosUvw(builder, sigmaPosUvw):
    StateVector_IngestAddSigmaPosUvw(builder, sigmaPosUvw)

def StateVector_IngestStartSigmaPosUvwVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartSigmaPosUvwVector(builder, numElems):
    return StateVector_IngestStartSigmaPosUvwVector(builder, numElems)

def StateVector_IngestAddSigmaVelUvw(builder, sigmaVelUvw):
    builder.PrependUOffsetTRelativeSlot(80, flatbuffers.number_types.UOffsetTFlags.py_type(sigmaVelUvw), 0)

def AddSigmaVelUvw(builder, sigmaVelUvw):
    StateVector_IngestAddSigmaVelUvw(builder, sigmaVelUvw)

def StateVector_IngestStartSigmaVelUvwVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartSigmaVelUvwVector(builder, numElems):
    return StateVector_IngestStartSigmaVelUvwVector(builder, numElems)

def StateVector_IngestAddRms(builder, rms):
    builder.PrependFloat64Slot(81, rms, 0.0)

def AddRms(builder, rms):
    StateVector_IngestAddRms(builder, rms)

def StateVector_IngestAddRawFileUri(builder, rawFileUri):
    builder.PrependUOffsetTRelativeSlot(82, flatbuffers.number_types.UOffsetTFlags.py_type(rawFileUri), 0)

def AddRawFileUri(builder, rawFileUri):
    StateVector_IngestAddRawFileUri(builder, rawFileUri)

def StateVector_IngestAddSource(builder, source):
    builder.PrependUOffsetTRelativeSlot(83, flatbuffers.number_types.UOffsetTFlags.py_type(source), 0)

def AddSource(builder, source):
    StateVector_IngestAddSource(builder, source)

def StateVector_IngestAddOrigin(builder, origin):
    builder.PrependUOffsetTRelativeSlot(84, flatbuffers.number_types.UOffsetTFlags.py_type(origin), 0)

def AddOrigin(builder, origin):
    StateVector_IngestAddOrigin(builder, origin)

def StateVector_IngestAddDataMode(builder, dataMode):
    builder.PrependInt8Slot(85, dataMode, 0)

def AddDataMode(builder, dataMode):
    StateVector_IngestAddDataMode(builder, dataMode)

def StateVector_IngestAddTags(builder, tags):
    builder.PrependUOffsetTRelativeSlot(86, flatbuffers.number_types.UOffsetTFlags.py_type(tags), 0)

def AddTags(builder, tags):
    StateVector_IngestAddTags(builder, tags)

def StateVector_IngestStartTagsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartTagsVector(builder, numElems):
    return StateVector_IngestStartTagsVector(builder, numElems)

def StateVector_IngestAddAlgorithm(builder, algorithm):
    builder.PrependUOffsetTRelativeSlot(87, flatbuffers.number_types.UOffsetTFlags.py_type(algorithm), 0)

def AddAlgorithm(builder, algorithm):
    StateVector_IngestAddAlgorithm(builder, algorithm)

def StateVector_IngestAddSourcedData(builder, sourcedData):
    builder.PrependUOffsetTRelativeSlot(88, flatbuffers.number_types.UOffsetTFlags.py_type(sourcedData), 0)

def AddSourcedData(builder, sourcedData):
    StateVector_IngestAddSourcedData(builder, sourcedData)

def StateVector_IngestStartSourcedDataVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartSourcedDataVector(builder, numElems):
    return StateVector_IngestStartSourcedDataVector(builder, numElems)

def StateVector_IngestAddSourcedDataTypes(builder, sourcedDataTypes):
    builder.PrependInt8Slot(89, sourcedDataTypes, 0)

def AddSourcedDataTypes(builder, sourcedDataTypes):
    StateVector_IngestAddSourcedDataTypes(builder, sourcedDataTypes)

def StateVector_IngestAddCreatedAt(builder, createdAt):
    builder.PrependUOffsetTRelativeSlot(90, flatbuffers.number_types.UOffsetTFlags.py_type(createdAt), 0)

def AddCreatedAt(builder, createdAt):
    StateVector_IngestAddCreatedAt(builder, createdAt)

def StateVector_IngestAddCreatedBy(builder, createdBy):
    builder.PrependUOffsetTRelativeSlot(91, flatbuffers.number_types.UOffsetTFlags.py_type(createdBy), 0)

def AddCreatedBy(builder, createdBy):
    StateVector_IngestAddCreatedBy(builder, createdBy)

def StateVector_IngestAddDescriptor(builder, descriptor):
    builder.PrependUOffsetTRelativeSlot(92, flatbuffers.number_types.UOffsetTFlags.py_type(descriptor), 0)

def AddDescriptor(builder, descriptor):
    StateVector_IngestAddDescriptor(builder, descriptor)

def StateVector_IngestAddTransactionId(builder, transactionId):
    builder.PrependUOffsetTRelativeSlot(93, flatbuffers.number_types.UOffsetTFlags.py_type(transactionId), 0)

def AddTransactionId(builder, transactionId):
    StateVector_IngestAddTransactionId(builder, transactionId)

def StateVector_IngestAddOrigNetwork(builder, origNetwork):
    builder.PrependUOffsetTRelativeSlot(94, flatbuffers.number_types.UOffsetTFlags.py_type(origNetwork), 0)

def AddOrigNetwork(builder, origNetwork):
    StateVector_IngestAddOrigNetwork(builder, origNetwork)

def StateVector_IngestAddSourceDl(builder, sourceDl):
    builder.PrependUOffsetTRelativeSlot(95, flatbuffers.number_types.UOffsetTFlags.py_type(sourceDl), 0)

def AddSourceDl(builder, sourceDl):
    StateVector_IngestAddSourceDl(builder, sourceDl)

def StateVector_IngestEnd(builder):
    return builder.EndObject()

def End(builder):
    return StateVector_IngestEnd(builder)

try:
    from typing import List
except:
    pass

class StateVector_IngestT(object):

    # StateVector_IngestT
    def __init__(self):
        self.idStateVector = None  # type: str
        self.classificationMarking = None  # type: str
        self.epoch = None  # type: str
        self.pedigree = None  # type: str
        self.idOnOrbit = None  # type: str
        self.satNo = 0  # type: int
        self.origObjectId = None  # type: str
        self.idOrbitDetermination = None  # type: str
        self.uct = False  # type: bool
        self.xpos = 0.0  # type: float
        self.ypos = 0.0  # type: float
        self.zpos = 0.0  # type: float
        self.xvel = 0.0  # type: float
        self.yvel = 0.0  # type: float
        self.zvel = 0.0  # type: float
        self.referenceFrame = 0  # type: int
        self.cov = None  # type: List[str]
        self.covReferenceFrame = 0  # type: int
        self.covMethod = None  # type: str
        self.eqCov = None  # type: List[str]
        self.xposAlt1 = 0.0  # type: float
        self.yposAlt1 = 0.0  # type: float
        self.zposAlt1 = 0.0  # type: float
        self.xvelAlt1 = 0.0  # type: float
        self.yvelAlt1 = 0.0  # type: float
        self.zvelAlt1 = 0.0  # type: float
        self.alt1ReferenceFrame = None  # type: str
        self.xposAlt2 = 0.0  # type: float
        self.yposAlt2 = 0.0  # type: float
        self.zposAlt2 = 0.0  # type: float
        self.xvelAlt2 = 0.0  # type: float
        self.yvelAlt2 = 0.0  # type: float
        self.zvelAlt2 = 0.0  # type: float
        self.alt2ReferenceFrame = None  # type: str
        self.posUnc = 0.0  # type: float
        self.velUnc = 0.0  # type: float
        self.mass = 0.0  # type: float
        self.area = 0.0  # type: float
        self.solarRadPressCoeff = 0.0  # type: float
        self.dragCoeff = 0.0  # type: float
        self.dragArea = 0.0  # type: float
        self.revNo = 0  # type: int
        self.geopotentialModel = None  # type: str
        self.dragModel = None  # type: str
        self.lunarSolar = False  # type: bool
        self.solarRadPress = False  # type: bool
        self.srpArea = 0.0  # type: float
        self.solidEarthTides = False  # type: bool
        self.inTrackThrust = False  # type: bool
        self.bDot = 0.0  # type: float
        self.edr = 0.0  # type: float
        self.thrustAccel = 0.0  # type: float
        self.cmOffset = 0.0  # type: float
        self.lastObStart = None  # type: str
        self.lastObEnd = None  # type: str
        self.obsAvailable = 0  # type: int
        self.obsUsed = 0  # type: int
        self.tracksAvail = 0  # type: int
        self.tracksUsed = 0  # type: int
        self.recOdspan = 0.0  # type: float
        self.actualOdspan = 0.0  # type: float
        self.residualsAcc = 0.0  # type: float
        self.solarFluxF10 = 0.0  # type: float
        self.solarFluxF10Avg = 0.0  # type: float
        self.solarFluxApavg = 0.0  # type: float
        self.taiUtc = 0.0  # type: float
        self.ut1Utc = 0.0  # type: float
        self.ut1Rate = 0.0  # type: float
        self.polarMotionX = 0.0  # type: float
        self.polarMotionY = 0.0  # type: float
        self.iau1980Terms = 0  # type: int
        self.leapSecondTime = None  # type: str
        self.integratorMode = None  # type: str
        self.partials = None  # type: str
        self.stepMode = None  # type: str
        self.fixedStep = False  # type: bool
        self.stepSizeSelection = None  # type: str
        self.stepSize = 0.0  # type: float
        self.errorControl = 0.0  # type: float
        self.sigmaPosUvw = None  # type: List[str]
        self.sigmaVelUvw = None  # type: List[str]
        self.rms = 0.0  # type: float
        self.rawFileUri = None  # type: str
        self.source = None  # type: str
        self.origin = None  # type: str
        self.dataMode = 0  # type: int
        self.tags = None  # type: List[str]
        self.algorithm = None  # type: str
        self.sourcedData = None  # type: List[str]
        self.sourcedDataTypes = 0  # type: int
        self.createdAt = None  # type: str
        self.createdBy = None  # type: str
        self.descriptor = None  # type: str
        self.transactionId = None  # type: str
        self.origNetwork = None  # type: str
        self.sourceDl = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        stateVectorIngest = StateVector_Ingest()
        stateVectorIngest.Init(buf, pos)
        return cls.InitFromObj(stateVectorIngest)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, stateVectorIngest):
        x = StateVector_IngestT()
        x._UnPack(stateVectorIngest)
        return x

    # StateVector_IngestT
    def _UnPack(self, stateVectorIngest):
        if stateVectorIngest is None:
            return
        self.idStateVector = stateVectorIngest.IdStateVector()
        self.classificationMarking = stateVectorIngest.ClassificationMarking()
        self.epoch = stateVectorIngest.Epoch()
        self.pedigree = stateVectorIngest.Pedigree()
        self.idOnOrbit = stateVectorIngest.IdOnOrbit()
        self.satNo = stateVectorIngest.SatNo()
        self.origObjectId = stateVectorIngest.OrigObjectId()
        self.idOrbitDetermination = stateVectorIngest.IdOrbitDetermination()
        self.uct = stateVectorIngest.Uct()
        self.xpos = stateVectorIngest.Xpos()
        self.ypos = stateVectorIngest.Ypos()
        self.zpos = stateVectorIngest.Zpos()
        self.xvel = stateVectorIngest.Xvel()
        self.yvel = stateVectorIngest.Yvel()
        self.zvel = stateVectorIngest.Zvel()
        self.referenceFrame = stateVectorIngest.ReferenceFrame()
        if not stateVectorIngest.CovIsNone():
            self.cov = []
            for i in range(stateVectorIngest.CovLength()):
                self.cov.append(stateVectorIngest.Cov(i))
        self.covReferenceFrame = stateVectorIngest.CovReferenceFrame()
        self.covMethod = stateVectorIngest.CovMethod()
        if not stateVectorIngest.EqCovIsNone():
            self.eqCov = []
            for i in range(stateVectorIngest.EqCovLength()):
                self.eqCov.append(stateVectorIngest.EqCov(i))
        self.xposAlt1 = stateVectorIngest.XposAlt1()
        self.yposAlt1 = stateVectorIngest.YposAlt1()
        self.zposAlt1 = stateVectorIngest.ZposAlt1()
        self.xvelAlt1 = stateVectorIngest.XvelAlt1()
        self.yvelAlt1 = stateVectorIngest.YvelAlt1()
        self.zvelAlt1 = stateVectorIngest.ZvelAlt1()
        self.alt1ReferenceFrame = stateVectorIngest.Alt1ReferenceFrame()
        self.xposAlt2 = stateVectorIngest.XposAlt2()
        self.yposAlt2 = stateVectorIngest.YposAlt2()
        self.zposAlt2 = stateVectorIngest.ZposAlt2()
        self.xvelAlt2 = stateVectorIngest.XvelAlt2()
        self.yvelAlt2 = stateVectorIngest.YvelAlt2()
        self.zvelAlt2 = stateVectorIngest.ZvelAlt2()
        self.alt2ReferenceFrame = stateVectorIngest.Alt2ReferenceFrame()
        self.posUnc = stateVectorIngest.PosUnc()
        self.velUnc = stateVectorIngest.VelUnc()
        self.mass = stateVectorIngest.Mass()
        self.area = stateVectorIngest.Area()
        self.solarRadPressCoeff = stateVectorIngest.SolarRadPressCoeff()
        self.dragCoeff = stateVectorIngest.DragCoeff()
        self.dragArea = stateVectorIngest.DragArea()
        self.revNo = stateVectorIngest.RevNo()
        self.geopotentialModel = stateVectorIngest.GeopotentialModel()
        self.dragModel = stateVectorIngest.DragModel()
        self.lunarSolar = stateVectorIngest.LunarSolar()
        self.solarRadPress = stateVectorIngest.SolarRadPress()
        self.srpArea = stateVectorIngest.SrpArea()
        self.solidEarthTides = stateVectorIngest.SolidEarthTides()
        self.inTrackThrust = stateVectorIngest.InTrackThrust()
        self.bDot = stateVectorIngest.BDot()
        self.edr = stateVectorIngest.Edr()
        self.thrustAccel = stateVectorIngest.ThrustAccel()
        self.cmOffset = stateVectorIngest.CmOffset()
        self.lastObStart = stateVectorIngest.LastObStart()
        self.lastObEnd = stateVectorIngest.LastObEnd()
        self.obsAvailable = stateVectorIngest.ObsAvailable()
        self.obsUsed = stateVectorIngest.ObsUsed()
        self.tracksAvail = stateVectorIngest.TracksAvail()
        self.tracksUsed = stateVectorIngest.TracksUsed()
        self.recOdspan = stateVectorIngest.RecOdspan()
        self.actualOdspan = stateVectorIngest.ActualOdspan()
        self.residualsAcc = stateVectorIngest.ResidualsAcc()
        self.solarFluxF10 = stateVectorIngest.SolarFluxF10()
        self.solarFluxF10Avg = stateVectorIngest.SolarFluxF10Avg()
        self.solarFluxApavg = stateVectorIngest.SolarFluxApavg()
        self.taiUtc = stateVectorIngest.TaiUtc()
        self.ut1Utc = stateVectorIngest.Ut1Utc()
        self.ut1Rate = stateVectorIngest.Ut1Rate()
        self.polarMotionX = stateVectorIngest.PolarMotionX()
        self.polarMotionY = stateVectorIngest.PolarMotionY()
        self.iau1980Terms = stateVectorIngest.Iau1980Terms()
        self.leapSecondTime = stateVectorIngest.LeapSecondTime()
        self.integratorMode = stateVectorIngest.IntegratorMode()
        self.partials = stateVectorIngest.Partials()
        self.stepMode = stateVectorIngest.StepMode()
        self.fixedStep = stateVectorIngest.FixedStep()
        self.stepSizeSelection = stateVectorIngest.StepSizeSelection()
        self.stepSize = stateVectorIngest.StepSize()
        self.errorControl = stateVectorIngest.ErrorControl()
        if not stateVectorIngest.SigmaPosUvwIsNone():
            self.sigmaPosUvw = []
            for i in range(stateVectorIngest.SigmaPosUvwLength()):
                self.sigmaPosUvw.append(stateVectorIngest.SigmaPosUvw(i))
        if not stateVectorIngest.SigmaVelUvwIsNone():
            self.sigmaVelUvw = []
            for i in range(stateVectorIngest.SigmaVelUvwLength()):
                self.sigmaVelUvw.append(stateVectorIngest.SigmaVelUvw(i))
        self.rms = stateVectorIngest.Rms()
        self.rawFileUri = stateVectorIngest.RawFileUri()
        self.source = stateVectorIngest.Source()
        self.origin = stateVectorIngest.Origin()
        self.dataMode = stateVectorIngest.DataMode()
        if not stateVectorIngest.TagsIsNone():
            self.tags = []
            for i in range(stateVectorIngest.TagsLength()):
                self.tags.append(stateVectorIngest.Tags(i))
        self.algorithm = stateVectorIngest.Algorithm()
        if not stateVectorIngest.SourcedDataIsNone():
            self.sourcedData = []
            for i in range(stateVectorIngest.SourcedDataLength()):
                self.sourcedData.append(stateVectorIngest.SourcedData(i))
        self.sourcedDataTypes = stateVectorIngest.SourcedDataTypes()
        self.createdAt = stateVectorIngest.CreatedAt()
        self.createdBy = stateVectorIngest.CreatedBy()
        self.descriptor = stateVectorIngest.Descriptor()
        self.transactionId = stateVectorIngest.TransactionId()
        self.origNetwork = stateVectorIngest.OrigNetwork()
        self.sourceDl = stateVectorIngest.SourceDl()

    # StateVector_IngestT
    def Pack(self, builder):
        if self.idStateVector is not None:
            idStateVector = builder.CreateString(self.idStateVector)
        if self.classificationMarking is not None:
            classificationMarking = builder.CreateString(self.classificationMarking)
        if self.epoch is not None:
            epoch = builder.CreateString(self.epoch)
        if self.pedigree is not None:
            pedigree = builder.CreateString(self.pedigree)
        if self.idOnOrbit is not None:
            idOnOrbit = builder.CreateString(self.idOnOrbit)
        if self.origObjectId is not None:
            origObjectId = builder.CreateString(self.origObjectId)
        if self.idOrbitDetermination is not None:
            idOrbitDetermination = builder.CreateString(self.idOrbitDetermination)
        if self.cov is not None:
            covlist = []
            for i in range(len(self.cov)):
                covlist.append(builder.CreateString(self.cov[i]))
            StateVector_IngestStartCovVector(builder, len(self.cov))
            for i in reversed(range(len(self.cov))):
                builder.PrependUOffsetTRelative(covlist[i])
            cov = builder.EndVector()
        if self.covMethod is not None:
            covMethod = builder.CreateString(self.covMethod)
        if self.eqCov is not None:
            eqCovlist = []
            for i in range(len(self.eqCov)):
                eqCovlist.append(builder.CreateString(self.eqCov[i]))
            StateVector_IngestStartEqCovVector(builder, len(self.eqCov))
            for i in reversed(range(len(self.eqCov))):
                builder.PrependUOffsetTRelative(eqCovlist[i])
            eqCov = builder.EndVector()
        if self.alt1ReferenceFrame is not None:
            alt1ReferenceFrame = builder.CreateString(self.alt1ReferenceFrame)
        if self.alt2ReferenceFrame is not None:
            alt2ReferenceFrame = builder.CreateString(self.alt2ReferenceFrame)
        if self.geopotentialModel is not None:
            geopotentialModel = builder.CreateString(self.geopotentialModel)
        if self.dragModel is not None:
            dragModel = builder.CreateString(self.dragModel)
        if self.lastObStart is not None:
            lastObStart = builder.CreateString(self.lastObStart)
        if self.lastObEnd is not None:
            lastObEnd = builder.CreateString(self.lastObEnd)
        if self.leapSecondTime is not None:
            leapSecondTime = builder.CreateString(self.leapSecondTime)
        if self.integratorMode is not None:
            integratorMode = builder.CreateString(self.integratorMode)
        if self.partials is not None:
            partials = builder.CreateString(self.partials)
        if self.stepMode is not None:
            stepMode = builder.CreateString(self.stepMode)
        if self.stepSizeSelection is not None:
            stepSizeSelection = builder.CreateString(self.stepSizeSelection)
        if self.sigmaPosUvw is not None:
            sigmaPosUvwlist = []
            for i in range(len(self.sigmaPosUvw)):
                sigmaPosUvwlist.append(builder.CreateString(self.sigmaPosUvw[i]))
            StateVector_IngestStartSigmaPosUvwVector(builder, len(self.sigmaPosUvw))
            for i in reversed(range(len(self.sigmaPosUvw))):
                builder.PrependUOffsetTRelative(sigmaPosUvwlist[i])
            sigmaPosUvw = builder.EndVector()
        if self.sigmaVelUvw is not None:
            sigmaVelUvwlist = []
            for i in range(len(self.sigmaVelUvw)):
                sigmaVelUvwlist.append(builder.CreateString(self.sigmaVelUvw[i]))
            StateVector_IngestStartSigmaVelUvwVector(builder, len(self.sigmaVelUvw))
            for i in reversed(range(len(self.sigmaVelUvw))):
                builder.PrependUOffsetTRelative(sigmaVelUvwlist[i])
            sigmaVelUvw = builder.EndVector()
        if self.rawFileUri is not None:
            rawFileUri = builder.CreateString(self.rawFileUri)
        if self.source is not None:
            source = builder.CreateString(self.source)
        if self.origin is not None:
            origin = builder.CreateString(self.origin)
        if self.tags is not None:
            tagslist = []
            for i in range(len(self.tags)):
                tagslist.append(builder.CreateString(self.tags[i]))
            StateVector_IngestStartTagsVector(builder, len(self.tags))
            for i in reversed(range(len(self.tags))):
                builder.PrependUOffsetTRelative(tagslist[i])
            tags = builder.EndVector()
        if self.algorithm is not None:
            algorithm = builder.CreateString(self.algorithm)
        if self.sourcedData is not None:
            sourcedDatalist = []
            for i in range(len(self.sourcedData)):
                sourcedDatalist.append(builder.CreateString(self.sourcedData[i]))
            StateVector_IngestStartSourcedDataVector(builder, len(self.sourcedData))
            for i in reversed(range(len(self.sourcedData))):
                builder.PrependUOffsetTRelative(sourcedDatalist[i])
            sourcedData = builder.EndVector()
        if self.createdAt is not None:
            createdAt = builder.CreateString(self.createdAt)
        if self.createdBy is not None:
            createdBy = builder.CreateString(self.createdBy)
        if self.descriptor is not None:
            descriptor = builder.CreateString(self.descriptor)
        if self.transactionId is not None:
            transactionId = builder.CreateString(self.transactionId)
        if self.origNetwork is not None:
            origNetwork = builder.CreateString(self.origNetwork)
        if self.sourceDl is not None:
            sourceDl = builder.CreateString(self.sourceDl)
        StateVector_IngestStart(builder)
        if self.idStateVector is not None:
            StateVector_IngestAddIdStateVector(builder, idStateVector)
        if self.classificationMarking is not None:
            StateVector_IngestAddClassificationMarking(builder, classificationMarking)
        if self.epoch is not None:
            StateVector_IngestAddEpoch(builder, epoch)
        if self.pedigree is not None:
            StateVector_IngestAddPedigree(builder, pedigree)
        if self.idOnOrbit is not None:
            StateVector_IngestAddIdOnOrbit(builder, idOnOrbit)
        StateVector_IngestAddSatNo(builder, self.satNo)
        if self.origObjectId is not None:
            StateVector_IngestAddOrigObjectId(builder, origObjectId)
        if self.idOrbitDetermination is not None:
            StateVector_IngestAddIdOrbitDetermination(builder, idOrbitDetermination)
        StateVector_IngestAddUct(builder, self.uct)
        StateVector_IngestAddXpos(builder, self.xpos)
        StateVector_IngestAddYpos(builder, self.ypos)
        StateVector_IngestAddZpos(builder, self.zpos)
        StateVector_IngestAddXvel(builder, self.xvel)
        StateVector_IngestAddYvel(builder, self.yvel)
        StateVector_IngestAddZvel(builder, self.zvel)
        StateVector_IngestAddReferenceFrame(builder, self.referenceFrame)
        if self.cov is not None:
            StateVector_IngestAddCov(builder, cov)
        StateVector_IngestAddCovReferenceFrame(builder, self.covReferenceFrame)
        if self.covMethod is not None:
            StateVector_IngestAddCovMethod(builder, covMethod)
        if self.eqCov is not None:
            StateVector_IngestAddEqCov(builder, eqCov)
        StateVector_IngestAddXposAlt1(builder, self.xposAlt1)
        StateVector_IngestAddYposAlt1(builder, self.yposAlt1)
        StateVector_IngestAddZposAlt1(builder, self.zposAlt1)
        StateVector_IngestAddXvelAlt1(builder, self.xvelAlt1)
        StateVector_IngestAddYvelAlt1(builder, self.yvelAlt1)
        StateVector_IngestAddZvelAlt1(builder, self.zvelAlt1)
        if self.alt1ReferenceFrame is not None:
            StateVector_IngestAddAlt1ReferenceFrame(builder, alt1ReferenceFrame)
        StateVector_IngestAddXposAlt2(builder, self.xposAlt2)
        StateVector_IngestAddYposAlt2(builder, self.yposAlt2)
        StateVector_IngestAddZposAlt2(builder, self.zposAlt2)
        StateVector_IngestAddXvelAlt2(builder, self.xvelAlt2)
        StateVector_IngestAddYvelAlt2(builder, self.yvelAlt2)
        StateVector_IngestAddZvelAlt2(builder, self.zvelAlt2)
        if self.alt2ReferenceFrame is not None:
            StateVector_IngestAddAlt2ReferenceFrame(builder, alt2ReferenceFrame)
        StateVector_IngestAddPosUnc(builder, self.posUnc)
        StateVector_IngestAddVelUnc(builder, self.velUnc)
        StateVector_IngestAddMass(builder, self.mass)
        StateVector_IngestAddArea(builder, self.area)
        StateVector_IngestAddSolarRadPressCoeff(builder, self.solarRadPressCoeff)
        StateVector_IngestAddDragCoeff(builder, self.dragCoeff)
        StateVector_IngestAddDragArea(builder, self.dragArea)
        StateVector_IngestAddRevNo(builder, self.revNo)
        if self.geopotentialModel is not None:
            StateVector_IngestAddGeopotentialModel(builder, geopotentialModel)
        if self.dragModel is not None:
            StateVector_IngestAddDragModel(builder, dragModel)
        StateVector_IngestAddLunarSolar(builder, self.lunarSolar)
        StateVector_IngestAddSolarRadPress(builder, self.solarRadPress)
        StateVector_IngestAddSrpArea(builder, self.srpArea)
        StateVector_IngestAddSolidEarthTides(builder, self.solidEarthTides)
        StateVector_IngestAddInTrackThrust(builder, self.inTrackThrust)
        StateVector_IngestAddBDot(builder, self.bDot)
        StateVector_IngestAddEdr(builder, self.edr)
        StateVector_IngestAddThrustAccel(builder, self.thrustAccel)
        StateVector_IngestAddCmOffset(builder, self.cmOffset)
        if self.lastObStart is not None:
            StateVector_IngestAddLastObStart(builder, lastObStart)
        if self.lastObEnd is not None:
            StateVector_IngestAddLastObEnd(builder, lastObEnd)
        StateVector_IngestAddObsAvailable(builder, self.obsAvailable)
        StateVector_IngestAddObsUsed(builder, self.obsUsed)
        StateVector_IngestAddTracksAvail(builder, self.tracksAvail)
        StateVector_IngestAddTracksUsed(builder, self.tracksUsed)
        StateVector_IngestAddRecOdspan(builder, self.recOdspan)
        StateVector_IngestAddActualOdspan(builder, self.actualOdspan)
        StateVector_IngestAddResidualsAcc(builder, self.residualsAcc)
        StateVector_IngestAddSolarFluxF10(builder, self.solarFluxF10)
        StateVector_IngestAddSolarFluxF10Avg(builder, self.solarFluxF10Avg)
        StateVector_IngestAddSolarFluxApavg(builder, self.solarFluxApavg)
        StateVector_IngestAddTaiUtc(builder, self.taiUtc)
        StateVector_IngestAddUt1Utc(builder, self.ut1Utc)
        StateVector_IngestAddUt1Rate(builder, self.ut1Rate)
        StateVector_IngestAddPolarMotionX(builder, self.polarMotionX)
        StateVector_IngestAddPolarMotionY(builder, self.polarMotionY)
        StateVector_IngestAddIau1980Terms(builder, self.iau1980Terms)
        if self.leapSecondTime is not None:
            StateVector_IngestAddLeapSecondTime(builder, leapSecondTime)
        if self.integratorMode is not None:
            StateVector_IngestAddIntegratorMode(builder, integratorMode)
        if self.partials is not None:
            StateVector_IngestAddPartials(builder, partials)
        if self.stepMode is not None:
            StateVector_IngestAddStepMode(builder, stepMode)
        StateVector_IngestAddFixedStep(builder, self.fixedStep)
        if self.stepSizeSelection is not None:
            StateVector_IngestAddStepSizeSelection(builder, stepSizeSelection)
        StateVector_IngestAddStepSize(builder, self.stepSize)
        StateVector_IngestAddErrorControl(builder, self.errorControl)
        if self.sigmaPosUvw is not None:
            StateVector_IngestAddSigmaPosUvw(builder, sigmaPosUvw)
        if self.sigmaVelUvw is not None:
            StateVector_IngestAddSigmaVelUvw(builder, sigmaVelUvw)
        StateVector_IngestAddRms(builder, self.rms)
        if self.rawFileUri is not None:
            StateVector_IngestAddRawFileUri(builder, rawFileUri)
        if self.source is not None:
            StateVector_IngestAddSource(builder, source)
        if self.origin is not None:
            StateVector_IngestAddOrigin(builder, origin)
        StateVector_IngestAddDataMode(builder, self.dataMode)
        if self.tags is not None:
            StateVector_IngestAddTags(builder, tags)
        if self.algorithm is not None:
            StateVector_IngestAddAlgorithm(builder, algorithm)
        if self.sourcedData is not None:
            StateVector_IngestAddSourcedData(builder, sourcedData)
        StateVector_IngestAddSourcedDataTypes(builder, self.sourcedDataTypes)
        if self.createdAt is not None:
            StateVector_IngestAddCreatedAt(builder, createdAt)
        if self.createdBy is not None:
            StateVector_IngestAddCreatedBy(builder, createdBy)
        if self.descriptor is not None:
            StateVector_IngestAddDescriptor(builder, descriptor)
        if self.transactionId is not None:
            StateVector_IngestAddTransactionId(builder, transactionId)
        if self.origNetwork is not None:
            StateVector_IngestAddOrigNetwork(builder, origNetwork)
        if self.sourceDl is not None:
            StateVector_IngestAddSourceDl(builder, sourceDl)
        stateVectorIngest = StateVector_IngestEnd(builder)
        return stateVectorIngest
