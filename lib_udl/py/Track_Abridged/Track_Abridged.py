# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# /// A track is a position and optionally a heading/velocity of an object such as an aircraft at a particular timestamp. It also includes optional information regarding the identity/type of the target object, if known.
class Track_Abridged(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Track_Abridged()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTrack_Abridged(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def Track_AbridgedBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x54\x52\x41\x43", size_prefixed=size_prefixed)

    # Track_Abridged
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Unique identifier of the record, auto-generated by the system.
    # Example: /// Example: TRACK-ID
    # Constraints: Minimum length = 1, Maximum length = 36
    # Track_Abridged
    def Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Classification marking of the data in IC/CAPCO Portion-marked format.
    # Example: /// Example: U
    # Constraints: Minimum length = 1, Maximum length = 128
    # Track_Abridged
    def ClassificationMarking(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Contact information for assets reporting PPLI (Precise Participant Location and Identification). PPLI is a Link 16 message that is used by units to transmit complete location, identification, and limited status information.
    # Example: /// Example: Contact Info
    # Constraints: Minimum length = 0, Maximum length = 64
    # Track_Abridged
    def Cntct(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Time the row was created in the database, auto-populated by the system.
    # Example: /// Example: 2018-01-01T16:00:00.123Z
    # Constraints: No constraints specified.
    # Track_Abridged
    def CreatedAt(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Application user who created the row in the database, auto-populated by the system.
    # Example: /// Example: some.user
    # Constraints: Minimum length = 1, Maximum length = 64
    # Track_Abridged
    def CreatedBy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Message Timestamp.
    # Example: /// Example: 2021-01-01T01:01:01.123456Z
    # Constraints: No constraints specified.
    # Track_Abridged
    def MsgTs(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Mission ID related to the track.
    # Example: /// Example: msnId
    # Constraints: Minimum length = 0, Maximum length = 36
    # Track_Abridged
    def MsnId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Nationality or organization of the tracking/reporting system or platform (e.g. FR, NATO, US, etc.).
    # Example: /// Example: US
    # Constraints: Minimum length = 0, Maximum length = 64
    # Track_Abridged
    def AssetNat(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Id/name of the platform providing the track data (i.e., tail number for air platform, tower ID for tower based sensor, site id for fixed radar).
    # Example: /// Example: asset
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def Asset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Id/name of sensor providing the track data.
    # Example: /// Example: sen
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def Sen(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Sensor quality.
    # Example: /// Example: senQual
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def SenQual(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # UUID identifying the track, which should remain the same on subsequent tracks of the same object.
    # Example: /// Example: trkId
    # Constraints: Minimum length = 0, Maximum length = 36
    # Track_Abridged
    def TrkId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
    # Example: /// Example: trkNum
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def TrkNum(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Status of the track (e.g., INITIATING, MAINTAINING, DROPPING, TERMINATED, etc.).
    # Example: /// Example: INITIATING
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def TrkStat(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Nationality or organization of the track object (e.g. FR, NATO, US, etc.).
    # Example: /// Example: NATO
    # Constraints: Minimum length = 0, Maximum length = 64
    # Track_Abridged
    def ObjNat(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The UID or designation of the tracked object.
    # Example: /// Example: objId
    # Constraints: Minimum length = 0, Maximum length = 36
    # Track_Abridged
    def ObjId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The generic classification of the track object/group (e.g., HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
    # Example: /// Example: WATERCRAFT
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def ObjType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The object specific type. Intended as, but not constrained to, MIL-STD-6016 environment dependent specific type designations. The specific type can be reported as either a combination of the code and environment (e.g. 155/SURFACE) or as the descriptive representation (e.g. AUDACE DDG), which are equivalent.
    # Example: /// Example: LIGHT_TANK
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def ObjSpec(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
    # Example: /// Example: COMBAT_VEHICLE
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def ObjPlat(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.
    # Example: /// Example: HOLDING
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def ObjAct(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The type of source information from which the track was derived. Intended as, but not constrained to, NATO STANAG 4676 modality types (AIS, BFT, BIOMETRIC, COMINT, DOPPLER, ELINT, HRR, HUMINT, IMAGE, MASINT, MIXED, OSINT, OTHER):
    # AIS: Derived from an automated identification system source.
    # BFT: Derived from a blue force tracking source.
    # BIOMETRICS: Derived from a biometrics source.
    # COMINT: Derived from a communications intelligence source.
    # DOPPLER: Derived from a radar doppler source.
    # ELINT: Derived from an electronics intelligence source.
    # HRR: Derived from a radar high range resolution source.
    # HUMINT: Derived from a human intelligence source.
    # IMAGE: Derived from a still or motion imagery source.
    # MASINT: Derived from a measurement and signals intelligence source.
    # MIXED: Derived from a combination of two or more sources.
    # OSINT: Derived from an open source intelligence source.
    # OTHER: Derived from other types of unspecified sources.
    # Example: /// Example: MASINT
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def ModType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(44))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # UUID of the track item object, applies to STANAG-4676 messages.
    # Example: /// Example: trkItmId
    # Constraints: Minimum length = 0, Maximum length = 36
    # Track_Abridged
    def TrkItmId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(46))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Track timestamp in ISO8601 UTC format.
    # Example: /// Example: 2021-06-07T14:17:39.653Z
    # Constraints: No constraints specified.
    # Track_Abridged
    def Ts(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(48))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Value indicating track quality (not standardized).
    # Example: /// Example: 0
    # Constraints: No constraints specified.
    # Track_Abridged
    def TrkQual(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(50))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Means by which the track data was created (e.g., MEASURED, AUTOMATIC PREDICTED, etc.).
    # Example: /// Example: MEASURED
    # Constraints: No constraints specified.
    # Track_Abridged
    def TrkPtType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(52))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
    # ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
    # FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
    # HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
    # NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
    # PENDING: Track object which has not been evaluated.
    # SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
    # UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
    # Example: /// Example: FRIEND
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def ObjIdent(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(54))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Track object identity credibility.
    # Example: /// Example: 0
    # Constraints: No constraints specified.
    # Track_Abridged
    def IdentCred(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(56))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Track object identity reliability.
    # Example: /// Example: 0
    # Constraints: No constraints specified.
    # Track_Abridged
    def IdentRel(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(58))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
    # FAKER: Friendly track, object, or entity acting as an exercise hostile.
    # JOKER: Friendly track, object, or entity acting as an exercise suspect.
    # KILO: Friendly high-value object.
    # TRAVELLER: Suspect land or surface track following a recognized traffic route.
    # ZOMBIE: Suspect track, object, or entity of special interest.
    # Example: /// Example: ZOMBIE
    # Constraints: Minimum length = 0, Maximum length = 32
    # Track_Abridged
    def IdentAmp(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(60))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
    # AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
    # LAND: On the surface of dry land.
    # SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
    # SURFACE: On the surface of a body of water.
    # SUBSURFACE: Below the surface of a body of water.
    # UNKNOWN: Environment is not known.
    # Example: /// Example: LAND
    # Constraints: Minimum length = 0, Maximum length = 16
    # Track_Abridged
    def Env(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(62))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Track environment confidence estimate (not standardized).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Track_Abridged
    def EnvConf(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(64))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Track_Abridged
    def TrkConf(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(66))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Track object location in ECEF [x, y, z], meters.  When provided, array must always contain 3 values.
    # Example: /// Example: [1.23, 2.34, 3.45]
    # Constraints: No constraints specified.
    # Track_Abridged
    def EcefPos(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(68))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def EcefPosLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(68))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def EcefPosIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(68))
        return o == 0

    # Track object velocity in ECEF [x', y', z'], meters/sec.  When provided, array must always contain 3 values.
    # Example: /// Example: [1.23, 2.34, 3.45]
    # Constraints: No constraints specified.
    # Track_Abridged
    def EcefVel(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(70))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def EcefVelLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(70))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def EcefVelIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(70))
        return o == 0

    # Track object acceleration in ECEF [x'', y'', z''], meters/sec^2.  When provided, array must always contain 3 values.
    # Example: /// Example: [1.23, 2.34, 3.45]
    # Constraints: No constraints specified.
    # Track_Abridged
    def EcefAcc(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(72))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def EcefAccLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(72))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def EcefAccIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(72))
        return o == 0

    # WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Track_Abridged
    def Lat(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(74))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Track_Abridged
    def Lon(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(76))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Track_Abridged
    def Alt(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(78))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Track object spd, in meters/sec.
    # Example: /// Example: 1.23
    # Constraints: No constraints specified.
    # Track_Abridged
    def Spd(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(80))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # The track object heading, in degrees clockwise from true North at the object location.
    # Example: /// Example: 19.7
    # Constraints: No constraints specified.
    # Track_Abridged
    def Hdng(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(82))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
    # Example: /// Example: 88.37
    # Constraints: No constraints specified.
    # Track_Abridged
    def Course(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(84))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # Origin of a local coordinate system [lat, lon, altitude].  When provided, array must always contain 3 values.
    # Example: /// Example: [1.23, 2.34, 3.45]
    # Constraints: No constraints specified.
    # Track_Abridged
    def Lco(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(86))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def LcoLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(86))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def LcoIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(86))
        return o == 0

    # x, y, and z-axis rotations about ECEF that define a local cartesian system.  When provided, array must always contain 3 values.
    # Example: /// Example: [1.23, 2.34, 3.45]
    # Constraints: No constraints specified.
    # Track_Abridged
    def Lcs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(88))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def LcsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(88))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def LcsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(88))
        return o == 0

    # Estimate of the position, [x, y, z], of the track object in the defined cartesian system, in meters.  When provided, array must always contain 3 values.
    # Example: /// Example: [1.23, 2.34, 3.45]
    # Constraints: No constraints specified.
    # Track_Abridged
    def LcPos(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(90))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def LcPosLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(90))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def LcPosIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(90))
        return o == 0

    # Estimate of the velocity, [x', y', z'], of the track object in the defined cartesian system, in meters/sec.  When provided, array must always contain 3 values.
    # Example: /// Example: [1.23, 2.34, 3.45]
    # Constraints: No constraints specified.
    # Track_Abridged
    def LcVel(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(92))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def LcVelLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(92))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def LcVelIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(92))
        return o == 0

    # Estimate of the acceleration, [x'', y'', z''], of the track object in the defined cartesian system, in meters/sec^2.  When provided, array must always contain 3 values.
    # Example: /// Example: [1.23, 2.34, 3.45]
    # Constraints: No constraints specified.
    # Track_Abridged
    def LcAcc(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(94))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def LcAccLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(94))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def LcAccIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(94))
        return o == 0

    # East, North, Up velocity components, in meters/sec.  When provided, array must always contain 3 values.
    # Example: /// Example: [1.23, 2.34, 3.45]
    # Constraints: No constraints specified.
    # Track_Abridged
    def ENuvel(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(96))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def ENuvelLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(96))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def ENuvelIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(96))
        return o == 0

    # East, North, Up position components, in meters.  When provided, array must always contain 3 values.
    # Example: /// Example: [1.23, 2.34, 3.45]
    # Constraints: No constraints specified.
    # Track_Abridged
    def ENupos(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(98))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def ENuposLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(98))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def ENuposIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(98))
        return o == 0

    # Covariance matrix, in meter and second based units, for the defined cartesian system.
    # The array values represent the lower triangular half of the position-velocity covariance matrix.  The size of the covariance matrix is dynamic.  The values are output as an array of values corresponding to the position-velocity covariance element positions, ordered as follows:
    # &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
    # x&nbsp;&nbsp;&nbsp;&nbsp;1
    # y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
    # z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
    # x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
    # y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
    # z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
    # The covariance matrix will be as large as the last element needed, and with unused values zero-filled to maintain proper element positioning in the array.  For example, for a 2D (x, y) position-only covariance, the covariance matrix will be 2x2 and the array would contain the 3 elements corresponding to the x, and y position.  Another example, now for a 2D (x, y) position-velocity covariance, the covariance matrix will be 5x5 and the array would contain the 15 elements corresponding to the relevant x, y, x', and y' values (with the z-row and z-column being all zeros). The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
    # Example: /// Example: [1.1, 2.2, 3.3]
    # Constraints: No constraints specified.
    # Track_Abridged
    def Cov(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(100))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def CovLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(100))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def CovIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(100))
        return o == 0

    # Uncertainty ellipsoid [semi-major axis (m), semi-minor axis (m), orientation (deg)].
    # Example: /// Example: [1.23, 2.34, 3.45]
    # Constraints: No constraints specified.
    # Track_Abridged
    def ErrEllp(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(102))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def ErrEllpLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(102))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def ErrEllpIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(102))
        return o == 0

    # Array of UDL record types (POI, MTI, TRACK, GROUNDIMAGE) that contributed to the generation of this fused track.  See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array, used in the track fusion. The 'srcTyps' and 'srcIds' arrays must match in size.
    # Example: /// Example: ['MTI', 'POI']
    # Constraints: No constraints specified.
    # Track_Abridged
    def SrcTyps(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(104))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def SrcTypsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(104))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def SrcTypsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(104))
        return o == 0

    # Array of UUIDs of the UDL data records that contributed to the generation of this fused track. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array, used in the track fusion.  The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object (e.g. /udl/poi/{uuid}).
    # Example: /// Example: ['f7c70cc8-f9b7-4467-b4ad-3904e360e842', '1da3fab000014e3133709830937387405']
    # Constraints: No constraints specified.
    # Track_Abridged
    def SrcIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(106))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def SrcIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(106))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def SrcIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(106))
        return o == 0

    # The call sign currently assigned to this track object.
    # Example: /// Example: callSign
    # Constraints: Minimum length = 0, Maximum length = 24
    # Track_Abridged
    def CallSign(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(108))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Flag indicating that this track is fused from multiple sensor sources.
    # Example: /// Example: True
    # Constraints: No constraints specified.
    # Track_Abridged
    def MultiSource(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(110))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # The J-series message type, if this track is derived from a J-series message.
    # Example: /// Example: J12.5
    # Constraints: Minimum length = 0, Maximum length = 5
    # Track_Abridged
    def JSeries(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(112))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The number of objects or units moving as a group and represented as a single entity in this track message. If null, the track is assumed to represent a single object. Note that if this track derives from a J-series message then special definitions apply for the following values: 13 indicates an estimated 2-7 units, 14 indicates an estimated more than 7 units, and 15 indicates an estimated more than 12 units.
    # Example: /// Example: 14
    # Constraints: No constraints specified.
    # Track_Abridged
    def Strength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(114))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Mode-1 interrogation response (mission code), indicating mission or aircraft type.
    # Example: /// Example: 1234
    # Constraints: No constraints specified.
    # Track_Abridged
    def M1(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(116))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Mode-1 validity status.
    # Example: /// Example: 1
    # Constraints: No constraints specified.
    # Track_Abridged
    def M1v(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(118))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Mode-2 interrogation response (military identification code).
    # Example: /// Example: 1234
    # Constraints: No constraints specified.
    # Track_Abridged
    def M2(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(120))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Mode-2 validity status.
    # Example: /// Example: 1
    # Constraints: No constraints specified.
    # Track_Abridged
    def M2v(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(122))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Mode-3/A interrogation response (aircraft identification), provides a 4-digit octal identification code for the aircraft, assigned by the air traffic controller. Mode-3/A is shared military/civilian use.
    # Example: /// Example: 2636
    # Constraints: No constraints specified.
    # Track_Abridged
    def M3a(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(124))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Mode-3/A validity status.
    # Example: /// Example: 1
    # Constraints: No constraints specified.
    # Track_Abridged
    def M3av(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(126))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
    # Example: /// Example: ['TAG1', 'TAG2']
    # Constraints: No constraints specified.
    # Track_Abridged
    def Tags(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(128))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Track_Abridged
    def TagsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(128))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Track_Abridged
    def TagsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(128))
        return o == 0

    # The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
    # Example: /// Example: AXE
    # Constraints: Minimum length = 0, Maximum length = 64
    # Track_Abridged
    def SourceDl(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(130))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Source of the data.
    # Example: /// Example: Bluestaq
    # Constraints: Minimum length = 1, Maximum length = 64
    # Track_Abridged
    def Source(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(132))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
    # Example: /// Example: THIRD_PARTY_DATASOURCE
    # Constraints: Minimum length = 0, Maximum length = 64
    # Track_Abridged
    def Origin(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(134))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
    # EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
    # REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
    # SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
    # TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    # Example: /// Example: TEST
    # Constraints: Minimum length = 1, Maximum length = 32
    # Track_Abridged
    def DataMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(136))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # The originating source network on which this record was created, auto-populated by the system.
    # Example: /// Example: ORIG
    # Constraints: Minimum length = 1, Maximum length = 32
    # Track_Abridged
    def OrigNetwork(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(138))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def Track_AbridgedStart(builder):
    builder.StartObject(68)

def Start(builder):
    Track_AbridgedStart(builder)

def Track_AbridgedAddId(builder, id):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(id), 0)

def AddId(builder, id):
    Track_AbridgedAddId(builder, id)

def Track_AbridgedAddClassificationMarking(builder, classificationMarking):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(classificationMarking), 0)

def AddClassificationMarking(builder, classificationMarking):
    Track_AbridgedAddClassificationMarking(builder, classificationMarking)

def Track_AbridgedAddCntct(builder, cntct):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(cntct), 0)

def AddCntct(builder, cntct):
    Track_AbridgedAddCntct(builder, cntct)

def Track_AbridgedAddCreatedAt(builder, createdAt):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(createdAt), 0)

def AddCreatedAt(builder, createdAt):
    Track_AbridgedAddCreatedAt(builder, createdAt)

def Track_AbridgedAddCreatedBy(builder, createdBy):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(createdBy), 0)

def AddCreatedBy(builder, createdBy):
    Track_AbridgedAddCreatedBy(builder, createdBy)

def Track_AbridgedAddMsgTs(builder, msgTs):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(msgTs), 0)

def AddMsgTs(builder, msgTs):
    Track_AbridgedAddMsgTs(builder, msgTs)

def Track_AbridgedAddMsnId(builder, msnId):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(msnId), 0)

def AddMsnId(builder, msnId):
    Track_AbridgedAddMsnId(builder, msnId)

def Track_AbridgedAddAssetNat(builder, assetNat):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(assetNat), 0)

def AddAssetNat(builder, assetNat):
    Track_AbridgedAddAssetNat(builder, assetNat)

def Track_AbridgedAddAsset(builder, asset):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(asset), 0)

def AddAsset(builder, asset):
    Track_AbridgedAddAsset(builder, asset)

def Track_AbridgedAddSen(builder, sen):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(sen), 0)

def AddSen(builder, sen):
    Track_AbridgedAddSen(builder, sen)

def Track_AbridgedAddSenQual(builder, senQual):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(senQual), 0)

def AddSenQual(builder, senQual):
    Track_AbridgedAddSenQual(builder, senQual)

def Track_AbridgedAddTrkId(builder, trkId):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(trkId), 0)

def AddTrkId(builder, trkId):
    Track_AbridgedAddTrkId(builder, trkId)

def Track_AbridgedAddTrkNum(builder, trkNum):
    builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(trkNum), 0)

def AddTrkNum(builder, trkNum):
    Track_AbridgedAddTrkNum(builder, trkNum)

def Track_AbridgedAddTrkStat(builder, trkStat):
    builder.PrependUOffsetTRelativeSlot(13, flatbuffers.number_types.UOffsetTFlags.py_type(trkStat), 0)

def AddTrkStat(builder, trkStat):
    Track_AbridgedAddTrkStat(builder, trkStat)

def Track_AbridgedAddObjNat(builder, objNat):
    builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(objNat), 0)

def AddObjNat(builder, objNat):
    Track_AbridgedAddObjNat(builder, objNat)

def Track_AbridgedAddObjId(builder, objId):
    builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(objId), 0)

def AddObjId(builder, objId):
    Track_AbridgedAddObjId(builder, objId)

def Track_AbridgedAddObjType(builder, objType):
    builder.PrependUOffsetTRelativeSlot(16, flatbuffers.number_types.UOffsetTFlags.py_type(objType), 0)

def AddObjType(builder, objType):
    Track_AbridgedAddObjType(builder, objType)

def Track_AbridgedAddObjSpec(builder, objSpec):
    builder.PrependUOffsetTRelativeSlot(17, flatbuffers.number_types.UOffsetTFlags.py_type(objSpec), 0)

def AddObjSpec(builder, objSpec):
    Track_AbridgedAddObjSpec(builder, objSpec)

def Track_AbridgedAddObjPlat(builder, objPlat):
    builder.PrependUOffsetTRelativeSlot(18, flatbuffers.number_types.UOffsetTFlags.py_type(objPlat), 0)

def AddObjPlat(builder, objPlat):
    Track_AbridgedAddObjPlat(builder, objPlat)

def Track_AbridgedAddObjAct(builder, objAct):
    builder.PrependUOffsetTRelativeSlot(19, flatbuffers.number_types.UOffsetTFlags.py_type(objAct), 0)

def AddObjAct(builder, objAct):
    Track_AbridgedAddObjAct(builder, objAct)

def Track_AbridgedAddModType(builder, modType):
    builder.PrependUOffsetTRelativeSlot(20, flatbuffers.number_types.UOffsetTFlags.py_type(modType), 0)

def AddModType(builder, modType):
    Track_AbridgedAddModType(builder, modType)

def Track_AbridgedAddTrkItmId(builder, trkItmId):
    builder.PrependUOffsetTRelativeSlot(21, flatbuffers.number_types.UOffsetTFlags.py_type(trkItmId), 0)

def AddTrkItmId(builder, trkItmId):
    Track_AbridgedAddTrkItmId(builder, trkItmId)

def Track_AbridgedAddTs(builder, ts):
    builder.PrependUOffsetTRelativeSlot(22, flatbuffers.number_types.UOffsetTFlags.py_type(ts), 0)

def AddTs(builder, ts):
    Track_AbridgedAddTs(builder, ts)

def Track_AbridgedAddTrkQual(builder, trkQual):
    builder.PrependInt32Slot(23, trkQual, 0)

def AddTrkQual(builder, trkQual):
    Track_AbridgedAddTrkQual(builder, trkQual)

def Track_AbridgedAddTrkPtType(builder, trkPtType):
    builder.PrependUOffsetTRelativeSlot(24, flatbuffers.number_types.UOffsetTFlags.py_type(trkPtType), 0)

def AddTrkPtType(builder, trkPtType):
    Track_AbridgedAddTrkPtType(builder, trkPtType)

def Track_AbridgedAddObjIdent(builder, objIdent):
    builder.PrependUOffsetTRelativeSlot(25, flatbuffers.number_types.UOffsetTFlags.py_type(objIdent), 0)

def AddObjIdent(builder, objIdent):
    Track_AbridgedAddObjIdent(builder, objIdent)

def Track_AbridgedAddIdentCred(builder, identCred):
    builder.PrependInt32Slot(26, identCred, 0)

def AddIdentCred(builder, identCred):
    Track_AbridgedAddIdentCred(builder, identCred)

def Track_AbridgedAddIdentRel(builder, identRel):
    builder.PrependInt32Slot(27, identRel, 0)

def AddIdentRel(builder, identRel):
    Track_AbridgedAddIdentRel(builder, identRel)

def Track_AbridgedAddIdentAmp(builder, identAmp):
    builder.PrependUOffsetTRelativeSlot(28, flatbuffers.number_types.UOffsetTFlags.py_type(identAmp), 0)

def AddIdentAmp(builder, identAmp):
    Track_AbridgedAddIdentAmp(builder, identAmp)

def Track_AbridgedAddEnv(builder, env):
    builder.PrependUOffsetTRelativeSlot(29, flatbuffers.number_types.UOffsetTFlags.py_type(env), 0)

def AddEnv(builder, env):
    Track_AbridgedAddEnv(builder, env)

def Track_AbridgedAddEnvConf(builder, envConf):
    builder.PrependFloat64Slot(30, envConf, 0.0)

def AddEnvConf(builder, envConf):
    Track_AbridgedAddEnvConf(builder, envConf)

def Track_AbridgedAddTrkConf(builder, trkConf):
    builder.PrependFloat64Slot(31, trkConf, 0.0)

def AddTrkConf(builder, trkConf):
    Track_AbridgedAddTrkConf(builder, trkConf)

def Track_AbridgedAddEcefPos(builder, ecefPos):
    builder.PrependUOffsetTRelativeSlot(32, flatbuffers.number_types.UOffsetTFlags.py_type(ecefPos), 0)

def AddEcefPos(builder, ecefPos):
    Track_AbridgedAddEcefPos(builder, ecefPos)

def Track_AbridgedStartEcefPosVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartEcefPosVector(builder, numElems):
    return Track_AbridgedStartEcefPosVector(builder, numElems)

def Track_AbridgedAddEcefVel(builder, ecefVel):
    builder.PrependUOffsetTRelativeSlot(33, flatbuffers.number_types.UOffsetTFlags.py_type(ecefVel), 0)

def AddEcefVel(builder, ecefVel):
    Track_AbridgedAddEcefVel(builder, ecefVel)

def Track_AbridgedStartEcefVelVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartEcefVelVector(builder, numElems):
    return Track_AbridgedStartEcefVelVector(builder, numElems)

def Track_AbridgedAddEcefAcc(builder, ecefAcc):
    builder.PrependUOffsetTRelativeSlot(34, flatbuffers.number_types.UOffsetTFlags.py_type(ecefAcc), 0)

def AddEcefAcc(builder, ecefAcc):
    Track_AbridgedAddEcefAcc(builder, ecefAcc)

def Track_AbridgedStartEcefAccVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartEcefAccVector(builder, numElems):
    return Track_AbridgedStartEcefAccVector(builder, numElems)

def Track_AbridgedAddLat(builder, lat):
    builder.PrependFloat64Slot(35, lat, 0.0)

def AddLat(builder, lat):
    Track_AbridgedAddLat(builder, lat)

def Track_AbridgedAddLon(builder, lon):
    builder.PrependFloat64Slot(36, lon, 0.0)

def AddLon(builder, lon):
    Track_AbridgedAddLon(builder, lon)

def Track_AbridgedAddAlt(builder, alt):
    builder.PrependFloat64Slot(37, alt, 0.0)

def AddAlt(builder, alt):
    Track_AbridgedAddAlt(builder, alt)

def Track_AbridgedAddSpd(builder, spd):
    builder.PrependFloat64Slot(38, spd, 0.0)

def AddSpd(builder, spd):
    Track_AbridgedAddSpd(builder, spd)

def Track_AbridgedAddHdng(builder, hdng):
    builder.PrependFloat64Slot(39, hdng, 0.0)

def AddHdng(builder, hdng):
    Track_AbridgedAddHdng(builder, hdng)

def Track_AbridgedAddCourse(builder, course):
    builder.PrependFloat64Slot(40, course, 0.0)

def AddCourse(builder, course):
    Track_AbridgedAddCourse(builder, course)

def Track_AbridgedAddLco(builder, lco):
    builder.PrependUOffsetTRelativeSlot(41, flatbuffers.number_types.UOffsetTFlags.py_type(lco), 0)

def AddLco(builder, lco):
    Track_AbridgedAddLco(builder, lco)

def Track_AbridgedStartLcoVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartLcoVector(builder, numElems):
    return Track_AbridgedStartLcoVector(builder, numElems)

def Track_AbridgedAddLcs(builder, lcs):
    builder.PrependUOffsetTRelativeSlot(42, flatbuffers.number_types.UOffsetTFlags.py_type(lcs), 0)

def AddLcs(builder, lcs):
    Track_AbridgedAddLcs(builder, lcs)

def Track_AbridgedStartLcsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartLcsVector(builder, numElems):
    return Track_AbridgedStartLcsVector(builder, numElems)

def Track_AbridgedAddLcPos(builder, lcPos):
    builder.PrependUOffsetTRelativeSlot(43, flatbuffers.number_types.UOffsetTFlags.py_type(lcPos), 0)

def AddLcPos(builder, lcPos):
    Track_AbridgedAddLcPos(builder, lcPos)

def Track_AbridgedStartLcPosVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartLcPosVector(builder, numElems):
    return Track_AbridgedStartLcPosVector(builder, numElems)

def Track_AbridgedAddLcVel(builder, lcVel):
    builder.PrependUOffsetTRelativeSlot(44, flatbuffers.number_types.UOffsetTFlags.py_type(lcVel), 0)

def AddLcVel(builder, lcVel):
    Track_AbridgedAddLcVel(builder, lcVel)

def Track_AbridgedStartLcVelVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartLcVelVector(builder, numElems):
    return Track_AbridgedStartLcVelVector(builder, numElems)

def Track_AbridgedAddLcAcc(builder, lcAcc):
    builder.PrependUOffsetTRelativeSlot(45, flatbuffers.number_types.UOffsetTFlags.py_type(lcAcc), 0)

def AddLcAcc(builder, lcAcc):
    Track_AbridgedAddLcAcc(builder, lcAcc)

def Track_AbridgedStartLcAccVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartLcAccVector(builder, numElems):
    return Track_AbridgedStartLcAccVector(builder, numElems)

def Track_AbridgedAddENuvel(builder, eNuvel):
    builder.PrependUOffsetTRelativeSlot(46, flatbuffers.number_types.UOffsetTFlags.py_type(eNuvel), 0)

def AddENuvel(builder, eNuvel):
    Track_AbridgedAddENuvel(builder, eNuvel)

def Track_AbridgedStartENuvelVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartENuvelVector(builder, numElems):
    return Track_AbridgedStartENuvelVector(builder, numElems)

def Track_AbridgedAddENupos(builder, eNupos):
    builder.PrependUOffsetTRelativeSlot(47, flatbuffers.number_types.UOffsetTFlags.py_type(eNupos), 0)

def AddENupos(builder, eNupos):
    Track_AbridgedAddENupos(builder, eNupos)

def Track_AbridgedStartENuposVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartENuposVector(builder, numElems):
    return Track_AbridgedStartENuposVector(builder, numElems)

def Track_AbridgedAddCov(builder, cov):
    builder.PrependUOffsetTRelativeSlot(48, flatbuffers.number_types.UOffsetTFlags.py_type(cov), 0)

def AddCov(builder, cov):
    Track_AbridgedAddCov(builder, cov)

def Track_AbridgedStartCovVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartCovVector(builder, numElems):
    return Track_AbridgedStartCovVector(builder, numElems)

def Track_AbridgedAddErrEllp(builder, errEllp):
    builder.PrependUOffsetTRelativeSlot(49, flatbuffers.number_types.UOffsetTFlags.py_type(errEllp), 0)

def AddErrEllp(builder, errEllp):
    Track_AbridgedAddErrEllp(builder, errEllp)

def Track_AbridgedStartErrEllpVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartErrEllpVector(builder, numElems):
    return Track_AbridgedStartErrEllpVector(builder, numElems)

def Track_AbridgedAddSrcTyps(builder, srcTyps):
    builder.PrependUOffsetTRelativeSlot(50, flatbuffers.number_types.UOffsetTFlags.py_type(srcTyps), 0)

def AddSrcTyps(builder, srcTyps):
    Track_AbridgedAddSrcTyps(builder, srcTyps)

def Track_AbridgedStartSrcTypsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartSrcTypsVector(builder, numElems):
    return Track_AbridgedStartSrcTypsVector(builder, numElems)

def Track_AbridgedAddSrcIds(builder, srcIds):
    builder.PrependUOffsetTRelativeSlot(51, flatbuffers.number_types.UOffsetTFlags.py_type(srcIds), 0)

def AddSrcIds(builder, srcIds):
    Track_AbridgedAddSrcIds(builder, srcIds)

def Track_AbridgedStartSrcIdsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartSrcIdsVector(builder, numElems):
    return Track_AbridgedStartSrcIdsVector(builder, numElems)

def Track_AbridgedAddCallSign(builder, callSign):
    builder.PrependUOffsetTRelativeSlot(52, flatbuffers.number_types.UOffsetTFlags.py_type(callSign), 0)

def AddCallSign(builder, callSign):
    Track_AbridgedAddCallSign(builder, callSign)

def Track_AbridgedAddMultiSource(builder, multiSource):
    builder.PrependBoolSlot(53, multiSource, 0)

def AddMultiSource(builder, multiSource):
    Track_AbridgedAddMultiSource(builder, multiSource)

def Track_AbridgedAddJSeries(builder, jSeries):
    builder.PrependUOffsetTRelativeSlot(54, flatbuffers.number_types.UOffsetTFlags.py_type(jSeries), 0)

def AddJSeries(builder, jSeries):
    Track_AbridgedAddJSeries(builder, jSeries)

def Track_AbridgedAddStrength(builder, strength):
    builder.PrependInt32Slot(55, strength, 0)

def AddStrength(builder, strength):
    Track_AbridgedAddStrength(builder, strength)

def Track_AbridgedAddM1(builder, m1):
    builder.PrependInt32Slot(56, m1, 0)

def AddM1(builder, m1):
    Track_AbridgedAddM1(builder, m1)

def Track_AbridgedAddM1v(builder, m1v):
    builder.PrependInt32Slot(57, m1v, 0)

def AddM1v(builder, m1v):
    Track_AbridgedAddM1v(builder, m1v)

def Track_AbridgedAddM2(builder, m2):
    builder.PrependInt32Slot(58, m2, 0)

def AddM2(builder, m2):
    Track_AbridgedAddM2(builder, m2)

def Track_AbridgedAddM2v(builder, m2v):
    builder.PrependInt32Slot(59, m2v, 0)

def AddM2v(builder, m2v):
    Track_AbridgedAddM2v(builder, m2v)

def Track_AbridgedAddM3a(builder, m3a):
    builder.PrependInt32Slot(60, m3a, 0)

def AddM3a(builder, m3a):
    Track_AbridgedAddM3a(builder, m3a)

def Track_AbridgedAddM3av(builder, m3av):
    builder.PrependInt32Slot(61, m3av, 0)

def AddM3av(builder, m3av):
    Track_AbridgedAddM3av(builder, m3av)

def Track_AbridgedAddTags(builder, tags):
    builder.PrependUOffsetTRelativeSlot(62, flatbuffers.number_types.UOffsetTFlags.py_type(tags), 0)

def AddTags(builder, tags):
    Track_AbridgedAddTags(builder, tags)

def Track_AbridgedStartTagsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartTagsVector(builder, numElems):
    return Track_AbridgedStartTagsVector(builder, numElems)

def Track_AbridgedAddSourceDl(builder, sourceDl):
    builder.PrependUOffsetTRelativeSlot(63, flatbuffers.number_types.UOffsetTFlags.py_type(sourceDl), 0)

def AddSourceDl(builder, sourceDl):
    Track_AbridgedAddSourceDl(builder, sourceDl)

def Track_AbridgedAddSource(builder, source):
    builder.PrependUOffsetTRelativeSlot(64, flatbuffers.number_types.UOffsetTFlags.py_type(source), 0)

def AddSource(builder, source):
    Track_AbridgedAddSource(builder, source)

def Track_AbridgedAddOrigin(builder, origin):
    builder.PrependUOffsetTRelativeSlot(65, flatbuffers.number_types.UOffsetTFlags.py_type(origin), 0)

def AddOrigin(builder, origin):
    Track_AbridgedAddOrigin(builder, origin)

def Track_AbridgedAddDataMode(builder, dataMode):
    builder.PrependInt8Slot(66, dataMode, 0)

def AddDataMode(builder, dataMode):
    Track_AbridgedAddDataMode(builder, dataMode)

def Track_AbridgedAddOrigNetwork(builder, origNetwork):
    builder.PrependUOffsetTRelativeSlot(67, flatbuffers.number_types.UOffsetTFlags.py_type(origNetwork), 0)

def AddOrigNetwork(builder, origNetwork):
    Track_AbridgedAddOrigNetwork(builder, origNetwork)

def Track_AbridgedEnd(builder):
    return builder.EndObject()

def End(builder):
    return Track_AbridgedEnd(builder)

try:
    from typing import List
except:
    pass

class Track_AbridgedT(object):

    # Track_AbridgedT
    def __init__(self):
        self.id = None  # type: str
        self.classificationMarking = None  # type: str
        self.cntct = None  # type: str
        self.createdAt = None  # type: str
        self.createdBy = None  # type: str
        self.msgTs = None  # type: str
        self.msnId = None  # type: str
        self.assetNat = None  # type: str
        self.asset = None  # type: str
        self.sen = None  # type: str
        self.senQual = None  # type: str
        self.trkId = None  # type: str
        self.trkNum = None  # type: str
        self.trkStat = None  # type: str
        self.objNat = None  # type: str
        self.objId = None  # type: str
        self.objType = None  # type: str
        self.objSpec = None  # type: str
        self.objPlat = None  # type: str
        self.objAct = None  # type: str
        self.modType = None  # type: str
        self.trkItmId = None  # type: str
        self.ts = None  # type: str
        self.trkQual = 0  # type: int
        self.trkPtType = None  # type: str
        self.objIdent = None  # type: str
        self.identCred = 0  # type: int
        self.identRel = 0  # type: int
        self.identAmp = None  # type: str
        self.env = None  # type: str
        self.envConf = 0.0  # type: float
        self.trkConf = 0.0  # type: float
        self.ecefPos = None  # type: List[str]
        self.ecefVel = None  # type: List[str]
        self.ecefAcc = None  # type: List[str]
        self.lat = 0.0  # type: float
        self.lon = 0.0  # type: float
        self.alt = 0.0  # type: float
        self.spd = 0.0  # type: float
        self.hdng = 0.0  # type: float
        self.course = 0.0  # type: float
        self.lco = None  # type: List[str]
        self.lcs = None  # type: List[str]
        self.lcPos = None  # type: List[str]
        self.lcVel = None  # type: List[str]
        self.lcAcc = None  # type: List[str]
        self.eNuvel = None  # type: List[str]
        self.eNupos = None  # type: List[str]
        self.cov = None  # type: List[str]
        self.errEllp = None  # type: List[str]
        self.srcTyps = None  # type: List[str]
        self.srcIds = None  # type: List[str]
        self.callSign = None  # type: str
        self.multiSource = False  # type: bool
        self.jSeries = None  # type: str
        self.strength = 0  # type: int
        self.m1 = 0  # type: int
        self.m1v = 0  # type: int
        self.m2 = 0  # type: int
        self.m2v = 0  # type: int
        self.m3a = 0  # type: int
        self.m3av = 0  # type: int
        self.tags = None  # type: List[str]
        self.sourceDl = None  # type: str
        self.source = None  # type: str
        self.origin = None  # type: str
        self.dataMode = 0  # type: int
        self.origNetwork = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        trackAbridged = Track_Abridged()
        trackAbridged.Init(buf, pos)
        return cls.InitFromObj(trackAbridged)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, trackAbridged):
        x = Track_AbridgedT()
        x._UnPack(trackAbridged)
        return x

    # Track_AbridgedT
    def _UnPack(self, trackAbridged):
        if trackAbridged is None:
            return
        self.id = trackAbridged.Id()
        self.classificationMarking = trackAbridged.ClassificationMarking()
        self.cntct = trackAbridged.Cntct()
        self.createdAt = trackAbridged.CreatedAt()
        self.createdBy = trackAbridged.CreatedBy()
        self.msgTs = trackAbridged.MsgTs()
        self.msnId = trackAbridged.MsnId()
        self.assetNat = trackAbridged.AssetNat()
        self.asset = trackAbridged.Asset()
        self.sen = trackAbridged.Sen()
        self.senQual = trackAbridged.SenQual()
        self.trkId = trackAbridged.TrkId()
        self.trkNum = trackAbridged.TrkNum()
        self.trkStat = trackAbridged.TrkStat()
        self.objNat = trackAbridged.ObjNat()
        self.objId = trackAbridged.ObjId()
        self.objType = trackAbridged.ObjType()
        self.objSpec = trackAbridged.ObjSpec()
        self.objPlat = trackAbridged.ObjPlat()
        self.objAct = trackAbridged.ObjAct()
        self.modType = trackAbridged.ModType()
        self.trkItmId = trackAbridged.TrkItmId()
        self.ts = trackAbridged.Ts()
        self.trkQual = trackAbridged.TrkQual()
        self.trkPtType = trackAbridged.TrkPtType()
        self.objIdent = trackAbridged.ObjIdent()
        self.identCred = trackAbridged.IdentCred()
        self.identRel = trackAbridged.IdentRel()
        self.identAmp = trackAbridged.IdentAmp()
        self.env = trackAbridged.Env()
        self.envConf = trackAbridged.EnvConf()
        self.trkConf = trackAbridged.TrkConf()
        if not trackAbridged.EcefPosIsNone():
            self.ecefPos = []
            for i in range(trackAbridged.EcefPosLength()):
                self.ecefPos.append(trackAbridged.EcefPos(i))
        if not trackAbridged.EcefVelIsNone():
            self.ecefVel = []
            for i in range(trackAbridged.EcefVelLength()):
                self.ecefVel.append(trackAbridged.EcefVel(i))
        if not trackAbridged.EcefAccIsNone():
            self.ecefAcc = []
            for i in range(trackAbridged.EcefAccLength()):
                self.ecefAcc.append(trackAbridged.EcefAcc(i))
        self.lat = trackAbridged.Lat()
        self.lon = trackAbridged.Lon()
        self.alt = trackAbridged.Alt()
        self.spd = trackAbridged.Spd()
        self.hdng = trackAbridged.Hdng()
        self.course = trackAbridged.Course()
        if not trackAbridged.LcoIsNone():
            self.lco = []
            for i in range(trackAbridged.LcoLength()):
                self.lco.append(trackAbridged.Lco(i))
        if not trackAbridged.LcsIsNone():
            self.lcs = []
            for i in range(trackAbridged.LcsLength()):
                self.lcs.append(trackAbridged.Lcs(i))
        if not trackAbridged.LcPosIsNone():
            self.lcPos = []
            for i in range(trackAbridged.LcPosLength()):
                self.lcPos.append(trackAbridged.LcPos(i))
        if not trackAbridged.LcVelIsNone():
            self.lcVel = []
            for i in range(trackAbridged.LcVelLength()):
                self.lcVel.append(trackAbridged.LcVel(i))
        if not trackAbridged.LcAccIsNone():
            self.lcAcc = []
            for i in range(trackAbridged.LcAccLength()):
                self.lcAcc.append(trackAbridged.LcAcc(i))
        if not trackAbridged.ENuvelIsNone():
            self.eNuvel = []
            for i in range(trackAbridged.ENuvelLength()):
                self.eNuvel.append(trackAbridged.ENuvel(i))
        if not trackAbridged.ENuposIsNone():
            self.eNupos = []
            for i in range(trackAbridged.ENuposLength()):
                self.eNupos.append(trackAbridged.ENupos(i))
        if not trackAbridged.CovIsNone():
            self.cov = []
            for i in range(trackAbridged.CovLength()):
                self.cov.append(trackAbridged.Cov(i))
        if not trackAbridged.ErrEllpIsNone():
            self.errEllp = []
            for i in range(trackAbridged.ErrEllpLength()):
                self.errEllp.append(trackAbridged.ErrEllp(i))
        if not trackAbridged.SrcTypsIsNone():
            self.srcTyps = []
            for i in range(trackAbridged.SrcTypsLength()):
                self.srcTyps.append(trackAbridged.SrcTyps(i))
        if not trackAbridged.SrcIdsIsNone():
            self.srcIds = []
            for i in range(trackAbridged.SrcIdsLength()):
                self.srcIds.append(trackAbridged.SrcIds(i))
        self.callSign = trackAbridged.CallSign()
        self.multiSource = trackAbridged.MultiSource()
        self.jSeries = trackAbridged.JSeries()
        self.strength = trackAbridged.Strength()
        self.m1 = trackAbridged.M1()
        self.m1v = trackAbridged.M1v()
        self.m2 = trackAbridged.M2()
        self.m2v = trackAbridged.M2v()
        self.m3a = trackAbridged.M3a()
        self.m3av = trackAbridged.M3av()
        if not trackAbridged.TagsIsNone():
            self.tags = []
            for i in range(trackAbridged.TagsLength()):
                self.tags.append(trackAbridged.Tags(i))
        self.sourceDl = trackAbridged.SourceDl()
        self.source = trackAbridged.Source()
        self.origin = trackAbridged.Origin()
        self.dataMode = trackAbridged.DataMode()
        self.origNetwork = trackAbridged.OrigNetwork()

    # Track_AbridgedT
    def Pack(self, builder):
        if self.id is not None:
            id = builder.CreateString(self.id)
        if self.classificationMarking is not None:
            classificationMarking = builder.CreateString(self.classificationMarking)
        if self.cntct is not None:
            cntct = builder.CreateString(self.cntct)
        if self.createdAt is not None:
            createdAt = builder.CreateString(self.createdAt)
        if self.createdBy is not None:
            createdBy = builder.CreateString(self.createdBy)
        if self.msgTs is not None:
            msgTs = builder.CreateString(self.msgTs)
        if self.msnId is not None:
            msnId = builder.CreateString(self.msnId)
        if self.assetNat is not None:
            assetNat = builder.CreateString(self.assetNat)
        if self.asset is not None:
            asset = builder.CreateString(self.asset)
        if self.sen is not None:
            sen = builder.CreateString(self.sen)
        if self.senQual is not None:
            senQual = builder.CreateString(self.senQual)
        if self.trkId is not None:
            trkId = builder.CreateString(self.trkId)
        if self.trkNum is not None:
            trkNum = builder.CreateString(self.trkNum)
        if self.trkStat is not None:
            trkStat = builder.CreateString(self.trkStat)
        if self.objNat is not None:
            objNat = builder.CreateString(self.objNat)
        if self.objId is not None:
            objId = builder.CreateString(self.objId)
        if self.objType is not None:
            objType = builder.CreateString(self.objType)
        if self.objSpec is not None:
            objSpec = builder.CreateString(self.objSpec)
        if self.objPlat is not None:
            objPlat = builder.CreateString(self.objPlat)
        if self.objAct is not None:
            objAct = builder.CreateString(self.objAct)
        if self.modType is not None:
            modType = builder.CreateString(self.modType)
        if self.trkItmId is not None:
            trkItmId = builder.CreateString(self.trkItmId)
        if self.ts is not None:
            ts = builder.CreateString(self.ts)
        if self.trkPtType is not None:
            trkPtType = builder.CreateString(self.trkPtType)
        if self.objIdent is not None:
            objIdent = builder.CreateString(self.objIdent)
        if self.identAmp is not None:
            identAmp = builder.CreateString(self.identAmp)
        if self.env is not None:
            env = builder.CreateString(self.env)
        if self.ecefPos is not None:
            ecefPoslist = []
            for i in range(len(self.ecefPos)):
                ecefPoslist.append(builder.CreateString(self.ecefPos[i]))
            Track_AbridgedStartEcefPosVector(builder, len(self.ecefPos))
            for i in reversed(range(len(self.ecefPos))):
                builder.PrependUOffsetTRelative(ecefPoslist[i])
            ecefPos = builder.EndVector()
        if self.ecefVel is not None:
            ecefVellist = []
            for i in range(len(self.ecefVel)):
                ecefVellist.append(builder.CreateString(self.ecefVel[i]))
            Track_AbridgedStartEcefVelVector(builder, len(self.ecefVel))
            for i in reversed(range(len(self.ecefVel))):
                builder.PrependUOffsetTRelative(ecefVellist[i])
            ecefVel = builder.EndVector()
        if self.ecefAcc is not None:
            ecefAcclist = []
            for i in range(len(self.ecefAcc)):
                ecefAcclist.append(builder.CreateString(self.ecefAcc[i]))
            Track_AbridgedStartEcefAccVector(builder, len(self.ecefAcc))
            for i in reversed(range(len(self.ecefAcc))):
                builder.PrependUOffsetTRelative(ecefAcclist[i])
            ecefAcc = builder.EndVector()
        if self.lco is not None:
            lcolist = []
            for i in range(len(self.lco)):
                lcolist.append(builder.CreateString(self.lco[i]))
            Track_AbridgedStartLcoVector(builder, len(self.lco))
            for i in reversed(range(len(self.lco))):
                builder.PrependUOffsetTRelative(lcolist[i])
            lco = builder.EndVector()
        if self.lcs is not None:
            lcslist = []
            for i in range(len(self.lcs)):
                lcslist.append(builder.CreateString(self.lcs[i]))
            Track_AbridgedStartLcsVector(builder, len(self.lcs))
            for i in reversed(range(len(self.lcs))):
                builder.PrependUOffsetTRelative(lcslist[i])
            lcs = builder.EndVector()
        if self.lcPos is not None:
            lcPoslist = []
            for i in range(len(self.lcPos)):
                lcPoslist.append(builder.CreateString(self.lcPos[i]))
            Track_AbridgedStartLcPosVector(builder, len(self.lcPos))
            for i in reversed(range(len(self.lcPos))):
                builder.PrependUOffsetTRelative(lcPoslist[i])
            lcPos = builder.EndVector()
        if self.lcVel is not None:
            lcVellist = []
            for i in range(len(self.lcVel)):
                lcVellist.append(builder.CreateString(self.lcVel[i]))
            Track_AbridgedStartLcVelVector(builder, len(self.lcVel))
            for i in reversed(range(len(self.lcVel))):
                builder.PrependUOffsetTRelative(lcVellist[i])
            lcVel = builder.EndVector()
        if self.lcAcc is not None:
            lcAcclist = []
            for i in range(len(self.lcAcc)):
                lcAcclist.append(builder.CreateString(self.lcAcc[i]))
            Track_AbridgedStartLcAccVector(builder, len(self.lcAcc))
            for i in reversed(range(len(self.lcAcc))):
                builder.PrependUOffsetTRelative(lcAcclist[i])
            lcAcc = builder.EndVector()
        if self.eNuvel is not None:
            eNuvellist = []
            for i in range(len(self.eNuvel)):
                eNuvellist.append(builder.CreateString(self.eNuvel[i]))
            Track_AbridgedStartENuvelVector(builder, len(self.eNuvel))
            for i in reversed(range(len(self.eNuvel))):
                builder.PrependUOffsetTRelative(eNuvellist[i])
            eNuvel = builder.EndVector()
        if self.eNupos is not None:
            eNuposlist = []
            for i in range(len(self.eNupos)):
                eNuposlist.append(builder.CreateString(self.eNupos[i]))
            Track_AbridgedStartENuposVector(builder, len(self.eNupos))
            for i in reversed(range(len(self.eNupos))):
                builder.PrependUOffsetTRelative(eNuposlist[i])
            eNupos = builder.EndVector()
        if self.cov is not None:
            covlist = []
            for i in range(len(self.cov)):
                covlist.append(builder.CreateString(self.cov[i]))
            Track_AbridgedStartCovVector(builder, len(self.cov))
            for i in reversed(range(len(self.cov))):
                builder.PrependUOffsetTRelative(covlist[i])
            cov = builder.EndVector()
        if self.errEllp is not None:
            errEllplist = []
            for i in range(len(self.errEllp)):
                errEllplist.append(builder.CreateString(self.errEllp[i]))
            Track_AbridgedStartErrEllpVector(builder, len(self.errEllp))
            for i in reversed(range(len(self.errEllp))):
                builder.PrependUOffsetTRelative(errEllplist[i])
            errEllp = builder.EndVector()
        if self.srcTyps is not None:
            srcTypslist = []
            for i in range(len(self.srcTyps)):
                srcTypslist.append(builder.CreateString(self.srcTyps[i]))
            Track_AbridgedStartSrcTypsVector(builder, len(self.srcTyps))
            for i in reversed(range(len(self.srcTyps))):
                builder.PrependUOffsetTRelative(srcTypslist[i])
            srcTyps = builder.EndVector()
        if self.srcIds is not None:
            srcIdslist = []
            for i in range(len(self.srcIds)):
                srcIdslist.append(builder.CreateString(self.srcIds[i]))
            Track_AbridgedStartSrcIdsVector(builder, len(self.srcIds))
            for i in reversed(range(len(self.srcIds))):
                builder.PrependUOffsetTRelative(srcIdslist[i])
            srcIds = builder.EndVector()
        if self.callSign is not None:
            callSign = builder.CreateString(self.callSign)
        if self.jSeries is not None:
            jSeries = builder.CreateString(self.jSeries)
        if self.tags is not None:
            tagslist = []
            for i in range(len(self.tags)):
                tagslist.append(builder.CreateString(self.tags[i]))
            Track_AbridgedStartTagsVector(builder, len(self.tags))
            for i in reversed(range(len(self.tags))):
                builder.PrependUOffsetTRelative(tagslist[i])
            tags = builder.EndVector()
        if self.sourceDl is not None:
            sourceDl = builder.CreateString(self.sourceDl)
        if self.source is not None:
            source = builder.CreateString(self.source)
        if self.origin is not None:
            origin = builder.CreateString(self.origin)
        if self.origNetwork is not None:
            origNetwork = builder.CreateString(self.origNetwork)
        Track_AbridgedStart(builder)
        if self.id is not None:
            Track_AbridgedAddId(builder, id)
        if self.classificationMarking is not None:
            Track_AbridgedAddClassificationMarking(builder, classificationMarking)
        if self.cntct is not None:
            Track_AbridgedAddCntct(builder, cntct)
        if self.createdAt is not None:
            Track_AbridgedAddCreatedAt(builder, createdAt)
        if self.createdBy is not None:
            Track_AbridgedAddCreatedBy(builder, createdBy)
        if self.msgTs is not None:
            Track_AbridgedAddMsgTs(builder, msgTs)
        if self.msnId is not None:
            Track_AbridgedAddMsnId(builder, msnId)
        if self.assetNat is not None:
            Track_AbridgedAddAssetNat(builder, assetNat)
        if self.asset is not None:
            Track_AbridgedAddAsset(builder, asset)
        if self.sen is not None:
            Track_AbridgedAddSen(builder, sen)
        if self.senQual is not None:
            Track_AbridgedAddSenQual(builder, senQual)
        if self.trkId is not None:
            Track_AbridgedAddTrkId(builder, trkId)
        if self.trkNum is not None:
            Track_AbridgedAddTrkNum(builder, trkNum)
        if self.trkStat is not None:
            Track_AbridgedAddTrkStat(builder, trkStat)
        if self.objNat is not None:
            Track_AbridgedAddObjNat(builder, objNat)
        if self.objId is not None:
            Track_AbridgedAddObjId(builder, objId)
        if self.objType is not None:
            Track_AbridgedAddObjType(builder, objType)
        if self.objSpec is not None:
            Track_AbridgedAddObjSpec(builder, objSpec)
        if self.objPlat is not None:
            Track_AbridgedAddObjPlat(builder, objPlat)
        if self.objAct is not None:
            Track_AbridgedAddObjAct(builder, objAct)
        if self.modType is not None:
            Track_AbridgedAddModType(builder, modType)
        if self.trkItmId is not None:
            Track_AbridgedAddTrkItmId(builder, trkItmId)
        if self.ts is not None:
            Track_AbridgedAddTs(builder, ts)
        Track_AbridgedAddTrkQual(builder, self.trkQual)
        if self.trkPtType is not None:
            Track_AbridgedAddTrkPtType(builder, trkPtType)
        if self.objIdent is not None:
            Track_AbridgedAddObjIdent(builder, objIdent)
        Track_AbridgedAddIdentCred(builder, self.identCred)
        Track_AbridgedAddIdentRel(builder, self.identRel)
        if self.identAmp is not None:
            Track_AbridgedAddIdentAmp(builder, identAmp)
        if self.env is not None:
            Track_AbridgedAddEnv(builder, env)
        Track_AbridgedAddEnvConf(builder, self.envConf)
        Track_AbridgedAddTrkConf(builder, self.trkConf)
        if self.ecefPos is not None:
            Track_AbridgedAddEcefPos(builder, ecefPos)
        if self.ecefVel is not None:
            Track_AbridgedAddEcefVel(builder, ecefVel)
        if self.ecefAcc is not None:
            Track_AbridgedAddEcefAcc(builder, ecefAcc)
        Track_AbridgedAddLat(builder, self.lat)
        Track_AbridgedAddLon(builder, self.lon)
        Track_AbridgedAddAlt(builder, self.alt)
        Track_AbridgedAddSpd(builder, self.spd)
        Track_AbridgedAddHdng(builder, self.hdng)
        Track_AbridgedAddCourse(builder, self.course)
        if self.lco is not None:
            Track_AbridgedAddLco(builder, lco)
        if self.lcs is not None:
            Track_AbridgedAddLcs(builder, lcs)
        if self.lcPos is not None:
            Track_AbridgedAddLcPos(builder, lcPos)
        if self.lcVel is not None:
            Track_AbridgedAddLcVel(builder, lcVel)
        if self.lcAcc is not None:
            Track_AbridgedAddLcAcc(builder, lcAcc)
        if self.eNuvel is not None:
            Track_AbridgedAddENuvel(builder, eNuvel)
        if self.eNupos is not None:
            Track_AbridgedAddENupos(builder, eNupos)
        if self.cov is not None:
            Track_AbridgedAddCov(builder, cov)
        if self.errEllp is not None:
            Track_AbridgedAddErrEllp(builder, errEllp)
        if self.srcTyps is not None:
            Track_AbridgedAddSrcTyps(builder, srcTyps)
        if self.srcIds is not None:
            Track_AbridgedAddSrcIds(builder, srcIds)
        if self.callSign is not None:
            Track_AbridgedAddCallSign(builder, callSign)
        Track_AbridgedAddMultiSource(builder, self.multiSource)
        if self.jSeries is not None:
            Track_AbridgedAddJSeries(builder, jSeries)
        Track_AbridgedAddStrength(builder, self.strength)
        Track_AbridgedAddM1(builder, self.m1)
        Track_AbridgedAddM1v(builder, self.m1v)
        Track_AbridgedAddM2(builder, self.m2)
        Track_AbridgedAddM2v(builder, self.m2v)
        Track_AbridgedAddM3a(builder, self.m3a)
        Track_AbridgedAddM3av(builder, self.m3av)
        if self.tags is not None:
            Track_AbridgedAddTags(builder, tags)
        if self.sourceDl is not None:
            Track_AbridgedAddSourceDl(builder, sourceDl)
        if self.source is not None:
            Track_AbridgedAddSource(builder, source)
        if self.origin is not None:
            Track_AbridgedAddOrigin(builder, origin)
        Track_AbridgedAddDataMode(builder, self.dataMode)
        if self.origNetwork is not None:
            Track_AbridgedAddOrigNetwork(builder, origNetwork)
        trackAbridged = Track_AbridgedEnd(builder)
        return trackAbridged
