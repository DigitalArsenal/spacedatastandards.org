// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct AirspaceControlMeans_Abridged;
struct AirspaceControlMeans_AbridgedBuilder;

enum AirspaceControlMeans_Abridged_cmShape_Enum : int8_t {
  /// No description available.
  AirspaceControlMeans_Abridged_cmShape_Enum_POLYARC = 0,
  /// No description available.
  AirspaceControlMeans_Abridged_cmShape_Enum_E1TRACK = 1,
  /// No description available.
  AirspaceControlMeans_Abridged_cmShape_Enum_POLYGON = 2,
  /// No description available.
  AirspaceControlMeans_Abridged_cmShape_Enum_CIRCLE = 3,
  /// No description available.
  AirspaceControlMeans_Abridged_cmShape_Enum_CORRIDOR = 4,
  /// No description available.
  AirspaceControlMeans_Abridged_cmShape_Enum_APOINT = 5,
  /// No description available.
  AirspaceControlMeans_Abridged_cmShape_Enum_AORBIT = 6,
  /// No description available.
  AirspaceControlMeans_Abridged_cmShape_Enum_GEOLINE = 7,
  AirspaceControlMeans_Abridged_cmShape_Enum_MIN = AirspaceControlMeans_Abridged_cmShape_Enum_POLYARC,
  AirspaceControlMeans_Abridged_cmShape_Enum_MAX = AirspaceControlMeans_Abridged_cmShape_Enum_GEOLINE
};

inline const AirspaceControlMeans_Abridged_cmShape_Enum (&EnumValuesAirspaceControlMeans_Abridged_cmShape_Enum())[8] {
  static const AirspaceControlMeans_Abridged_cmShape_Enum values[] = {
    AirspaceControlMeans_Abridged_cmShape_Enum_POLYARC,
    AirspaceControlMeans_Abridged_cmShape_Enum_E1TRACK,
    AirspaceControlMeans_Abridged_cmShape_Enum_POLYGON,
    AirspaceControlMeans_Abridged_cmShape_Enum_CIRCLE,
    AirspaceControlMeans_Abridged_cmShape_Enum_CORRIDOR,
    AirspaceControlMeans_Abridged_cmShape_Enum_APOINT,
    AirspaceControlMeans_Abridged_cmShape_Enum_AORBIT,
    AirspaceControlMeans_Abridged_cmShape_Enum_GEOLINE
  };
  return values;
}

inline const char * const *EnumNamesAirspaceControlMeans_Abridged_cmShape_Enum() {
  static const char * const names[9] = {
    "POLYARC",
    "E1TRACK",
    "POLYGON",
    "CIRCLE",
    "CORRIDOR",
    "APOINT",
    "AORBIT",
    "GEOLINE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAirspaceControlMeans_Abridged_cmShape_Enum(AirspaceControlMeans_Abridged_cmShape_Enum e) {
  if (::flatbuffers::IsOutRange(e, AirspaceControlMeans_Abridged_cmShape_Enum_POLYARC, AirspaceControlMeans_Abridged_cmShape_Enum_GEOLINE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAirspaceControlMeans_Abridged_cmShape_Enum()[index];
}

/// /// A conditional nested segment to report multiple airspace control means within a particular airspace control means status.
struct AirspaceControlMeans_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AirspaceControlMeans_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMTYPE = 4,
    VT_CMID = 6,
    VT_CMSHAPE = 8,
    VT_USAGE = 10,
    VT_LINK16ID = 12,
    VT_TRANSALTITUDE = 14,
    VT_GEODATUMALT = 16,
    VT_COORD0 = 18,
    VT_COORD1 = 20,
    VT_BEARING0 = 22,
    VT_BEARING1 = 24,
    VT_RADMAG0 = 26,
    VT_RADMAG1 = 28,
    VT_RADMAGUNIT = 30,
    VT_POLYCOORD = 32,
    VT_TRACKLEG = 34,
    VT_WIDTHLEFT = 36,
    VT_WIDTHRIGHT = 38,
    VT_WIDTH = 40,
    VT_WIDTHUNIT = 42,
    VT_CORRWAYPOINTS = 44,
    VT_ORBITALIGNMENT = 46,
    VT_EFFVDIM = 48,
    VT_AIRSPACETIMEPERIOD = 50,
    VT_AIRSPACECONTROLPOINT = 52,
    VT_CTRLAUTH = 54,
    VT_CTRLAUTHFREQS = 56,
    VT_GENTEXTIND = 58,
    VT_FREETEXT = 60
  };
  /// The code for the type of airspace control means.
  /// Example: /// Example: ACM:ADAREA
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *cmType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CMTYPE);
  }
  /// Airspace control means name or designator.
  /// Example: /// Example: DESIG:C34
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *cmId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CMID);
  }
  /// Designates the geometric type that defines the airspace shape. One of CIRCLE, CORRIDOR, LINE, ORBIT, etc.
  /// Example: /// Example: POLYARC
  /// Constraints: Minimum length = 0, Maximum length = 8
  AirspaceControlMeans_Abridged_cmShape_Enum cmShape() const {
    return static_cast<AirspaceControlMeans_Abridged_cmShape_Enum>(GetField<int8_t>(VT_CMSHAPE, 0));
  }
  /// Designates the means by which a defined airspace control means is to be used.
  /// Example: /// Example: USE:AIRCOR
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *usage() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USAGE);
  }
  /// Unique Link 16 identifier assigned to the airspace control means.
  /// Example: /// Example: F3356
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *link16Id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LINK16ID);
  }
  /// The altitude at or below which the vertical position of an aircraft is controlled by reference to true altitude.
  /// Example: /// Example: 18000FT
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *transAltitude() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSALTITUDE);
  }
  /// Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated, if different from the top level ACO datum.
  /// Example: /// Example: NAR
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *geoDatumAlt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GEODATUMALT);
  }
  /// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
  /// Example: /// Example: 152345N0505657E
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *coord0() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COORD0);
  }
  /// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
  /// Example: /// Example: 1523N05057E
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *coord1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COORD1);
  }
  /// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "beginning" radial bearing parameter.
  /// Example: /// Example: 330
  /// Constraints: No constraints specified.
  double bearing0() const {
    return GetField<double>(VT_BEARING0, 0.0);
  }
  /// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "ending" radial bearing parameter.
  /// Example: /// Example: 160
  /// Constraints: No constraints specified.
  double bearing1() const {
    return GetField<double>(VT_BEARING1, 0.0);
  }
  /// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "inner" radial magnitude arc limit. If provided, the field radMagUnit is required.
  /// Example: /// Example: 30.04
  /// Constraints: No constraints specified.
  double radMag0() const {
    return GetField<double>(VT_RADMAG0, 0.0);
  }
  /// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "outer" radial magnitude arc limit. If provided, the field radMagUnit is required.
  /// Example: /// Example: 50.12
  /// Constraints: No constraints specified.
  double radMag1() const {
    return GetField<double>(VT_RADMAG1, 0.0);
  }
  /// Specifies the unit of length in which radial magnitudes are given. Use M for meters, KM for kilometers, or NM for nautical miles.
  /// Example: /// Example: NM
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *radMagUnit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RADMAGUNIT);
  }
  /// A set of geospatial coordinates specified in DMS (Degrees, Minutes, Seconds) format which determine the vertices of a one or two dimensional geospatial shape. When shape is set to "POLYARC" or "POLYGON," this field is required as applied in the construction of the area boundary. If cmShape is set to "COORIDOR" or "GEOLINE," this field is required and can be interpreted as an ordered set of points along a path in space.
  /// Example: /// Example: ['203632N0594256E', '155000N0594815E', '155000N0591343E']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *polyCoord() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_POLYCOORD);
  }
  /// Index of a segment in an airtrack, which is defined by an ordered set of points.
  /// Example: /// Example: 99
  /// Constraints: No constraints specified.
  int32_t trackLeg() const {
    return GetField<int32_t>(VT_TRACKLEG, 0);
  }
  /// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the LEFT half-plane realtive to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the left of the track segment line. If provided, the field widthUnit is required.
  /// Example: /// Example: 5.2
  /// Constraints: No constraints specified.
  double widthLeft() const {
    return GetField<double>(VT_WIDTHLEFT, 0.0);
  }
  /// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the RIGHT half-plane relative to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the right of the track segment line. If provided, the field widthUnit is required.
  /// Example: /// Example: 10.4
  /// Constraints: No constraints specified.
  double widthRight() const {
    return GetField<double>(VT_WIDTHRIGHT, 0.0);
  }
  /// Used to describe the "side to side" distance of a target, object or area. If cmShape is set to "CORRIDOR" or "AORBIT", this field is required and is mapped to the width parameter. If provided, the field widthUnit is required.
  /// Example: /// Example: 15.6
  /// Constraints: No constraints specified.
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  /// Specifies the unit of length for which widths are given. Use M for meters, KM for kilometers, or NM for nautical miles.
  /// Example: /// Example: KM
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *widthUnit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WIDTHUNIT);
  }
  /// An array of at least two alphanumeric symbols used to serially identify the corridor waypoints. If cmShape is set to "CORRIDOR," one of either corrWayPoints or polyCoord is required to specify the centerline of the corridor path.
  /// Example: /// Example: ['POB', 'RDU', 'IAD']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *corrWayPoints() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CORRWAYPOINTS);
  }
  /// Orbit alignment look-up code. Can be C=Center, L=Left, R=Right.
  /// Example: /// Example: C
  /// Constraints: Minimum length = 0, Maximum length = 1
  const ::flatbuffers::String *orbitAlignment() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORBITALIGNMENT);
  }
  /// Description of the airspace vertical dimension.
  /// Example: /// Example: BRRA:GL-100AGL
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *effVDim() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EFFVDIM);
  }
  /// The timePeriod set describes the effective datetime for a given airspace control means.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *airspaceTimePeriod() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_AIRSPACETIMEPERIOD);
  }
  /// The controlPoint set describes any reference/controlling/rendevous point for a given airspace control means.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *airspaceControlPoint() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_AIRSPACECONTROLPOINT);
  }
  /// The commander responsible within a specified geographical area for the airspace control operation assigned to him.
  /// Example: /// Example: RHEIN MAIN CP
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *ctrlAuth() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CTRLAUTH);
  }
  /// The frequency for the airspace control authority. Can specify HZ, KHZ, MHZ, GHZ or a DESIG frequency designator code.
  /// Example: /// Example: ['125.25MHZ']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ctrlAuthFreqs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CTRLAUTHFREQS);
  }
  /// Used to provide transit intstructions for the airspace control means.
  /// Example: /// Example: SITUATION
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *genTextInd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GENTEXTIND);
  }
  /// General informat detailing the transit instruction for the airspace control means.
  /// Example: /// Example: 1. CAPACITY: MDM TK, 50 VEHICLE CONVOY. 2. CHOKE POINTS: EXIT 5
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *freeText() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FREETEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CMTYPE) &&
           verifier.VerifyString(cmType()) &&
           VerifyOffset(verifier, VT_CMID) &&
           verifier.VerifyString(cmId()) &&
           VerifyField<int8_t>(verifier, VT_CMSHAPE, 1) &&
           VerifyOffset(verifier, VT_USAGE) &&
           verifier.VerifyString(usage()) &&
           VerifyOffset(verifier, VT_LINK16ID) &&
           verifier.VerifyString(link16Id()) &&
           VerifyOffset(verifier, VT_TRANSALTITUDE) &&
           verifier.VerifyString(transAltitude()) &&
           VerifyOffset(verifier, VT_GEODATUMALT) &&
           verifier.VerifyString(geoDatumAlt()) &&
           VerifyOffset(verifier, VT_COORD0) &&
           verifier.VerifyString(coord0()) &&
           VerifyOffset(verifier, VT_COORD1) &&
           verifier.VerifyString(coord1()) &&
           VerifyField<double>(verifier, VT_BEARING0, 8) &&
           VerifyField<double>(verifier, VT_BEARING1, 8) &&
           VerifyField<double>(verifier, VT_RADMAG0, 8) &&
           VerifyField<double>(verifier, VT_RADMAG1, 8) &&
           VerifyOffset(verifier, VT_RADMAGUNIT) &&
           verifier.VerifyString(radMagUnit()) &&
           VerifyOffset(verifier, VT_POLYCOORD) &&
           verifier.VerifyVector(polyCoord()) &&
           verifier.VerifyVectorOfStrings(polyCoord()) &&
           VerifyField<int32_t>(verifier, VT_TRACKLEG, 4) &&
           VerifyField<double>(verifier, VT_WIDTHLEFT, 8) &&
           VerifyField<double>(verifier, VT_WIDTHRIGHT, 8) &&
           VerifyField<double>(verifier, VT_WIDTH, 8) &&
           VerifyOffset(verifier, VT_WIDTHUNIT) &&
           verifier.VerifyString(widthUnit()) &&
           VerifyOffset(verifier, VT_CORRWAYPOINTS) &&
           verifier.VerifyVector(corrWayPoints()) &&
           verifier.VerifyVectorOfStrings(corrWayPoints()) &&
           VerifyOffset(verifier, VT_ORBITALIGNMENT) &&
           verifier.VerifyString(orbitAlignment()) &&
           VerifyOffset(verifier, VT_EFFVDIM) &&
           verifier.VerifyString(effVDim()) &&
           VerifyOffset(verifier, VT_AIRSPACETIMEPERIOD) &&
           verifier.VerifyVector(airspaceTimePeriod()) &&
           verifier.VerifyVectorOfStrings(airspaceTimePeriod()) &&
           VerifyOffset(verifier, VT_AIRSPACECONTROLPOINT) &&
           verifier.VerifyVector(airspaceControlPoint()) &&
           verifier.VerifyVectorOfStrings(airspaceControlPoint()) &&
           VerifyOffset(verifier, VT_CTRLAUTH) &&
           verifier.VerifyString(ctrlAuth()) &&
           VerifyOffset(verifier, VT_CTRLAUTHFREQS) &&
           verifier.VerifyVector(ctrlAuthFreqs()) &&
           verifier.VerifyVectorOfStrings(ctrlAuthFreqs()) &&
           VerifyOffset(verifier, VT_GENTEXTIND) &&
           verifier.VerifyString(genTextInd()) &&
           VerifyOffset(verifier, VT_FREETEXT) &&
           verifier.VerifyString(freeText()) &&
           verifier.EndTable();
  }
};

struct AirspaceControlMeans_AbridgedBuilder {
  typedef AirspaceControlMeans_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cmType(::flatbuffers::Offset<::flatbuffers::String> cmType) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_CMTYPE, cmType);
  }
  void add_cmId(::flatbuffers::Offset<::flatbuffers::String> cmId) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_CMID, cmId);
  }
  void add_cmShape(AirspaceControlMeans_Abridged_cmShape_Enum cmShape) {
    fbb_.AddElement<int8_t>(AirspaceControlMeans_Abridged::VT_CMSHAPE, static_cast<int8_t>(cmShape), 0);
  }
  void add_usage(::flatbuffers::Offset<::flatbuffers::String> usage) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_USAGE, usage);
  }
  void add_link16Id(::flatbuffers::Offset<::flatbuffers::String> link16Id) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_LINK16ID, link16Id);
  }
  void add_transAltitude(::flatbuffers::Offset<::flatbuffers::String> transAltitude) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_TRANSALTITUDE, transAltitude);
  }
  void add_geoDatumAlt(::flatbuffers::Offset<::flatbuffers::String> geoDatumAlt) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_GEODATUMALT, geoDatumAlt);
  }
  void add_coord0(::flatbuffers::Offset<::flatbuffers::String> coord0) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_COORD0, coord0);
  }
  void add_coord1(::flatbuffers::Offset<::flatbuffers::String> coord1) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_COORD1, coord1);
  }
  void add_bearing0(double bearing0) {
    fbb_.AddElement<double>(AirspaceControlMeans_Abridged::VT_BEARING0, bearing0, 0.0);
  }
  void add_bearing1(double bearing1) {
    fbb_.AddElement<double>(AirspaceControlMeans_Abridged::VT_BEARING1, bearing1, 0.0);
  }
  void add_radMag0(double radMag0) {
    fbb_.AddElement<double>(AirspaceControlMeans_Abridged::VT_RADMAG0, radMag0, 0.0);
  }
  void add_radMag1(double radMag1) {
    fbb_.AddElement<double>(AirspaceControlMeans_Abridged::VT_RADMAG1, radMag1, 0.0);
  }
  void add_radMagUnit(::flatbuffers::Offset<::flatbuffers::String> radMagUnit) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_RADMAGUNIT, radMagUnit);
  }
  void add_polyCoord(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> polyCoord) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_POLYCOORD, polyCoord);
  }
  void add_trackLeg(int32_t trackLeg) {
    fbb_.AddElement<int32_t>(AirspaceControlMeans_Abridged::VT_TRACKLEG, trackLeg, 0);
  }
  void add_widthLeft(double widthLeft) {
    fbb_.AddElement<double>(AirspaceControlMeans_Abridged::VT_WIDTHLEFT, widthLeft, 0.0);
  }
  void add_widthRight(double widthRight) {
    fbb_.AddElement<double>(AirspaceControlMeans_Abridged::VT_WIDTHRIGHT, widthRight, 0.0);
  }
  void add_width(double width) {
    fbb_.AddElement<double>(AirspaceControlMeans_Abridged::VT_WIDTH, width, 0.0);
  }
  void add_widthUnit(::flatbuffers::Offset<::flatbuffers::String> widthUnit) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_WIDTHUNIT, widthUnit);
  }
  void add_corrWayPoints(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> corrWayPoints) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_CORRWAYPOINTS, corrWayPoints);
  }
  void add_orbitAlignment(::flatbuffers::Offset<::flatbuffers::String> orbitAlignment) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_ORBITALIGNMENT, orbitAlignment);
  }
  void add_effVDim(::flatbuffers::Offset<::flatbuffers::String> effVDim) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_EFFVDIM, effVDim);
  }
  void add_airspaceTimePeriod(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> airspaceTimePeriod) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_AIRSPACETIMEPERIOD, airspaceTimePeriod);
  }
  void add_airspaceControlPoint(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> airspaceControlPoint) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_AIRSPACECONTROLPOINT, airspaceControlPoint);
  }
  void add_ctrlAuth(::flatbuffers::Offset<::flatbuffers::String> ctrlAuth) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_CTRLAUTH, ctrlAuth);
  }
  void add_ctrlAuthFreqs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ctrlAuthFreqs) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_CTRLAUTHFREQS, ctrlAuthFreqs);
  }
  void add_genTextInd(::flatbuffers::Offset<::flatbuffers::String> genTextInd) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_GENTEXTIND, genTextInd);
  }
  void add_freeText(::flatbuffers::Offset<::flatbuffers::String> freeText) {
    fbb_.AddOffset(AirspaceControlMeans_Abridged::VT_FREETEXT, freeText);
  }
  explicit AirspaceControlMeans_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AirspaceControlMeans_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AirspaceControlMeans_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AirspaceControlMeans_Abridged> CreateAirspaceControlMeans_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> cmType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> cmId = 0,
    AirspaceControlMeans_Abridged_cmShape_Enum cmShape = AirspaceControlMeans_Abridged_cmShape_Enum_POLYARC,
    ::flatbuffers::Offset<::flatbuffers::String> usage = 0,
    ::flatbuffers::Offset<::flatbuffers::String> link16Id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> transAltitude = 0,
    ::flatbuffers::Offset<::flatbuffers::String> geoDatumAlt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> coord0 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> coord1 = 0,
    double bearing0 = 0.0,
    double bearing1 = 0.0,
    double radMag0 = 0.0,
    double radMag1 = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> radMagUnit = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> polyCoord = 0,
    int32_t trackLeg = 0,
    double widthLeft = 0.0,
    double widthRight = 0.0,
    double width = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> widthUnit = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> corrWayPoints = 0,
    ::flatbuffers::Offset<::flatbuffers::String> orbitAlignment = 0,
    ::flatbuffers::Offset<::flatbuffers::String> effVDim = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> airspaceTimePeriod = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> airspaceControlPoint = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ctrlAuth = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ctrlAuthFreqs = 0,
    ::flatbuffers::Offset<::flatbuffers::String> genTextInd = 0,
    ::flatbuffers::Offset<::flatbuffers::String> freeText = 0) {
  AirspaceControlMeans_AbridgedBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_widthRight(widthRight);
  builder_.add_widthLeft(widthLeft);
  builder_.add_radMag1(radMag1);
  builder_.add_radMag0(radMag0);
  builder_.add_bearing1(bearing1);
  builder_.add_bearing0(bearing0);
  builder_.add_freeText(freeText);
  builder_.add_genTextInd(genTextInd);
  builder_.add_ctrlAuthFreqs(ctrlAuthFreqs);
  builder_.add_ctrlAuth(ctrlAuth);
  builder_.add_airspaceControlPoint(airspaceControlPoint);
  builder_.add_airspaceTimePeriod(airspaceTimePeriod);
  builder_.add_effVDim(effVDim);
  builder_.add_orbitAlignment(orbitAlignment);
  builder_.add_corrWayPoints(corrWayPoints);
  builder_.add_widthUnit(widthUnit);
  builder_.add_trackLeg(trackLeg);
  builder_.add_polyCoord(polyCoord);
  builder_.add_radMagUnit(radMagUnit);
  builder_.add_coord1(coord1);
  builder_.add_coord0(coord0);
  builder_.add_geoDatumAlt(geoDatumAlt);
  builder_.add_transAltitude(transAltitude);
  builder_.add_link16Id(link16Id);
  builder_.add_usage(usage);
  builder_.add_cmId(cmId);
  builder_.add_cmType(cmType);
  builder_.add_cmShape(cmShape);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AirspaceControlMeans_Abridged> CreateAirspaceControlMeans_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *cmType = nullptr,
    const char *cmId = nullptr,
    AirspaceControlMeans_Abridged_cmShape_Enum cmShape = AirspaceControlMeans_Abridged_cmShape_Enum_POLYARC,
    const char *usage = nullptr,
    const char *link16Id = nullptr,
    const char *transAltitude = nullptr,
    const char *geoDatumAlt = nullptr,
    const char *coord0 = nullptr,
    const char *coord1 = nullptr,
    double bearing0 = 0.0,
    double bearing1 = 0.0,
    double radMag0 = 0.0,
    double radMag1 = 0.0,
    const char *radMagUnit = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *polyCoord = nullptr,
    int32_t trackLeg = 0,
    double widthLeft = 0.0,
    double widthRight = 0.0,
    double width = 0.0,
    const char *widthUnit = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *corrWayPoints = nullptr,
    const char *orbitAlignment = nullptr,
    const char *effVDim = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *airspaceTimePeriod = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *airspaceControlPoint = nullptr,
    const char *ctrlAuth = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ctrlAuthFreqs = nullptr,
    const char *genTextInd = nullptr,
    const char *freeText = nullptr) {
  auto cmType__ = cmType ? _fbb.CreateString(cmType) : 0;
  auto cmId__ = cmId ? _fbb.CreateString(cmId) : 0;
  auto usage__ = usage ? _fbb.CreateString(usage) : 0;
  auto link16Id__ = link16Id ? _fbb.CreateString(link16Id) : 0;
  auto transAltitude__ = transAltitude ? _fbb.CreateString(transAltitude) : 0;
  auto geoDatumAlt__ = geoDatumAlt ? _fbb.CreateString(geoDatumAlt) : 0;
  auto coord0__ = coord0 ? _fbb.CreateString(coord0) : 0;
  auto coord1__ = coord1 ? _fbb.CreateString(coord1) : 0;
  auto radMagUnit__ = radMagUnit ? _fbb.CreateString(radMagUnit) : 0;
  auto polyCoord__ = polyCoord ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*polyCoord) : 0;
  auto widthUnit__ = widthUnit ? _fbb.CreateString(widthUnit) : 0;
  auto corrWayPoints__ = corrWayPoints ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*corrWayPoints) : 0;
  auto orbitAlignment__ = orbitAlignment ? _fbb.CreateString(orbitAlignment) : 0;
  auto effVDim__ = effVDim ? _fbb.CreateString(effVDim) : 0;
  auto airspaceTimePeriod__ = airspaceTimePeriod ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*airspaceTimePeriod) : 0;
  auto airspaceControlPoint__ = airspaceControlPoint ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*airspaceControlPoint) : 0;
  auto ctrlAuth__ = ctrlAuth ? _fbb.CreateString(ctrlAuth) : 0;
  auto ctrlAuthFreqs__ = ctrlAuthFreqs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ctrlAuthFreqs) : 0;
  auto genTextInd__ = genTextInd ? _fbb.CreateString(genTextInd) : 0;
  auto freeText__ = freeText ? _fbb.CreateString(freeText) : 0;
  return CreateAirspaceControlMeans_Abridged(
      _fbb,
      cmType__,
      cmId__,
      cmShape,
      usage__,
      link16Id__,
      transAltitude__,
      geoDatumAlt__,
      coord0__,
      coord1__,
      bearing0,
      bearing1,
      radMag0,
      radMag1,
      radMagUnit__,
      polyCoord__,
      trackLeg,
      widthLeft,
      widthRight,
      width,
      widthUnit__,
      corrWayPoints__,
      orbitAlignment__,
      effVDim__,
      airspaceTimePeriod__,
      airspaceControlPoint__,
      ctrlAuth__,
      ctrlAuthFreqs__,
      genTextInd__,
      freeText__);
}

inline const AirspaceControlMeans_Abridged *GetAirspaceControlMeans_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<AirspaceControlMeans_Abridged>(buf);
}

inline const AirspaceControlMeans_Abridged *GetSizePrefixedAirspaceControlMeans_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<AirspaceControlMeans_Abridged>(buf);
}

inline const char *AirspaceControlMeans_AbridgedIdentifier() {
  return "AIRS";
}

inline bool AirspaceControlMeans_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AirspaceControlMeans_AbridgedIdentifier());
}

inline bool SizePrefixedAirspaceControlMeans_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AirspaceControlMeans_AbridgedIdentifier(), true);
}

inline bool VerifyAirspaceControlMeans_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AirspaceControlMeans_Abridged>(AirspaceControlMeans_AbridgedIdentifier());
}

inline bool VerifySizePrefixedAirspaceControlMeans_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AirspaceControlMeans_Abridged>(AirspaceControlMeans_AbridgedIdentifier());
}

inline void FinishAirspaceControlMeans_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AirspaceControlMeans_Abridged> root) {
  fbb.Finish(root, AirspaceControlMeans_AbridgedIdentifier());
}

inline void FinishSizePrefixedAirspaceControlMeans_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AirspaceControlMeans_Abridged> root) {
  fbb.FinishSizePrefixed(root, AirspaceControlMeans_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
