// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct TrackDetails_Ingest;
struct TrackDetails_IngestBuilder;

enum TrackDetails_Ingest_env_Enum : int8_t {
  /// Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
  TrackDetails_Ingest_env_Enum_AIR = 0,
  /// On the surface of dry land.
  TrackDetails_Ingest_env_Enum_LAND = 1,
  /// Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
  TrackDetails_Ingest_env_Enum_SPACE = 2,
  /// On the surface of a body of water.
  TrackDetails_Ingest_env_Enum_SURFACE = 3,
  /// Below the surface of a body of water.
  TrackDetails_Ingest_env_Enum_SUBSURFACE = 4,
  /// Environment is not known.
  TrackDetails_Ingest_env_Enum_UNKNOWN = 5,
  TrackDetails_Ingest_env_Enum_MIN = TrackDetails_Ingest_env_Enum_AIR,
  TrackDetails_Ingest_env_Enum_MAX = TrackDetails_Ingest_env_Enum_UNKNOWN
};

inline const TrackDetails_Ingest_env_Enum (&EnumValuesTrackDetails_Ingest_env_Enum())[6] {
  static const TrackDetails_Ingest_env_Enum values[] = {
    TrackDetails_Ingest_env_Enum_AIR,
    TrackDetails_Ingest_env_Enum_LAND,
    TrackDetails_Ingest_env_Enum_SPACE,
    TrackDetails_Ingest_env_Enum_SURFACE,
    TrackDetails_Ingest_env_Enum_SUBSURFACE,
    TrackDetails_Ingest_env_Enum_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesTrackDetails_Ingest_env_Enum() {
  static const char * const names[7] = {
    "AIR",
    "LAND",
    "SPACE",
    "SURFACE",
    "SUBSURFACE",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackDetails_Ingest_env_Enum(TrackDetails_Ingest_env_Enum e) {
  if (::flatbuffers::IsOutRange(e, TrackDetails_Ingest_env_Enum_AIR, TrackDetails_Ingest_env_Enum_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackDetails_Ingest_env_Enum()[index];
}

enum TrackDetails_Ingest_objIdent_Enum : int8_t {
  /// Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  TrackDetails_Ingest_objIdent_Enum_ASSUMED_FRIEND = 0,
  /// Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  TrackDetails_Ingest_objIdent_Enum_FRIEND = 1,
  /// Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  TrackDetails_Ingest_objIdent_Enum_HOSTILE = 2,
  /// Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  TrackDetails_Ingest_objIdent_Enum_NEUTRAL = 3,
  /// Track object which has not been evaluated.
  TrackDetails_Ingest_objIdent_Enum_PENDING = 4,
  /// Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  TrackDetails_Ingest_objIdent_Enum_SUSPECT = 5,
  /// Track object which has been evaluated and does not meet criteria for any standard identity.
  TrackDetails_Ingest_objIdent_Enum_UNKNOWN = 6,
  TrackDetails_Ingest_objIdent_Enum_MIN = TrackDetails_Ingest_objIdent_Enum_ASSUMED_FRIEND,
  TrackDetails_Ingest_objIdent_Enum_MAX = TrackDetails_Ingest_objIdent_Enum_UNKNOWN
};

inline const TrackDetails_Ingest_objIdent_Enum (&EnumValuesTrackDetails_Ingest_objIdent_Enum())[7] {
  static const TrackDetails_Ingest_objIdent_Enum values[] = {
    TrackDetails_Ingest_objIdent_Enum_ASSUMED_FRIEND,
    TrackDetails_Ingest_objIdent_Enum_FRIEND,
    TrackDetails_Ingest_objIdent_Enum_HOSTILE,
    TrackDetails_Ingest_objIdent_Enum_NEUTRAL,
    TrackDetails_Ingest_objIdent_Enum_PENDING,
    TrackDetails_Ingest_objIdent_Enum_SUSPECT,
    TrackDetails_Ingest_objIdent_Enum_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesTrackDetails_Ingest_objIdent_Enum() {
  static const char * const names[8] = {
    "ASSUMED_FRIEND",
    "FRIEND",
    "HOSTILE",
    "NEUTRAL",
    "PENDING",
    "SUSPECT",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackDetails_Ingest_objIdent_Enum(TrackDetails_Ingest_objIdent_Enum e) {
  if (::flatbuffers::IsOutRange(e, TrackDetails_Ingest_objIdent_Enum_ASSUMED_FRIEND, TrackDetails_Ingest_objIdent_Enum_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackDetails_Ingest_objIdent_Enum()[index];
}

enum TrackDetails_Ingest_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  TrackDetails_Ingest_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  TrackDetails_Ingest_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  TrackDetails_Ingest_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  TrackDetails_Ingest_dataMode_Enum_EXERCISE = 3,
  TrackDetails_Ingest_dataMode_Enum_MIN = TrackDetails_Ingest_dataMode_Enum_REAL,
  TrackDetails_Ingest_dataMode_Enum_MAX = TrackDetails_Ingest_dataMode_Enum_EXERCISE
};

inline const TrackDetails_Ingest_dataMode_Enum (&EnumValuesTrackDetails_Ingest_dataMode_Enum())[4] {
  static const TrackDetails_Ingest_dataMode_Enum values[] = {
    TrackDetails_Ingest_dataMode_Enum_REAL,
    TrackDetails_Ingest_dataMode_Enum_TEST,
    TrackDetails_Ingest_dataMode_Enum_SIMULATED,
    TrackDetails_Ingest_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesTrackDetails_Ingest_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackDetails_Ingest_dataMode_Enum(TrackDetails_Ingest_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, TrackDetails_Ingest_dataMode_Enum_REAL, TrackDetails_Ingest_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackDetails_Ingest_dataMode_Enum()[index];
}

/// /// These services provide operations for querying of all available track details and amplifying track data. A track is a position and optionally a heading/velocity of an object such as an aircraft, marine vessel, etc at a particular timestamp. It also includes optional information regarding the identity/type of the target object and other amplifying object data, if known.
struct TrackDetails_Ingest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TrackDetails_IngestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_ENV = 8,
    VT_MSGTYPE = 10,
    VT_HULLNUM = 12,
    VT_PIF = 14,
    VT_SCONUM = 16,
    VT_NTDS = 18,
    VT_DISID = 20,
    VT_MIDBCAT = 22,
    VT_BENUMBER = 24,
    VT_OSUFFIX = 26,
    VT_PIN = 28,
    VT_LOSTTRKIND = 30,
    VT_MUIDSRCTRK = 32,
    VT_MUIDSRC = 34,
    VT_MSLSTATUS = 36,
    VT_TRKCONF = 38,
    VT_TRKQUAL = 40,
    VT_ALERT = 42,
    VT_ORIGXREF = 44,
    VT_ELNOT1 = 46,
    VT_ELNOT2 = 48,
    VT_OBJIDENT = 50,
    VT_OBJTYPE = 52,
    VT_OBJPLAT = 54,
    VT_OBJACT = 56,
    VT_OBJNAT = 58,
    VT_NAME = 60,
    VT_SHORTNAME = 62,
    VT_TRKID = 64,
    VT_TRKNUM = 66,
    VT_TRKSCOPE = 68,
    VT_SOURCEUID = 70,
    VT_CALLSIGN = 72,
    VT_IDENTAMP = 74,
    VT_SPACEAMP = 76,
    VT_SPACEAMPCONF = 78,
    VT_SPACESPECTYPE = 80,
    VT_ACFTSUBTYPE = 82,
    VT_TS = 84,
    VT_LAUNCHTIME = 86,
    VT_IMPACTTIME = 88,
    VT_FTNMSGTS = 90,
    VT_FTN = 92,
    VT_FTNCMD = 94,
    VT_RTNMSGTS = 96,
    VT_RTN = 98,
    VT_RTNTRKSTATE = 100,
    VT_RTNCMD = 102,
    VT_SEN = 104,
    VT_RPTCHXREF = 106,
    VT_RPTARCHIVED = 108,
    VT_SELFREPORT = 110,
    VT_MIL2525BSTR = 112,
    VT_TRNSPDRID = 114,
    VT_TRNSPDRTYPE = 116,
    VT_EMITTERNAME = 118,
    VT_INFOSOURCE = 120,
    VT_BOOSTING = 122,
    VT_FREQ = 124,
    VT_MAXFREQ = 126,
    VT_HARMONICS = 128,
    VT_PRI = 130,
    VT_PRF = 132,
    VT_PW = 134,
    VT_SCANTYPE = 136,
    VT_SCANRATE = 138,
    VT_SCN = 140,
    VT_CI = 142,
    VT_ANGELEV = 144,
    VT_LAT = 146,
    VT_LON = 148,
    VT_LAUNCHLAT = 150,
    VT_LAUNCHLON = 152,
    VT_IMPACTLAT = 154,
    VT_IMPACTLON = 156,
    VT_POLARSINGLOCLAT = 158,
    VT_POLARSINGLOCLON = 160,
    VT_AZCORRCENTERLINE = 162,
    VT_AZCORRARCWIDTH = 164,
    VT_ERRSEMIINTAXIS = 166,
    VT_ERRAREAORIENT = 168,
    VT_ERRSEMIMAJELEV = 170,
    VT_ERRGEOAREASWITCH = 172,
    VT_BURNOUTALT = 174,
    VT_TESEVENTID = 176,
    VT_SPD = 178,
    VT_AVGSPD = 180,
    VT_TOL = 182,
    VT_ALT = 184,
    VT_HDNG = 186,
    VT_COURSE = 188,
    VT_PROPRPM = 190,
    VT_TPK = 192,
    VT_COOPLOCIND = 194,
    VT_MANEUVERIND = 196,
    VT_LAUNCHAOUTYPE = 198,
    VT_LAUNCHAOUDATA = 200,
    VT_IMPACTAOUTYPE = 202,
    VT_IMPACTAOUDATA = 204,
    VT_AOURPTTYPE = 206,
    VT_AOURPTDATA = 208,
    VT_ECEFPOS = 210,
    VT_ECEFVEL = 212,
    VT_CONTAINMENT = 214,
    VT_CPA = 216,
    VT_TCPA = 218,
    VT_NAVSTATUS = 220,
    VT_POSDEVICETYPE = 222,
    VT_ATON = 224,
    VT_OFFPOSIND = 226,
    VT_ANTENNAREFDIMENSIONS = 228,
    VT_SHIPCLASS = 230,
    VT_IMON = 232,
    VT_MMSI = 234,
    VT_DRAUGHT = 236,
    VT_LENGTH = 238,
    VT_WIDTH = 240,
    VT_CARGOTYPE = 242,
    VT_APPGRP = 244,
    VT_HULLPROF = 246,
    VT_PROPTYPE = 248,
    VT_NUMBLADES = 250,
    VT_NUMSHAFTS = 252,
    VT_STERNTYPE = 254,
    VT_VSLWT = 256,
    VT_ARRTIME = 258,
    VT_ARRFLAG = 260,
    VT_ARRCARGO = 262,
    VT_ARRPORT = 264,
    VT_DEPPORT = 266,
    VT_DEPFLAG = 268,
    VT_DEPCARGO = 270,
    VT_DESFLAG = 272,
    VT_DESCARGO = 274,
    VT_DESTINATION = 276,
    VT_ETA = 278,
    VT_ETD = 280,
    VT_IFF = 282,
    VT_EMGIND = 284,
    VT_DROPPTIND = 286,
    VT_REINFORCED = 288,
    VT_REDUCED = 290,
    VT_HQ = 292,
    VT_DUMMY = 294,
    VT_TASKFORCE = 296,
    VT_FEINT = 298,
    VT_INSTALLATION = 300,
    VT_STAFFCMTS = 302,
    VT_ADDINFO = 304,
    VT_EVALRATING = 306,
    VT_CREATEDAT = 308,
    VT_CREATEDBY = 310,
    VT_SOURCE = 312,
    VT_ORIGIN = 314,
    VT_DATAMODE = 316,
    VT_ORIGNETWORK = 318
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: TRACK-DETAILS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
  ///  AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///  LAND: On the surface of dry land.
  ///  SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///  SURFACE: On the surface of a body of water.
  ///  SUBSURFACE: Below the surface of a body of water.
  ///  UNKNOWN: Environment is not known.
  /// Example: /// Example: LAND
  /// Constraints: Minimum length = 0, Maximum length = 16
  TrackDetails_Ingest_env_Enum env() const {
    return static_cast<TrackDetails_Ingest_env_Enum>(GetField<int8_t>(VT_ENV, 0));
  }
  /// Optional message type designation.
  /// Example: /// Example: PLATFORM
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *msgType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSGTYPE);
  }
  /// The vessel hull number designation of this maritime vessel.  The hull number is a 1-6 character alphanumeric entry assigned to a ship and painted on the hull.
  /// Example: /// Example: A30081
  /// Constraints: Minimum length = 0, Maximum length = 7
  const ::flatbuffers::String *hullNum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HULLNUM);
  }
  /// The Pseudo Identification Feature (PIF) number is a four digit code that provides an exact ID for the ship or aircraft. Friendly military only.
  /// Example: /// Example: 0137
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *pif() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PIF);
  }
  /// The Ship Control Number (SCONUM) is a naval vessel identification number (alphanumeric code) assigned by the Office of Naval Intelligence. SCONUM is sometimes referred to as NOIC ID. SCONUMs are typically of the form A#####, where A is an alpha character and # is numerical.
  /// Example: /// Example: B45524
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *sconum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCONUM);
  }
  /// The Naval Tactical Data System (NTDS) track number assigned to this track.
  /// Example: /// Example: ZZ777
  /// Constraints: Minimum length = 0, Maximum length = 6
  const ::flatbuffers::String *ntds() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NTDS);
  }
  /// The Intel Discrete Identifier (IDI) code assigned to this track.  The IDI is a four-digit code representing hostile or unknown tracks.
  /// Example: /// Example: 7670
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *disId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DISID);
  }
  /// The category code that represents the associated facility purpose within the target system.  This value is the category code in the MIDB (Modernized Intelligence Database).
  /// Example: /// Example: 20345
  /// Constraints: Minimum length = 0, Maximum length = 6
  const ::flatbuffers::String *midbCat() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIDBCAT);
  }
  /// The Basic Encyclopedia (BE) number associated with this installation or area.
  /// Example: /// Example: ENC-123
  /// Constraints: Minimum length = 0, Maximum length = 10
  const ::flatbuffers::String *beNumber() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BENUMBER);
  }
  /// The O-suffix associated with this facility.  The O-suffix is a five-character alpha/numeric system used to identify a facility, or demographic area, within an installation. The Installation Basic Encyclopedia (beNumber), in conjunction with the O-suffix, uniquely identifies the facility within the Modernized Integrated Database (MIDB).  The Installation beNumber and oSuffix are also used in conjunction with the midbCat code to classify the function or purpose of the facility.
  /// Example: /// Example: AA125
  /// Constraints: Minimum length = 0, Maximum length = 6
  const ::flatbuffers::String *oSuffix() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OSUFFIX);
  }
  /// This value represents the site number of a specific electronic site or its associated equipment.
  /// Example: /// Example: E12345012
  /// Constraints: Minimum length = 0, Maximum length = 9
  const ::flatbuffers::String *pin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PIN);
  }
  /// Flag indicating whether the missile is considered lost, if reporting a missile track.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool lostTrkInd() const {
    return GetField<uint8_t>(VT_LOSTTRKIND, 0) != 0;
  }
  /// Track ID for the source of the Missile-Unique Identifier (MUID), if reporting a missile track.
  /// Example: /// Example: MUID-SRC-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *muidSrcTrk() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MUIDSRCTRK);
  }
  /// Source of the Missile-Unique Identifier (MUID), if reporting a missile track.
  /// Example: /// Example: MUID-SRC
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *muidSrc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MUIDSRC);
  }
  /// The status of the missile track in this record, if reporting a missile track (e.g. AT LAUNCH, AT OBSERVATION, FLYING, IMPACTED, LOST, STALE, DEBRIS).
  /// Example: /// Example: AT LAUNCH
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *mslStatus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSLSTATUS);
  }
  /// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
  /// Example: /// Example: 0.95
  /// Constraints: No constraints specified.
  double trkConf() const {
    return GetField<double>(VT_TRKCONF, 0.0);
  }
  /// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track; Higher values indicate higher track quality, i.e., lower errors in reported position.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t trkQual() const {
    return GetField<int32_t>(VT_TRKQUAL, 0);
  }
  /// A track may be designated as an alert track with the following designations:
  /// HIT - High Interest Track
  /// TGT - Target
  /// SUS - Suspect Carrier
  /// NSP - Cleared Suspect
  /// If alert is null, the track is assumed to be of non-alert status.
  /// Example: /// Example: TGT
  /// Constraints: Minimum length = 0, Maximum length = 3
  const ::flatbuffers::String *alert() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALERT);
  }
  /// Original source cross-reference code for the Command that originated the report.
  /// Example: /// Example: INT
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *origXref() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGXREF);
  }
  /// Primary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
  /// Example: /// Example: A123A
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *elnot1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ELNOT1);
  }
  /// Secondary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
  /// Example: /// Example: A123B
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *elnot2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ELNOT2);
  }
  /// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
  ///  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  ///  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  ///  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  ///  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  ///  PENDING: Track object which has not been evaluated.
  ///  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  ///  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
  /// Example: /// Example: FRIEND
  /// Constraints: Minimum length = 0, Maximum length = 32
  TrackDetails_Ingest_objIdent_Enum objIdent() const {
    return static_cast<TrackDetails_Ingest_objIdent_Enum>(GetField<int8_t>(VT_OBJIDENT, 0));
  }
  /// The generic classification of the track object/group (e.g., BALLISTIC, HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
  /// Example: /// Example: TRACKED
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *objType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJTYPE);
  }
  /// The object platform type is intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. SATELLITE).
  /// Example: /// Example: WEAPON
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *objPlat() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJPLAT);
  }
  /// The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. ANTISPACE WARFARE).
  /// Example: /// Example: HOLDING
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *objAct() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJACT);
  }
  /// Nationality of the tracked object.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *objNat() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJNAT);
  }
  /// Track name.
  /// Example: /// Example: TRACK-NAME
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Abbreviated track name.
  /// Example: /// Example: COMMSCHECK
  /// Constraints: Minimum length = 0, Maximum length = 11
  const ::flatbuffers::String *shortName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORTNAME);
  }
  /// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
  /// Example: /// Example: trkId
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *trkId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRKID);
  }
  /// The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
  /// Example: /// Example: trkNum
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *trkNum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRKNUM);
  }
  /// Value Indicating the scope of this track:
  /// 1 - TERMINAL  (Terminal) - available only on the workstation where they were created.
  /// 2 - LOCAL  (Local) - available only on workstations in the local area network
  /// 3 - OTH  (Over the Horizon) - available to everyone.
  /// Example: /// Example: OTH
  /// Constraints: Minimum length = 0, Maximum length = 12
  const ::flatbuffers::String *trkScope() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRKSCOPE);
  }
  /// The unique identifier of the source node.
  /// Example: /// Example: MCS
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *sourceUid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEUID);
  }
  /// The call sign currently assigned to this track object.
  /// Example: /// Example: Charlie
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *callSign() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALLSIGN);
  }
  /// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
  ///  FAKER: Friendly track, object, or entity acting as an exercise hostile.
  ///  JOKER: Friendly track, object, or entity acting as an exercise suspect.
  ///  KILO: Friendly high-value object.
  ///  TRAVELLER: Suspect land or surface track following a recognized traffic route.
  ///  ZOMBIE: Suspect track, object, or entity of special interest.
  /// Example: /// Example: JOKER
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *identAmp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENTAMP);
  }
  /// Space amplification indicates additional information on the space environment object being reported (e.g. DEBRIS, FUEL-AIR EXPLOSIVE, NUCLEAR WARHEAD).
  /// Example: /// Example: NUCLEAR WARHEAD
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *spaceAmp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACEAMP);
  }
  /// Confidence level of the amplifying characteristics.  Values range from 0 to 6, with 0 indicating the lowest confidence and 6 indicating the highest.
  /// Example: /// Example: 6
  /// Constraints: No constraints specified.
  int32_t spaceAmpConf() const {
    return GetField<int32_t>(VT_SPACEAMPCONF, 0);
  }
  /// Specific type of point or track with an environment of space.
  /// Example: /// Example: SS-21_MOD_2_CRBM
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *spaceSpecType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACESPECTYPE);
  }
  /// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM:
  /// SRBM - Short-Range Ballistic Missile
  /// MRBM - Medium-Range Ballistic Missile
  /// IRBM - Intermediate-Range Ballistic Missile
  /// LRBM - Long-Range Ballistic Missile
  /// ICBM - Intercontinental Ballistic Missile
  /// SLBM - Submarine-Launched Ballistic Missile.
  /// Example: /// Example: SLBM
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *acftSubType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACFTSUBTYPE);
  }
  /// Track timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *ts() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TS);
  }
  /// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *launchTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCHTIME);
  }
  /// Missile impact timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *impactTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMPACTTIME);
  }
  /// The message timestamp that the ftn track position was recorded, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *ftnMsgTs() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FTNMSGTS);
  }
  /// An ftn used to associate information and directives with the track.
  /// Example: /// Example: FTN
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *ftn() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FTN);
  }
  /// The name of the Command reporting the Force Over-The-Horizon Track Coordinator (FOTC) track number.
  /// Example: /// Example: TRUETT
  /// Constraints: Minimum length = 0, Maximum length = 18
  const ::flatbuffers::String *ftnCmd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FTNCMD);
  }
  /// The message timestamp that the reference track position was recorded, in ISO 8601 UTC format with microsecond precision. The 'rtnMsgTs' and 'rtn' arrays must match in size.
  /// Example: /// Example: ['2021-02-25T12:00:00.123456Z']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *rtnMsgTs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_RTNMSGTS);
  }
  /// A Reference Track Number used to associate information and directives with the track.  Referenced, but not constrained to, MIL-STD-6016F Reference Track Number. The 'rtnMsgTs' and 'rtn' arrays must match in size.
  /// Example: /// Example: ['ex-a']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *rtn() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_RTN);
  }
  /// Value representing the state of the Received Track.
  /// Example: /// Example: Local_RTN
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *rtnTrkState() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RTNTRKSTATE);
  }
  /// The name of the Command reporting the Received Track Number (RTN).
  /// Example: /// Example: YORKTOWN
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *rtnCmd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RTNCMD);
  }
  /// Id/name of sensor providing the track data.
  /// Example: /// Example: OTH
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *sen() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEN);
  }
  /// Source cross-reference code for the Command that originated the track report.
  /// Example: /// Example: INT
  /// Constraints: Minimum length = 0, Maximum length = 18
  const ::flatbuffers::String *rptChxref() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RPTCHXREF);
  }
  /// Flag indicating whether this track is archived.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool rptArchived() const {
    return GetField<uint8_t>(VT_RPTARCHIVED, 0) != 0;
  }
  /// Flag indicating that this track is self reported.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool selfReport() const {
    return GetField<uint8_t>(VT_SELFREPORT, 0) != 0;
  }
  /// The MIL-STD-2525B symbology code that applies to the subject of this track.
  /// Example: /// Example: SHP*S----------
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *mil2525Bstr() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIL2525BSTR);
  }
  /// Transponder ID for the track.  This does not correspond to the UDL transponder schema.
  /// Example: /// Example: 11
  /// Constraints: Minimum length = 0, Maximum length = 61
  const ::flatbuffers::String *trnspdrId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRNSPDRID);
  }
  /// Transponder type for the track.
  /// Example: /// Example: AFTS
  /// Constraints: Minimum length = 0, Maximum length = 51
  const ::flatbuffers::String *trnspdrType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRNSPDRTYPE);
  }
  /// Radar name of the sensor tracking this object (e.g., RAY1500, SPN-43, HEADNET).
  /// Example: /// Example: RAY1500
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *emitterName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EMITTERNAME);
  }
  /// Source code for source of information used to detect track.
  /// Example: /// Example: S1
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *infoSource() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INFOSOURCE);
  }
  /// Flag indicating that the missile is currently in a state of boosting, if reporting a missile track.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool boosting() const {
    return GetField<uint8_t>(VT_BOOSTING, 0) != 0;
  }
  /// Frequency, in hertz, for the signature report.
  /// Example: /// Example: 63.65
  /// Constraints: No constraints specified.
  double freq() const {
    return GetField<double>(VT_FREQ, 0.0);
  }
  /// Maximum frequency, in hertz, reported for this acoustic track.
  /// Example: /// Example: 10324.53
  /// Constraints: No constraints specified.
  double maxFreq() const {
    return GetField<double>(VT_MAXFREQ, 0.0);
  }
  /// List of harmonics of the signature report in descending order of predominance using 1-2 digit combinations separated by commas, e.g., 8,12,4. (1-22NS).
  /// Example: /// Example: 8,12,4
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *harmonics() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HARMONICS);
  }
  /// Pulse repetition interval of the emitter, measured in microseconds.  The interval between the start of one pulse and the start of another.
  /// Example: /// Example: 56657.2238
  /// Constraints: No constraints specified.
  double pri() const {
    return GetField<double>(VT_PRI, 0.0);
  }
  /// Pulse repetition frequency of the emitter, measured in pulses per second.  PRF is the number of pulses transmitted per second. This is the reciprocal of the pri value.
  /// Example: /// Example: 17.65
  /// Constraints: No constraints specified.
  double prf() const {
    return GetField<double>(VT_PRF, 0.0);
  }
  /// Pulse width of the emitter, measured in microseconds.  This is the duration of the pulse.
  /// Example: /// Example: 1347.45
  /// Constraints: No constraints specified.
  double pw() const {
    return GetField<double>(VT_PW, 0.0);
  }
  /// Type of radar scan.
  /// Example: /// Example: UNK
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *scanType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCANTYPE);
  }
  /// Scan rate of the emitter, measured in seconds per rotation (SPR).
  /// Example: /// Example: 12.01
  /// Constraints: No constraints specified.
  double scanRate() const {
    return GetField<double>(VT_SCANRATE, 0.0);
  }
  /// The Sequential Contact Number (SCN) for this track.
  /// Example: /// Example: 1474305
  /// Constraints: No constraints specified.
  int32_t scn() const {
    return GetField<int32_t>(VT_SCN, 0);
  }
  /// Correlation Index; reference code for the site that originally reported the track.
  /// Example: /// Example: BB
  /// Constraints: Minimum length = 0, Maximum length = 3
  const ::flatbuffers::String *cI() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CI);
  }
  /// The angle formed between the line of sight of the observer and the horizon, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
  /// Example: /// Example: 15.2
  /// Constraints: No constraints specified.
  double angElev() const {
    return GetField<double>(VT_ANGELEV, 0.0);
  }
  /// WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  /// WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  /// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  double launchLat() const {
    return GetField<double>(VT_LAUNCHLAT, 0.0);
  }
  /// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74550102
  /// Constraints: No constraints specified.
  double launchLon() const {
    return GetField<double>(VT_LAUNCHLON, 0.0);
  }
  /// WGS-84 latitude of the missile impact point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  double impactLat() const {
    return GetField<double>(VT_IMPACTLAT, 0.0);
  }
  /// WGS-84 longitude of the missile impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74550102
  /// Constraints: No constraints specified.
  double impactLon() const {
    return GetField<double>(VT_IMPACTLON, 0.0);
  }
  /// WGS-84 azimuth corridor reference point latitude, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  double polarSingLocLat() const {
    return GetField<double>(VT_POLARSINGLOCLAT, 0.0);
  }
  /// WGS-84 azimuth corridor reference point longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74550102
  /// Constraints: No constraints specified.
  double polarSingLocLon() const {
    return GetField<double>(VT_POLARSINGLOCLON, 0.0);
  }
  /// The azimuth corridor centerline angle measured in degrees clockwise from true north, of the center line of an azimuth corridor. The center line extends from the referenced corridor origin location.
  /// Example: /// Example: 12.876
  /// Constraints: No constraints specified.
  double azCorrCenterLine() const {
    return GetField<double>(VT_AZCORRCENTERLINE, 0.0);
  }
  /// Azimuth corridor arc distance measured in meters from reference point of azimuth corridor to far edge of bounded azimuth corridor wedge, measured along azimuth corridor center line.
  /// Example: /// Example: 71.76
  /// Constraints: No constraints specified.
  double azCorrArcWidth() const {
    return GetField<double>(VT_AZCORRARCWIDTH, 0.0);
  }
  /// The error in the semi-intermediate axis.  The semi-intermediate axis is intermediate in length between semi-major and semi-minor axes. This field is doubled and centered on intersection of area semi-major axis and area semi-minor axis at 90 degrees to the plane defined by those axes. For these shapes, the volume is defined as having a 50-percent probability of containing the true location of the referenced entity.
  /// Example: /// Example: 7010.882
  /// Constraints: No constraints specified.
  double errSemiIntAxis() const {
    return GetField<double>(VT_ERRSEMIINTAXIS, 0.0);
  }
  /// The error in the Area Orientation.  Area Orientation is the angle or roll in degrees, between area semi-minor axis and plane defined by local vertical and area semi-major axis. When reported without major and minor axis, it is angle between an axis perpendicular to a 2D true north axis and plane defined by local vertical and a 2D true north axis.
  /// Example: /// Example: 69.6
  /// Constraints: No constraints specified.
  double errAreaOrient() const {
    return GetField<double>(VT_ERRAREAORIENT, 0.0);
  }
  /// The error in the Semi-major elevation axis. Semi-major elevation axis is the elevation of the cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical semi-major axis, in degrees, measured from local horizontal.
  /// Example: /// Example: 168.8
  /// Constraints: No constraints specified.
  double errSemiMajElev() const {
    return GetField<double>(VT_ERRSEMIMAJELEV, 0.0);
  }
  /// Geometric area switch identifies the 3D shape of the error volume by providing the 2D shape for the 3D plane. The 3D plane is the plane orthogonal to the area semi-major axis and area semi-minor axis. Depending on whether the 2D plane is reported as an error ellipse 2D or as an error rectangle 2D, this switch reports a complete error volume that is cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical.
  /// 0 - SWITCH_TYPE_UNKNOWN
  /// 1 - SQUARE_RECTANGLE
  /// 2 - CIRCLE_ELLIPSE.
  /// Example: /// Example: CIRCLE_ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *errGeoAreaSwitch() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERRGEOAREASWITCH);
  }
  /// Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
  /// Example: /// Example: 30567.452
  /// Constraints: No constraints specified.
  double burnoutAlt() const {
    return GetField<double>(VT_BURNOUTALT, 0.0);
  }
  /// Threat Event System Track ID.
  /// Example: /// Example: 6217
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *tesEventId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TESEVENTID);
  }
  /// Track object speed, in meters/sec.
  /// Example: /// Example: 15.03443
  /// Constraints: No constraints specified.
  double spd() const {
    return GetField<double>(VT_SPD, 0.0);
  }
  /// The average speed, in kilometers/hour, calculated for the subject during the latest voyage/excursion.
  /// Example: /// Example: 18.25
  /// Constraints: No constraints specified.
  double avgSpd() const {
    return GetField<double>(VT_AVGSPD, 0.0);
  }
  /// Motion model Time On Leg in hours.
  /// Example: /// Example: 4.1
  /// Constraints: No constraints specified.
  double tol() const {
    return GetField<double>(VT_TOL, 0.0);
  }
  /// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
  /// Example: /// Example: 153.01
  /// Constraints: No constraints specified.
  double alt() const {
    return GetField<double>(VT_ALT, 0.0);
  }
  /// Track object heading, in degrees clockwise from true north.
  /// Example: /// Example: 19.7
  /// Constraints: No constraints specified.
  double hdng() const {
    return GetField<double>(VT_HDNG, 0.0);
  }
  /// The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
  /// Example: /// Example: 4.3580153
  /// Constraints: No constraints specified.
  double course() const {
    return GetField<double>(VT_COURSE, 0.0);
  }
  /// The number of propeller revolutions per minute for a submarine or ship.
  /// Example: /// Example: 8.2
  /// Constraints: No constraints specified.
  double propRPM() const {
    return GetField<double>(VT_PROPRPM, 0.0);
  }
  /// The number of turns of the vessel propellers per knot of forward motion.
  /// Example: /// Example: 2.65
  /// Constraints: No constraints specified.
  double tpk() const {
    return GetField<double>(VT_TPK, 0.0);
  }
  /// The Cooperative Location Indicator specifies whether the reported entity location was derived using reported locations from sensors on more than one platform.
  /// 0 - COOPERATIVE_LOCATOR_NONE
  /// 1 - SINGLE_PLATFORM
  /// 2 - FRAGMENT
  /// 3 - COOPERATIVE.
  /// Example: /// Example: COOPERATIVE
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *coopLocInd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COOPLOCIND);
  }
  /// The manuevering indicator specifying the missile boost phase.
  /// 0 - POST_BOOST_NONE
  /// 1 - POST_BOOST_MANUEVER
  /// 2 - POST_BOOST_COMPLETE_MANUEVER.
  /// Example: /// Example: POST_BOOST_NONE
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *maneuverInd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MANEUVERIND);
  }
  /// The launch location Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the launchAouData array and is required if launchAouData is not null. See the launchAouData field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *launchAouType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCHAOUTYPE);
  }
  /// Three element array representing the launch location Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the launchAouType specified in this record:
  ///  ELLIPSE:
  ///    brg - orientation in degrees of the ellipse
  ///    a1 - semi-major axis in meters
  ///    a2 - semi-minor axis in meters
  ///  BEARING (BEARING BOX or MTST BEARING BOX):
  ///    brg - orientation in degrees of the bearing box
  ///    a1 - length of bearing box in meters
  ///    a2 - half-width of bearing box in meters
  ///  OTHER (All other type values):
  ///    brg - line of bearing in degrees true
  ///    a1 - bearing error in degrees
  ///    a2 - estimated range in meters.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *launchAouData() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_LAUNCHAOUDATA);
  }
  /// The impact point Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the impactAouData array and is required if impactAouData is not null. See the impactAouData field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *impactAouType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMPACTAOUTYPE);
  }
  /// Three element array representing the impact point Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the impactAouType specified in this record:
  ///  ELLIPSE:
  ///    brg - orientation in degrees of the ellipse
  ///    a1 - semi-major axis in meters
  ///    a2 - semi-minor axis in meters
  ///  BEARING (BEARING BOX or MTST BEARING BOX):
  ///    brg - orientation in degrees of the bearing box
  ///    a1 - length of bearing box in meters
  ///    a2 - half-width of bearing box in meters
  ///  OTHER (All other type values):
  ///    brg - line of bearing in degrees true
  ///    a1 - bearing error in degrees
  ///    a2 - estimated range in meters.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *impactAouData() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_IMPACTAOUDATA);
  }
  /// The track Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouRptData array and is required if aouRptData is not null. See the aouRptData field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *aouRptType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AOURPTTYPE);
  }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouRptType specified in this record:
  ///  ELLIPSE:
  ///    brg - orientation in degrees of the ellipse
  ///    a1 - semi-major axis in meters
  ///    a2 - semi-minor axis in meters
  ///  BEARING (BEARING BOX or MTST BEARING BOX):
  ///    brg - orientation in degrees of the bearing box
  ///    a1 - length of bearing box in meters
  ///    a2 - half-width of bearing box in meters
  ///  OTHER (All other type values):
  ///    brg - line of bearing in degrees true
  ///    a1 - bearing error in degrees
  ///    a2 - estimated range in meters.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *aouRptData() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_AOURPTDATA);
  }
  /// Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
  /// Example: /// Example: [1.23, 2.35, 3.42]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ecefPos() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ECEFPOS);
  }
  /// Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
  /// Example: /// Example: [1.23, 2.35, 3.42]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ecefVel() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ECEFVEL);
  }
  /// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
  /// Example: /// Example: 97
  /// Constraints: No constraints specified.
  double containment() const {
    return GetField<double>(VT_CONTAINMENT, 0.0);
  }
  /// The distance, in meters, of the closest point of approach between this track to the master reference track.
  /// Example: /// Example: 500
  /// Constraints: No constraints specified.
  double cpa() const {
    return GetField<double>(VT_CPA, 0.0);
  }
  /// The time, in ISO 8601 UTC format with millisecond precision, of the  closest point of approach between this track and the master reference track.
  /// Example: /// Example: 2021-02-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *tcpa() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TCPA);
  }
  /// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Underway Using Engine
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *navStatus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAVSTATUS);
  }
  /// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: GPS
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *posDeviceType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POSDEVICETYPE);
  }
  /// Type of Aid to Navigation. Intended as, but not constrained to, the USCG NAVCEN  aids to navigation. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Cardinal Mark N
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *aton() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATON);
  }
  /// Indicator position (OFF, ON, UNK) for optional floating navigational aids only.
  /// Example: /// Example: ON
  /// Constraints: Minimum length = 0, Maximum length = 3
  const ::flatbuffers::String *offPosInd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OFFPOSIND);
  }
  /// The reference dimensions of the vessel, reported as [A, B, C, D], in meters. Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna. Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
  /// Example: /// Example: [50.1, 50.1, 20.1, 20.1]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *antennaRefDimensions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ANTENNAREFDIMENSIONS);
  }
  /// The common name for a group of ships with similar design, usually named for the first vessel of the class.
  /// Example: /// Example: Nimitz
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *shipClass() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHIPCLASS);
  }
  /// The International Maritime Organization Number of the vessel. IMON is a seven-digit number that uniquely identifies the vessel.
  /// Example: /// Example: 9015462
  /// Constraints: No constraints specified.
  int32_t imon() const {
    return GetField<int32_t>(VT_IMON, 0);
  }
  /// The Maritime Mobile Service Identity of the vessel. MMSI is a nine-digit number that identifies the transmitter station of the vessel.
  /// Example: /// Example: 304010417
  /// Constraints: No constraints specified.
  int32_t mmsi() const {
    return GetField<int32_t>(VT_MMSI, 0);
  }
  /// The maximum static draught, in meters, of the vessel according to the AIS transmission.
  /// Example: /// Example: 21.1
  /// Constraints: No constraints specified.
  double draught() const {
    return GetField<double>(VT_DRAUGHT, 0.0);
  }
  /// The overall length of the vessel, in meters. A value of 511 indicates a vessel length of 511 meters or greater.
  /// Example: /// Example: 511.1
  /// Constraints: No constraints specified.
  double length() const {
    return GetField<double>(VT_LENGTH, 0.0);
  }
  /// The breadth of the vessel, in meters. A value of 63 indicates a vessel breadth of 63 meters or greater.
  /// Example: /// Example: 24.1
  /// Constraints: No constraints specified.
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  /// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *cargoType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CARGOTYPE);
  }
  /// Appearance group code.
  /// GP1 - Superstructure exceeds 1/3 of ship length.
  /// GP2 - Superstructure less than 1/3 of ship length.
  /// GP3 - Stack aft.
  /// Example: /// Example: GP1
  /// Constraints: Minimum length = 0, Maximum length = 7
  const ::flatbuffers::String *appGrp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APPGRP);
  }
  /// Hull profile code. Based on GCCS-J hull profiles.
  /// FLUSH           No breaks in Hull Profile.
  /// RAISED 1        Hull Profile shows distinct raised area at bow. Remainder of deck is flush.
  /// RAISED 2        Hull Profile shows distinct raised area amidships. Bow and stern are flush.
  /// RAISED 3        Hull Profile shows distinct raised area at stern. Remainder of deck is flush.
  /// RAISED 1-2-3    Distinct raised areas at bow, midships, and stern with breaks between each raise.
  /// RAISED 1-2      Raised area at bow and midships with break between.
  /// RAISED 1-3      Raised area at bow and stern with break between.
  /// RAISED 12       Continuous raised area encompassing both bow and midships.
  /// RAISED 23       Continuous raised area encompassing midships and stern.
  /// RAISED 12-3     Raised areas at bow, midships and stern. Bow and midship raises are continuous. Break between midship and stern raises.
  /// RAISED 1-23     Raised areas at bow, midships, and stern. Midship and stern raises are continuous with break between bow and midship raises.
  /// RAISED 1-L2-3   Raised areas at bow, midships, and stern with break between each raise. Midships raise is longer than that associated with raised 1-2-3.
  /// Example: /// Example: Raised 1-23
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *hullProf() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HULLPROF);
  }
  /// The type of propulsion employed by the track object (Diesel, Nuclear).
  /// Example: /// Example: Diesel
  /// Constraints: Minimum length = 0, Maximum length = 6
  const ::flatbuffers::String *propType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROPTYPE);
  }
  /// The number of blades per shaft of the track object.  Applicable for maritime vessels.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  int32_t numBlades() const {
    return GetField<int32_t>(VT_NUMBLADES, 0);
  }
  /// The number of shafts on the track object.  Applicable for maritime vessels.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  int32_t numShafts() const {
    return GetField<int32_t>(VT_NUMSHAFTS, 0);
  }
  /// The stern type code (Counter, Cruiser) associated with the track object.
  /// Example: /// Example: Cruiser
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *sternType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STERNTYPE);
  }
  /// The weight, in tons, of the vessel associated with this track.
  /// Example: /// Example: 3423.76
  /// Constraints: No constraints specified.
  double vslWt() const {
    return GetField<double>(VT_VSLWT, 0.0);
  }
  /// The Arrival Time of the vessel at the destination, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *arrTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARRTIME);
  }
  /// The flag of the arrival port.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *arrFlag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARRFLAG);
  }
  /// The reported arrival cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *arrCargo() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARRCARGO);
  }
  /// The Arrival Port of the vessel according to the AIS transmission.
  /// Example: /// Example: Lanshan
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *arrPort() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARRPORT);
  }
  /// The Departure Port of the vessel according to the AIS transmission.
  /// Example: /// Example: Lanshan
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *depPort() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEPPORT);
  }
  /// The flag of the departure port.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *depFlag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEPFLAG);
  }
  /// The reported departure cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *depCargo() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEPCARGO);
  }
  /// The flag of the destination port.
  /// Example: /// Example: USA
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *desFlag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESFLAG);
  }
  /// The reported destination cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *desCargo() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCARGO);
  }
  /// The destination of the vessel according to the AIS transmission.
  /// Example: /// Example: USCLE
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *destination() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESTINATION);
  }
  /// The Estimated Time of Arrival of the vessel at the destination port, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *eta() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ETA);
  }
  /// The Estimated Time of Departure of the vessel from the departure port (depPort), according to Marine Traffic calculations, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *etd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ETD);
  }
  /// A text amplifier displaying IFF/SIF/AIS Identification modes and codes.
  /// Example: /// Example: ID Mode
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *iff() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IFF);
  }
  /// Flag indicating that the track object has an emergency.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool emgInd() const {
    return GetField<uint8_t>(VT_EMGIND, 0) != 0;
  }
  /// The drop-point indicator setting.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool dropPtInd() const {
    return GetField<uint8_t>(VT_DROPPTIND, 0) != 0;
  }
  /// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool reinforced() const {
    return GetField<uint8_t>(VT_REINFORCED, 0) != 0;
  }
  /// Flag indicating for the track represents a reduced force object or group.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool reduced() const {
    return GetField<uint8_t>(VT_REDUCED, 0) != 0;
  }
  /// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool hq() const {
    return GetField<uint8_t>(VT_HQ, 0) != 0;
  }
  /// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  /// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool taskForce() const {
    return GetField<uint8_t>(VT_TASKFORCE, 0) != 0;
  }
  /// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool feint() const {
    return GetField<uint8_t>(VT_FEINT, 0) != 0;
  }
  /// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool installation() const {
    return GetField<uint8_t>(VT_INSTALLATION, 0) != 0;
  }
  /// A text amplifier for units, equipment and installations; content is implementation specific.
  /// Example: /// Example: Staff Comments
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *staffCmts() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STAFFCMTS);
  }
  /// A text amplifier for units, equipment and installations; content is implementation specific.
  /// Example: /// Example: Additional information
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *addInfo() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADDINFO);
  }
  /// A text amplifier code for units, equipment, and installations that consists of a one-letter reliability rating and a one-number credibility rating based on the following definitions of each:
  ///  Reliability Ratings:
  ///   A-completely reliable
  ///   B-usually reliable
  ///   C-fairly reliable
  ///   D-not usually reliable
  ///   E-unreliable
  ///   F-reliability cannot be judged
  ///  Credibility Ratings:
  ///   1-confirmed by other sources
  ///   2-probably true
  ///   3-possibly true
  ///   4-doubtfully true
  ///   5-improbable
  ///   6-truth cannot be judged.
  /// Example: /// Example: A1
  /// Constraints: Minimum length = 0, Maximum length = 2
  const ::flatbuffers::String *evalRating() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EVALRATING);
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2021-02-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  TrackDetails_Ingest_dataMode_Enum dataMode() const {
    return static_cast<TrackDetails_Ingest_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyField<int8_t>(verifier, VT_ENV, 1) &&
           VerifyOffset(verifier, VT_MSGTYPE) &&
           verifier.VerifyString(msgType()) &&
           VerifyOffset(verifier, VT_HULLNUM) &&
           verifier.VerifyString(hullNum()) &&
           VerifyOffset(verifier, VT_PIF) &&
           verifier.VerifyString(pif()) &&
           VerifyOffset(verifier, VT_SCONUM) &&
           verifier.VerifyString(sconum()) &&
           VerifyOffset(verifier, VT_NTDS) &&
           verifier.VerifyString(ntds()) &&
           VerifyOffset(verifier, VT_DISID) &&
           verifier.VerifyString(disId()) &&
           VerifyOffset(verifier, VT_MIDBCAT) &&
           verifier.VerifyString(midbCat()) &&
           VerifyOffset(verifier, VT_BENUMBER) &&
           verifier.VerifyString(beNumber()) &&
           VerifyOffset(verifier, VT_OSUFFIX) &&
           verifier.VerifyString(oSuffix()) &&
           VerifyOffset(verifier, VT_PIN) &&
           verifier.VerifyString(pin()) &&
           VerifyField<uint8_t>(verifier, VT_LOSTTRKIND, 1) &&
           VerifyOffset(verifier, VT_MUIDSRCTRK) &&
           verifier.VerifyString(muidSrcTrk()) &&
           VerifyOffset(verifier, VT_MUIDSRC) &&
           verifier.VerifyString(muidSrc()) &&
           VerifyOffset(verifier, VT_MSLSTATUS) &&
           verifier.VerifyString(mslStatus()) &&
           VerifyField<double>(verifier, VT_TRKCONF, 8) &&
           VerifyField<int32_t>(verifier, VT_TRKQUAL, 4) &&
           VerifyOffset(verifier, VT_ALERT) &&
           verifier.VerifyString(alert()) &&
           VerifyOffset(verifier, VT_ORIGXREF) &&
           verifier.VerifyString(origXref()) &&
           VerifyOffset(verifier, VT_ELNOT1) &&
           verifier.VerifyString(elnot1()) &&
           VerifyOffset(verifier, VT_ELNOT2) &&
           verifier.VerifyString(elnot2()) &&
           VerifyField<int8_t>(verifier, VT_OBJIDENT, 1) &&
           VerifyOffset(verifier, VT_OBJTYPE) &&
           verifier.VerifyString(objType()) &&
           VerifyOffset(verifier, VT_OBJPLAT) &&
           verifier.VerifyString(objPlat()) &&
           VerifyOffset(verifier, VT_OBJACT) &&
           verifier.VerifyString(objAct()) &&
           VerifyOffset(verifier, VT_OBJNAT) &&
           verifier.VerifyString(objNat()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SHORTNAME) &&
           verifier.VerifyString(shortName()) &&
           VerifyOffset(verifier, VT_TRKID) &&
           verifier.VerifyString(trkId()) &&
           VerifyOffset(verifier, VT_TRKNUM) &&
           verifier.VerifyString(trkNum()) &&
           VerifyOffset(verifier, VT_TRKSCOPE) &&
           verifier.VerifyString(trkScope()) &&
           VerifyOffset(verifier, VT_SOURCEUID) &&
           verifier.VerifyString(sourceUid()) &&
           VerifyOffset(verifier, VT_CALLSIGN) &&
           verifier.VerifyString(callSign()) &&
           VerifyOffset(verifier, VT_IDENTAMP) &&
           verifier.VerifyString(identAmp()) &&
           VerifyOffset(verifier, VT_SPACEAMP) &&
           verifier.VerifyString(spaceAmp()) &&
           VerifyField<int32_t>(verifier, VT_SPACEAMPCONF, 4) &&
           VerifyOffset(verifier, VT_SPACESPECTYPE) &&
           verifier.VerifyString(spaceSpecType()) &&
           VerifyOffset(verifier, VT_ACFTSUBTYPE) &&
           verifier.VerifyString(acftSubType()) &&
           VerifyOffset(verifier, VT_TS) &&
           verifier.VerifyString(ts()) &&
           VerifyOffset(verifier, VT_LAUNCHTIME) &&
           verifier.VerifyString(launchTime()) &&
           VerifyOffset(verifier, VT_IMPACTTIME) &&
           verifier.VerifyString(impactTime()) &&
           VerifyOffset(verifier, VT_FTNMSGTS) &&
           verifier.VerifyString(ftnMsgTs()) &&
           VerifyOffset(verifier, VT_FTN) &&
           verifier.VerifyString(ftn()) &&
           VerifyOffset(verifier, VT_FTNCMD) &&
           verifier.VerifyString(ftnCmd()) &&
           VerifyOffset(verifier, VT_RTNMSGTS) &&
           verifier.VerifyVector(rtnMsgTs()) &&
           verifier.VerifyVectorOfStrings(rtnMsgTs()) &&
           VerifyOffset(verifier, VT_RTN) &&
           verifier.VerifyVector(rtn()) &&
           verifier.VerifyVectorOfStrings(rtn()) &&
           VerifyOffset(verifier, VT_RTNTRKSTATE) &&
           verifier.VerifyString(rtnTrkState()) &&
           VerifyOffset(verifier, VT_RTNCMD) &&
           verifier.VerifyString(rtnCmd()) &&
           VerifyOffset(verifier, VT_SEN) &&
           verifier.VerifyString(sen()) &&
           VerifyOffset(verifier, VT_RPTCHXREF) &&
           verifier.VerifyString(rptChxref()) &&
           VerifyField<uint8_t>(verifier, VT_RPTARCHIVED, 1) &&
           VerifyField<uint8_t>(verifier, VT_SELFREPORT, 1) &&
           VerifyOffset(verifier, VT_MIL2525BSTR) &&
           verifier.VerifyString(mil2525Bstr()) &&
           VerifyOffset(verifier, VT_TRNSPDRID) &&
           verifier.VerifyString(trnspdrId()) &&
           VerifyOffset(verifier, VT_TRNSPDRTYPE) &&
           verifier.VerifyString(trnspdrType()) &&
           VerifyOffset(verifier, VT_EMITTERNAME) &&
           verifier.VerifyString(emitterName()) &&
           VerifyOffset(verifier, VT_INFOSOURCE) &&
           verifier.VerifyString(infoSource()) &&
           VerifyField<uint8_t>(verifier, VT_BOOSTING, 1) &&
           VerifyField<double>(verifier, VT_FREQ, 8) &&
           VerifyField<double>(verifier, VT_MAXFREQ, 8) &&
           VerifyOffset(verifier, VT_HARMONICS) &&
           verifier.VerifyString(harmonics()) &&
           VerifyField<double>(verifier, VT_PRI, 8) &&
           VerifyField<double>(verifier, VT_PRF, 8) &&
           VerifyField<double>(verifier, VT_PW, 8) &&
           VerifyOffset(verifier, VT_SCANTYPE) &&
           verifier.VerifyString(scanType()) &&
           VerifyField<double>(verifier, VT_SCANRATE, 8) &&
           VerifyField<int32_t>(verifier, VT_SCN, 4) &&
           VerifyOffset(verifier, VT_CI) &&
           verifier.VerifyString(cI()) &&
           VerifyField<double>(verifier, VT_ANGELEV, 8) &&
           VerifyField<double>(verifier, VT_LAT, 8) &&
           VerifyField<double>(verifier, VT_LON, 8) &&
           VerifyField<double>(verifier, VT_LAUNCHLAT, 8) &&
           VerifyField<double>(verifier, VT_LAUNCHLON, 8) &&
           VerifyField<double>(verifier, VT_IMPACTLAT, 8) &&
           VerifyField<double>(verifier, VT_IMPACTLON, 8) &&
           VerifyField<double>(verifier, VT_POLARSINGLOCLAT, 8) &&
           VerifyField<double>(verifier, VT_POLARSINGLOCLON, 8) &&
           VerifyField<double>(verifier, VT_AZCORRCENTERLINE, 8) &&
           VerifyField<double>(verifier, VT_AZCORRARCWIDTH, 8) &&
           VerifyField<double>(verifier, VT_ERRSEMIINTAXIS, 8) &&
           VerifyField<double>(verifier, VT_ERRAREAORIENT, 8) &&
           VerifyField<double>(verifier, VT_ERRSEMIMAJELEV, 8) &&
           VerifyOffset(verifier, VT_ERRGEOAREASWITCH) &&
           verifier.VerifyString(errGeoAreaSwitch()) &&
           VerifyField<double>(verifier, VT_BURNOUTALT, 8) &&
           VerifyOffset(verifier, VT_TESEVENTID) &&
           verifier.VerifyString(tesEventId()) &&
           VerifyField<double>(verifier, VT_SPD, 8) &&
           VerifyField<double>(verifier, VT_AVGSPD, 8) &&
           VerifyField<double>(verifier, VT_TOL, 8) &&
           VerifyField<double>(verifier, VT_ALT, 8) &&
           VerifyField<double>(verifier, VT_HDNG, 8) &&
           VerifyField<double>(verifier, VT_COURSE, 8) &&
           VerifyField<double>(verifier, VT_PROPRPM, 8) &&
           VerifyField<double>(verifier, VT_TPK, 8) &&
           VerifyOffset(verifier, VT_COOPLOCIND) &&
           verifier.VerifyString(coopLocInd()) &&
           VerifyOffset(verifier, VT_MANEUVERIND) &&
           verifier.VerifyString(maneuverInd()) &&
           VerifyOffset(verifier, VT_LAUNCHAOUTYPE) &&
           verifier.VerifyString(launchAouType()) &&
           VerifyOffset(verifier, VT_LAUNCHAOUDATA) &&
           verifier.VerifyVector(launchAouData()) &&
           verifier.VerifyVectorOfStrings(launchAouData()) &&
           VerifyOffset(verifier, VT_IMPACTAOUTYPE) &&
           verifier.VerifyString(impactAouType()) &&
           VerifyOffset(verifier, VT_IMPACTAOUDATA) &&
           verifier.VerifyVector(impactAouData()) &&
           verifier.VerifyVectorOfStrings(impactAouData()) &&
           VerifyOffset(verifier, VT_AOURPTTYPE) &&
           verifier.VerifyString(aouRptType()) &&
           VerifyOffset(verifier, VT_AOURPTDATA) &&
           verifier.VerifyVector(aouRptData()) &&
           verifier.VerifyVectorOfStrings(aouRptData()) &&
           VerifyOffset(verifier, VT_ECEFPOS) &&
           verifier.VerifyVector(ecefPos()) &&
           verifier.VerifyVectorOfStrings(ecefPos()) &&
           VerifyOffset(verifier, VT_ECEFVEL) &&
           verifier.VerifyVector(ecefVel()) &&
           verifier.VerifyVectorOfStrings(ecefVel()) &&
           VerifyField<double>(verifier, VT_CONTAINMENT, 8) &&
           VerifyField<double>(verifier, VT_CPA, 8) &&
           VerifyOffset(verifier, VT_TCPA) &&
           verifier.VerifyString(tcpa()) &&
           VerifyOffset(verifier, VT_NAVSTATUS) &&
           verifier.VerifyString(navStatus()) &&
           VerifyOffset(verifier, VT_POSDEVICETYPE) &&
           verifier.VerifyString(posDeviceType()) &&
           VerifyOffset(verifier, VT_ATON) &&
           verifier.VerifyString(aton()) &&
           VerifyOffset(verifier, VT_OFFPOSIND) &&
           verifier.VerifyString(offPosInd()) &&
           VerifyOffset(verifier, VT_ANTENNAREFDIMENSIONS) &&
           verifier.VerifyVector(antennaRefDimensions()) &&
           verifier.VerifyVectorOfStrings(antennaRefDimensions()) &&
           VerifyOffset(verifier, VT_SHIPCLASS) &&
           verifier.VerifyString(shipClass()) &&
           VerifyField<int32_t>(verifier, VT_IMON, 4) &&
           VerifyField<int32_t>(verifier, VT_MMSI, 4) &&
           VerifyField<double>(verifier, VT_DRAUGHT, 8) &&
           VerifyField<double>(verifier, VT_LENGTH, 8) &&
           VerifyField<double>(verifier, VT_WIDTH, 8) &&
           VerifyOffset(verifier, VT_CARGOTYPE) &&
           verifier.VerifyString(cargoType()) &&
           VerifyOffset(verifier, VT_APPGRP) &&
           verifier.VerifyString(appGrp()) &&
           VerifyOffset(verifier, VT_HULLPROF) &&
           verifier.VerifyString(hullProf()) &&
           VerifyOffset(verifier, VT_PROPTYPE) &&
           verifier.VerifyString(propType()) &&
           VerifyField<int32_t>(verifier, VT_NUMBLADES, 4) &&
           VerifyField<int32_t>(verifier, VT_NUMSHAFTS, 4) &&
           VerifyOffset(verifier, VT_STERNTYPE) &&
           verifier.VerifyString(sternType()) &&
           VerifyField<double>(verifier, VT_VSLWT, 8) &&
           VerifyOffset(verifier, VT_ARRTIME) &&
           verifier.VerifyString(arrTime()) &&
           VerifyOffset(verifier, VT_ARRFLAG) &&
           verifier.VerifyString(arrFlag()) &&
           VerifyOffset(verifier, VT_ARRCARGO) &&
           verifier.VerifyString(arrCargo()) &&
           VerifyOffset(verifier, VT_ARRPORT) &&
           verifier.VerifyString(arrPort()) &&
           VerifyOffset(verifier, VT_DEPPORT) &&
           verifier.VerifyString(depPort()) &&
           VerifyOffset(verifier, VT_DEPFLAG) &&
           verifier.VerifyString(depFlag()) &&
           VerifyOffset(verifier, VT_DEPCARGO) &&
           verifier.VerifyString(depCargo()) &&
           VerifyOffset(verifier, VT_DESFLAG) &&
           verifier.VerifyString(desFlag()) &&
           VerifyOffset(verifier, VT_DESCARGO) &&
           verifier.VerifyString(desCargo()) &&
           VerifyOffset(verifier, VT_DESTINATION) &&
           verifier.VerifyString(destination()) &&
           VerifyOffset(verifier, VT_ETA) &&
           verifier.VerifyString(eta()) &&
           VerifyOffset(verifier, VT_ETD) &&
           verifier.VerifyString(etd()) &&
           VerifyOffset(verifier, VT_IFF) &&
           verifier.VerifyString(iff()) &&
           VerifyField<uint8_t>(verifier, VT_EMGIND, 1) &&
           VerifyField<uint8_t>(verifier, VT_DROPPTIND, 1) &&
           VerifyField<uint8_t>(verifier, VT_REINFORCED, 1) &&
           VerifyField<uint8_t>(verifier, VT_REDUCED, 1) &&
           VerifyField<uint8_t>(verifier, VT_HQ, 1) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           VerifyField<uint8_t>(verifier, VT_TASKFORCE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FEINT, 1) &&
           VerifyField<uint8_t>(verifier, VT_INSTALLATION, 1) &&
           VerifyOffset(verifier, VT_STAFFCMTS) &&
           verifier.VerifyString(staffCmts()) &&
           VerifyOffset(verifier, VT_ADDINFO) &&
           verifier.VerifyString(addInfo()) &&
           VerifyOffset(verifier, VT_EVALRATING) &&
           verifier.VerifyString(evalRating()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct TrackDetails_IngestBuilder {
  typedef TrackDetails_Ingest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_env(TrackDetails_Ingest_env_Enum env) {
    fbb_.AddElement<int8_t>(TrackDetails_Ingest::VT_ENV, static_cast<int8_t>(env), 0);
  }
  void add_msgType(::flatbuffers::Offset<::flatbuffers::String> msgType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_MSGTYPE, msgType);
  }
  void add_hullNum(::flatbuffers::Offset<::flatbuffers::String> hullNum) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_HULLNUM, hullNum);
  }
  void add_pif(::flatbuffers::Offset<::flatbuffers::String> pif) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_PIF, pif);
  }
  void add_sconum(::flatbuffers::Offset<::flatbuffers::String> sconum) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_SCONUM, sconum);
  }
  void add_ntds(::flatbuffers::Offset<::flatbuffers::String> ntds) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_NTDS, ntds);
  }
  void add_disId(::flatbuffers::Offset<::flatbuffers::String> disId) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_DISID, disId);
  }
  void add_midbCat(::flatbuffers::Offset<::flatbuffers::String> midbCat) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_MIDBCAT, midbCat);
  }
  void add_beNumber(::flatbuffers::Offset<::flatbuffers::String> beNumber) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_BENUMBER, beNumber);
  }
  void add_oSuffix(::flatbuffers::Offset<::flatbuffers::String> oSuffix) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_OSUFFIX, oSuffix);
  }
  void add_pin(::flatbuffers::Offset<::flatbuffers::String> pin) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_PIN, pin);
  }
  void add_lostTrkInd(bool lostTrkInd) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_LOSTTRKIND, static_cast<uint8_t>(lostTrkInd), 0);
  }
  void add_muidSrcTrk(::flatbuffers::Offset<::flatbuffers::String> muidSrcTrk) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_MUIDSRCTRK, muidSrcTrk);
  }
  void add_muidSrc(::flatbuffers::Offset<::flatbuffers::String> muidSrc) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_MUIDSRC, muidSrc);
  }
  void add_mslStatus(::flatbuffers::Offset<::flatbuffers::String> mslStatus) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_MSLSTATUS, mslStatus);
  }
  void add_trkConf(double trkConf) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_TRKCONF, trkConf, 0.0);
  }
  void add_trkQual(int32_t trkQual) {
    fbb_.AddElement<int32_t>(TrackDetails_Ingest::VT_TRKQUAL, trkQual, 0);
  }
  void add_alert(::flatbuffers::Offset<::flatbuffers::String> alert) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ALERT, alert);
  }
  void add_origXref(::flatbuffers::Offset<::flatbuffers::String> origXref) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ORIGXREF, origXref);
  }
  void add_elnot1(::flatbuffers::Offset<::flatbuffers::String> elnot1) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ELNOT1, elnot1);
  }
  void add_elnot2(::flatbuffers::Offset<::flatbuffers::String> elnot2) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ELNOT2, elnot2);
  }
  void add_objIdent(TrackDetails_Ingest_objIdent_Enum objIdent) {
    fbb_.AddElement<int8_t>(TrackDetails_Ingest::VT_OBJIDENT, static_cast<int8_t>(objIdent), 0);
  }
  void add_objType(::flatbuffers::Offset<::flatbuffers::String> objType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_OBJTYPE, objType);
  }
  void add_objPlat(::flatbuffers::Offset<::flatbuffers::String> objPlat) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_OBJPLAT, objPlat);
  }
  void add_objAct(::flatbuffers::Offset<::flatbuffers::String> objAct) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_OBJACT, objAct);
  }
  void add_objNat(::flatbuffers::Offset<::flatbuffers::String> objNat) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_OBJNAT, objNat);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_NAME, name);
  }
  void add_shortName(::flatbuffers::Offset<::flatbuffers::String> shortName) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_SHORTNAME, shortName);
  }
  void add_trkId(::flatbuffers::Offset<::flatbuffers::String> trkId) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_TRKID, trkId);
  }
  void add_trkNum(::flatbuffers::Offset<::flatbuffers::String> trkNum) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_TRKNUM, trkNum);
  }
  void add_trkScope(::flatbuffers::Offset<::flatbuffers::String> trkScope) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_TRKSCOPE, trkScope);
  }
  void add_sourceUid(::flatbuffers::Offset<::flatbuffers::String> sourceUid) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_SOURCEUID, sourceUid);
  }
  void add_callSign(::flatbuffers::Offset<::flatbuffers::String> callSign) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_CALLSIGN, callSign);
  }
  void add_identAmp(::flatbuffers::Offset<::flatbuffers::String> identAmp) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_IDENTAMP, identAmp);
  }
  void add_spaceAmp(::flatbuffers::Offset<::flatbuffers::String> spaceAmp) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_SPACEAMP, spaceAmp);
  }
  void add_spaceAmpConf(int32_t spaceAmpConf) {
    fbb_.AddElement<int32_t>(TrackDetails_Ingest::VT_SPACEAMPCONF, spaceAmpConf, 0);
  }
  void add_spaceSpecType(::flatbuffers::Offset<::flatbuffers::String> spaceSpecType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_SPACESPECTYPE, spaceSpecType);
  }
  void add_acftSubType(::flatbuffers::Offset<::flatbuffers::String> acftSubType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ACFTSUBTYPE, acftSubType);
  }
  void add_ts(::flatbuffers::Offset<::flatbuffers::String> ts) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_TS, ts);
  }
  void add_launchTime(::flatbuffers::Offset<::flatbuffers::String> launchTime) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_LAUNCHTIME, launchTime);
  }
  void add_impactTime(::flatbuffers::Offset<::flatbuffers::String> impactTime) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_IMPACTTIME, impactTime);
  }
  void add_ftnMsgTs(::flatbuffers::Offset<::flatbuffers::String> ftnMsgTs) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_FTNMSGTS, ftnMsgTs);
  }
  void add_ftn(::flatbuffers::Offset<::flatbuffers::String> ftn) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_FTN, ftn);
  }
  void add_ftnCmd(::flatbuffers::Offset<::flatbuffers::String> ftnCmd) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_FTNCMD, ftnCmd);
  }
  void add_rtnMsgTs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> rtnMsgTs) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_RTNMSGTS, rtnMsgTs);
  }
  void add_rtn(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> rtn) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_RTN, rtn);
  }
  void add_rtnTrkState(::flatbuffers::Offset<::flatbuffers::String> rtnTrkState) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_RTNTRKSTATE, rtnTrkState);
  }
  void add_rtnCmd(::flatbuffers::Offset<::flatbuffers::String> rtnCmd) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_RTNCMD, rtnCmd);
  }
  void add_sen(::flatbuffers::Offset<::flatbuffers::String> sen) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_SEN, sen);
  }
  void add_rptChxref(::flatbuffers::Offset<::flatbuffers::String> rptChxref) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_RPTCHXREF, rptChxref);
  }
  void add_rptArchived(bool rptArchived) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_RPTARCHIVED, static_cast<uint8_t>(rptArchived), 0);
  }
  void add_selfReport(bool selfReport) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_SELFREPORT, static_cast<uint8_t>(selfReport), 0);
  }
  void add_mil2525Bstr(::flatbuffers::Offset<::flatbuffers::String> mil2525Bstr) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_MIL2525BSTR, mil2525Bstr);
  }
  void add_trnspdrId(::flatbuffers::Offset<::flatbuffers::String> trnspdrId) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_TRNSPDRID, trnspdrId);
  }
  void add_trnspdrType(::flatbuffers::Offset<::flatbuffers::String> trnspdrType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_TRNSPDRTYPE, trnspdrType);
  }
  void add_emitterName(::flatbuffers::Offset<::flatbuffers::String> emitterName) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_EMITTERNAME, emitterName);
  }
  void add_infoSource(::flatbuffers::Offset<::flatbuffers::String> infoSource) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_INFOSOURCE, infoSource);
  }
  void add_boosting(bool boosting) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_BOOSTING, static_cast<uint8_t>(boosting), 0);
  }
  void add_freq(double freq) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_FREQ, freq, 0.0);
  }
  void add_maxFreq(double maxFreq) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_MAXFREQ, maxFreq, 0.0);
  }
  void add_harmonics(::flatbuffers::Offset<::flatbuffers::String> harmonics) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_HARMONICS, harmonics);
  }
  void add_pri(double pri) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_PRI, pri, 0.0);
  }
  void add_prf(double prf) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_PRF, prf, 0.0);
  }
  void add_pw(double pw) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_PW, pw, 0.0);
  }
  void add_scanType(::flatbuffers::Offset<::flatbuffers::String> scanType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_SCANTYPE, scanType);
  }
  void add_scanRate(double scanRate) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_SCANRATE, scanRate, 0.0);
  }
  void add_scn(int32_t scn) {
    fbb_.AddElement<int32_t>(TrackDetails_Ingest::VT_SCN, scn, 0);
  }
  void add_cI(::flatbuffers::Offset<::flatbuffers::String> cI) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_CI, cI);
  }
  void add_angElev(double angElev) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_ANGELEV, angElev, 0.0);
  }
  void add_lat(double lat) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_LON, lon, 0.0);
  }
  void add_launchLat(double launchLat) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_LAUNCHLAT, launchLat, 0.0);
  }
  void add_launchLon(double launchLon) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_LAUNCHLON, launchLon, 0.0);
  }
  void add_impactLat(double impactLat) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_IMPACTLAT, impactLat, 0.0);
  }
  void add_impactLon(double impactLon) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_IMPACTLON, impactLon, 0.0);
  }
  void add_polarSingLocLat(double polarSingLocLat) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_POLARSINGLOCLAT, polarSingLocLat, 0.0);
  }
  void add_polarSingLocLon(double polarSingLocLon) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_POLARSINGLOCLON, polarSingLocLon, 0.0);
  }
  void add_azCorrCenterLine(double azCorrCenterLine) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_AZCORRCENTERLINE, azCorrCenterLine, 0.0);
  }
  void add_azCorrArcWidth(double azCorrArcWidth) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_AZCORRARCWIDTH, azCorrArcWidth, 0.0);
  }
  void add_errSemiIntAxis(double errSemiIntAxis) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_ERRSEMIINTAXIS, errSemiIntAxis, 0.0);
  }
  void add_errAreaOrient(double errAreaOrient) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_ERRAREAORIENT, errAreaOrient, 0.0);
  }
  void add_errSemiMajElev(double errSemiMajElev) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_ERRSEMIMAJELEV, errSemiMajElev, 0.0);
  }
  void add_errGeoAreaSwitch(::flatbuffers::Offset<::flatbuffers::String> errGeoAreaSwitch) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ERRGEOAREASWITCH, errGeoAreaSwitch);
  }
  void add_burnoutAlt(double burnoutAlt) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_BURNOUTALT, burnoutAlt, 0.0);
  }
  void add_tesEventId(::flatbuffers::Offset<::flatbuffers::String> tesEventId) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_TESEVENTID, tesEventId);
  }
  void add_spd(double spd) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_SPD, spd, 0.0);
  }
  void add_avgSpd(double avgSpd) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_AVGSPD, avgSpd, 0.0);
  }
  void add_tol(double tol) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_TOL, tol, 0.0);
  }
  void add_alt(double alt) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_ALT, alt, 0.0);
  }
  void add_hdng(double hdng) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_HDNG, hdng, 0.0);
  }
  void add_course(double course) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_COURSE, course, 0.0);
  }
  void add_propRPM(double propRPM) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_PROPRPM, propRPM, 0.0);
  }
  void add_tpk(double tpk) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_TPK, tpk, 0.0);
  }
  void add_coopLocInd(::flatbuffers::Offset<::flatbuffers::String> coopLocInd) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_COOPLOCIND, coopLocInd);
  }
  void add_maneuverInd(::flatbuffers::Offset<::flatbuffers::String> maneuverInd) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_MANEUVERIND, maneuverInd);
  }
  void add_launchAouType(::flatbuffers::Offset<::flatbuffers::String> launchAouType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_LAUNCHAOUTYPE, launchAouType);
  }
  void add_launchAouData(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> launchAouData) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_LAUNCHAOUDATA, launchAouData);
  }
  void add_impactAouType(::flatbuffers::Offset<::flatbuffers::String> impactAouType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_IMPACTAOUTYPE, impactAouType);
  }
  void add_impactAouData(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> impactAouData) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_IMPACTAOUDATA, impactAouData);
  }
  void add_aouRptType(::flatbuffers::Offset<::flatbuffers::String> aouRptType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_AOURPTTYPE, aouRptType);
  }
  void add_aouRptData(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> aouRptData) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_AOURPTDATA, aouRptData);
  }
  void add_ecefPos(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ecefPos) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ECEFPOS, ecefPos);
  }
  void add_ecefVel(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ecefVel) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ECEFVEL, ecefVel);
  }
  void add_containment(double containment) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_CONTAINMENT, containment, 0.0);
  }
  void add_cpa(double cpa) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_CPA, cpa, 0.0);
  }
  void add_tcpa(::flatbuffers::Offset<::flatbuffers::String> tcpa) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_TCPA, tcpa);
  }
  void add_navStatus(::flatbuffers::Offset<::flatbuffers::String> navStatus) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_NAVSTATUS, navStatus);
  }
  void add_posDeviceType(::flatbuffers::Offset<::flatbuffers::String> posDeviceType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_POSDEVICETYPE, posDeviceType);
  }
  void add_aton(::flatbuffers::Offset<::flatbuffers::String> aton) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ATON, aton);
  }
  void add_offPosInd(::flatbuffers::Offset<::flatbuffers::String> offPosInd) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_OFFPOSIND, offPosInd);
  }
  void add_antennaRefDimensions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> antennaRefDimensions) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ANTENNAREFDIMENSIONS, antennaRefDimensions);
  }
  void add_shipClass(::flatbuffers::Offset<::flatbuffers::String> shipClass) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_SHIPCLASS, shipClass);
  }
  void add_imon(int32_t imon) {
    fbb_.AddElement<int32_t>(TrackDetails_Ingest::VT_IMON, imon, 0);
  }
  void add_mmsi(int32_t mmsi) {
    fbb_.AddElement<int32_t>(TrackDetails_Ingest::VT_MMSI, mmsi, 0);
  }
  void add_draught(double draught) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_DRAUGHT, draught, 0.0);
  }
  void add_length(double length) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_LENGTH, length, 0.0);
  }
  void add_width(double width) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_WIDTH, width, 0.0);
  }
  void add_cargoType(::flatbuffers::Offset<::flatbuffers::String> cargoType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_CARGOTYPE, cargoType);
  }
  void add_appGrp(::flatbuffers::Offset<::flatbuffers::String> appGrp) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_APPGRP, appGrp);
  }
  void add_hullProf(::flatbuffers::Offset<::flatbuffers::String> hullProf) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_HULLPROF, hullProf);
  }
  void add_propType(::flatbuffers::Offset<::flatbuffers::String> propType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_PROPTYPE, propType);
  }
  void add_numBlades(int32_t numBlades) {
    fbb_.AddElement<int32_t>(TrackDetails_Ingest::VT_NUMBLADES, numBlades, 0);
  }
  void add_numShafts(int32_t numShafts) {
    fbb_.AddElement<int32_t>(TrackDetails_Ingest::VT_NUMSHAFTS, numShafts, 0);
  }
  void add_sternType(::flatbuffers::Offset<::flatbuffers::String> sternType) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_STERNTYPE, sternType);
  }
  void add_vslWt(double vslWt) {
    fbb_.AddElement<double>(TrackDetails_Ingest::VT_VSLWT, vslWt, 0.0);
  }
  void add_arrTime(::flatbuffers::Offset<::flatbuffers::String> arrTime) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ARRTIME, arrTime);
  }
  void add_arrFlag(::flatbuffers::Offset<::flatbuffers::String> arrFlag) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ARRFLAG, arrFlag);
  }
  void add_arrCargo(::flatbuffers::Offset<::flatbuffers::String> arrCargo) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ARRCARGO, arrCargo);
  }
  void add_arrPort(::flatbuffers::Offset<::flatbuffers::String> arrPort) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ARRPORT, arrPort);
  }
  void add_depPort(::flatbuffers::Offset<::flatbuffers::String> depPort) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_DEPPORT, depPort);
  }
  void add_depFlag(::flatbuffers::Offset<::flatbuffers::String> depFlag) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_DEPFLAG, depFlag);
  }
  void add_depCargo(::flatbuffers::Offset<::flatbuffers::String> depCargo) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_DEPCARGO, depCargo);
  }
  void add_desFlag(::flatbuffers::Offset<::flatbuffers::String> desFlag) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_DESFLAG, desFlag);
  }
  void add_desCargo(::flatbuffers::Offset<::flatbuffers::String> desCargo) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_DESCARGO, desCargo);
  }
  void add_destination(::flatbuffers::Offset<::flatbuffers::String> destination) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_DESTINATION, destination);
  }
  void add_eta(::flatbuffers::Offset<::flatbuffers::String> eta) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ETA, eta);
  }
  void add_etd(::flatbuffers::Offset<::flatbuffers::String> etd) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ETD, etd);
  }
  void add_iff(::flatbuffers::Offset<::flatbuffers::String> iff) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_IFF, iff);
  }
  void add_emgInd(bool emgInd) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_EMGIND, static_cast<uint8_t>(emgInd), 0);
  }
  void add_dropPtInd(bool dropPtInd) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_DROPPTIND, static_cast<uint8_t>(dropPtInd), 0);
  }
  void add_reinforced(bool reinforced) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_REINFORCED, static_cast<uint8_t>(reinforced), 0);
  }
  void add_reduced(bool reduced) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_REDUCED, static_cast<uint8_t>(reduced), 0);
  }
  void add_hq(bool hq) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_HQ, static_cast<uint8_t>(hq), 0);
  }
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  void add_taskForce(bool taskForce) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_TASKFORCE, static_cast<uint8_t>(taskForce), 0);
  }
  void add_feint(bool feint) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_FEINT, static_cast<uint8_t>(feint), 0);
  }
  void add_installation(bool installation) {
    fbb_.AddElement<uint8_t>(TrackDetails_Ingest::VT_INSTALLATION, static_cast<uint8_t>(installation), 0);
  }
  void add_staffCmts(::flatbuffers::Offset<::flatbuffers::String> staffCmts) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_STAFFCMTS, staffCmts);
  }
  void add_addInfo(::flatbuffers::Offset<::flatbuffers::String> addInfo) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ADDINFO, addInfo);
  }
  void add_evalRating(::flatbuffers::Offset<::flatbuffers::String> evalRating) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_EVALRATING, evalRating);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ORIGIN, origin);
  }
  void add_dataMode(TrackDetails_Ingest_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(TrackDetails_Ingest::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(TrackDetails_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  explicit TrackDetails_IngestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TrackDetails_Ingest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TrackDetails_Ingest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TrackDetails_Ingest> CreateTrackDetails_Ingest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    TrackDetails_Ingest_env_Enum env = TrackDetails_Ingest_env_Enum_AIR,
    ::flatbuffers::Offset<::flatbuffers::String> msgType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> hullNum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pif = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sconum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ntds = 0,
    ::flatbuffers::Offset<::flatbuffers::String> disId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> midbCat = 0,
    ::flatbuffers::Offset<::flatbuffers::String> beNumber = 0,
    ::flatbuffers::Offset<::flatbuffers::String> oSuffix = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pin = 0,
    bool lostTrkInd = false,
    ::flatbuffers::Offset<::flatbuffers::String> muidSrcTrk = 0,
    ::flatbuffers::Offset<::flatbuffers::String> muidSrc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mslStatus = 0,
    double trkConf = 0.0,
    int32_t trkQual = 0,
    ::flatbuffers::Offset<::flatbuffers::String> alert = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origXref = 0,
    ::flatbuffers::Offset<::flatbuffers::String> elnot1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> elnot2 = 0,
    TrackDetails_Ingest_objIdent_Enum objIdent = TrackDetails_Ingest_objIdent_Enum_ASSUMED_FRIEND,
    ::flatbuffers::Offset<::flatbuffers::String> objType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> objPlat = 0,
    ::flatbuffers::Offset<::flatbuffers::String> objAct = 0,
    ::flatbuffers::Offset<::flatbuffers::String> objNat = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> shortName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trkId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trkNum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trkScope = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceUid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> callSign = 0,
    ::flatbuffers::Offset<::flatbuffers::String> identAmp = 0,
    ::flatbuffers::Offset<::flatbuffers::String> spaceAmp = 0,
    int32_t spaceAmpConf = 0,
    ::flatbuffers::Offset<::flatbuffers::String> spaceSpecType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> acftSubType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ts = 0,
    ::flatbuffers::Offset<::flatbuffers::String> launchTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> impactTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ftnMsgTs = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ftn = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ftnCmd = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> rtnMsgTs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> rtn = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rtnTrkState = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rtnCmd = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sen = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rptChxref = 0,
    bool rptArchived = false,
    bool selfReport = false,
    ::flatbuffers::Offset<::flatbuffers::String> mil2525Bstr = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trnspdrId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trnspdrType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> emitterName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> infoSource = 0,
    bool boosting = false,
    double freq = 0.0,
    double maxFreq = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> harmonics = 0,
    double pri = 0.0,
    double prf = 0.0,
    double pw = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> scanType = 0,
    double scanRate = 0.0,
    int32_t scn = 0,
    ::flatbuffers::Offset<::flatbuffers::String> cI = 0,
    double angElev = 0.0,
    double lat = 0.0,
    double lon = 0.0,
    double launchLat = 0.0,
    double launchLon = 0.0,
    double impactLat = 0.0,
    double impactLon = 0.0,
    double polarSingLocLat = 0.0,
    double polarSingLocLon = 0.0,
    double azCorrCenterLine = 0.0,
    double azCorrArcWidth = 0.0,
    double errSemiIntAxis = 0.0,
    double errAreaOrient = 0.0,
    double errSemiMajElev = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> errGeoAreaSwitch = 0,
    double burnoutAlt = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> tesEventId = 0,
    double spd = 0.0,
    double avgSpd = 0.0,
    double tol = 0.0,
    double alt = 0.0,
    double hdng = 0.0,
    double course = 0.0,
    double propRPM = 0.0,
    double tpk = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> coopLocInd = 0,
    ::flatbuffers::Offset<::flatbuffers::String> maneuverInd = 0,
    ::flatbuffers::Offset<::flatbuffers::String> launchAouType = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> launchAouData = 0,
    ::flatbuffers::Offset<::flatbuffers::String> impactAouType = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> impactAouData = 0,
    ::flatbuffers::Offset<::flatbuffers::String> aouRptType = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> aouRptData = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ecefPos = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ecefVel = 0,
    double containment = 0.0,
    double cpa = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> tcpa = 0,
    ::flatbuffers::Offset<::flatbuffers::String> navStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::String> posDeviceType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> aton = 0,
    ::flatbuffers::Offset<::flatbuffers::String> offPosInd = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> antennaRefDimensions = 0,
    ::flatbuffers::Offset<::flatbuffers::String> shipClass = 0,
    int32_t imon = 0,
    int32_t mmsi = 0,
    double draught = 0.0,
    double length = 0.0,
    double width = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> cargoType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> appGrp = 0,
    ::flatbuffers::Offset<::flatbuffers::String> hullProf = 0,
    ::flatbuffers::Offset<::flatbuffers::String> propType = 0,
    int32_t numBlades = 0,
    int32_t numShafts = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sternType = 0,
    double vslWt = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> arrTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> arrFlag = 0,
    ::flatbuffers::Offset<::flatbuffers::String> arrCargo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> arrPort = 0,
    ::flatbuffers::Offset<::flatbuffers::String> depPort = 0,
    ::flatbuffers::Offset<::flatbuffers::String> depFlag = 0,
    ::flatbuffers::Offset<::flatbuffers::String> depCargo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> desFlag = 0,
    ::flatbuffers::Offset<::flatbuffers::String> desCargo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> destination = 0,
    ::flatbuffers::Offset<::flatbuffers::String> eta = 0,
    ::flatbuffers::Offset<::flatbuffers::String> etd = 0,
    ::flatbuffers::Offset<::flatbuffers::String> iff = 0,
    bool emgInd = false,
    bool dropPtInd = false,
    bool reinforced = false,
    bool reduced = false,
    bool hq = false,
    bool dummy = false,
    bool taskForce = false,
    bool feint = false,
    bool installation = false,
    ::flatbuffers::Offset<::flatbuffers::String> staffCmts = 0,
    ::flatbuffers::Offset<::flatbuffers::String> addInfo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> evalRating = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    TrackDetails_Ingest_dataMode_Enum dataMode = TrackDetails_Ingest_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  TrackDetails_IngestBuilder builder_(_fbb);
  builder_.add_vslWt(vslWt);
  builder_.add_width(width);
  builder_.add_length(length);
  builder_.add_draught(draught);
  builder_.add_cpa(cpa);
  builder_.add_containment(containment);
  builder_.add_tpk(tpk);
  builder_.add_propRPM(propRPM);
  builder_.add_course(course);
  builder_.add_hdng(hdng);
  builder_.add_alt(alt);
  builder_.add_tol(tol);
  builder_.add_avgSpd(avgSpd);
  builder_.add_spd(spd);
  builder_.add_burnoutAlt(burnoutAlt);
  builder_.add_errSemiMajElev(errSemiMajElev);
  builder_.add_errAreaOrient(errAreaOrient);
  builder_.add_errSemiIntAxis(errSemiIntAxis);
  builder_.add_azCorrArcWidth(azCorrArcWidth);
  builder_.add_azCorrCenterLine(azCorrCenterLine);
  builder_.add_polarSingLocLon(polarSingLocLon);
  builder_.add_polarSingLocLat(polarSingLocLat);
  builder_.add_impactLon(impactLon);
  builder_.add_impactLat(impactLat);
  builder_.add_launchLon(launchLon);
  builder_.add_launchLat(launchLat);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  builder_.add_angElev(angElev);
  builder_.add_scanRate(scanRate);
  builder_.add_pw(pw);
  builder_.add_prf(prf);
  builder_.add_pri(pri);
  builder_.add_maxFreq(maxFreq);
  builder_.add_freq(freq);
  builder_.add_trkConf(trkConf);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_evalRating(evalRating);
  builder_.add_addInfo(addInfo);
  builder_.add_staffCmts(staffCmts);
  builder_.add_iff(iff);
  builder_.add_etd(etd);
  builder_.add_eta(eta);
  builder_.add_destination(destination);
  builder_.add_desCargo(desCargo);
  builder_.add_desFlag(desFlag);
  builder_.add_depCargo(depCargo);
  builder_.add_depFlag(depFlag);
  builder_.add_depPort(depPort);
  builder_.add_arrPort(arrPort);
  builder_.add_arrCargo(arrCargo);
  builder_.add_arrFlag(arrFlag);
  builder_.add_arrTime(arrTime);
  builder_.add_sternType(sternType);
  builder_.add_numShafts(numShafts);
  builder_.add_numBlades(numBlades);
  builder_.add_propType(propType);
  builder_.add_hullProf(hullProf);
  builder_.add_appGrp(appGrp);
  builder_.add_cargoType(cargoType);
  builder_.add_mmsi(mmsi);
  builder_.add_imon(imon);
  builder_.add_shipClass(shipClass);
  builder_.add_antennaRefDimensions(antennaRefDimensions);
  builder_.add_offPosInd(offPosInd);
  builder_.add_aton(aton);
  builder_.add_posDeviceType(posDeviceType);
  builder_.add_navStatus(navStatus);
  builder_.add_tcpa(tcpa);
  builder_.add_ecefVel(ecefVel);
  builder_.add_ecefPos(ecefPos);
  builder_.add_aouRptData(aouRptData);
  builder_.add_aouRptType(aouRptType);
  builder_.add_impactAouData(impactAouData);
  builder_.add_impactAouType(impactAouType);
  builder_.add_launchAouData(launchAouData);
  builder_.add_launchAouType(launchAouType);
  builder_.add_maneuverInd(maneuverInd);
  builder_.add_coopLocInd(coopLocInd);
  builder_.add_tesEventId(tesEventId);
  builder_.add_errGeoAreaSwitch(errGeoAreaSwitch);
  builder_.add_cI(cI);
  builder_.add_scn(scn);
  builder_.add_scanType(scanType);
  builder_.add_harmonics(harmonics);
  builder_.add_infoSource(infoSource);
  builder_.add_emitterName(emitterName);
  builder_.add_trnspdrType(trnspdrType);
  builder_.add_trnspdrId(trnspdrId);
  builder_.add_mil2525Bstr(mil2525Bstr);
  builder_.add_rptChxref(rptChxref);
  builder_.add_sen(sen);
  builder_.add_rtnCmd(rtnCmd);
  builder_.add_rtnTrkState(rtnTrkState);
  builder_.add_rtn(rtn);
  builder_.add_rtnMsgTs(rtnMsgTs);
  builder_.add_ftnCmd(ftnCmd);
  builder_.add_ftn(ftn);
  builder_.add_ftnMsgTs(ftnMsgTs);
  builder_.add_impactTime(impactTime);
  builder_.add_launchTime(launchTime);
  builder_.add_ts(ts);
  builder_.add_acftSubType(acftSubType);
  builder_.add_spaceSpecType(spaceSpecType);
  builder_.add_spaceAmpConf(spaceAmpConf);
  builder_.add_spaceAmp(spaceAmp);
  builder_.add_identAmp(identAmp);
  builder_.add_callSign(callSign);
  builder_.add_sourceUid(sourceUid);
  builder_.add_trkScope(trkScope);
  builder_.add_trkNum(trkNum);
  builder_.add_trkId(trkId);
  builder_.add_shortName(shortName);
  builder_.add_name(name);
  builder_.add_objNat(objNat);
  builder_.add_objAct(objAct);
  builder_.add_objPlat(objPlat);
  builder_.add_objType(objType);
  builder_.add_elnot2(elnot2);
  builder_.add_elnot1(elnot1);
  builder_.add_origXref(origXref);
  builder_.add_alert(alert);
  builder_.add_trkQual(trkQual);
  builder_.add_mslStatus(mslStatus);
  builder_.add_muidSrc(muidSrc);
  builder_.add_muidSrcTrk(muidSrcTrk);
  builder_.add_pin(pin);
  builder_.add_oSuffix(oSuffix);
  builder_.add_beNumber(beNumber);
  builder_.add_midbCat(midbCat);
  builder_.add_disId(disId);
  builder_.add_ntds(ntds);
  builder_.add_sconum(sconum);
  builder_.add_pif(pif);
  builder_.add_hullNum(hullNum);
  builder_.add_msgType(msgType);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_installation(installation);
  builder_.add_feint(feint);
  builder_.add_taskForce(taskForce);
  builder_.add_dummy(dummy);
  builder_.add_hq(hq);
  builder_.add_reduced(reduced);
  builder_.add_reinforced(reinforced);
  builder_.add_dropPtInd(dropPtInd);
  builder_.add_emgInd(emgInd);
  builder_.add_boosting(boosting);
  builder_.add_selfReport(selfReport);
  builder_.add_rptArchived(rptArchived);
  builder_.add_objIdent(objIdent);
  builder_.add_lostTrkInd(lostTrkInd);
  builder_.add_env(env);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TrackDetails_Ingest> CreateTrackDetails_IngestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    TrackDetails_Ingest_env_Enum env = TrackDetails_Ingest_env_Enum_AIR,
    const char *msgType = nullptr,
    const char *hullNum = nullptr,
    const char *pif = nullptr,
    const char *sconum = nullptr,
    const char *ntds = nullptr,
    const char *disId = nullptr,
    const char *midbCat = nullptr,
    const char *beNumber = nullptr,
    const char *oSuffix = nullptr,
    const char *pin = nullptr,
    bool lostTrkInd = false,
    const char *muidSrcTrk = nullptr,
    const char *muidSrc = nullptr,
    const char *mslStatus = nullptr,
    double trkConf = 0.0,
    int32_t trkQual = 0,
    const char *alert = nullptr,
    const char *origXref = nullptr,
    const char *elnot1 = nullptr,
    const char *elnot2 = nullptr,
    TrackDetails_Ingest_objIdent_Enum objIdent = TrackDetails_Ingest_objIdent_Enum_ASSUMED_FRIEND,
    const char *objType = nullptr,
    const char *objPlat = nullptr,
    const char *objAct = nullptr,
    const char *objNat = nullptr,
    const char *name = nullptr,
    const char *shortName = nullptr,
    const char *trkId = nullptr,
    const char *trkNum = nullptr,
    const char *trkScope = nullptr,
    const char *sourceUid = nullptr,
    const char *callSign = nullptr,
    const char *identAmp = nullptr,
    const char *spaceAmp = nullptr,
    int32_t spaceAmpConf = 0,
    const char *spaceSpecType = nullptr,
    const char *acftSubType = nullptr,
    const char *ts = nullptr,
    const char *launchTime = nullptr,
    const char *impactTime = nullptr,
    const char *ftnMsgTs = nullptr,
    const char *ftn = nullptr,
    const char *ftnCmd = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *rtnMsgTs = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *rtn = nullptr,
    const char *rtnTrkState = nullptr,
    const char *rtnCmd = nullptr,
    const char *sen = nullptr,
    const char *rptChxref = nullptr,
    bool rptArchived = false,
    bool selfReport = false,
    const char *mil2525Bstr = nullptr,
    const char *trnspdrId = nullptr,
    const char *trnspdrType = nullptr,
    const char *emitterName = nullptr,
    const char *infoSource = nullptr,
    bool boosting = false,
    double freq = 0.0,
    double maxFreq = 0.0,
    const char *harmonics = nullptr,
    double pri = 0.0,
    double prf = 0.0,
    double pw = 0.0,
    const char *scanType = nullptr,
    double scanRate = 0.0,
    int32_t scn = 0,
    const char *cI = nullptr,
    double angElev = 0.0,
    double lat = 0.0,
    double lon = 0.0,
    double launchLat = 0.0,
    double launchLon = 0.0,
    double impactLat = 0.0,
    double impactLon = 0.0,
    double polarSingLocLat = 0.0,
    double polarSingLocLon = 0.0,
    double azCorrCenterLine = 0.0,
    double azCorrArcWidth = 0.0,
    double errSemiIntAxis = 0.0,
    double errAreaOrient = 0.0,
    double errSemiMajElev = 0.0,
    const char *errGeoAreaSwitch = nullptr,
    double burnoutAlt = 0.0,
    const char *tesEventId = nullptr,
    double spd = 0.0,
    double avgSpd = 0.0,
    double tol = 0.0,
    double alt = 0.0,
    double hdng = 0.0,
    double course = 0.0,
    double propRPM = 0.0,
    double tpk = 0.0,
    const char *coopLocInd = nullptr,
    const char *maneuverInd = nullptr,
    const char *launchAouType = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *launchAouData = nullptr,
    const char *impactAouType = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *impactAouData = nullptr,
    const char *aouRptType = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *aouRptData = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ecefPos = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ecefVel = nullptr,
    double containment = 0.0,
    double cpa = 0.0,
    const char *tcpa = nullptr,
    const char *navStatus = nullptr,
    const char *posDeviceType = nullptr,
    const char *aton = nullptr,
    const char *offPosInd = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *antennaRefDimensions = nullptr,
    const char *shipClass = nullptr,
    int32_t imon = 0,
    int32_t mmsi = 0,
    double draught = 0.0,
    double length = 0.0,
    double width = 0.0,
    const char *cargoType = nullptr,
    const char *appGrp = nullptr,
    const char *hullProf = nullptr,
    const char *propType = nullptr,
    int32_t numBlades = 0,
    int32_t numShafts = 0,
    const char *sternType = nullptr,
    double vslWt = 0.0,
    const char *arrTime = nullptr,
    const char *arrFlag = nullptr,
    const char *arrCargo = nullptr,
    const char *arrPort = nullptr,
    const char *depPort = nullptr,
    const char *depFlag = nullptr,
    const char *depCargo = nullptr,
    const char *desFlag = nullptr,
    const char *desCargo = nullptr,
    const char *destination = nullptr,
    const char *eta = nullptr,
    const char *etd = nullptr,
    const char *iff = nullptr,
    bool emgInd = false,
    bool dropPtInd = false,
    bool reinforced = false,
    bool reduced = false,
    bool hq = false,
    bool dummy = false,
    bool taskForce = false,
    bool feint = false,
    bool installation = false,
    const char *staffCmts = nullptr,
    const char *addInfo = nullptr,
    const char *evalRating = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    TrackDetails_Ingest_dataMode_Enum dataMode = TrackDetails_Ingest_dataMode_Enum_REAL,
    const char *origNetwork = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto msgType__ = msgType ? _fbb.CreateString(msgType) : 0;
  auto hullNum__ = hullNum ? _fbb.CreateString(hullNum) : 0;
  auto pif__ = pif ? _fbb.CreateString(pif) : 0;
  auto sconum__ = sconum ? _fbb.CreateString(sconum) : 0;
  auto ntds__ = ntds ? _fbb.CreateString(ntds) : 0;
  auto disId__ = disId ? _fbb.CreateString(disId) : 0;
  auto midbCat__ = midbCat ? _fbb.CreateString(midbCat) : 0;
  auto beNumber__ = beNumber ? _fbb.CreateString(beNumber) : 0;
  auto oSuffix__ = oSuffix ? _fbb.CreateString(oSuffix) : 0;
  auto pin__ = pin ? _fbb.CreateString(pin) : 0;
  auto muidSrcTrk__ = muidSrcTrk ? _fbb.CreateString(muidSrcTrk) : 0;
  auto muidSrc__ = muidSrc ? _fbb.CreateString(muidSrc) : 0;
  auto mslStatus__ = mslStatus ? _fbb.CreateString(mslStatus) : 0;
  auto alert__ = alert ? _fbb.CreateString(alert) : 0;
  auto origXref__ = origXref ? _fbb.CreateString(origXref) : 0;
  auto elnot1__ = elnot1 ? _fbb.CreateString(elnot1) : 0;
  auto elnot2__ = elnot2 ? _fbb.CreateString(elnot2) : 0;
  auto objType__ = objType ? _fbb.CreateString(objType) : 0;
  auto objPlat__ = objPlat ? _fbb.CreateString(objPlat) : 0;
  auto objAct__ = objAct ? _fbb.CreateString(objAct) : 0;
  auto objNat__ = objNat ? _fbb.CreateString(objNat) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shortName__ = shortName ? _fbb.CreateString(shortName) : 0;
  auto trkId__ = trkId ? _fbb.CreateString(trkId) : 0;
  auto trkNum__ = trkNum ? _fbb.CreateString(trkNum) : 0;
  auto trkScope__ = trkScope ? _fbb.CreateString(trkScope) : 0;
  auto sourceUid__ = sourceUid ? _fbb.CreateString(sourceUid) : 0;
  auto callSign__ = callSign ? _fbb.CreateString(callSign) : 0;
  auto identAmp__ = identAmp ? _fbb.CreateString(identAmp) : 0;
  auto spaceAmp__ = spaceAmp ? _fbb.CreateString(spaceAmp) : 0;
  auto spaceSpecType__ = spaceSpecType ? _fbb.CreateString(spaceSpecType) : 0;
  auto acftSubType__ = acftSubType ? _fbb.CreateString(acftSubType) : 0;
  auto ts__ = ts ? _fbb.CreateString(ts) : 0;
  auto launchTime__ = launchTime ? _fbb.CreateString(launchTime) : 0;
  auto impactTime__ = impactTime ? _fbb.CreateString(impactTime) : 0;
  auto ftnMsgTs__ = ftnMsgTs ? _fbb.CreateString(ftnMsgTs) : 0;
  auto ftn__ = ftn ? _fbb.CreateString(ftn) : 0;
  auto ftnCmd__ = ftnCmd ? _fbb.CreateString(ftnCmd) : 0;
  auto rtnMsgTs__ = rtnMsgTs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*rtnMsgTs) : 0;
  auto rtn__ = rtn ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*rtn) : 0;
  auto rtnTrkState__ = rtnTrkState ? _fbb.CreateString(rtnTrkState) : 0;
  auto rtnCmd__ = rtnCmd ? _fbb.CreateString(rtnCmd) : 0;
  auto sen__ = sen ? _fbb.CreateString(sen) : 0;
  auto rptChxref__ = rptChxref ? _fbb.CreateString(rptChxref) : 0;
  auto mil2525Bstr__ = mil2525Bstr ? _fbb.CreateString(mil2525Bstr) : 0;
  auto trnspdrId__ = trnspdrId ? _fbb.CreateString(trnspdrId) : 0;
  auto trnspdrType__ = trnspdrType ? _fbb.CreateString(trnspdrType) : 0;
  auto emitterName__ = emitterName ? _fbb.CreateString(emitterName) : 0;
  auto infoSource__ = infoSource ? _fbb.CreateString(infoSource) : 0;
  auto harmonics__ = harmonics ? _fbb.CreateString(harmonics) : 0;
  auto scanType__ = scanType ? _fbb.CreateString(scanType) : 0;
  auto cI__ = cI ? _fbb.CreateString(cI) : 0;
  auto errGeoAreaSwitch__ = errGeoAreaSwitch ? _fbb.CreateString(errGeoAreaSwitch) : 0;
  auto tesEventId__ = tesEventId ? _fbb.CreateString(tesEventId) : 0;
  auto coopLocInd__ = coopLocInd ? _fbb.CreateString(coopLocInd) : 0;
  auto maneuverInd__ = maneuverInd ? _fbb.CreateString(maneuverInd) : 0;
  auto launchAouType__ = launchAouType ? _fbb.CreateString(launchAouType) : 0;
  auto launchAouData__ = launchAouData ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*launchAouData) : 0;
  auto impactAouType__ = impactAouType ? _fbb.CreateString(impactAouType) : 0;
  auto impactAouData__ = impactAouData ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*impactAouData) : 0;
  auto aouRptType__ = aouRptType ? _fbb.CreateString(aouRptType) : 0;
  auto aouRptData__ = aouRptData ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*aouRptData) : 0;
  auto ecefPos__ = ecefPos ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ecefPos) : 0;
  auto ecefVel__ = ecefVel ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ecefVel) : 0;
  auto tcpa__ = tcpa ? _fbb.CreateString(tcpa) : 0;
  auto navStatus__ = navStatus ? _fbb.CreateString(navStatus) : 0;
  auto posDeviceType__ = posDeviceType ? _fbb.CreateString(posDeviceType) : 0;
  auto aton__ = aton ? _fbb.CreateString(aton) : 0;
  auto offPosInd__ = offPosInd ? _fbb.CreateString(offPosInd) : 0;
  auto antennaRefDimensions__ = antennaRefDimensions ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*antennaRefDimensions) : 0;
  auto shipClass__ = shipClass ? _fbb.CreateString(shipClass) : 0;
  auto cargoType__ = cargoType ? _fbb.CreateString(cargoType) : 0;
  auto appGrp__ = appGrp ? _fbb.CreateString(appGrp) : 0;
  auto hullProf__ = hullProf ? _fbb.CreateString(hullProf) : 0;
  auto propType__ = propType ? _fbb.CreateString(propType) : 0;
  auto sternType__ = sternType ? _fbb.CreateString(sternType) : 0;
  auto arrTime__ = arrTime ? _fbb.CreateString(arrTime) : 0;
  auto arrFlag__ = arrFlag ? _fbb.CreateString(arrFlag) : 0;
  auto arrCargo__ = arrCargo ? _fbb.CreateString(arrCargo) : 0;
  auto arrPort__ = arrPort ? _fbb.CreateString(arrPort) : 0;
  auto depPort__ = depPort ? _fbb.CreateString(depPort) : 0;
  auto depFlag__ = depFlag ? _fbb.CreateString(depFlag) : 0;
  auto depCargo__ = depCargo ? _fbb.CreateString(depCargo) : 0;
  auto desFlag__ = desFlag ? _fbb.CreateString(desFlag) : 0;
  auto desCargo__ = desCargo ? _fbb.CreateString(desCargo) : 0;
  auto destination__ = destination ? _fbb.CreateString(destination) : 0;
  auto eta__ = eta ? _fbb.CreateString(eta) : 0;
  auto etd__ = etd ? _fbb.CreateString(etd) : 0;
  auto iff__ = iff ? _fbb.CreateString(iff) : 0;
  auto staffCmts__ = staffCmts ? _fbb.CreateString(staffCmts) : 0;
  auto addInfo__ = addInfo ? _fbb.CreateString(addInfo) : 0;
  auto evalRating__ = evalRating ? _fbb.CreateString(evalRating) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateTrackDetails_Ingest(
      _fbb,
      id__,
      classificationMarking__,
      env,
      msgType__,
      hullNum__,
      pif__,
      sconum__,
      ntds__,
      disId__,
      midbCat__,
      beNumber__,
      oSuffix__,
      pin__,
      lostTrkInd,
      muidSrcTrk__,
      muidSrc__,
      mslStatus__,
      trkConf,
      trkQual,
      alert__,
      origXref__,
      elnot1__,
      elnot2__,
      objIdent,
      objType__,
      objPlat__,
      objAct__,
      objNat__,
      name__,
      shortName__,
      trkId__,
      trkNum__,
      trkScope__,
      sourceUid__,
      callSign__,
      identAmp__,
      spaceAmp__,
      spaceAmpConf,
      spaceSpecType__,
      acftSubType__,
      ts__,
      launchTime__,
      impactTime__,
      ftnMsgTs__,
      ftn__,
      ftnCmd__,
      rtnMsgTs__,
      rtn__,
      rtnTrkState__,
      rtnCmd__,
      sen__,
      rptChxref__,
      rptArchived,
      selfReport,
      mil2525Bstr__,
      trnspdrId__,
      trnspdrType__,
      emitterName__,
      infoSource__,
      boosting,
      freq,
      maxFreq,
      harmonics__,
      pri,
      prf,
      pw,
      scanType__,
      scanRate,
      scn,
      cI__,
      angElev,
      lat,
      lon,
      launchLat,
      launchLon,
      impactLat,
      impactLon,
      polarSingLocLat,
      polarSingLocLon,
      azCorrCenterLine,
      azCorrArcWidth,
      errSemiIntAxis,
      errAreaOrient,
      errSemiMajElev,
      errGeoAreaSwitch__,
      burnoutAlt,
      tesEventId__,
      spd,
      avgSpd,
      tol,
      alt,
      hdng,
      course,
      propRPM,
      tpk,
      coopLocInd__,
      maneuverInd__,
      launchAouType__,
      launchAouData__,
      impactAouType__,
      impactAouData__,
      aouRptType__,
      aouRptData__,
      ecefPos__,
      ecefVel__,
      containment,
      cpa,
      tcpa__,
      navStatus__,
      posDeviceType__,
      aton__,
      offPosInd__,
      antennaRefDimensions__,
      shipClass__,
      imon,
      mmsi,
      draught,
      length,
      width,
      cargoType__,
      appGrp__,
      hullProf__,
      propType__,
      numBlades,
      numShafts,
      sternType__,
      vslWt,
      arrTime__,
      arrFlag__,
      arrCargo__,
      arrPort__,
      depPort__,
      depFlag__,
      depCargo__,
      desFlag__,
      desCargo__,
      destination__,
      eta__,
      etd__,
      iff__,
      emgInd,
      dropPtInd,
      reinforced,
      reduced,
      hq,
      dummy,
      taskForce,
      feint,
      installation,
      staffCmts__,
      addInfo__,
      evalRating__,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      dataMode,
      origNetwork__);
}

inline const TrackDetails_Ingest *GetTrackDetails_Ingest(const void *buf) {
  return ::flatbuffers::GetRoot<TrackDetails_Ingest>(buf);
}

inline const TrackDetails_Ingest *GetSizePrefixedTrackDetails_Ingest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<TrackDetails_Ingest>(buf);
}

inline const char *TrackDetails_IngestIdentifier() {
  return "TRAC";
}

inline bool TrackDetails_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TrackDetails_IngestIdentifier());
}

inline bool SizePrefixedTrackDetails_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TrackDetails_IngestIdentifier(), true);
}

inline bool VerifyTrackDetails_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<TrackDetails_Ingest>(TrackDetails_IngestIdentifier());
}

inline bool VerifySizePrefixedTrackDetails_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<TrackDetails_Ingest>(TrackDetails_IngestIdentifier());
}

inline void FinishTrackDetails_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TrackDetails_Ingest> root) {
  fbb.Finish(root, TrackDetails_IngestIdentifier());
}

inline void FinishSizePrefixedTrackDetails_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TrackDetails_Ingest> root) {
  fbb.FinishSizePrefixed(root, TrackDetails_IngestIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
