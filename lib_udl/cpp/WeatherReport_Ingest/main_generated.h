// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct WeatherReport_Ingest;
struct WeatherReport_IngestBuilder;

enum WeatherReport_Ingest_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  WeatherReport_Ingest_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  WeatherReport_Ingest_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  WeatherReport_Ingest_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  WeatherReport_Ingest_dataMode_Enum_EXERCISE = 3,
  WeatherReport_Ingest_dataMode_Enum_MIN = WeatherReport_Ingest_dataMode_Enum_REAL,
  WeatherReport_Ingest_dataMode_Enum_MAX = WeatherReport_Ingest_dataMode_Enum_EXERCISE
};

inline const WeatherReport_Ingest_dataMode_Enum (&EnumValuesWeatherReport_Ingest_dataMode_Enum())[4] {
  static const WeatherReport_Ingest_dataMode_Enum values[] = {
    WeatherReport_Ingest_dataMode_Enum_REAL,
    WeatherReport_Ingest_dataMode_Enum_TEST,
    WeatherReport_Ingest_dataMode_Enum_SIMULATED,
    WeatherReport_Ingest_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesWeatherReport_Ingest_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameWeatherReport_Ingest_dataMode_Enum(WeatherReport_Ingest_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, WeatherReport_Ingest_dataMode_Enum_REAL, WeatherReport_Ingest_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWeatherReport_Ingest_dataMode_Enum()[index];
}

/// /// These services provide for posting and querying Weather Over Target information. The information contained within describes the current weather conditions over a target area or region to include navigational considerations such as altimeter settings, visibility, cloud heights etc.
struct WeatherReport_Ingest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WeatherReport_IngestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_IDSENSOR = 8,
    VT_ORIGSENSORID = 10,
    VT_WEATHERID = 12,
    VT_IDGROUNDIMAGERY = 14,
    VT_IDSITE = 16,
    VT_IDAIRFIELD = 18,
    VT_ICAO = 20,
    VT_EXTERNALID = 22,
    VT_EXTERNALLOCATIONID = 24,
    VT_REPORTTYPE = 26,
    VT_OBTIME = 28,
    VT_FORECASTSTARTTIME = 30,
    VT_FORECASTENDTIME = 32,
    VT_LAT = 34,
    VT_LON = 36,
    VT_ALT = 38,
    VT_GEOPOTENTIALALT = 40,
    VT_DATALEVEL = 42,
    VT_AREA = 44,
    VT_ATEXT = 46,
    VT_AGJSON = 48,
    VT_ATYPE = 50,
    VT_ANDIMS = 52,
    VT_ASRID = 54,
    VT_WINDSPD = 56,
    VT_WINDSPDAVG = 58,
    VT_WINDGUST = 60,
    VT_WINDGUST10 = 62,
    VT_VSHEAR = 64,
    VT_HSHEAR = 66,
    VT_RADVEL = 68,
    VT_RADVELBEAM1 = 70,
    VT_RADVELBEAM2 = 72,
    VT_RADVELBEAM3 = 74,
    VT_RADVELBEAM4 = 76,
    VT_RADVELBEAM5 = 78,
    VT_WINDDIR = 80,
    VT_WINDDIRAVG = 82,
    VT_WINDDIRPEAK = 84,
    VT_WINDDIRPEAK10 = 86,
    VT_WINDCHILL = 88,
    VT_DIRDEV = 90,
    VT_WINDVAR = 92,
    VT_WINDCOV = 94,
    VT_CLOUDCOVER = 96,
    VT_CLOUDHGHT = 98,
    VT_ACTWEATHER = 100,
    VT_WEATHERDESC = 102,
    VT_WEATHERINT = 104,
    VT_RAWMETAR = 106,
    VT_RAWTAF = 108,
    VT_QNH = 110,
    VT_VISIBILITY = 112,
    VT_TEMPERATURE = 114,
    VT_SOILTEMP = 116,
    VT_BARPRESS = 118,
    VT_PRECIPRATE = 120,
    VT_RAINHOUR = 122,
    VT_SOLARRAD = 124,
    VT_DIFRAD = 126,
    VT_REFRAD = 128,
    VT_SENLAT = 130,
    VT_SENLON = 132,
    VT_SENALT = 134,
    VT_DEWPOINT = 136,
    VT_RELHUMIDITY = 138,
    VT_INDEXREFRACTION = 140,
    VT_SOILMOISTURE = 142,
    VT_SURROUNDINGWEATHER = 144,
    VT_WEATHERAMP = 146,
    VT_CONTRAILHGHTLOWER = 148,
    VT_CONTRAILHGHTUPPER = 150,
    VT_ICINGUPPERLIMIT = 152,
    VT_ICINGLOWERLIMIT = 154,
    VT_ENROUTEWEATHER = 156,
    VT_CCEVENT = 158,
    VT_SRCTYPS = 160,
    VT_SRCIDS = 162,
    VT_ORIGNETWORK = 164,
    VT_CREATEDAT = 166,
    VT_CREATEDBY = 168,
    VT_SOURCE = 170,
    VT_ORIGIN = 172,
    VT_DATAMODE = 174
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: WEATHER-REPORT-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Unique identifier of the sensor making the weather measurement.
  /// Example: /// Example: 0129f577-e04c-441e-65ca-0a04a750bed9
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR);
  }
  /// Optional identifier provided by the record source. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origSensorId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGSENSORID);
  }
  /// Identifier of the weather over target, which should remain the same on subsequent Weather Over Target records.
  /// Example: /// Example: WEATHER-ID
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *weatherId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEATHERID);
  }
  /// Identifier of the ground imagery associated for this weather over target report.
  /// Example: /// Example: GROUND-IMAGERY-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idGroundImagery() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDGROUNDIMAGERY);
  }
  /// Identifier of the Site that is associated with this weather report.
  /// Example: /// Example: AIRFIELD-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSite() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSITE);
  }
  /// Identifier of the Airfield associated with this weather report.
  /// Example: /// Example: 8fb38d6d-a3de-45dd-8974-4e3ed73e9449
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idAirfield() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDAIRFIELD);
  }
  /// The International Civil Aviation Organization (ICAO) code of the airfield associated with this weather report.
  /// Example: /// Example: KAFF
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *icao() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICAO);
  }
  /// Optional observation or forecast ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: GDSSMB022408301601304517
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *externalId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTERNALID);
  }
  /// Optional location ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: TMDS060AD4OG03CC
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *externalLocationId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTERNALLOCATIONID);
  }
  /// Identifies the type of weather report (e.g. OBSERVATION, FORECAST, etc.).
  /// Example: /// Example: FORECAST
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *reportType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REPORTTYPE);
  }
  /// Datetime when a weather observation was made or forecast was issued in ISO 8601 UTC datetime format with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *obTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBTIME);
  }
  /// Valid start time of a weather forecast in ISO 8601 UTC datetime format with millisecond precision.
  /// Example: /// Example: 2024-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *forecastStartTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FORECASTSTARTTIME);
  }
  /// Valid end time of a weather forecast in ISO 8601 UTC datetime format with millisecond precision.
  /// Example: /// Example: 2024-01-01T18:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *forecastEndTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FORECASTENDTIME);
  }
  /// The central WGS-84 latitude of the weather report, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 56.12
  /// Constraints: No constraints specified.
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  /// The central WGS-84 longitude of the weather report, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: -156.6
  /// Constraints: No constraints specified.
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  /// Point height above ellipsoid (WGS-84), in meters.
  /// Example: /// Example: 123.12
  /// Constraints: No constraints specified.
  double alt() const {
    return GetField<double>(VT_ALT, 0.0);
  }
  /// Altitude of a pressure surface in the atmosphere above mean sea level, in meters.
  /// Example: /// Example: 1000.0
  /// Constraints: No constraints specified.
  double geoPotentialAlt() const {
    return GetField<double>(VT_GEOPOTENTIALALT, 0.0);
  }
  /// Specific pressures or heights where measurements are taken, labeled as either MANDATORY or SIGNIFICANT levels. Mandatory levels are at particular pressures at geopotential heights. Significant levels are at particular geometric heights.
  /// Example: /// Example: MANDATORY
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *dataLevel() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATALEVEL);
  }
  /// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
  /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *area() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AREA);
  }
  /// Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
  /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *atext() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATEXT);
  }
  /// Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
  /// Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *agjson() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AGJSON);
  }
  /// Type of region as projected on the ground.
  /// Example: /// Example: ST_Polygon
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *atype() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATYPE);
  }
  /// Number of dimensions of the geometry depicted by region.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t andims() const {
    return GetField<int32_t>(VT_ANDIMS, 0);
  }
  /// Geographical spatial_ref_sys for region.
  /// Example: /// Example: 4326
  /// Constraints: No constraints specified.
  int32_t asrid() const {
    return GetField<int32_t>(VT_ASRID, 0);
  }
  /// Expresses the speed of the wind in meters/second.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double windSpd() const {
    return GetField<double>(VT_WINDSPD, 0.0);
  }
  /// Average wind speed over a 1 minute period, in meters/second.
  /// Example: /// Example: 12.1
  /// Constraints: No constraints specified.
  double windSpdAvg() const {
    return GetField<double>(VT_WINDSPDAVG, 0.0);
  }
  /// Expresses the max gust speed of the wind, in meters/second.
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  double windGust() const {
    return GetField<double>(VT_WINDGUST, 0.0);
  }
  /// Expresses the max gust speed of the wind recorded in a 10 minute period, in meters/second.
  /// Example: /// Example: 13.2
  /// Constraints: No constraints specified.
  double windGust10() const {
    return GetField<double>(VT_WINDGUST10, 0.0);
  }
  /// The change in wind speed between two different altitudes divided by the vertical distance between them, in units of 1/sec.
  /// Example: /// Example: 3.8
  /// Constraints: No constraints specified.
  double vshear() const {
    return GetField<double>(VT_VSHEAR, 0.0);
  }
  /// The change in wind speed between two different lateral positions at a given altitude divided by the horizontal distance between them, in units of 1/sec.
  /// Example: /// Example: 3.8
  /// Constraints: No constraints specified.
  double hshear() const {
    return GetField<double>(VT_HSHEAR, 0.0);
  }
  /// Average radial velocity of wind as measured by radar with multi-beam configurations. Radial velocity is the component of wind velocity moving directly toward or away from a sensor's radar beam, in meters per second. Values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar).
  /// Example: /// Example: -0.04
  /// Constraints: No constraints specified.
  double radVel() const {
    return GetField<double>(VT_RADVEL, 0.0);
  }
  /// Component of wind velocity moving directly toward or away from radar beam 1, in meters per second. Radial velocity values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar). The beam number designation is defined by the data source.
  /// Example: /// Example: 4.4
  /// Constraints: No constraints specified.
  double radVelBeam1() const {
    return GetField<double>(VT_RADVELBEAM1, 0.0);
  }
  /// Component of wind velocity moving directly toward or away from radar beam 2, in meters per second. Radial velocity values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar). The beam number designation is defined by the data source.
  /// Example: /// Example: -0.2
  /// Constraints: No constraints specified.
  double radVelBeam2() const {
    return GetField<double>(VT_RADVELBEAM2, 0.0);
  }
  /// Component of wind velocity moving directly toward or away from radar beam 3, in meters per second. Radial velocity values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar). The beam number designation is defined by the data source.
  /// Example: /// Example: -0.2
  /// Constraints: No constraints specified.
  double radVelBeam3() const {
    return GetField<double>(VT_RADVELBEAM3, 0.0);
  }
  /// Component of wind velocity moving directly toward or away from radar beam 4, in meters per second. Radial velocity values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar). The beam number designation is defined by the data source.
  /// Example: /// Example: 11.4
  /// Constraints: No constraints specified.
  double radVelBeam4() const {
    return GetField<double>(VT_RADVELBEAM4, 0.0);
  }
  /// Component of wind velocity moving directly toward or away from radar beam 5, in meters per second. Radial velocity values can either be positive (wind is moving away from the radar) or negative (wind is moving toward the radar). The beam number designation is defined by the data source.
  /// Example: /// Example: 4.1
  /// Constraints: No constraints specified.
  double radVelBeam5() const {
    return GetField<double>(VT_RADVELBEAM5, 0.0);
  }
  /// Direction the wind is blowing, in degrees clockwise from true north.
  /// Example: /// Example: 75.1234
  /// Constraints: No constraints specified.
  double windDir() const {
    return GetField<double>(VT_WINDDIR, 0.0);
  }
  /// Average wind direction over a 1 minute period, in degrees clockwise from true north.
  /// Example: /// Example: 57.1
  /// Constraints: No constraints specified.
  double windDirAvg() const {
    return GetField<double>(VT_WINDDIRAVG, 0.0);
  }
  /// Wind direction corresponding to the peak wind speed during a 1 minute period, in degrees clockwise from true north.
  /// Example: /// Example: 78.4
  /// Constraints: No constraints specified.
  double windDirPeak() const {
    return GetField<double>(VT_WINDDIRPEAK, 0.0);
  }
  /// Wind direction corresponding to the peak wind speed during a 10 minute period, in degrees clockwise from true north.
  /// Example: /// Example: 44.5
  /// Constraints: No constraints specified.
  double windDirPeak10() const {
    return GetField<double>(VT_WINDDIRPEAK10, 0.0);
  }
  /// The perceived temperature in degrees C.
  /// Example: /// Example: 15.6
  /// Constraints: No constraints specified.
  double windChill() const {
    return GetField<double>(VT_WINDCHILL, 0.0);
  }
  /// The difference in wind direction recorded over a period of time, in degrees.
  /// Example: /// Example: 9.1
  /// Constraints: No constraints specified.
  double dirDev() const {
    return GetField<double>(VT_DIRDEV, 0.0);
  }
  /// Boolean describing whether or not the wind direction and/or speed is variable.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool windVar() const {
    return GetField<uint8_t>(VT_WINDVAR, 0) != 0;
  }
  /// Covariance matrix, in knots and second based units.  The array values represent the lower triangular half of the covariance matrix. The size of the covariance matrix is 2x2.  The covariance elements are position dependent within the array with values ordered as follows:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y
  /// x&nbsp;&nbsp;&nbsp;&nbsp;1
  /// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
  /// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
  /// Example: /// Example: [1.1, 2.2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *windCov() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_WINDCOV);
  }
  /// Array of cloud cover descriptions - each element can be maximum of 16 characters long. Intended as, but not constrained to, MIL-STD-6016 cloud cover designations (e.g. SKY CLEAR, SCATTERED, BROKEN, OVERCAST, SKY OBSCURED). Each element of the array corresponds to the elements in the cloudHght array specified respectively.
  /// Example: /// Example: ['OVERCAST', 'BROKEN']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *cloudCover() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CLOUDCOVER);
  }
  /// Array of cloud base heights in meters described by the cloudHght array. Each element of the array corresponds to the elements in the cloudCover array specified respectively.
  /// Example: /// Example: [1.2, 2.2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *cloudHght() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CLOUDHGHT);
  }
  /// Describes the actual weather at position. Intended as, but not constrained to, MIL-STD-6016 actual weather (e.g. NO STATEMENT, NO SIGNIFICANT WEATHER, DRIZZLE, RAIN, SNOW, SNOW GRAINS, DIAMOND DUST, ICE PELLETS, HAIL, SMALL HAIL, MIST, FOG, SMOKE, VOLCANIC ASH, WIDESPREAD DUST, SAND, HAZE, WELL DEVELOPED DUST, SQUALLS, FUNNEL CLOUDS, SANDSTORM, DUSTSTORM, LOW CLOUDS, CLOUDY, GROUND FOG, DUST, HEAVY RAIN, THUNDERSTORMS AWT, HEAVY THUNDERSTORMS, HURRICANE TYPHOON CYCLONE, TROPICAL STORM, TORNADO, HIGH WINDS, LIGHTNING, FREEZING DRIZZLE, FREEZING RAIN, HEAVY SNOW, ICING, SNOW OR RAIN AND SNOW MIXED, SHOWERS, CLEAR).
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *actWeather() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACTWEATHER);
  }
  /// Used in conjunction with actWeather and weatherInt. Intended as, but not constrained to, MIL-STD-6016 actual weather descriptor (e.g. NO STATEMENT, SHALLOW, PATCHES, LOW DRIFTING, BLOWING, SHOWERS, THUNDERSTORMS, SUPERCOOLED).
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *weatherDesc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEATHERDESC);
  }
  /// Weather Intensity. Used in conjunction with actWeather and weatherDesc. Intended as, but not constrained to, MIL-STD-6016 weather intensity (e.g. NO STATEMENT, LIGHT, MODERATE, HEAVY, IN VICINITY).
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *weatherInt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEATHERINT);
  }
  /// The Raw Meteorological Aerodrome Report (METAR) string.
  /// Example: /// Example: KXYZ 241456Z 19012G20KT 10SM FEW120 SCT200 BKN250 26/M04 A2981 RMK AO2 PK WND 19026/1420 SLP068 T02611039 51015
  /// Constraints: Minimum length = 0, Maximum length = 512
  const ::flatbuffers::String *rawMETAR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RAWMETAR);
  }
  /// Terminal Aerodrome Forecast (TAF) containing detailed weather predictions for a specific airport or aerodrome.
  /// Example: /// Example: KXYZ 051730Z 0518/0624 31008KT 3SM -SHRA BKN020 FM052300 30006KT 5SM -SHRA OVC030 PROB30 0604/0606 VRB20G35KT 1SM TSRA BKN015CB FM060600 25010KT 4SM -SHRA OVC050 TEMPO 0608/0611 2SM -SHRA OVC030 RMK NXT FCST BY 00Z=
  /// Constraints: Minimum length = 0, Maximum length = 1024
  const ::flatbuffers::String *rawTAF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RAWTAF);
  }
  /// Altimeter set to read zero at mean sea level in kilopascals.
  /// Example: /// Example: 1234.456
  /// Constraints: No constraints specified.
  double qnh() const {
    return GetField<double>(VT_QNH, 0.0);
  }
  /// Visual distance in meters.
  /// Example: /// Example: 1234.456
  /// Constraints: No constraints specified.
  double visibility() const {
    return GetField<double>(VT_VISIBILITY, 0.0);
  }
  /// The measurement of air temperature in degrees C.
  /// Example: /// Example: 23.45
  /// Constraints: No constraints specified.
  double temperature() const {
    return GetField<double>(VT_TEMPERATURE, 0.0);
  }
  /// The measurement of soil temperature in degrees C.
  /// Example: /// Example: 22.4
  /// Constraints: No constraints specified.
  double soilTemp() const {
    return GetField<double>(VT_SOILTEMP, 0.0);
  }
  /// The measurement of air pressure in the atmosphere in kilopascals.
  /// Example: /// Example: 101.2
  /// Constraints: No constraints specified.
  double barPress() const {
    return GetField<double>(VT_BARPRESS, 0.0);
  }
  /// The speed at which water is being applied to a specific area in millimeters per hour.
  /// Example: /// Example: 3.4
  /// Constraints: No constraints specified.
  double precipRate() const {
    return GetField<double>(VT_PRECIPRATE, 0.0);
  }
  /// The amount of rain that has fallen in the past hour, in centimeters.
  /// Example: /// Example: 1.2
  /// Constraints: No constraints specified.
  double rainHour() const {
    return GetField<double>(VT_RAINHOUR, 0.0);
  }
  /// The power per unit area received from the Sun in the form of electromagnetic radiation as measured in the wavelength range of the measuring instrument. The solar irradiance is measured in watt per square meter (W/m2).
  /// Example: /// Example: 1234.456
  /// Constraints: No constraints specified.
  double solarRad() const {
    return GetField<double>(VT_SOLARRAD, 0.0);
  }
  /// The amount of radiation that reaches earth's surface after being scattered by the atmosphere, in Watts per square meter.
  /// Example: /// Example: 234.5
  /// Constraints: No constraints specified.
  double difRad() const {
    return GetField<double>(VT_DIFRAD, 0.0);
  }
  /// The amount of radiation that changes direction as a function of atmospheric density, in Watts per square meter.
  /// Example: /// Example: 56.7
  /// Constraints: No constraints specified.
  double refRad() const {
    return GetField<double>(VT_REFRAD, 0.0);
  }
  /// Sensor WGS84 latitude at obTime in degrees. -90 to 90 degrees (negative values south of equator). This includes pilot reports or other means of weather observation.
  /// Example: /// Example: 12.456
  /// Constraints: No constraints specified.
  double senlat() const {
    return GetField<double>(VT_SENLAT, 0.0);
  }
  /// Sensor WGS84 longitude at obTime in degrees. -180 to 180 degrees (negative values west of Prime Meridian). This includes pilot reports or other means of weather observation.
  /// Example: /// Example: 123.456
  /// Constraints: No constraints specified.
  double senlon() const {
    return GetField<double>(VT_SENLON, 0.0);
  }
  /// Sensor altitude at obTime in km. This includes pilot reports or other means of weather observation.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double senalt() const {
    return GetField<double>(VT_SENALT, 0.0);
  }
  /// The temperature at which air is saturated with water vapor, in degrees C.
  /// Example: /// Example: 15.6
  /// Constraints: No constraints specified.
  double dewPoint() const {
    return GetField<double>(VT_DEWPOINT, 0.0);
  }
  /// The percentage of water vapor in the atmosphere.
  /// Example: /// Example: 34.456
  /// Constraints: No constraints specified.
  double relHumidity() const {
    return GetField<double>(VT_RELHUMIDITY, 0.0);
  }
  /// An indication of how much the atmosphere refracts light.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double indexRefraction() const {
    return GetField<double>(VT_INDEXREFRACTION, 0.0);
  }
  /// The volumetric percentage of soil water contained in a given volume of soil.
  /// Example: /// Example: 3.5
  /// Constraints: No constraints specified.
  double soilMoisture() const {
    return GetField<double>(VT_SOILMOISTURE, 0.0);
  }
  /// Describes in which direction (if any) that better weather conditions exist. Intended as, but not constrained to, MIL-STD-6016 surrounding weather designations (e.g. NO STATEMENT, BETTER TO NORTH, BETTER TO EAST, BETTER TO SOUTH, BETTER TO WEST).
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *surroundingWeather() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SURROUNDINGWEATHER);
  }
  /// Amplifies the actual weather being reported. Intended as, but not constrained to, MIL-STD-6016 weather amplification designations (e.g. NO STATEMENT, NO SCATTERED BROKEN MEDIUM CLOUD, SCATTERED BROKEN MEDIUM CLOUDS, GUSTY WINDS AT SERVICE, FOG IN VALLEYS, HIGHER TERRAIN OBSCURED, SURFACE CONDITIONS VARIABLE, SURFACE WIND NE, SURFACE WIND SE, SURFACE WIND SW, SURFACE WIND NW, PRESENCE OF CUMULONIMBUS).
  /// Example: /// Example: NO STATEMENT
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *weatherAmp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEATHERAMP);
  }
  /// Reports the lowest altitude at which contrails are occurring, in meters.
  /// Example: /// Example: 123.123
  /// Constraints: No constraints specified.
  double contrailHghtLower() const {
    return GetField<double>(VT_CONTRAILHGHTLOWER, 0.0);
  }
  /// Reports the highest altitude at which contrails are occurring, in meters.
  /// Example: /// Example: 123.123
  /// Constraints: No constraints specified.
  double contrailHghtUpper() const {
    return GetField<double>(VT_CONTRAILHGHTUPPER, 0.0);
  }
  /// Reports the highest altitude at which icing or freezing rain is occurring, in meters.
  /// Example: /// Example: 123.123
  /// Constraints: No constraints specified.
  double icingUpperLimit() const {
    return GetField<double>(VT_ICINGUPPERLIMIT, 0.0);
  }
  /// Reports the lowest altitude at which icing or freezing rain is occurring, in meters.
  /// Example: /// Example: 123.123
  /// Constraints: No constraints specified.
  double icingLowerLimit() const {
    return GetField<double>(VT_ICINGLOWERLIMIT, 0.0);
  }
  /// Describes the flight conditions in route to the target  (NO STATEMENT, MAINLY IFR, MAINLY VFR, THUNDERSTORMS).
  /// MAINLY IFR:&nbsp;&nbsp;Predominantly Instrument Flight Rules.
  /// MAINLY VFR:&nbsp;&nbsp;Predominantly Visual Flight Rules.
  /// THUNDERSTORMS:&nbsp;&nbsp;Thunderstorms expected in route.
  /// Example: /// Example: THUNDERSTORMS
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *enRouteWeather() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENROUTEWEATHER);
  }
  /// Flag indicating detection of a cloud-to-cloud lightning event.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool ccEvent() const {
    return GetField<uint8_t>(VT_CCEVENT, 0) != 0;
  }
  /// Array of UDL record types (SENSOR, WEATHERDATA) that are related to this WeatherReport record. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
  /// Example: /// Example: ['SENSOR', 'WEATHERDATA']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *srcTyps() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SRCTYPS);
  }
  /// Array of UUID(s) of the UDL data record(s) that are related to this WeatherReport record. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
  /// Example: /// Example: ['e609a90d-4059-4043-9f1a-fd7b49a3e1d0', 'c739fcdb-c0c9-43c0-97b6-bfc80d0ffd52']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *srcIds() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SRCIDS);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  WeatherReport_Ingest_dataMode_Enum dataMode() const {
    return static_cast<WeatherReport_Ingest_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_IDSENSOR) &&
           verifier.VerifyString(idSensor()) &&
           VerifyOffset(verifier, VT_ORIGSENSORID) &&
           verifier.VerifyString(origSensorId()) &&
           VerifyOffset(verifier, VT_WEATHERID) &&
           verifier.VerifyString(weatherId()) &&
           VerifyOffset(verifier, VT_IDGROUNDIMAGERY) &&
           verifier.VerifyString(idGroundImagery()) &&
           VerifyOffset(verifier, VT_IDSITE) &&
           verifier.VerifyString(idSite()) &&
           VerifyOffset(verifier, VT_IDAIRFIELD) &&
           verifier.VerifyString(idAirfield()) &&
           VerifyOffset(verifier, VT_ICAO) &&
           verifier.VerifyString(icao()) &&
           VerifyOffset(verifier, VT_EXTERNALID) &&
           verifier.VerifyString(externalId()) &&
           VerifyOffset(verifier, VT_EXTERNALLOCATIONID) &&
           verifier.VerifyString(externalLocationId()) &&
           VerifyOffset(verifier, VT_REPORTTYPE) &&
           verifier.VerifyString(reportType()) &&
           VerifyOffset(verifier, VT_OBTIME) &&
           verifier.VerifyString(obTime()) &&
           VerifyOffset(verifier, VT_FORECASTSTARTTIME) &&
           verifier.VerifyString(forecastStartTime()) &&
           VerifyOffset(verifier, VT_FORECASTENDTIME) &&
           verifier.VerifyString(forecastEndTime()) &&
           VerifyField<double>(verifier, VT_LAT, 8) &&
           VerifyField<double>(verifier, VT_LON, 8) &&
           VerifyField<double>(verifier, VT_ALT, 8) &&
           VerifyField<double>(verifier, VT_GEOPOTENTIALALT, 8) &&
           VerifyOffset(verifier, VT_DATALEVEL) &&
           verifier.VerifyString(dataLevel()) &&
           VerifyOffset(verifier, VT_AREA) &&
           verifier.VerifyString(area()) &&
           VerifyOffset(verifier, VT_ATEXT) &&
           verifier.VerifyString(atext()) &&
           VerifyOffset(verifier, VT_AGJSON) &&
           verifier.VerifyString(agjson()) &&
           VerifyOffset(verifier, VT_ATYPE) &&
           verifier.VerifyString(atype()) &&
           VerifyField<int32_t>(verifier, VT_ANDIMS, 4) &&
           VerifyField<int32_t>(verifier, VT_ASRID, 4) &&
           VerifyField<double>(verifier, VT_WINDSPD, 8) &&
           VerifyField<double>(verifier, VT_WINDSPDAVG, 8) &&
           VerifyField<double>(verifier, VT_WINDGUST, 8) &&
           VerifyField<double>(verifier, VT_WINDGUST10, 8) &&
           VerifyField<double>(verifier, VT_VSHEAR, 8) &&
           VerifyField<double>(verifier, VT_HSHEAR, 8) &&
           VerifyField<double>(verifier, VT_RADVEL, 8) &&
           VerifyField<double>(verifier, VT_RADVELBEAM1, 8) &&
           VerifyField<double>(verifier, VT_RADVELBEAM2, 8) &&
           VerifyField<double>(verifier, VT_RADVELBEAM3, 8) &&
           VerifyField<double>(verifier, VT_RADVELBEAM4, 8) &&
           VerifyField<double>(verifier, VT_RADVELBEAM5, 8) &&
           VerifyField<double>(verifier, VT_WINDDIR, 8) &&
           VerifyField<double>(verifier, VT_WINDDIRAVG, 8) &&
           VerifyField<double>(verifier, VT_WINDDIRPEAK, 8) &&
           VerifyField<double>(verifier, VT_WINDDIRPEAK10, 8) &&
           VerifyField<double>(verifier, VT_WINDCHILL, 8) &&
           VerifyField<double>(verifier, VT_DIRDEV, 8) &&
           VerifyField<uint8_t>(verifier, VT_WINDVAR, 1) &&
           VerifyOffset(verifier, VT_WINDCOV) &&
           verifier.VerifyVector(windCov()) &&
           verifier.VerifyVectorOfStrings(windCov()) &&
           VerifyOffset(verifier, VT_CLOUDCOVER) &&
           verifier.VerifyVector(cloudCover()) &&
           verifier.VerifyVectorOfStrings(cloudCover()) &&
           VerifyOffset(verifier, VT_CLOUDHGHT) &&
           verifier.VerifyVector(cloudHght()) &&
           verifier.VerifyVectorOfStrings(cloudHght()) &&
           VerifyOffset(verifier, VT_ACTWEATHER) &&
           verifier.VerifyString(actWeather()) &&
           VerifyOffset(verifier, VT_WEATHERDESC) &&
           verifier.VerifyString(weatherDesc()) &&
           VerifyOffset(verifier, VT_WEATHERINT) &&
           verifier.VerifyString(weatherInt()) &&
           VerifyOffset(verifier, VT_RAWMETAR) &&
           verifier.VerifyString(rawMETAR()) &&
           VerifyOffset(verifier, VT_RAWTAF) &&
           verifier.VerifyString(rawTAF()) &&
           VerifyField<double>(verifier, VT_QNH, 8) &&
           VerifyField<double>(verifier, VT_VISIBILITY, 8) &&
           VerifyField<double>(verifier, VT_TEMPERATURE, 8) &&
           VerifyField<double>(verifier, VT_SOILTEMP, 8) &&
           VerifyField<double>(verifier, VT_BARPRESS, 8) &&
           VerifyField<double>(verifier, VT_PRECIPRATE, 8) &&
           VerifyField<double>(verifier, VT_RAINHOUR, 8) &&
           VerifyField<double>(verifier, VT_SOLARRAD, 8) &&
           VerifyField<double>(verifier, VT_DIFRAD, 8) &&
           VerifyField<double>(verifier, VT_REFRAD, 8) &&
           VerifyField<double>(verifier, VT_SENLAT, 8) &&
           VerifyField<double>(verifier, VT_SENLON, 8) &&
           VerifyField<double>(verifier, VT_SENALT, 8) &&
           VerifyField<double>(verifier, VT_DEWPOINT, 8) &&
           VerifyField<double>(verifier, VT_RELHUMIDITY, 8) &&
           VerifyField<double>(verifier, VT_INDEXREFRACTION, 8) &&
           VerifyField<double>(verifier, VT_SOILMOISTURE, 8) &&
           VerifyOffset(verifier, VT_SURROUNDINGWEATHER) &&
           verifier.VerifyString(surroundingWeather()) &&
           VerifyOffset(verifier, VT_WEATHERAMP) &&
           verifier.VerifyString(weatherAmp()) &&
           VerifyField<double>(verifier, VT_CONTRAILHGHTLOWER, 8) &&
           VerifyField<double>(verifier, VT_CONTRAILHGHTUPPER, 8) &&
           VerifyField<double>(verifier, VT_ICINGUPPERLIMIT, 8) &&
           VerifyField<double>(verifier, VT_ICINGLOWERLIMIT, 8) &&
           VerifyOffset(verifier, VT_ENROUTEWEATHER) &&
           verifier.VerifyString(enRouteWeather()) &&
           VerifyField<uint8_t>(verifier, VT_CCEVENT, 1) &&
           VerifyOffset(verifier, VT_SRCTYPS) &&
           verifier.VerifyVector(srcTyps()) &&
           verifier.VerifyVectorOfStrings(srcTyps()) &&
           VerifyOffset(verifier, VT_SRCIDS) &&
           verifier.VerifyVector(srcIds()) &&
           verifier.VerifyVectorOfStrings(srcIds()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           verifier.EndTable();
  }
};

struct WeatherReport_IngestBuilder {
  typedef WeatherReport_Ingest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_idSensor(::flatbuffers::Offset<::flatbuffers::String> idSensor) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_IDSENSOR, idSensor);
  }
  void add_origSensorId(::flatbuffers::Offset<::flatbuffers::String> origSensorId) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_ORIGSENSORID, origSensorId);
  }
  void add_weatherId(::flatbuffers::Offset<::flatbuffers::String> weatherId) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_WEATHERID, weatherId);
  }
  void add_idGroundImagery(::flatbuffers::Offset<::flatbuffers::String> idGroundImagery) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_IDGROUNDIMAGERY, idGroundImagery);
  }
  void add_idSite(::flatbuffers::Offset<::flatbuffers::String> idSite) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_IDSITE, idSite);
  }
  void add_idAirfield(::flatbuffers::Offset<::flatbuffers::String> idAirfield) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_IDAIRFIELD, idAirfield);
  }
  void add_icao(::flatbuffers::Offset<::flatbuffers::String> icao) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_ICAO, icao);
  }
  void add_externalId(::flatbuffers::Offset<::flatbuffers::String> externalId) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_EXTERNALID, externalId);
  }
  void add_externalLocationId(::flatbuffers::Offset<::flatbuffers::String> externalLocationId) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_EXTERNALLOCATIONID, externalLocationId);
  }
  void add_reportType(::flatbuffers::Offset<::flatbuffers::String> reportType) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_REPORTTYPE, reportType);
  }
  void add_obTime(::flatbuffers::Offset<::flatbuffers::String> obTime) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_OBTIME, obTime);
  }
  void add_forecastStartTime(::flatbuffers::Offset<::flatbuffers::String> forecastStartTime) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_FORECASTSTARTTIME, forecastStartTime);
  }
  void add_forecastEndTime(::flatbuffers::Offset<::flatbuffers::String> forecastEndTime) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_FORECASTENDTIME, forecastEndTime);
  }
  void add_lat(double lat) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_LON, lon, 0.0);
  }
  void add_alt(double alt) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_ALT, alt, 0.0);
  }
  void add_geoPotentialAlt(double geoPotentialAlt) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_GEOPOTENTIALALT, geoPotentialAlt, 0.0);
  }
  void add_dataLevel(::flatbuffers::Offset<::flatbuffers::String> dataLevel) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_DATALEVEL, dataLevel);
  }
  void add_area(::flatbuffers::Offset<::flatbuffers::String> area) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_AREA, area);
  }
  void add_atext(::flatbuffers::Offset<::flatbuffers::String> atext) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_ATEXT, atext);
  }
  void add_agjson(::flatbuffers::Offset<::flatbuffers::String> agjson) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_AGJSON, agjson);
  }
  void add_atype(::flatbuffers::Offset<::flatbuffers::String> atype) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_ATYPE, atype);
  }
  void add_andims(int32_t andims) {
    fbb_.AddElement<int32_t>(WeatherReport_Ingest::VT_ANDIMS, andims, 0);
  }
  void add_asrid(int32_t asrid) {
    fbb_.AddElement<int32_t>(WeatherReport_Ingest::VT_ASRID, asrid, 0);
  }
  void add_windSpd(double windSpd) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_WINDSPD, windSpd, 0.0);
  }
  void add_windSpdAvg(double windSpdAvg) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_WINDSPDAVG, windSpdAvg, 0.0);
  }
  void add_windGust(double windGust) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_WINDGUST, windGust, 0.0);
  }
  void add_windGust10(double windGust10) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_WINDGUST10, windGust10, 0.0);
  }
  void add_vshear(double vshear) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_VSHEAR, vshear, 0.0);
  }
  void add_hshear(double hshear) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_HSHEAR, hshear, 0.0);
  }
  void add_radVel(double radVel) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_RADVEL, radVel, 0.0);
  }
  void add_radVelBeam1(double radVelBeam1) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_RADVELBEAM1, radVelBeam1, 0.0);
  }
  void add_radVelBeam2(double radVelBeam2) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_RADVELBEAM2, radVelBeam2, 0.0);
  }
  void add_radVelBeam3(double radVelBeam3) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_RADVELBEAM3, radVelBeam3, 0.0);
  }
  void add_radVelBeam4(double radVelBeam4) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_RADVELBEAM4, radVelBeam4, 0.0);
  }
  void add_radVelBeam5(double radVelBeam5) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_RADVELBEAM5, radVelBeam5, 0.0);
  }
  void add_windDir(double windDir) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_WINDDIR, windDir, 0.0);
  }
  void add_windDirAvg(double windDirAvg) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_WINDDIRAVG, windDirAvg, 0.0);
  }
  void add_windDirPeak(double windDirPeak) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_WINDDIRPEAK, windDirPeak, 0.0);
  }
  void add_windDirPeak10(double windDirPeak10) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_WINDDIRPEAK10, windDirPeak10, 0.0);
  }
  void add_windChill(double windChill) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_WINDCHILL, windChill, 0.0);
  }
  void add_dirDev(double dirDev) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_DIRDEV, dirDev, 0.0);
  }
  void add_windVar(bool windVar) {
    fbb_.AddElement<uint8_t>(WeatherReport_Ingest::VT_WINDVAR, static_cast<uint8_t>(windVar), 0);
  }
  void add_windCov(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> windCov) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_WINDCOV, windCov);
  }
  void add_cloudCover(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cloudCover) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_CLOUDCOVER, cloudCover);
  }
  void add_cloudHght(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cloudHght) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_CLOUDHGHT, cloudHght);
  }
  void add_actWeather(::flatbuffers::Offset<::flatbuffers::String> actWeather) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_ACTWEATHER, actWeather);
  }
  void add_weatherDesc(::flatbuffers::Offset<::flatbuffers::String> weatherDesc) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_WEATHERDESC, weatherDesc);
  }
  void add_weatherInt(::flatbuffers::Offset<::flatbuffers::String> weatherInt) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_WEATHERINT, weatherInt);
  }
  void add_rawMETAR(::flatbuffers::Offset<::flatbuffers::String> rawMETAR) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_RAWMETAR, rawMETAR);
  }
  void add_rawTAF(::flatbuffers::Offset<::flatbuffers::String> rawTAF) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_RAWTAF, rawTAF);
  }
  void add_qnh(double qnh) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_QNH, qnh, 0.0);
  }
  void add_visibility(double visibility) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_VISIBILITY, visibility, 0.0);
  }
  void add_temperature(double temperature) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_TEMPERATURE, temperature, 0.0);
  }
  void add_soilTemp(double soilTemp) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_SOILTEMP, soilTemp, 0.0);
  }
  void add_barPress(double barPress) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_BARPRESS, barPress, 0.0);
  }
  void add_precipRate(double precipRate) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_PRECIPRATE, precipRate, 0.0);
  }
  void add_rainHour(double rainHour) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_RAINHOUR, rainHour, 0.0);
  }
  void add_solarRad(double solarRad) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_SOLARRAD, solarRad, 0.0);
  }
  void add_difRad(double difRad) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_DIFRAD, difRad, 0.0);
  }
  void add_refRad(double refRad) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_REFRAD, refRad, 0.0);
  }
  void add_senlat(double senlat) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_SENLAT, senlat, 0.0);
  }
  void add_senlon(double senlon) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_SENLON, senlon, 0.0);
  }
  void add_senalt(double senalt) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_SENALT, senalt, 0.0);
  }
  void add_dewPoint(double dewPoint) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_DEWPOINT, dewPoint, 0.0);
  }
  void add_relHumidity(double relHumidity) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_RELHUMIDITY, relHumidity, 0.0);
  }
  void add_indexRefraction(double indexRefraction) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_INDEXREFRACTION, indexRefraction, 0.0);
  }
  void add_soilMoisture(double soilMoisture) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_SOILMOISTURE, soilMoisture, 0.0);
  }
  void add_surroundingWeather(::flatbuffers::Offset<::flatbuffers::String> surroundingWeather) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_SURROUNDINGWEATHER, surroundingWeather);
  }
  void add_weatherAmp(::flatbuffers::Offset<::flatbuffers::String> weatherAmp) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_WEATHERAMP, weatherAmp);
  }
  void add_contrailHghtLower(double contrailHghtLower) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_CONTRAILHGHTLOWER, contrailHghtLower, 0.0);
  }
  void add_contrailHghtUpper(double contrailHghtUpper) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_CONTRAILHGHTUPPER, contrailHghtUpper, 0.0);
  }
  void add_icingUpperLimit(double icingUpperLimit) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_ICINGUPPERLIMIT, icingUpperLimit, 0.0);
  }
  void add_icingLowerLimit(double icingLowerLimit) {
    fbb_.AddElement<double>(WeatherReport_Ingest::VT_ICINGLOWERLIMIT, icingLowerLimit, 0.0);
  }
  void add_enRouteWeather(::flatbuffers::Offset<::flatbuffers::String> enRouteWeather) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_ENROUTEWEATHER, enRouteWeather);
  }
  void add_ccEvent(bool ccEvent) {
    fbb_.AddElement<uint8_t>(WeatherReport_Ingest::VT_CCEVENT, static_cast<uint8_t>(ccEvent), 0);
  }
  void add_srcTyps(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcTyps) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_SRCTYPS, srcTyps);
  }
  void add_srcIds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcIds) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_SRCIDS, srcIds);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(WeatherReport_Ingest::VT_ORIGIN, origin);
  }
  void add_dataMode(WeatherReport_Ingest_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(WeatherReport_Ingest::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  explicit WeatherReport_IngestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WeatherReport_Ingest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WeatherReport_Ingest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WeatherReport_Ingest> CreateWeatherReport_Ingest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origSensorId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> weatherId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idGroundImagery = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSite = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idAirfield = 0,
    ::flatbuffers::Offset<::flatbuffers::String> icao = 0,
    ::flatbuffers::Offset<::flatbuffers::String> externalId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> externalLocationId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reportType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> obTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> forecastStartTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> forecastEndTime = 0,
    double lat = 0.0,
    double lon = 0.0,
    double alt = 0.0,
    double geoPotentialAlt = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> dataLevel = 0,
    ::flatbuffers::Offset<::flatbuffers::String> area = 0,
    ::flatbuffers::Offset<::flatbuffers::String> atext = 0,
    ::flatbuffers::Offset<::flatbuffers::String> agjson = 0,
    ::flatbuffers::Offset<::flatbuffers::String> atype = 0,
    int32_t andims = 0,
    int32_t asrid = 0,
    double windSpd = 0.0,
    double windSpdAvg = 0.0,
    double windGust = 0.0,
    double windGust10 = 0.0,
    double vshear = 0.0,
    double hshear = 0.0,
    double radVel = 0.0,
    double radVelBeam1 = 0.0,
    double radVelBeam2 = 0.0,
    double radVelBeam3 = 0.0,
    double radVelBeam4 = 0.0,
    double radVelBeam5 = 0.0,
    double windDir = 0.0,
    double windDirAvg = 0.0,
    double windDirPeak = 0.0,
    double windDirPeak10 = 0.0,
    double windChill = 0.0,
    double dirDev = 0.0,
    bool windVar = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> windCov = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cloudCover = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cloudHght = 0,
    ::flatbuffers::Offset<::flatbuffers::String> actWeather = 0,
    ::flatbuffers::Offset<::flatbuffers::String> weatherDesc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> weatherInt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rawMETAR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rawTAF = 0,
    double qnh = 0.0,
    double visibility = 0.0,
    double temperature = 0.0,
    double soilTemp = 0.0,
    double barPress = 0.0,
    double precipRate = 0.0,
    double rainHour = 0.0,
    double solarRad = 0.0,
    double difRad = 0.0,
    double refRad = 0.0,
    double senlat = 0.0,
    double senlon = 0.0,
    double senalt = 0.0,
    double dewPoint = 0.0,
    double relHumidity = 0.0,
    double indexRefraction = 0.0,
    double soilMoisture = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> surroundingWeather = 0,
    ::flatbuffers::Offset<::flatbuffers::String> weatherAmp = 0,
    double contrailHghtLower = 0.0,
    double contrailHghtUpper = 0.0,
    double icingUpperLimit = 0.0,
    double icingLowerLimit = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> enRouteWeather = 0,
    bool ccEvent = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcTyps = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcIds = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    WeatherReport_Ingest_dataMode_Enum dataMode = WeatherReport_Ingest_dataMode_Enum_REAL) {
  WeatherReport_IngestBuilder builder_(_fbb);
  builder_.add_icingLowerLimit(icingLowerLimit);
  builder_.add_icingUpperLimit(icingUpperLimit);
  builder_.add_contrailHghtUpper(contrailHghtUpper);
  builder_.add_contrailHghtLower(contrailHghtLower);
  builder_.add_soilMoisture(soilMoisture);
  builder_.add_indexRefraction(indexRefraction);
  builder_.add_relHumidity(relHumidity);
  builder_.add_dewPoint(dewPoint);
  builder_.add_senalt(senalt);
  builder_.add_senlon(senlon);
  builder_.add_senlat(senlat);
  builder_.add_refRad(refRad);
  builder_.add_difRad(difRad);
  builder_.add_solarRad(solarRad);
  builder_.add_rainHour(rainHour);
  builder_.add_precipRate(precipRate);
  builder_.add_barPress(barPress);
  builder_.add_soilTemp(soilTemp);
  builder_.add_temperature(temperature);
  builder_.add_visibility(visibility);
  builder_.add_qnh(qnh);
  builder_.add_dirDev(dirDev);
  builder_.add_windChill(windChill);
  builder_.add_windDirPeak10(windDirPeak10);
  builder_.add_windDirPeak(windDirPeak);
  builder_.add_windDirAvg(windDirAvg);
  builder_.add_windDir(windDir);
  builder_.add_radVelBeam5(radVelBeam5);
  builder_.add_radVelBeam4(radVelBeam4);
  builder_.add_radVelBeam3(radVelBeam3);
  builder_.add_radVelBeam2(radVelBeam2);
  builder_.add_radVelBeam1(radVelBeam1);
  builder_.add_radVel(radVel);
  builder_.add_hshear(hshear);
  builder_.add_vshear(vshear);
  builder_.add_windGust10(windGust10);
  builder_.add_windGust(windGust);
  builder_.add_windSpdAvg(windSpdAvg);
  builder_.add_windSpd(windSpd);
  builder_.add_geoPotentialAlt(geoPotentialAlt);
  builder_.add_alt(alt);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_origNetwork(origNetwork);
  builder_.add_srcIds(srcIds);
  builder_.add_srcTyps(srcTyps);
  builder_.add_enRouteWeather(enRouteWeather);
  builder_.add_weatherAmp(weatherAmp);
  builder_.add_surroundingWeather(surroundingWeather);
  builder_.add_rawTAF(rawTAF);
  builder_.add_rawMETAR(rawMETAR);
  builder_.add_weatherInt(weatherInt);
  builder_.add_weatherDesc(weatherDesc);
  builder_.add_actWeather(actWeather);
  builder_.add_cloudHght(cloudHght);
  builder_.add_cloudCover(cloudCover);
  builder_.add_windCov(windCov);
  builder_.add_asrid(asrid);
  builder_.add_andims(andims);
  builder_.add_atype(atype);
  builder_.add_agjson(agjson);
  builder_.add_atext(atext);
  builder_.add_area(area);
  builder_.add_dataLevel(dataLevel);
  builder_.add_forecastEndTime(forecastEndTime);
  builder_.add_forecastStartTime(forecastStartTime);
  builder_.add_obTime(obTime);
  builder_.add_reportType(reportType);
  builder_.add_externalLocationId(externalLocationId);
  builder_.add_externalId(externalId);
  builder_.add_icao(icao);
  builder_.add_idAirfield(idAirfield);
  builder_.add_idSite(idSite);
  builder_.add_idGroundImagery(idGroundImagery);
  builder_.add_weatherId(weatherId);
  builder_.add_origSensorId(origSensorId);
  builder_.add_idSensor(idSensor);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_ccEvent(ccEvent);
  builder_.add_windVar(windVar);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WeatherReport_Ingest> CreateWeatherReport_IngestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *idSensor = nullptr,
    const char *origSensorId = nullptr,
    const char *weatherId = nullptr,
    const char *idGroundImagery = nullptr,
    const char *idSite = nullptr,
    const char *idAirfield = nullptr,
    const char *icao = nullptr,
    const char *externalId = nullptr,
    const char *externalLocationId = nullptr,
    const char *reportType = nullptr,
    const char *obTime = nullptr,
    const char *forecastStartTime = nullptr,
    const char *forecastEndTime = nullptr,
    double lat = 0.0,
    double lon = 0.0,
    double alt = 0.0,
    double geoPotentialAlt = 0.0,
    const char *dataLevel = nullptr,
    const char *area = nullptr,
    const char *atext = nullptr,
    const char *agjson = nullptr,
    const char *atype = nullptr,
    int32_t andims = 0,
    int32_t asrid = 0,
    double windSpd = 0.0,
    double windSpdAvg = 0.0,
    double windGust = 0.0,
    double windGust10 = 0.0,
    double vshear = 0.0,
    double hshear = 0.0,
    double radVel = 0.0,
    double radVelBeam1 = 0.0,
    double radVelBeam2 = 0.0,
    double radVelBeam3 = 0.0,
    double radVelBeam4 = 0.0,
    double radVelBeam5 = 0.0,
    double windDir = 0.0,
    double windDirAvg = 0.0,
    double windDirPeak = 0.0,
    double windDirPeak10 = 0.0,
    double windChill = 0.0,
    double dirDev = 0.0,
    bool windVar = false,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *windCov = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *cloudCover = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *cloudHght = nullptr,
    const char *actWeather = nullptr,
    const char *weatherDesc = nullptr,
    const char *weatherInt = nullptr,
    const char *rawMETAR = nullptr,
    const char *rawTAF = nullptr,
    double qnh = 0.0,
    double visibility = 0.0,
    double temperature = 0.0,
    double soilTemp = 0.0,
    double barPress = 0.0,
    double precipRate = 0.0,
    double rainHour = 0.0,
    double solarRad = 0.0,
    double difRad = 0.0,
    double refRad = 0.0,
    double senlat = 0.0,
    double senlon = 0.0,
    double senalt = 0.0,
    double dewPoint = 0.0,
    double relHumidity = 0.0,
    double indexRefraction = 0.0,
    double soilMoisture = 0.0,
    const char *surroundingWeather = nullptr,
    const char *weatherAmp = nullptr,
    double contrailHghtLower = 0.0,
    double contrailHghtUpper = 0.0,
    double icingUpperLimit = 0.0,
    double icingLowerLimit = 0.0,
    const char *enRouteWeather = nullptr,
    bool ccEvent = false,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *srcTyps = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *srcIds = nullptr,
    const char *origNetwork = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    WeatherReport_Ingest_dataMode_Enum dataMode = WeatherReport_Ingest_dataMode_Enum_REAL) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto idSensor__ = idSensor ? _fbb.CreateString(idSensor) : 0;
  auto origSensorId__ = origSensorId ? _fbb.CreateString(origSensorId) : 0;
  auto weatherId__ = weatherId ? _fbb.CreateString(weatherId) : 0;
  auto idGroundImagery__ = idGroundImagery ? _fbb.CreateString(idGroundImagery) : 0;
  auto idSite__ = idSite ? _fbb.CreateString(idSite) : 0;
  auto idAirfield__ = idAirfield ? _fbb.CreateString(idAirfield) : 0;
  auto icao__ = icao ? _fbb.CreateString(icao) : 0;
  auto externalId__ = externalId ? _fbb.CreateString(externalId) : 0;
  auto externalLocationId__ = externalLocationId ? _fbb.CreateString(externalLocationId) : 0;
  auto reportType__ = reportType ? _fbb.CreateString(reportType) : 0;
  auto obTime__ = obTime ? _fbb.CreateString(obTime) : 0;
  auto forecastStartTime__ = forecastStartTime ? _fbb.CreateString(forecastStartTime) : 0;
  auto forecastEndTime__ = forecastEndTime ? _fbb.CreateString(forecastEndTime) : 0;
  auto dataLevel__ = dataLevel ? _fbb.CreateString(dataLevel) : 0;
  auto area__ = area ? _fbb.CreateString(area) : 0;
  auto atext__ = atext ? _fbb.CreateString(atext) : 0;
  auto agjson__ = agjson ? _fbb.CreateString(agjson) : 0;
  auto atype__ = atype ? _fbb.CreateString(atype) : 0;
  auto windCov__ = windCov ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*windCov) : 0;
  auto cloudCover__ = cloudCover ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*cloudCover) : 0;
  auto cloudHght__ = cloudHght ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*cloudHght) : 0;
  auto actWeather__ = actWeather ? _fbb.CreateString(actWeather) : 0;
  auto weatherDesc__ = weatherDesc ? _fbb.CreateString(weatherDesc) : 0;
  auto weatherInt__ = weatherInt ? _fbb.CreateString(weatherInt) : 0;
  auto rawMETAR__ = rawMETAR ? _fbb.CreateString(rawMETAR) : 0;
  auto rawTAF__ = rawTAF ? _fbb.CreateString(rawTAF) : 0;
  auto surroundingWeather__ = surroundingWeather ? _fbb.CreateString(surroundingWeather) : 0;
  auto weatherAmp__ = weatherAmp ? _fbb.CreateString(weatherAmp) : 0;
  auto enRouteWeather__ = enRouteWeather ? _fbb.CreateString(enRouteWeather) : 0;
  auto srcTyps__ = srcTyps ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*srcTyps) : 0;
  auto srcIds__ = srcIds ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*srcIds) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  return CreateWeatherReport_Ingest(
      _fbb,
      id__,
      classificationMarking__,
      idSensor__,
      origSensorId__,
      weatherId__,
      idGroundImagery__,
      idSite__,
      idAirfield__,
      icao__,
      externalId__,
      externalLocationId__,
      reportType__,
      obTime__,
      forecastStartTime__,
      forecastEndTime__,
      lat,
      lon,
      alt,
      geoPotentialAlt,
      dataLevel__,
      area__,
      atext__,
      agjson__,
      atype__,
      andims,
      asrid,
      windSpd,
      windSpdAvg,
      windGust,
      windGust10,
      vshear,
      hshear,
      radVel,
      radVelBeam1,
      radVelBeam2,
      radVelBeam3,
      radVelBeam4,
      radVelBeam5,
      windDir,
      windDirAvg,
      windDirPeak,
      windDirPeak10,
      windChill,
      dirDev,
      windVar,
      windCov__,
      cloudCover__,
      cloudHght__,
      actWeather__,
      weatherDesc__,
      weatherInt__,
      rawMETAR__,
      rawTAF__,
      qnh,
      visibility,
      temperature,
      soilTemp,
      barPress,
      precipRate,
      rainHour,
      solarRad,
      difRad,
      refRad,
      senlat,
      senlon,
      senalt,
      dewPoint,
      relHumidity,
      indexRefraction,
      soilMoisture,
      surroundingWeather__,
      weatherAmp__,
      contrailHghtLower,
      contrailHghtUpper,
      icingUpperLimit,
      icingLowerLimit,
      enRouteWeather__,
      ccEvent,
      srcTyps__,
      srcIds__,
      origNetwork__,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      dataMode);
}

inline const WeatherReport_Ingest *GetWeatherReport_Ingest(const void *buf) {
  return ::flatbuffers::GetRoot<WeatherReport_Ingest>(buf);
}

inline const WeatherReport_Ingest *GetSizePrefixedWeatherReport_Ingest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<WeatherReport_Ingest>(buf);
}

inline const char *WeatherReport_IngestIdentifier() {
  return "WEAT";
}

inline bool WeatherReport_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, WeatherReport_IngestIdentifier());
}

inline bool SizePrefixedWeatherReport_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, WeatherReport_IngestIdentifier(), true);
}

inline bool VerifyWeatherReport_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<WeatherReport_Ingest>(WeatherReport_IngestIdentifier());
}

inline bool VerifySizePrefixedWeatherReport_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<WeatherReport_Ingest>(WeatherReport_IngestIdentifier());
}

inline void FinishWeatherReport_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<WeatherReport_Ingest> root) {
  fbb.Finish(root, WeatherReport_IngestIdentifier());
}

inline void FinishSizePrefixedWeatherReport_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<WeatherReport_Ingest> root) {
  fbb.FinishSizePrefixed(root, WeatherReport_IngestIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
