// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct AnalyticImagery_Ingest;
struct AnalyticImagery_IngestBuilder;

enum AnalyticImagery_Ingest_dataMode_Enum : int8_t {
  /// No description available.
  AnalyticImagery_Ingest_dataMode_Enum_REAL = 0,
  /// No description available.
  AnalyticImagery_Ingest_dataMode_Enum_TEST = 1,
  /// No description available.
  AnalyticImagery_Ingest_dataMode_Enum_SIMULATED = 2,
  /// No description available.
  AnalyticImagery_Ingest_dataMode_Enum_EXERCISE = 3,
  AnalyticImagery_Ingest_dataMode_Enum_MIN = AnalyticImagery_Ingest_dataMode_Enum_REAL,
  AnalyticImagery_Ingest_dataMode_Enum_MAX = AnalyticImagery_Ingest_dataMode_Enum_EXERCISE
};

inline const AnalyticImagery_Ingest_dataMode_Enum (&EnumValuesAnalyticImagery_Ingest_dataMode_Enum())[4] {
  static const AnalyticImagery_Ingest_dataMode_Enum values[] = {
    AnalyticImagery_Ingest_dataMode_Enum_REAL,
    AnalyticImagery_Ingest_dataMode_Enum_TEST,
    AnalyticImagery_Ingest_dataMode_Enum_SIMULATED,
    AnalyticImagery_Ingest_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesAnalyticImagery_Ingest_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnalyticImagery_Ingest_dataMode_Enum(AnalyticImagery_Ingest_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, AnalyticImagery_Ingest_dataMode_Enum_REAL, AnalyticImagery_Ingest_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnalyticImagery_Ingest_dataMode_Enum()[index];
}

/// /// The analytic imagery schema supports data plots and graphics of various types. The records contain general file information, allows for annotations to user-defined areas of interest on the graphics, and supports keyword searching.
struct AnalyticImagery_Ingest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnalyticImagery_IngestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_CONTENT = 8,
    VT_MSGTIME = 10,
    VT_IMAGETYPE = 12,
    VT_FILENAME = 14,
    VT_FILESIZE = 16,
    VT_IMGWIDTH = 18,
    VT_IMGHEIGHT = 20,
    VT_XUNITS = 22,
    VT_YUNITS = 24,
    VT_ZUNITS = 26,
    VT_IMAGESETID = 28,
    VT_IMAGESETLENGTH = 30,
    VT_SEQUENCEID = 32,
    VT_DESCRIPTION = 34,
    VT_DATASTART = 36,
    VT_DATASTOP = 38,
    VT_ANNLIMS = 40,
    VT_ANNTEXT = 42,
    VT_KEYWORDS = 44,
    VT_AREA = 46,
    VT_ATEXT = 48,
    VT_AGJSON = 50,
    VT_ATYPE = 52,
    VT_ANDIMS = 54,
    VT_ASRID = 56,
    VT_SATID = 58,
    VT_SATIDCONF = 60,
    VT_SRCTYPS = 62,
    VT_SRCIDS = 64,
    VT_TAGS = 66,
    VT_CHECKSUMVALUE = 68,
    VT_TRANSACTIONID = 70,
    VT_CREATEDAT = 72,
    VT_CREATEDBY = 74,
    VT_SOURCE = 76,
    VT_ORIGIN = 78,
    VT_ORIGNETWORK = 80,
    VT_SOURCEDL = 82,
    VT_DATAMODE = 84
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: ANALYTIC-IMAGERY-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// General type of content of this image (CONTOUR, DIAGRAM, HEATMAP, HISTOGRAM, PLOT, SCREENSHOT).
  /// Example: /// Example: CONTOUR
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *content() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENT);
  }
  /// The message time of this image record, in ISO8601 UTC format with millisecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *msgTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSGTIME);
  }
  /// The type of image associated with this record (GIF, JPG, PNG, TIF).
  /// Example: /// Example: JPG
  /// Constraints: Minimum length = 1, Maximum length = 16
  const ::flatbuffers::String *imageType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMAGETYPE);
  }
  /// The image file name.
  /// Example: /// Example: IMAGE-NAME
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  /// The image file size, in bytes.  The maximum file size for this service is 40,000,000 bytes (40MB). Files exceeding the maximum size will be rejected.
  /// Example: /// Example: 7654321
  /// Constraints: No constraints specified.
  int64_t filesize() const {
    return GetField<int64_t>(VT_FILESIZE, 0);
  }
  /// The image width (horizontal), in pixels.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  int32_t imgWidth() const {
    return GetField<int32_t>(VT_IMGWIDTH, 0);
  }
  /// The image height (vertical), in pixels.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  int32_t imgHeight() const {
    return GetField<int32_t>(VT_IMGHEIGHT, 0);
  }
  /// Optional field indicating the units that apply to the x-axis of the attached image, when applicable.
  /// Example: /// Example: pixels
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *xUnits() const {
    return GetPointer<const ::flatbuffers::String *>(VT_XUNITS);
  }
  /// Optional field indicating the units that apply to the y-axis of the attached image, when applicable.
  /// Example: /// Example: pixels
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *yUnits() const {
    return GetPointer<const ::flatbuffers::String *>(VT_YUNITS);
  }
  /// Optional field indicating the units that apply to the z-axis of the attached image, when applicable.
  /// Example: /// Example: pixels
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *zUnits() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ZUNITS);
  }
  /// User-defined set ID of a sequence of images.  Used to associate related analytic image records.
  /// Example: /// Example: IMAGE-IDS
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *imageSetId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMAGESETID);
  }
  /// The number of images in an image set.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  int32_t imageSetLength() const {
    return GetField<int32_t>(VT_IMAGESETLENGTH, 0);
  }
  /// The sequence number of an image within an image set.  If null, then it is assumed that the order of images in an imageSet is not relevant.
  /// Example: /// Example: 123
  /// Constraints: No constraints specified.
  int32_t sequenceId() const {
    return GetField<int32_t>(VT_SEQUENCEID, 0);
  }
  /// Description of the image content and utility.
  /// Example: /// Example: Image description
  /// Constraints: Minimum length = 1, Maximum length = 512
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// The start time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *dataStart() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATASTART);
  }
  /// The stop time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *dataStop() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATASTOP);
  }
  /// Rectangular annotation limits, specified in pixels, as an array of arrays of the coordinates [ [UL1x, UL1y], [UR1x, UR1y], [LR1x, LR1y], [LL1x, LL1y] ], indicating the corners of a rectangle beginning with the Upper Left (UL) and moving clockwise. Allows the image provider to highlight one or more rectangular area(s) of interest. The array must contain Nx4 two-element arrays, where N is the number of rectangles of interest.  The associated annotation(s) should be included in the annText array.
  /// Example: /// Example: [[1, 1], [1, 2], [1, 3], [1, 4]]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *annLims() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ANNLIMS);
  }
  /// Annotation text, a string array of annotation(s) corresponding to the rectangular areas specified in annLims.  This array contains the annotation text associated with the areas of interest indicated in annLims, in order.  This array should contain one annotation per four values of the area (annLims) array.
  /// Example: /// Example: ['rec1', 'rec2']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *annText() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ANNTEXT);
  }
  /// Array of searchable keywords for this analytic imagery record.
  /// Example: /// Example: ['Key1', 'Key2']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *keywords() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_KEYWORDS);
  }
  /// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
  /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *area() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AREA);
  }
  /// Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
  /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *atext() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATEXT);
  }
  /// Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
  /// Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *agjson() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AGJSON);
  }
  /// Type of region as projected on the ground.
  /// Example: /// Example: POLYGON
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *atype() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATYPE);
  }
  /// Number of dimensions of the geometry depicted by region.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t andims() const {
    return GetField<int32_t>(VT_ANDIMS, 0);
  }
  /// Geographical spatial_ref_sys for region.
  /// Example: /// Example: 4326
  /// Constraints: No constraints specified.
  int32_t asrid() const {
    return GetField<int32_t>(VT_ASRID, 0);
  }
  /// Assessed satellite ID (NORAD RSO object number).  The 'satId' and 'satIdConf' arrays must match in size.
  /// Example: /// Example: [12004, 12005]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *satId() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SATID);
  }
  /// Assessed satellite confidence corresponding to an assessment ID.  Values are between 0.0 and 1.0.  The 'satId' and 'satIdConf' arrays must match in size.
  /// Example: /// Example: [0.98, 0.22]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *satIdConf() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SATIDCONF);
  }
  /// Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this image. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
  /// Example: /// Example: ['MTI', 'POI']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *srcTyps() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SRCTYPS);
  }
  /// Array of UUIDs of the UDL data records that are related to this image. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
  /// Example: /// Example: ['DOA_ID', 'DWELL_ID']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *srcIds() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SRCIDS);
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['TAG1', 'TAG2']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TAGS);
  }
  /// MD5 checksum value of the file. The ingest/create operation will automatically generate the value.
  /// Example: /// Example: 123
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *checksumValue() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHECKSUMVALUE);
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: a7bdef1f-5a4f-4716-bee4-7a1e0ec7d35a
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *transactionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSACTIONID);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: ORIGIN
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: TST1
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *sourceDL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEDL);
  }
  /// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  AnalyticImagery_Ingest_dataMode_Enum dataMode() const {
    return static_cast<AnalyticImagery_Ingest_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           VerifyOffset(verifier, VT_MSGTIME) &&
           verifier.VerifyString(msgTime()) &&
           VerifyOffset(verifier, VT_IMAGETYPE) &&
           verifier.VerifyString(imageType()) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<int64_t>(verifier, VT_FILESIZE, 8) &&
           VerifyField<int32_t>(verifier, VT_IMGWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_IMGHEIGHT, 4) &&
           VerifyOffset(verifier, VT_XUNITS) &&
           verifier.VerifyString(xUnits()) &&
           VerifyOffset(verifier, VT_YUNITS) &&
           verifier.VerifyString(yUnits()) &&
           VerifyOffset(verifier, VT_ZUNITS) &&
           verifier.VerifyString(zUnits()) &&
           VerifyOffset(verifier, VT_IMAGESETID) &&
           verifier.VerifyString(imageSetId()) &&
           VerifyField<int32_t>(verifier, VT_IMAGESETLENGTH, 4) &&
           VerifyField<int32_t>(verifier, VT_SEQUENCEID, 4) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_DATASTART) &&
           verifier.VerifyString(dataStart()) &&
           VerifyOffset(verifier, VT_DATASTOP) &&
           verifier.VerifyString(dataStop()) &&
           VerifyOffset(verifier, VT_ANNLIMS) &&
           verifier.VerifyVector(annLims()) &&
           verifier.VerifyVectorOfStrings(annLims()) &&
           VerifyOffset(verifier, VT_ANNTEXT) &&
           verifier.VerifyVector(annText()) &&
           verifier.VerifyVectorOfStrings(annText()) &&
           VerifyOffset(verifier, VT_KEYWORDS) &&
           verifier.VerifyVector(keywords()) &&
           verifier.VerifyVectorOfStrings(keywords()) &&
           VerifyOffset(verifier, VT_AREA) &&
           verifier.VerifyString(area()) &&
           VerifyOffset(verifier, VT_ATEXT) &&
           verifier.VerifyString(atext()) &&
           VerifyOffset(verifier, VT_AGJSON) &&
           verifier.VerifyString(agjson()) &&
           VerifyOffset(verifier, VT_ATYPE) &&
           verifier.VerifyString(atype()) &&
           VerifyField<int32_t>(verifier, VT_ANDIMS, 4) &&
           VerifyField<int32_t>(verifier, VT_ASRID, 4) &&
           VerifyOffset(verifier, VT_SATID) &&
           verifier.VerifyVector(satId()) &&
           verifier.VerifyVectorOfStrings(satId()) &&
           VerifyOffset(verifier, VT_SATIDCONF) &&
           verifier.VerifyVector(satIdConf()) &&
           verifier.VerifyVectorOfStrings(satIdConf()) &&
           VerifyOffset(verifier, VT_SRCTYPS) &&
           verifier.VerifyVector(srcTyps()) &&
           verifier.VerifyVectorOfStrings(srcTyps()) &&
           VerifyOffset(verifier, VT_SRCIDS) &&
           verifier.VerifyVector(srcIds()) &&
           verifier.VerifyVectorOfStrings(srcIds()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyOffset(verifier, VT_CHECKSUMVALUE) &&
           verifier.VerifyString(checksumValue()) &&
           VerifyOffset(verifier, VT_TRANSACTIONID) &&
           verifier.VerifyString(transactionId()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyOffset(verifier, VT_SOURCEDL) &&
           verifier.VerifyString(sourceDL()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           verifier.EndTable();
  }
};

struct AnalyticImagery_IngestBuilder {
  typedef AnalyticImagery_Ingest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::String> content) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_CONTENT, content);
  }
  void add_msgTime(::flatbuffers::Offset<::flatbuffers::String> msgTime) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_MSGTIME, msgTime);
  }
  void add_imageType(::flatbuffers::Offset<::flatbuffers::String> imageType) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_IMAGETYPE, imageType);
  }
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_FILENAME, filename);
  }
  void add_filesize(int64_t filesize) {
    fbb_.AddElement<int64_t>(AnalyticImagery_Ingest::VT_FILESIZE, filesize, 0);
  }
  void add_imgWidth(int32_t imgWidth) {
    fbb_.AddElement<int32_t>(AnalyticImagery_Ingest::VT_IMGWIDTH, imgWidth, 0);
  }
  void add_imgHeight(int32_t imgHeight) {
    fbb_.AddElement<int32_t>(AnalyticImagery_Ingest::VT_IMGHEIGHT, imgHeight, 0);
  }
  void add_xUnits(::flatbuffers::Offset<::flatbuffers::String> xUnits) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_XUNITS, xUnits);
  }
  void add_yUnits(::flatbuffers::Offset<::flatbuffers::String> yUnits) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_YUNITS, yUnits);
  }
  void add_zUnits(::flatbuffers::Offset<::flatbuffers::String> zUnits) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_ZUNITS, zUnits);
  }
  void add_imageSetId(::flatbuffers::Offset<::flatbuffers::String> imageSetId) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_IMAGESETID, imageSetId);
  }
  void add_imageSetLength(int32_t imageSetLength) {
    fbb_.AddElement<int32_t>(AnalyticImagery_Ingest::VT_IMAGESETLENGTH, imageSetLength, 0);
  }
  void add_sequenceId(int32_t sequenceId) {
    fbb_.AddElement<int32_t>(AnalyticImagery_Ingest::VT_SEQUENCEID, sequenceId, 0);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_DESCRIPTION, description);
  }
  void add_dataStart(::flatbuffers::Offset<::flatbuffers::String> dataStart) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_DATASTART, dataStart);
  }
  void add_dataStop(::flatbuffers::Offset<::flatbuffers::String> dataStop) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_DATASTOP, dataStop);
  }
  void add_annLims(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> annLims) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_ANNLIMS, annLims);
  }
  void add_annText(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> annText) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_ANNTEXT, annText);
  }
  void add_keywords(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> keywords) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_KEYWORDS, keywords);
  }
  void add_area(::flatbuffers::Offset<::flatbuffers::String> area) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_AREA, area);
  }
  void add_atext(::flatbuffers::Offset<::flatbuffers::String> atext) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_ATEXT, atext);
  }
  void add_agjson(::flatbuffers::Offset<::flatbuffers::String> agjson) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_AGJSON, agjson);
  }
  void add_atype(::flatbuffers::Offset<::flatbuffers::String> atype) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_ATYPE, atype);
  }
  void add_andims(int32_t andims) {
    fbb_.AddElement<int32_t>(AnalyticImagery_Ingest::VT_ANDIMS, andims, 0);
  }
  void add_asrid(int32_t asrid) {
    fbb_.AddElement<int32_t>(AnalyticImagery_Ingest::VT_ASRID, asrid, 0);
  }
  void add_satId(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> satId) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_SATID, satId);
  }
  void add_satIdConf(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> satIdConf) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_SATIDCONF, satIdConf);
  }
  void add_srcTyps(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcTyps) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_SRCTYPS, srcTyps);
  }
  void add_srcIds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcIds) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_SRCIDS, srcIds);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_TAGS, tags);
  }
  void add_checksumValue(::flatbuffers::Offset<::flatbuffers::String> checksumValue) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_CHECKSUMVALUE, checksumValue);
  }
  void add_transactionId(::flatbuffers::Offset<::flatbuffers::String> transactionId) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_TRANSACTIONID, transactionId);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  void add_sourceDL(::flatbuffers::Offset<::flatbuffers::String> sourceDL) {
    fbb_.AddOffset(AnalyticImagery_Ingest::VT_SOURCEDL, sourceDL);
  }
  void add_dataMode(AnalyticImagery_Ingest_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(AnalyticImagery_Ingest::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  explicit AnalyticImagery_IngestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnalyticImagery_Ingest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnalyticImagery_Ingest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnalyticImagery_Ingest> CreateAnalyticImagery_Ingest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> content = 0,
    ::flatbuffers::Offset<::flatbuffers::String> msgTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> imageType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    int64_t filesize = 0,
    int32_t imgWidth = 0,
    int32_t imgHeight = 0,
    ::flatbuffers::Offset<::flatbuffers::String> xUnits = 0,
    ::flatbuffers::Offset<::flatbuffers::String> yUnits = 0,
    ::flatbuffers::Offset<::flatbuffers::String> zUnits = 0,
    ::flatbuffers::Offset<::flatbuffers::String> imageSetId = 0,
    int32_t imageSetLength = 0,
    int32_t sequenceId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dataStart = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dataStop = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> annLims = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> annText = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> keywords = 0,
    ::flatbuffers::Offset<::flatbuffers::String> area = 0,
    ::flatbuffers::Offset<::flatbuffers::String> atext = 0,
    ::flatbuffers::Offset<::flatbuffers::String> agjson = 0,
    ::flatbuffers::Offset<::flatbuffers::String> atype = 0,
    int32_t andims = 0,
    int32_t asrid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> satId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> satIdConf = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcTyps = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcIds = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> checksumValue = 0,
    ::flatbuffers::Offset<::flatbuffers::String> transactionId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceDL = 0,
    AnalyticImagery_Ingest_dataMode_Enum dataMode = AnalyticImagery_Ingest_dataMode_Enum_REAL) {
  AnalyticImagery_IngestBuilder builder_(_fbb);
  builder_.add_filesize(filesize);
  builder_.add_sourceDL(sourceDL);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_transactionId(transactionId);
  builder_.add_checksumValue(checksumValue);
  builder_.add_tags(tags);
  builder_.add_srcIds(srcIds);
  builder_.add_srcTyps(srcTyps);
  builder_.add_satIdConf(satIdConf);
  builder_.add_satId(satId);
  builder_.add_asrid(asrid);
  builder_.add_andims(andims);
  builder_.add_atype(atype);
  builder_.add_agjson(agjson);
  builder_.add_atext(atext);
  builder_.add_area(area);
  builder_.add_keywords(keywords);
  builder_.add_annText(annText);
  builder_.add_annLims(annLims);
  builder_.add_dataStop(dataStop);
  builder_.add_dataStart(dataStart);
  builder_.add_description(description);
  builder_.add_sequenceId(sequenceId);
  builder_.add_imageSetLength(imageSetLength);
  builder_.add_imageSetId(imageSetId);
  builder_.add_zUnits(zUnits);
  builder_.add_yUnits(yUnits);
  builder_.add_xUnits(xUnits);
  builder_.add_imgHeight(imgHeight);
  builder_.add_imgWidth(imgWidth);
  builder_.add_filename(filename);
  builder_.add_imageType(imageType);
  builder_.add_msgTime(msgTime);
  builder_.add_content(content);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AnalyticImagery_Ingest> CreateAnalyticImagery_IngestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *content = nullptr,
    const char *msgTime = nullptr,
    const char *imageType = nullptr,
    const char *filename = nullptr,
    int64_t filesize = 0,
    int32_t imgWidth = 0,
    int32_t imgHeight = 0,
    const char *xUnits = nullptr,
    const char *yUnits = nullptr,
    const char *zUnits = nullptr,
    const char *imageSetId = nullptr,
    int32_t imageSetLength = 0,
    int32_t sequenceId = 0,
    const char *description = nullptr,
    const char *dataStart = nullptr,
    const char *dataStop = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *annLims = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *annText = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *keywords = nullptr,
    const char *area = nullptr,
    const char *atext = nullptr,
    const char *agjson = nullptr,
    const char *atype = nullptr,
    int32_t andims = 0,
    int32_t asrid = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *satId = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *satIdConf = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *srcTyps = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *srcIds = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tags = nullptr,
    const char *checksumValue = nullptr,
    const char *transactionId = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr,
    const char *sourceDL = nullptr,
    AnalyticImagery_Ingest_dataMode_Enum dataMode = AnalyticImagery_Ingest_dataMode_Enum_REAL) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto content__ = content ? _fbb.CreateString(content) : 0;
  auto msgTime__ = msgTime ? _fbb.CreateString(msgTime) : 0;
  auto imageType__ = imageType ? _fbb.CreateString(imageType) : 0;
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  auto xUnits__ = xUnits ? _fbb.CreateString(xUnits) : 0;
  auto yUnits__ = yUnits ? _fbb.CreateString(yUnits) : 0;
  auto zUnits__ = zUnits ? _fbb.CreateString(zUnits) : 0;
  auto imageSetId__ = imageSetId ? _fbb.CreateString(imageSetId) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto dataStart__ = dataStart ? _fbb.CreateString(dataStart) : 0;
  auto dataStop__ = dataStop ? _fbb.CreateString(dataStop) : 0;
  auto annLims__ = annLims ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*annLims) : 0;
  auto annText__ = annText ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*annText) : 0;
  auto keywords__ = keywords ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*keywords) : 0;
  auto area__ = area ? _fbb.CreateString(area) : 0;
  auto atext__ = atext ? _fbb.CreateString(atext) : 0;
  auto agjson__ = agjson ? _fbb.CreateString(agjson) : 0;
  auto atype__ = atype ? _fbb.CreateString(atype) : 0;
  auto satId__ = satId ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*satId) : 0;
  auto satIdConf__ = satIdConf ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*satIdConf) : 0;
  auto srcTyps__ = srcTyps ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*srcTyps) : 0;
  auto srcIds__ = srcIds ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*srcIds) : 0;
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tags) : 0;
  auto checksumValue__ = checksumValue ? _fbb.CreateString(checksumValue) : 0;
  auto transactionId__ = transactionId ? _fbb.CreateString(transactionId) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto sourceDL__ = sourceDL ? _fbb.CreateString(sourceDL) : 0;
  return CreateAnalyticImagery_Ingest(
      _fbb,
      id__,
      classificationMarking__,
      content__,
      msgTime__,
      imageType__,
      filename__,
      filesize,
      imgWidth,
      imgHeight,
      xUnits__,
      yUnits__,
      zUnits__,
      imageSetId__,
      imageSetLength,
      sequenceId,
      description__,
      dataStart__,
      dataStop__,
      annLims__,
      annText__,
      keywords__,
      area__,
      atext__,
      agjson__,
      atype__,
      andims,
      asrid,
      satId__,
      satIdConf__,
      srcTyps__,
      srcIds__,
      tags__,
      checksumValue__,
      transactionId__,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      origNetwork__,
      sourceDL__,
      dataMode);
}

inline const AnalyticImagery_Ingest *GetAnalyticImagery_Ingest(const void *buf) {
  return ::flatbuffers::GetRoot<AnalyticImagery_Ingest>(buf);
}

inline const AnalyticImagery_Ingest *GetSizePrefixedAnalyticImagery_Ingest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<AnalyticImagery_Ingest>(buf);
}

inline const char *AnalyticImagery_IngestIdentifier() {
  return "ANAL";
}

inline bool AnalyticImagery_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AnalyticImagery_IngestIdentifier());
}

inline bool SizePrefixedAnalyticImagery_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AnalyticImagery_IngestIdentifier(), true);
}

inline bool VerifyAnalyticImagery_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AnalyticImagery_Ingest>(AnalyticImagery_IngestIdentifier());
}

inline bool VerifySizePrefixedAnalyticImagery_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AnalyticImagery_Ingest>(AnalyticImagery_IngestIdentifier());
}

inline void FinishAnalyticImagery_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AnalyticImagery_Ingest> root) {
  fbb.Finish(root, AnalyticImagery_IngestIdentifier());
}

inline void FinishSizePrefixedAnalyticImagery_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AnalyticImagery_Ingest> root) {
  fbb.FinishSizePrefixed(root, AnalyticImagery_IngestIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
