// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct MissileTrackVector_Ingest;
struct MissileTrackVector_IngestBuilder;

/// /// Schema for Missile Track Vector data.
struct MissileTrackVector_Ingest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MissileTrackVector_IngestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_OBJECT = 6,
    VT_EPOCH = 8,
    VT_IDSENSOR = 10,
    VT_ORIGSENSORID = 12,
    VT_POS = 14,
    VT_VEL = 16,
    VT_ACCEL = 18,
    VT_COURSE = 20,
    VT_SPD = 22,
    VT_REFERENCEFRAME = 24,
    VT_COV = 26,
    VT_COVREFERENCEFRAME = 28,
    VT_VECTORLAT = 30,
    VT_VECTORLON = 32,
    VT_VECTORALT = 34,
    VT_CONFIDENCE = 36,
    VT_STATUS = 38,
    VT_TIMESOURCE = 40,
    VT_QUAT = 42,
    VT_FLIGHTAZ = 44
  };
  /// Type of vector represented (e.g. LOS, PREDICTED, STATE).
  /// Example: /// Example: STATE
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Object to which this vector applies.
  /// Example: /// Example: TARGET
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *object() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT);
  }
  /// Vector timestamp in ISO8601 UTC format, with microsecond precision.
  /// Example: /// Example: 2024-03-30T15:02:39.346768Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *epoch() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPOCH);
  }
  /// Unique identifier of the reporting sensor of the object.
  /// Example: /// Example: a7e99418-b6d6-29ab-e767-440a989cce26
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR);
  }
  /// Optional identifier provided by the source to indicate the reporting sensor of the object. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 46
  const ::flatbuffers::String *origSensorId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGSENSORID);
  }
  /// Three element array, expressing the cartesian position vector of the target object, in kilometers, in the specified referenceFrame. If referenceFrame is null then ECEF should be assumed. The array element order is [x, y, z].
  /// Example: /// Example: [-1456.91592, -2883.54041, 6165.55186]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *pos() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_POS);
  }
  /// Three element array, expressing the cartesian velocity vector of the target object, in kilometers/second, in the specified referenceFrame. If referenceFrame is null then ECEF should be assumed. The array element order is [x', y', z'].
  /// Example: /// Example: [-1.21981, -6.60208, -3.36515]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *vel() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VEL);
  }
  /// Three element array, expressing the cartesian acceleration vector of the target object, in kilometers/second^2, in the specified referenceFrame. If referenceFrame is null then ECEF should be assumed. The array element order is [x'', y'', z''].
  /// Example: /// Example: [0.59236, -0.03537, 0.35675]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *accel() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ACCEL);
  }
  /// Track object course, in degrees clockwise from true north.
  /// Example: /// Example: 7.3580153
  /// Constraints: No constraints specified.
  double course() const {
    return GetField<double>(VT_COURSE, 0.0);
  }
  /// Track object speed, in kilometers/sec.
  /// Example: /// Example: 15.03443
  /// Constraints: No constraints specified.
  double spd() const {
    return GetField<double>(VT_SPD, 0.0);
  }
  /// The reference frame of the cartesian vector (ECEF, J2000). If the referenceFrame is null it is assumed to be ECEF.
  /// Example: /// Example: ECEF
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *referenceFrame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFERENCEFRAME);
  }
  /// Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.
  /// If the covReferenceFrame is null it is assumed to be UVW. The array values (1-45) represent the upper triangular half of the position-velocity-acceleration covariance matrix.
  /// The covariance elements are position dependent within the array with values ordered as follows:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x"&nbsp;&nbsp;&nbsp;&nbsp;y"&nbsp;&nbsp;&nbsp;&nbsp;z"
  /// x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9
  /// y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;14&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;&nbsp;17
  /// z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;&nbsp;23&nbsp;&nbsp;&nbsp;24
  /// x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;26&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;&nbsp;30
  /// y'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;31&nbsp;&nbsp;&nbsp;32&nbsp;&nbsp;&nbsp;33&nbsp;&nbsp;&nbsp;34&nbsp;&nbsp;&nbsp;35
  /// z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;&nbsp;38&nbsp;&nbsp;&nbsp;39
  /// x"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;42
  /// y"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;44
  /// z"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45
  /// The cov array should contain only the upper right triangle values from top left down to bottom right, in order.
  /// Example: /// Example: [1.1, 2.2, 3.3]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *cov() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COV);
  }
  /// The reference frame of the covariance elements (ECEF, J2000, UVW). If the referenceFrame is null it is assumed to be UVW.
  /// Example: /// Example: ECEF
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *covReferenceFrame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COVREFERENCEFRAME);
  }
  /// WGS-84 object latitude subpoint at epoch, represented as -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.0
  /// Constraints: No constraints specified.
  double vectorLat() const {
    return GetField<double>(VT_VECTORLAT, 0.0);
  }
  /// WGS-84 object longitude subpoint at epoch, represented as -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 150.0
  /// Constraints: No constraints specified.
  double vectorLon() const {
    return GetField<double>(VT_VECTORLON, 0.0);
  }
  /// Object altitude at epoch, expressed in kilometers above WGS-84 ellipsoid.
  /// Example: /// Example: 25.0
  /// Constraints: No constraints specified.
  double vectorAlt() const {
    return GetField<double>(VT_VECTORALT, 0.0);
  }
  /// Confidence of the vector, 0-100.
  /// Example: /// Example: 100
  /// Constraints: No constraints specified.
  int32_t confidence() const {
    return GetField<int32_t>(VT_CONFIDENCE, 0);
  }
  /// Status of the vector (e.g. INITIAL, UPDATE).
  /// Example: /// Example: INITIAL
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  /// Source of the time value.
  /// Example: /// Example: Sensor 1
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *timeSource() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIMESOURCE);
  }
  /// The quaternion describing the attitude of the spacecraft with respect to the reference frame listed in the 'referenceFrame' field. The array element order convention is the three vector components, followed by the scalar component.
  /// Example: /// Example: [0.03, 0.02, 0.01, 0.012]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *quat() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_QUAT);
  }
  /// The flight azimuth associated with the current state vector (0-360 degrees).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  double flightAz() const {
    return GetField<double>(VT_FLIGHTAZ, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           verifier.VerifyString(object()) &&
           VerifyOffset(verifier, VT_EPOCH) &&
           verifier.VerifyString(epoch()) &&
           VerifyOffset(verifier, VT_IDSENSOR) &&
           verifier.VerifyString(idSensor()) &&
           VerifyOffset(verifier, VT_ORIGSENSORID) &&
           verifier.VerifyString(origSensorId()) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyVector(pos()) &&
           verifier.VerifyVectorOfStrings(pos()) &&
           VerifyOffset(verifier, VT_VEL) &&
           verifier.VerifyVector(vel()) &&
           verifier.VerifyVectorOfStrings(vel()) &&
           VerifyOffset(verifier, VT_ACCEL) &&
           verifier.VerifyVector(accel()) &&
           verifier.VerifyVectorOfStrings(accel()) &&
           VerifyField<double>(verifier, VT_COURSE, 8) &&
           VerifyField<double>(verifier, VT_SPD, 8) &&
           VerifyOffset(verifier, VT_REFERENCEFRAME) &&
           verifier.VerifyString(referenceFrame()) &&
           VerifyOffset(verifier, VT_COV) &&
           verifier.VerifyVector(cov()) &&
           verifier.VerifyVectorOfStrings(cov()) &&
           VerifyOffset(verifier, VT_COVREFERENCEFRAME) &&
           verifier.VerifyString(covReferenceFrame()) &&
           VerifyField<double>(verifier, VT_VECTORLAT, 8) &&
           VerifyField<double>(verifier, VT_VECTORLON, 8) &&
           VerifyField<double>(verifier, VT_VECTORALT, 8) &&
           VerifyField<int32_t>(verifier, VT_CONFIDENCE, 4) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyOffset(verifier, VT_TIMESOURCE) &&
           verifier.VerifyString(timeSource()) &&
           VerifyOffset(verifier, VT_QUAT) &&
           verifier.VerifyVector(quat()) &&
           verifier.VerifyVectorOfStrings(quat()) &&
           VerifyField<double>(verifier, VT_FLIGHTAZ, 8) &&
           verifier.EndTable();
  }
};

struct MissileTrackVector_IngestBuilder {
  typedef MissileTrackVector_Ingest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_TYPE, type);
  }
  void add_object(::flatbuffers::Offset<::flatbuffers::String> object) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_OBJECT, object);
  }
  void add_epoch(::flatbuffers::Offset<::flatbuffers::String> epoch) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_EPOCH, epoch);
  }
  void add_idSensor(::flatbuffers::Offset<::flatbuffers::String> idSensor) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_IDSENSOR, idSensor);
  }
  void add_origSensorId(::flatbuffers::Offset<::flatbuffers::String> origSensorId) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_ORIGSENSORID, origSensorId);
  }
  void add_pos(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> pos) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_POS, pos);
  }
  void add_vel(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> vel) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_VEL, vel);
  }
  void add_accel(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> accel) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_ACCEL, accel);
  }
  void add_course(double course) {
    fbb_.AddElement<double>(MissileTrackVector_Ingest::VT_COURSE, course, 0.0);
  }
  void add_spd(double spd) {
    fbb_.AddElement<double>(MissileTrackVector_Ingest::VT_SPD, spd, 0.0);
  }
  void add_referenceFrame(::flatbuffers::Offset<::flatbuffers::String> referenceFrame) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_REFERENCEFRAME, referenceFrame);
  }
  void add_cov(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cov) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_COV, cov);
  }
  void add_covReferenceFrame(::flatbuffers::Offset<::flatbuffers::String> covReferenceFrame) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_COVREFERENCEFRAME, covReferenceFrame);
  }
  void add_vectorLat(double vectorLat) {
    fbb_.AddElement<double>(MissileTrackVector_Ingest::VT_VECTORLAT, vectorLat, 0.0);
  }
  void add_vectorLon(double vectorLon) {
    fbb_.AddElement<double>(MissileTrackVector_Ingest::VT_VECTORLON, vectorLon, 0.0);
  }
  void add_vectorAlt(double vectorAlt) {
    fbb_.AddElement<double>(MissileTrackVector_Ingest::VT_VECTORALT, vectorAlt, 0.0);
  }
  void add_confidence(int32_t confidence) {
    fbb_.AddElement<int32_t>(MissileTrackVector_Ingest::VT_CONFIDENCE, confidence, 0);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_STATUS, status);
  }
  void add_timeSource(::flatbuffers::Offset<::flatbuffers::String> timeSource) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_TIMESOURCE, timeSource);
  }
  void add_quat(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> quat) {
    fbb_.AddOffset(MissileTrackVector_Ingest::VT_QUAT, quat);
  }
  void add_flightAz(double flightAz) {
    fbb_.AddElement<double>(MissileTrackVector_Ingest::VT_FLIGHTAZ, flightAz, 0.0);
  }
  explicit MissileTrackVector_IngestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MissileTrackVector_Ingest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MissileTrackVector_Ingest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MissileTrackVector_Ingest> CreateMissileTrackVector_Ingest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> object = 0,
    ::flatbuffers::Offset<::flatbuffers::String> epoch = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origSensorId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> pos = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> vel = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> accel = 0,
    double course = 0.0,
    double spd = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> referenceFrame = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cov = 0,
    ::flatbuffers::Offset<::flatbuffers::String> covReferenceFrame = 0,
    double vectorLat = 0.0,
    double vectorLon = 0.0,
    double vectorAlt = 0.0,
    int32_t confidence = 0,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    ::flatbuffers::Offset<::flatbuffers::String> timeSource = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> quat = 0,
    double flightAz = 0.0) {
  MissileTrackVector_IngestBuilder builder_(_fbb);
  builder_.add_flightAz(flightAz);
  builder_.add_vectorAlt(vectorAlt);
  builder_.add_vectorLon(vectorLon);
  builder_.add_vectorLat(vectorLat);
  builder_.add_spd(spd);
  builder_.add_course(course);
  builder_.add_quat(quat);
  builder_.add_timeSource(timeSource);
  builder_.add_status(status);
  builder_.add_confidence(confidence);
  builder_.add_covReferenceFrame(covReferenceFrame);
  builder_.add_cov(cov);
  builder_.add_referenceFrame(referenceFrame);
  builder_.add_accel(accel);
  builder_.add_vel(vel);
  builder_.add_pos(pos);
  builder_.add_origSensorId(origSensorId);
  builder_.add_idSensor(idSensor);
  builder_.add_epoch(epoch);
  builder_.add_object(object);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MissileTrackVector_Ingest> CreateMissileTrackVector_IngestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *object = nullptr,
    const char *epoch = nullptr,
    const char *idSensor = nullptr,
    const char *origSensorId = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *pos = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *vel = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *accel = nullptr,
    double course = 0.0,
    double spd = 0.0,
    const char *referenceFrame = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *cov = nullptr,
    const char *covReferenceFrame = nullptr,
    double vectorLat = 0.0,
    double vectorLon = 0.0,
    double vectorAlt = 0.0,
    int32_t confidence = 0,
    const char *status = nullptr,
    const char *timeSource = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *quat = nullptr,
    double flightAz = 0.0) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto object__ = object ? _fbb.CreateString(object) : 0;
  auto epoch__ = epoch ? _fbb.CreateString(epoch) : 0;
  auto idSensor__ = idSensor ? _fbb.CreateString(idSensor) : 0;
  auto origSensorId__ = origSensorId ? _fbb.CreateString(origSensorId) : 0;
  auto pos__ = pos ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*pos) : 0;
  auto vel__ = vel ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*vel) : 0;
  auto accel__ = accel ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*accel) : 0;
  auto referenceFrame__ = referenceFrame ? _fbb.CreateString(referenceFrame) : 0;
  auto cov__ = cov ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*cov) : 0;
  auto covReferenceFrame__ = covReferenceFrame ? _fbb.CreateString(covReferenceFrame) : 0;
  auto status__ = status ? _fbb.CreateString(status) : 0;
  auto timeSource__ = timeSource ? _fbb.CreateString(timeSource) : 0;
  auto quat__ = quat ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*quat) : 0;
  return CreateMissileTrackVector_Ingest(
      _fbb,
      type__,
      object__,
      epoch__,
      idSensor__,
      origSensorId__,
      pos__,
      vel__,
      accel__,
      course,
      spd,
      referenceFrame__,
      cov__,
      covReferenceFrame__,
      vectorLat,
      vectorLon,
      vectorAlt,
      confidence,
      status__,
      timeSource__,
      quat__,
      flightAz);
}

inline const MissileTrackVector_Ingest *GetMissileTrackVector_Ingest(const void *buf) {
  return ::flatbuffers::GetRoot<MissileTrackVector_Ingest>(buf);
}

inline const MissileTrackVector_Ingest *GetSizePrefixedMissileTrackVector_Ingest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MissileTrackVector_Ingest>(buf);
}

inline const char *MissileTrackVector_IngestIdentifier() {
  return "MISS";
}

inline bool MissileTrackVector_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MissileTrackVector_IngestIdentifier());
}

inline bool SizePrefixedMissileTrackVector_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MissileTrackVector_IngestIdentifier(), true);
}

inline bool VerifyMissileTrackVector_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MissileTrackVector_Ingest>(MissileTrackVector_IngestIdentifier());
}

inline bool VerifySizePrefixedMissileTrackVector_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MissileTrackVector_Ingest>(MissileTrackVector_IngestIdentifier());
}

inline void FinishMissileTrackVector_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MissileTrackVector_Ingest> root) {
  fbb.Finish(root, MissileTrackVector_IngestIdentifier());
}

inline void FinishSizePrefixedMissileTrackVector_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MissileTrackVector_Ingest> root) {
  fbb.FinishSizePrefixed(root, MissileTrackVector_IngestIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
