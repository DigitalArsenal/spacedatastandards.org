// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct LogisticsSegments_Full;
struct LogisticsSegments_FullBuilder;

/// /// Remarks associated with this LogisticsSupport record.
struct LogisticsSegments_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogisticsSegments_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENTNUMBER = 4,
    VT_MODECODE = 6,
    VT_MISSIONTYPE = 8,
    VT_IDMISSION = 10,
    VT_EXTMISSIONID = 12,
    VT_MISSIONNUMBER = 14,
    VT_ITIN = 16,
    VT_SEGTAILNUMBER = 18,
    VT_SEGAIRCRAFTMDS = 20,
    VT_DEPARTUREICAO = 22,
    VT_SEGACTDEPTIME = 24,
    VT_ARRIVALICAO = 26,
    VT_SEGACTARRTIME = 28,
    VT_SEGESTDEPTIME = 30,
    VT_SEGESTARRTIME = 32
  };
  /// Used to sequence the segments in the transportation plan.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  int32_t segmentNumber() const {
    return GetField<int32_t>(VT_SEGMENTNUMBER, 0);
  }
  /// Transportation mode.  AMC airlift, Commercial airlift, Other, or surface transportation.
  /// Example: /// Example: A
  /// Constraints: Minimum length = 1, Maximum length = 1
  const ::flatbuffers::String *modeCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODECODE);
  }
  /// The type of mission (e.g. SAAM, CHNL, etc.).
  /// Example: /// Example: SAAM
  /// Constraints: Minimum length = 0, Maximum length = 6
  const ::flatbuffers::String *missionType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MISSIONTYPE);
  }
  /// The unique identifier of the mission to which this logistics record is assigned.
  /// Example: /// Example: EXAMPLE-UUID
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *idMission() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDMISSION);
  }
  /// The GDSS mission ID for this segment.
  /// Example: /// Example: 2001101RF01202307062205
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *extMissionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTMISSIONID);
  }
  /// The user generated identifier for an air mission subgroup.
  /// Example: /// Example: TAM308901196
  /// Constraints: Minimum length = 0, Maximum length = 12
  const ::flatbuffers::String *missionNumber() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MISSIONNUMBER);
  }
  /// Start air mission itinerary point identifier.
  /// Example: /// Example: 200
  /// Constraints: No constraints specified.
  int32_t itin() const {
    return GetField<int32_t>(VT_ITIN, 0);
  }
  /// The identifier that represents a specific aircraft within an aircraft type.
  /// Example: /// Example: N819AX
  /// Constraints: Minimum length = 0, Maximum length = 7
  const ::flatbuffers::String *segTailNumber() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEGTAILNUMBER);
  }
  /// The aircraft Model Design Series (MDS) designation (e.g. E-2C HAWKEYE, F-15 EAGLE, KC-130 HERCULES, etc.) of this aircraft. Intended as, but not constrained to, MIL-STD-6016 environment dependent specific type designations.
  /// Example: /// Example: B7772E
  /// Constraints: Minimum length = 0, Maximum length = 30
  const ::flatbuffers::String *segAircraftMDS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEGAIRCRAFTMDS);
  }
  /// Airport ICAO departure code.
  /// Example: /// Example: PHIK
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *departureICAO() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEPARTUREICAO);
  }
  /// Actual departure time to the segment destination, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-17T19:20:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *segActDepTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEGACTDEPTIME);
  }
  /// Airport ICAO arrival code.
  /// Example: /// Example: YBCS
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *arrivalICAO() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARRIVALICAO);
  }
  /// Actual arrival time to segment destination, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-17T19:20:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *segActArrTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEGACTARRTIME);
  }
  /// GC. LGTPS_C_DT_EST_DEP.  GD2: Estimated departure time from the segment origin. Only supplied when the segment is not attached to a Mission, otherwise the ETD is derived from the Mission segment origin point. This datetime should be in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-17T19:20:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *segEstDepTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEGESTDEPTIME);
  }
  /// GC. LGTPS_C_DT_EST_ARR.  GD2: Estimated arrival time to the segment destination. Only supplied when the segment is not attached to a Mission, otherwise the ETA is derived from the Mission segment destination point. This datetime should be in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2023-07-17T19:20:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *segEstArrTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEGESTARRTIME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEGMENTNUMBER, 4) &&
           VerifyOffset(verifier, VT_MODECODE) &&
           verifier.VerifyString(modeCode()) &&
           VerifyOffset(verifier, VT_MISSIONTYPE) &&
           verifier.VerifyString(missionType()) &&
           VerifyOffset(verifier, VT_IDMISSION) &&
           verifier.VerifyString(idMission()) &&
           VerifyOffset(verifier, VT_EXTMISSIONID) &&
           verifier.VerifyString(extMissionId()) &&
           VerifyOffset(verifier, VT_MISSIONNUMBER) &&
           verifier.VerifyString(missionNumber()) &&
           VerifyField<int32_t>(verifier, VT_ITIN, 4) &&
           VerifyOffset(verifier, VT_SEGTAILNUMBER) &&
           verifier.VerifyString(segTailNumber()) &&
           VerifyOffset(verifier, VT_SEGAIRCRAFTMDS) &&
           verifier.VerifyString(segAircraftMDS()) &&
           VerifyOffset(verifier, VT_DEPARTUREICAO) &&
           verifier.VerifyString(departureICAO()) &&
           VerifyOffset(verifier, VT_SEGACTDEPTIME) &&
           verifier.VerifyString(segActDepTime()) &&
           VerifyOffset(verifier, VT_ARRIVALICAO) &&
           verifier.VerifyString(arrivalICAO()) &&
           VerifyOffset(verifier, VT_SEGACTARRTIME) &&
           verifier.VerifyString(segActArrTime()) &&
           VerifyOffset(verifier, VT_SEGESTDEPTIME) &&
           verifier.VerifyString(segEstDepTime()) &&
           VerifyOffset(verifier, VT_SEGESTARRTIME) &&
           verifier.VerifyString(segEstArrTime()) &&
           verifier.EndTable();
  }
};

struct LogisticsSegments_FullBuilder {
  typedef LogisticsSegments_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_segmentNumber(int32_t segmentNumber) {
    fbb_.AddElement<int32_t>(LogisticsSegments_Full::VT_SEGMENTNUMBER, segmentNumber, 0);
  }
  void add_modeCode(::flatbuffers::Offset<::flatbuffers::String> modeCode) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_MODECODE, modeCode);
  }
  void add_missionType(::flatbuffers::Offset<::flatbuffers::String> missionType) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_MISSIONTYPE, missionType);
  }
  void add_idMission(::flatbuffers::Offset<::flatbuffers::String> idMission) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_IDMISSION, idMission);
  }
  void add_extMissionId(::flatbuffers::Offset<::flatbuffers::String> extMissionId) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_EXTMISSIONID, extMissionId);
  }
  void add_missionNumber(::flatbuffers::Offset<::flatbuffers::String> missionNumber) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_MISSIONNUMBER, missionNumber);
  }
  void add_itin(int32_t itin) {
    fbb_.AddElement<int32_t>(LogisticsSegments_Full::VT_ITIN, itin, 0);
  }
  void add_segTailNumber(::flatbuffers::Offset<::flatbuffers::String> segTailNumber) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_SEGTAILNUMBER, segTailNumber);
  }
  void add_segAircraftMDS(::flatbuffers::Offset<::flatbuffers::String> segAircraftMDS) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_SEGAIRCRAFTMDS, segAircraftMDS);
  }
  void add_departureICAO(::flatbuffers::Offset<::flatbuffers::String> departureICAO) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_DEPARTUREICAO, departureICAO);
  }
  void add_segActDepTime(::flatbuffers::Offset<::flatbuffers::String> segActDepTime) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_SEGACTDEPTIME, segActDepTime);
  }
  void add_arrivalICAO(::flatbuffers::Offset<::flatbuffers::String> arrivalICAO) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_ARRIVALICAO, arrivalICAO);
  }
  void add_segActArrTime(::flatbuffers::Offset<::flatbuffers::String> segActArrTime) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_SEGACTARRTIME, segActArrTime);
  }
  void add_segEstDepTime(::flatbuffers::Offset<::flatbuffers::String> segEstDepTime) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_SEGESTDEPTIME, segEstDepTime);
  }
  void add_segEstArrTime(::flatbuffers::Offset<::flatbuffers::String> segEstArrTime) {
    fbb_.AddOffset(LogisticsSegments_Full::VT_SEGESTARRTIME, segEstArrTime);
  }
  explicit LogisticsSegments_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogisticsSegments_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogisticsSegments_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogisticsSegments_Full> CreateLogisticsSegments_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t segmentNumber = 0,
    ::flatbuffers::Offset<::flatbuffers::String> modeCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> missionType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idMission = 0,
    ::flatbuffers::Offset<::flatbuffers::String> extMissionId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> missionNumber = 0,
    int32_t itin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> segTailNumber = 0,
    ::flatbuffers::Offset<::flatbuffers::String> segAircraftMDS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> departureICAO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> segActDepTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> arrivalICAO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> segActArrTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> segEstDepTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> segEstArrTime = 0) {
  LogisticsSegments_FullBuilder builder_(_fbb);
  builder_.add_segEstArrTime(segEstArrTime);
  builder_.add_segEstDepTime(segEstDepTime);
  builder_.add_segActArrTime(segActArrTime);
  builder_.add_arrivalICAO(arrivalICAO);
  builder_.add_segActDepTime(segActDepTime);
  builder_.add_departureICAO(departureICAO);
  builder_.add_segAircraftMDS(segAircraftMDS);
  builder_.add_segTailNumber(segTailNumber);
  builder_.add_itin(itin);
  builder_.add_missionNumber(missionNumber);
  builder_.add_extMissionId(extMissionId);
  builder_.add_idMission(idMission);
  builder_.add_missionType(missionType);
  builder_.add_modeCode(modeCode);
  builder_.add_segmentNumber(segmentNumber);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LogisticsSegments_Full> CreateLogisticsSegments_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t segmentNumber = 0,
    const char *modeCode = nullptr,
    const char *missionType = nullptr,
    const char *idMission = nullptr,
    const char *extMissionId = nullptr,
    const char *missionNumber = nullptr,
    int32_t itin = 0,
    const char *segTailNumber = nullptr,
    const char *segAircraftMDS = nullptr,
    const char *departureICAO = nullptr,
    const char *segActDepTime = nullptr,
    const char *arrivalICAO = nullptr,
    const char *segActArrTime = nullptr,
    const char *segEstDepTime = nullptr,
    const char *segEstArrTime = nullptr) {
  auto modeCode__ = modeCode ? _fbb.CreateString(modeCode) : 0;
  auto missionType__ = missionType ? _fbb.CreateString(missionType) : 0;
  auto idMission__ = idMission ? _fbb.CreateString(idMission) : 0;
  auto extMissionId__ = extMissionId ? _fbb.CreateString(extMissionId) : 0;
  auto missionNumber__ = missionNumber ? _fbb.CreateString(missionNumber) : 0;
  auto segTailNumber__ = segTailNumber ? _fbb.CreateString(segTailNumber) : 0;
  auto segAircraftMDS__ = segAircraftMDS ? _fbb.CreateString(segAircraftMDS) : 0;
  auto departureICAO__ = departureICAO ? _fbb.CreateString(departureICAO) : 0;
  auto segActDepTime__ = segActDepTime ? _fbb.CreateString(segActDepTime) : 0;
  auto arrivalICAO__ = arrivalICAO ? _fbb.CreateString(arrivalICAO) : 0;
  auto segActArrTime__ = segActArrTime ? _fbb.CreateString(segActArrTime) : 0;
  auto segEstDepTime__ = segEstDepTime ? _fbb.CreateString(segEstDepTime) : 0;
  auto segEstArrTime__ = segEstArrTime ? _fbb.CreateString(segEstArrTime) : 0;
  return CreateLogisticsSegments_Full(
      _fbb,
      segmentNumber,
      modeCode__,
      missionType__,
      idMission__,
      extMissionId__,
      missionNumber__,
      itin,
      segTailNumber__,
      segAircraftMDS__,
      departureICAO__,
      segActDepTime__,
      arrivalICAO__,
      segActArrTime__,
      segEstDepTime__,
      segEstArrTime__);
}

inline const LogisticsSegments_Full *GetLogisticsSegments_Full(const void *buf) {
  return ::flatbuffers::GetRoot<LogisticsSegments_Full>(buf);
}

inline const LogisticsSegments_Full *GetSizePrefixedLogisticsSegments_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<LogisticsSegments_Full>(buf);
}

inline const char *LogisticsSegments_FullIdentifier() {
  return "LOGI";
}

inline bool LogisticsSegments_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, LogisticsSegments_FullIdentifier());
}

inline bool SizePrefixedLogisticsSegments_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, LogisticsSegments_FullIdentifier(), true);
}

inline bool VerifyLogisticsSegments_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<LogisticsSegments_Full>(LogisticsSegments_FullIdentifier());
}

inline bool VerifySizePrefixedLogisticsSegments_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<LogisticsSegments_Full>(LogisticsSegments_FullIdentifier());
}

inline void FinishLogisticsSegments_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LogisticsSegments_Full> root) {
  fbb.Finish(root, LogisticsSegments_FullIdentifier());
}

inline void FinishSizePrefixedLogisticsSegments_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LogisticsSegments_Full> root) {
  fbb.FinishSizePrefixed(root, LogisticsSegments_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
