// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct SiteStatus_Full;
struct SiteStatus_FullBuilder;

enum SiteStatus_Full_instStatus_Enum : int8_t {
  /// No description available.
  SiteStatus_Full_instStatus_Enum_FMC = 0,
  /// No description available.
  SiteStatus_Full_instStatus_Enum_PMC = 1,
  /// No description available.
  SiteStatus_Full_instStatus_Enum_NMC = 2,
  /// No description available.
  SiteStatus_Full_instStatus_Enum_UNK = 3,
  SiteStatus_Full_instStatus_Enum_MIN = SiteStatus_Full_instStatus_Enum_FMC,
  SiteStatus_Full_instStatus_Enum_MAX = SiteStatus_Full_instStatus_Enum_UNK
};

inline const SiteStatus_Full_instStatus_Enum (&EnumValuesSiteStatus_Full_instStatus_Enum())[4] {
  static const SiteStatus_Full_instStatus_Enum values[] = {
    SiteStatus_Full_instStatus_Enum_FMC,
    SiteStatus_Full_instStatus_Enum_PMC,
    SiteStatus_Full_instStatus_Enum_NMC,
    SiteStatus_Full_instStatus_Enum_UNK
  };
  return values;
}

inline const char * const *EnumNamesSiteStatus_Full_instStatus_Enum() {
  static const char * const names[5] = {
    "FMC",
    "PMC",
    "NMC",
    "UNK",
    nullptr
  };
  return names;
}

inline const char *EnumNameSiteStatus_Full_instStatus_Enum(SiteStatus_Full_instStatus_Enum e) {
  if (::flatbuffers::IsOutRange(e, SiteStatus_Full_instStatus_Enum_FMC, SiteStatus_Full_instStatus_Enum_UNK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSiteStatus_Full_instStatus_Enum()[index];
}

enum SiteStatus_Full_fpcon_Enum : int8_t {
  /// No description available.
  SiteStatus_Full_fpcon_Enum_NORMAL = 0,
  /// No description available.
  SiteStatus_Full_fpcon_Enum_ALPHA = 1,
  /// No description available.
  SiteStatus_Full_fpcon_Enum_BRAVO = 2,
  /// No description available.
  SiteStatus_Full_fpcon_Enum_CHARLIE = 3,
  /// No description available.
  SiteStatus_Full_fpcon_Enum_DELTA = 4,
  SiteStatus_Full_fpcon_Enum_MIN = SiteStatus_Full_fpcon_Enum_NORMAL,
  SiteStatus_Full_fpcon_Enum_MAX = SiteStatus_Full_fpcon_Enum_DELTA
};

inline const SiteStatus_Full_fpcon_Enum (&EnumValuesSiteStatus_Full_fpcon_Enum())[5] {
  static const SiteStatus_Full_fpcon_Enum values[] = {
    SiteStatus_Full_fpcon_Enum_NORMAL,
    SiteStatus_Full_fpcon_Enum_ALPHA,
    SiteStatus_Full_fpcon_Enum_BRAVO,
    SiteStatus_Full_fpcon_Enum_CHARLIE,
    SiteStatus_Full_fpcon_Enum_DELTA
  };
  return values;
}

inline const char * const *EnumNamesSiteStatus_Full_fpcon_Enum() {
  static const char * const names[6] = {
    "NORMAL",
    "ALPHA",
    "BRAVO",
    "CHARLIE",
    "DELTA",
    nullptr
  };
  return names;
}

inline const char *EnumNameSiteStatus_Full_fpcon_Enum(SiteStatus_Full_fpcon_Enum e) {
  if (::flatbuffers::IsOutRange(e, SiteStatus_Full_fpcon_Enum_NORMAL, SiteStatus_Full_fpcon_Enum_DELTA)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSiteStatus_Full_fpcon_Enum()[index];
}

enum SiteStatus_Full_hpcon_Enum : int8_t {
  /// No description available.
  SiteStatus_Full_hpcon_Enum_E0 = 0,
  /// No description available.
  SiteStatus_Full_hpcon_Enum_ALPHA = 1,
  /// No description available.
  SiteStatus_Full_hpcon_Enum_BRAVO = 2,
  /// No description available.
  SiteStatus_Full_hpcon_Enum_CHARLIE = 3,
  /// No description available.
  SiteStatus_Full_hpcon_Enum_DELTA = 4,
  SiteStatus_Full_hpcon_Enum_MIN = SiteStatus_Full_hpcon_Enum_E0,
  SiteStatus_Full_hpcon_Enum_MAX = SiteStatus_Full_hpcon_Enum_DELTA
};

inline const SiteStatus_Full_hpcon_Enum (&EnumValuesSiteStatus_Full_hpcon_Enum())[5] {
  static const SiteStatus_Full_hpcon_Enum values[] = {
    SiteStatus_Full_hpcon_Enum_E0,
    SiteStatus_Full_hpcon_Enum_ALPHA,
    SiteStatus_Full_hpcon_Enum_BRAVO,
    SiteStatus_Full_hpcon_Enum_CHARLIE,
    SiteStatus_Full_hpcon_Enum_DELTA
  };
  return values;
}

inline const char * const *EnumNamesSiteStatus_Full_hpcon_Enum() {
  static const char * const names[6] = {
    "E0",
    "ALPHA",
    "BRAVO",
    "CHARLIE",
    "DELTA",
    nullptr
  };
  return names;
}

inline const char *EnumNameSiteStatus_Full_hpcon_Enum(SiteStatus_Full_hpcon_Enum e) {
  if (::flatbuffers::IsOutRange(e, SiteStatus_Full_hpcon_Enum_E0, SiteStatus_Full_hpcon_Enum_DELTA)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSiteStatus_Full_hpcon_Enum()[index];
}

enum SiteStatus_Full_cpcon_Enum : int8_t {
  /// No description available.
  SiteStatus_Full_cpcon_Enum_E1 = 0,
  /// No description available.
  SiteStatus_Full_cpcon_Enum_E2 = 1,
  /// No description available.
  SiteStatus_Full_cpcon_Enum_E3 = 2,
  /// No description available.
  SiteStatus_Full_cpcon_Enum_E4 = 3,
  /// No description available.
  SiteStatus_Full_cpcon_Enum_E5 = 4,
  SiteStatus_Full_cpcon_Enum_MIN = SiteStatus_Full_cpcon_Enum_E1,
  SiteStatus_Full_cpcon_Enum_MAX = SiteStatus_Full_cpcon_Enum_E5
};

inline const SiteStatus_Full_cpcon_Enum (&EnumValuesSiteStatus_Full_cpcon_Enum())[5] {
  static const SiteStatus_Full_cpcon_Enum values[] = {
    SiteStatus_Full_cpcon_Enum_E1,
    SiteStatus_Full_cpcon_Enum_E2,
    SiteStatus_Full_cpcon_Enum_E3,
    SiteStatus_Full_cpcon_Enum_E4,
    SiteStatus_Full_cpcon_Enum_E5
  };
  return values;
}

inline const char * const *EnumNamesSiteStatus_Full_cpcon_Enum() {
  static const char * const names[6] = {
    "E1",
    "E2",
    "E3",
    "E4",
    "E5",
    nullptr
  };
  return names;
}

inline const char *EnumNameSiteStatus_Full_cpcon_Enum(SiteStatus_Full_cpcon_Enum e) {
  if (::flatbuffers::IsOutRange(e, SiteStatus_Full_cpcon_Enum_E1, SiteStatus_Full_cpcon_Enum_E5)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSiteStatus_Full_cpcon_Enum()[index];
}

enum SiteStatus_Full_cat_Enum : int8_t {
  /// No description available.
  SiteStatus_Full_cat_Enum_COLD = 0,
  /// No description available.
  SiteStatus_Full_cat_Enum_WARM = 1,
  /// No description available.
  SiteStatus_Full_cat_Enum_HOT = 2,
  SiteStatus_Full_cat_Enum_MIN = SiteStatus_Full_cat_Enum_COLD,
  SiteStatus_Full_cat_Enum_MAX = SiteStatus_Full_cat_Enum_HOT
};

inline const SiteStatus_Full_cat_Enum (&EnumValuesSiteStatus_Full_cat_Enum())[3] {
  static const SiteStatus_Full_cat_Enum values[] = {
    SiteStatus_Full_cat_Enum_COLD,
    SiteStatus_Full_cat_Enum_WARM,
    SiteStatus_Full_cat_Enum_HOT
  };
  return values;
}

inline const char * const *EnumNamesSiteStatus_Full_cat_Enum() {
  static const char * const names[4] = {
    "COLD",
    "WARM",
    "HOT",
    nullptr
  };
  return names;
}

inline const char *EnumNameSiteStatus_Full_cat_Enum(SiteStatus_Full_cat_Enum e) {
  if (::flatbuffers::IsOutRange(e, SiteStatus_Full_cat_Enum_COLD, SiteStatus_Full_cat_Enum_HOT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSiteStatus_Full_cat_Enum()[index];
}

enum SiteStatus_Full_eoc_Enum : int8_t {
  /// No description available.
  SiteStatus_Full_eoc_Enum_COLD = 0,
  /// No description available.
  SiteStatus_Full_eoc_Enum_WARM = 1,
  /// No description available.
  SiteStatus_Full_eoc_Enum_HOT = 2,
  SiteStatus_Full_eoc_Enum_MIN = SiteStatus_Full_eoc_Enum_COLD,
  SiteStatus_Full_eoc_Enum_MAX = SiteStatus_Full_eoc_Enum_HOT
};

inline const SiteStatus_Full_eoc_Enum (&EnumValuesSiteStatus_Full_eoc_Enum())[3] {
  static const SiteStatus_Full_eoc_Enum values[] = {
    SiteStatus_Full_eoc_Enum_COLD,
    SiteStatus_Full_eoc_Enum_WARM,
    SiteStatus_Full_eoc_Enum_HOT
  };
  return values;
}

inline const char * const *EnumNamesSiteStatus_Full_eoc_Enum() {
  static const char * const names[4] = {
    "COLD",
    "WARM",
    "HOT",
    nullptr
  };
  return names;
}

inline const char *EnumNameSiteStatus_Full_eoc_Enum(SiteStatus_Full_eoc_Enum e) {
  if (::flatbuffers::IsOutRange(e, SiteStatus_Full_eoc_Enum_COLD, SiteStatus_Full_eoc_Enum_HOT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSiteStatus_Full_eoc_Enum()[index];
}

enum SiteStatus_Full_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  SiteStatus_Full_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  SiteStatus_Full_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  SiteStatus_Full_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  SiteStatus_Full_dataMode_Enum_EXERCISE = 3,
  SiteStatus_Full_dataMode_Enum_MIN = SiteStatus_Full_dataMode_Enum_REAL,
  SiteStatus_Full_dataMode_Enum_MAX = SiteStatus_Full_dataMode_Enum_EXERCISE
};

inline const SiteStatus_Full_dataMode_Enum (&EnumValuesSiteStatus_Full_dataMode_Enum())[4] {
  static const SiteStatus_Full_dataMode_Enum values[] = {
    SiteStatus_Full_dataMode_Enum_REAL,
    SiteStatus_Full_dataMode_Enum_TEST,
    SiteStatus_Full_dataMode_Enum_SIMULATED,
    SiteStatus_Full_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesSiteStatus_Full_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSiteStatus_Full_dataMode_Enum(SiteStatus_Full_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, SiteStatus_Full_dataMode_Enum_REAL, SiteStatus_Full_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSiteStatus_Full_dataMode_Enum()[index];
}

/// /// No description available.
struct SiteStatus_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SiteStatus_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_IDSITE = 8,
    VT_SITETYPE = 10,
    VT_MOBILEALTID = 12,
    VT_POIID = 14,
    VT_TRACKID = 16,
    VT_TRACKREFL16 = 18,
    VT_OPSCAPABILITY = 20,
    VT_INSTSTATUS = 22,
    VT_FPCON = 24,
    VT_HPCON = 26,
    VT_CPCON = 28,
    VT_REPORTTIME = 30,
    VT_TIMEFUNCTION = 32,
    VT_WEATHERMESSAGE = 34,
    VT_PES = 36,
    VT_HOTINVENTORY = 38,
    VT_COLDINVENTORY = 40,
    VT_SAMMODE = 42,
    VT_RADIATEMODE = 44,
    VT_OPSIMPAIRMENT = 46,
    VT_COMMIMPAIRMENT = 48,
    VT_CAT = 50,
    VT_EOC = 52,
    VT_LINK = 54,
    VT_LINKSTATUS = 56,
    VT_RADARSYSTEM = 58,
    VT_RADARSTATUS = 60,
    VT_MISSILE = 62,
    VT_MISSILEINVENTORY = 64,
    VT_CREATEDAT = 66,
    VT_CREATEDBY = 68,
    VT_UPDATEDAT = 70,
    VT_UPDATEDBY = 72,
    VT_SOURCE = 74,
    VT_ORIGIN = 76,
    VT_ORIGNETWORK = 78,
    VT_DATAMODE = 80
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: SITESTATUS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The ID of the site, if this status is associated with a fixed site or platform.
  /// Example: /// Example: 41e3e554-9790-40b9-bd7b-f30d864dcad8
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idSite() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSITE);
  }
  /// Optional site type or further detail of type.  Intended for, but not limited to, Link-16 site type specifications (e.g. ADOC, GACC, SOC, TACC, etc.).
  /// Example: /// Example: ADOC
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *siteType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SITETYPE);
  }
  /// Alternate Identifier for a mobile or transportable platform provided by source.
  /// Example: /// Example: MOBILEALT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *mobileAltId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MOBILEALTID);
  }
  /// The POI (point of interest) ID related to this platform, if available.
  /// Example: /// Example: d4a91864-6140-4b8d-67cd-45421c75f696
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *poiid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POIID);
  }
  /// The track ID related to this platform (if mobile or transportable), if available.
  /// Example: /// Example: PCM4923-1656174732-4-1-257
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *trackId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRACKID);
  }
  /// Link-16 specific reference track number.
  /// Example: /// Example: TrkNm
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *trackRefL16() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRACKREFL16);
  }
  /// The operational status of the platform (e.g. Fully Operational, Partially Operational, Not Operational, etc.).
  /// Example: /// Example: Fully Operational
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *opsCapability() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPSCAPABILITY);
  }
  /// The status of the installation.
  /// FMC - Fully Mission Capable
  ///  PMC - Partially Mission Capable
  /// NMC - Non Mission Capable
  /// UNK - Unknown.
  /// Example: /// Example: PMC
  /// Constraints: Minimum length = 0, Maximum length = 3
  SiteStatus_Full_instStatus_Enum instStatus() const {
    return static_cast<SiteStatus_Full_instStatus_Enum>(GetField<int8_t>(VT_INSTSTATUS, 0));
  }
  /// Force Protection Condition (FPCON).
  /// NORMAL - Applies when a general global threat of possible terrorist activity exists and warrants a routine security posture.
  /// ALPHA - Applies when an increased general threat of possible terrorist activity against personnel or facilities. Nature and extent of threat are unpredictable.
  /// BRAVO - Applies when an increased or predictable threat of terrorist activity exists.
  /// CHARLIE - Applies when an incident occurs or intelligence is received indicating some form of terrorist action against personnel and facilities is imminent.
  /// DELTA - Applies in the immediate area where an attack has occurred or when intelligence is received indicating terrorist action against a location is imminent.
  /// Example: /// Example: BRAVO
  /// Constraints: Minimum length = 0, Maximum length = 7
  SiteStatus_Full_fpcon_Enum fpcon() const {
    return static_cast<SiteStatus_Full_fpcon_Enum>(GetField<int8_t>(VT_FPCON, 0));
  }
  /// Health Protection Condition (HPCON).
  /// 0 - Routine, no community transmission.
  /// ALPHA - Limited, community transmission beginning.
  /// BRAVO - Moderate, increased community transmission.
  /// CHARLIE - Substantial, sustained community transmission.
  /// DELTA - Severe, widespread community transmission.
  /// Example: /// Example: CHARLIE
  /// Constraints: Minimum length = 0, Maximum length = 7
  SiteStatus_Full_hpcon_Enum hpcon() const {
    return static_cast<SiteStatus_Full_hpcon_Enum>(GetField<int8_t>(VT_HPCON, 0));
  }
  /// Cyberspace Protection Condition (CPCON).
  /// 1 - VERY HIGH - Critical functions.
  /// 2 - HIGH - Critical and essential functions.
  /// 3 - MEDIUM - Critical, essential, and support functions.
  /// 4 - LOW - All functions.
  /// 5 - VERY LOW - All functions.
  /// Example: /// Example: 4
  /// Constraints: Minimum length = 0, Maximum length = 1
  SiteStatus_Full_cpcon_Enum cpcon() const {
    return static_cast<SiteStatus_Full_cpcon_Enum>(GetField<int8_t>(VT_CPCON, 0));
  }
  /// Time of report, in ISO8601 UTC format.
  /// Example: /// Example: 2021-01-01T01:01:01.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *reportTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REPORTTIME);
  }
  /// Description of the time function associated with the reportTime (e.g. Activation, Deactivation, Arrival, Departure, etc.), if applicable.
  /// Example: /// Example: Activation
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *timeFunction() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIMEFUNCTION);
  }
  /// Description of the current weather conditions over a site.
  /// Example: /// Example: Heavy rain
  /// Constraints: Minimum length = 0, Maximum length = 512
  const ::flatbuffers::String *weatherMessage() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEATHERMESSAGE);
  }
  /// Position Engagement Status flag, Indicating whether this platform is initiating multiple simultaneous engagements.  A value of 1/True indicates the platform is initiating multiple simultaneous engagements.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool pes() const {
    return GetField<uint8_t>(VT_PES, 0) != 0;
  }
  /// Estimated number of hot missiles of all types remaining in weapons system inventory.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t hotInventory() const {
    return GetField<int32_t>(VT_HOTINVENTORY, 0);
  }
  /// Estimated number of cold missiles of all types remaining in weapons system inventory.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t coldInventory() const {
    return GetField<int32_t>(VT_COLDINVENTORY, 0);
  }
  /// The state of a SAM unit (e.g. Initialization, Standby, Reorientation, etc.).
  /// Example: /// Example: Initialization
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *samMode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SAMMODE);
  }
  /// SAM sensor radar surveillance mode (Active, Passive, Off).
  /// Example: /// Example: Active
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *radiateMode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RADIATEMODE);
  }
  /// The primary component degrading the operational capability of the platform or system.
  /// Example: /// Example: opsImpairment
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *opsImpairment() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPSIMPAIRMENT);
  }
  /// The communications component causing the platform or system to be less than fully operational.
  /// Example: /// Example: commImpairment
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *commImpairment() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMIMPAIRMENT);
  }
  /// Crisis Action Team (CAT).
  /// COLD - Not in use.
  /// WARM - Facility prepped/possible skeleton crew.
  /// HOT - Fully active.
  /// Example: /// Example: COLD
  /// Constraints: Minimum length = 0, Maximum length = 4
  SiteStatus_Full_cat_Enum cat() const {
    return static_cast<SiteStatus_Full_cat_Enum>(GetField<int8_t>(VT_CAT, 0));
  }
  /// Emergency Operations Center (EOC) status.
  /// COLD - Not in use.
  /// WARM - Facility prepped/possible skeleton crew.
  /// HOT - Fully active.
  /// Example: /// Example: WARM
  /// Constraints: Minimum length = 0, Maximum length = 4
  SiteStatus_Full_eoc_Enum eoc() const {
    return static_cast<SiteStatus_Full_eoc_Enum>(GetField<int8_t>(VT_EOC, 0));
  }
  /// Array of Link item(s) for which status is available and reported (ATDL, IJMS,  LINK-1, LINK-11, LINK-11B, LINK-16).  This array must be the same length as the linkStatus array.
  /// Example: /// Example: ['ATDL', 'IJMS', 'LINK-1']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *link() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_LINK);
  }
  /// Array of the status (AVAILABLE, DEGRADED, NOT AVAILABLE, etc.) for each links in the link array. This array must be the same length as the link array, and the status must correspond to the appropriate position index in the link array.
  /// Example: /// Example: ['AVAILABLE', 'DEGRADED', 'NOT AVAILABLE']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *linkStatus() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_LINKSTATUS);
  }
  /// Array of radar system(s) for which status is available and reported (ACQUISITION, IFFSIF, ILLUMINATING, MODE-4, PRIMARY SURVEILLANCE, SECONDARY SURVEILLANCE, TERTIARY SURVEILLANCE). This array must be the same length as the radarStatus array.
  /// Example: /// Example: ['ILLUMINATING', 'MODE-4', 'MODE-3']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *radarSystem() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_RADARSYSTEM);
  }
  /// Array of the status (NON-OPERATIONAL, OPERATIONAL, OFF) for each radar system in the radarSystem array. This array must be the same length as the radarSystem array, and the status must correspond to the appropriate position index in the radarSystem array.
  /// Example: /// Example: ['OPERATIONAL', 'OFF', 'NON-OPERATIONAL']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *radarStatus() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_RADARSTATUS);
  }
  /// Array of specific missile types for which an estimated inventory count is available (e.g. GMD TYPE A, HARPOON, TOMAHAWK, etc.).  This array must be the same length as the missileInventory array.
  /// Example: /// Example: ['GMD', 'HARPOON', 'JAVELIN']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *missile() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MISSILE);
  }
  /// Array of the quantity of each of the missile items.  This array must be the same length as the missile array, and the values must correspond to appropriate position index in the missile array.
  /// Example: /// Example: [5, 10, 100]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *missileInventory() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MISSILEINVENTORY);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Time the row was updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *updatedAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDAT);
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *updatedBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  SiteStatus_Full_dataMode_Enum dataMode() const {
    return static_cast<SiteStatus_Full_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_IDSITE) &&
           verifier.VerifyString(idSite()) &&
           VerifyOffset(verifier, VT_SITETYPE) &&
           verifier.VerifyString(siteType()) &&
           VerifyOffset(verifier, VT_MOBILEALTID) &&
           verifier.VerifyString(mobileAltId()) &&
           VerifyOffset(verifier, VT_POIID) &&
           verifier.VerifyString(poiid()) &&
           VerifyOffset(verifier, VT_TRACKID) &&
           verifier.VerifyString(trackId()) &&
           VerifyOffset(verifier, VT_TRACKREFL16) &&
           verifier.VerifyString(trackRefL16()) &&
           VerifyOffset(verifier, VT_OPSCAPABILITY) &&
           verifier.VerifyString(opsCapability()) &&
           VerifyField<int8_t>(verifier, VT_INSTSTATUS, 1) &&
           VerifyField<int8_t>(verifier, VT_FPCON, 1) &&
           VerifyField<int8_t>(verifier, VT_HPCON, 1) &&
           VerifyField<int8_t>(verifier, VT_CPCON, 1) &&
           VerifyOffset(verifier, VT_REPORTTIME) &&
           verifier.VerifyString(reportTime()) &&
           VerifyOffset(verifier, VT_TIMEFUNCTION) &&
           verifier.VerifyString(timeFunction()) &&
           VerifyOffset(verifier, VT_WEATHERMESSAGE) &&
           verifier.VerifyString(weatherMessage()) &&
           VerifyField<uint8_t>(verifier, VT_PES, 1) &&
           VerifyField<int32_t>(verifier, VT_HOTINVENTORY, 4) &&
           VerifyField<int32_t>(verifier, VT_COLDINVENTORY, 4) &&
           VerifyOffset(verifier, VT_SAMMODE) &&
           verifier.VerifyString(samMode()) &&
           VerifyOffset(verifier, VT_RADIATEMODE) &&
           verifier.VerifyString(radiateMode()) &&
           VerifyOffset(verifier, VT_OPSIMPAIRMENT) &&
           verifier.VerifyString(opsImpairment()) &&
           VerifyOffset(verifier, VT_COMMIMPAIRMENT) &&
           verifier.VerifyString(commImpairment()) &&
           VerifyField<int8_t>(verifier, VT_CAT, 1) &&
           VerifyField<int8_t>(verifier, VT_EOC, 1) &&
           VerifyOffset(verifier, VT_LINK) &&
           verifier.VerifyVector(link()) &&
           verifier.VerifyVectorOfStrings(link()) &&
           VerifyOffset(verifier, VT_LINKSTATUS) &&
           verifier.VerifyVector(linkStatus()) &&
           verifier.VerifyVectorOfStrings(linkStatus()) &&
           VerifyOffset(verifier, VT_RADARSYSTEM) &&
           verifier.VerifyVector(radarSystem()) &&
           verifier.VerifyVectorOfStrings(radarSystem()) &&
           VerifyOffset(verifier, VT_RADARSTATUS) &&
           verifier.VerifyVector(radarStatus()) &&
           verifier.VerifyVectorOfStrings(radarStatus()) &&
           VerifyOffset(verifier, VT_MISSILE) &&
           verifier.VerifyVector(missile()) &&
           verifier.VerifyVectorOfStrings(missile()) &&
           VerifyOffset(verifier, VT_MISSILEINVENTORY) &&
           verifier.VerifyVector(missileInventory()) &&
           verifier.VerifyVectorOfStrings(missileInventory()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_UPDATEDAT) &&
           verifier.VerifyString(updatedAt()) &&
           VerifyOffset(verifier, VT_UPDATEDBY) &&
           verifier.VerifyString(updatedBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           verifier.EndTable();
  }
};

struct SiteStatus_FullBuilder {
  typedef SiteStatus_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(SiteStatus_Full::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(SiteStatus_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_idSite(::flatbuffers::Offset<::flatbuffers::String> idSite) {
    fbb_.AddOffset(SiteStatus_Full::VT_IDSITE, idSite);
  }
  void add_siteType(::flatbuffers::Offset<::flatbuffers::String> siteType) {
    fbb_.AddOffset(SiteStatus_Full::VT_SITETYPE, siteType);
  }
  void add_mobileAltId(::flatbuffers::Offset<::flatbuffers::String> mobileAltId) {
    fbb_.AddOffset(SiteStatus_Full::VT_MOBILEALTID, mobileAltId);
  }
  void add_poiid(::flatbuffers::Offset<::flatbuffers::String> poiid) {
    fbb_.AddOffset(SiteStatus_Full::VT_POIID, poiid);
  }
  void add_trackId(::flatbuffers::Offset<::flatbuffers::String> trackId) {
    fbb_.AddOffset(SiteStatus_Full::VT_TRACKID, trackId);
  }
  void add_trackRefL16(::flatbuffers::Offset<::flatbuffers::String> trackRefL16) {
    fbb_.AddOffset(SiteStatus_Full::VT_TRACKREFL16, trackRefL16);
  }
  void add_opsCapability(::flatbuffers::Offset<::flatbuffers::String> opsCapability) {
    fbb_.AddOffset(SiteStatus_Full::VT_OPSCAPABILITY, opsCapability);
  }
  void add_instStatus(SiteStatus_Full_instStatus_Enum instStatus) {
    fbb_.AddElement<int8_t>(SiteStatus_Full::VT_INSTSTATUS, static_cast<int8_t>(instStatus), 0);
  }
  void add_fpcon(SiteStatus_Full_fpcon_Enum fpcon) {
    fbb_.AddElement<int8_t>(SiteStatus_Full::VT_FPCON, static_cast<int8_t>(fpcon), 0);
  }
  void add_hpcon(SiteStatus_Full_hpcon_Enum hpcon) {
    fbb_.AddElement<int8_t>(SiteStatus_Full::VT_HPCON, static_cast<int8_t>(hpcon), 0);
  }
  void add_cpcon(SiteStatus_Full_cpcon_Enum cpcon) {
    fbb_.AddElement<int8_t>(SiteStatus_Full::VT_CPCON, static_cast<int8_t>(cpcon), 0);
  }
  void add_reportTime(::flatbuffers::Offset<::flatbuffers::String> reportTime) {
    fbb_.AddOffset(SiteStatus_Full::VT_REPORTTIME, reportTime);
  }
  void add_timeFunction(::flatbuffers::Offset<::flatbuffers::String> timeFunction) {
    fbb_.AddOffset(SiteStatus_Full::VT_TIMEFUNCTION, timeFunction);
  }
  void add_weatherMessage(::flatbuffers::Offset<::flatbuffers::String> weatherMessage) {
    fbb_.AddOffset(SiteStatus_Full::VT_WEATHERMESSAGE, weatherMessage);
  }
  void add_pes(bool pes) {
    fbb_.AddElement<uint8_t>(SiteStatus_Full::VT_PES, static_cast<uint8_t>(pes), 0);
  }
  void add_hotInventory(int32_t hotInventory) {
    fbb_.AddElement<int32_t>(SiteStatus_Full::VT_HOTINVENTORY, hotInventory, 0);
  }
  void add_coldInventory(int32_t coldInventory) {
    fbb_.AddElement<int32_t>(SiteStatus_Full::VT_COLDINVENTORY, coldInventory, 0);
  }
  void add_samMode(::flatbuffers::Offset<::flatbuffers::String> samMode) {
    fbb_.AddOffset(SiteStatus_Full::VT_SAMMODE, samMode);
  }
  void add_radiateMode(::flatbuffers::Offset<::flatbuffers::String> radiateMode) {
    fbb_.AddOffset(SiteStatus_Full::VT_RADIATEMODE, radiateMode);
  }
  void add_opsImpairment(::flatbuffers::Offset<::flatbuffers::String> opsImpairment) {
    fbb_.AddOffset(SiteStatus_Full::VT_OPSIMPAIRMENT, opsImpairment);
  }
  void add_commImpairment(::flatbuffers::Offset<::flatbuffers::String> commImpairment) {
    fbb_.AddOffset(SiteStatus_Full::VT_COMMIMPAIRMENT, commImpairment);
  }
  void add_cat(SiteStatus_Full_cat_Enum cat) {
    fbb_.AddElement<int8_t>(SiteStatus_Full::VT_CAT, static_cast<int8_t>(cat), 0);
  }
  void add_eoc(SiteStatus_Full_eoc_Enum eoc) {
    fbb_.AddElement<int8_t>(SiteStatus_Full::VT_EOC, static_cast<int8_t>(eoc), 0);
  }
  void add_link(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> link) {
    fbb_.AddOffset(SiteStatus_Full::VT_LINK, link);
  }
  void add_linkStatus(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> linkStatus) {
    fbb_.AddOffset(SiteStatus_Full::VT_LINKSTATUS, linkStatus);
  }
  void add_radarSystem(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> radarSystem) {
    fbb_.AddOffset(SiteStatus_Full::VT_RADARSYSTEM, radarSystem);
  }
  void add_radarStatus(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> radarStatus) {
    fbb_.AddOffset(SiteStatus_Full::VT_RADARSTATUS, radarStatus);
  }
  void add_missile(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> missile) {
    fbb_.AddOffset(SiteStatus_Full::VT_MISSILE, missile);
  }
  void add_missileInventory(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> missileInventory) {
    fbb_.AddOffset(SiteStatus_Full::VT_MISSILEINVENTORY, missileInventory);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(SiteStatus_Full::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(SiteStatus_Full::VT_CREATEDBY, createdBy);
  }
  void add_updatedAt(::flatbuffers::Offset<::flatbuffers::String> updatedAt) {
    fbb_.AddOffset(SiteStatus_Full::VT_UPDATEDAT, updatedAt);
  }
  void add_updatedBy(::flatbuffers::Offset<::flatbuffers::String> updatedBy) {
    fbb_.AddOffset(SiteStatus_Full::VT_UPDATEDBY, updatedBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(SiteStatus_Full::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(SiteStatus_Full::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(SiteStatus_Full::VT_ORIGNETWORK, origNetwork);
  }
  void add_dataMode(SiteStatus_Full_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(SiteStatus_Full::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  explicit SiteStatus_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SiteStatus_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SiteStatus_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SiteStatus_Full> CreateSiteStatus_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSite = 0,
    ::flatbuffers::Offset<::flatbuffers::String> siteType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mobileAltId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> poiid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trackId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trackRefL16 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> opsCapability = 0,
    SiteStatus_Full_instStatus_Enum instStatus = SiteStatus_Full_instStatus_Enum_FMC,
    SiteStatus_Full_fpcon_Enum fpcon = SiteStatus_Full_fpcon_Enum_NORMAL,
    SiteStatus_Full_hpcon_Enum hpcon = SiteStatus_Full_hpcon_Enum_E0,
    SiteStatus_Full_cpcon_Enum cpcon = SiteStatus_Full_cpcon_Enum_E1,
    ::flatbuffers::Offset<::flatbuffers::String> reportTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> timeFunction = 0,
    ::flatbuffers::Offset<::flatbuffers::String> weatherMessage = 0,
    bool pes = false,
    int32_t hotInventory = 0,
    int32_t coldInventory = 0,
    ::flatbuffers::Offset<::flatbuffers::String> samMode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> radiateMode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> opsImpairment = 0,
    ::flatbuffers::Offset<::flatbuffers::String> commImpairment = 0,
    SiteStatus_Full_cat_Enum cat = SiteStatus_Full_cat_Enum_COLD,
    SiteStatus_Full_eoc_Enum eoc = SiteStatus_Full_eoc_Enum_COLD,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> link = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> linkStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> radarSystem = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> radarStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> missile = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> missileInventory = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    SiteStatus_Full_dataMode_Enum dataMode = SiteStatus_Full_dataMode_Enum_REAL) {
  SiteStatus_FullBuilder builder_(_fbb);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_updatedBy(updatedBy);
  builder_.add_updatedAt(updatedAt);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_missileInventory(missileInventory);
  builder_.add_missile(missile);
  builder_.add_radarStatus(radarStatus);
  builder_.add_radarSystem(radarSystem);
  builder_.add_linkStatus(linkStatus);
  builder_.add_link(link);
  builder_.add_commImpairment(commImpairment);
  builder_.add_opsImpairment(opsImpairment);
  builder_.add_radiateMode(radiateMode);
  builder_.add_samMode(samMode);
  builder_.add_coldInventory(coldInventory);
  builder_.add_hotInventory(hotInventory);
  builder_.add_weatherMessage(weatherMessage);
  builder_.add_timeFunction(timeFunction);
  builder_.add_reportTime(reportTime);
  builder_.add_opsCapability(opsCapability);
  builder_.add_trackRefL16(trackRefL16);
  builder_.add_trackId(trackId);
  builder_.add_poiid(poiid);
  builder_.add_mobileAltId(mobileAltId);
  builder_.add_siteType(siteType);
  builder_.add_idSite(idSite);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_eoc(eoc);
  builder_.add_cat(cat);
  builder_.add_pes(pes);
  builder_.add_cpcon(cpcon);
  builder_.add_hpcon(hpcon);
  builder_.add_fpcon(fpcon);
  builder_.add_instStatus(instStatus);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SiteStatus_Full> CreateSiteStatus_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *idSite = nullptr,
    const char *siteType = nullptr,
    const char *mobileAltId = nullptr,
    const char *poiid = nullptr,
    const char *trackId = nullptr,
    const char *trackRefL16 = nullptr,
    const char *opsCapability = nullptr,
    SiteStatus_Full_instStatus_Enum instStatus = SiteStatus_Full_instStatus_Enum_FMC,
    SiteStatus_Full_fpcon_Enum fpcon = SiteStatus_Full_fpcon_Enum_NORMAL,
    SiteStatus_Full_hpcon_Enum hpcon = SiteStatus_Full_hpcon_Enum_E0,
    SiteStatus_Full_cpcon_Enum cpcon = SiteStatus_Full_cpcon_Enum_E1,
    const char *reportTime = nullptr,
    const char *timeFunction = nullptr,
    const char *weatherMessage = nullptr,
    bool pes = false,
    int32_t hotInventory = 0,
    int32_t coldInventory = 0,
    const char *samMode = nullptr,
    const char *radiateMode = nullptr,
    const char *opsImpairment = nullptr,
    const char *commImpairment = nullptr,
    SiteStatus_Full_cat_Enum cat = SiteStatus_Full_cat_Enum_COLD,
    SiteStatus_Full_eoc_Enum eoc = SiteStatus_Full_eoc_Enum_COLD,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *link = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *linkStatus = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *radarSystem = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *radarStatus = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *missile = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *missileInventory = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *updatedAt = nullptr,
    const char *updatedBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr,
    SiteStatus_Full_dataMode_Enum dataMode = SiteStatus_Full_dataMode_Enum_REAL) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto idSite__ = idSite ? _fbb.CreateString(idSite) : 0;
  auto siteType__ = siteType ? _fbb.CreateString(siteType) : 0;
  auto mobileAltId__ = mobileAltId ? _fbb.CreateString(mobileAltId) : 0;
  auto poiid__ = poiid ? _fbb.CreateString(poiid) : 0;
  auto trackId__ = trackId ? _fbb.CreateString(trackId) : 0;
  auto trackRefL16__ = trackRefL16 ? _fbb.CreateString(trackRefL16) : 0;
  auto opsCapability__ = opsCapability ? _fbb.CreateString(opsCapability) : 0;
  auto reportTime__ = reportTime ? _fbb.CreateString(reportTime) : 0;
  auto timeFunction__ = timeFunction ? _fbb.CreateString(timeFunction) : 0;
  auto weatherMessage__ = weatherMessage ? _fbb.CreateString(weatherMessage) : 0;
  auto samMode__ = samMode ? _fbb.CreateString(samMode) : 0;
  auto radiateMode__ = radiateMode ? _fbb.CreateString(radiateMode) : 0;
  auto opsImpairment__ = opsImpairment ? _fbb.CreateString(opsImpairment) : 0;
  auto commImpairment__ = commImpairment ? _fbb.CreateString(commImpairment) : 0;
  auto link__ = link ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*link) : 0;
  auto linkStatus__ = linkStatus ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*linkStatus) : 0;
  auto radarSystem__ = radarSystem ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*radarSystem) : 0;
  auto radarStatus__ = radarStatus ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*radarStatus) : 0;
  auto missile__ = missile ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*missile) : 0;
  auto missileInventory__ = missileInventory ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*missileInventory) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto updatedAt__ = updatedAt ? _fbb.CreateString(updatedAt) : 0;
  auto updatedBy__ = updatedBy ? _fbb.CreateString(updatedBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateSiteStatus_Full(
      _fbb,
      id__,
      classificationMarking__,
      idSite__,
      siteType__,
      mobileAltId__,
      poiid__,
      trackId__,
      trackRefL16__,
      opsCapability__,
      instStatus,
      fpcon,
      hpcon,
      cpcon,
      reportTime__,
      timeFunction__,
      weatherMessage__,
      pes,
      hotInventory,
      coldInventory,
      samMode__,
      radiateMode__,
      opsImpairment__,
      commImpairment__,
      cat,
      eoc,
      link__,
      linkStatus__,
      radarSystem__,
      radarStatus__,
      missile__,
      missileInventory__,
      createdAt__,
      createdBy__,
      updatedAt__,
      updatedBy__,
      source__,
      origin__,
      origNetwork__,
      dataMode);
}

inline const SiteStatus_Full *GetSiteStatus_Full(const void *buf) {
  return ::flatbuffers::GetRoot<SiteStatus_Full>(buf);
}

inline const SiteStatus_Full *GetSizePrefixedSiteStatus_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SiteStatus_Full>(buf);
}

inline const char *SiteStatus_FullIdentifier() {
  return "SITE";
}

inline bool SiteStatus_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SiteStatus_FullIdentifier());
}

inline bool SizePrefixedSiteStatus_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SiteStatus_FullIdentifier(), true);
}

inline bool VerifySiteStatus_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SiteStatus_Full>(SiteStatus_FullIdentifier());
}

inline bool VerifySizePrefixedSiteStatus_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SiteStatus_Full>(SiteStatus_FullIdentifier());
}

inline void FinishSiteStatus_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SiteStatus_Full> root) {
  fbb.Finish(root, SiteStatus_FullIdentifier());
}

inline void FinishSizePrefixedSiteStatus_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SiteStatus_Full> root) {
  fbb.FinishSizePrefixed(root, SiteStatus_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
