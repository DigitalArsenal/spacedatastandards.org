// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct StateVector_Abridged;
struct StateVector_AbridgedBuilder;

enum StateVector_Abridged_referenceFrame_Enum : int8_t {
  /// No description available.
  StateVector_Abridged_referenceFrame_Enum_J2000 = 0,
  /// No description available.
  StateVector_Abridged_referenceFrame_Enum_EFG_TDR = 1,
  /// No description available.
  StateVector_Abridged_referenceFrame_Enum_ECR_ECEF = 2,
  /// No description available.
  StateVector_Abridged_referenceFrame_Enum_TEME = 3,
  /// No description available.
  StateVector_Abridged_referenceFrame_Enum_ITRF = 4,
  /// No description available.
  StateVector_Abridged_referenceFrame_Enum_GCRF = 5,
  StateVector_Abridged_referenceFrame_Enum_MIN = StateVector_Abridged_referenceFrame_Enum_J2000,
  StateVector_Abridged_referenceFrame_Enum_MAX = StateVector_Abridged_referenceFrame_Enum_GCRF
};

inline const StateVector_Abridged_referenceFrame_Enum (&EnumValuesStateVector_Abridged_referenceFrame_Enum())[6] {
  static const StateVector_Abridged_referenceFrame_Enum values[] = {
    StateVector_Abridged_referenceFrame_Enum_J2000,
    StateVector_Abridged_referenceFrame_Enum_EFG_TDR,
    StateVector_Abridged_referenceFrame_Enum_ECR_ECEF,
    StateVector_Abridged_referenceFrame_Enum_TEME,
    StateVector_Abridged_referenceFrame_Enum_ITRF,
    StateVector_Abridged_referenceFrame_Enum_GCRF
  };
  return values;
}

inline const char * const *EnumNamesStateVector_Abridged_referenceFrame_Enum() {
  static const char * const names[7] = {
    "J2000",
    "EFG_TDR",
    "ECR_ECEF",
    "TEME",
    "ITRF",
    "GCRF",
    nullptr
  };
  return names;
}

inline const char *EnumNameStateVector_Abridged_referenceFrame_Enum(StateVector_Abridged_referenceFrame_Enum e) {
  if (::flatbuffers::IsOutRange(e, StateVector_Abridged_referenceFrame_Enum_J2000, StateVector_Abridged_referenceFrame_Enum_GCRF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStateVector_Abridged_referenceFrame_Enum()[index];
}

enum StateVector_Abridged_covReferenceFrame_Enum : int8_t {
  /// No description available.
  StateVector_Abridged_covReferenceFrame_Enum_J2000 = 0,
  /// No description available.
  StateVector_Abridged_covReferenceFrame_Enum_UVW = 1,
  StateVector_Abridged_covReferenceFrame_Enum_MIN = StateVector_Abridged_covReferenceFrame_Enum_J2000,
  StateVector_Abridged_covReferenceFrame_Enum_MAX = StateVector_Abridged_covReferenceFrame_Enum_UVW
};

inline const StateVector_Abridged_covReferenceFrame_Enum (&EnumValuesStateVector_Abridged_covReferenceFrame_Enum())[2] {
  static const StateVector_Abridged_covReferenceFrame_Enum values[] = {
    StateVector_Abridged_covReferenceFrame_Enum_J2000,
    StateVector_Abridged_covReferenceFrame_Enum_UVW
  };
  return values;
}

inline const char * const *EnumNamesStateVector_Abridged_covReferenceFrame_Enum() {
  static const char * const names[3] = {
    "J2000",
    "UVW",
    nullptr
  };
  return names;
}

inline const char *EnumNameStateVector_Abridged_covReferenceFrame_Enum(StateVector_Abridged_covReferenceFrame_Enum e) {
  if (::flatbuffers::IsOutRange(e, StateVector_Abridged_covReferenceFrame_Enum_J2000, StateVector_Abridged_covReferenceFrame_Enum_UVW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStateVector_Abridged_covReferenceFrame_Enum()[index];
}

enum StateVector_Abridged_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  StateVector_Abridged_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  StateVector_Abridged_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  StateVector_Abridged_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  StateVector_Abridged_dataMode_Enum_EXERCISE = 3,
  StateVector_Abridged_dataMode_Enum_MIN = StateVector_Abridged_dataMode_Enum_REAL,
  StateVector_Abridged_dataMode_Enum_MAX = StateVector_Abridged_dataMode_Enum_EXERCISE
};

inline const StateVector_Abridged_dataMode_Enum (&EnumValuesStateVector_Abridged_dataMode_Enum())[4] {
  static const StateVector_Abridged_dataMode_Enum values[] = {
    StateVector_Abridged_dataMode_Enum_REAL,
    StateVector_Abridged_dataMode_Enum_TEST,
    StateVector_Abridged_dataMode_Enum_SIMULATED,
    StateVector_Abridged_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesStateVector_Abridged_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameStateVector_Abridged_dataMode_Enum(StateVector_Abridged_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, StateVector_Abridged_dataMode_Enum_REAL, StateVector_Abridged_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStateVector_Abridged_dataMode_Enum()[index];
}

/// /// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Discover' tab in the storefront to confirm coordinate frames by data provider.
struct StateVector_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateVector_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDSTATEVECTOR = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_EPOCH = 8,
    VT_PEDIGREE = 10,
    VT_IDONORBIT = 12,
    VT_SATNO = 14,
    VT_ORIGOBJECTID = 16,
    VT_IDORBITDETERMINATION = 18,
    VT_UCT = 20,
    VT_XPOS = 22,
    VT_YPOS = 24,
    VT_ZPOS = 26,
    VT_XVEL = 28,
    VT_YVEL = 30,
    VT_ZVEL = 32,
    VT_REFERENCEFRAME = 34,
    VT_COV = 36,
    VT_COVREFERENCEFRAME = 38,
    VT_COVMETHOD = 40,
    VT_EQCOV = 42,
    VT_XPOSALT1 = 44,
    VT_YPOSALT1 = 46,
    VT_ZPOSALT1 = 48,
    VT_XVELALT1 = 50,
    VT_YVELALT1 = 52,
    VT_ZVELALT1 = 54,
    VT_ALT1REFERENCEFRAME = 56,
    VT_XPOSALT2 = 58,
    VT_YPOSALT2 = 60,
    VT_ZPOSALT2 = 62,
    VT_XVELALT2 = 64,
    VT_YVELALT2 = 66,
    VT_ZVELALT2 = 68,
    VT_ALT2REFERENCEFRAME = 70,
    VT_POSUNC = 72,
    VT_VELUNC = 74,
    VT_MASS = 76,
    VT_AREA = 78,
    VT_SOLARRADPRESSCOEFF = 80,
    VT_DRAGCOEFF = 82,
    VT_DRAGAREA = 84,
    VT_REVNO = 86,
    VT_GEOPOTENTIALMODEL = 88,
    VT_DRAGMODEL = 90,
    VT_LUNARSOLAR = 92,
    VT_SOLARRADPRESS = 94,
    VT_SRPAREA = 96,
    VT_SOLIDEARTHTIDES = 98,
    VT_INTRACKTHRUST = 100,
    VT_BDOT = 102,
    VT_EDR = 104,
    VT_THRUSTACCEL = 106,
    VT_CMOFFSET = 108,
    VT_LASTOBSTART = 110,
    VT_LASTOBEND = 112,
    VT_OBSAVAILABLE = 114,
    VT_OBSUSED = 116,
    VT_TRACKSAVAIL = 118,
    VT_TRACKSUSED = 120,
    VT_RECODSPAN = 122,
    VT_ACTUALODSPAN = 124,
    VT_RESIDUALSACC = 126,
    VT_SOLARFLUXF10 = 128,
    VT_SOLARFLUXF10AVG = 130,
    VT_SOLARFLUXAPAVG = 132,
    VT_TAIUTC = 134,
    VT_UT1UTC = 136,
    VT_UT1RATE = 138,
    VT_POLARMOTIONX = 140,
    VT_POLARMOTIONY = 142,
    VT_IAU1980TERMS = 144,
    VT_LEAPSECONDTIME = 146,
    VT_INTEGRATORMODE = 148,
    VT_PARTIALS = 150,
    VT_STEPMODE = 152,
    VT_FIXEDSTEP = 154,
    VT_STEPSIZESELECTION = 156,
    VT_STEPSIZE = 158,
    VT_ERRORCONTROL = 160,
    VT_SIGMAPOSUVW = 162,
    VT_SIGMAVELUVW = 164,
    VT_RMS = 166,
    VT_SOURCE = 168,
    VT_ORIGIN = 170,
    VT_DATAMODE = 172,
    VT_ALGORITHM = 174,
    VT_CREATEDAT = 176,
    VT_CREATEDBY = 178,
    VT_DESCRIPTOR = 180,
    VT_TRANSACTIONID = 182,
    VT_ORIGNETWORK = 184,
    VT_SOURCEDL = 186
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: STATEVECTOR-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idStateVector() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSTATEVECTOR);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Time of validity for state vector in ISO 8601 UTC datetime format, with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *epoch() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPOCH);
  }
  /// The pedigree of state vector, or methods used for its generation to include state update/orbit determination, propagation from another state, or a state from a calibration satellite (e.g. ORBIT_UPDATE, PROPAGATION, CALIBRATION, CONJUNCTION, FLIGHT_PLAN).
  /// Example: /// Example: CONJUNCTION
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *pedigree() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PEDIGREE);
  }
  /// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idOnOrbit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDONORBIT);
  }
  /// Satellite/Catalog number of the target OnOrbit object.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  int32_t satNo() const {
    return GetField<int32_t>(VT_SATNO, 0);
  }
  /// Optional identifier provided by state vector source to indicate the target onorbit object of this state vector. This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origObjectId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGOBJECTID);
  }
  /// Unique identifier of the OD solution record that produced this state vector. This ID can be used to obtain additional information on an OrbitDetermination object using the 'get by ID' operation (e.g. /udl/orbitdetermination/{id}). For example, the OrbitDetermination with idOrbitDetermination = abc would be queries as /udl/orbitdetermination/abc.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idOrbitDetermination() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDORBITDETERMINATION);
  }
  /// Boolean indicating this state vector was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool uct() const {
    return GetField<uint8_t>(VT_UCT, 0) != 0;
  }
  /// Cartesian X position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: -1118.577381
  /// Constraints: No constraints specified.
  double xpos() const {
    return GetField<double>(VT_XPOS, 0.0);
  }
  /// Cartesian Y position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 3026.231084
  /// Constraints: No constraints specified.
  double ypos() const {
    return GetField<double>(VT_YPOS, 0.0);
  }
  /// Cartesian Z position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 6167.831808
  /// Constraints: No constraints specified.
  double zpos() const {
    return GetField<double>(VT_ZPOS, 0.0);
  }
  /// Cartesian X velocity of target, in kilometers/second, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: -4.25242784
  /// Constraints: No constraints specified.
  double xvel() const {
    return GetField<double>(VT_XVEL, 0.0);
  }
  /// Cartesian Y velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 5.291107434
  /// Constraints: No constraints specified.
  double yvel() const {
    return GetField<double>(VT_YVEL, 0.0);
  }
  /// Cartesian Z velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: -3.356493869
  /// Constraints: No constraints specified.
  double zvel() const {
    return GetField<double>(VT_ZVEL, 0.0);
  }
  /// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  StateVector_Abridged_referenceFrame_Enum referenceFrame() const {
    return static_cast<StateVector_Abridged_referenceFrame_Enum>(GetField<int8_t>(VT_REFERENCEFRAME, 0));
  }
  /// Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.  If the covReferenceFrame is null it is assumed to be J2000.
  /// The array values (1-21) represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR&nbsp;&nbsp;
  /// x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
  /// y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3
  /// z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6
  /// x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;10
  /// y'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
  /// z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;
  /// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
  /// If additional covariance terms are included for DRAG, SRP, and/or THRUST, the matrix can be extended with the following order of elements:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR
  /// DRG&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;23&nbsp;&nbsp;24&nbsp;&nbsp;25&nbsp;&nbsp;26&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;
  /// SRP&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;30&nbsp;&nbsp;31&nbsp;&nbsp;32&nbsp;&nbsp;33&nbsp;&nbsp;&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;
  /// THR&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;38&nbsp;&nbsp;39&nbsp;&nbsp;40&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45&nbsp;
  /// Example: /// Example: [1.1, 2.2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *cov() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COV);
  }
  /// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  StateVector_Abridged_covReferenceFrame_Enum covReferenceFrame() const {
    return static_cast<StateVector_Abridged_covReferenceFrame_Enum>(GetField<int8_t>(VT_COVREFERENCEFRAME, 0));
  }
  /// The method used to generate the covariance during the orbit determination (OD) that produced the state vector, or whether an arbitrary, non-calculated default value was used (CALCULATED, DEFAULT).
  /// Example: /// Example: CALCULATED
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *covMethod() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COVMETHOD);
  }
  /// The covariance matrix values represent the lower triangular half of the covariance matrix in terms of equinoctial elements.&nbsp; The size of the covariance matrix is dynamic.&nbsp; The values are outputted in order across each row, i.e.:
  /// 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5
  /// 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp; 10
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// 51&nbsp; 52&nbsp; 53&nbsp; 54&nbsp; 55
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
  /// The ordering of values is as follows:
  /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Af&nbsp;&nbsp; Ag&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp; N&nbsp;&nbsp; Chi&nbsp; Psi&nbsp;&nbsp; B&nbsp;&nbsp; BDOT AGOM&nbsp; T&nbsp;&nbsp; C1&nbsp;&nbsp; C2&nbsp; ...
  /// Af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
  /// Ag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3
  /// L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 6
  /// N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 10
  /// Chi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; 12&nbsp;&nbsp; 13&nbsp;&nbsp; 14&nbsp;&nbsp; 15
  /// Psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 17&nbsp;&nbsp; 18&nbsp;&nbsp; 19&nbsp;&nbsp; 20&nbsp;&nbsp; 21
  /// B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 23&nbsp;&nbsp; 24 &nbsp;&nbsp;25&nbsp;&nbsp; 26&nbsp;&nbsp; 27&nbsp;&nbsp; 28
  /// BDOT&nbsp;&nbsp; 29&nbsp;&nbsp; 30&nbsp;&nbsp; 31&nbsp;&nbsp; 32&nbsp;&nbsp; 33&nbsp;&nbsp; 34&nbsp;&nbsp; 35&nbsp;&nbsp; 36
  /// AGOM&nbsp; 37&nbsp;&nbsp; 38&nbsp;&nbsp; 39&nbsp;&nbsp; 40&nbsp;&nbsp; 41&nbsp;&nbsp; 42&nbsp;&nbsp; 43&nbsp;&nbsp; 44&nbsp;&nbsp; 45
  /// T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;&nbsp; 47&nbsp;&nbsp; 48&nbsp;&nbsp; 49&nbsp;&nbsp; 50&nbsp;&nbsp; 51&nbsp;&nbsp; 52&nbsp;&nbsp; 53&nbsp;&nbsp; 54&nbsp;&nbsp; 55
  /// C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 56&nbsp;&nbsp; 57&nbsp;&nbsp; 58&nbsp;&nbsp; 59&nbsp;&nbsp; 60&nbsp;&nbsp; 61&nbsp;&nbsp; 62&nbsp;&nbsp; 63&nbsp;&nbsp; 64&nbsp;&nbsp; 65&nbsp;&nbsp; 66
  /// C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67&nbsp;&nbsp; 68&nbsp;&nbsp; 69&nbsp;&nbsp; 70&nbsp;&nbsp; 71&nbsp; &nbsp;72&nbsp;&nbsp; 73&nbsp;&nbsp; 74&nbsp;&nbsp; 75&nbsp;&nbsp; 76&nbsp;&nbsp; 77&nbsp;&nbsp; 78
  /// :
  /// :
  /// where C1, C2, etc, are the "consider parameters" that may be added to the covariance matrix.&nbsp; The covariance matrix will be as large as the last element/model parameter needed.&nbsp; In other words, if the DC solved for all 6 elements plus AGOM, the covariance matrix will be 9x9 (and the rows for B and BDOT will be all zeros).&nbsp; If the covariance matrix is unavailable, the size will be set to 0x0, and no data will follow.&nbsp; The cov field should contain only the lower left triangle values from top left down to bottom right, in order.
  /// Example: /// Example: [1.1, 2.2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *eqCov() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_EQCOV);
  }
  /// Cartesian X position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -1145.688502
  /// Constraints: No constraints specified.
  double xposAlt1() const {
    return GetField<double>(VT_XPOSALT1, 0.0);
  }
  /// Cartesian Y position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 3020.729572
  /// Constraints: No constraints specified.
  double yposAlt1() const {
    return GetField<double>(VT_YPOSALT1, 0.0);
  }
  /// Cartesian Z position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 6165.55187
  /// Constraints: No constraints specified.
  double zposAlt1() const {
    return GetField<double>(VT_ZPOSALT1, 0.0);
  }
  /// Cartesian X velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -4.270832252
  /// Constraints: No constraints specified.
  double xvelAlt1() const {
    return GetField<double>(VT_XVELALT1, 0.0);
  }
  /// Cartesian Y velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 5.27074276
  /// Constraints: No constraints specified.
  double yvelAlt1() const {
    return GetField<double>(VT_YVELALT1, 0.0);
  }
  /// Cartesian Z velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -3.365155181
  /// Constraints: No constraints specified.
  double zvelAlt1() const {
    return GetField<double>(VT_ZVELALT1, 0.0);
  }
  /// The reference frame of the alternate1 (Alt1) cartesian orbital state.
  /// Example: /// Example: TEME
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *alt1ReferenceFrame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALT1REFERENCEFRAME);
  }
  /// Cartesian X position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -1456.915926
  /// Constraints: No constraints specified.
  double xposAlt2() const {
    return GetField<double>(VT_XPOSALT2, 0.0);
  }
  /// Cartesian Y position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -2883.540406
  /// Constraints: No constraints specified.
  double yposAlt2() const {
    return GetField<double>(VT_YPOSALT2, 0.0);
  }
  /// Cartesian Z position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: 6165.55187
  /// Constraints: No constraints specified.
  double zposAlt2() const {
    return GetField<double>(VT_ZPOSALT2, 0.0);
  }
  /// Cartesian X velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -1.219814294
  /// Constraints: No constraints specified.
  double xvelAlt2() const {
    return GetField<double>(VT_XVELALT2, 0.0);
  }
  /// Cartesian Y velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -6.602080212
  /// Constraints: No constraints specified.
  double yvelAlt2() const {
    return GetField<double>(VT_YVELALT2, 0.0);
  }
  /// Cartesian Z velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
  /// Example: /// Example: -3.365155181
  /// Constraints: No constraints specified.
  double zvelAlt2() const {
    return GetField<double>(VT_ZVELALT2, 0.0);
  }
  /// The reference frame of the alternate2 (Alt2) cartesian orbital state.
  /// Example: /// Example: EFG/TDR
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *alt2ReferenceFrame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALT2REFERENCEFRAME);
  }
  /// One sigma position uncertainty, in kilometers.
  /// Example: /// Example: 0.333399744452
  /// Constraints: No constraints specified.
  double posUnc() const {
    return GetField<double>(VT_POSUNC, 0.0);
  }
  /// One sigma velocity uncertainty, in kilometers/second.
  /// Example: /// Example: 4e-06
  /// Constraints: No constraints specified.
  double velUnc() const {
    return GetField<double>(VT_VELUNC, 0.0);
  }
  /// The mass of the object, in kilograms.
  /// Example: /// Example: 164.5
  /// Constraints: No constraints specified.
  double mass() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  /// The actual area of the object at it's largest cross-section, expressed in meters^2.
  /// Example: /// Example: 5.065
  /// Constraints: No constraints specified.
  double area() const {
    return GetField<double>(VT_AREA, 0.0);
  }
  /// Area-to-mass ratio coefficient for solar radiation pressure.
  /// Example: /// Example: 0.0244394
  /// Constraints: No constraints specified.
  double solarRadPressCoeff() const {
    return GetField<double>(VT_SOLARRADPRESSCOEFF, 0.0);
  }
  /// Area-to-mass ratio coefficient for atmospheric ballistic drag (m2/kg).
  /// Example: /// Example: 0.0224391269775
  /// Constraints: No constraints specified.
  double dragCoeff() const {
    return GetField<double>(VT_DRAGCOEFF, 0.0);
  }
  /// The effective area of the object exposed to atmospheric drag, expressed in meters^2.
  /// Example: /// Example: 4.739
  /// Constraints: No constraints specified.
  double dragArea() const {
    return GetField<double>(VT_DRAGAREA, 0.0);
  }
  /// Epoch revolution number.
  /// Example: /// Example: 7205
  /// Constraints: No constraints specified.
  int32_t revNo() const {
    return GetField<int32_t>(VT_REVNO, 0);
  }
  /// Geopotential model used for this vector (e.g. EGM-96, WGS-84, WGS-72, JGM-2, or GEM-T3), including mm degree zonals, nn degree/order tesserals. E.g. EGM-96 24Z,24T.
  /// Example: /// Example: EGM-96
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *geopotentialModel() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GEOPOTENTIALMODEL);
  }
  /// The Drag Model used for this vector (e.g. HARRIS-PRIESTER, JAC70, JBH09, MSIS90, NONE, etc.).
  /// Example: /// Example: JAC70
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *dragModel() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DRAGMODEL);
  }
  /// Boolean indicating use of lunar/solar perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool lunarSolar() const {
    return GetField<uint8_t>(VT_LUNARSOLAR, 0) != 0;
  }
  /// Boolean indicating use of solar radiation pressure perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool solarRadPress() const {
    return GetField<uint8_t>(VT_SOLARRADPRESS, 0) != 0;
  }
  /// The effective area of the object exposed to solar radiation pressure, expressed in meters^2.
  /// Example: /// Example: 4.311
  /// Constraints: No constraints specified.
  double srpArea() const {
    return GetField<double>(VT_SRPAREA, 0.0);
  }
  /// Boolean indicating use of solid earth tide perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool solidEarthTides() const {
    return GetField<uint8_t>(VT_SOLIDEARTHTIDES, 0) != 0;
  }
  /// Boolean indicating use of in-track thrust perturbations for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool inTrackThrust() const {
    return GetField<uint8_t>(VT_INTRACKTHRUST, 0) != 0;
  }
  /// First derivative of drag/ballistic coefficient (m2/kg-s).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double bDot() const {
    return GetField<double>(VT_BDOT, 0.0);
  }
  /// Model parameter value for energy dissipation rate (EDR) (w/kg).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double edr() const {
    return GetField<double>(VT_EDR, 0.0);
  }
  /// Model parameter value for thrust acceleration (m/s2).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double thrustAccel() const {
    return GetField<double>(VT_THRUSTACCEL, 0.0);
  }
  /// Model parameter value for center of mass offset (m).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double cmOffset() const {
    return GetField<double>(VT_CMOFFSET, 0.0);
  }
  /// The start of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
  /// Example: /// Example: 2022-11-09T11:20:21.247192Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *lastObStart() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTOBSTART);
  }
  /// The end of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
  /// Example: /// Example: 2022-11-09T11:20:21.247192Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *lastObEnd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTOBEND);
  }
  /// The number of observations available for the OD of the object.
  /// Example: /// Example: 376
  /// Constraints: No constraints specified.
  int32_t obsAvailable() const {
    return GetField<int32_t>(VT_OBSAVAILABLE, 0);
  }
  /// The number of observations accepted for the OD of the object.
  /// Example: /// Example: 374
  /// Constraints: No constraints specified.
  int32_t obsUsed() const {
    return GetField<int32_t>(VT_OBSUSED, 0);
  }
  /// The number of sensor tracks available for the OD of the object.
  /// Example: /// Example: 163
  /// Constraints: No constraints specified.
  int32_t tracksAvail() const {
    return GetField<int32_t>(VT_TRACKSAVAIL, 0);
  }
  /// The number of sensor tracks accepted for the OD of the object.
  /// Example: /// Example: 163
  /// Constraints: No constraints specified.
  int32_t tracksUsed() const {
    return GetField<int32_t>(VT_TRACKSUSED, 0);
  }
  /// The recommended OD time span calculated for the object, expressed in days.
  /// Example: /// Example: 3.5
  /// Constraints: No constraints specified.
  double recODSpan() const {
    return GetField<double>(VT_RECODSPAN, 0.0);
  }
  /// The actual time span used for the OD of the object, expressed in days.
  /// Example: /// Example: 3.5
  /// Constraints: No constraints specified.
  double actualODSpan() const {
    return GetField<double>(VT_ACTUALODSPAN, 0.0);
  }
  /// The percentage of residuals accepted in the OD of the object.
  /// Example: /// Example: 99.5
  /// Constraints: No constraints specified.
  double residualsAcc() const {
    return GetField<double>(VT_RESIDUALSACC, 0.0);
  }
  /// F10 (10.7 cm) solar flux value.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double solarFluxF10() const {
    return GetField<double>(VT_SOLARFLUXF10, 0.0);
  }
  /// F10 (10.7 cm) solar flux 81-day average value.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double solarFluxF10Avg() const {
    return GetField<double>(VT_SOLARFLUXF10AVG, 0.0);
  }
  /// Average solar flux geomagnetic index.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double solarFluxAPAvg() const {
    return GetField<double>(VT_SOLARFLUXAPAVG, 0.0);
  }
  /// TAI (Temps Atomique International) minus UTC (Universal Time Coordinates) offset in seconds.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double taiUtc() const {
    return GetField<double>(VT_TAIUTC, 0.0);
  }
  /// Universal Time-1 (UT1) minus UTC offset, in seconds.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double ut1Utc() const {
    return GetField<double>(VT_UT1UTC, 0.0);
  }
  /// Rate of change of UT1 (milliseconds/day) - first derivative of ut1Utc.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double ut1Rate() const {
    return GetField<double>(VT_UT1RATE, 0.0);
  }
  /// Polar Wander Motion X (arc seconds).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double polarMotionX() const {
    return GetField<double>(VT_POLARMOTIONX, 0.0);
  }
  /// Polar Wander Motion Y (arc seconds).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double polarMotionY() const {
    return GetField<double>(VT_POLARMOTIONY, 0.0);
  }
  /// Number of terms used in the IAU 1980 nutation model (4, 50, or 106).
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  int32_t iau1980Terms() const {
    return GetField<int32_t>(VT_IAU1980TERMS, 0);
  }
  /// Time of the next leap second after epoch in ISO 8601 UTC time. If the next leap second is not known, the time of the previous leap second is used.
  /// Example: /// Example: 2021-01-01T01:01:01.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *leapSecondTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LEAPSECONDTIME);
  }
  /// Integrator Mode.
  /// Example: /// Example: integratorMode
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *integratorMode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTEGRATORMODE);
  }
  /// Type of partial derivatives used (ANALYTIC, FULL NUM, or FAST NUM).
  /// Example: /// Example: ANALYTIC
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *partials() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARTIALS);
  }
  /// Integrator step mode (AUTO, TIME, or S).
  /// Example: /// Example: AUTO
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *stepMode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STEPMODE);
  }
  /// Boolean indicating use of fixed step size for this vector.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool fixedStep() const {
    return GetField<uint8_t>(VT_FIXEDSTEP, 0) != 0;
  }
  /// Initial step size selection (AUTO or MANUAL).
  /// Example: /// Example: AUTO
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *stepSizeSelection() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STEPSIZESELECTION);
  }
  /// Initial integration step size (seconds).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double stepSize() const {
    return GetField<double>(VT_STEPSIZE, 0.0);
  }
  /// Integrator error control.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double errorControl() const {
    return GetField<double>(VT_ERRORCONTROL, 0.0);
  }
  /// Array containing the standard deviation of error in target object position, U, V and W direction respectively (km).
  /// Example: /// Example: [1.23, 4.56]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *sigmaPosUVW() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SIGMAPOSUVW);
  }
  /// Array containing the standard deviation of error in target object velocity, U, V and W direction respectively (km/sec).
  /// Example: /// Example: [1.23, 4.56]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *sigmaVelUVW() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SIGMAVELUVW);
  }
  /// The Weighted Root Mean Squared (RMS) of the differential correction on the target object that produced this vector.  WRMS is a quality indicator of the state vector update, with a value of 1.00 being optimal.  WRMS applies to Batch Least Squares (BLS) processes.
  /// Example: /// Example: 0.991
  /// Constraints: No constraints specified.
  double rms() const {
    return GetField<double>(VT_RMS, 0.0);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  StateVector_Abridged_dataMode_Enum dataMode() const {
    return static_cast<StateVector_Abridged_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Optional algorithm used to produce this record.
  /// Example: /// Example: SAMPLE_ALGORITHM
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *algorithm() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALGORITHM);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: descriptor
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTOR);
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: transactionId
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *transactionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSACTIONID);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *sourceDL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEDL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDSTATEVECTOR) &&
           verifier.VerifyString(idStateVector()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_EPOCH) &&
           verifier.VerifyString(epoch()) &&
           VerifyOffset(verifier, VT_PEDIGREE) &&
           verifier.VerifyString(pedigree()) &&
           VerifyOffset(verifier, VT_IDONORBIT) &&
           verifier.VerifyString(idOnOrbit()) &&
           VerifyField<int32_t>(verifier, VT_SATNO, 4) &&
           VerifyOffset(verifier, VT_ORIGOBJECTID) &&
           verifier.VerifyString(origObjectId()) &&
           VerifyOffset(verifier, VT_IDORBITDETERMINATION) &&
           verifier.VerifyString(idOrbitDetermination()) &&
           VerifyField<uint8_t>(verifier, VT_UCT, 1) &&
           VerifyField<double>(verifier, VT_XPOS, 8) &&
           VerifyField<double>(verifier, VT_YPOS, 8) &&
           VerifyField<double>(verifier, VT_ZPOS, 8) &&
           VerifyField<double>(verifier, VT_XVEL, 8) &&
           VerifyField<double>(verifier, VT_YVEL, 8) &&
           VerifyField<double>(verifier, VT_ZVEL, 8) &&
           VerifyField<int8_t>(verifier, VT_REFERENCEFRAME, 1) &&
           VerifyOffset(verifier, VT_COV) &&
           verifier.VerifyVector(cov()) &&
           verifier.VerifyVectorOfStrings(cov()) &&
           VerifyField<int8_t>(verifier, VT_COVREFERENCEFRAME, 1) &&
           VerifyOffset(verifier, VT_COVMETHOD) &&
           verifier.VerifyString(covMethod()) &&
           VerifyOffset(verifier, VT_EQCOV) &&
           verifier.VerifyVector(eqCov()) &&
           verifier.VerifyVectorOfStrings(eqCov()) &&
           VerifyField<double>(verifier, VT_XPOSALT1, 8) &&
           VerifyField<double>(verifier, VT_YPOSALT1, 8) &&
           VerifyField<double>(verifier, VT_ZPOSALT1, 8) &&
           VerifyField<double>(verifier, VT_XVELALT1, 8) &&
           VerifyField<double>(verifier, VT_YVELALT1, 8) &&
           VerifyField<double>(verifier, VT_ZVELALT1, 8) &&
           VerifyOffset(verifier, VT_ALT1REFERENCEFRAME) &&
           verifier.VerifyString(alt1ReferenceFrame()) &&
           VerifyField<double>(verifier, VT_XPOSALT2, 8) &&
           VerifyField<double>(verifier, VT_YPOSALT2, 8) &&
           VerifyField<double>(verifier, VT_ZPOSALT2, 8) &&
           VerifyField<double>(verifier, VT_XVELALT2, 8) &&
           VerifyField<double>(verifier, VT_YVELALT2, 8) &&
           VerifyField<double>(verifier, VT_ZVELALT2, 8) &&
           VerifyOffset(verifier, VT_ALT2REFERENCEFRAME) &&
           verifier.VerifyString(alt2ReferenceFrame()) &&
           VerifyField<double>(verifier, VT_POSUNC, 8) &&
           VerifyField<double>(verifier, VT_VELUNC, 8) &&
           VerifyField<double>(verifier, VT_MASS, 8) &&
           VerifyField<double>(verifier, VT_AREA, 8) &&
           VerifyField<double>(verifier, VT_SOLARRADPRESSCOEFF, 8) &&
           VerifyField<double>(verifier, VT_DRAGCOEFF, 8) &&
           VerifyField<double>(verifier, VT_DRAGAREA, 8) &&
           VerifyField<int32_t>(verifier, VT_REVNO, 4) &&
           VerifyOffset(verifier, VT_GEOPOTENTIALMODEL) &&
           verifier.VerifyString(geopotentialModel()) &&
           VerifyOffset(verifier, VT_DRAGMODEL) &&
           verifier.VerifyString(dragModel()) &&
           VerifyField<uint8_t>(verifier, VT_LUNARSOLAR, 1) &&
           VerifyField<uint8_t>(verifier, VT_SOLARRADPRESS, 1) &&
           VerifyField<double>(verifier, VT_SRPAREA, 8) &&
           VerifyField<uint8_t>(verifier, VT_SOLIDEARTHTIDES, 1) &&
           VerifyField<uint8_t>(verifier, VT_INTRACKTHRUST, 1) &&
           VerifyField<double>(verifier, VT_BDOT, 8) &&
           VerifyField<double>(verifier, VT_EDR, 8) &&
           VerifyField<double>(verifier, VT_THRUSTACCEL, 8) &&
           VerifyField<double>(verifier, VT_CMOFFSET, 8) &&
           VerifyOffset(verifier, VT_LASTOBSTART) &&
           verifier.VerifyString(lastObStart()) &&
           VerifyOffset(verifier, VT_LASTOBEND) &&
           verifier.VerifyString(lastObEnd()) &&
           VerifyField<int32_t>(verifier, VT_OBSAVAILABLE, 4) &&
           VerifyField<int32_t>(verifier, VT_OBSUSED, 4) &&
           VerifyField<int32_t>(verifier, VT_TRACKSAVAIL, 4) &&
           VerifyField<int32_t>(verifier, VT_TRACKSUSED, 4) &&
           VerifyField<double>(verifier, VT_RECODSPAN, 8) &&
           VerifyField<double>(verifier, VT_ACTUALODSPAN, 8) &&
           VerifyField<double>(verifier, VT_RESIDUALSACC, 8) &&
           VerifyField<double>(verifier, VT_SOLARFLUXF10, 8) &&
           VerifyField<double>(verifier, VT_SOLARFLUXF10AVG, 8) &&
           VerifyField<double>(verifier, VT_SOLARFLUXAPAVG, 8) &&
           VerifyField<double>(verifier, VT_TAIUTC, 8) &&
           VerifyField<double>(verifier, VT_UT1UTC, 8) &&
           VerifyField<double>(verifier, VT_UT1RATE, 8) &&
           VerifyField<double>(verifier, VT_POLARMOTIONX, 8) &&
           VerifyField<double>(verifier, VT_POLARMOTIONY, 8) &&
           VerifyField<int32_t>(verifier, VT_IAU1980TERMS, 4) &&
           VerifyOffset(verifier, VT_LEAPSECONDTIME) &&
           verifier.VerifyString(leapSecondTime()) &&
           VerifyOffset(verifier, VT_INTEGRATORMODE) &&
           verifier.VerifyString(integratorMode()) &&
           VerifyOffset(verifier, VT_PARTIALS) &&
           verifier.VerifyString(partials()) &&
           VerifyOffset(verifier, VT_STEPMODE) &&
           verifier.VerifyString(stepMode()) &&
           VerifyField<uint8_t>(verifier, VT_FIXEDSTEP, 1) &&
           VerifyOffset(verifier, VT_STEPSIZESELECTION) &&
           verifier.VerifyString(stepSizeSelection()) &&
           VerifyField<double>(verifier, VT_STEPSIZE, 8) &&
           VerifyField<double>(verifier, VT_ERRORCONTROL, 8) &&
           VerifyOffset(verifier, VT_SIGMAPOSUVW) &&
           verifier.VerifyVector(sigmaPosUVW()) &&
           verifier.VerifyVectorOfStrings(sigmaPosUVW()) &&
           VerifyOffset(verifier, VT_SIGMAVELUVW) &&
           verifier.VerifyVector(sigmaVelUVW()) &&
           verifier.VerifyVectorOfStrings(sigmaVelUVW()) &&
           VerifyField<double>(verifier, VT_RMS, 8) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_ALGORITHM) &&
           verifier.VerifyString(algorithm()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_DESCRIPTOR) &&
           verifier.VerifyString(descriptor()) &&
           VerifyOffset(verifier, VT_TRANSACTIONID) &&
           verifier.VerifyString(transactionId()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyOffset(verifier, VT_SOURCEDL) &&
           verifier.VerifyString(sourceDL()) &&
           verifier.EndTable();
  }
};

struct StateVector_AbridgedBuilder {
  typedef StateVector_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_idStateVector(::flatbuffers::Offset<::flatbuffers::String> idStateVector) {
    fbb_.AddOffset(StateVector_Abridged::VT_IDSTATEVECTOR, idStateVector);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(StateVector_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_epoch(::flatbuffers::Offset<::flatbuffers::String> epoch) {
    fbb_.AddOffset(StateVector_Abridged::VT_EPOCH, epoch);
  }
  void add_pedigree(::flatbuffers::Offset<::flatbuffers::String> pedigree) {
    fbb_.AddOffset(StateVector_Abridged::VT_PEDIGREE, pedigree);
  }
  void add_idOnOrbit(::flatbuffers::Offset<::flatbuffers::String> idOnOrbit) {
    fbb_.AddOffset(StateVector_Abridged::VT_IDONORBIT, idOnOrbit);
  }
  void add_satNo(int32_t satNo) {
    fbb_.AddElement<int32_t>(StateVector_Abridged::VT_SATNO, satNo, 0);
  }
  void add_origObjectId(::flatbuffers::Offset<::flatbuffers::String> origObjectId) {
    fbb_.AddOffset(StateVector_Abridged::VT_ORIGOBJECTID, origObjectId);
  }
  void add_idOrbitDetermination(::flatbuffers::Offset<::flatbuffers::String> idOrbitDetermination) {
    fbb_.AddOffset(StateVector_Abridged::VT_IDORBITDETERMINATION, idOrbitDetermination);
  }
  void add_uct(bool uct) {
    fbb_.AddElement<uint8_t>(StateVector_Abridged::VT_UCT, static_cast<uint8_t>(uct), 0);
  }
  void add_xpos(double xpos) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_XPOS, xpos, 0.0);
  }
  void add_ypos(double ypos) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_YPOS, ypos, 0.0);
  }
  void add_zpos(double zpos) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_ZPOS, zpos, 0.0);
  }
  void add_xvel(double xvel) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_XVEL, xvel, 0.0);
  }
  void add_yvel(double yvel) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_YVEL, yvel, 0.0);
  }
  void add_zvel(double zvel) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_ZVEL, zvel, 0.0);
  }
  void add_referenceFrame(StateVector_Abridged_referenceFrame_Enum referenceFrame) {
    fbb_.AddElement<int8_t>(StateVector_Abridged::VT_REFERENCEFRAME, static_cast<int8_t>(referenceFrame), 0);
  }
  void add_cov(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cov) {
    fbb_.AddOffset(StateVector_Abridged::VT_COV, cov);
  }
  void add_covReferenceFrame(StateVector_Abridged_covReferenceFrame_Enum covReferenceFrame) {
    fbb_.AddElement<int8_t>(StateVector_Abridged::VT_COVREFERENCEFRAME, static_cast<int8_t>(covReferenceFrame), 0);
  }
  void add_covMethod(::flatbuffers::Offset<::flatbuffers::String> covMethod) {
    fbb_.AddOffset(StateVector_Abridged::VT_COVMETHOD, covMethod);
  }
  void add_eqCov(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> eqCov) {
    fbb_.AddOffset(StateVector_Abridged::VT_EQCOV, eqCov);
  }
  void add_xposAlt1(double xposAlt1) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_XPOSALT1, xposAlt1, 0.0);
  }
  void add_yposAlt1(double yposAlt1) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_YPOSALT1, yposAlt1, 0.0);
  }
  void add_zposAlt1(double zposAlt1) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_ZPOSALT1, zposAlt1, 0.0);
  }
  void add_xvelAlt1(double xvelAlt1) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_XVELALT1, xvelAlt1, 0.0);
  }
  void add_yvelAlt1(double yvelAlt1) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_YVELALT1, yvelAlt1, 0.0);
  }
  void add_zvelAlt1(double zvelAlt1) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_ZVELALT1, zvelAlt1, 0.0);
  }
  void add_alt1ReferenceFrame(::flatbuffers::Offset<::flatbuffers::String> alt1ReferenceFrame) {
    fbb_.AddOffset(StateVector_Abridged::VT_ALT1REFERENCEFRAME, alt1ReferenceFrame);
  }
  void add_xposAlt2(double xposAlt2) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_XPOSALT2, xposAlt2, 0.0);
  }
  void add_yposAlt2(double yposAlt2) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_YPOSALT2, yposAlt2, 0.0);
  }
  void add_zposAlt2(double zposAlt2) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_ZPOSALT2, zposAlt2, 0.0);
  }
  void add_xvelAlt2(double xvelAlt2) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_XVELALT2, xvelAlt2, 0.0);
  }
  void add_yvelAlt2(double yvelAlt2) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_YVELALT2, yvelAlt2, 0.0);
  }
  void add_zvelAlt2(double zvelAlt2) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_ZVELALT2, zvelAlt2, 0.0);
  }
  void add_alt2ReferenceFrame(::flatbuffers::Offset<::flatbuffers::String> alt2ReferenceFrame) {
    fbb_.AddOffset(StateVector_Abridged::VT_ALT2REFERENCEFRAME, alt2ReferenceFrame);
  }
  void add_posUnc(double posUnc) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_POSUNC, posUnc, 0.0);
  }
  void add_velUnc(double velUnc) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_VELUNC, velUnc, 0.0);
  }
  void add_mass(double mass) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_MASS, mass, 0.0);
  }
  void add_area(double area) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_AREA, area, 0.0);
  }
  void add_solarRadPressCoeff(double solarRadPressCoeff) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_SOLARRADPRESSCOEFF, solarRadPressCoeff, 0.0);
  }
  void add_dragCoeff(double dragCoeff) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_DRAGCOEFF, dragCoeff, 0.0);
  }
  void add_dragArea(double dragArea) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_DRAGAREA, dragArea, 0.0);
  }
  void add_revNo(int32_t revNo) {
    fbb_.AddElement<int32_t>(StateVector_Abridged::VT_REVNO, revNo, 0);
  }
  void add_geopotentialModel(::flatbuffers::Offset<::flatbuffers::String> geopotentialModel) {
    fbb_.AddOffset(StateVector_Abridged::VT_GEOPOTENTIALMODEL, geopotentialModel);
  }
  void add_dragModel(::flatbuffers::Offset<::flatbuffers::String> dragModel) {
    fbb_.AddOffset(StateVector_Abridged::VT_DRAGMODEL, dragModel);
  }
  void add_lunarSolar(bool lunarSolar) {
    fbb_.AddElement<uint8_t>(StateVector_Abridged::VT_LUNARSOLAR, static_cast<uint8_t>(lunarSolar), 0);
  }
  void add_solarRadPress(bool solarRadPress) {
    fbb_.AddElement<uint8_t>(StateVector_Abridged::VT_SOLARRADPRESS, static_cast<uint8_t>(solarRadPress), 0);
  }
  void add_srpArea(double srpArea) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_SRPAREA, srpArea, 0.0);
  }
  void add_solidEarthTides(bool solidEarthTides) {
    fbb_.AddElement<uint8_t>(StateVector_Abridged::VT_SOLIDEARTHTIDES, static_cast<uint8_t>(solidEarthTides), 0);
  }
  void add_inTrackThrust(bool inTrackThrust) {
    fbb_.AddElement<uint8_t>(StateVector_Abridged::VT_INTRACKTHRUST, static_cast<uint8_t>(inTrackThrust), 0);
  }
  void add_bDot(double bDot) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_BDOT, bDot, 0.0);
  }
  void add_edr(double edr) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_EDR, edr, 0.0);
  }
  void add_thrustAccel(double thrustAccel) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_THRUSTACCEL, thrustAccel, 0.0);
  }
  void add_cmOffset(double cmOffset) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_CMOFFSET, cmOffset, 0.0);
  }
  void add_lastObStart(::flatbuffers::Offset<::flatbuffers::String> lastObStart) {
    fbb_.AddOffset(StateVector_Abridged::VT_LASTOBSTART, lastObStart);
  }
  void add_lastObEnd(::flatbuffers::Offset<::flatbuffers::String> lastObEnd) {
    fbb_.AddOffset(StateVector_Abridged::VT_LASTOBEND, lastObEnd);
  }
  void add_obsAvailable(int32_t obsAvailable) {
    fbb_.AddElement<int32_t>(StateVector_Abridged::VT_OBSAVAILABLE, obsAvailable, 0);
  }
  void add_obsUsed(int32_t obsUsed) {
    fbb_.AddElement<int32_t>(StateVector_Abridged::VT_OBSUSED, obsUsed, 0);
  }
  void add_tracksAvail(int32_t tracksAvail) {
    fbb_.AddElement<int32_t>(StateVector_Abridged::VT_TRACKSAVAIL, tracksAvail, 0);
  }
  void add_tracksUsed(int32_t tracksUsed) {
    fbb_.AddElement<int32_t>(StateVector_Abridged::VT_TRACKSUSED, tracksUsed, 0);
  }
  void add_recODSpan(double recODSpan) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_RECODSPAN, recODSpan, 0.0);
  }
  void add_actualODSpan(double actualODSpan) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_ACTUALODSPAN, actualODSpan, 0.0);
  }
  void add_residualsAcc(double residualsAcc) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_RESIDUALSACC, residualsAcc, 0.0);
  }
  void add_solarFluxF10(double solarFluxF10) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_SOLARFLUXF10, solarFluxF10, 0.0);
  }
  void add_solarFluxF10Avg(double solarFluxF10Avg) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_SOLARFLUXF10AVG, solarFluxF10Avg, 0.0);
  }
  void add_solarFluxAPAvg(double solarFluxAPAvg) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_SOLARFLUXAPAVG, solarFluxAPAvg, 0.0);
  }
  void add_taiUtc(double taiUtc) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_TAIUTC, taiUtc, 0.0);
  }
  void add_ut1Utc(double ut1Utc) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_UT1UTC, ut1Utc, 0.0);
  }
  void add_ut1Rate(double ut1Rate) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_UT1RATE, ut1Rate, 0.0);
  }
  void add_polarMotionX(double polarMotionX) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_POLARMOTIONX, polarMotionX, 0.0);
  }
  void add_polarMotionY(double polarMotionY) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_POLARMOTIONY, polarMotionY, 0.0);
  }
  void add_iau1980Terms(int32_t iau1980Terms) {
    fbb_.AddElement<int32_t>(StateVector_Abridged::VT_IAU1980TERMS, iau1980Terms, 0);
  }
  void add_leapSecondTime(::flatbuffers::Offset<::flatbuffers::String> leapSecondTime) {
    fbb_.AddOffset(StateVector_Abridged::VT_LEAPSECONDTIME, leapSecondTime);
  }
  void add_integratorMode(::flatbuffers::Offset<::flatbuffers::String> integratorMode) {
    fbb_.AddOffset(StateVector_Abridged::VT_INTEGRATORMODE, integratorMode);
  }
  void add_partials(::flatbuffers::Offset<::flatbuffers::String> partials) {
    fbb_.AddOffset(StateVector_Abridged::VT_PARTIALS, partials);
  }
  void add_stepMode(::flatbuffers::Offset<::flatbuffers::String> stepMode) {
    fbb_.AddOffset(StateVector_Abridged::VT_STEPMODE, stepMode);
  }
  void add_fixedStep(bool fixedStep) {
    fbb_.AddElement<uint8_t>(StateVector_Abridged::VT_FIXEDSTEP, static_cast<uint8_t>(fixedStep), 0);
  }
  void add_stepSizeSelection(::flatbuffers::Offset<::flatbuffers::String> stepSizeSelection) {
    fbb_.AddOffset(StateVector_Abridged::VT_STEPSIZESELECTION, stepSizeSelection);
  }
  void add_stepSize(double stepSize) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_STEPSIZE, stepSize, 0.0);
  }
  void add_errorControl(double errorControl) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_ERRORCONTROL, errorControl, 0.0);
  }
  void add_sigmaPosUVW(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> sigmaPosUVW) {
    fbb_.AddOffset(StateVector_Abridged::VT_SIGMAPOSUVW, sigmaPosUVW);
  }
  void add_sigmaVelUVW(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> sigmaVelUVW) {
    fbb_.AddOffset(StateVector_Abridged::VT_SIGMAVELUVW, sigmaVelUVW);
  }
  void add_rms(double rms) {
    fbb_.AddElement<double>(StateVector_Abridged::VT_RMS, rms, 0.0);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(StateVector_Abridged::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(StateVector_Abridged::VT_ORIGIN, origin);
  }
  void add_dataMode(StateVector_Abridged_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(StateVector_Abridged::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_algorithm(::flatbuffers::Offset<::flatbuffers::String> algorithm) {
    fbb_.AddOffset(StateVector_Abridged::VT_ALGORITHM, algorithm);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(StateVector_Abridged::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(StateVector_Abridged::VT_CREATEDBY, createdBy);
  }
  void add_descriptor(::flatbuffers::Offset<::flatbuffers::String> descriptor) {
    fbb_.AddOffset(StateVector_Abridged::VT_DESCRIPTOR, descriptor);
  }
  void add_transactionId(::flatbuffers::Offset<::flatbuffers::String> transactionId) {
    fbb_.AddOffset(StateVector_Abridged::VT_TRANSACTIONID, transactionId);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(StateVector_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  void add_sourceDL(::flatbuffers::Offset<::flatbuffers::String> sourceDL) {
    fbb_.AddOffset(StateVector_Abridged::VT_SOURCEDL, sourceDL);
  }
  explicit StateVector_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StateVector_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StateVector_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StateVector_Abridged> CreateStateVector_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> idStateVector = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> epoch = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pedigree = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idOnOrbit = 0,
    int32_t satNo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origObjectId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idOrbitDetermination = 0,
    bool uct = false,
    double xpos = 0.0,
    double ypos = 0.0,
    double zpos = 0.0,
    double xvel = 0.0,
    double yvel = 0.0,
    double zvel = 0.0,
    StateVector_Abridged_referenceFrame_Enum referenceFrame = StateVector_Abridged_referenceFrame_Enum_J2000,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cov = 0,
    StateVector_Abridged_covReferenceFrame_Enum covReferenceFrame = StateVector_Abridged_covReferenceFrame_Enum_J2000,
    ::flatbuffers::Offset<::flatbuffers::String> covMethod = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> eqCov = 0,
    double xposAlt1 = 0.0,
    double yposAlt1 = 0.0,
    double zposAlt1 = 0.0,
    double xvelAlt1 = 0.0,
    double yvelAlt1 = 0.0,
    double zvelAlt1 = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> alt1ReferenceFrame = 0,
    double xposAlt2 = 0.0,
    double yposAlt2 = 0.0,
    double zposAlt2 = 0.0,
    double xvelAlt2 = 0.0,
    double yvelAlt2 = 0.0,
    double zvelAlt2 = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> alt2ReferenceFrame = 0,
    double posUnc = 0.0,
    double velUnc = 0.0,
    double mass = 0.0,
    double area = 0.0,
    double solarRadPressCoeff = 0.0,
    double dragCoeff = 0.0,
    double dragArea = 0.0,
    int32_t revNo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> geopotentialModel = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dragModel = 0,
    bool lunarSolar = false,
    bool solarRadPress = false,
    double srpArea = 0.0,
    bool solidEarthTides = false,
    bool inTrackThrust = false,
    double bDot = 0.0,
    double edr = 0.0,
    double thrustAccel = 0.0,
    double cmOffset = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> lastObStart = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastObEnd = 0,
    int32_t obsAvailable = 0,
    int32_t obsUsed = 0,
    int32_t tracksAvail = 0,
    int32_t tracksUsed = 0,
    double recODSpan = 0.0,
    double actualODSpan = 0.0,
    double residualsAcc = 0.0,
    double solarFluxF10 = 0.0,
    double solarFluxF10Avg = 0.0,
    double solarFluxAPAvg = 0.0,
    double taiUtc = 0.0,
    double ut1Utc = 0.0,
    double ut1Rate = 0.0,
    double polarMotionX = 0.0,
    double polarMotionY = 0.0,
    int32_t iau1980Terms = 0,
    ::flatbuffers::Offset<::flatbuffers::String> leapSecondTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> integratorMode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> partials = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stepMode = 0,
    bool fixedStep = false,
    ::flatbuffers::Offset<::flatbuffers::String> stepSizeSelection = 0,
    double stepSize = 0.0,
    double errorControl = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> sigmaPosUVW = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> sigmaVelUVW = 0,
    double rms = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    StateVector_Abridged_dataMode_Enum dataMode = StateVector_Abridged_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> algorithm = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> descriptor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> transactionId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceDL = 0) {
  StateVector_AbridgedBuilder builder_(_fbb);
  builder_.add_rms(rms);
  builder_.add_errorControl(errorControl);
  builder_.add_stepSize(stepSize);
  builder_.add_polarMotionY(polarMotionY);
  builder_.add_polarMotionX(polarMotionX);
  builder_.add_ut1Rate(ut1Rate);
  builder_.add_ut1Utc(ut1Utc);
  builder_.add_taiUtc(taiUtc);
  builder_.add_solarFluxAPAvg(solarFluxAPAvg);
  builder_.add_solarFluxF10Avg(solarFluxF10Avg);
  builder_.add_solarFluxF10(solarFluxF10);
  builder_.add_residualsAcc(residualsAcc);
  builder_.add_actualODSpan(actualODSpan);
  builder_.add_recODSpan(recODSpan);
  builder_.add_cmOffset(cmOffset);
  builder_.add_thrustAccel(thrustAccel);
  builder_.add_edr(edr);
  builder_.add_bDot(bDot);
  builder_.add_srpArea(srpArea);
  builder_.add_dragArea(dragArea);
  builder_.add_dragCoeff(dragCoeff);
  builder_.add_solarRadPressCoeff(solarRadPressCoeff);
  builder_.add_area(area);
  builder_.add_mass(mass);
  builder_.add_velUnc(velUnc);
  builder_.add_posUnc(posUnc);
  builder_.add_zvelAlt2(zvelAlt2);
  builder_.add_yvelAlt2(yvelAlt2);
  builder_.add_xvelAlt2(xvelAlt2);
  builder_.add_zposAlt2(zposAlt2);
  builder_.add_yposAlt2(yposAlt2);
  builder_.add_xposAlt2(xposAlt2);
  builder_.add_zvelAlt1(zvelAlt1);
  builder_.add_yvelAlt1(yvelAlt1);
  builder_.add_xvelAlt1(xvelAlt1);
  builder_.add_zposAlt1(zposAlt1);
  builder_.add_yposAlt1(yposAlt1);
  builder_.add_xposAlt1(xposAlt1);
  builder_.add_zvel(zvel);
  builder_.add_yvel(yvel);
  builder_.add_xvel(xvel);
  builder_.add_zpos(zpos);
  builder_.add_ypos(ypos);
  builder_.add_xpos(xpos);
  builder_.add_sourceDL(sourceDL);
  builder_.add_origNetwork(origNetwork);
  builder_.add_transactionId(transactionId);
  builder_.add_descriptor(descriptor);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_algorithm(algorithm);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_sigmaVelUVW(sigmaVelUVW);
  builder_.add_sigmaPosUVW(sigmaPosUVW);
  builder_.add_stepSizeSelection(stepSizeSelection);
  builder_.add_stepMode(stepMode);
  builder_.add_partials(partials);
  builder_.add_integratorMode(integratorMode);
  builder_.add_leapSecondTime(leapSecondTime);
  builder_.add_iau1980Terms(iau1980Terms);
  builder_.add_tracksUsed(tracksUsed);
  builder_.add_tracksAvail(tracksAvail);
  builder_.add_obsUsed(obsUsed);
  builder_.add_obsAvailable(obsAvailable);
  builder_.add_lastObEnd(lastObEnd);
  builder_.add_lastObStart(lastObStart);
  builder_.add_dragModel(dragModel);
  builder_.add_geopotentialModel(geopotentialModel);
  builder_.add_revNo(revNo);
  builder_.add_alt2ReferenceFrame(alt2ReferenceFrame);
  builder_.add_alt1ReferenceFrame(alt1ReferenceFrame);
  builder_.add_eqCov(eqCov);
  builder_.add_covMethod(covMethod);
  builder_.add_cov(cov);
  builder_.add_idOrbitDetermination(idOrbitDetermination);
  builder_.add_origObjectId(origObjectId);
  builder_.add_satNo(satNo);
  builder_.add_idOnOrbit(idOnOrbit);
  builder_.add_pedigree(pedigree);
  builder_.add_epoch(epoch);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_idStateVector(idStateVector);
  builder_.add_dataMode(dataMode);
  builder_.add_fixedStep(fixedStep);
  builder_.add_inTrackThrust(inTrackThrust);
  builder_.add_solidEarthTides(solidEarthTides);
  builder_.add_solarRadPress(solarRadPress);
  builder_.add_lunarSolar(lunarSolar);
  builder_.add_covReferenceFrame(covReferenceFrame);
  builder_.add_referenceFrame(referenceFrame);
  builder_.add_uct(uct);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StateVector_Abridged> CreateStateVector_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *idStateVector = nullptr,
    const char *classificationMarking = nullptr,
    const char *epoch = nullptr,
    const char *pedigree = nullptr,
    const char *idOnOrbit = nullptr,
    int32_t satNo = 0,
    const char *origObjectId = nullptr,
    const char *idOrbitDetermination = nullptr,
    bool uct = false,
    double xpos = 0.0,
    double ypos = 0.0,
    double zpos = 0.0,
    double xvel = 0.0,
    double yvel = 0.0,
    double zvel = 0.0,
    StateVector_Abridged_referenceFrame_Enum referenceFrame = StateVector_Abridged_referenceFrame_Enum_J2000,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *cov = nullptr,
    StateVector_Abridged_covReferenceFrame_Enum covReferenceFrame = StateVector_Abridged_covReferenceFrame_Enum_J2000,
    const char *covMethod = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *eqCov = nullptr,
    double xposAlt1 = 0.0,
    double yposAlt1 = 0.0,
    double zposAlt1 = 0.0,
    double xvelAlt1 = 0.0,
    double yvelAlt1 = 0.0,
    double zvelAlt1 = 0.0,
    const char *alt1ReferenceFrame = nullptr,
    double xposAlt2 = 0.0,
    double yposAlt2 = 0.0,
    double zposAlt2 = 0.0,
    double xvelAlt2 = 0.0,
    double yvelAlt2 = 0.0,
    double zvelAlt2 = 0.0,
    const char *alt2ReferenceFrame = nullptr,
    double posUnc = 0.0,
    double velUnc = 0.0,
    double mass = 0.0,
    double area = 0.0,
    double solarRadPressCoeff = 0.0,
    double dragCoeff = 0.0,
    double dragArea = 0.0,
    int32_t revNo = 0,
    const char *geopotentialModel = nullptr,
    const char *dragModel = nullptr,
    bool lunarSolar = false,
    bool solarRadPress = false,
    double srpArea = 0.0,
    bool solidEarthTides = false,
    bool inTrackThrust = false,
    double bDot = 0.0,
    double edr = 0.0,
    double thrustAccel = 0.0,
    double cmOffset = 0.0,
    const char *lastObStart = nullptr,
    const char *lastObEnd = nullptr,
    int32_t obsAvailable = 0,
    int32_t obsUsed = 0,
    int32_t tracksAvail = 0,
    int32_t tracksUsed = 0,
    double recODSpan = 0.0,
    double actualODSpan = 0.0,
    double residualsAcc = 0.0,
    double solarFluxF10 = 0.0,
    double solarFluxF10Avg = 0.0,
    double solarFluxAPAvg = 0.0,
    double taiUtc = 0.0,
    double ut1Utc = 0.0,
    double ut1Rate = 0.0,
    double polarMotionX = 0.0,
    double polarMotionY = 0.0,
    int32_t iau1980Terms = 0,
    const char *leapSecondTime = nullptr,
    const char *integratorMode = nullptr,
    const char *partials = nullptr,
    const char *stepMode = nullptr,
    bool fixedStep = false,
    const char *stepSizeSelection = nullptr,
    double stepSize = 0.0,
    double errorControl = 0.0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *sigmaPosUVW = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *sigmaVelUVW = nullptr,
    double rms = 0.0,
    const char *source = nullptr,
    const char *origin = nullptr,
    StateVector_Abridged_dataMode_Enum dataMode = StateVector_Abridged_dataMode_Enum_REAL,
    const char *algorithm = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *descriptor = nullptr,
    const char *transactionId = nullptr,
    const char *origNetwork = nullptr,
    const char *sourceDL = nullptr) {
  auto idStateVector__ = idStateVector ? _fbb.CreateString(idStateVector) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto epoch__ = epoch ? _fbb.CreateString(epoch) : 0;
  auto pedigree__ = pedigree ? _fbb.CreateString(pedigree) : 0;
  auto idOnOrbit__ = idOnOrbit ? _fbb.CreateString(idOnOrbit) : 0;
  auto origObjectId__ = origObjectId ? _fbb.CreateString(origObjectId) : 0;
  auto idOrbitDetermination__ = idOrbitDetermination ? _fbb.CreateString(idOrbitDetermination) : 0;
  auto cov__ = cov ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*cov) : 0;
  auto covMethod__ = covMethod ? _fbb.CreateString(covMethod) : 0;
  auto eqCov__ = eqCov ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*eqCov) : 0;
  auto alt1ReferenceFrame__ = alt1ReferenceFrame ? _fbb.CreateString(alt1ReferenceFrame) : 0;
  auto alt2ReferenceFrame__ = alt2ReferenceFrame ? _fbb.CreateString(alt2ReferenceFrame) : 0;
  auto geopotentialModel__ = geopotentialModel ? _fbb.CreateString(geopotentialModel) : 0;
  auto dragModel__ = dragModel ? _fbb.CreateString(dragModel) : 0;
  auto lastObStart__ = lastObStart ? _fbb.CreateString(lastObStart) : 0;
  auto lastObEnd__ = lastObEnd ? _fbb.CreateString(lastObEnd) : 0;
  auto leapSecondTime__ = leapSecondTime ? _fbb.CreateString(leapSecondTime) : 0;
  auto integratorMode__ = integratorMode ? _fbb.CreateString(integratorMode) : 0;
  auto partials__ = partials ? _fbb.CreateString(partials) : 0;
  auto stepMode__ = stepMode ? _fbb.CreateString(stepMode) : 0;
  auto stepSizeSelection__ = stepSizeSelection ? _fbb.CreateString(stepSizeSelection) : 0;
  auto sigmaPosUVW__ = sigmaPosUVW ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*sigmaPosUVW) : 0;
  auto sigmaVelUVW__ = sigmaVelUVW ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*sigmaVelUVW) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto algorithm__ = algorithm ? _fbb.CreateString(algorithm) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto descriptor__ = descriptor ? _fbb.CreateString(descriptor) : 0;
  auto transactionId__ = transactionId ? _fbb.CreateString(transactionId) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto sourceDL__ = sourceDL ? _fbb.CreateString(sourceDL) : 0;
  return CreateStateVector_Abridged(
      _fbb,
      idStateVector__,
      classificationMarking__,
      epoch__,
      pedigree__,
      idOnOrbit__,
      satNo,
      origObjectId__,
      idOrbitDetermination__,
      uct,
      xpos,
      ypos,
      zpos,
      xvel,
      yvel,
      zvel,
      referenceFrame,
      cov__,
      covReferenceFrame,
      covMethod__,
      eqCov__,
      xposAlt1,
      yposAlt1,
      zposAlt1,
      xvelAlt1,
      yvelAlt1,
      zvelAlt1,
      alt1ReferenceFrame__,
      xposAlt2,
      yposAlt2,
      zposAlt2,
      xvelAlt2,
      yvelAlt2,
      zvelAlt2,
      alt2ReferenceFrame__,
      posUnc,
      velUnc,
      mass,
      area,
      solarRadPressCoeff,
      dragCoeff,
      dragArea,
      revNo,
      geopotentialModel__,
      dragModel__,
      lunarSolar,
      solarRadPress,
      srpArea,
      solidEarthTides,
      inTrackThrust,
      bDot,
      edr,
      thrustAccel,
      cmOffset,
      lastObStart__,
      lastObEnd__,
      obsAvailable,
      obsUsed,
      tracksAvail,
      tracksUsed,
      recODSpan,
      actualODSpan,
      residualsAcc,
      solarFluxF10,
      solarFluxF10Avg,
      solarFluxAPAvg,
      taiUtc,
      ut1Utc,
      ut1Rate,
      polarMotionX,
      polarMotionY,
      iau1980Terms,
      leapSecondTime__,
      integratorMode__,
      partials__,
      stepMode__,
      fixedStep,
      stepSizeSelection__,
      stepSize,
      errorControl,
      sigmaPosUVW__,
      sigmaVelUVW__,
      rms,
      source__,
      origin__,
      dataMode,
      algorithm__,
      createdAt__,
      createdBy__,
      descriptor__,
      transactionId__,
      origNetwork__,
      sourceDL__);
}

inline const StateVector_Abridged *GetStateVector_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<StateVector_Abridged>(buf);
}

inline const StateVector_Abridged *GetSizePrefixedStateVector_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<StateVector_Abridged>(buf);
}

inline const char *StateVector_AbridgedIdentifier() {
  return "STAT";
}

inline bool StateVector_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, StateVector_AbridgedIdentifier());
}

inline bool SizePrefixedStateVector_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, StateVector_AbridgedIdentifier(), true);
}

inline bool VerifyStateVector_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<StateVector_Abridged>(StateVector_AbridgedIdentifier());
}

inline bool VerifySizePrefixedStateVector_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<StateVector_Abridged>(StateVector_AbridgedIdentifier());
}

inline void FinishStateVector_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<StateVector_Abridged> root) {
  fbb.Finish(root, StateVector_AbridgedIdentifier());
}

inline void FinishSizePrefixedStateVector_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<StateVector_Abridged> root) {
  fbb.FinishSizePrefixed(root, StateVector_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
