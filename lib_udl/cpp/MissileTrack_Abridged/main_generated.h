// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct MissileTrack_Abridged;
struct MissileTrack_AbridgedBuilder;

enum MissileTrack_Abridged_env_Enum : int8_t {
  /// Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
  MissileTrack_Abridged_env_Enum_AIR = 0,
  /// On the surface of dry land.
  MissileTrack_Abridged_env_Enum_LAND = 1,
  /// Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
  MissileTrack_Abridged_env_Enum_SPACE = 2,
  /// On the surface of a body of water.
  MissileTrack_Abridged_env_Enum_SURFACE = 3,
  /// Below the surface of a body of water.
  MissileTrack_Abridged_env_Enum_SUBSURFACE = 4,
  /// Environment is not known.
  MissileTrack_Abridged_env_Enum_UNKNOWN = 5,
  MissileTrack_Abridged_env_Enum_MIN = MissileTrack_Abridged_env_Enum_AIR,
  MissileTrack_Abridged_env_Enum_MAX = MissileTrack_Abridged_env_Enum_UNKNOWN
};

inline const MissileTrack_Abridged_env_Enum (&EnumValuesMissileTrack_Abridged_env_Enum())[6] {
  static const MissileTrack_Abridged_env_Enum values[] = {
    MissileTrack_Abridged_env_Enum_AIR,
    MissileTrack_Abridged_env_Enum_LAND,
    MissileTrack_Abridged_env_Enum_SPACE,
    MissileTrack_Abridged_env_Enum_SURFACE,
    MissileTrack_Abridged_env_Enum_SUBSURFACE,
    MissileTrack_Abridged_env_Enum_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesMissileTrack_Abridged_env_Enum() {
  static const char * const names[7] = {
    "AIR",
    "LAND",
    "SPACE",
    "SURFACE",
    "SUBSURFACE",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameMissileTrack_Abridged_env_Enum(MissileTrack_Abridged_env_Enum e) {
  if (::flatbuffers::IsOutRange(e, MissileTrack_Abridged_env_Enum_AIR, MissileTrack_Abridged_env_Enum_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMissileTrack_Abridged_env_Enum()[index];
}

enum MissileTrack_Abridged_objIdent_Enum : int8_t {
  /// Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  MissileTrack_Abridged_objIdent_Enum_ASSUMED_FRIEND = 0,
  /// Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  MissileTrack_Abridged_objIdent_Enum_FRIEND = 1,
  /// Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  MissileTrack_Abridged_objIdent_Enum_HOSTILE = 2,
  /// Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  MissileTrack_Abridged_objIdent_Enum_NEUTRAL = 3,
  /// Track object which has not been evaluated.
  MissileTrack_Abridged_objIdent_Enum_PENDING = 4,
  /// Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  MissileTrack_Abridged_objIdent_Enum_SUSPECT = 5,
  /// Track object which has been evaluated and does not meet criteria for any standard identity.
  MissileTrack_Abridged_objIdent_Enum_UNKNOWN = 6,
  MissileTrack_Abridged_objIdent_Enum_MIN = MissileTrack_Abridged_objIdent_Enum_ASSUMED_FRIEND,
  MissileTrack_Abridged_objIdent_Enum_MAX = MissileTrack_Abridged_objIdent_Enum_UNKNOWN
};

inline const MissileTrack_Abridged_objIdent_Enum (&EnumValuesMissileTrack_Abridged_objIdent_Enum())[7] {
  static const MissileTrack_Abridged_objIdent_Enum values[] = {
    MissileTrack_Abridged_objIdent_Enum_ASSUMED_FRIEND,
    MissileTrack_Abridged_objIdent_Enum_FRIEND,
    MissileTrack_Abridged_objIdent_Enum_HOSTILE,
    MissileTrack_Abridged_objIdent_Enum_NEUTRAL,
    MissileTrack_Abridged_objIdent_Enum_PENDING,
    MissileTrack_Abridged_objIdent_Enum_SUSPECT,
    MissileTrack_Abridged_objIdent_Enum_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesMissileTrack_Abridged_objIdent_Enum() {
  static const char * const names[8] = {
    "ASSUMED_FRIEND",
    "FRIEND",
    "HOSTILE",
    "NEUTRAL",
    "PENDING",
    "SUSPECT",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameMissileTrack_Abridged_objIdent_Enum(MissileTrack_Abridged_objIdent_Enum e) {
  if (::flatbuffers::IsOutRange(e, MissileTrack_Abridged_objIdent_Enum_ASSUMED_FRIEND, MissileTrack_Abridged_objIdent_Enum_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMissileTrack_Abridged_objIdent_Enum()[index];
}

enum MissileTrack_Abridged_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  MissileTrack_Abridged_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  MissileTrack_Abridged_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  MissileTrack_Abridged_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  MissileTrack_Abridged_dataMode_Enum_EXERCISE = 3,
  MissileTrack_Abridged_dataMode_Enum_MIN = MissileTrack_Abridged_dataMode_Enum_REAL,
  MissileTrack_Abridged_dataMode_Enum_MAX = MissileTrack_Abridged_dataMode_Enum_EXERCISE
};

inline const MissileTrack_Abridged_dataMode_Enum (&EnumValuesMissileTrack_Abridged_dataMode_Enum())[4] {
  static const MissileTrack_Abridged_dataMode_Enum values[] = {
    MissileTrack_Abridged_dataMode_Enum_REAL,
    MissileTrack_Abridged_dataMode_Enum_TEST,
    MissileTrack_Abridged_dataMode_Enum_SIMULATED,
    MissileTrack_Abridged_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesMissileTrack_Abridged_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameMissileTrack_Abridged_dataMode_Enum(MissileTrack_Abridged_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, MissileTrack_Abridged_dataMode_Enum_REAL, MissileTrack_Abridged_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMissileTrack_Abridged_dataMode_Enum()[index];
}

/// /// These services provide operations for querying of all available missile track details and amplifying missile data. A missile track is a position and optionally a heading/velocity of an object across all environments at a particular timestamp. It also includes optional information regarding the identity/type of missile, impact location, launch location and other amplifying object data, if known.
struct MissileTrack_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MissileTrack_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_MSGTYPE = 8,
    VT_MSGSUBTYPE = 10,
    VT_MSGCREATEDATE = 12,
    VT_ENV = 14,
    VT_OBJTYPE = 16,
    VT_OBJTYPECONF = 18,
    VT_OBJPLAT = 20,
    VT_OBJIDENT = 22,
    VT_SPACEAMP = 24,
    VT_OBJACT = 26,
    VT_SPACESPECTYPE = 28,
    VT_ACFTSUBTYPE = 30,
    VT_NAME = 32,
    VT_CALLSIGN = 34,
    VT_LOSTTRKIND = 36,
    VT_TRACKID = 38,
    VT_PARENTTRACKID = 40,
    VT_MUIDSRCTRK = 42,
    VT_MUIDSRC = 44,
    VT_ALERT = 46,
    VT_MSLSTATUS = 48,
    VT_TS = 50,
    VT_AOURPTTYPE = 52,
    VT_AOURPTDATA = 54,
    VT_CONTAINMENT = 56,
    VT_TRKCONF = 58,
    VT_TRKQUAL = 60,
    VT_ANGELEV = 62,
    VT_SENMODE = 64,
    VT_INFOSOURCE = 66,
    VT_BOOSTING = 68,
    VT_POLARSINGLOCLAT = 70,
    VT_POLARSINGLOCLON = 72,
    VT_EMGIND = 74,
    VT_DROPPTIND = 76,
    VT_SPACEAMPCONF = 78,
    VT_LAUNCHTIME = 80,
    VT_LAUNCHLAT = 82,
    VT_LAUNCHLON = 84,
    VT_AZCORR = 86,
    VT_BURNOUTALT = 88,
    VT_LAUNCHAOUTYPE = 90,
    VT_LAUNCHAOUDATA = 92,
    VT_IMPACTTIME = 94,
    VT_IMPACTLAT = 96,
    VT_IMPACTLON = 98,
    VT_IMPACTAOUTYPE = 100,
    VT_IMPACTAOUDATA = 102,
    VT_VECTORS = 104,
    VT_ORIGNETWORK = 106,
    VT_CREATEDAT = 108,
    VT_CREATEDBY = 110,
    VT_SOURCE = 112,
    VT_ORIGIN = 114,
    VT_DATAMODE = 116
  };
  /// Unique identifier of the record, auto-generated by the system if not provided on create operations.
  /// Example: /// Example: MissileTrack_ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The type of external message from which this request originated.
  /// Example: /// Example: MSG-TYPE
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *msgType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSGTYPE);
  }
  /// The message subtype is a finer grain categorization of message types as many messages can contain a variety of data content within the same structure.  Examples include but are not limited to Initial, Final, Launch, Update, etc.  Users should consult the appropriate documentation, based on the message type, for the definitions of the subtypes that apply to that message.
  /// Example: /// Example: Update
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *msgSubType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSGSUBTYPE);
  }
  /// The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-04-25T08:17:01.346Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *msgCreateDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSGCREATEDATE);
  }
  /// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
  ///  AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///  LAND: On the surface of dry land.
  ///  SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
  ///  SURFACE: On the surface of a body of water.
  ///  SUBSURFACE: Below the surface of a body of water.
  ///  UNKNOWN: Environment is not known.
  /// Example: /// Example: AIR
  /// Constraints: Minimum length = 0, Maximum length = 16
  MissileTrack_Abridged_env_Enum env() const {
    return static_cast<MissileTrack_Abridged_env_Enum>(GetField<int8_t>(VT_ENV, 0));
  }
  /// The type of object to which this record refers. The object type may be updated in later records based on assessment of additional data.
  /// Example: /// Example: Ballistic
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *objType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJTYPE);
  }
  /// Confidence of the object type, 0-100.
  /// Example: /// Example: 90
  /// Constraints: No constraints specified.
  int32_t objTypeConf() const {
    return GetField<int32_t>(VT_OBJTYPECONF, 0);
  }
  /// Space Platform field along with the Space Activity field further defines the identity of a Space track (examples: SATELLITE, WEAPON, PATROL). The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
  /// Example: /// Example: WEAPON
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *objPlat() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJPLAT);
  }
  /// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
  ///  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  ///  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  ///  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  ///  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  ///  PENDING: Track object which has not been evaluated.
  ///  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  ///  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
  /// Example: /// Example: FRIEND
  /// Constraints: Minimum length = 0, Maximum length = 32
  MissileTrack_Abridged_objIdent_Enum objIdent() const {
    return static_cast<MissileTrack_Abridged_objIdent_Enum>(GetField<int8_t>(VT_OBJIDENT, 0));
  }
  /// Space amplification indicates additional information on the space environment being reported (examples: NUCLEAR WARHEAD, FUEL-AIR EXPLOSIVE WARHEAD, DEBRIS).
  /// Example: /// Example: NUCLEAR WARHEAD
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *spaceAmp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACEAMP);
  }
  /// Space activity (examples: RECONNAISSANCE, ANTISPACE WARFARE, TELEVISION). The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.
  /// Example: /// Example: HOLDING
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *objAct() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJACT);
  }
  /// Specific type of point or track with an environment of space.
  /// Example: /// Example: SS-21_MOD_2_CRBM
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *spaceSpecType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACESPECTYPE);
  }
  /// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM. 
  /// &nbsp;SRBM - Short-Range Ballistic Missile
  /// &nbsp;MRBM - Medium-Range Ballistic Missile
  /// &nbsp;IRBM - Intermediate-Range Ballistic Missile
  /// &nbsp;LRBM - Long-Range Ballistic Missile
  /// &nbsp;ICBM - Intercontinental Ballistic Missile
  /// &nbsp;SLBM - Submarine-Launched Ballistic Missile.
  /// Example: /// Example: SLBM
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *acftSubType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACFTSUBTYPE);
  }
  /// Track name.
  /// Example: /// Example: TRACK-NAME
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// The call sign currently assigned to the track object.
  /// Example: /// Example: Charlie
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *callSign() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALLSIGN);
  }
  /// Indicates whether or not the missile is considered lost.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool lostTrkInd() const {
    return GetField<uint8_t>(VT_LOSTTRKIND, 0) != 0;
  }
  /// Track ID within the originating system.
  /// Example: /// Example: 102288
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *trackId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRACKID);
  }
  /// Track ID of the parent track, within the originating system, from which the track was developed.
  /// Example: /// Example: 102288
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *parentTrackId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARENTTRACKID);
  }
  /// Track ID for the source of the missile-unique identifier.
  /// Example: /// Example: MUID-SRC-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *muidSrcTrk() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MUIDSRCTRK);
  }
  /// Source of the missile-unique identifier (MUID).
  /// Example: /// Example: MUID-SRC
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *muidSrc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MUIDSRC);
  }
  /// A track may be designated as a non-alert track or an alert track.
  /// Examples include but are not limited to:
  /// &nbsp;Non-alert tracks – choose None (Blank).
  /// &nbsp;Alert tracks – enter the proper alert classification:
  /// &nbsp;HIT - High Interest Track
  /// &nbsp;TGT - Target
  /// &nbsp;SUS - Suspect Carrier
  /// &nbsp;NSP - Cleared Suspect.
  /// Example: /// Example: HIT
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *alert() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALERT);
  }
  /// Missile status enumeration examples include but are not limited to:
  /// &nbsp;AT LAUNCH 
  /// &nbsp;AT OBSERVATION 
  /// &nbsp;FLYING 
  /// &nbsp;IMPACTED 
  /// &nbsp;LOST 
  /// &nbsp;STALE
  /// &nbsp;DEBRIS.
  /// Example: /// Example: AT LAUNCH
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *mslStatus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSLSTATUS);
  }
  /// The receipt time of the data by the processing system, in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *ts() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TS);
  }
  /// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 40
  const ::flatbuffers::String *aouRptType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AOURPTTYPE);
  }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
  /// &nbsp;ELLIPSE:
  /// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
  /// &nbsp;&nbsp;a1 - semi-major axis in kilometers
  /// &nbsp;&nbsp;a2 - semi-minor axis in kilometers
  /// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
  /// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
  /// &nbsp;&nbsp;a1 - length of bearing box in kilometers
  /// &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
  /// &nbsp;OTHER (All other type values):
  /// &nbsp;&nbsp;brg - line of bearing in degrees true
  /// &nbsp;&nbsp;a1 - bearing error in degrees
  /// &nbsp;&nbsp;a2 - estimated range in kilometers.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *aouRptData() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_AOURPTDATA);
  }
  /// The percentage of time that the estimated AoU will "cover" the true position of the track.
  /// Example: /// Example: 90.64
  /// Constraints: No constraints specified.
  double containment() const {
    return GetField<double>(VT_CONTAINMENT, 0.0);
  }
  /// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
  /// Example: /// Example: 0.95
  /// Constraints: No constraints specified.
  double trkConf() const {
    return GetField<double>(VT_TRKCONF, 0.0);
  }
  /// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track, with higher values indicating higher track quality; i.e., lower errors in reported position.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t trkQual() const {
    return GetField<int32_t>(VT_TRKQUAL, 0);
  }
  /// Angle of elevation/depression between observer and missile in degrees.
  /// Example: /// Example: 15.2
  /// Constraints: No constraints specified.
  double angElev() const {
    return GetField<double>(VT_ANGELEV, 0.0);
  }
  /// Last report type received from the sensor (for example, OBSBO = observation burnout).
  /// Example: /// Example: OBSBO
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *senMode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SENMODE);
  }
  /// Source code for source of information used to detect track.
  /// Example: /// Example: S1
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *infoSource() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INFOSOURCE);
  }
  /// Indicates whether or not the missile is currently in a state of boosting.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool boosting() const {
    return GetField<uint8_t>(VT_BOOSTING, 0) != 0;
  }
  /// Azimuth corridor reference point latitude.
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  double polarSingLocLat() const {
    return GetField<double>(VT_POLARSINGLOCLAT, 0.0);
  }
  /// Azimuth corridor reference point longitude.
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  double polarSingLocLon() const {
    return GetField<double>(VT_POLARSINGLOCLON, 0.0);
  }
  /// Indicates whether or not a track has an emergency.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool emgInd() const {
    return GetField<uint8_t>(VT_EMGIND, 0) != 0;
  }
  /// The drop-point indicator setting.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool dropPtInd() const {
    return GetField<uint8_t>(VT_DROPPTIND, 0) != 0;
  }
  /// Confidence level of the amplifying characteristics. Values range from 0 to 6.
  /// Example: /// Example: 6
  /// Constraints: No constraints specified.
  int32_t spaceAmpConf() const {
    return GetField<int32_t>(VT_SPACEAMPCONF, 0);
  }
  /// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *launchTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCHTIME);
  }
  /// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  double launchLat() const {
    return GetField<double>(VT_LAUNCHLAT, 0.0);
  }
  /// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  double launchLon() const {
    return GetField<double>(VT_LAUNCHLON, 0.0);
  }
  /// Missile azimuth corridor data.
  /// Example: /// Example: 12.876
  /// Constraints: No constraints specified.
  double azCorr() const {
    return GetField<double>(VT_AZCORR, 0.0);
  }
  /// Track point burnout altitude relative to WGS-84 ellipsoid, in kilometers.
  /// Example: /// Example: 30567.452
  /// Constraints: No constraints specified.
  double burnoutAlt() const {
    return GetField<double>(VT_BURNOUTALT, 0.0);
  }
  /// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 40
  const ::flatbuffers::String *launchAouType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCHAOUTYPE);
  }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
  /// &nbsp;ELLIPSE:
  /// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
  /// &nbsp;&nbsp;a1 - semi-major axis in kilometers
  /// &nbsp;&nbsp;a2 - semi-minor axis in kilometers
  /// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
  /// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
  /// &nbsp;&nbsp;a1 - length of bearing box in kilometers
  /// &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
  /// &nbsp;OTHER (All other type values):
  /// &nbsp;&nbsp;brg - line of bearing in degrees true
  /// &nbsp;&nbsp;a1 - bearing error in degrees
  /// &nbsp;&nbsp;a2 - estimated range in kilometers.
  /// Example: /// Example: [1.23, 2.34, 3.45]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *launchAouData() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_LAUNCHAOUDATA);
  }
  /// Estimated time of impact timestamp in ISO8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *impactTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMPACTTIME);
  }
  /// WGS-84 latitude of the missile object impact point, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  double impactLat() const {
    return GetField<double>(VT_IMPACTLAT, 0.0);
  }
  /// WGS-84 longitude of the missile object impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  double impactLon() const {
    return GetField<double>(VT_IMPACTLON, 0.0);
  }
  /// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 40
  const ::flatbuffers::String *impactAouType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMPACTAOUTYPE);
  }
  /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
  /// &nbsp;ELLIPSE:
  /// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
  /// &nbsp;&nbsp;a1 - semi-major axis in kilometers
  /// &nbsp;&nbsp;a2 - semi-minor axis in kilometers
  /// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
  /// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
  /// &nbsp;&nbsp;a1 - length of bearing box in kilometers
  /// &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
  /// &nbsp;OTHER (All other type values):
  /// &nbsp;&nbsp;brg - line of bearing in degrees true
  /// &nbsp;&nbsp;a1 - bearing error in degrees
  /// &nbsp;&nbsp;a2 - estimated range in kilometers.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *impactAouData() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_IMPACTAOUDATA);
  }
  /// Array of MissileTrackVector objects. Missile track vectors are cartesian vectors of position, velocity, and acceleration that, together with their time, 'epoch', uniquely determine the trajectory of the missile. ECEF is the preferred coordinate frame but in some cases data may be in another frame as specified by 'referenceFrame', depending on the provider.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *vectors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VECTORS);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2021-02-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  MissileTrack_Abridged_dataMode_Enum dataMode() const {
    return static_cast<MissileTrack_Abridged_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_MSGTYPE) &&
           verifier.VerifyString(msgType()) &&
           VerifyOffset(verifier, VT_MSGSUBTYPE) &&
           verifier.VerifyString(msgSubType()) &&
           VerifyOffset(verifier, VT_MSGCREATEDATE) &&
           verifier.VerifyString(msgCreateDate()) &&
           VerifyField<int8_t>(verifier, VT_ENV, 1) &&
           VerifyOffset(verifier, VT_OBJTYPE) &&
           verifier.VerifyString(objType()) &&
           VerifyField<int32_t>(verifier, VT_OBJTYPECONF, 4) &&
           VerifyOffset(verifier, VT_OBJPLAT) &&
           verifier.VerifyString(objPlat()) &&
           VerifyField<int8_t>(verifier, VT_OBJIDENT, 1) &&
           VerifyOffset(verifier, VT_SPACEAMP) &&
           verifier.VerifyString(spaceAmp()) &&
           VerifyOffset(verifier, VT_OBJACT) &&
           verifier.VerifyString(objAct()) &&
           VerifyOffset(verifier, VT_SPACESPECTYPE) &&
           verifier.VerifyString(spaceSpecType()) &&
           VerifyOffset(verifier, VT_ACFTSUBTYPE) &&
           verifier.VerifyString(acftSubType()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CALLSIGN) &&
           verifier.VerifyString(callSign()) &&
           VerifyField<uint8_t>(verifier, VT_LOSTTRKIND, 1) &&
           VerifyOffset(verifier, VT_TRACKID) &&
           verifier.VerifyString(trackId()) &&
           VerifyOffset(verifier, VT_PARENTTRACKID) &&
           verifier.VerifyString(parentTrackId()) &&
           VerifyOffset(verifier, VT_MUIDSRCTRK) &&
           verifier.VerifyString(muidSrcTrk()) &&
           VerifyOffset(verifier, VT_MUIDSRC) &&
           verifier.VerifyString(muidSrc()) &&
           VerifyOffset(verifier, VT_ALERT) &&
           verifier.VerifyString(alert()) &&
           VerifyOffset(verifier, VT_MSLSTATUS) &&
           verifier.VerifyString(mslStatus()) &&
           VerifyOffset(verifier, VT_TS) &&
           verifier.VerifyString(ts()) &&
           VerifyOffset(verifier, VT_AOURPTTYPE) &&
           verifier.VerifyString(aouRptType()) &&
           VerifyOffset(verifier, VT_AOURPTDATA) &&
           verifier.VerifyVector(aouRptData()) &&
           verifier.VerifyVectorOfStrings(aouRptData()) &&
           VerifyField<double>(verifier, VT_CONTAINMENT, 8) &&
           VerifyField<double>(verifier, VT_TRKCONF, 8) &&
           VerifyField<int32_t>(verifier, VT_TRKQUAL, 4) &&
           VerifyField<double>(verifier, VT_ANGELEV, 8) &&
           VerifyOffset(verifier, VT_SENMODE) &&
           verifier.VerifyString(senMode()) &&
           VerifyOffset(verifier, VT_INFOSOURCE) &&
           verifier.VerifyString(infoSource()) &&
           VerifyField<uint8_t>(verifier, VT_BOOSTING, 1) &&
           VerifyField<double>(verifier, VT_POLARSINGLOCLAT, 8) &&
           VerifyField<double>(verifier, VT_POLARSINGLOCLON, 8) &&
           VerifyField<uint8_t>(verifier, VT_EMGIND, 1) &&
           VerifyField<uint8_t>(verifier, VT_DROPPTIND, 1) &&
           VerifyField<int32_t>(verifier, VT_SPACEAMPCONF, 4) &&
           VerifyOffset(verifier, VT_LAUNCHTIME) &&
           verifier.VerifyString(launchTime()) &&
           VerifyField<double>(verifier, VT_LAUNCHLAT, 8) &&
           VerifyField<double>(verifier, VT_LAUNCHLON, 8) &&
           VerifyField<double>(verifier, VT_AZCORR, 8) &&
           VerifyField<double>(verifier, VT_BURNOUTALT, 8) &&
           VerifyOffset(verifier, VT_LAUNCHAOUTYPE) &&
           verifier.VerifyString(launchAouType()) &&
           VerifyOffset(verifier, VT_LAUNCHAOUDATA) &&
           verifier.VerifyVector(launchAouData()) &&
           verifier.VerifyVectorOfStrings(launchAouData()) &&
           VerifyOffset(verifier, VT_IMPACTTIME) &&
           verifier.VerifyString(impactTime()) &&
           VerifyField<double>(verifier, VT_IMPACTLAT, 8) &&
           VerifyField<double>(verifier, VT_IMPACTLON, 8) &&
           VerifyOffset(verifier, VT_IMPACTAOUTYPE) &&
           verifier.VerifyString(impactAouType()) &&
           VerifyOffset(verifier, VT_IMPACTAOUDATA) &&
           verifier.VerifyVector(impactAouData()) &&
           verifier.VerifyVectorOfStrings(impactAouData()) &&
           VerifyOffset(verifier, VT_VECTORS) &&
           verifier.VerifyVector(vectors()) &&
           verifier.VerifyVectorOfStrings(vectors()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           verifier.EndTable();
  }
};

struct MissileTrack_AbridgedBuilder {
  typedef MissileTrack_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_msgType(::flatbuffers::Offset<::flatbuffers::String> msgType) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_MSGTYPE, msgType);
  }
  void add_msgSubType(::flatbuffers::Offset<::flatbuffers::String> msgSubType) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_MSGSUBTYPE, msgSubType);
  }
  void add_msgCreateDate(::flatbuffers::Offset<::flatbuffers::String> msgCreateDate) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_MSGCREATEDATE, msgCreateDate);
  }
  void add_env(MissileTrack_Abridged_env_Enum env) {
    fbb_.AddElement<int8_t>(MissileTrack_Abridged::VT_ENV, static_cast<int8_t>(env), 0);
  }
  void add_objType(::flatbuffers::Offset<::flatbuffers::String> objType) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_OBJTYPE, objType);
  }
  void add_objTypeConf(int32_t objTypeConf) {
    fbb_.AddElement<int32_t>(MissileTrack_Abridged::VT_OBJTYPECONF, objTypeConf, 0);
  }
  void add_objPlat(::flatbuffers::Offset<::flatbuffers::String> objPlat) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_OBJPLAT, objPlat);
  }
  void add_objIdent(MissileTrack_Abridged_objIdent_Enum objIdent) {
    fbb_.AddElement<int8_t>(MissileTrack_Abridged::VT_OBJIDENT, static_cast<int8_t>(objIdent), 0);
  }
  void add_spaceAmp(::flatbuffers::Offset<::flatbuffers::String> spaceAmp) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_SPACEAMP, spaceAmp);
  }
  void add_objAct(::flatbuffers::Offset<::flatbuffers::String> objAct) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_OBJACT, objAct);
  }
  void add_spaceSpecType(::flatbuffers::Offset<::flatbuffers::String> spaceSpecType) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_SPACESPECTYPE, spaceSpecType);
  }
  void add_acftSubType(::flatbuffers::Offset<::flatbuffers::String> acftSubType) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_ACFTSUBTYPE, acftSubType);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_NAME, name);
  }
  void add_callSign(::flatbuffers::Offset<::flatbuffers::String> callSign) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_CALLSIGN, callSign);
  }
  void add_lostTrkInd(bool lostTrkInd) {
    fbb_.AddElement<uint8_t>(MissileTrack_Abridged::VT_LOSTTRKIND, static_cast<uint8_t>(lostTrkInd), 0);
  }
  void add_trackId(::flatbuffers::Offset<::flatbuffers::String> trackId) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_TRACKID, trackId);
  }
  void add_parentTrackId(::flatbuffers::Offset<::flatbuffers::String> parentTrackId) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_PARENTTRACKID, parentTrackId);
  }
  void add_muidSrcTrk(::flatbuffers::Offset<::flatbuffers::String> muidSrcTrk) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_MUIDSRCTRK, muidSrcTrk);
  }
  void add_muidSrc(::flatbuffers::Offset<::flatbuffers::String> muidSrc) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_MUIDSRC, muidSrc);
  }
  void add_alert(::flatbuffers::Offset<::flatbuffers::String> alert) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_ALERT, alert);
  }
  void add_mslStatus(::flatbuffers::Offset<::flatbuffers::String> mslStatus) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_MSLSTATUS, mslStatus);
  }
  void add_ts(::flatbuffers::Offset<::flatbuffers::String> ts) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_TS, ts);
  }
  void add_aouRptType(::flatbuffers::Offset<::flatbuffers::String> aouRptType) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_AOURPTTYPE, aouRptType);
  }
  void add_aouRptData(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> aouRptData) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_AOURPTDATA, aouRptData);
  }
  void add_containment(double containment) {
    fbb_.AddElement<double>(MissileTrack_Abridged::VT_CONTAINMENT, containment, 0.0);
  }
  void add_trkConf(double trkConf) {
    fbb_.AddElement<double>(MissileTrack_Abridged::VT_TRKCONF, trkConf, 0.0);
  }
  void add_trkQual(int32_t trkQual) {
    fbb_.AddElement<int32_t>(MissileTrack_Abridged::VT_TRKQUAL, trkQual, 0);
  }
  void add_angElev(double angElev) {
    fbb_.AddElement<double>(MissileTrack_Abridged::VT_ANGELEV, angElev, 0.0);
  }
  void add_senMode(::flatbuffers::Offset<::flatbuffers::String> senMode) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_SENMODE, senMode);
  }
  void add_infoSource(::flatbuffers::Offset<::flatbuffers::String> infoSource) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_INFOSOURCE, infoSource);
  }
  void add_boosting(bool boosting) {
    fbb_.AddElement<uint8_t>(MissileTrack_Abridged::VT_BOOSTING, static_cast<uint8_t>(boosting), 0);
  }
  void add_polarSingLocLat(double polarSingLocLat) {
    fbb_.AddElement<double>(MissileTrack_Abridged::VT_POLARSINGLOCLAT, polarSingLocLat, 0.0);
  }
  void add_polarSingLocLon(double polarSingLocLon) {
    fbb_.AddElement<double>(MissileTrack_Abridged::VT_POLARSINGLOCLON, polarSingLocLon, 0.0);
  }
  void add_emgInd(bool emgInd) {
    fbb_.AddElement<uint8_t>(MissileTrack_Abridged::VT_EMGIND, static_cast<uint8_t>(emgInd), 0);
  }
  void add_dropPtInd(bool dropPtInd) {
    fbb_.AddElement<uint8_t>(MissileTrack_Abridged::VT_DROPPTIND, static_cast<uint8_t>(dropPtInd), 0);
  }
  void add_spaceAmpConf(int32_t spaceAmpConf) {
    fbb_.AddElement<int32_t>(MissileTrack_Abridged::VT_SPACEAMPCONF, spaceAmpConf, 0);
  }
  void add_launchTime(::flatbuffers::Offset<::flatbuffers::String> launchTime) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_LAUNCHTIME, launchTime);
  }
  void add_launchLat(double launchLat) {
    fbb_.AddElement<double>(MissileTrack_Abridged::VT_LAUNCHLAT, launchLat, 0.0);
  }
  void add_launchLon(double launchLon) {
    fbb_.AddElement<double>(MissileTrack_Abridged::VT_LAUNCHLON, launchLon, 0.0);
  }
  void add_azCorr(double azCorr) {
    fbb_.AddElement<double>(MissileTrack_Abridged::VT_AZCORR, azCorr, 0.0);
  }
  void add_burnoutAlt(double burnoutAlt) {
    fbb_.AddElement<double>(MissileTrack_Abridged::VT_BURNOUTALT, burnoutAlt, 0.0);
  }
  void add_launchAouType(::flatbuffers::Offset<::flatbuffers::String> launchAouType) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_LAUNCHAOUTYPE, launchAouType);
  }
  void add_launchAouData(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> launchAouData) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_LAUNCHAOUDATA, launchAouData);
  }
  void add_impactTime(::flatbuffers::Offset<::flatbuffers::String> impactTime) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_IMPACTTIME, impactTime);
  }
  void add_impactLat(double impactLat) {
    fbb_.AddElement<double>(MissileTrack_Abridged::VT_IMPACTLAT, impactLat, 0.0);
  }
  void add_impactLon(double impactLon) {
    fbb_.AddElement<double>(MissileTrack_Abridged::VT_IMPACTLON, impactLon, 0.0);
  }
  void add_impactAouType(::flatbuffers::Offset<::flatbuffers::String> impactAouType) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_IMPACTAOUTYPE, impactAouType);
  }
  void add_impactAouData(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> impactAouData) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_IMPACTAOUDATA, impactAouData);
  }
  void add_vectors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> vectors) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_VECTORS, vectors);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(MissileTrack_Abridged::VT_ORIGIN, origin);
  }
  void add_dataMode(MissileTrack_Abridged_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(MissileTrack_Abridged::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  explicit MissileTrack_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MissileTrack_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MissileTrack_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MissileTrack_Abridged> CreateMissileTrack_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> msgType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> msgSubType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> msgCreateDate = 0,
    MissileTrack_Abridged_env_Enum env = MissileTrack_Abridged_env_Enum_AIR,
    ::flatbuffers::Offset<::flatbuffers::String> objType = 0,
    int32_t objTypeConf = 0,
    ::flatbuffers::Offset<::flatbuffers::String> objPlat = 0,
    MissileTrack_Abridged_objIdent_Enum objIdent = MissileTrack_Abridged_objIdent_Enum_ASSUMED_FRIEND,
    ::flatbuffers::Offset<::flatbuffers::String> spaceAmp = 0,
    ::flatbuffers::Offset<::flatbuffers::String> objAct = 0,
    ::flatbuffers::Offset<::flatbuffers::String> spaceSpecType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> acftSubType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> callSign = 0,
    bool lostTrkInd = false,
    ::flatbuffers::Offset<::flatbuffers::String> trackId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> parentTrackId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> muidSrcTrk = 0,
    ::flatbuffers::Offset<::flatbuffers::String> muidSrc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> alert = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mslStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ts = 0,
    ::flatbuffers::Offset<::flatbuffers::String> aouRptType = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> aouRptData = 0,
    double containment = 0.0,
    double trkConf = 0.0,
    int32_t trkQual = 0,
    double angElev = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> senMode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> infoSource = 0,
    bool boosting = false,
    double polarSingLocLat = 0.0,
    double polarSingLocLon = 0.0,
    bool emgInd = false,
    bool dropPtInd = false,
    int32_t spaceAmpConf = 0,
    ::flatbuffers::Offset<::flatbuffers::String> launchTime = 0,
    double launchLat = 0.0,
    double launchLon = 0.0,
    double azCorr = 0.0,
    double burnoutAlt = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> launchAouType = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> launchAouData = 0,
    ::flatbuffers::Offset<::flatbuffers::String> impactTime = 0,
    double impactLat = 0.0,
    double impactLon = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> impactAouType = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> impactAouData = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> vectors = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    MissileTrack_Abridged_dataMode_Enum dataMode = MissileTrack_Abridged_dataMode_Enum_REAL) {
  MissileTrack_AbridgedBuilder builder_(_fbb);
  builder_.add_impactLon(impactLon);
  builder_.add_impactLat(impactLat);
  builder_.add_burnoutAlt(burnoutAlt);
  builder_.add_azCorr(azCorr);
  builder_.add_launchLon(launchLon);
  builder_.add_launchLat(launchLat);
  builder_.add_polarSingLocLon(polarSingLocLon);
  builder_.add_polarSingLocLat(polarSingLocLat);
  builder_.add_angElev(angElev);
  builder_.add_trkConf(trkConf);
  builder_.add_containment(containment);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_origNetwork(origNetwork);
  builder_.add_vectors(vectors);
  builder_.add_impactAouData(impactAouData);
  builder_.add_impactAouType(impactAouType);
  builder_.add_impactTime(impactTime);
  builder_.add_launchAouData(launchAouData);
  builder_.add_launchAouType(launchAouType);
  builder_.add_launchTime(launchTime);
  builder_.add_spaceAmpConf(spaceAmpConf);
  builder_.add_infoSource(infoSource);
  builder_.add_senMode(senMode);
  builder_.add_trkQual(trkQual);
  builder_.add_aouRptData(aouRptData);
  builder_.add_aouRptType(aouRptType);
  builder_.add_ts(ts);
  builder_.add_mslStatus(mslStatus);
  builder_.add_alert(alert);
  builder_.add_muidSrc(muidSrc);
  builder_.add_muidSrcTrk(muidSrcTrk);
  builder_.add_parentTrackId(parentTrackId);
  builder_.add_trackId(trackId);
  builder_.add_callSign(callSign);
  builder_.add_name(name);
  builder_.add_acftSubType(acftSubType);
  builder_.add_spaceSpecType(spaceSpecType);
  builder_.add_objAct(objAct);
  builder_.add_spaceAmp(spaceAmp);
  builder_.add_objPlat(objPlat);
  builder_.add_objTypeConf(objTypeConf);
  builder_.add_objType(objType);
  builder_.add_msgCreateDate(msgCreateDate);
  builder_.add_msgSubType(msgSubType);
  builder_.add_msgType(msgType);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_dropPtInd(dropPtInd);
  builder_.add_emgInd(emgInd);
  builder_.add_boosting(boosting);
  builder_.add_lostTrkInd(lostTrkInd);
  builder_.add_objIdent(objIdent);
  builder_.add_env(env);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MissileTrack_Abridged> CreateMissileTrack_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *msgType = nullptr,
    const char *msgSubType = nullptr,
    const char *msgCreateDate = nullptr,
    MissileTrack_Abridged_env_Enum env = MissileTrack_Abridged_env_Enum_AIR,
    const char *objType = nullptr,
    int32_t objTypeConf = 0,
    const char *objPlat = nullptr,
    MissileTrack_Abridged_objIdent_Enum objIdent = MissileTrack_Abridged_objIdent_Enum_ASSUMED_FRIEND,
    const char *spaceAmp = nullptr,
    const char *objAct = nullptr,
    const char *spaceSpecType = nullptr,
    const char *acftSubType = nullptr,
    const char *name = nullptr,
    const char *callSign = nullptr,
    bool lostTrkInd = false,
    const char *trackId = nullptr,
    const char *parentTrackId = nullptr,
    const char *muidSrcTrk = nullptr,
    const char *muidSrc = nullptr,
    const char *alert = nullptr,
    const char *mslStatus = nullptr,
    const char *ts = nullptr,
    const char *aouRptType = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *aouRptData = nullptr,
    double containment = 0.0,
    double trkConf = 0.0,
    int32_t trkQual = 0,
    double angElev = 0.0,
    const char *senMode = nullptr,
    const char *infoSource = nullptr,
    bool boosting = false,
    double polarSingLocLat = 0.0,
    double polarSingLocLon = 0.0,
    bool emgInd = false,
    bool dropPtInd = false,
    int32_t spaceAmpConf = 0,
    const char *launchTime = nullptr,
    double launchLat = 0.0,
    double launchLon = 0.0,
    double azCorr = 0.0,
    double burnoutAlt = 0.0,
    const char *launchAouType = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *launchAouData = nullptr,
    const char *impactTime = nullptr,
    double impactLat = 0.0,
    double impactLon = 0.0,
    const char *impactAouType = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *impactAouData = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *vectors = nullptr,
    const char *origNetwork = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    MissileTrack_Abridged_dataMode_Enum dataMode = MissileTrack_Abridged_dataMode_Enum_REAL) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto msgType__ = msgType ? _fbb.CreateString(msgType) : 0;
  auto msgSubType__ = msgSubType ? _fbb.CreateString(msgSubType) : 0;
  auto msgCreateDate__ = msgCreateDate ? _fbb.CreateString(msgCreateDate) : 0;
  auto objType__ = objType ? _fbb.CreateString(objType) : 0;
  auto objPlat__ = objPlat ? _fbb.CreateString(objPlat) : 0;
  auto spaceAmp__ = spaceAmp ? _fbb.CreateString(spaceAmp) : 0;
  auto objAct__ = objAct ? _fbb.CreateString(objAct) : 0;
  auto spaceSpecType__ = spaceSpecType ? _fbb.CreateString(spaceSpecType) : 0;
  auto acftSubType__ = acftSubType ? _fbb.CreateString(acftSubType) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto callSign__ = callSign ? _fbb.CreateString(callSign) : 0;
  auto trackId__ = trackId ? _fbb.CreateString(trackId) : 0;
  auto parentTrackId__ = parentTrackId ? _fbb.CreateString(parentTrackId) : 0;
  auto muidSrcTrk__ = muidSrcTrk ? _fbb.CreateString(muidSrcTrk) : 0;
  auto muidSrc__ = muidSrc ? _fbb.CreateString(muidSrc) : 0;
  auto alert__ = alert ? _fbb.CreateString(alert) : 0;
  auto mslStatus__ = mslStatus ? _fbb.CreateString(mslStatus) : 0;
  auto ts__ = ts ? _fbb.CreateString(ts) : 0;
  auto aouRptType__ = aouRptType ? _fbb.CreateString(aouRptType) : 0;
  auto aouRptData__ = aouRptData ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*aouRptData) : 0;
  auto senMode__ = senMode ? _fbb.CreateString(senMode) : 0;
  auto infoSource__ = infoSource ? _fbb.CreateString(infoSource) : 0;
  auto launchTime__ = launchTime ? _fbb.CreateString(launchTime) : 0;
  auto launchAouType__ = launchAouType ? _fbb.CreateString(launchAouType) : 0;
  auto launchAouData__ = launchAouData ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*launchAouData) : 0;
  auto impactTime__ = impactTime ? _fbb.CreateString(impactTime) : 0;
  auto impactAouType__ = impactAouType ? _fbb.CreateString(impactAouType) : 0;
  auto impactAouData__ = impactAouData ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*impactAouData) : 0;
  auto vectors__ = vectors ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*vectors) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  return CreateMissileTrack_Abridged(
      _fbb,
      id__,
      classificationMarking__,
      msgType__,
      msgSubType__,
      msgCreateDate__,
      env,
      objType__,
      objTypeConf,
      objPlat__,
      objIdent,
      spaceAmp__,
      objAct__,
      spaceSpecType__,
      acftSubType__,
      name__,
      callSign__,
      lostTrkInd,
      trackId__,
      parentTrackId__,
      muidSrcTrk__,
      muidSrc__,
      alert__,
      mslStatus__,
      ts__,
      aouRptType__,
      aouRptData__,
      containment,
      trkConf,
      trkQual,
      angElev,
      senMode__,
      infoSource__,
      boosting,
      polarSingLocLat,
      polarSingLocLon,
      emgInd,
      dropPtInd,
      spaceAmpConf,
      launchTime__,
      launchLat,
      launchLon,
      azCorr,
      burnoutAlt,
      launchAouType__,
      launchAouData__,
      impactTime__,
      impactLat,
      impactLon,
      impactAouType__,
      impactAouData__,
      vectors__,
      origNetwork__,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      dataMode);
}

inline const MissileTrack_Abridged *GetMissileTrack_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<MissileTrack_Abridged>(buf);
}

inline const MissileTrack_Abridged *GetSizePrefixedMissileTrack_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MissileTrack_Abridged>(buf);
}

inline const char *MissileTrack_AbridgedIdentifier() {
  return "MISS";
}

inline bool MissileTrack_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MissileTrack_AbridgedIdentifier());
}

inline bool SizePrefixedMissileTrack_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MissileTrack_AbridgedIdentifier(), true);
}

inline bool VerifyMissileTrack_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MissileTrack_Abridged>(MissileTrack_AbridgedIdentifier());
}

inline bool VerifySizePrefixedMissileTrack_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MissileTrack_Abridged>(MissileTrack_AbridgedIdentifier());
}

inline void FinishMissileTrack_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MissileTrack_Abridged> root) {
  fbb.Finish(root, MissileTrack_AbridgedIdentifier());
}

inline void FinishSizePrefixedMissileTrack_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MissileTrack_Abridged> root) {
  fbb.FinishSizePrefixed(root, MissileTrack_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
