// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Evac_Full;
struct Evac_FullBuilder;

enum Evac_Full_type_Enum : int8_t {
  /// No description available.
  Evac_Full_type_Enum_REQUEST = 0,
  /// No description available.
  Evac_Full_type_Enum_RESPONSE = 1,
  Evac_Full_type_Enum_MIN = Evac_Full_type_Enum_REQUEST,
  Evac_Full_type_Enum_MAX = Evac_Full_type_Enum_RESPONSE
};

inline const Evac_Full_type_Enum (&EnumValuesEvac_Full_type_Enum())[2] {
  static const Evac_Full_type_Enum values[] = {
    Evac_Full_type_Enum_REQUEST,
    Evac_Full_type_Enum_RESPONSE
  };
  return values;
}

inline const char * const *EnumNamesEvac_Full_type_Enum() {
  static const char * const names[3] = {
    "REQUEST",
    "RESPONSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvac_Full_type_Enum(Evac_Full_type_Enum e) {
  if (::flatbuffers::IsOutRange(e, Evac_Full_type_Enum_REQUEST, Evac_Full_type_Enum_RESPONSE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEvac_Full_type_Enum()[index];
}

enum Evac_Full_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  Evac_Full_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  Evac_Full_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  Evac_Full_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  Evac_Full_dataMode_Enum_EXERCISE = 3,
  Evac_Full_dataMode_Enum_MIN = Evac_Full_dataMode_Enum_REAL,
  Evac_Full_dataMode_Enum_MAX = Evac_Full_dataMode_Enum_EXERCISE
};

inline const Evac_Full_dataMode_Enum (&EnumValuesEvac_Full_dataMode_Enum())[4] {
  static const Evac_Full_dataMode_Enum values[] = {
    Evac_Full_dataMode_Enum_REAL,
    Evac_Full_dataMode_Enum_TEST,
    Evac_Full_dataMode_Enum_SIMULATED,
    Evac_Full_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesEvac_Full_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvac_Full_dataMode_Enum(Evac_Full_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, Evac_Full_dataMode_Enum_REAL, Evac_Full_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEvac_Full_dataMode_Enum()[index];
}

/// /// Casualty report and evacuation request. Used to report and request support to evacuate friendly and enemy casualties.
struct Evac_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Evac_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_MEDEVACID = 8,
    VT_TYPE = 10,
    VT_MISSIONTYPE = 12,
    VT_IDWEATHERREPORT = 14,
    VT_NUMKIA = 16,
    VT_NUMWIA = 18,
    VT_NUMLITTER = 20,
    VT_NUMAMBULATORY = 22,
    VT_MEDICREQ = 24,
    VT_REQNUM = 26,
    VT_REQTIME = 28,
    VT_REQCALLSIGN = 30,
    VT_PICKUPTIME = 32,
    VT_PICKUPLAT = 34,
    VT_PICKUPLON = 36,
    VT_PICKUPALT = 38,
    VT_CE = 40,
    VT_LE = 42,
    VT_TERRAIN = 44,
    VT_OBSTACLESREMARKS = 46,
    VT_TERRAINREMARKS = 48,
    VT_ZONENAME = 50,
    VT_ZONEMARKING = 52,
    VT_ZONESECURITY = 54,
    VT_ZONEMARKINGCOLOR = 56,
    VT_ZONEHOT = 58,
    VT_CNTCTFREQ = 60,
    VT_ZONECONTRCALLSIGN = 62,
    VT_NUMCASUALTIES = 64,
    VT_COMMENTS = 66,
    VT_CASUALTYINFO = 68,
    VT_ENEMYDATA = 70,
    VT_RELATEDDOCS = 72,
    VT_ORIGNETWORK = 74,
    VT_CREATEDAT = 76,
    VT_CREATEDBY = 78,
    VT_SOURCE = 80,
    VT_ORIGIN = 82,
    VT_DATAMODE = 84
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: MEDEVACEVENT-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// UUID identifying the medevac mission, which should remain the same on subsequent posts related to the same medevac mission.
  /// Example: /// Example: MedEvac-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *medevacId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MEDEVACID);
  }
  /// The type of this medevac record (REQUEST, RESPONSE).
  /// Example: /// Example: REQUEST
  /// Constraints: Minimum length = 1, Maximum length = 8
  Evac_Full_type_Enum type() const {
    return static_cast<Evac_Full_type_Enum>(GetField<int8_t>(VT_TYPE, 0));
  }
  /// The operation type of the evacuation. (NOT SPECIFIED, AIR, GROUND, SURFACE).
  /// Example: /// Example: GROUND
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *missionType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MISSIONTYPE);
  }
  /// Unique identifier of a weather report associated with this evacuation.
  /// Example: /// Example: WeatherReport-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idWeatherReport() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDWEATHERREPORT);
  }
  /// Number of people Killed In Action.
  /// Example: /// Example: 0
  /// Constraints: No constraints specified.
  int32_t numKIA() const {
    return GetField<int32_t>(VT_NUMKIA, 0);
  }
  /// Number of people Wounded In Action.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  int32_t numWIA() const {
    return GetField<int32_t>(VT_NUMWIA, 0);
  }
  /// Number of littered personnel requiring evacuation.
  /// Example: /// Example: 0
  /// Constraints: No constraints specified.
  int32_t numLitter() const {
    return GetField<int32_t>(VT_NUMLITTER, 0);
  }
  /// Number of ambulatory personnel requiring evacuation.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  int32_t numAmbulatory() const {
    return GetField<int32_t>(VT_NUMAMBULATORY, 0);
  }
  /// Flag indicating whether the mission requires medical personnel.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool medicReq() const {
    return GetField<uint8_t>(VT_MEDICREQ, 0) != 0;
  }
  /// Externally provided Medevac request number (e.g. MED.1.223908).
  /// Example: /// Example: MED.1.234567
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *reqNum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REQNUM);
  }
  /// The request time, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-10-15T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *reqTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REQTIME);
  }
  /// The call sign of this medevac requestor.
  /// Example: /// Example: Bravo
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *reqCallSign() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REQCALLSIGN);
  }
  /// The expected pickup time, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-10-20T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *pickupTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PICKUPTIME);
  }
  /// WGS-84 latitude of the pickup location, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 75.1234
  /// Constraints: No constraints specified.
  double pickupLat() const {
    return GetField<double>(VT_PICKUPLAT, 0.0);
  }
  /// WGS-84 longitude of the pickup location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 175.1234
  /// Constraints: No constraints specified.
  double pickupLon() const {
    return GetField<double>(VT_PICKUPLON, 0.0);
  }
  /// Altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a point height above ellipsoid, and negative values indicate a point height below ellipsoid.
  /// Example: /// Example: 30.1234
  /// Constraints: No constraints specified.
  double pickupAlt() const {
    return GetField<double>(VT_PICKUPALT, 0.0);
  }
  /// Radius of circular area about lat/lon point, in meters (1-sigma, if representing error).
  /// Example: /// Example: 10.1234
  /// Constraints: No constraints specified.
  double ce() const {
    return GetField<double>(VT_CE, 0.0);
  }
  /// Height above lat/lon point, in meters (1-sigma, if representing linear error).
  /// Example: /// Example: 5.1234
  /// Constraints: No constraints specified.
  double le() const {
    return GetField<double>(VT_LE, 0.0);
  }
  /// Short description of the terrain features of the pickup location (WOODS, TREES, PLOWED FIELDS, FLAT, STANDING WATER, MARSH, URBAN BUILT-UP AREA, MOUNTAIN, HILL, SAND TD, ROCKY, VALLEY, METAMORPHIC ICE, UNKNOWN TD, SEA, NO STATEMENT).
  /// Example: /// Example: ROCKY
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *terrain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TERRAIN);
  }
  /// Amplifying data for the terrain describing important obstacles in or around the zone.
  /// Example: /// Example: N/A
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *obstaclesRemarks() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBSTACLESREMARKS);
  }
  /// Amplifying data for the terrain describing any notable additional terrain features.
  /// Example: /// Example: N/A
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *terrainRemarks() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TERRAINREMARKS);
  }
  /// The name of the zone.
  /// Example: /// Example: example-zone
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *zoneName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ZONENAME);
  }
  /// The expected marker identifying the pickup site (SMOKE ZONE MARKING, FLARES, MIRROR, GLIDE ANGLE INDICATOR LIGHT, LIGHT ZONE MARKING, PANELS, FIRE, LASER DESIGNATOR,  STROBE LIGHTS, VEHICLE LIGHTS, COLORED SMOKE, WHITE PHOSPHERUS, INFRARED, ILLUMINATION, FRATRICIDE FENCE).
  /// Example: /// Example: ILLUMINATION
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *zoneMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ZONEMARKING);
  }
  /// The pickup site security (UNKNOWN ZONESECURITY, NO ENEMY, POSSIBLE ENEMY, ENEMY IN AREA USE CAUTION, ENEMY IN AREA ARMED ESCORT REQUIRED).
  /// Example: /// Example: NO ENEMY
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *zoneSecurity() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ZONESECURITY);
  }
  /// Color used for the pickup site marking (RED, WHITE, BLUE, YELLOW, GREEN, ORANGE, BLACK, PURPLE, BROWN, TAN, GRAY, SILVER, CAMOUFLAGE, OTHER COLOR).
  /// Example: /// Example: RED
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *zoneMarkingColor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ZONEMARKINGCOLOR);
  }
  /// Flag indicating that the pickup site is hot and hostiles are in the area.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool zoneHot() const {
    return GetField<uint8_t>(VT_ZONEHOT, 0) != 0;
  }
  /// The contact frequency, in Hz, of the agency or zone controller.
  /// Example: /// Example: 3.11
  /// Constraints: No constraints specified.
  double cntctFreq() const {
    return GetField<double>(VT_CNTCTFREQ, 0.0);
  }
  /// The call sign of the zone controller.
  /// Example: /// Example: Tango
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *zoneContrCallSign() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ZONECONTRCALLSIGN);
  }
  /// The count of people requiring medevac.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  int32_t numCasualties() const {
    return GetField<int32_t>(VT_NUMCASUALTIES, 0);
  }
  /// Additional comments for the medevac mission.
  /// Example: /// Example: Comments concerning mission
  /// Constraints: Minimum length = 0, Maximum length = 1024
  const ::flatbuffers::String *comments() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMENTS);
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *casualtyInfo() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CASUALTYINFO);
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *enemyData() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ENEMYDATA);
  }
  /// Related document ids.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *relatedDocs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_RELATEDDOCS);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  Evac_Full_dataMode_Enum dataMode() const {
    return static_cast<Evac_Full_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_MEDEVACID) &&
           verifier.VerifyString(medevacId()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_MISSIONTYPE) &&
           verifier.VerifyString(missionType()) &&
           VerifyOffset(verifier, VT_IDWEATHERREPORT) &&
           verifier.VerifyString(idWeatherReport()) &&
           VerifyField<int32_t>(verifier, VT_NUMKIA, 4) &&
           VerifyField<int32_t>(verifier, VT_NUMWIA, 4) &&
           VerifyField<int32_t>(verifier, VT_NUMLITTER, 4) &&
           VerifyField<int32_t>(verifier, VT_NUMAMBULATORY, 4) &&
           VerifyField<uint8_t>(verifier, VT_MEDICREQ, 1) &&
           VerifyOffset(verifier, VT_REQNUM) &&
           verifier.VerifyString(reqNum()) &&
           VerifyOffset(verifier, VT_REQTIME) &&
           verifier.VerifyString(reqTime()) &&
           VerifyOffset(verifier, VT_REQCALLSIGN) &&
           verifier.VerifyString(reqCallSign()) &&
           VerifyOffset(verifier, VT_PICKUPTIME) &&
           verifier.VerifyString(pickupTime()) &&
           VerifyField<double>(verifier, VT_PICKUPLAT, 8) &&
           VerifyField<double>(verifier, VT_PICKUPLON, 8) &&
           VerifyField<double>(verifier, VT_PICKUPALT, 8) &&
           VerifyField<double>(verifier, VT_CE, 8) &&
           VerifyField<double>(verifier, VT_LE, 8) &&
           VerifyOffset(verifier, VT_TERRAIN) &&
           verifier.VerifyString(terrain()) &&
           VerifyOffset(verifier, VT_OBSTACLESREMARKS) &&
           verifier.VerifyString(obstaclesRemarks()) &&
           VerifyOffset(verifier, VT_TERRAINREMARKS) &&
           verifier.VerifyString(terrainRemarks()) &&
           VerifyOffset(verifier, VT_ZONENAME) &&
           verifier.VerifyString(zoneName()) &&
           VerifyOffset(verifier, VT_ZONEMARKING) &&
           verifier.VerifyString(zoneMarking()) &&
           VerifyOffset(verifier, VT_ZONESECURITY) &&
           verifier.VerifyString(zoneSecurity()) &&
           VerifyOffset(verifier, VT_ZONEMARKINGCOLOR) &&
           verifier.VerifyString(zoneMarkingColor()) &&
           VerifyField<uint8_t>(verifier, VT_ZONEHOT, 1) &&
           VerifyField<double>(verifier, VT_CNTCTFREQ, 8) &&
           VerifyOffset(verifier, VT_ZONECONTRCALLSIGN) &&
           verifier.VerifyString(zoneContrCallSign()) &&
           VerifyField<int32_t>(verifier, VT_NUMCASUALTIES, 4) &&
           VerifyOffset(verifier, VT_COMMENTS) &&
           verifier.VerifyString(comments()) &&
           VerifyOffset(verifier, VT_CASUALTYINFO) &&
           verifier.VerifyVector(casualtyInfo()) &&
           verifier.VerifyVectorOfStrings(casualtyInfo()) &&
           VerifyOffset(verifier, VT_ENEMYDATA) &&
           verifier.VerifyVector(enemyData()) &&
           verifier.VerifyVectorOfStrings(enemyData()) &&
           VerifyOffset(verifier, VT_RELATEDDOCS) &&
           verifier.VerifyVector(relatedDocs()) &&
           verifier.VerifyVectorOfStrings(relatedDocs()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           verifier.EndTable();
  }
};

struct Evac_FullBuilder {
  typedef Evac_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Evac_Full::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(Evac_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_medevacId(::flatbuffers::Offset<::flatbuffers::String> medevacId) {
    fbb_.AddOffset(Evac_Full::VT_MEDEVACID, medevacId);
  }
  void add_type(Evac_Full_type_Enum type) {
    fbb_.AddElement<int8_t>(Evac_Full::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_missionType(::flatbuffers::Offset<::flatbuffers::String> missionType) {
    fbb_.AddOffset(Evac_Full::VT_MISSIONTYPE, missionType);
  }
  void add_idWeatherReport(::flatbuffers::Offset<::flatbuffers::String> idWeatherReport) {
    fbb_.AddOffset(Evac_Full::VT_IDWEATHERREPORT, idWeatherReport);
  }
  void add_numKIA(int32_t numKIA) {
    fbb_.AddElement<int32_t>(Evac_Full::VT_NUMKIA, numKIA, 0);
  }
  void add_numWIA(int32_t numWIA) {
    fbb_.AddElement<int32_t>(Evac_Full::VT_NUMWIA, numWIA, 0);
  }
  void add_numLitter(int32_t numLitter) {
    fbb_.AddElement<int32_t>(Evac_Full::VT_NUMLITTER, numLitter, 0);
  }
  void add_numAmbulatory(int32_t numAmbulatory) {
    fbb_.AddElement<int32_t>(Evac_Full::VT_NUMAMBULATORY, numAmbulatory, 0);
  }
  void add_medicReq(bool medicReq) {
    fbb_.AddElement<uint8_t>(Evac_Full::VT_MEDICREQ, static_cast<uint8_t>(medicReq), 0);
  }
  void add_reqNum(::flatbuffers::Offset<::flatbuffers::String> reqNum) {
    fbb_.AddOffset(Evac_Full::VT_REQNUM, reqNum);
  }
  void add_reqTime(::flatbuffers::Offset<::flatbuffers::String> reqTime) {
    fbb_.AddOffset(Evac_Full::VT_REQTIME, reqTime);
  }
  void add_reqCallSign(::flatbuffers::Offset<::flatbuffers::String> reqCallSign) {
    fbb_.AddOffset(Evac_Full::VT_REQCALLSIGN, reqCallSign);
  }
  void add_pickupTime(::flatbuffers::Offset<::flatbuffers::String> pickupTime) {
    fbb_.AddOffset(Evac_Full::VT_PICKUPTIME, pickupTime);
  }
  void add_pickupLat(double pickupLat) {
    fbb_.AddElement<double>(Evac_Full::VT_PICKUPLAT, pickupLat, 0.0);
  }
  void add_pickupLon(double pickupLon) {
    fbb_.AddElement<double>(Evac_Full::VT_PICKUPLON, pickupLon, 0.0);
  }
  void add_pickupAlt(double pickupAlt) {
    fbb_.AddElement<double>(Evac_Full::VT_PICKUPALT, pickupAlt, 0.0);
  }
  void add_ce(double ce) {
    fbb_.AddElement<double>(Evac_Full::VT_CE, ce, 0.0);
  }
  void add_le(double le) {
    fbb_.AddElement<double>(Evac_Full::VT_LE, le, 0.0);
  }
  void add_terrain(::flatbuffers::Offset<::flatbuffers::String> terrain) {
    fbb_.AddOffset(Evac_Full::VT_TERRAIN, terrain);
  }
  void add_obstaclesRemarks(::flatbuffers::Offset<::flatbuffers::String> obstaclesRemarks) {
    fbb_.AddOffset(Evac_Full::VT_OBSTACLESREMARKS, obstaclesRemarks);
  }
  void add_terrainRemarks(::flatbuffers::Offset<::flatbuffers::String> terrainRemarks) {
    fbb_.AddOffset(Evac_Full::VT_TERRAINREMARKS, terrainRemarks);
  }
  void add_zoneName(::flatbuffers::Offset<::flatbuffers::String> zoneName) {
    fbb_.AddOffset(Evac_Full::VT_ZONENAME, zoneName);
  }
  void add_zoneMarking(::flatbuffers::Offset<::flatbuffers::String> zoneMarking) {
    fbb_.AddOffset(Evac_Full::VT_ZONEMARKING, zoneMarking);
  }
  void add_zoneSecurity(::flatbuffers::Offset<::flatbuffers::String> zoneSecurity) {
    fbb_.AddOffset(Evac_Full::VT_ZONESECURITY, zoneSecurity);
  }
  void add_zoneMarkingColor(::flatbuffers::Offset<::flatbuffers::String> zoneMarkingColor) {
    fbb_.AddOffset(Evac_Full::VT_ZONEMARKINGCOLOR, zoneMarkingColor);
  }
  void add_zoneHot(bool zoneHot) {
    fbb_.AddElement<uint8_t>(Evac_Full::VT_ZONEHOT, static_cast<uint8_t>(zoneHot), 0);
  }
  void add_cntctFreq(double cntctFreq) {
    fbb_.AddElement<double>(Evac_Full::VT_CNTCTFREQ, cntctFreq, 0.0);
  }
  void add_zoneContrCallSign(::flatbuffers::Offset<::flatbuffers::String> zoneContrCallSign) {
    fbb_.AddOffset(Evac_Full::VT_ZONECONTRCALLSIGN, zoneContrCallSign);
  }
  void add_numCasualties(int32_t numCasualties) {
    fbb_.AddElement<int32_t>(Evac_Full::VT_NUMCASUALTIES, numCasualties, 0);
  }
  void add_comments(::flatbuffers::Offset<::flatbuffers::String> comments) {
    fbb_.AddOffset(Evac_Full::VT_COMMENTS, comments);
  }
  void add_casualtyInfo(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> casualtyInfo) {
    fbb_.AddOffset(Evac_Full::VT_CASUALTYINFO, casualtyInfo);
  }
  void add_enemyData(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> enemyData) {
    fbb_.AddOffset(Evac_Full::VT_ENEMYDATA, enemyData);
  }
  void add_relatedDocs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> relatedDocs) {
    fbb_.AddOffset(Evac_Full::VT_RELATEDDOCS, relatedDocs);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(Evac_Full::VT_ORIGNETWORK, origNetwork);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(Evac_Full::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(Evac_Full::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(Evac_Full::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(Evac_Full::VT_ORIGIN, origin);
  }
  void add_dataMode(Evac_Full_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(Evac_Full::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  explicit Evac_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Evac_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Evac_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Evac_Full> CreateEvac_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> medevacId = 0,
    Evac_Full_type_Enum type = Evac_Full_type_Enum_REQUEST,
    ::flatbuffers::Offset<::flatbuffers::String> missionType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idWeatherReport = 0,
    int32_t numKIA = 0,
    int32_t numWIA = 0,
    int32_t numLitter = 0,
    int32_t numAmbulatory = 0,
    bool medicReq = false,
    ::flatbuffers::Offset<::flatbuffers::String> reqNum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reqTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reqCallSign = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pickupTime = 0,
    double pickupLat = 0.0,
    double pickupLon = 0.0,
    double pickupAlt = 0.0,
    double ce = 0.0,
    double le = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> terrain = 0,
    ::flatbuffers::Offset<::flatbuffers::String> obstaclesRemarks = 0,
    ::flatbuffers::Offset<::flatbuffers::String> terrainRemarks = 0,
    ::flatbuffers::Offset<::flatbuffers::String> zoneName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> zoneMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> zoneSecurity = 0,
    ::flatbuffers::Offset<::flatbuffers::String> zoneMarkingColor = 0,
    bool zoneHot = false,
    double cntctFreq = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> zoneContrCallSign = 0,
    int32_t numCasualties = 0,
    ::flatbuffers::Offset<::flatbuffers::String> comments = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> casualtyInfo = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> enemyData = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> relatedDocs = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    Evac_Full_dataMode_Enum dataMode = Evac_Full_dataMode_Enum_REAL) {
  Evac_FullBuilder builder_(_fbb);
  builder_.add_cntctFreq(cntctFreq);
  builder_.add_le(le);
  builder_.add_ce(ce);
  builder_.add_pickupAlt(pickupAlt);
  builder_.add_pickupLon(pickupLon);
  builder_.add_pickupLat(pickupLat);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_origNetwork(origNetwork);
  builder_.add_relatedDocs(relatedDocs);
  builder_.add_enemyData(enemyData);
  builder_.add_casualtyInfo(casualtyInfo);
  builder_.add_comments(comments);
  builder_.add_numCasualties(numCasualties);
  builder_.add_zoneContrCallSign(zoneContrCallSign);
  builder_.add_zoneMarkingColor(zoneMarkingColor);
  builder_.add_zoneSecurity(zoneSecurity);
  builder_.add_zoneMarking(zoneMarking);
  builder_.add_zoneName(zoneName);
  builder_.add_terrainRemarks(terrainRemarks);
  builder_.add_obstaclesRemarks(obstaclesRemarks);
  builder_.add_terrain(terrain);
  builder_.add_pickupTime(pickupTime);
  builder_.add_reqCallSign(reqCallSign);
  builder_.add_reqTime(reqTime);
  builder_.add_reqNum(reqNum);
  builder_.add_numAmbulatory(numAmbulatory);
  builder_.add_numLitter(numLitter);
  builder_.add_numWIA(numWIA);
  builder_.add_numKIA(numKIA);
  builder_.add_idWeatherReport(idWeatherReport);
  builder_.add_missionType(missionType);
  builder_.add_medevacId(medevacId);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_zoneHot(zoneHot);
  builder_.add_medicReq(medicReq);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Evac_Full> CreateEvac_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *medevacId = nullptr,
    Evac_Full_type_Enum type = Evac_Full_type_Enum_REQUEST,
    const char *missionType = nullptr,
    const char *idWeatherReport = nullptr,
    int32_t numKIA = 0,
    int32_t numWIA = 0,
    int32_t numLitter = 0,
    int32_t numAmbulatory = 0,
    bool medicReq = false,
    const char *reqNum = nullptr,
    const char *reqTime = nullptr,
    const char *reqCallSign = nullptr,
    const char *pickupTime = nullptr,
    double pickupLat = 0.0,
    double pickupLon = 0.0,
    double pickupAlt = 0.0,
    double ce = 0.0,
    double le = 0.0,
    const char *terrain = nullptr,
    const char *obstaclesRemarks = nullptr,
    const char *terrainRemarks = nullptr,
    const char *zoneName = nullptr,
    const char *zoneMarking = nullptr,
    const char *zoneSecurity = nullptr,
    const char *zoneMarkingColor = nullptr,
    bool zoneHot = false,
    double cntctFreq = 0.0,
    const char *zoneContrCallSign = nullptr,
    int32_t numCasualties = 0,
    const char *comments = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *casualtyInfo = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *enemyData = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *relatedDocs = nullptr,
    const char *origNetwork = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    Evac_Full_dataMode_Enum dataMode = Evac_Full_dataMode_Enum_REAL) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto medevacId__ = medevacId ? _fbb.CreateString(medevacId) : 0;
  auto missionType__ = missionType ? _fbb.CreateString(missionType) : 0;
  auto idWeatherReport__ = idWeatherReport ? _fbb.CreateString(idWeatherReport) : 0;
  auto reqNum__ = reqNum ? _fbb.CreateString(reqNum) : 0;
  auto reqTime__ = reqTime ? _fbb.CreateString(reqTime) : 0;
  auto reqCallSign__ = reqCallSign ? _fbb.CreateString(reqCallSign) : 0;
  auto pickupTime__ = pickupTime ? _fbb.CreateString(pickupTime) : 0;
  auto terrain__ = terrain ? _fbb.CreateString(terrain) : 0;
  auto obstaclesRemarks__ = obstaclesRemarks ? _fbb.CreateString(obstaclesRemarks) : 0;
  auto terrainRemarks__ = terrainRemarks ? _fbb.CreateString(terrainRemarks) : 0;
  auto zoneName__ = zoneName ? _fbb.CreateString(zoneName) : 0;
  auto zoneMarking__ = zoneMarking ? _fbb.CreateString(zoneMarking) : 0;
  auto zoneSecurity__ = zoneSecurity ? _fbb.CreateString(zoneSecurity) : 0;
  auto zoneMarkingColor__ = zoneMarkingColor ? _fbb.CreateString(zoneMarkingColor) : 0;
  auto zoneContrCallSign__ = zoneContrCallSign ? _fbb.CreateString(zoneContrCallSign) : 0;
  auto comments__ = comments ? _fbb.CreateString(comments) : 0;
  auto casualtyInfo__ = casualtyInfo ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*casualtyInfo) : 0;
  auto enemyData__ = enemyData ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*enemyData) : 0;
  auto relatedDocs__ = relatedDocs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*relatedDocs) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  return CreateEvac_Full(
      _fbb,
      id__,
      classificationMarking__,
      medevacId__,
      type,
      missionType__,
      idWeatherReport__,
      numKIA,
      numWIA,
      numLitter,
      numAmbulatory,
      medicReq,
      reqNum__,
      reqTime__,
      reqCallSign__,
      pickupTime__,
      pickupLat,
      pickupLon,
      pickupAlt,
      ce,
      le,
      terrain__,
      obstaclesRemarks__,
      terrainRemarks__,
      zoneName__,
      zoneMarking__,
      zoneSecurity__,
      zoneMarkingColor__,
      zoneHot,
      cntctFreq,
      zoneContrCallSign__,
      numCasualties,
      comments__,
      casualtyInfo__,
      enemyData__,
      relatedDocs__,
      origNetwork__,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      dataMode);
}

inline const Evac_Full *GetEvac_Full(const void *buf) {
  return ::flatbuffers::GetRoot<Evac_Full>(buf);
}

inline const Evac_Full *GetSizePrefixedEvac_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Evac_Full>(buf);
}

inline const char *Evac_FullIdentifier() {
  return "EVAC";
}

inline bool Evac_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Evac_FullIdentifier());
}

inline bool SizePrefixedEvac_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Evac_FullIdentifier(), true);
}

inline bool VerifyEvac_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Evac_Full>(Evac_FullIdentifier());
}

inline bool VerifySizePrefixedEvac_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Evac_Full>(Evac_FullIdentifier());
}

inline void FinishEvac_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Evac_Full> root) {
  fbb.Finish(root, Evac_FullIdentifier());
}

inline void FinishSizePrefixedEvac_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Evac_Full> root) {
  fbb.FinishSizePrefixed(root, Evac_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
