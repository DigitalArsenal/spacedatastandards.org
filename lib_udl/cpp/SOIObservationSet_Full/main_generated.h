// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct SOIObservationSet_Full;
struct SOIObservationSet_FullBuilder;

enum SOIObservationSet_Full_type_Enum : int8_t {
  /// No description available.
  SOIObservationSet_Full_type_Enum_OPTICAL = 0,
  /// No description available.
  SOIObservationSet_Full_type_Enum_RADAR = 1,
  SOIObservationSet_Full_type_Enum_MIN = SOIObservationSet_Full_type_Enum_OPTICAL,
  SOIObservationSet_Full_type_Enum_MAX = SOIObservationSet_Full_type_Enum_RADAR
};

inline const SOIObservationSet_Full_type_Enum (&EnumValuesSOIObservationSet_Full_type_Enum())[2] {
  static const SOIObservationSet_Full_type_Enum values[] = {
    SOIObservationSet_Full_type_Enum_OPTICAL,
    SOIObservationSet_Full_type_Enum_RADAR
  };
  return values;
}

inline const char * const *EnumNamesSOIObservationSet_Full_type_Enum() {
  static const char * const names[3] = {
    "OPTICAL",
    "RADAR",
    nullptr
  };
  return names;
}

inline const char *EnumNameSOIObservationSet_Full_type_Enum(SOIObservationSet_Full_type_Enum e) {
  if (::flatbuffers::IsOutRange(e, SOIObservationSet_Full_type_Enum_OPTICAL, SOIObservationSet_Full_type_Enum_RADAR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSOIObservationSet_Full_type_Enum()[index];
}

enum SOIObservationSet_Full_referenceFrame_Enum : int8_t {
  /// No description available.
  SOIObservationSet_Full_referenceFrame_Enum_J2000 = 0,
  /// No description available.
  SOIObservationSet_Full_referenceFrame_Enum_EFG_TDR = 1,
  /// No description available.
  SOIObservationSet_Full_referenceFrame_Enum_ECR_ECEF = 2,
  /// No description available.
  SOIObservationSet_Full_referenceFrame_Enum_TEME = 3,
  /// No description available.
  SOIObservationSet_Full_referenceFrame_Enum_ITRF = 4,
  /// No description available.
  SOIObservationSet_Full_referenceFrame_Enum_GCRF = 5,
  SOIObservationSet_Full_referenceFrame_Enum_MIN = SOIObservationSet_Full_referenceFrame_Enum_J2000,
  SOIObservationSet_Full_referenceFrame_Enum_MAX = SOIObservationSet_Full_referenceFrame_Enum_GCRF
};

inline const SOIObservationSet_Full_referenceFrame_Enum (&EnumValuesSOIObservationSet_Full_referenceFrame_Enum())[6] {
  static const SOIObservationSet_Full_referenceFrame_Enum values[] = {
    SOIObservationSet_Full_referenceFrame_Enum_J2000,
    SOIObservationSet_Full_referenceFrame_Enum_EFG_TDR,
    SOIObservationSet_Full_referenceFrame_Enum_ECR_ECEF,
    SOIObservationSet_Full_referenceFrame_Enum_TEME,
    SOIObservationSet_Full_referenceFrame_Enum_ITRF,
    SOIObservationSet_Full_referenceFrame_Enum_GCRF
  };
  return values;
}

inline const char * const *EnumNamesSOIObservationSet_Full_referenceFrame_Enum() {
  static const char * const names[7] = {
    "J2000",
    "EFG_TDR",
    "ECR_ECEF",
    "TEME",
    "ITRF",
    "GCRF",
    nullptr
  };
  return names;
}

inline const char *EnumNameSOIObservationSet_Full_referenceFrame_Enum(SOIObservationSet_Full_referenceFrame_Enum e) {
  if (::flatbuffers::IsOutRange(e, SOIObservationSet_Full_referenceFrame_Enum_J2000, SOIObservationSet_Full_referenceFrame_Enum_GCRF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSOIObservationSet_Full_referenceFrame_Enum()[index];
}

enum SOIObservationSet_Full_senReferenceFrame_Enum : int8_t {
  /// No description available.
  SOIObservationSet_Full_senReferenceFrame_Enum_J2000 = 0,
  /// No description available.
  SOIObservationSet_Full_senReferenceFrame_Enum_EFG_TDR = 1,
  /// No description available.
  SOIObservationSet_Full_senReferenceFrame_Enum_ECR_ECEF = 2,
  /// No description available.
  SOIObservationSet_Full_senReferenceFrame_Enum_TEME = 3,
  /// No description available.
  SOIObservationSet_Full_senReferenceFrame_Enum_ITRF = 4,
  /// No description available.
  SOIObservationSet_Full_senReferenceFrame_Enum_GCRF = 5,
  SOIObservationSet_Full_senReferenceFrame_Enum_MIN = SOIObservationSet_Full_senReferenceFrame_Enum_J2000,
  SOIObservationSet_Full_senReferenceFrame_Enum_MAX = SOIObservationSet_Full_senReferenceFrame_Enum_GCRF
};

inline const SOIObservationSet_Full_senReferenceFrame_Enum (&EnumValuesSOIObservationSet_Full_senReferenceFrame_Enum())[6] {
  static const SOIObservationSet_Full_senReferenceFrame_Enum values[] = {
    SOIObservationSet_Full_senReferenceFrame_Enum_J2000,
    SOIObservationSet_Full_senReferenceFrame_Enum_EFG_TDR,
    SOIObservationSet_Full_senReferenceFrame_Enum_ECR_ECEF,
    SOIObservationSet_Full_senReferenceFrame_Enum_TEME,
    SOIObservationSet_Full_senReferenceFrame_Enum_ITRF,
    SOIObservationSet_Full_senReferenceFrame_Enum_GCRF
  };
  return values;
}

inline const char * const *EnumNamesSOIObservationSet_Full_senReferenceFrame_Enum() {
  static const char * const names[7] = {
    "J2000",
    "EFG_TDR",
    "ECR_ECEF",
    "TEME",
    "ITRF",
    "GCRF",
    nullptr
  };
  return names;
}

inline const char *EnumNameSOIObservationSet_Full_senReferenceFrame_Enum(SOIObservationSet_Full_senReferenceFrame_Enum e) {
  if (::flatbuffers::IsOutRange(e, SOIObservationSet_Full_senReferenceFrame_Enum_J2000, SOIObservationSet_Full_senReferenceFrame_Enum_GCRF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSOIObservationSet_Full_senReferenceFrame_Enum()[index];
}

enum SOIObservationSet_Full_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  SOIObservationSet_Full_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  SOIObservationSet_Full_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  SOIObservationSet_Full_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  SOIObservationSet_Full_dataMode_Enum_EXERCISE = 3,
  SOIObservationSet_Full_dataMode_Enum_MIN = SOIObservationSet_Full_dataMode_Enum_REAL,
  SOIObservationSet_Full_dataMode_Enum_MAX = SOIObservationSet_Full_dataMode_Enum_EXERCISE
};

inline const SOIObservationSet_Full_dataMode_Enum (&EnumValuesSOIObservationSet_Full_dataMode_Enum())[4] {
  static const SOIObservationSet_Full_dataMode_Enum values[] = {
    SOIObservationSet_Full_dataMode_Enum_REAL,
    SOIObservationSet_Full_dataMode_Enum_TEST,
    SOIObservationSet_Full_dataMode_Enum_SIMULATED,
    SOIObservationSet_Full_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesSOIObservationSet_Full_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSOIObservationSet_Full_dataMode_Enum(SOIObservationSet_Full_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, SOIObservationSet_Full_dataMode_Enum_REAL, SOIObservationSet_Full_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSOIObservationSet_Full_dataMode_Enum()[index];
}

/// /// These services provide operations for posting space object idenfification observation sets.
struct SOIObservationSet_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SOIObservationSet_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_MSGCREATEDATE = 8,
    VT_IDSENSOR = 10,
    VT_ORIGSENSORID = 12,
    VT_SENSORASID = 14,
    VT_IDONORBIT = 16,
    VT_SATNO = 18,
    VT_ORIGOBJECTID = 20,
    VT_SENLAT = 22,
    VT_SENLON = 24,
    VT_SENALT = 26,
    VT_SENX = 28,
    VT_SENY = 30,
    VT_SENZ = 32,
    VT_SENVELX = 34,
    VT_SENVELY = 36,
    VT_SENVELZ = 38,
    VT_IDELSET = 40,
    VT_STARTTIME = 42,
    VT_ENDTIME = 44,
    VT_NUMOBS = 46,
    VT_TYPE = 48,
    VT_POLARANGLESTART = 50,
    VT_POLARANGLEEND = 52,
    VT_REFERENCEFRAME = 54,
    VT_SENREFERENCEFRAME = 56,
    VT_LOSDECLINATIONSTART = 58,
    VT_LOSDECLINATIONEND = 60,
    VT_POINTINGANGLEAZSTART = 62,
    VT_POINTINGANGLEAZEND = 64,
    VT_POINTINGANGLEELSTART = 66,
    VT_POINTINGANGLEELEND = 68,
    VT_PIXELARRAYWIDTH = 70,
    VT_PIXELARRAYHEIGHT = 72,
    VT_NUMSPECTRALFILTERS = 74,
    VT_SPECTRALFILTERS = 76,
    VT_COLLECTIONMODE = 78,
    VT_GAIN = 80,
    VT_BINNINGHORIZ = 82,
    VT_BINNINGVERT = 84,
    VT_SOLARMAG = 86,
    VT_PIXELMIN = 88,
    VT_PIXELMAX = 90,
    VT_SOFTWAREVERSION = 92,
    VT_SATELLITENAME = 94,
    VT_STARCATNAME = 96,
    VT_CORRQUALITY = 98,
    VT_UCT = 100,
    VT_VALIDCALIBRATIONS = 102,
    VT_CALIBRATIONTYPE = 104,
    VT_PERCENTSATTHRESHOLD = 106,
    VT_CHANGEDETECTED = 108,
    VT_PERIODICITYCHANGEDETECTED = 110,
    VT_BRIGHTNESSVARIANCECHANGEDETECTED = 112,
    VT_SOLARPHASEANGLEBRIGHTNESSCHANGEDETECTED = 114,
    VT_CHANGECONF = 116,
    VT_COLLECTIONDENSITYCONF = 118,
    VT_PERIODICITYSAMPLINGCONF = 120,
    VT_PERIODICITYDETECTIONCONF = 122,
    VT_COLLECTIONID = 124,
    VT_CALIBRATIONS = 126,
    VT_TAGS = 128,
    VT_TRANSACTIONID = 130,
    VT_OPTICALSOIOBSERVATIONLIST = 132,
    VT_RADARSOIOBSERVATIONLIST = 134,
    VT_CREATEDAT = 136,
    VT_CREATEDBY = 138,
    VT_SOURCE = 140,
    VT_ORIGIN = 142,
    VT_ORIGNETWORK = 144,
    VT_SOURCEDL = 146,
    VT_DATAMODE = 148
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// SOI msgCreateDate time in ISO 8601 UTC time, with millisecond precision.
  /// Example: /// Example: 2022-07-07T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *msgCreateDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSGCREATEDATE);
  }
  /// ID of the observing sensor.
  /// Example: /// Example: SENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR);
  }
  /// Optional identifier provided by the record source to indicate the sensor identifier to which this attitude set applies if this set is reporting a single sensor orientation. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origSensorId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGSENSORID);
  }
  /// ID of the AttitudeSet record for the observing sensor.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *sensorAsId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SENSORASID);
  }
  /// Unique identifier of the target on-orbit object, if correlated.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idOnOrbit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDONORBIT);
  }
  /// Satellite/catalog number of the target on-orbit object.
  /// Example: /// Example: 101
  /// Constraints: No constraints specified.
  int32_t satNo() const {
    return GetField<int32_t>(VT_SATNO, 0);
  }
  /// Optional identifier provided by observation source to indicate the target onorbit object of this observation. This may be an internal identifier and not necessarily a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *origObjectId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGOBJECTID);
  }
  /// Sensor WGS84 latitude at startTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  double senlat() const {
    return GetField<double>(VT_SENLAT, 0.0);
  }
  /// Sensor WGS84 longitude at startTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -180 to 180 degrees (negative values south of equator).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  double senlon() const {
    return GetField<double>(VT_SENLON, 0.0);
  }
  /// Sensor altitude at startTime (if mobile/onorbit) in kilometers.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senalt() const {
    return GetField<double>(VT_SENALT, 0.0);
  }
  /// Cartesian X position of the observing mobile/onorbit sensor at startTime, in kilometers, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senx() const {
    return GetField<double>(VT_SENX, 0.0);
  }
  /// Cartesian Y position of the observing mobile/onorbit sensor at startTime, in kilometers, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double seny() const {
    return GetField<double>(VT_SENY, 0.0);
  }
  /// Cartesian Z position of the observing mobile/onorbit sensor at startTime, in kilometers, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senz() const {
    return GetField<double>(VT_SENZ, 0.0);
  }
  /// Cartesian X velocity of the observing mobile/onorbit sensor at startTime, in kilometers per second, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senvelx() const {
    return GetField<double>(VT_SENVELX, 0.0);
  }
  /// Cartesian Y velocity of the observing mobile/onorbit sensor at startTime, in kilometers per second, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senvely() const {
    return GetField<double>(VT_SENVELY, 0.0);
  }
  /// Cartesian Z velocity of the observing mobile/onorbit sensor at startTime, in kilometers per second, in the specified senReferenceFrame. If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senvelz() const {
    return GetField<double>(VT_SENVELZ, 0.0);
  }
  /// ID of the UDL Elset of the Space Object under observation.
  /// Example: /// Example: REF-ELSET-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idElset() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDELSET);
  }
  /// Observation set detection start time in ISO 8601 UTC with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *startTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STARTTIME);
  }
  /// Observation set detection end time in ISO 8601 UTC with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *endTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENDTIME);
  }
  /// The number of observation records in the set.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t numObs() const {
    return GetField<int32_t>(VT_NUMOBS, 0);
  }
  /// Observation type (OPTICAL, RADAR).
  /// Example: /// Example: OPTICAL
  /// Constraints: Minimum length = 1, Maximum length = 24
  SOIObservationSet_Full_type_Enum type() const {
    return static_cast<SOIObservationSet_Full_type_Enum>(GetField<int8_t>(VT_TYPE, 0));
  }
  /// Polar angle of the gimbal/mount at observation set detection start time in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double polarAngleStart() const {
    return GetField<double>(VT_POLARANGLESTART, 0.0);
  }
  /// Polar angle of the gimbal/mount at observation set detection end time in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double polarAngleEnd() const {
    return GetField<double>(VT_POLARANGLEEND, 0.0);
  }
  /// The reference frame of the observation measurements. If the referenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  SOIObservationSet_Full_referenceFrame_Enum referenceFrame() const {
    return static_cast<SOIObservationSet_Full_referenceFrame_Enum>(GetField<int8_t>(VT_REFERENCEFRAME, 0));
  }
  /// The reference frame of the observing sensor state. If the senReferenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  SOIObservationSet_Full_senReferenceFrame_Enum senReferenceFrame() const {
    return static_cast<SOIObservationSet_Full_senReferenceFrame_Enum>(GetField<int8_t>(VT_SENREFERENCEFRAME, 0));
  }
  /// Line of sight declination at observation set detection start time. Specified in degrees, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed (e.g -30 to 130.0).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double losDeclinationStart() const {
    return GetField<double>(VT_LOSDECLINATIONSTART, 0.0);
  }
  /// Line of sight declination at observation set detection end time. Specified in degrees, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed (e.g -30 to 130.0).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double losDeclinationEnd() const {
    return GetField<double>(VT_LOSDECLINATIONEND, 0.0);
  }
  /// Pointing angle of the Azimuth gimbal/mount at observation set detection start time. Specified in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double pointingAngleAzStart() const {
    return GetField<double>(VT_POINTINGANGLEAZSTART, 0.0);
  }
  /// Pointing angle of the Azimuth gimbal/mount at observation set detection end time. Specified in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double pointingAngleAzEnd() const {
    return GetField<double>(VT_POINTINGANGLEAZEND, 0.0);
  }
  /// Pointing angle of the Elevation gimbal/mount at observation set detection start time. Specified in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double pointingAngleElStart() const {
    return GetField<double>(VT_POINTINGANGLEELSTART, 0.0);
  }
  /// Pointing angle of the Elevation gimbal/mount at observation set detection end time. Specified in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double pointingAngleElEnd() const {
    return GetField<double>(VT_POINTINGANGLEELEND, 0.0);
  }
  /// Pixel array size (width) in pixels.
  /// Example: /// Example: 32
  /// Constraints: No constraints specified.
  int32_t pixelArrayWidth() const {
    return GetField<int32_t>(VT_PIXELARRAYWIDTH, 0);
  }
  /// Pixel array size (height) in pixels.
  /// Example: /// Example: 32
  /// Constraints: No constraints specified.
  int32_t pixelArrayHeight() const {
    return GetField<int32_t>(VT_PIXELARRAYHEIGHT, 0);
  }
  /// The value is the number of spectral filters used.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  int32_t numSpectralFilters() const {
    return GetField<int32_t>(VT_NUMSPECTRALFILTERS, 0);
  }
  /// Array of the SpectralFilters keywords, must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.
  /// Example: /// Example: ['Keyword1', 'Keyword2']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *spectralFilters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SPECTRALFILTERS);
  }
  /// Mode indicating telescope movement during collection (AUTOTRACK, MANUAL AUTOTRACK, MANUAL RATE TRACK, MANUAL SIDEREAL, SIDEREAL, RATE TRACK).
  /// Example: /// Example: RATE TRACK
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *collectionMode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLECTIONMODE);
  }
  /// The gain used during the collection, in units of photoelectrons per analog-to-digital unit (e-/ADU). If no gain is used, the value = 1.
  /// Example: /// Example: 234.2
  /// Constraints: No constraints specified.
  double gain() const {
    return GetField<double>(VT_GAIN, 0.0);
  }
  /// The number of pixels binned horizontally.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t binningHoriz() const {
    return GetField<int32_t>(VT_BINNINGHORIZ, 0);
  }
  /// The number of pixels binned vertically.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t binningVert() const {
    return GetField<int32_t>(VT_BINNINGVERT, 0);
  }
  /// The in-band solar magnitude at 1 A.U.
  /// Example: /// Example: -26.91
  /// Constraints: No constraints specified.
  double solarMag() const {
    return GetField<double>(VT_SOLARMAG, 0.0);
  }
  /// The minimum valid pixel value.
  /// Example: /// Example: 0
  /// Constraints: No constraints specified.
  int32_t pixelMin() const {
    return GetField<int32_t>(VT_PIXELMIN, 0);
  }
  /// The maximum valid pixel value.
  /// Example: /// Example: 16383
  /// Constraints: No constraints specified.
  int32_t pixelMax() const {
    return GetField<int32_t>(VT_PIXELMAX, 0);
  }
  /// Software Version used to Capture, Process, and Deliver the data.
  /// Example: /// Example: GSV99/17-1
  /// Constraints: Minimum length = 0, Maximum length = 70
  const ::flatbuffers::String *softwareVersion() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOFTWAREVERSION);
  }
  /// Name of the target satellite.
  /// Example: /// Example: TITAN 3C TRANSTAGE R/B
  /// Constraints: Minimum length = 0, Maximum length = 70
  const ::flatbuffers::String *satelliteName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SATELLITENAME);
  }
  /// Name of the Star Catalog used for photometry and astrometry.
  /// Example: /// Example: SSTRC5
  /// Constraints: Minimum length = 0, Maximum length = 70
  const ::flatbuffers::String *starCatName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STARCATNAME);
  }
  /// Object Correlation Quality value. Measures how close the observed object's orbit is to matching an object in the catalog. The scale of this field may vary depending on provider. Users should consult the data provider to verify the meaning of the value (e.g. A value of 0.0 indicates a high/strong correlation, while a value closer to 1.0 indicates low/weak correlation).
  /// Example: /// Example: 0.327
  /// Constraints: No constraints specified.
  double corrQuality() const {
    return GetField<double>(VT_CORRQUALITY, 0.0);
  }
  /// Boolean indicating whether the target object was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool uct() const {
    return GetField<uint8_t>(VT_UCT, 0) != 0;
  }
  /// Key to indicate which, if any of, the pre/post photometer calibrations are valid for use when generating data for the EOSSA file. If the field is not populated, then the provided calibration data will be used when generating the EOSSA file (e.g. PRE, POST, BOTH, NONE).
  /// Example: /// Example: BOTH
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *validCalibrations() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALIDCALIBRATIONS);
  }
  /// Type of calibration used by the Sensor (e.g. ALL SKY, DIFFERENTIAL, DEFAULT, NONE).
  /// Example: /// Example: ALL SKY
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *calibrationType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALIBRATIONTYPE);
  }
  /// A threshold for percent of pixels that make up object signal that are beyond the saturation point for the sensor that are removed in the EOSSA file, in range of 0 to 1.
  /// Example: /// Example: 0.1
  /// Constraints: No constraints specified.
  double percentSatThreshold() const {
    return GetField<double>(VT_PERCENTSATTHRESHOLD, 0.0);
  }
  /// Boolean indicating if any change event was detected, based on historical collection data for the object.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool changeDetected() const {
    return GetField<uint8_t>(VT_CHANGEDETECTED, 0) != 0;
  }
  /// Boolean indicating if a periodicity change event was detected, based on historical collection data for the object.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool periodicityChangeDetected() const {
    return GetField<uint8_t>(VT_PERIODICITYCHANGEDETECTED, 0) != 0;
  }
  /// Boolean indicating if a brightness variance change event was detected, based on historical collection data for the object.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool brightnessVarianceChangeDetected() const {
    return GetField<uint8_t>(VT_BRIGHTNESSVARIANCECHANGEDETECTED, 0) != 0;
  }
  /// Boolean indicating if a solar phase angle brightness change event was detected, based on historical collection data for the object.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool solarPhaseAngleBrightnessChangeDetected() const {
    return GetField<uint8_t>(VT_SOLARPHASEANGLEBRIGHTNESSCHANGEDETECTED, 0) != 0;
  }
  /// Overall qualitative confidence assessment of change detection results (e.g. HIGH, MEDIUM, LOW).
  /// Example: /// Example: MEDIUM
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *changeConf() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHANGECONF);
  }
  /// Qualitative Collection Density assessment, with respect to confidence of detecting a change event (e.g. HIGH, MEDIUM, LOW).
  /// Example: /// Example: MEDIUM
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *collectionDensityConf() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLECTIONDENSITYCONF);
  }
  /// Qualitative Periodicity Sampling assessment, with respect to confidence of detecting a change event (e.g. HIGH, MEDIUM, LOW).
  /// Example: /// Example: MEDIUM
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *periodicitySamplingConf() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PERIODICITYSAMPLINGCONF);
  }
  /// Qualitative assessment of the periodicity detection results from the Attitude and Shape Retrieval (ASR) Periodicity Assessment (PA) Tool (e.g. HIGH, MEDIUM, LOW).
  /// Example: /// Example: MEDIUM
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *periodicityDetectionConf() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PERIODICITYDETECTIONCONF);
  }
  /// Universally Unique collection ID. Mechanism to correlate Single Point Photometry (SPP) JSON files to images.
  /// Example: /// Example: b5133288-ab63-4b15-81f6-c7eec0cdb0c0
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *collectionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLECTIONID);
  }
  /// Array of SOI Calibrations associated with this SOIObservationSet.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *calibrations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CALIBRATIONS);
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['TAG1', 'TAG2']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TAGS);
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *transactionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSACTIONID);
  }
  /// OpticalSOIObservations associated with this SOIObservationSet.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *opticalSOIObservationList() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OPTICALSOIOBSERVATIONLIST);
  }
  /// RadarSOIObservations associated with this RadarSOIObservationSet.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *radarSOIObservationList() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_RADARSOIOBSERVATIONLIST);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *sourceDL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEDL);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  SOIObservationSet_Full_dataMode_Enum dataMode() const {
    return static_cast<SOIObservationSet_Full_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_MSGCREATEDATE) &&
           verifier.VerifyString(msgCreateDate()) &&
           VerifyOffset(verifier, VT_IDSENSOR) &&
           verifier.VerifyString(idSensor()) &&
           VerifyOffset(verifier, VT_ORIGSENSORID) &&
           verifier.VerifyString(origSensorId()) &&
           VerifyOffset(verifier, VT_SENSORASID) &&
           verifier.VerifyString(sensorAsId()) &&
           VerifyOffset(verifier, VT_IDONORBIT) &&
           verifier.VerifyString(idOnOrbit()) &&
           VerifyField<int32_t>(verifier, VT_SATNO, 4) &&
           VerifyOffset(verifier, VT_ORIGOBJECTID) &&
           verifier.VerifyString(origObjectId()) &&
           VerifyField<double>(verifier, VT_SENLAT, 8) &&
           VerifyField<double>(verifier, VT_SENLON, 8) &&
           VerifyField<double>(verifier, VT_SENALT, 8) &&
           VerifyField<double>(verifier, VT_SENX, 8) &&
           VerifyField<double>(verifier, VT_SENY, 8) &&
           VerifyField<double>(verifier, VT_SENZ, 8) &&
           VerifyField<double>(verifier, VT_SENVELX, 8) &&
           VerifyField<double>(verifier, VT_SENVELY, 8) &&
           VerifyField<double>(verifier, VT_SENVELZ, 8) &&
           VerifyOffset(verifier, VT_IDELSET) &&
           verifier.VerifyString(idElset()) &&
           VerifyOffset(verifier, VT_STARTTIME) &&
           verifier.VerifyString(startTime()) &&
           VerifyOffset(verifier, VT_ENDTIME) &&
           verifier.VerifyString(endTime()) &&
           VerifyField<int32_t>(verifier, VT_NUMOBS, 4) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<double>(verifier, VT_POLARANGLESTART, 8) &&
           VerifyField<double>(verifier, VT_POLARANGLEEND, 8) &&
           VerifyField<int8_t>(verifier, VT_REFERENCEFRAME, 1) &&
           VerifyField<int8_t>(verifier, VT_SENREFERENCEFRAME, 1) &&
           VerifyField<double>(verifier, VT_LOSDECLINATIONSTART, 8) &&
           VerifyField<double>(verifier, VT_LOSDECLINATIONEND, 8) &&
           VerifyField<double>(verifier, VT_POINTINGANGLEAZSTART, 8) &&
           VerifyField<double>(verifier, VT_POINTINGANGLEAZEND, 8) &&
           VerifyField<double>(verifier, VT_POINTINGANGLEELSTART, 8) &&
           VerifyField<double>(verifier, VT_POINTINGANGLEELEND, 8) &&
           VerifyField<int32_t>(verifier, VT_PIXELARRAYWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_PIXELARRAYHEIGHT, 4) &&
           VerifyField<int32_t>(verifier, VT_NUMSPECTRALFILTERS, 4) &&
           VerifyOffset(verifier, VT_SPECTRALFILTERS) &&
           verifier.VerifyVector(spectralFilters()) &&
           verifier.VerifyVectorOfStrings(spectralFilters()) &&
           VerifyOffset(verifier, VT_COLLECTIONMODE) &&
           verifier.VerifyString(collectionMode()) &&
           VerifyField<double>(verifier, VT_GAIN, 8) &&
           VerifyField<int32_t>(verifier, VT_BINNINGHORIZ, 4) &&
           VerifyField<int32_t>(verifier, VT_BINNINGVERT, 4) &&
           VerifyField<double>(verifier, VT_SOLARMAG, 8) &&
           VerifyField<int32_t>(verifier, VT_PIXELMIN, 4) &&
           VerifyField<int32_t>(verifier, VT_PIXELMAX, 4) &&
           VerifyOffset(verifier, VT_SOFTWAREVERSION) &&
           verifier.VerifyString(softwareVersion()) &&
           VerifyOffset(verifier, VT_SATELLITENAME) &&
           verifier.VerifyString(satelliteName()) &&
           VerifyOffset(verifier, VT_STARCATNAME) &&
           verifier.VerifyString(starCatName()) &&
           VerifyField<double>(verifier, VT_CORRQUALITY, 8) &&
           VerifyField<uint8_t>(verifier, VT_UCT, 1) &&
           VerifyOffset(verifier, VT_VALIDCALIBRATIONS) &&
           verifier.VerifyString(validCalibrations()) &&
           VerifyOffset(verifier, VT_CALIBRATIONTYPE) &&
           verifier.VerifyString(calibrationType()) &&
           VerifyField<double>(verifier, VT_PERCENTSATTHRESHOLD, 8) &&
           VerifyField<uint8_t>(verifier, VT_CHANGEDETECTED, 1) &&
           VerifyField<uint8_t>(verifier, VT_PERIODICITYCHANGEDETECTED, 1) &&
           VerifyField<uint8_t>(verifier, VT_BRIGHTNESSVARIANCECHANGEDETECTED, 1) &&
           VerifyField<uint8_t>(verifier, VT_SOLARPHASEANGLEBRIGHTNESSCHANGEDETECTED, 1) &&
           VerifyOffset(verifier, VT_CHANGECONF) &&
           verifier.VerifyString(changeConf()) &&
           VerifyOffset(verifier, VT_COLLECTIONDENSITYCONF) &&
           verifier.VerifyString(collectionDensityConf()) &&
           VerifyOffset(verifier, VT_PERIODICITYSAMPLINGCONF) &&
           verifier.VerifyString(periodicitySamplingConf()) &&
           VerifyOffset(verifier, VT_PERIODICITYDETECTIONCONF) &&
           verifier.VerifyString(periodicityDetectionConf()) &&
           VerifyOffset(verifier, VT_COLLECTIONID) &&
           verifier.VerifyString(collectionId()) &&
           VerifyOffset(verifier, VT_CALIBRATIONS) &&
           verifier.VerifyVector(calibrations()) &&
           verifier.VerifyVectorOfStrings(calibrations()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyOffset(verifier, VT_TRANSACTIONID) &&
           verifier.VerifyString(transactionId()) &&
           VerifyOffset(verifier, VT_OPTICALSOIOBSERVATIONLIST) &&
           verifier.VerifyVector(opticalSOIObservationList()) &&
           verifier.VerifyVectorOfStrings(opticalSOIObservationList()) &&
           VerifyOffset(verifier, VT_RADARSOIOBSERVATIONLIST) &&
           verifier.VerifyVector(radarSOIObservationList()) &&
           verifier.VerifyVectorOfStrings(radarSOIObservationList()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyOffset(verifier, VT_SOURCEDL) &&
           verifier.VerifyString(sourceDL()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           verifier.EndTable();
  }
};

struct SOIObservationSet_FullBuilder {
  typedef SOIObservationSet_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_msgCreateDate(::flatbuffers::Offset<::flatbuffers::String> msgCreateDate) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_MSGCREATEDATE, msgCreateDate);
  }
  void add_idSensor(::flatbuffers::Offset<::flatbuffers::String> idSensor) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_IDSENSOR, idSensor);
  }
  void add_origSensorId(::flatbuffers::Offset<::flatbuffers::String> origSensorId) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_ORIGSENSORID, origSensorId);
  }
  void add_sensorAsId(::flatbuffers::Offset<::flatbuffers::String> sensorAsId) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_SENSORASID, sensorAsId);
  }
  void add_idOnOrbit(::flatbuffers::Offset<::flatbuffers::String> idOnOrbit) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_IDONORBIT, idOnOrbit);
  }
  void add_satNo(int32_t satNo) {
    fbb_.AddElement<int32_t>(SOIObservationSet_Full::VT_SATNO, satNo, 0);
  }
  void add_origObjectId(::flatbuffers::Offset<::flatbuffers::String> origObjectId) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_ORIGOBJECTID, origObjectId);
  }
  void add_senlat(double senlat) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_SENLAT, senlat, 0.0);
  }
  void add_senlon(double senlon) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_SENLON, senlon, 0.0);
  }
  void add_senalt(double senalt) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_SENALT, senalt, 0.0);
  }
  void add_senx(double senx) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_SENX, senx, 0.0);
  }
  void add_seny(double seny) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_SENY, seny, 0.0);
  }
  void add_senz(double senz) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_SENZ, senz, 0.0);
  }
  void add_senvelx(double senvelx) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_SENVELX, senvelx, 0.0);
  }
  void add_senvely(double senvely) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_SENVELY, senvely, 0.0);
  }
  void add_senvelz(double senvelz) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_SENVELZ, senvelz, 0.0);
  }
  void add_idElset(::flatbuffers::Offset<::flatbuffers::String> idElset) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_IDELSET, idElset);
  }
  void add_startTime(::flatbuffers::Offset<::flatbuffers::String> startTime) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_STARTTIME, startTime);
  }
  void add_endTime(::flatbuffers::Offset<::flatbuffers::String> endTime) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_ENDTIME, endTime);
  }
  void add_numObs(int32_t numObs) {
    fbb_.AddElement<int32_t>(SOIObservationSet_Full::VT_NUMOBS, numObs, 0);
  }
  void add_type(SOIObservationSet_Full_type_Enum type) {
    fbb_.AddElement<int8_t>(SOIObservationSet_Full::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_polarAngleStart(double polarAngleStart) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_POLARANGLESTART, polarAngleStart, 0.0);
  }
  void add_polarAngleEnd(double polarAngleEnd) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_POLARANGLEEND, polarAngleEnd, 0.0);
  }
  void add_referenceFrame(SOIObservationSet_Full_referenceFrame_Enum referenceFrame) {
    fbb_.AddElement<int8_t>(SOIObservationSet_Full::VT_REFERENCEFRAME, static_cast<int8_t>(referenceFrame), 0);
  }
  void add_senReferenceFrame(SOIObservationSet_Full_senReferenceFrame_Enum senReferenceFrame) {
    fbb_.AddElement<int8_t>(SOIObservationSet_Full::VT_SENREFERENCEFRAME, static_cast<int8_t>(senReferenceFrame), 0);
  }
  void add_losDeclinationStart(double losDeclinationStart) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_LOSDECLINATIONSTART, losDeclinationStart, 0.0);
  }
  void add_losDeclinationEnd(double losDeclinationEnd) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_LOSDECLINATIONEND, losDeclinationEnd, 0.0);
  }
  void add_pointingAngleAzStart(double pointingAngleAzStart) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_POINTINGANGLEAZSTART, pointingAngleAzStart, 0.0);
  }
  void add_pointingAngleAzEnd(double pointingAngleAzEnd) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_POINTINGANGLEAZEND, pointingAngleAzEnd, 0.0);
  }
  void add_pointingAngleElStart(double pointingAngleElStart) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_POINTINGANGLEELSTART, pointingAngleElStart, 0.0);
  }
  void add_pointingAngleElEnd(double pointingAngleElEnd) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_POINTINGANGLEELEND, pointingAngleElEnd, 0.0);
  }
  void add_pixelArrayWidth(int32_t pixelArrayWidth) {
    fbb_.AddElement<int32_t>(SOIObservationSet_Full::VT_PIXELARRAYWIDTH, pixelArrayWidth, 0);
  }
  void add_pixelArrayHeight(int32_t pixelArrayHeight) {
    fbb_.AddElement<int32_t>(SOIObservationSet_Full::VT_PIXELARRAYHEIGHT, pixelArrayHeight, 0);
  }
  void add_numSpectralFilters(int32_t numSpectralFilters) {
    fbb_.AddElement<int32_t>(SOIObservationSet_Full::VT_NUMSPECTRALFILTERS, numSpectralFilters, 0);
  }
  void add_spectralFilters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> spectralFilters) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_SPECTRALFILTERS, spectralFilters);
  }
  void add_collectionMode(::flatbuffers::Offset<::flatbuffers::String> collectionMode) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_COLLECTIONMODE, collectionMode);
  }
  void add_gain(double gain) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_GAIN, gain, 0.0);
  }
  void add_binningHoriz(int32_t binningHoriz) {
    fbb_.AddElement<int32_t>(SOIObservationSet_Full::VT_BINNINGHORIZ, binningHoriz, 0);
  }
  void add_binningVert(int32_t binningVert) {
    fbb_.AddElement<int32_t>(SOIObservationSet_Full::VT_BINNINGVERT, binningVert, 0);
  }
  void add_solarMag(double solarMag) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_SOLARMAG, solarMag, 0.0);
  }
  void add_pixelMin(int32_t pixelMin) {
    fbb_.AddElement<int32_t>(SOIObservationSet_Full::VT_PIXELMIN, pixelMin, 0);
  }
  void add_pixelMax(int32_t pixelMax) {
    fbb_.AddElement<int32_t>(SOIObservationSet_Full::VT_PIXELMAX, pixelMax, 0);
  }
  void add_softwareVersion(::flatbuffers::Offset<::flatbuffers::String> softwareVersion) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_SOFTWAREVERSION, softwareVersion);
  }
  void add_satelliteName(::flatbuffers::Offset<::flatbuffers::String> satelliteName) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_SATELLITENAME, satelliteName);
  }
  void add_starCatName(::flatbuffers::Offset<::flatbuffers::String> starCatName) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_STARCATNAME, starCatName);
  }
  void add_corrQuality(double corrQuality) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_CORRQUALITY, corrQuality, 0.0);
  }
  void add_uct(bool uct) {
    fbb_.AddElement<uint8_t>(SOIObservationSet_Full::VT_UCT, static_cast<uint8_t>(uct), 0);
  }
  void add_validCalibrations(::flatbuffers::Offset<::flatbuffers::String> validCalibrations) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_VALIDCALIBRATIONS, validCalibrations);
  }
  void add_calibrationType(::flatbuffers::Offset<::flatbuffers::String> calibrationType) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_CALIBRATIONTYPE, calibrationType);
  }
  void add_percentSatThreshold(double percentSatThreshold) {
    fbb_.AddElement<double>(SOIObservationSet_Full::VT_PERCENTSATTHRESHOLD, percentSatThreshold, 0.0);
  }
  void add_changeDetected(bool changeDetected) {
    fbb_.AddElement<uint8_t>(SOIObservationSet_Full::VT_CHANGEDETECTED, static_cast<uint8_t>(changeDetected), 0);
  }
  void add_periodicityChangeDetected(bool periodicityChangeDetected) {
    fbb_.AddElement<uint8_t>(SOIObservationSet_Full::VT_PERIODICITYCHANGEDETECTED, static_cast<uint8_t>(periodicityChangeDetected), 0);
  }
  void add_brightnessVarianceChangeDetected(bool brightnessVarianceChangeDetected) {
    fbb_.AddElement<uint8_t>(SOIObservationSet_Full::VT_BRIGHTNESSVARIANCECHANGEDETECTED, static_cast<uint8_t>(brightnessVarianceChangeDetected), 0);
  }
  void add_solarPhaseAngleBrightnessChangeDetected(bool solarPhaseAngleBrightnessChangeDetected) {
    fbb_.AddElement<uint8_t>(SOIObservationSet_Full::VT_SOLARPHASEANGLEBRIGHTNESSCHANGEDETECTED, static_cast<uint8_t>(solarPhaseAngleBrightnessChangeDetected), 0);
  }
  void add_changeConf(::flatbuffers::Offset<::flatbuffers::String> changeConf) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_CHANGECONF, changeConf);
  }
  void add_collectionDensityConf(::flatbuffers::Offset<::flatbuffers::String> collectionDensityConf) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_COLLECTIONDENSITYCONF, collectionDensityConf);
  }
  void add_periodicitySamplingConf(::flatbuffers::Offset<::flatbuffers::String> periodicitySamplingConf) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_PERIODICITYSAMPLINGCONF, periodicitySamplingConf);
  }
  void add_periodicityDetectionConf(::flatbuffers::Offset<::flatbuffers::String> periodicityDetectionConf) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_PERIODICITYDETECTIONCONF, periodicityDetectionConf);
  }
  void add_collectionId(::flatbuffers::Offset<::flatbuffers::String> collectionId) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_COLLECTIONID, collectionId);
  }
  void add_calibrations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> calibrations) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_CALIBRATIONS, calibrations);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_TAGS, tags);
  }
  void add_transactionId(::flatbuffers::Offset<::flatbuffers::String> transactionId) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_TRANSACTIONID, transactionId);
  }
  void add_opticalSOIObservationList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> opticalSOIObservationList) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_OPTICALSOIOBSERVATIONLIST, opticalSOIObservationList);
  }
  void add_radarSOIObservationList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> radarSOIObservationList) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_RADARSOIOBSERVATIONLIST, radarSOIObservationList);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_ORIGNETWORK, origNetwork);
  }
  void add_sourceDL(::flatbuffers::Offset<::flatbuffers::String> sourceDL) {
    fbb_.AddOffset(SOIObservationSet_Full::VT_SOURCEDL, sourceDL);
  }
  void add_dataMode(SOIObservationSet_Full_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(SOIObservationSet_Full::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  explicit SOIObservationSet_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SOIObservationSet_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SOIObservationSet_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SOIObservationSet_Full> CreateSOIObservationSet_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> msgCreateDate = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origSensorId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sensorAsId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idOnOrbit = 0,
    int32_t satNo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origObjectId = 0,
    double senlat = 0.0,
    double senlon = 0.0,
    double senalt = 0.0,
    double senx = 0.0,
    double seny = 0.0,
    double senz = 0.0,
    double senvelx = 0.0,
    double senvely = 0.0,
    double senvelz = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> idElset = 0,
    ::flatbuffers::Offset<::flatbuffers::String> startTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> endTime = 0,
    int32_t numObs = 0,
    SOIObservationSet_Full_type_Enum type = SOIObservationSet_Full_type_Enum_OPTICAL,
    double polarAngleStart = 0.0,
    double polarAngleEnd = 0.0,
    SOIObservationSet_Full_referenceFrame_Enum referenceFrame = SOIObservationSet_Full_referenceFrame_Enum_J2000,
    SOIObservationSet_Full_senReferenceFrame_Enum senReferenceFrame = SOIObservationSet_Full_senReferenceFrame_Enum_J2000,
    double losDeclinationStart = 0.0,
    double losDeclinationEnd = 0.0,
    double pointingAngleAzStart = 0.0,
    double pointingAngleAzEnd = 0.0,
    double pointingAngleElStart = 0.0,
    double pointingAngleElEnd = 0.0,
    int32_t pixelArrayWidth = 0,
    int32_t pixelArrayHeight = 0,
    int32_t numSpectralFilters = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> spectralFilters = 0,
    ::flatbuffers::Offset<::flatbuffers::String> collectionMode = 0,
    double gain = 0.0,
    int32_t binningHoriz = 0,
    int32_t binningVert = 0,
    double solarMag = 0.0,
    int32_t pixelMin = 0,
    int32_t pixelMax = 0,
    ::flatbuffers::Offset<::flatbuffers::String> softwareVersion = 0,
    ::flatbuffers::Offset<::flatbuffers::String> satelliteName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> starCatName = 0,
    double corrQuality = 0.0,
    bool uct = false,
    ::flatbuffers::Offset<::flatbuffers::String> validCalibrations = 0,
    ::flatbuffers::Offset<::flatbuffers::String> calibrationType = 0,
    double percentSatThreshold = 0.0,
    bool changeDetected = false,
    bool periodicityChangeDetected = false,
    bool brightnessVarianceChangeDetected = false,
    bool solarPhaseAngleBrightnessChangeDetected = false,
    ::flatbuffers::Offset<::flatbuffers::String> changeConf = 0,
    ::flatbuffers::Offset<::flatbuffers::String> collectionDensityConf = 0,
    ::flatbuffers::Offset<::flatbuffers::String> periodicitySamplingConf = 0,
    ::flatbuffers::Offset<::flatbuffers::String> periodicityDetectionConf = 0,
    ::flatbuffers::Offset<::flatbuffers::String> collectionId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> calibrations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> transactionId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> opticalSOIObservationList = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> radarSOIObservationList = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceDL = 0,
    SOIObservationSet_Full_dataMode_Enum dataMode = SOIObservationSet_Full_dataMode_Enum_REAL) {
  SOIObservationSet_FullBuilder builder_(_fbb);
  builder_.add_percentSatThreshold(percentSatThreshold);
  builder_.add_corrQuality(corrQuality);
  builder_.add_solarMag(solarMag);
  builder_.add_gain(gain);
  builder_.add_pointingAngleElEnd(pointingAngleElEnd);
  builder_.add_pointingAngleElStart(pointingAngleElStart);
  builder_.add_pointingAngleAzEnd(pointingAngleAzEnd);
  builder_.add_pointingAngleAzStart(pointingAngleAzStart);
  builder_.add_losDeclinationEnd(losDeclinationEnd);
  builder_.add_losDeclinationStart(losDeclinationStart);
  builder_.add_polarAngleEnd(polarAngleEnd);
  builder_.add_polarAngleStart(polarAngleStart);
  builder_.add_senvelz(senvelz);
  builder_.add_senvely(senvely);
  builder_.add_senvelx(senvelx);
  builder_.add_senz(senz);
  builder_.add_seny(seny);
  builder_.add_senx(senx);
  builder_.add_senalt(senalt);
  builder_.add_senlon(senlon);
  builder_.add_senlat(senlat);
  builder_.add_sourceDL(sourceDL);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_radarSOIObservationList(radarSOIObservationList);
  builder_.add_opticalSOIObservationList(opticalSOIObservationList);
  builder_.add_transactionId(transactionId);
  builder_.add_tags(tags);
  builder_.add_calibrations(calibrations);
  builder_.add_collectionId(collectionId);
  builder_.add_periodicityDetectionConf(periodicityDetectionConf);
  builder_.add_periodicitySamplingConf(periodicitySamplingConf);
  builder_.add_collectionDensityConf(collectionDensityConf);
  builder_.add_changeConf(changeConf);
  builder_.add_calibrationType(calibrationType);
  builder_.add_validCalibrations(validCalibrations);
  builder_.add_starCatName(starCatName);
  builder_.add_satelliteName(satelliteName);
  builder_.add_softwareVersion(softwareVersion);
  builder_.add_pixelMax(pixelMax);
  builder_.add_pixelMin(pixelMin);
  builder_.add_binningVert(binningVert);
  builder_.add_binningHoriz(binningHoriz);
  builder_.add_collectionMode(collectionMode);
  builder_.add_spectralFilters(spectralFilters);
  builder_.add_numSpectralFilters(numSpectralFilters);
  builder_.add_pixelArrayHeight(pixelArrayHeight);
  builder_.add_pixelArrayWidth(pixelArrayWidth);
  builder_.add_numObs(numObs);
  builder_.add_endTime(endTime);
  builder_.add_startTime(startTime);
  builder_.add_idElset(idElset);
  builder_.add_origObjectId(origObjectId);
  builder_.add_satNo(satNo);
  builder_.add_idOnOrbit(idOnOrbit);
  builder_.add_sensorAsId(sensorAsId);
  builder_.add_origSensorId(origSensorId);
  builder_.add_idSensor(idSensor);
  builder_.add_msgCreateDate(msgCreateDate);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_solarPhaseAngleBrightnessChangeDetected(solarPhaseAngleBrightnessChangeDetected);
  builder_.add_brightnessVarianceChangeDetected(brightnessVarianceChangeDetected);
  builder_.add_periodicityChangeDetected(periodicityChangeDetected);
  builder_.add_changeDetected(changeDetected);
  builder_.add_uct(uct);
  builder_.add_senReferenceFrame(senReferenceFrame);
  builder_.add_referenceFrame(referenceFrame);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SOIObservationSet_Full> CreateSOIObservationSet_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *msgCreateDate = nullptr,
    const char *idSensor = nullptr,
    const char *origSensorId = nullptr,
    const char *sensorAsId = nullptr,
    const char *idOnOrbit = nullptr,
    int32_t satNo = 0,
    const char *origObjectId = nullptr,
    double senlat = 0.0,
    double senlon = 0.0,
    double senalt = 0.0,
    double senx = 0.0,
    double seny = 0.0,
    double senz = 0.0,
    double senvelx = 0.0,
    double senvely = 0.0,
    double senvelz = 0.0,
    const char *idElset = nullptr,
    const char *startTime = nullptr,
    const char *endTime = nullptr,
    int32_t numObs = 0,
    SOIObservationSet_Full_type_Enum type = SOIObservationSet_Full_type_Enum_OPTICAL,
    double polarAngleStart = 0.0,
    double polarAngleEnd = 0.0,
    SOIObservationSet_Full_referenceFrame_Enum referenceFrame = SOIObservationSet_Full_referenceFrame_Enum_J2000,
    SOIObservationSet_Full_senReferenceFrame_Enum senReferenceFrame = SOIObservationSet_Full_senReferenceFrame_Enum_J2000,
    double losDeclinationStart = 0.0,
    double losDeclinationEnd = 0.0,
    double pointingAngleAzStart = 0.0,
    double pointingAngleAzEnd = 0.0,
    double pointingAngleElStart = 0.0,
    double pointingAngleElEnd = 0.0,
    int32_t pixelArrayWidth = 0,
    int32_t pixelArrayHeight = 0,
    int32_t numSpectralFilters = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *spectralFilters = nullptr,
    const char *collectionMode = nullptr,
    double gain = 0.0,
    int32_t binningHoriz = 0,
    int32_t binningVert = 0,
    double solarMag = 0.0,
    int32_t pixelMin = 0,
    int32_t pixelMax = 0,
    const char *softwareVersion = nullptr,
    const char *satelliteName = nullptr,
    const char *starCatName = nullptr,
    double corrQuality = 0.0,
    bool uct = false,
    const char *validCalibrations = nullptr,
    const char *calibrationType = nullptr,
    double percentSatThreshold = 0.0,
    bool changeDetected = false,
    bool periodicityChangeDetected = false,
    bool brightnessVarianceChangeDetected = false,
    bool solarPhaseAngleBrightnessChangeDetected = false,
    const char *changeConf = nullptr,
    const char *collectionDensityConf = nullptr,
    const char *periodicitySamplingConf = nullptr,
    const char *periodicityDetectionConf = nullptr,
    const char *collectionId = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *calibrations = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tags = nullptr,
    const char *transactionId = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *opticalSOIObservationList = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *radarSOIObservationList = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr,
    const char *sourceDL = nullptr,
    SOIObservationSet_Full_dataMode_Enum dataMode = SOIObservationSet_Full_dataMode_Enum_REAL) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto msgCreateDate__ = msgCreateDate ? _fbb.CreateString(msgCreateDate) : 0;
  auto idSensor__ = idSensor ? _fbb.CreateString(idSensor) : 0;
  auto origSensorId__ = origSensorId ? _fbb.CreateString(origSensorId) : 0;
  auto sensorAsId__ = sensorAsId ? _fbb.CreateString(sensorAsId) : 0;
  auto idOnOrbit__ = idOnOrbit ? _fbb.CreateString(idOnOrbit) : 0;
  auto origObjectId__ = origObjectId ? _fbb.CreateString(origObjectId) : 0;
  auto idElset__ = idElset ? _fbb.CreateString(idElset) : 0;
  auto startTime__ = startTime ? _fbb.CreateString(startTime) : 0;
  auto endTime__ = endTime ? _fbb.CreateString(endTime) : 0;
  auto spectralFilters__ = spectralFilters ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*spectralFilters) : 0;
  auto collectionMode__ = collectionMode ? _fbb.CreateString(collectionMode) : 0;
  auto softwareVersion__ = softwareVersion ? _fbb.CreateString(softwareVersion) : 0;
  auto satelliteName__ = satelliteName ? _fbb.CreateString(satelliteName) : 0;
  auto starCatName__ = starCatName ? _fbb.CreateString(starCatName) : 0;
  auto validCalibrations__ = validCalibrations ? _fbb.CreateString(validCalibrations) : 0;
  auto calibrationType__ = calibrationType ? _fbb.CreateString(calibrationType) : 0;
  auto changeConf__ = changeConf ? _fbb.CreateString(changeConf) : 0;
  auto collectionDensityConf__ = collectionDensityConf ? _fbb.CreateString(collectionDensityConf) : 0;
  auto periodicitySamplingConf__ = periodicitySamplingConf ? _fbb.CreateString(periodicitySamplingConf) : 0;
  auto periodicityDetectionConf__ = periodicityDetectionConf ? _fbb.CreateString(periodicityDetectionConf) : 0;
  auto collectionId__ = collectionId ? _fbb.CreateString(collectionId) : 0;
  auto calibrations__ = calibrations ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*calibrations) : 0;
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tags) : 0;
  auto transactionId__ = transactionId ? _fbb.CreateString(transactionId) : 0;
  auto opticalSOIObservationList__ = opticalSOIObservationList ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*opticalSOIObservationList) : 0;
  auto radarSOIObservationList__ = radarSOIObservationList ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*radarSOIObservationList) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto sourceDL__ = sourceDL ? _fbb.CreateString(sourceDL) : 0;
  return CreateSOIObservationSet_Full(
      _fbb,
      id__,
      classificationMarking__,
      msgCreateDate__,
      idSensor__,
      origSensorId__,
      sensorAsId__,
      idOnOrbit__,
      satNo,
      origObjectId__,
      senlat,
      senlon,
      senalt,
      senx,
      seny,
      senz,
      senvelx,
      senvely,
      senvelz,
      idElset__,
      startTime__,
      endTime__,
      numObs,
      type,
      polarAngleStart,
      polarAngleEnd,
      referenceFrame,
      senReferenceFrame,
      losDeclinationStart,
      losDeclinationEnd,
      pointingAngleAzStart,
      pointingAngleAzEnd,
      pointingAngleElStart,
      pointingAngleElEnd,
      pixelArrayWidth,
      pixelArrayHeight,
      numSpectralFilters,
      spectralFilters__,
      collectionMode__,
      gain,
      binningHoriz,
      binningVert,
      solarMag,
      pixelMin,
      pixelMax,
      softwareVersion__,
      satelliteName__,
      starCatName__,
      corrQuality,
      uct,
      validCalibrations__,
      calibrationType__,
      percentSatThreshold,
      changeDetected,
      periodicityChangeDetected,
      brightnessVarianceChangeDetected,
      solarPhaseAngleBrightnessChangeDetected,
      changeConf__,
      collectionDensityConf__,
      periodicitySamplingConf__,
      periodicityDetectionConf__,
      collectionId__,
      calibrations__,
      tags__,
      transactionId__,
      opticalSOIObservationList__,
      radarSOIObservationList__,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      origNetwork__,
      sourceDL__,
      dataMode);
}

inline const SOIObservationSet_Full *GetSOIObservationSet_Full(const void *buf) {
  return ::flatbuffers::GetRoot<SOIObservationSet_Full>(buf);
}

inline const SOIObservationSet_Full *GetSizePrefixedSOIObservationSet_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SOIObservationSet_Full>(buf);
}

inline const char *SOIObservationSet_FullIdentifier() {
  return "SOIO";
}

inline bool SOIObservationSet_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SOIObservationSet_FullIdentifier());
}

inline bool SizePrefixedSOIObservationSet_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SOIObservationSet_FullIdentifier(), true);
}

inline bool VerifySOIObservationSet_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SOIObservationSet_Full>(SOIObservationSet_FullIdentifier());
}

inline bool VerifySizePrefixedSOIObservationSet_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SOIObservationSet_Full>(SOIObservationSet_FullIdentifier());
}

inline void FinishSOIObservationSet_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SOIObservationSet_Full> root) {
  fbb.Finish(root, SOIObservationSet_FullIdentifier());
}

inline void FinishSizePrefixedSOIObservationSet_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SOIObservationSet_Full> root) {
  fbb.FinishSizePrefixed(root, SOIObservationSet_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
