// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct MtiTargetReport_Full;
struct MtiTargetReport_FullBuilder;

/// /// A grouping of zero or more target reports for which the sensor provides a single time, sensor position, reference position on the ground with simple estimates for the observed area at the reported time, and other pertinent data.
struct MtiTargetReport_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MtiTargetReport_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_D32_1 = 4,
    VT_D32_2 = 6,
    VT_D32_3 = 8,
    VT_D32_4 = 10,
    VT_D32_5 = 12,
    VT_D32_6 = 14,
    VT_D32_7 = 16,
    VT_D32_8 = 18,
    VT_D32_9 = 20,
    VT_D32_10 = 22,
    VT_D32_11 = 24,
    VT_D32_12 = 26,
    VT_D32_13 = 28,
    VT_D32_14 = 30,
    VT_D32_15 = 32,
    VT_D32_16 = 34,
    VT_D32_17 = 36,
    VT_D32_18 = 38
  };
  /// Sequential count of this MTI report within the dwell.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t d32_1() const {
    return GetField<int32_t>(VT_D32_1, 0);
  }
  /// The North-South position of the reported detection, expressed as degrees North (positive) or South (negative) of the Equator.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double d32_2() const {
    return GetField<double>(VT_D32_2, 0.0);
  }
  /// The East-West position of the reported detection, expressed as degrees East (positive) from the Prime Meridian.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double d32_3() const {
    return GetField<double>(VT_D32_3, 0.0);
  }
  /// The North-South position of the reported detection, expressed as degrees North (positive) or South (negative) from the Dwell Area Center Latitude.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t d32_4() const {
    return GetField<int32_t>(VT_D32_4, 0);
  }
  /// The East-West position of the reported detection, expressed as degrees East (positive, 0 to 180) or West (negative, 0 to -180) of the Prime Meridian from the Dwell Area Center Longitude.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t d32_5() const {
    return GetField<int32_t>(VT_D32_5, 0);
  }
  /// Height of the reported detection, referenced to its position above the WGS 84 ellipsoid, in meters.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t d32_6() const {
    return GetField<int32_t>(VT_D32_6, 0);
  }
  /// The component of velocity for the reported detection, expressed in centimeters per second, corrected for platform motion, along the line of sight between the sensor and the reported detection, where the positive direction is away from the sensor.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t d32_7() const {
    return GetField<int32_t>(VT_D32_7, 0);
  }
  /// The target wrap velocity permits trackers to un-wrap velocities for targets with line-of-sight components large enough to exceed the first velocity period.  Expressed in centimeters/sec.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t d32_8() const {
    return GetField<int32_t>(VT_D32_8, 0);
  }
  /// Estimated signal-to-noise ratio (SNR) of the target return, in decibels.
  /// Example: /// Example: 17
  /// Constraints: No constraints specified.
  int32_t d32_9() const {
    return GetField<int32_t>(VT_D32_9, 0);
  }
  /// The classification of the target (i.e. vehicle, aircraft, â€¦).
  /// Example: /// Example: vehicle
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *d32_10() const {
    return GetPointer<const ::flatbuffers::String *>(VT_D32_10);
  }
  /// Estimated probability that the target classification field is correctly classified.
  /// Example: /// Example: 90
  /// Constraints: No constraints specified.
  int32_t d32_11() const {
    return GetField<int32_t>(VT_D32_11, 0);
  }
  /// Standard deviation of the estimated slant range of the reported detection, in centimeters.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t d32_12() const {
    return GetField<int32_t>(VT_D32_12, 0);
  }
  /// Standard deviation of the position estimate, in the cross-range direction, of the reported detection, in decimeters.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t d32_13() const {
    return GetField<int32_t>(VT_D32_13, 0);
  }
  /// Standard deviation of the estimated geodetic height, in meters.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t d32_14() const {
    return GetField<int32_t>(VT_D32_14, 0);
  }
  /// Standard deviation of the measured line-of-sight velocity component, in centimeters per second.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t d32_15() const {
    return GetField<int32_t>(VT_D32_15, 0);
  }
  /// The Truth Tag- Application is the Application Field truncated to 8 bits, from the Entity State Protocol Data Unit (PDU) used to generate the MTI Target.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t d32_16() const {
    return GetField<int32_t>(VT_D32_16, 0);
  }
  /// The Truth Tag - Entity is the Entity Field from the Entity State PDU used to generate the MTI Target.
  /// Example: /// Example: 1234567890
  /// Constraints: No constraints specified.
  int64_t d32_17() const {
    return GetField<int64_t>(VT_D32_17, 0);
  }
  /// Estimated radar cross section of the target return, in half-decibels.
  /// Example: /// Example: 98
  /// Constraints: No constraints specified.
  int32_t d32_18() const {
    return GetField<int32_t>(VT_D32_18, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_D32_1, 4) &&
           VerifyField<double>(verifier, VT_D32_2, 8) &&
           VerifyField<double>(verifier, VT_D32_3, 8) &&
           VerifyField<int32_t>(verifier, VT_D32_4, 4) &&
           VerifyField<int32_t>(verifier, VT_D32_5, 4) &&
           VerifyField<int32_t>(verifier, VT_D32_6, 4) &&
           VerifyField<int32_t>(verifier, VT_D32_7, 4) &&
           VerifyField<int32_t>(verifier, VT_D32_8, 4) &&
           VerifyField<int32_t>(verifier, VT_D32_9, 4) &&
           VerifyOffset(verifier, VT_D32_10) &&
           verifier.VerifyString(d32_10()) &&
           VerifyField<int32_t>(verifier, VT_D32_11, 4) &&
           VerifyField<int32_t>(verifier, VT_D32_12, 4) &&
           VerifyField<int32_t>(verifier, VT_D32_13, 4) &&
           VerifyField<int32_t>(verifier, VT_D32_14, 4) &&
           VerifyField<int32_t>(verifier, VT_D32_15, 4) &&
           VerifyField<int32_t>(verifier, VT_D32_16, 4) &&
           VerifyField<int64_t>(verifier, VT_D32_17, 8) &&
           VerifyField<int32_t>(verifier, VT_D32_18, 4) &&
           verifier.EndTable();
  }
};

struct MtiTargetReport_FullBuilder {
  typedef MtiTargetReport_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_d32_1(int32_t d32_1) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_1, d32_1, 0);
  }
  void add_d32_2(double d32_2) {
    fbb_.AddElement<double>(MtiTargetReport_Full::VT_D32_2, d32_2, 0.0);
  }
  void add_d32_3(double d32_3) {
    fbb_.AddElement<double>(MtiTargetReport_Full::VT_D32_3, d32_3, 0.0);
  }
  void add_d32_4(int32_t d32_4) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_4, d32_4, 0);
  }
  void add_d32_5(int32_t d32_5) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_5, d32_5, 0);
  }
  void add_d32_6(int32_t d32_6) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_6, d32_6, 0);
  }
  void add_d32_7(int32_t d32_7) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_7, d32_7, 0);
  }
  void add_d32_8(int32_t d32_8) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_8, d32_8, 0);
  }
  void add_d32_9(int32_t d32_9) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_9, d32_9, 0);
  }
  void add_d32_10(::flatbuffers::Offset<::flatbuffers::String> d32_10) {
    fbb_.AddOffset(MtiTargetReport_Full::VT_D32_10, d32_10);
  }
  void add_d32_11(int32_t d32_11) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_11, d32_11, 0);
  }
  void add_d32_12(int32_t d32_12) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_12, d32_12, 0);
  }
  void add_d32_13(int32_t d32_13) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_13, d32_13, 0);
  }
  void add_d32_14(int32_t d32_14) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_14, d32_14, 0);
  }
  void add_d32_15(int32_t d32_15) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_15, d32_15, 0);
  }
  void add_d32_16(int32_t d32_16) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_16, d32_16, 0);
  }
  void add_d32_17(int64_t d32_17) {
    fbb_.AddElement<int64_t>(MtiTargetReport_Full::VT_D32_17, d32_17, 0);
  }
  void add_d32_18(int32_t d32_18) {
    fbb_.AddElement<int32_t>(MtiTargetReport_Full::VT_D32_18, d32_18, 0);
  }
  explicit MtiTargetReport_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MtiTargetReport_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MtiTargetReport_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MtiTargetReport_Full> CreateMtiTargetReport_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t d32_1 = 0,
    double d32_2 = 0.0,
    double d32_3 = 0.0,
    int32_t d32_4 = 0,
    int32_t d32_5 = 0,
    int32_t d32_6 = 0,
    int32_t d32_7 = 0,
    int32_t d32_8 = 0,
    int32_t d32_9 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> d32_10 = 0,
    int32_t d32_11 = 0,
    int32_t d32_12 = 0,
    int32_t d32_13 = 0,
    int32_t d32_14 = 0,
    int32_t d32_15 = 0,
    int32_t d32_16 = 0,
    int64_t d32_17 = 0,
    int32_t d32_18 = 0) {
  MtiTargetReport_FullBuilder builder_(_fbb);
  builder_.add_d32_17(d32_17);
  builder_.add_d32_3(d32_3);
  builder_.add_d32_2(d32_2);
  builder_.add_d32_18(d32_18);
  builder_.add_d32_16(d32_16);
  builder_.add_d32_15(d32_15);
  builder_.add_d32_14(d32_14);
  builder_.add_d32_13(d32_13);
  builder_.add_d32_12(d32_12);
  builder_.add_d32_11(d32_11);
  builder_.add_d32_10(d32_10);
  builder_.add_d32_9(d32_9);
  builder_.add_d32_8(d32_8);
  builder_.add_d32_7(d32_7);
  builder_.add_d32_6(d32_6);
  builder_.add_d32_5(d32_5);
  builder_.add_d32_4(d32_4);
  builder_.add_d32_1(d32_1);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MtiTargetReport_Full> CreateMtiTargetReport_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t d32_1 = 0,
    double d32_2 = 0.0,
    double d32_3 = 0.0,
    int32_t d32_4 = 0,
    int32_t d32_5 = 0,
    int32_t d32_6 = 0,
    int32_t d32_7 = 0,
    int32_t d32_8 = 0,
    int32_t d32_9 = 0,
    const char *d32_10 = nullptr,
    int32_t d32_11 = 0,
    int32_t d32_12 = 0,
    int32_t d32_13 = 0,
    int32_t d32_14 = 0,
    int32_t d32_15 = 0,
    int32_t d32_16 = 0,
    int64_t d32_17 = 0,
    int32_t d32_18 = 0) {
  auto d32_10__ = d32_10 ? _fbb.CreateString(d32_10) : 0;
  return CreateMtiTargetReport_Full(
      _fbb,
      d32_1,
      d32_2,
      d32_3,
      d32_4,
      d32_5,
      d32_6,
      d32_7,
      d32_8,
      d32_9,
      d32_10__,
      d32_11,
      d32_12,
      d32_13,
      d32_14,
      d32_15,
      d32_16,
      d32_17,
      d32_18);
}

inline const MtiTargetReport_Full *GetMtiTargetReport_Full(const void *buf) {
  return ::flatbuffers::GetRoot<MtiTargetReport_Full>(buf);
}

inline const MtiTargetReport_Full *GetSizePrefixedMtiTargetReport_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MtiTargetReport_Full>(buf);
}

inline const char *MtiTargetReport_FullIdentifier() {
  return "MTIT";
}

inline bool MtiTargetReport_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MtiTargetReport_FullIdentifier());
}

inline bool SizePrefixedMtiTargetReport_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MtiTargetReport_FullIdentifier(), true);
}

inline bool VerifyMtiTargetReport_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MtiTargetReport_Full>(MtiTargetReport_FullIdentifier());
}

inline bool VerifySizePrefixedMtiTargetReport_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MtiTargetReport_Full>(MtiTargetReport_FullIdentifier());
}

inline void FinishMtiTargetReport_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MtiTargetReport_Full> root) {
  fbb.Finish(root, MtiTargetReport_FullIdentifier());
}

inline void FinishSizePrefixedMtiTargetReport_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MtiTargetReport_Full> root) {
  fbb.FinishSizePrefixed(root, MtiTargetReport_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
