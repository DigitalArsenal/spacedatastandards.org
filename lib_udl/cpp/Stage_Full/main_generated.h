// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Stage_Full;
struct Stage_FullBuilder;

enum Stage_Full_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  Stage_Full_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  Stage_Full_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  Stage_Full_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  Stage_Full_dataMode_Enum_EXERCISE = 3,
  Stage_Full_dataMode_Enum_MIN = Stage_Full_dataMode_Enum_REAL,
  Stage_Full_dataMode_Enum_MAX = Stage_Full_dataMode_Enum_EXERCISE
};

inline const Stage_Full_dataMode_Enum (&EnumValuesStage_Full_dataMode_Enum())[4] {
  static const Stage_Full_dataMode_Enum values[] = {
    Stage_Full_dataMode_Enum_REAL,
    Stage_Full_dataMode_Enum_TEST,
    Stage_Full_dataMode_Enum_SIMULATED,
    Stage_Full_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesStage_Full_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameStage_Full_dataMode_Enum(Stage_Full_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, Stage_Full_dataMode_Enum_REAL, Stage_Full_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStage_Full_dataMode_Enum()[index];
}

/// /// Launch stage information for a particular launch vehicle. A launch vehicle can have several stages, each with 1 to many engines.
struct Stage_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Stage_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_IDLAUNCHVEHICLE = 6,
    VT_IDENGINE = 8,
    VT_CLASSIFICATIONMARKING = 10,
    VT_STAGENUMBER = 12,
    VT_TYPE = 14,
    VT_MANUFACTURERORGID = 16,
    VT_NUMENGINES = 18,
    VT_LENGTH = 20,
    VT_DIAMETER = 22,
    VT_MASS = 24,
    VT_VERNIER = 26,
    VT_NUMVERNIER = 28,
    VT_MAINENGINETHRUSTSEALEVEL = 30,
    VT_MAINENGINETHRUSTVACUUM = 32,
    VT_THRUSTSEALEVEL = 34,
    VT_THRUSTVACUUM = 36,
    VT_BURNTIME = 38,
    VT_NUMBURNS = 40,
    VT_VERNIERBURNTIME = 42,
    VT_VERNIERNUMBURNS = 44,
    VT_VERNIERTHRUSTSEALEVEL = 46,
    VT_VERNIERTHRUSTVACUUM = 48,
    VT_NUMSTAGEELEMENTS = 50,
    VT_REUSABLE = 52,
    VT_RESTARTABLE = 54,
    VT_CONTROLTHRUSTER1 = 56,
    VT_NUMCONTROLTHRUSTER1 = 58,
    VT_CONTROLTHRUSTER2 = 60,
    VT_NUMCONTROLTHRUSTER2 = 62,
    VT_PHOTOURLS = 64,
    VT_NOTES = 66,
    VT_AVIONICSNOTES = 68,
    VT_TAGS = 70,
    VT_CREATEDAT = 72,
    VT_CREATEDBY = 74,
    VT_UPDATEDAT = 76,
    VT_UPDATEDBY = 78,
    VT_SOURCE = 80,
    VT_ORIGIN = 82,
    VT_ORIGNETWORK = 84,
    VT_DATAMODE = 86,
    VT_ENGINE = 88
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: STAGE-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Identifier of the launch vehicle record for this stage.
  /// Example: /// Example: LAUNCHVEHICLE-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idLaunchVehicle() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDLAUNCHVEHICLE);
  }
  /// Identifier of the Engine record for this stage.
  /// Example: /// Example: ENGINE-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idEngine() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENGINE);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The stage number of this launch stage.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t stageNumber() const {
    return GetField<int32_t>(VT_STAGENUMBER, 0);
  }
  /// Engine cycle type (e.g. Electrostatic Ion, Pressure Fed, Hall, Catalytic Decomposition, etc.).
  /// Example: /// Example: Electrostatic Ion
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// ID of the organization that manufactures this launch stage.
  /// Example: /// Example: 5feed5d7-d131-57e5-a3fd-acc173bca736
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *manufacturerOrgId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MANUFACTURERORGID);
  }
  /// The number of the specified engines on this launch stage.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t numEngines() const {
    return GetField<int32_t>(VT_NUMENGINES, 0);
  }
  /// Stage length in meters.
  /// Example: /// Example: 25.13
  /// Constraints: No constraints specified.
  double length() const {
    return GetField<double>(VT_LENGTH, 0.0);
  }
  /// Stage maximum external diameter in meters.
  /// Example: /// Example: 3.95
  /// Constraints: No constraints specified.
  double diameter() const {
    return GetField<double>(VT_DIAMETER, 0.0);
  }
  /// Stage gross mass in kg.
  /// Example: /// Example: 9956.1
  /// Constraints: No constraints specified.
  double mass() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  /// Engine vernier or additional engine type.
  /// Example: /// Example: vernier
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *vernier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERNIER);
  }
  /// Number of vernier or additional engines.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  int32_t numVernier() const {
    return GetField<int32_t>(VT_NUMVERNIER, 0);
  }
  /// Thrust of the stage main engine at sea level in kN.
  /// Example: /// Example: 733.4
  /// Constraints: No constraints specified.
  double mainEngineThrustSeaLevel() const {
    return GetField<double>(VT_MAINENGINETHRUSTSEALEVEL, 0.0);
  }
  /// Thrust of the stage main engine in a vacuum in kN.
  /// Example: /// Example: 733.4
  /// Constraints: No constraints specified.
  double mainEngineThrustVacuum() const {
    return GetField<double>(VT_MAINENGINETHRUSTVACUUM, 0.0);
  }
  /// Total thrust of the stage at sea level in kN.
  /// Example: /// Example: 733.4
  /// Constraints: No constraints specified.
  double thrustSeaLevel() const {
    return GetField<double>(VT_THRUSTSEALEVEL, 0.0);
  }
  /// Total thrust of the stage in a vacuum in kN.
  /// Example: /// Example: 733.4
  /// Constraints: No constraints specified.
  double thrustVacuum() const {
    return GetField<double>(VT_THRUSTVACUUM, 0.0);
  }
  /// Total burn time of the stage engines in seconds.
  /// Example: /// Example: 256.3
  /// Constraints: No constraints specified.
  double burnTime() const {
    return GetField<double>(VT_BURNTIME, 0.0);
  }
  /// Number of burns for the stage engines.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t numBurns() const {
    return GetField<int32_t>(VT_NUMBURNS, 0);
  }
  /// Total burn time of the vernier or additional stage engines in seconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double vernierBurnTime() const {
    return GetField<double>(VT_VERNIERBURNTIME, 0.0);
  }
  /// Total number of burns of the vernier or additional stage engines.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  int32_t vernierNumBurns() const {
    return GetField<int32_t>(VT_VERNIERNUMBURNS, 0);
  }
  /// Total thrust of one of the vernier or additional engines at sea level in kN.
  /// Example: /// Example: 4.1
  /// Constraints: No constraints specified.
  double vernierThrustSeaLevel() const {
    return GetField<double>(VT_VERNIERTHRUSTSEALEVEL, 0.0);
  }
  /// Total thrust of one of the vernier or additional engines in a vacuum in kN.
  /// Example: /// Example: 3.2
  /// Constraints: No constraints specified.
  double vernierThrustVacuum() const {
    return GetField<double>(VT_VERNIERTHRUSTVACUUM, 0.0);
  }
  /// Number of launch stage elements used in this stage.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t numStageElements() const {
    return GetField<int32_t>(VT_NUMSTAGEELEMENTS, 0);
  }
  /// Boolean indicating if this launch stage is reusable.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool reusable() const {
    return GetField<uint8_t>(VT_REUSABLE, 0) != 0;
  }
  /// Boolean indicating if this launch stage can be restarted.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool restartable() const {
    return GetField<uint8_t>(VT_RESTARTABLE, 0) != 0;
  }
  /// Control thruster 1 type.
  /// Example: /// Example: controlThruster1
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *controlThruster1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTROLTHRUSTER1);
  }
  /// Number of type control thruster 1.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t numControlThruster1() const {
    return GetField<int32_t>(VT_NUMCONTROLTHRUSTER1, 0);
  }
  /// Control thruster 2 type.
  /// Example: /// Example: controlThruster2
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *controlThruster2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTROLTHRUSTER2);
  }
  /// Number of type control thruster 2.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t numControlThruster2() const {
    return GetField<int32_t>(VT_NUMCONTROLTHRUSTER2, 0);
  }
  /// Array of URLs of photos of the stage.
  /// Example: /// Example: ['photoURL']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *photoURLs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PHOTOURLS);
  }
  /// Description/notes of the stage.
  /// Example: /// Example: Sample Notes
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *notes() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  /// Description/notes of the stage avionics.
  /// Example: /// Example: Sample Notes
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *avionicsNotes() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AVIONICSNOTES);
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['TAG1', 'TAG2']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TAGS);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *updatedAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDAT);
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *updatedBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  Stage_Full_dataMode_Enum dataMode() const {
    return static_cast<Stage_Full_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *engine() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENGINE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_IDLAUNCHVEHICLE) &&
           verifier.VerifyString(idLaunchVehicle()) &&
           VerifyOffset(verifier, VT_IDENGINE) &&
           verifier.VerifyString(idEngine()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyField<int32_t>(verifier, VT_STAGENUMBER, 4) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_MANUFACTURERORGID) &&
           verifier.VerifyString(manufacturerOrgId()) &&
           VerifyField<int32_t>(verifier, VT_NUMENGINES, 4) &&
           VerifyField<double>(verifier, VT_LENGTH, 8) &&
           VerifyField<double>(verifier, VT_DIAMETER, 8) &&
           VerifyField<double>(verifier, VT_MASS, 8) &&
           VerifyOffset(verifier, VT_VERNIER) &&
           verifier.VerifyString(vernier()) &&
           VerifyField<int32_t>(verifier, VT_NUMVERNIER, 4) &&
           VerifyField<double>(verifier, VT_MAINENGINETHRUSTSEALEVEL, 8) &&
           VerifyField<double>(verifier, VT_MAINENGINETHRUSTVACUUM, 8) &&
           VerifyField<double>(verifier, VT_THRUSTSEALEVEL, 8) &&
           VerifyField<double>(verifier, VT_THRUSTVACUUM, 8) &&
           VerifyField<double>(verifier, VT_BURNTIME, 8) &&
           VerifyField<int32_t>(verifier, VT_NUMBURNS, 4) &&
           VerifyField<double>(verifier, VT_VERNIERBURNTIME, 8) &&
           VerifyField<int32_t>(verifier, VT_VERNIERNUMBURNS, 4) &&
           VerifyField<double>(verifier, VT_VERNIERTHRUSTSEALEVEL, 8) &&
           VerifyField<double>(verifier, VT_VERNIERTHRUSTVACUUM, 8) &&
           VerifyField<int32_t>(verifier, VT_NUMSTAGEELEMENTS, 4) &&
           VerifyField<uint8_t>(verifier, VT_REUSABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_RESTARTABLE, 1) &&
           VerifyOffset(verifier, VT_CONTROLTHRUSTER1) &&
           verifier.VerifyString(controlThruster1()) &&
           VerifyField<int32_t>(verifier, VT_NUMCONTROLTHRUSTER1, 4) &&
           VerifyOffset(verifier, VT_CONTROLTHRUSTER2) &&
           verifier.VerifyString(controlThruster2()) &&
           VerifyField<int32_t>(verifier, VT_NUMCONTROLTHRUSTER2, 4) &&
           VerifyOffset(verifier, VT_PHOTOURLS) &&
           verifier.VerifyVector(photoURLs()) &&
           verifier.VerifyVectorOfStrings(photoURLs()) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(notes()) &&
           VerifyOffset(verifier, VT_AVIONICSNOTES) &&
           verifier.VerifyString(avionicsNotes()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_UPDATEDAT) &&
           verifier.VerifyString(updatedAt()) &&
           VerifyOffset(verifier, VT_UPDATEDBY) &&
           verifier.VerifyString(updatedBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_ENGINE) &&
           verifier.VerifyString(engine()) &&
           verifier.EndTable();
  }
};

struct Stage_FullBuilder {
  typedef Stage_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Stage_Full::VT_ID, id);
  }
  void add_idLaunchVehicle(::flatbuffers::Offset<::flatbuffers::String> idLaunchVehicle) {
    fbb_.AddOffset(Stage_Full::VT_IDLAUNCHVEHICLE, idLaunchVehicle);
  }
  void add_idEngine(::flatbuffers::Offset<::flatbuffers::String> idEngine) {
    fbb_.AddOffset(Stage_Full::VT_IDENGINE, idEngine);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(Stage_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_stageNumber(int32_t stageNumber) {
    fbb_.AddElement<int32_t>(Stage_Full::VT_STAGENUMBER, stageNumber, 0);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(Stage_Full::VT_TYPE, type);
  }
  void add_manufacturerOrgId(::flatbuffers::Offset<::flatbuffers::String> manufacturerOrgId) {
    fbb_.AddOffset(Stage_Full::VT_MANUFACTURERORGID, manufacturerOrgId);
  }
  void add_numEngines(int32_t numEngines) {
    fbb_.AddElement<int32_t>(Stage_Full::VT_NUMENGINES, numEngines, 0);
  }
  void add_length(double length) {
    fbb_.AddElement<double>(Stage_Full::VT_LENGTH, length, 0.0);
  }
  void add_diameter(double diameter) {
    fbb_.AddElement<double>(Stage_Full::VT_DIAMETER, diameter, 0.0);
  }
  void add_mass(double mass) {
    fbb_.AddElement<double>(Stage_Full::VT_MASS, mass, 0.0);
  }
  void add_vernier(::flatbuffers::Offset<::flatbuffers::String> vernier) {
    fbb_.AddOffset(Stage_Full::VT_VERNIER, vernier);
  }
  void add_numVernier(int32_t numVernier) {
    fbb_.AddElement<int32_t>(Stage_Full::VT_NUMVERNIER, numVernier, 0);
  }
  void add_mainEngineThrustSeaLevel(double mainEngineThrustSeaLevel) {
    fbb_.AddElement<double>(Stage_Full::VT_MAINENGINETHRUSTSEALEVEL, mainEngineThrustSeaLevel, 0.0);
  }
  void add_mainEngineThrustVacuum(double mainEngineThrustVacuum) {
    fbb_.AddElement<double>(Stage_Full::VT_MAINENGINETHRUSTVACUUM, mainEngineThrustVacuum, 0.0);
  }
  void add_thrustSeaLevel(double thrustSeaLevel) {
    fbb_.AddElement<double>(Stage_Full::VT_THRUSTSEALEVEL, thrustSeaLevel, 0.0);
  }
  void add_thrustVacuum(double thrustVacuum) {
    fbb_.AddElement<double>(Stage_Full::VT_THRUSTVACUUM, thrustVacuum, 0.0);
  }
  void add_burnTime(double burnTime) {
    fbb_.AddElement<double>(Stage_Full::VT_BURNTIME, burnTime, 0.0);
  }
  void add_numBurns(int32_t numBurns) {
    fbb_.AddElement<int32_t>(Stage_Full::VT_NUMBURNS, numBurns, 0);
  }
  void add_vernierBurnTime(double vernierBurnTime) {
    fbb_.AddElement<double>(Stage_Full::VT_VERNIERBURNTIME, vernierBurnTime, 0.0);
  }
  void add_vernierNumBurns(int32_t vernierNumBurns) {
    fbb_.AddElement<int32_t>(Stage_Full::VT_VERNIERNUMBURNS, vernierNumBurns, 0);
  }
  void add_vernierThrustSeaLevel(double vernierThrustSeaLevel) {
    fbb_.AddElement<double>(Stage_Full::VT_VERNIERTHRUSTSEALEVEL, vernierThrustSeaLevel, 0.0);
  }
  void add_vernierThrustVacuum(double vernierThrustVacuum) {
    fbb_.AddElement<double>(Stage_Full::VT_VERNIERTHRUSTVACUUM, vernierThrustVacuum, 0.0);
  }
  void add_numStageElements(int32_t numStageElements) {
    fbb_.AddElement<int32_t>(Stage_Full::VT_NUMSTAGEELEMENTS, numStageElements, 0);
  }
  void add_reusable(bool reusable) {
    fbb_.AddElement<uint8_t>(Stage_Full::VT_REUSABLE, static_cast<uint8_t>(reusable), 0);
  }
  void add_restartable(bool restartable) {
    fbb_.AddElement<uint8_t>(Stage_Full::VT_RESTARTABLE, static_cast<uint8_t>(restartable), 0);
  }
  void add_controlThruster1(::flatbuffers::Offset<::flatbuffers::String> controlThruster1) {
    fbb_.AddOffset(Stage_Full::VT_CONTROLTHRUSTER1, controlThruster1);
  }
  void add_numControlThruster1(int32_t numControlThruster1) {
    fbb_.AddElement<int32_t>(Stage_Full::VT_NUMCONTROLTHRUSTER1, numControlThruster1, 0);
  }
  void add_controlThruster2(::flatbuffers::Offset<::flatbuffers::String> controlThruster2) {
    fbb_.AddOffset(Stage_Full::VT_CONTROLTHRUSTER2, controlThruster2);
  }
  void add_numControlThruster2(int32_t numControlThruster2) {
    fbb_.AddElement<int32_t>(Stage_Full::VT_NUMCONTROLTHRUSTER2, numControlThruster2, 0);
  }
  void add_photoURLs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> photoURLs) {
    fbb_.AddOffset(Stage_Full::VT_PHOTOURLS, photoURLs);
  }
  void add_notes(::flatbuffers::Offset<::flatbuffers::String> notes) {
    fbb_.AddOffset(Stage_Full::VT_NOTES, notes);
  }
  void add_avionicsNotes(::flatbuffers::Offset<::flatbuffers::String> avionicsNotes) {
    fbb_.AddOffset(Stage_Full::VT_AVIONICSNOTES, avionicsNotes);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags) {
    fbb_.AddOffset(Stage_Full::VT_TAGS, tags);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(Stage_Full::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(Stage_Full::VT_CREATEDBY, createdBy);
  }
  void add_updatedAt(::flatbuffers::Offset<::flatbuffers::String> updatedAt) {
    fbb_.AddOffset(Stage_Full::VT_UPDATEDAT, updatedAt);
  }
  void add_updatedBy(::flatbuffers::Offset<::flatbuffers::String> updatedBy) {
    fbb_.AddOffset(Stage_Full::VT_UPDATEDBY, updatedBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(Stage_Full::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(Stage_Full::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(Stage_Full::VT_ORIGNETWORK, origNetwork);
  }
  void add_dataMode(Stage_Full_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(Stage_Full::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_engine(::flatbuffers::Offset<::flatbuffers::String> engine) {
    fbb_.AddOffset(Stage_Full::VT_ENGINE, engine);
  }
  explicit Stage_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Stage_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Stage_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Stage_Full> CreateStage_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idLaunchVehicle = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idEngine = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    int32_t stageNumber = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> manufacturerOrgId = 0,
    int32_t numEngines = 0,
    double length = 0.0,
    double diameter = 0.0,
    double mass = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> vernier = 0,
    int32_t numVernier = 0,
    double mainEngineThrustSeaLevel = 0.0,
    double mainEngineThrustVacuum = 0.0,
    double thrustSeaLevel = 0.0,
    double thrustVacuum = 0.0,
    double burnTime = 0.0,
    int32_t numBurns = 0,
    double vernierBurnTime = 0.0,
    int32_t vernierNumBurns = 0,
    double vernierThrustSeaLevel = 0.0,
    double vernierThrustVacuum = 0.0,
    int32_t numStageElements = 0,
    bool reusable = false,
    bool restartable = false,
    ::flatbuffers::Offset<::flatbuffers::String> controlThruster1 = 0,
    int32_t numControlThruster1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> controlThruster2 = 0,
    int32_t numControlThruster2 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> photoURLs = 0,
    ::flatbuffers::Offset<::flatbuffers::String> notes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> avionicsNotes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    Stage_Full_dataMode_Enum dataMode = Stage_Full_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> engine = 0) {
  Stage_FullBuilder builder_(_fbb);
  builder_.add_vernierThrustVacuum(vernierThrustVacuum);
  builder_.add_vernierThrustSeaLevel(vernierThrustSeaLevel);
  builder_.add_vernierBurnTime(vernierBurnTime);
  builder_.add_burnTime(burnTime);
  builder_.add_thrustVacuum(thrustVacuum);
  builder_.add_thrustSeaLevel(thrustSeaLevel);
  builder_.add_mainEngineThrustVacuum(mainEngineThrustVacuum);
  builder_.add_mainEngineThrustSeaLevel(mainEngineThrustSeaLevel);
  builder_.add_mass(mass);
  builder_.add_diameter(diameter);
  builder_.add_length(length);
  builder_.add_engine(engine);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_updatedBy(updatedBy);
  builder_.add_updatedAt(updatedAt);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_tags(tags);
  builder_.add_avionicsNotes(avionicsNotes);
  builder_.add_notes(notes);
  builder_.add_photoURLs(photoURLs);
  builder_.add_numControlThruster2(numControlThruster2);
  builder_.add_controlThruster2(controlThruster2);
  builder_.add_numControlThruster1(numControlThruster1);
  builder_.add_controlThruster1(controlThruster1);
  builder_.add_numStageElements(numStageElements);
  builder_.add_vernierNumBurns(vernierNumBurns);
  builder_.add_numBurns(numBurns);
  builder_.add_numVernier(numVernier);
  builder_.add_vernier(vernier);
  builder_.add_numEngines(numEngines);
  builder_.add_manufacturerOrgId(manufacturerOrgId);
  builder_.add_type(type);
  builder_.add_stageNumber(stageNumber);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_idEngine(idEngine);
  builder_.add_idLaunchVehicle(idLaunchVehicle);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_restartable(restartable);
  builder_.add_reusable(reusable);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Stage_Full> CreateStage_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *idLaunchVehicle = nullptr,
    const char *idEngine = nullptr,
    const char *classificationMarking = nullptr,
    int32_t stageNumber = 0,
    const char *type = nullptr,
    const char *manufacturerOrgId = nullptr,
    int32_t numEngines = 0,
    double length = 0.0,
    double diameter = 0.0,
    double mass = 0.0,
    const char *vernier = nullptr,
    int32_t numVernier = 0,
    double mainEngineThrustSeaLevel = 0.0,
    double mainEngineThrustVacuum = 0.0,
    double thrustSeaLevel = 0.0,
    double thrustVacuum = 0.0,
    double burnTime = 0.0,
    int32_t numBurns = 0,
    double vernierBurnTime = 0.0,
    int32_t vernierNumBurns = 0,
    double vernierThrustSeaLevel = 0.0,
    double vernierThrustVacuum = 0.0,
    int32_t numStageElements = 0,
    bool reusable = false,
    bool restartable = false,
    const char *controlThruster1 = nullptr,
    int32_t numControlThruster1 = 0,
    const char *controlThruster2 = nullptr,
    int32_t numControlThruster2 = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *photoURLs = nullptr,
    const char *notes = nullptr,
    const char *avionicsNotes = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tags = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *updatedAt = nullptr,
    const char *updatedBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr,
    Stage_Full_dataMode_Enum dataMode = Stage_Full_dataMode_Enum_REAL,
    const char *engine = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto idLaunchVehicle__ = idLaunchVehicle ? _fbb.CreateString(idLaunchVehicle) : 0;
  auto idEngine__ = idEngine ? _fbb.CreateString(idEngine) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto manufacturerOrgId__ = manufacturerOrgId ? _fbb.CreateString(manufacturerOrgId) : 0;
  auto vernier__ = vernier ? _fbb.CreateString(vernier) : 0;
  auto controlThruster1__ = controlThruster1 ? _fbb.CreateString(controlThruster1) : 0;
  auto controlThruster2__ = controlThruster2 ? _fbb.CreateString(controlThruster2) : 0;
  auto photoURLs__ = photoURLs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*photoURLs) : 0;
  auto notes__ = notes ? _fbb.CreateString(notes) : 0;
  auto avionicsNotes__ = avionicsNotes ? _fbb.CreateString(avionicsNotes) : 0;
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tags) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto updatedAt__ = updatedAt ? _fbb.CreateString(updatedAt) : 0;
  auto updatedBy__ = updatedBy ? _fbb.CreateString(updatedBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto engine__ = engine ? _fbb.CreateString(engine) : 0;
  return CreateStage_Full(
      _fbb,
      id__,
      idLaunchVehicle__,
      idEngine__,
      classificationMarking__,
      stageNumber,
      type__,
      manufacturerOrgId__,
      numEngines,
      length,
      diameter,
      mass,
      vernier__,
      numVernier,
      mainEngineThrustSeaLevel,
      mainEngineThrustVacuum,
      thrustSeaLevel,
      thrustVacuum,
      burnTime,
      numBurns,
      vernierBurnTime,
      vernierNumBurns,
      vernierThrustSeaLevel,
      vernierThrustVacuum,
      numStageElements,
      reusable,
      restartable,
      controlThruster1__,
      numControlThruster1,
      controlThruster2__,
      numControlThruster2,
      photoURLs__,
      notes__,
      avionicsNotes__,
      tags__,
      createdAt__,
      createdBy__,
      updatedAt__,
      updatedBy__,
      source__,
      origin__,
      origNetwork__,
      dataMode,
      engine__);
}

inline const Stage_Full *GetStage_Full(const void *buf) {
  return ::flatbuffers::GetRoot<Stage_Full>(buf);
}

inline const Stage_Full *GetSizePrefixedStage_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Stage_Full>(buf);
}

inline const char *Stage_FullIdentifier() {
  return "STAG";
}

inline bool Stage_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Stage_FullIdentifier());
}

inline bool SizePrefixedStage_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Stage_FullIdentifier(), true);
}

inline bool VerifyStage_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Stage_Full>(Stage_FullIdentifier());
}

inline bool VerifySizePrefixedStage_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Stage_Full>(Stage_FullIdentifier());
}

inline void FinishStage_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Stage_Full> root) {
  fbb.Finish(root, Stage_FullIdentifier());
}

inline void FinishSizePrefixedStage_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Stage_Full> root) {
  fbb.FinishSizePrefixed(root, Stage_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
