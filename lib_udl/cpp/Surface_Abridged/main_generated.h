// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Surface_Abridged;
struct Surface_AbridgedBuilder;

enum Surface_Abridged_dataMode_Enum : int8_t {
  /// No description available.
  Surface_Abridged_dataMode_Enum_REAL = 0,
  /// No description available.
  Surface_Abridged_dataMode_Enum_TEST = 1,
  /// No description available.
  Surface_Abridged_dataMode_Enum_SIMULATED = 2,
  /// No description available.
  Surface_Abridged_dataMode_Enum_EXERCISE = 3,
  Surface_Abridged_dataMode_Enum_MIN = Surface_Abridged_dataMode_Enum_REAL,
  Surface_Abridged_dataMode_Enum_MAX = Surface_Abridged_dataMode_Enum_EXERCISE
};

inline const Surface_Abridged_dataMode_Enum (&EnumValuesSurface_Abridged_dataMode_Enum())[4] {
  static const Surface_Abridged_dataMode_Enum values[] = {
    Surface_Abridged_dataMode_Enum_REAL,
    Surface_Abridged_dataMode_Enum_TEST,
    Surface_Abridged_dataMode_Enum_SIMULATED,
    Surface_Abridged_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesSurface_Abridged_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSurface_Abridged_dataMode_Enum(Surface_Abridged_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, Surface_Abridged_dataMode_Enum_REAL, Surface_Abridged_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSurface_Abridged_dataMode_Enum()[index];
}

/// /// Surface information contains properties related to an airfield's runway, taxiway, and parking. The surface types and characteristics can dictate the airfield's capability of hosting a specific aircraft.
struct Surface_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Surface_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_NAME = 8,
    VT_TYPE = 10,
    VT_IDSITE = 12,
    VT_ALTSITEID = 14,
    VT_PRIMARY = 16,
    VT_LENGTHFT = 18,
    VT_LDAFT = 20,
    VT_WIDTHFT = 22,
    VT_LENGTHM = 24,
    VT_LDAM = 26,
    VT_WIDTHM = 28,
    VT_MATERIAL = 30,
    VT_CONDITION = 32,
    VT_RAWWBC = 34,
    VT_PCN = 36,
    VT_LCN = 38,
    VT_SWTKIP = 40,
    VT_TWTKIP = 42,
    VT_STWTKIP = 44,
    VT_TTWTKIP = 46,
    VT_DDWTKIP = 48,
    VT_SBTTWTKIP = 50,
    VT_TDTWTKIP = 52,
    VT_TRTWTKIP = 54,
    VT_DDTWTKIP = 56,
    VT_SWTKN = 58,
    VT_TWTKN = 60,
    VT_STWTKN = 62,
    VT_TTWTKN = 64,
    VT_DDWTKN = 66,
    VT_SBTTWTKN = 68,
    VT_TDTWTKN = 70,
    VT_TRTWTKN = 72,
    VT_DDTWTKN = 74,
    VT_LIGHTING = 76,
    VT_LIGHTSUNKN = 78,
    VT_LIGHTSAPRCH = 80,
    VT_LIGHTSVASI = 82,
    VT_LIGHTSPAPI = 84,
    VT_LIGHTSOLS = 86,
    VT_LIGHTSREIL = 88,
    VT_LIGHTSTDZL = 90,
    VT_LIGHTSCL = 92,
    VT_OBSTACLE = 94,
    VT_CREATEDAT = 96,
    VT_CREATEDBY = 98,
    VT_SOURCE = 100,
    VT_ORIGIN = 102,
    VT_ORIGNETWORK = 104,
    VT_DATAMODE = 106
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: be831d39-1822-da9f-7ace-6cc5643397dc
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The surface name or identifier.
  /// Example: /// Example: West lot
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// The surface type of this record (e.g. RUNWAY, TAXIWAY, PARKING).
  /// Example: /// Example: PARKING
  /// Constraints: Minimum length = 1, Maximum length = 7
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// The ID of the site where this surface is located.
  /// Example: /// Example: SITE-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSite() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSITE);
  }
  /// Alternate site identifier provided by the source.
  /// Example: /// Example: ORIG-SITE-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *altSiteId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALTSITEID);
  }
  /// Flag indicating this is the primary runway.  Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool primary() const {
    return GetField<uint8_t>(VT_PRIMARY, 0) != 0;
  }
  /// The length of the surface type, in feet.  Applicable for runway and parking surface types.
  /// Example: /// Example: 1500
  /// Constraints: No constraints specified.
  int32_t lengthFt() const {
    return GetField<int32_t>(VT_LENGTHFT, 0);
  }
  /// The landing distance available for the runway, in feet.  Applicable for runway surface types only.
  /// Example: /// Example: 475
  /// Constraints: No constraints specified.
  int32_t ldaFt() const {
    return GetField<int32_t>(VT_LDAFT, 0);
  }
  /// The width of the surface type, in feet.
  /// Example: /// Example: 220
  /// Constraints: No constraints specified.
  int32_t widthFt() const {
    return GetField<int32_t>(VT_WIDTHFT, 0);
  }
  /// The length of the surface type, in meters.  Applicable for runway and parking surface types.
  /// Example: /// Example: 457
  /// Constraints: No constraints specified.
  int32_t lengthM() const {
    return GetField<int32_t>(VT_LENGTHM, 0);
  }
  /// The landing distance available for the runway, in meters.  Applicable for runway surface types only.
  /// Example: /// Example: 145
  /// Constraints: No constraints specified.
  int32_t ldaM() const {
    return GetField<int32_t>(VT_LDAM, 0);
  }
  /// The width of the surface type, in meters.
  /// Example: /// Example: 67
  /// Constraints: No constraints specified.
  int32_t widthM() const {
    return GetField<int32_t>(VT_WIDTHM, 0);
  }
  /// The surface material (e.g. Asphalt, Concrete, Dirt).
  /// Example: /// Example: Concrete
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *material() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATERIAL);
  }
  /// The surface condition (e.g. GOOD, FAIR, POOR, SERIOUS, FAILED, CLOSED, UNKNOWN).
  /// Example: /// Example: GOOD
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *condition() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONDITION);
  }
  /// Raw weight bearing capacity value or pavement strength.
  /// Example: /// Example: LCN 42
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *rawWBC() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RAWWBC);
  }
  /// Pavement classification number (PCN) and tire pressure code.
  /// Example: /// Example: 73RBWT
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *pcn() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PCN);
  }
  /// Load classification number or pavement rating which ranks aircraft on a scale of 1 to 120.
  /// Example: /// Example: 50
  /// Constraints: No constraints specified.
  int32_t lcn() const {
    return GetField<int32_t>(VT_LCN, 0);
  }
  /// The max weight allowable on this surface type for an S-type (single) landing gear configuration, in kilopounds (kip). Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 143
  /// Constraints: No constraints specified.
  int32_t sWtKip() const {
    return GetField<int32_t>(VT_SWTKIP, 0);
  }
  /// The max weight allowable on this surface type for a T-type (twin (dual)) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 188
  /// Constraints: No constraints specified.
  int32_t tWtKip() const {
    return GetField<int32_t>(VT_TWTKIP, 0);
  }
  /// The max weight allowable on this surface type for an ST-type (single tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 195
  /// Constraints: No constraints specified.
  int32_t stWtKip() const {
    return GetField<int32_t>(VT_STWTKIP, 0);
  }
  /// The max weight allowable on this surface type for a GDSS TT-type (twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 414
  /// Constraints: No constraints specified.
  int32_t ttWtKip() const {
    return GetField<int32_t>(VT_TTWTKIP, 0);
  }
  /// The max weight allowable on this surface type for an FAA 2D-type (twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 416
  /// Constraints: No constraints specified.
  int32_t ddWtKip() const {
    return GetField<int32_t>(VT_DDWTKIP, 0);
  }
  /// The max weight allowable on this surface type for an SBTT-type (single belly twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 603
  /// Constraints: No constraints specified.
  int32_t sbttWtKip() const {
    return GetField<int32_t>(VT_SBTTWTKIP, 0);
  }
  /// The max weight allowable on this surface type for a TDT-type (twin delta tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 870
  /// Constraints: No constraints specified.
  int32_t tdtWtkip() const {
    return GetField<int32_t>(VT_TDTWTKIP, 0);
  }
  /// The max weight allowable on this surface type for a TRT-type (triple tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 622
  /// Constraints: No constraints specified.
  int32_t trtWtKip() const {
    return GetField<int32_t>(VT_TRTWTKIP, 0);
  }
  /// The max weight allowable on this surface type for a DDT-type (double dual tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 833
  /// Constraints: No constraints specified.
  int32_t ddtWtKip() const {
    return GetField<int32_t>(VT_DDTWTKIP, 0);
  }
  /// The max weight allowable on this surface type for an S-type (single) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 636
  /// Constraints: No constraints specified.
  int32_t sWtKN() const {
    return GetField<int32_t>(VT_SWTKN, 0);
  }
  /// The max weight allowable on this surface type for a T-type (twin (dual)) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 836
  /// Constraints: No constraints specified.
  int32_t tWtKN() const {
    return GetField<int32_t>(VT_TWTKN, 0);
  }
  /// The max weight allowable on this surface type for an ST-type (single tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 867
  /// Constraints: No constraints specified.
  int32_t stWtKN() const {
    return GetField<int32_t>(VT_STWTKN, 0);
  }
  /// The max weight allowable on this surface type for a GDSS TT-type (twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 1842
  /// Constraints: No constraints specified.
  int32_t ttWtKN() const {
    return GetField<int32_t>(VT_TTWTKN, 0);
  }
  /// The max weight allowable on this surface type for an FAA 2D-type (twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 1850
  /// Constraints: No constraints specified.
  int32_t ddWtKN() const {
    return GetField<int32_t>(VT_DDWTKN, 0);
  }
  /// The max weight allowable on this surface type for an SBTT-type (single belly twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 2682
  /// Constraints: No constraints specified.
  int32_t sbttWtKN() const {
    return GetField<int32_t>(VT_SBTTWTKN, 0);
  }
  /// The max weight allowable on this surface type for a TDT-type (twin delta tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 3870
  /// Constraints: No constraints specified.
  int32_t tdtWtKN() const {
    return GetField<int32_t>(VT_TDTWTKN, 0);
  }
  /// The max weight allowable on this surface type for a TRT-type (triple tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 2767
  /// Constraints: No constraints specified.
  int32_t trtWtKN() const {
    return GetField<int32_t>(VT_TRTWTKN, 0);
  }
  /// The max weight allowable on this surface type for a DDT-type (double dual tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
  /// Example: /// Example: 3705
  /// Constraints: No constraints specified.
  int32_t ddtWtKN() const {
    return GetField<int32_t>(VT_DDTWTKN, 0);
  }
  /// Flag indicating the surface has lighting.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool lighting() const {
    return GetField<uint8_t>(VT_LIGHTING, 0) != 0;
  }
  /// Flag indicating the runway lighting is unknown. Applicable for runway surface types only.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool lightsUNKN() const {
    return GetField<uint8_t>(VT_LIGHTSUNKN, 0) != 0;
  }
  /// Flag indicating the runway has approach lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool lightsAPRCH() const {
    return GetField<uint8_t>(VT_LIGHTSAPRCH, 0) != 0;
  }
  /// Flag indicating the runway has Visual Approach Slope Indicator (VASI) lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool lightsVASI() const {
    return GetField<uint8_t>(VT_LIGHTSVASI, 0) != 0;
  }
  /// Flag indicating the runway has Precision Approach Path Indicator (PAPI) lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool lightsPAPI() const {
    return GetField<uint8_t>(VT_LIGHTSPAPI, 0) != 0;
  }
  /// Flag indicating the runway has Optical Landing System (OLS) lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool lightsOLS() const {
    return GetField<uint8_t>(VT_LIGHTSOLS, 0) != 0;
  }
  /// Flag indicating the runway has Runway End Identifier Lights (REIL). Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool lightsREIL() const {
    return GetField<uint8_t>(VT_LIGHTSREIL, 0) != 0;
  }
  /// Flag indicating the runway has Touchdown Zone lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool lightsTDZL() const {
    return GetField<uint8_t>(VT_LIGHTSTDZL, 0) != 0;
  }
  /// Flag indicating the runway has centerline lights. Applicable for runway surface types only.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool lightsCL() const {
    return GetField<uint8_t>(VT_LIGHTSCL, 0) != 0;
  }
  /// Flag indicating the surface type has an obstacle. Applicable for taxiway and parking surface types.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool obstacle() const {
    return GetField<uint8_t>(VT_OBSTACLE, 0) != 0;
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  Surface_Abridged_dataMode_Enum dataMode() const {
    return static_cast<Surface_Abridged_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_IDSITE) &&
           verifier.VerifyString(idSite()) &&
           VerifyOffset(verifier, VT_ALTSITEID) &&
           verifier.VerifyString(altSiteId()) &&
           VerifyField<uint8_t>(verifier, VT_PRIMARY, 1) &&
           VerifyField<int32_t>(verifier, VT_LENGTHFT, 4) &&
           VerifyField<int32_t>(verifier, VT_LDAFT, 4) &&
           VerifyField<int32_t>(verifier, VT_WIDTHFT, 4) &&
           VerifyField<int32_t>(verifier, VT_LENGTHM, 4) &&
           VerifyField<int32_t>(verifier, VT_LDAM, 4) &&
           VerifyField<int32_t>(verifier, VT_WIDTHM, 4) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyString(material()) &&
           VerifyOffset(verifier, VT_CONDITION) &&
           verifier.VerifyString(condition()) &&
           VerifyOffset(verifier, VT_RAWWBC) &&
           verifier.VerifyString(rawWBC()) &&
           VerifyOffset(verifier, VT_PCN) &&
           verifier.VerifyString(pcn()) &&
           VerifyField<int32_t>(verifier, VT_LCN, 4) &&
           VerifyField<int32_t>(verifier, VT_SWTKIP, 4) &&
           VerifyField<int32_t>(verifier, VT_TWTKIP, 4) &&
           VerifyField<int32_t>(verifier, VT_STWTKIP, 4) &&
           VerifyField<int32_t>(verifier, VT_TTWTKIP, 4) &&
           VerifyField<int32_t>(verifier, VT_DDWTKIP, 4) &&
           VerifyField<int32_t>(verifier, VT_SBTTWTKIP, 4) &&
           VerifyField<int32_t>(verifier, VT_TDTWTKIP, 4) &&
           VerifyField<int32_t>(verifier, VT_TRTWTKIP, 4) &&
           VerifyField<int32_t>(verifier, VT_DDTWTKIP, 4) &&
           VerifyField<int32_t>(verifier, VT_SWTKN, 4) &&
           VerifyField<int32_t>(verifier, VT_TWTKN, 4) &&
           VerifyField<int32_t>(verifier, VT_STWTKN, 4) &&
           VerifyField<int32_t>(verifier, VT_TTWTKN, 4) &&
           VerifyField<int32_t>(verifier, VT_DDWTKN, 4) &&
           VerifyField<int32_t>(verifier, VT_SBTTWTKN, 4) &&
           VerifyField<int32_t>(verifier, VT_TDTWTKN, 4) &&
           VerifyField<int32_t>(verifier, VT_TRTWTKN, 4) &&
           VerifyField<int32_t>(verifier, VT_DDTWTKN, 4) &&
           VerifyField<uint8_t>(verifier, VT_LIGHTING, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIGHTSUNKN, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIGHTSAPRCH, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIGHTSVASI, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIGHTSPAPI, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIGHTSOLS, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIGHTSREIL, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIGHTSTDZL, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIGHTSCL, 1) &&
           VerifyField<uint8_t>(verifier, VT_OBSTACLE, 1) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           verifier.EndTable();
  }
};

struct Surface_AbridgedBuilder {
  typedef Surface_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Surface_Abridged::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(Surface_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Surface_Abridged::VT_NAME, name);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(Surface_Abridged::VT_TYPE, type);
  }
  void add_idSite(::flatbuffers::Offset<::flatbuffers::String> idSite) {
    fbb_.AddOffset(Surface_Abridged::VT_IDSITE, idSite);
  }
  void add_altSiteId(::flatbuffers::Offset<::flatbuffers::String> altSiteId) {
    fbb_.AddOffset(Surface_Abridged::VT_ALTSITEID, altSiteId);
  }
  void add_primary(bool primary) {
    fbb_.AddElement<uint8_t>(Surface_Abridged::VT_PRIMARY, static_cast<uint8_t>(primary), 0);
  }
  void add_lengthFt(int32_t lengthFt) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_LENGTHFT, lengthFt, 0);
  }
  void add_ldaFt(int32_t ldaFt) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_LDAFT, ldaFt, 0);
  }
  void add_widthFt(int32_t widthFt) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_WIDTHFT, widthFt, 0);
  }
  void add_lengthM(int32_t lengthM) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_LENGTHM, lengthM, 0);
  }
  void add_ldaM(int32_t ldaM) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_LDAM, ldaM, 0);
  }
  void add_widthM(int32_t widthM) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_WIDTHM, widthM, 0);
  }
  void add_material(::flatbuffers::Offset<::flatbuffers::String> material) {
    fbb_.AddOffset(Surface_Abridged::VT_MATERIAL, material);
  }
  void add_condition(::flatbuffers::Offset<::flatbuffers::String> condition) {
    fbb_.AddOffset(Surface_Abridged::VT_CONDITION, condition);
  }
  void add_rawWBC(::flatbuffers::Offset<::flatbuffers::String> rawWBC) {
    fbb_.AddOffset(Surface_Abridged::VT_RAWWBC, rawWBC);
  }
  void add_pcn(::flatbuffers::Offset<::flatbuffers::String> pcn) {
    fbb_.AddOffset(Surface_Abridged::VT_PCN, pcn);
  }
  void add_lcn(int32_t lcn) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_LCN, lcn, 0);
  }
  void add_sWtKip(int32_t sWtKip) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_SWTKIP, sWtKip, 0);
  }
  void add_tWtKip(int32_t tWtKip) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_TWTKIP, tWtKip, 0);
  }
  void add_stWtKip(int32_t stWtKip) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_STWTKIP, stWtKip, 0);
  }
  void add_ttWtKip(int32_t ttWtKip) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_TTWTKIP, ttWtKip, 0);
  }
  void add_ddWtKip(int32_t ddWtKip) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_DDWTKIP, ddWtKip, 0);
  }
  void add_sbttWtKip(int32_t sbttWtKip) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_SBTTWTKIP, sbttWtKip, 0);
  }
  void add_tdtWtkip(int32_t tdtWtkip) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_TDTWTKIP, tdtWtkip, 0);
  }
  void add_trtWtKip(int32_t trtWtKip) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_TRTWTKIP, trtWtKip, 0);
  }
  void add_ddtWtKip(int32_t ddtWtKip) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_DDTWTKIP, ddtWtKip, 0);
  }
  void add_sWtKN(int32_t sWtKN) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_SWTKN, sWtKN, 0);
  }
  void add_tWtKN(int32_t tWtKN) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_TWTKN, tWtKN, 0);
  }
  void add_stWtKN(int32_t stWtKN) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_STWTKN, stWtKN, 0);
  }
  void add_ttWtKN(int32_t ttWtKN) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_TTWTKN, ttWtKN, 0);
  }
  void add_ddWtKN(int32_t ddWtKN) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_DDWTKN, ddWtKN, 0);
  }
  void add_sbttWtKN(int32_t sbttWtKN) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_SBTTWTKN, sbttWtKN, 0);
  }
  void add_tdtWtKN(int32_t tdtWtKN) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_TDTWTKN, tdtWtKN, 0);
  }
  void add_trtWtKN(int32_t trtWtKN) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_TRTWTKN, trtWtKN, 0);
  }
  void add_ddtWtKN(int32_t ddtWtKN) {
    fbb_.AddElement<int32_t>(Surface_Abridged::VT_DDTWTKN, ddtWtKN, 0);
  }
  void add_lighting(bool lighting) {
    fbb_.AddElement<uint8_t>(Surface_Abridged::VT_LIGHTING, static_cast<uint8_t>(lighting), 0);
  }
  void add_lightsUNKN(bool lightsUNKN) {
    fbb_.AddElement<uint8_t>(Surface_Abridged::VT_LIGHTSUNKN, static_cast<uint8_t>(lightsUNKN), 0);
  }
  void add_lightsAPRCH(bool lightsAPRCH) {
    fbb_.AddElement<uint8_t>(Surface_Abridged::VT_LIGHTSAPRCH, static_cast<uint8_t>(lightsAPRCH), 0);
  }
  void add_lightsVASI(bool lightsVASI) {
    fbb_.AddElement<uint8_t>(Surface_Abridged::VT_LIGHTSVASI, static_cast<uint8_t>(lightsVASI), 0);
  }
  void add_lightsPAPI(bool lightsPAPI) {
    fbb_.AddElement<uint8_t>(Surface_Abridged::VT_LIGHTSPAPI, static_cast<uint8_t>(lightsPAPI), 0);
  }
  void add_lightsOLS(bool lightsOLS) {
    fbb_.AddElement<uint8_t>(Surface_Abridged::VT_LIGHTSOLS, static_cast<uint8_t>(lightsOLS), 0);
  }
  void add_lightsREIL(bool lightsREIL) {
    fbb_.AddElement<uint8_t>(Surface_Abridged::VT_LIGHTSREIL, static_cast<uint8_t>(lightsREIL), 0);
  }
  void add_lightsTDZL(bool lightsTDZL) {
    fbb_.AddElement<uint8_t>(Surface_Abridged::VT_LIGHTSTDZL, static_cast<uint8_t>(lightsTDZL), 0);
  }
  void add_lightsCL(bool lightsCL) {
    fbb_.AddElement<uint8_t>(Surface_Abridged::VT_LIGHTSCL, static_cast<uint8_t>(lightsCL), 0);
  }
  void add_obstacle(bool obstacle) {
    fbb_.AddElement<uint8_t>(Surface_Abridged::VT_OBSTACLE, static_cast<uint8_t>(obstacle), 0);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(Surface_Abridged::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(Surface_Abridged::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(Surface_Abridged::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(Surface_Abridged::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(Surface_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  void add_dataMode(Surface_Abridged_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(Surface_Abridged::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  explicit Surface_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Surface_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Surface_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Surface_Abridged> CreateSurface_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSite = 0,
    ::flatbuffers::Offset<::flatbuffers::String> altSiteId = 0,
    bool primary = false,
    int32_t lengthFt = 0,
    int32_t ldaFt = 0,
    int32_t widthFt = 0,
    int32_t lengthM = 0,
    int32_t ldaM = 0,
    int32_t widthM = 0,
    ::flatbuffers::Offset<::flatbuffers::String> material = 0,
    ::flatbuffers::Offset<::flatbuffers::String> condition = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rawWBC = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pcn = 0,
    int32_t lcn = 0,
    int32_t sWtKip = 0,
    int32_t tWtKip = 0,
    int32_t stWtKip = 0,
    int32_t ttWtKip = 0,
    int32_t ddWtKip = 0,
    int32_t sbttWtKip = 0,
    int32_t tdtWtkip = 0,
    int32_t trtWtKip = 0,
    int32_t ddtWtKip = 0,
    int32_t sWtKN = 0,
    int32_t tWtKN = 0,
    int32_t stWtKN = 0,
    int32_t ttWtKN = 0,
    int32_t ddWtKN = 0,
    int32_t sbttWtKN = 0,
    int32_t tdtWtKN = 0,
    int32_t trtWtKN = 0,
    int32_t ddtWtKN = 0,
    bool lighting = false,
    bool lightsUNKN = false,
    bool lightsAPRCH = false,
    bool lightsVASI = false,
    bool lightsPAPI = false,
    bool lightsOLS = false,
    bool lightsREIL = false,
    bool lightsTDZL = false,
    bool lightsCL = false,
    bool obstacle = false,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    Surface_Abridged_dataMode_Enum dataMode = Surface_Abridged_dataMode_Enum_REAL) {
  Surface_AbridgedBuilder builder_(_fbb);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_ddtWtKN(ddtWtKN);
  builder_.add_trtWtKN(trtWtKN);
  builder_.add_tdtWtKN(tdtWtKN);
  builder_.add_sbttWtKN(sbttWtKN);
  builder_.add_ddWtKN(ddWtKN);
  builder_.add_ttWtKN(ttWtKN);
  builder_.add_stWtKN(stWtKN);
  builder_.add_tWtKN(tWtKN);
  builder_.add_sWtKN(sWtKN);
  builder_.add_ddtWtKip(ddtWtKip);
  builder_.add_trtWtKip(trtWtKip);
  builder_.add_tdtWtkip(tdtWtkip);
  builder_.add_sbttWtKip(sbttWtKip);
  builder_.add_ddWtKip(ddWtKip);
  builder_.add_ttWtKip(ttWtKip);
  builder_.add_stWtKip(stWtKip);
  builder_.add_tWtKip(tWtKip);
  builder_.add_sWtKip(sWtKip);
  builder_.add_lcn(lcn);
  builder_.add_pcn(pcn);
  builder_.add_rawWBC(rawWBC);
  builder_.add_condition(condition);
  builder_.add_material(material);
  builder_.add_widthM(widthM);
  builder_.add_ldaM(ldaM);
  builder_.add_lengthM(lengthM);
  builder_.add_widthFt(widthFt);
  builder_.add_ldaFt(ldaFt);
  builder_.add_lengthFt(lengthFt);
  builder_.add_altSiteId(altSiteId);
  builder_.add_idSite(idSite);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_obstacle(obstacle);
  builder_.add_lightsCL(lightsCL);
  builder_.add_lightsTDZL(lightsTDZL);
  builder_.add_lightsREIL(lightsREIL);
  builder_.add_lightsOLS(lightsOLS);
  builder_.add_lightsPAPI(lightsPAPI);
  builder_.add_lightsVASI(lightsVASI);
  builder_.add_lightsAPRCH(lightsAPRCH);
  builder_.add_lightsUNKN(lightsUNKN);
  builder_.add_lighting(lighting);
  builder_.add_primary(primary);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Surface_Abridged> CreateSurface_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *name = nullptr,
    const char *type = nullptr,
    const char *idSite = nullptr,
    const char *altSiteId = nullptr,
    bool primary = false,
    int32_t lengthFt = 0,
    int32_t ldaFt = 0,
    int32_t widthFt = 0,
    int32_t lengthM = 0,
    int32_t ldaM = 0,
    int32_t widthM = 0,
    const char *material = nullptr,
    const char *condition = nullptr,
    const char *rawWBC = nullptr,
    const char *pcn = nullptr,
    int32_t lcn = 0,
    int32_t sWtKip = 0,
    int32_t tWtKip = 0,
    int32_t stWtKip = 0,
    int32_t ttWtKip = 0,
    int32_t ddWtKip = 0,
    int32_t sbttWtKip = 0,
    int32_t tdtWtkip = 0,
    int32_t trtWtKip = 0,
    int32_t ddtWtKip = 0,
    int32_t sWtKN = 0,
    int32_t tWtKN = 0,
    int32_t stWtKN = 0,
    int32_t ttWtKN = 0,
    int32_t ddWtKN = 0,
    int32_t sbttWtKN = 0,
    int32_t tdtWtKN = 0,
    int32_t trtWtKN = 0,
    int32_t ddtWtKN = 0,
    bool lighting = false,
    bool lightsUNKN = false,
    bool lightsAPRCH = false,
    bool lightsVASI = false,
    bool lightsPAPI = false,
    bool lightsOLS = false,
    bool lightsREIL = false,
    bool lightsTDZL = false,
    bool lightsCL = false,
    bool obstacle = false,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr,
    Surface_Abridged_dataMode_Enum dataMode = Surface_Abridged_dataMode_Enum_REAL) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto idSite__ = idSite ? _fbb.CreateString(idSite) : 0;
  auto altSiteId__ = altSiteId ? _fbb.CreateString(altSiteId) : 0;
  auto material__ = material ? _fbb.CreateString(material) : 0;
  auto condition__ = condition ? _fbb.CreateString(condition) : 0;
  auto rawWBC__ = rawWBC ? _fbb.CreateString(rawWBC) : 0;
  auto pcn__ = pcn ? _fbb.CreateString(pcn) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateSurface_Abridged(
      _fbb,
      id__,
      classificationMarking__,
      name__,
      type__,
      idSite__,
      altSiteId__,
      primary,
      lengthFt,
      ldaFt,
      widthFt,
      lengthM,
      ldaM,
      widthM,
      material__,
      condition__,
      rawWBC__,
      pcn__,
      lcn,
      sWtKip,
      tWtKip,
      stWtKip,
      ttWtKip,
      ddWtKip,
      sbttWtKip,
      tdtWtkip,
      trtWtKip,
      ddtWtKip,
      sWtKN,
      tWtKN,
      stWtKN,
      ttWtKN,
      ddWtKN,
      sbttWtKN,
      tdtWtKN,
      trtWtKN,
      ddtWtKN,
      lighting,
      lightsUNKN,
      lightsAPRCH,
      lightsVASI,
      lightsPAPI,
      lightsOLS,
      lightsREIL,
      lightsTDZL,
      lightsCL,
      obstacle,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      origNetwork__,
      dataMode);
}

inline const Surface_Abridged *GetSurface_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<Surface_Abridged>(buf);
}

inline const Surface_Abridged *GetSizePrefixedSurface_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Surface_Abridged>(buf);
}

inline const char *Surface_AbridgedIdentifier() {
  return "SURF";
}

inline bool Surface_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Surface_AbridgedIdentifier());
}

inline bool SizePrefixedSurface_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Surface_AbridgedIdentifier(), true);
}

inline bool VerifySurface_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Surface_Abridged>(Surface_AbridgedIdentifier());
}

inline bool VerifySizePrefixedSurface_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Surface_Abridged>(Surface_AbridgedIdentifier());
}

inline void FinishSurface_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Surface_Abridged> root) {
  fbb.Finish(root, Surface_AbridgedIdentifier());
}

inline void FinishSizePrefixedSurface_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Surface_Abridged> root) {
  fbb.FinishSizePrefixed(root, Surface_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
