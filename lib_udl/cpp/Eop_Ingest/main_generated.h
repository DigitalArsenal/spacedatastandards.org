// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Eop_Ingest;
struct Eop_IngestBuilder;

enum Eop_Ingest_polarMotionState_Enum : int8_t {
  /// No description available.
  Eop_Ingest_polarMotionState_Enum_I = 0,
  /// No description available.
  Eop_Ingest_polarMotionState_Enum_P = 1,
  Eop_Ingest_polarMotionState_Enum_MIN = Eop_Ingest_polarMotionState_Enum_I,
  Eop_Ingest_polarMotionState_Enum_MAX = Eop_Ingest_polarMotionState_Enum_P
};

inline const Eop_Ingest_polarMotionState_Enum (&EnumValuesEop_Ingest_polarMotionState_Enum())[2] {
  static const Eop_Ingest_polarMotionState_Enum values[] = {
    Eop_Ingest_polarMotionState_Enum_I,
    Eop_Ingest_polarMotionState_Enum_P
  };
  return values;
}

inline const char * const *EnumNamesEop_Ingest_polarMotionState_Enum() {
  static const char * const names[3] = {
    "I",
    "P",
    nullptr
  };
  return names;
}

inline const char *EnumNameEop_Ingest_polarMotionState_Enum(Eop_Ingest_polarMotionState_Enum e) {
  if (::flatbuffers::IsOutRange(e, Eop_Ingest_polarMotionState_Enum_I, Eop_Ingest_polarMotionState_Enum_P)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEop_Ingest_polarMotionState_Enum()[index];
}

enum Eop_Ingest_ut1UTCState_Enum : int8_t {
  /// No description available.
  Eop_Ingest_ut1UTCState_Enum_I = 0,
  /// No description available.
  Eop_Ingest_ut1UTCState_Enum_P = 1,
  Eop_Ingest_ut1UTCState_Enum_MIN = Eop_Ingest_ut1UTCState_Enum_I,
  Eop_Ingest_ut1UTCState_Enum_MAX = Eop_Ingest_ut1UTCState_Enum_P
};

inline const Eop_Ingest_ut1UTCState_Enum (&EnumValuesEop_Ingest_ut1UTCState_Enum())[2] {
  static const Eop_Ingest_ut1UTCState_Enum values[] = {
    Eop_Ingest_ut1UTCState_Enum_I,
    Eop_Ingest_ut1UTCState_Enum_P
  };
  return values;
}

inline const char * const *EnumNamesEop_Ingest_ut1UTCState_Enum() {
  static const char * const names[3] = {
    "I",
    "P",
    nullptr
  };
  return names;
}

inline const char *EnumNameEop_Ingest_ut1UTCState_Enum(Eop_Ingest_ut1UTCState_Enum e) {
  if (::flatbuffers::IsOutRange(e, Eop_Ingest_ut1UTCState_Enum_I, Eop_Ingest_ut1UTCState_Enum_P)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEop_Ingest_ut1UTCState_Enum()[index];
}

enum Eop_Ingest_nutationState_Enum : int8_t {
  /// No description available.
  Eop_Ingest_nutationState_Enum_I = 0,
  /// No description available.
  Eop_Ingest_nutationState_Enum_P = 1,
  Eop_Ingest_nutationState_Enum_MIN = Eop_Ingest_nutationState_Enum_I,
  Eop_Ingest_nutationState_Enum_MAX = Eop_Ingest_nutationState_Enum_P
};

inline const Eop_Ingest_nutationState_Enum (&EnumValuesEop_Ingest_nutationState_Enum())[2] {
  static const Eop_Ingest_nutationState_Enum values[] = {
    Eop_Ingest_nutationState_Enum_I,
    Eop_Ingest_nutationState_Enum_P
  };
  return values;
}

inline const char * const *EnumNamesEop_Ingest_nutationState_Enum() {
  static const char * const names[3] = {
    "I",
    "P",
    nullptr
  };
  return names;
}

inline const char *EnumNameEop_Ingest_nutationState_Enum(Eop_Ingest_nutationState_Enum e) {
  if (::flatbuffers::IsOutRange(e, Eop_Ingest_nutationState_Enum_I, Eop_Ingest_nutationState_Enum_P)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEop_Ingest_nutationState_Enum()[index];
}

enum Eop_Ingest_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  Eop_Ingest_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  Eop_Ingest_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  Eop_Ingest_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  Eop_Ingest_dataMode_Enum_EXERCISE = 3,
  Eop_Ingest_dataMode_Enum_MIN = Eop_Ingest_dataMode_Enum_REAL,
  Eop_Ingest_dataMode_Enum_MAX = Eop_Ingest_dataMode_Enum_EXERCISE
};

inline const Eop_Ingest_dataMode_Enum (&EnumValuesEop_Ingest_dataMode_Enum())[4] {
  static const Eop_Ingest_dataMode_Enum values[] = {
    Eop_Ingest_dataMode_Enum_REAL,
    Eop_Ingest_dataMode_Enum_TEST,
    Eop_Ingest_dataMode_Enum_SIMULATED,
    Eop_Ingest_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesEop_Ingest_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameEop_Ingest_dataMode_Enum(Eop_Ingest_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, Eop_Ingest_dataMode_Enum_REAL, Eop_Ingest_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEop_Ingest_dataMode_Enum()[index];
}

/// /// Model representation of Earth Orientation Parameters (EOP) produced by the IERS (International Earth Rotation and Reference Systems Service). Earth Orientation Parameters describe the irregularities of the earth's rotation. Technically, they are the parameters which provide the rotation of the ITRS (International Terrestrial Reference System) to the ICRS (International Celestial Reference System) as a function of time.
/// Universal time -- Universal time (UT1) is the time of the earth clock, which performs one revolution in about 24h. It is practically proportional to the sidereal time. The excess revolution time is called length of day (LOD).
/// Coordinates of the pole -- x and y are the coordinates of the Celestial Ephemeris Pole (CEP) relative to the IRP, the IERS Reference Pole. The CEP differs from the instantaneous rotation axis by quasi-diurnal terms with amplitudes under 0.01" (see Seidelmann, 1982). The x-axis is in the direction of the ITRF zero-meridian; the y-axis is in the direction 90 degrees West longitude.
/// Celestial pole offsets -- Celestial pole offsets are described in the IAU Precession and Nutation models. The observed differences with respect to the conventional celestial pole position defined by the models are monitored and reported by the IERS.
/// IERS Bulletins A and B provide current information on the Earth's orientation in the IERS Reference System.  This includes Universal Time, coordinates of the terrestrial pole, and celestial pole offsets.  Bulletin A gives an advanced solution updated weekly; the standard solution is given monthly in Bulletin B. Fields suffixed with 'B' are Bulletin B values. All solutions are continuous within their respective uncertainties.  Bulletin A is issued by the IERS Rapid Service/Prediction Centre at the U.S. Naval Observatory, Washington, DC and Bulletin B is issued by the IERS Earth Orientation Centre at the Paris Observatory. IERS Bulletin A reports the latest determinations for polar motion, UT1-UTC, and nutation offsets at daily intervals based on a combination of contributed analysis results using data from Very Long Baseline Interferometry (VLBI), Satellite Laser Ranging (SLR), Global Positioning System (GPS) satellites, and Lunar Laser Ranging (LLR). Predictions for variations a year into the future are also provided. Meteorological predictions of variations in Atmospheric Angular Momentum (AAM) are used to aid in the prediction of near-term UT1-UTC changes. This publication is prepared by the IERS Rapid Service/Prediction Center.
struct Eop_Ingest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Eop_IngestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_EOPDATE = 8,
    VT_POLARMOTIONSTATE = 10,
    VT_POLARMOTIONX = 12,
    VT_POLARMOTIONXUNC = 14,
    VT_POLARMOTIONY = 16,
    VT_POLARMOTIONYUNC = 18,
    VT_UT1UTCSTATE = 20,
    VT_UT1UTC = 22,
    VT_UT1UTCUNC = 24,
    VT_LOD = 26,
    VT_LODUNC = 28,
    VT_NUTATIONSTATE = 30,
    VT_DPSI = 32,
    VT_DPSIUNC = 34,
    VT_DEPSILON = 36,
    VT_DEPSILONUNC = 38,
    VT_DX = 40,
    VT_DXUNC = 42,
    VT_DY = 44,
    VT_DYUNC = 46,
    VT_POLARMOTIONXB = 48,
    VT_POLARMOTIONYB = 50,
    VT_UT1UTCB = 52,
    VT_DPSIB = 54,
    VT_DEPSILONB = 56,
    VT_DXB = 58,
    VT_DYB = 60,
    VT_PRECESSIONNUTATIONSTD = 62,
    VT_RAWFILEURI = 64,
    VT_SOURCE = 66,
    VT_ORIGIN = 68,
    VT_DATAMODE = 70,
    VT_CREATEDAT = 72,
    VT_CREATEDBY = 74,
    VT_ORIGNETWORK = 76
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: EOP-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Effective date/time for the EOP values in ISO8601 UTC format.  The values could be current or predicted.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *eopDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EOPDATE);
  }
  /// Flag indicating Issued (I), or Predicted (P) for this record's polar motion values.
  /// Example: /// Example: I
  /// Constraints: Minimum length = 0, Maximum length = 1
  Eop_Ingest_polarMotionState_Enum polarMotionState() const {
    return static_cast<Eop_Ingest_polarMotionState_Enum>(GetField<int8_t>(VT_POLARMOTIONSTATE, 0));
  }
  /// The Bulletin A X coordinate value of earth polar motion at eopDate. Polar motion of the Earth is the motion of the Earth's rotational axis relative to its crust. This is measured with respect to a reference frame in which the solid Earth is fixed (a so-called Earth-centered, Earth-fixed or ECEF reference frame). Measured in arc seconds.
  /// Example: /// Example: 0.182987
  /// Constraints: No constraints specified.
  double polarMotionX() const {
    return GetField<double>(VT_POLARMOTIONX, 0.0);
  }
  /// Estimated uncertainty/error in polarMotionX value in arc seconds.
  /// Example: /// Example: 0.000672
  /// Constraints: No constraints specified.
  double polarMotionXUnc() const {
    return GetField<double>(VT_POLARMOTIONXUNC, 0.0);
  }
  /// The Bulletin A Y coordinate value of earth polar motion at eopDate. Polar motion of the Earth is the motion of the Earth's rotational axis relative to its crust. This is measured with respect to a reference frame in which the solid Earth is fixed (a so-called Earth-centered, Earth-fixed or ECEF reference frame). Measured in arc seconds.
  /// Example: /// Example: 0.168775
  /// Constraints: No constraints specified.
  double polarMotionY() const {
    return GetField<double>(VT_POLARMOTIONY, 0.0);
  }
  /// Estimated uncertainty/error in polarMotionY value in arc seconds.
  /// Example: /// Example: 0.000345
  /// Constraints: No constraints specified.
  double polarMotionYUnc() const {
    return GetField<double>(VT_POLARMOTIONYUNC, 0.0);
  }
  /// Flag indicating Issued (I), or Predicted (P) for this record''s Bulletin A UT1-UTC values.
  /// Example: /// Example: I
  /// Constraints: Minimum length = 0, Maximum length = 1
  Eop_Ingest_ut1UTCState_Enum ut1UTCState() const {
    return static_cast<Eop_Ingest_ut1UTCState_Enum>(GetField<int8_t>(VT_UT1UTCSTATE, 0));
  }
  /// The difference between the Bulletin A UT1 and UTC time scales as of eopDate in seconds.
  /// Example: /// Example: -0.1251659
  /// Constraints: No constraints specified.
  double ut1UTC() const {
    return GetField<double>(VT_UT1UTC, 0.0);
  }
  /// The estimated uncertainty/error in the ut1UTC value in seconds.
  /// Example: /// Example: 2.07e-05
  /// Constraints: No constraints specified.
  double ut1UTCUnc() const {
    return GetField<double>(VT_UT1UTCUNC, 0.0);
  }
  /// Bulletin A length of day or LOD in milliseconds. Universal time (UT1) is the time of the earth clock, which performs one revolution in about 24h. It is practically proportional to the sidereal time. The excess revolution time is called length of day (LOD).
  /// Example: /// Example: 1.8335
  /// Constraints: No constraints specified.
  double lod() const {
    return GetField<double>(VT_LOD, 0.0);
  }
  /// The estimated uncertainty/error in the lod value in seconds.
  /// Example: /// Example: 0.0201
  /// Constraints: No constraints specified.
  double lodUnc() const {
    return GetField<double>(VT_LODUNC, 0.0);
  }
  /// Flag indicating Issued (I), or Predicted (P) for this record's nutation values (dPSI and dEpsilon).
  /// Example: /// Example: I
  /// Constraints: Minimum length = 0, Maximum length = 1
  Eop_Ingest_nutationState_Enum nutationState() const {
    return static_cast<Eop_Ingest_nutationState_Enum>(GetField<int8_t>(VT_NUTATIONSTATE, 0));
  }
  /// The Bulletin A offset in longitude dDy1980 with respect to the IAU 1976 Theory of Precession and the IAU 1980 Theory of Nutation, measured in milliseconds of arc. Note: dPSI is not used when this record represents IAU 2000 data.
  /// Example: /// Example: -10.437
  /// Constraints: No constraints specified.
  double dPSI() const {
    return GetField<double>(VT_DPSI, 0.0);
  }
  /// The estimated uncertainty/error in the dPSI value in milliseconds of arc.
  /// Example: /// Example: 0.507
  /// Constraints: No constraints specified.
  double dPSIUnc() const {
    return GetField<double>(VT_DPSIUNC, 0.0);
  }
  /// The Bulletin A offset in obliquity dDe1980 with respect to the IAU 1976 Theory of Precession and the IAU 1980 Theory of Nutation, measured in milliseconds of arc. Note: dEpsilon is not used when this record represents IAU 2000 data.
  /// Example: /// Example: -0.917
  /// Constraints: No constraints specified.
  double dEpsilon() const {
    return GetField<double>(VT_DEPSILON, 0.0);
  }
  /// The estimated uncertainty/error in the dEpsilon value in milliseconds of arc.
  /// Example: /// Example: 0.165
  /// Constraints: No constraints specified.
  double dEpsilonUnc() const {
    return GetField<double>(VT_DEPSILONUNC, 0.0);
  }
  /// The Bulletin A celestial pole offset along x-axis with respect to the IAU 2000A Theory of Precession and Nutation, measured in milliseconds of arc. Note: dX is not used when this record represents IAU 1980 data.
  /// Example: /// Example: -0.086
  /// Constraints: No constraints specified.
  double dX() const {
    return GetField<double>(VT_DX, 0.0);
  }
  /// The estimated uncertainty/error in the Bulletin A dX value, in milliseconds of arc.
  /// Example: /// Example: 0.202
  /// Constraints: No constraints specified.
  double dXUnc() const {
    return GetField<double>(VT_DXUNC, 0.0);
  }
  /// The Bulletin A celestial pole offset along y-axis with respect to the IAU 2000A Theory of Precession and Nutation, measured in milliseconds of arc. Note: dY is not used when this record represents IAU 1980 data.
  /// Example: /// Example: 0.13
  /// Constraints: No constraints specified.
  double dY() const {
    return GetField<double>(VT_DY, 0.0);
  }
  /// The estimated uncertainty/error in the Bulletin A dY value, in milliseconds of arc.
  /// Example: /// Example: 0.165
  /// Constraints: No constraints specified.
  double dYUnc() const {
    return GetField<double>(VT_DYUNC, 0.0);
  }
  /// Bulletin B X coordinate value of earth polar motion at eopDate. Polar motion of the Earth is the motion of the Earth's rotational axis relative to its crust. This is measured with respect to a reference frame in which the solid Earth is fixed (a so-called Earth-centered, Earth-fixed or ECEF reference frame). Measured in arc seconds.
  /// Example: /// Example: 0.1824
  /// Constraints: No constraints specified.
  double polarMotionXB() const {
    return GetField<double>(VT_POLARMOTIONXB, 0.0);
  }
  /// Bulletin B Y coordinate value of earth polar motion at eopDate. Polar motion of the Earth is the motion of the Earth's rotational axis relative to its crust. This is measured with respect to a reference frame in which the solid Earth is fixed (a so-called Earth-centered, Earth-fixed or ECEF reference frame). Measured in arc seconds.
  /// Example: /// Example: 0.1679
  /// Constraints: No constraints specified.
  double polarMotionYB() const {
    return GetField<double>(VT_POLARMOTIONYB, 0.0);
  }
  /// The Bulletin B difference between the UT1 and UTC time scales as of eopDate in seconds.
  /// Example: /// Example: -0.1253
  /// Constraints: No constraints specified.
  double ut1UTCB() const {
    return GetField<double>(VT_UT1UTCB, 0.0);
  }
  /// The Bulletin B offset in longitude dDy1980 with respect to the IAU 1976 Theory of Precession and the IAU 1980 Theory of Nutation, measured in milliseconds of arc. Note: dPSIB is not used when this record represents IAU 2000 data.
  /// Example: /// Example: -9.9
  /// Constraints: No constraints specified.
  double dPSIB() const {
    return GetField<double>(VT_DPSIB, 0.0);
  }
  /// The Bulletin B offset in obliquity dDe1980 with respect to the IAU 1976 Theory of Precession and the IAU 1980 Theory of Nutation, measured in milliseconds of arc. Note: dEpsilonB is not used when this record represents IAU 2000 data.
  /// Example: /// Example: -1.7
  /// Constraints: No constraints specified.
  double dEpsilonB() const {
    return GetField<double>(VT_DEPSILONB, 0.0);
  }
  /// The Bulletin B celestial pole offset along the X-axis with respect to the IAU 2000A Theory of Precession and Nutation, measured in milliseconds of arc. Note: dXB is not used when this record represents IAU 1980 data.
  /// Example: /// Example: 0.129
  /// Constraints: No constraints specified.
  double dXB() const {
    return GetField<double>(VT_DXB, 0.0);
  }
  /// The Bulletin B celestial pole offset along the Y-axis with respect to the IAU 2000A Theory of Precession and Nutation, measured in milliseconds of arc. Note: dYB is not used when this record represents IAU 1980 data.
  /// Example: /// Example: -0.653
  /// Constraints: No constraints specified.
  double dYB() const {
    return GetField<double>(VT_DYB, 0.0);
  }
  /// The IAU Theory of Precession and Theory of Nutation applied to the data in this record. IAU1980 records employ the IAU 1976 Theory of Precession and IAU 1980 Theory of Nutation, and IAU2000 records employ the IAU 2000A Theory of Precession and Nutation.
  /// Example: /// Example: IAU1980
  /// Constraints: Minimum length = 0, Maximum length = 10
  const ::flatbuffers::String *precessionNutationStd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRECESSIONNUTATIONSTD);
  }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  /// Example: /// Example: Example URI
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *rawFileURI() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RAWFILEURI);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  Eop_Ingest_dataMode_Enum dataMode() const {
    return static_cast<Eop_Ingest_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_EOPDATE) &&
           verifier.VerifyString(eopDate()) &&
           VerifyField<int8_t>(verifier, VT_POLARMOTIONSTATE, 1) &&
           VerifyField<double>(verifier, VT_POLARMOTIONX, 8) &&
           VerifyField<double>(verifier, VT_POLARMOTIONXUNC, 8) &&
           VerifyField<double>(verifier, VT_POLARMOTIONY, 8) &&
           VerifyField<double>(verifier, VT_POLARMOTIONYUNC, 8) &&
           VerifyField<int8_t>(verifier, VT_UT1UTCSTATE, 1) &&
           VerifyField<double>(verifier, VT_UT1UTC, 8) &&
           VerifyField<double>(verifier, VT_UT1UTCUNC, 8) &&
           VerifyField<double>(verifier, VT_LOD, 8) &&
           VerifyField<double>(verifier, VT_LODUNC, 8) &&
           VerifyField<int8_t>(verifier, VT_NUTATIONSTATE, 1) &&
           VerifyField<double>(verifier, VT_DPSI, 8) &&
           VerifyField<double>(verifier, VT_DPSIUNC, 8) &&
           VerifyField<double>(verifier, VT_DEPSILON, 8) &&
           VerifyField<double>(verifier, VT_DEPSILONUNC, 8) &&
           VerifyField<double>(verifier, VT_DX, 8) &&
           VerifyField<double>(verifier, VT_DXUNC, 8) &&
           VerifyField<double>(verifier, VT_DY, 8) &&
           VerifyField<double>(verifier, VT_DYUNC, 8) &&
           VerifyField<double>(verifier, VT_POLARMOTIONXB, 8) &&
           VerifyField<double>(verifier, VT_POLARMOTIONYB, 8) &&
           VerifyField<double>(verifier, VT_UT1UTCB, 8) &&
           VerifyField<double>(verifier, VT_DPSIB, 8) &&
           VerifyField<double>(verifier, VT_DEPSILONB, 8) &&
           VerifyField<double>(verifier, VT_DXB, 8) &&
           VerifyField<double>(verifier, VT_DYB, 8) &&
           VerifyOffset(verifier, VT_PRECESSIONNUTATIONSTD) &&
           verifier.VerifyString(precessionNutationStd()) &&
           VerifyOffset(verifier, VT_RAWFILEURI) &&
           verifier.VerifyString(rawFileURI()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct Eop_IngestBuilder {
  typedef Eop_Ingest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Eop_Ingest::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(Eop_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_eopDate(::flatbuffers::Offset<::flatbuffers::String> eopDate) {
    fbb_.AddOffset(Eop_Ingest::VT_EOPDATE, eopDate);
  }
  void add_polarMotionState(Eop_Ingest_polarMotionState_Enum polarMotionState) {
    fbb_.AddElement<int8_t>(Eop_Ingest::VT_POLARMOTIONSTATE, static_cast<int8_t>(polarMotionState), 0);
  }
  void add_polarMotionX(double polarMotionX) {
    fbb_.AddElement<double>(Eop_Ingest::VT_POLARMOTIONX, polarMotionX, 0.0);
  }
  void add_polarMotionXUnc(double polarMotionXUnc) {
    fbb_.AddElement<double>(Eop_Ingest::VT_POLARMOTIONXUNC, polarMotionXUnc, 0.0);
  }
  void add_polarMotionY(double polarMotionY) {
    fbb_.AddElement<double>(Eop_Ingest::VT_POLARMOTIONY, polarMotionY, 0.0);
  }
  void add_polarMotionYUnc(double polarMotionYUnc) {
    fbb_.AddElement<double>(Eop_Ingest::VT_POLARMOTIONYUNC, polarMotionYUnc, 0.0);
  }
  void add_ut1UTCState(Eop_Ingest_ut1UTCState_Enum ut1UTCState) {
    fbb_.AddElement<int8_t>(Eop_Ingest::VT_UT1UTCSTATE, static_cast<int8_t>(ut1UTCState), 0);
  }
  void add_ut1UTC(double ut1UTC) {
    fbb_.AddElement<double>(Eop_Ingest::VT_UT1UTC, ut1UTC, 0.0);
  }
  void add_ut1UTCUnc(double ut1UTCUnc) {
    fbb_.AddElement<double>(Eop_Ingest::VT_UT1UTCUNC, ut1UTCUnc, 0.0);
  }
  void add_lod(double lod) {
    fbb_.AddElement<double>(Eop_Ingest::VT_LOD, lod, 0.0);
  }
  void add_lodUnc(double lodUnc) {
    fbb_.AddElement<double>(Eop_Ingest::VT_LODUNC, lodUnc, 0.0);
  }
  void add_nutationState(Eop_Ingest_nutationState_Enum nutationState) {
    fbb_.AddElement<int8_t>(Eop_Ingest::VT_NUTATIONSTATE, static_cast<int8_t>(nutationState), 0);
  }
  void add_dPSI(double dPSI) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DPSI, dPSI, 0.0);
  }
  void add_dPSIUnc(double dPSIUnc) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DPSIUNC, dPSIUnc, 0.0);
  }
  void add_dEpsilon(double dEpsilon) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DEPSILON, dEpsilon, 0.0);
  }
  void add_dEpsilonUnc(double dEpsilonUnc) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DEPSILONUNC, dEpsilonUnc, 0.0);
  }
  void add_dX(double dX) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DX, dX, 0.0);
  }
  void add_dXUnc(double dXUnc) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DXUNC, dXUnc, 0.0);
  }
  void add_dY(double dY) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DY, dY, 0.0);
  }
  void add_dYUnc(double dYUnc) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DYUNC, dYUnc, 0.0);
  }
  void add_polarMotionXB(double polarMotionXB) {
    fbb_.AddElement<double>(Eop_Ingest::VT_POLARMOTIONXB, polarMotionXB, 0.0);
  }
  void add_polarMotionYB(double polarMotionYB) {
    fbb_.AddElement<double>(Eop_Ingest::VT_POLARMOTIONYB, polarMotionYB, 0.0);
  }
  void add_ut1UTCB(double ut1UTCB) {
    fbb_.AddElement<double>(Eop_Ingest::VT_UT1UTCB, ut1UTCB, 0.0);
  }
  void add_dPSIB(double dPSIB) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DPSIB, dPSIB, 0.0);
  }
  void add_dEpsilonB(double dEpsilonB) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DEPSILONB, dEpsilonB, 0.0);
  }
  void add_dXB(double dXB) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DXB, dXB, 0.0);
  }
  void add_dYB(double dYB) {
    fbb_.AddElement<double>(Eop_Ingest::VT_DYB, dYB, 0.0);
  }
  void add_precessionNutationStd(::flatbuffers::Offset<::flatbuffers::String> precessionNutationStd) {
    fbb_.AddOffset(Eop_Ingest::VT_PRECESSIONNUTATIONSTD, precessionNutationStd);
  }
  void add_rawFileURI(::flatbuffers::Offset<::flatbuffers::String> rawFileURI) {
    fbb_.AddOffset(Eop_Ingest::VT_RAWFILEURI, rawFileURI);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(Eop_Ingest::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(Eop_Ingest::VT_ORIGIN, origin);
  }
  void add_dataMode(Eop_Ingest_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(Eop_Ingest::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(Eop_Ingest::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(Eop_Ingest::VT_CREATEDBY, createdBy);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(Eop_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  explicit Eop_IngestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Eop_Ingest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Eop_Ingest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Eop_Ingest> CreateEop_Ingest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> eopDate = 0,
    Eop_Ingest_polarMotionState_Enum polarMotionState = Eop_Ingest_polarMotionState_Enum_I,
    double polarMotionX = 0.0,
    double polarMotionXUnc = 0.0,
    double polarMotionY = 0.0,
    double polarMotionYUnc = 0.0,
    Eop_Ingest_ut1UTCState_Enum ut1UTCState = Eop_Ingest_ut1UTCState_Enum_I,
    double ut1UTC = 0.0,
    double ut1UTCUnc = 0.0,
    double lod = 0.0,
    double lodUnc = 0.0,
    Eop_Ingest_nutationState_Enum nutationState = Eop_Ingest_nutationState_Enum_I,
    double dPSI = 0.0,
    double dPSIUnc = 0.0,
    double dEpsilon = 0.0,
    double dEpsilonUnc = 0.0,
    double dX = 0.0,
    double dXUnc = 0.0,
    double dY = 0.0,
    double dYUnc = 0.0,
    double polarMotionXB = 0.0,
    double polarMotionYB = 0.0,
    double ut1UTCB = 0.0,
    double dPSIB = 0.0,
    double dEpsilonB = 0.0,
    double dXB = 0.0,
    double dYB = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> precessionNutationStd = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rawFileURI = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    Eop_Ingest_dataMode_Enum dataMode = Eop_Ingest_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  Eop_IngestBuilder builder_(_fbb);
  builder_.add_dYB(dYB);
  builder_.add_dXB(dXB);
  builder_.add_dEpsilonB(dEpsilonB);
  builder_.add_dPSIB(dPSIB);
  builder_.add_ut1UTCB(ut1UTCB);
  builder_.add_polarMotionYB(polarMotionYB);
  builder_.add_polarMotionXB(polarMotionXB);
  builder_.add_dYUnc(dYUnc);
  builder_.add_dY(dY);
  builder_.add_dXUnc(dXUnc);
  builder_.add_dX(dX);
  builder_.add_dEpsilonUnc(dEpsilonUnc);
  builder_.add_dEpsilon(dEpsilon);
  builder_.add_dPSIUnc(dPSIUnc);
  builder_.add_dPSI(dPSI);
  builder_.add_lodUnc(lodUnc);
  builder_.add_lod(lod);
  builder_.add_ut1UTCUnc(ut1UTCUnc);
  builder_.add_ut1UTC(ut1UTC);
  builder_.add_polarMotionYUnc(polarMotionYUnc);
  builder_.add_polarMotionY(polarMotionY);
  builder_.add_polarMotionXUnc(polarMotionXUnc);
  builder_.add_polarMotionX(polarMotionX);
  builder_.add_origNetwork(origNetwork);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_rawFileURI(rawFileURI);
  builder_.add_precessionNutationStd(precessionNutationStd);
  builder_.add_eopDate(eopDate);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_nutationState(nutationState);
  builder_.add_ut1UTCState(ut1UTCState);
  builder_.add_polarMotionState(polarMotionState);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Eop_Ingest> CreateEop_IngestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *eopDate = nullptr,
    Eop_Ingest_polarMotionState_Enum polarMotionState = Eop_Ingest_polarMotionState_Enum_I,
    double polarMotionX = 0.0,
    double polarMotionXUnc = 0.0,
    double polarMotionY = 0.0,
    double polarMotionYUnc = 0.0,
    Eop_Ingest_ut1UTCState_Enum ut1UTCState = Eop_Ingest_ut1UTCState_Enum_I,
    double ut1UTC = 0.0,
    double ut1UTCUnc = 0.0,
    double lod = 0.0,
    double lodUnc = 0.0,
    Eop_Ingest_nutationState_Enum nutationState = Eop_Ingest_nutationState_Enum_I,
    double dPSI = 0.0,
    double dPSIUnc = 0.0,
    double dEpsilon = 0.0,
    double dEpsilonUnc = 0.0,
    double dX = 0.0,
    double dXUnc = 0.0,
    double dY = 0.0,
    double dYUnc = 0.0,
    double polarMotionXB = 0.0,
    double polarMotionYB = 0.0,
    double ut1UTCB = 0.0,
    double dPSIB = 0.0,
    double dEpsilonB = 0.0,
    double dXB = 0.0,
    double dYB = 0.0,
    const char *precessionNutationStd = nullptr,
    const char *rawFileURI = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    Eop_Ingest_dataMode_Enum dataMode = Eop_Ingest_dataMode_Enum_REAL,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *origNetwork = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto eopDate__ = eopDate ? _fbb.CreateString(eopDate) : 0;
  auto precessionNutationStd__ = precessionNutationStd ? _fbb.CreateString(precessionNutationStd) : 0;
  auto rawFileURI__ = rawFileURI ? _fbb.CreateString(rawFileURI) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateEop_Ingest(
      _fbb,
      id__,
      classificationMarking__,
      eopDate__,
      polarMotionState,
      polarMotionX,
      polarMotionXUnc,
      polarMotionY,
      polarMotionYUnc,
      ut1UTCState,
      ut1UTC,
      ut1UTCUnc,
      lod,
      lodUnc,
      nutationState,
      dPSI,
      dPSIUnc,
      dEpsilon,
      dEpsilonUnc,
      dX,
      dXUnc,
      dY,
      dYUnc,
      polarMotionXB,
      polarMotionYB,
      ut1UTCB,
      dPSIB,
      dEpsilonB,
      dXB,
      dYB,
      precessionNutationStd__,
      rawFileURI__,
      source__,
      origin__,
      dataMode,
      createdAt__,
      createdBy__,
      origNetwork__);
}

inline const Eop_Ingest *GetEop_Ingest(const void *buf) {
  return ::flatbuffers::GetRoot<Eop_Ingest>(buf);
}

inline const Eop_Ingest *GetSizePrefixedEop_Ingest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Eop_Ingest>(buf);
}

inline const char *Eop_IngestIdentifier() {
  return "EOPI";
}

inline bool Eop_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Eop_IngestIdentifier());
}

inline bool SizePrefixedEop_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Eop_IngestIdentifier(), true);
}

inline bool VerifyEop_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Eop_Ingest>(Eop_IngestIdentifier());
}

inline bool VerifySizePrefixedEop_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Eop_Ingest>(Eop_IngestIdentifier());
}

inline void FinishEop_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Eop_Ingest> root) {
  fbb.Finish(root, Eop_IngestIdentifier());
}

inline void FinishSizePrefixedEop_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Eop_Ingest> root) {
  fbb.FinishSizePrefixed(root, Eop_IngestIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
